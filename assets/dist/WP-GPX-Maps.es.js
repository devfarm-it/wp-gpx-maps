var xM = Object.defineProperty;
var vM = (m, a, d) => a in m ? xM(m, a, { enumerable: !0, configurable: !0, writable: !0, value: d }) : m[a] = d;
var Yt = (m, a, d) => (vM(m, typeof a != "symbol" ? a + "" : a, d), d);
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Gf(m) {
  return m + 0.5 | 0;
}
const Ic = (m, a, d) => Math.max(Math.min(m, d), a);
function wf(m) {
  return Ic(Gf(m * 2.55), 0, 255);
}
function kc(m) {
  return Ic(Gf(m * 255), 0, 255);
}
function Fl(m) {
  return Ic(Gf(m / 2.55) / 100, 0, 1);
}
function $v(m) {
  return Ic(Gf(m * 100), 0, 100);
}
const sa = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Gg = [..."0123456789ABCDEF"], bM = (m) => Gg[m & 15], wM = (m) => Gg[(m & 240) >> 4] + Gg[m & 15], um = (m) => (m & 240) >> 4 === (m & 15), TM = (m) => um(m.r) && um(m.g) && um(m.b) && um(m.a);
function MM(m) {
  var a = m.length, d;
  return m[0] === "#" && (a === 4 || a === 5 ? d = {
    r: 255 & sa[m[1]] * 17,
    g: 255 & sa[m[2]] * 17,
    b: 255 & sa[m[3]] * 17,
    a: a === 5 ? sa[m[4]] * 17 : 255
  } : (a === 7 || a === 9) && (d = {
    r: sa[m[1]] << 4 | sa[m[2]],
    g: sa[m[3]] << 4 | sa[m[4]],
    b: sa[m[5]] << 4 | sa[m[6]],
    a: a === 9 ? sa[m[7]] << 4 | sa[m[8]] : 255
  })), d;
}
const SM = (m, a) => m < 255 ? a(m) : "";
function EM(m) {
  var a = TM(m) ? bM : wM;
  return m ? "#" + a(m.r) + a(m.g) + a(m.b) + SM(m.a, a) : void 0;
}
const AM = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function bb(m, a, d) {
  const g = a * Math.min(d, 1 - d), w = (b, E = (b + m / 30) % 12) => d - g * Math.max(Math.min(E - 3, 9 - E, 1), -1);
  return [w(0), w(8), w(4)];
}
function PM(m, a, d) {
  const g = (w, b = (w + m / 60) % 6) => d - d * a * Math.max(Math.min(b, 4 - b, 1), 0);
  return [g(5), g(3), g(1)];
}
function CM(m, a, d) {
  const g = bb(m, 1, 0.5);
  let w;
  for (a + d > 1 && (w = 1 / (a + d), a *= w, d *= w), w = 0; w < 3; w++)
    g[w] *= 1 - a - d, g[w] += a;
  return g;
}
function IM(m, a, d, g, w) {
  return m === w ? (a - d) / g + (a < d ? 6 : 0) : a === w ? (d - m) / g + 2 : (m - a) / g + 4;
}
function ay(m) {
  const d = m.r / 255, g = m.g / 255, w = m.b / 255, b = Math.max(d, g, w), E = Math.min(d, g, w), i = (b + E) / 2;
  let O, j, Y;
  return b !== E && (Y = b - E, j = i > 0.5 ? Y / (2 - b - E) : Y / (b + E), O = IM(d, g, w, Y, b), O = O * 60 + 0.5), [O | 0, j || 0, i];
}
function ly(m, a, d, g) {
  return (Array.isArray(a) ? m(a[0], a[1], a[2]) : m(a, d, g)).map(kc);
}
function cy(m, a, d) {
  return ly(bb, m, a, d);
}
function LM(m, a, d) {
  return ly(CM, m, a, d);
}
function zM(m, a, d) {
  return ly(PM, m, a, d);
}
function wb(m) {
  return (m % 360 + 360) % 360;
}
function DM(m) {
  const a = AM.exec(m);
  let d = 255, g;
  if (!a)
    return;
  a[5] !== g && (d = a[6] ? wf(+a[5]) : kc(+a[5]));
  const w = wb(+a[2]), b = +a[3] / 100, E = +a[4] / 100;
  return a[1] === "hwb" ? g = LM(w, b, E) : a[1] === "hsv" ? g = zM(w, b, E) : g = cy(w, b, E), {
    r: g[0],
    g: g[1],
    b: g[2],
    a: d
  };
}
function kM(m, a) {
  var d = ay(m);
  d[0] = wb(d[0] + a), d = cy(d), m.r = d[0], m.g = d[1], m.b = d[2];
}
function RM(m) {
  if (!m)
    return;
  const a = ay(m), d = a[0], g = $v(a[1]), w = $v(a[2]);
  return m.a < 255 ? `hsla(${d}, ${g}%, ${w}%, ${Fl(m.a)})` : `hsl(${d}, ${g}%, ${w}%)`;
}
const Xv = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Yv = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function OM() {
  const m = {}, a = Object.keys(Yv), d = Object.keys(Xv);
  let g, w, b, E, i;
  for (g = 0; g < a.length; g++) {
    for (E = i = a[g], w = 0; w < d.length; w++)
      b = d[w], i = i.replace(b, Xv[b]);
    b = parseInt(Yv[E], 16), m[i] = [b >> 16 & 255, b >> 8 & 255, b & 255];
  }
  return m;
}
let dm;
function FM(m) {
  dm || (dm = OM(), dm.transparent = [0, 0, 0, 0]);
  const a = dm[m.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const BM = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function NM(m) {
  const a = BM.exec(m);
  let d = 255, g, w, b;
  if (a) {
    if (a[7] !== g) {
      const E = +a[7];
      d = a[8] ? wf(E) : Ic(E * 255, 0, 255);
    }
    return g = +a[1], w = +a[3], b = +a[5], g = 255 & (a[2] ? wf(g) : Ic(g, 0, 255)), w = 255 & (a[4] ? wf(w) : Ic(w, 0, 255)), b = 255 & (a[6] ? wf(b) : Ic(b, 0, 255)), {
      r: g,
      g: w,
      b,
      a: d
    };
  }
}
function VM(m) {
  return m && (m.a < 255 ? `rgba(${m.r}, ${m.g}, ${m.b}, ${Fl(m.a)})` : `rgb(${m.r}, ${m.g}, ${m.b})`);
}
const Ig = (m) => m <= 31308e-7 ? m * 12.92 : Math.pow(m, 1 / 2.4) * 1.055 - 0.055, qu = (m) => m <= 0.04045 ? m / 12.92 : Math.pow((m + 0.055) / 1.055, 2.4);
function UM(m, a, d) {
  const g = qu(Fl(m.r)), w = qu(Fl(m.g)), b = qu(Fl(m.b));
  return {
    r: kc(Ig(g + d * (qu(Fl(a.r)) - g))),
    g: kc(Ig(w + d * (qu(Fl(a.g)) - w))),
    b: kc(Ig(b + d * (qu(Fl(a.b)) - b))),
    a: m.a + d * (a.a - m.a)
  };
}
function fm(m, a, d) {
  if (m) {
    let g = ay(m);
    g[a] = Math.max(0, Math.min(g[a] + g[a] * d, a === 0 ? 360 : 1)), g = cy(g), m.r = g[0], m.g = g[1], m.b = g[2];
  }
}
function Tb(m, a) {
  return m && Object.assign(a || {}, m);
}
function Kv(m) {
  var a = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(m) ? m.length >= 3 && (a = { r: m[0], g: m[1], b: m[2], a: 255 }, m.length > 3 && (a.a = kc(m[3]))) : (a = Tb(m, { r: 0, g: 0, b: 0, a: 1 }), a.a = kc(a.a)), a;
}
function jM(m) {
  return m.charAt(0) === "r" ? NM(m) : DM(m);
}
class kf {
  constructor(a) {
    if (a instanceof kf)
      return a;
    const d = typeof a;
    let g;
    d === "object" ? g = Kv(a) : d === "string" && (g = MM(a) || FM(a) || jM(a)), this._rgb = g, this._valid = !!g;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var a = Tb(this._rgb);
    return a && (a.a = Fl(a.a)), a;
  }
  set rgb(a) {
    this._rgb = Kv(a);
  }
  rgbString() {
    return this._valid ? VM(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? EM(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? RM(this._rgb) : void 0;
  }
  mix(a, d) {
    if (a) {
      const g = this.rgb, w = a.rgb;
      let b;
      const E = d === b ? 0.5 : d, i = 2 * E - 1, O = g.a - w.a, j = ((i * O === -1 ? i : (i + O) / (1 + i * O)) + 1) / 2;
      b = 1 - j, g.r = 255 & j * g.r + b * w.r + 0.5, g.g = 255 & j * g.g + b * w.g + 0.5, g.b = 255 & j * g.b + b * w.b + 0.5, g.a = E * g.a + (1 - E) * w.a, this.rgb = g;
    }
    return this;
  }
  interpolate(a, d) {
    return a && (this._rgb = UM(this._rgb, a._rgb, d)), this;
  }
  clone() {
    return new kf(this.rgb);
  }
  alpha(a) {
    return this._rgb.a = kc(a), this;
  }
  clearer(a) {
    const d = this._rgb;
    return d.a *= 1 - a, this;
  }
  greyscale() {
    const a = this._rgb, d = Gf(a.r * 0.3 + a.g * 0.59 + a.b * 0.11);
    return a.r = a.g = a.b = d, this;
  }
  opaquer(a) {
    const d = this._rgb;
    return d.a *= 1 + a, this;
  }
  negate() {
    const a = this._rgb;
    return a.r = 255 - a.r, a.g = 255 - a.g, a.b = 255 - a.b, this;
  }
  lighten(a) {
    return fm(this._rgb, 2, a), this;
  }
  darken(a) {
    return fm(this._rgb, 2, -a), this;
  }
  saturate(a) {
    return fm(this._rgb, 1, a), this;
  }
  desaturate(a) {
    return fm(this._rgb, 1, -a), this;
  }
  rotate(a) {
    return kM(this._rgb, a), this;
  }
}
/*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function kl() {
}
const GM = (() => {
  let m = 0;
  return () => m++;
})();
function En(m) {
  return m == null;
}
function hs(m) {
  if (Array.isArray && Array.isArray(m))
    return !0;
  const a = Object.prototype.toString.call(m);
  return a.slice(0, 7) === "[object" && a.slice(-6) === "Array]";
}
function yn(m) {
  return m !== null && Object.prototype.toString.call(m) === "[object Object]";
}
function Ps(m) {
  return (typeof m == "number" || m instanceof Number) && isFinite(+m);
}
function Bo(m, a) {
  return Ps(m) ? m : a;
}
function en(m, a) {
  return typeof m > "u" ? a : m;
}
const ZM = (m, a) => typeof m == "string" && m.endsWith("%") ? parseFloat(m) / 100 : +m / a, Mb = (m, a) => typeof m == "string" && m.endsWith("%") ? parseFloat(m) / 100 * a : +m;
function is(m, a, d) {
  if (m && typeof m.call == "function")
    return m.apply(d, a);
}
function Zn(m, a, d, g) {
  let w, b, E;
  if (hs(m))
    if (b = m.length, g)
      for (w = b - 1; w >= 0; w--)
        a.call(d, m[w], w);
    else
      for (w = 0; w < b; w++)
        a.call(d, m[w], w);
  else if (yn(m))
    for (E = Object.keys(m), b = E.length, w = 0; w < b; w++)
      a.call(d, m[E[w]], E[w]);
}
function Om(m, a) {
  let d, g, w, b;
  if (!m || !a || m.length !== a.length)
    return !1;
  for (d = 0, g = m.length; d < g; ++d)
    if (w = m[d], b = a[d], w.datasetIndex !== b.datasetIndex || w.index !== b.index)
      return !1;
  return !0;
}
function Fm(m) {
  if (hs(m))
    return m.map(Fm);
  if (yn(m)) {
    const a = /* @__PURE__ */ Object.create(null), d = Object.keys(m), g = d.length;
    let w = 0;
    for (; w < g; ++w)
      a[d[w]] = Fm(m[d[w]]);
    return a;
  }
  return m;
}
function Sb(m) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(m) === -1;
}
function HM(m, a, d, g) {
  if (!Sb(m))
    return;
  const w = a[m], b = d[m];
  yn(w) && yn(b) ? Rf(w, b, g) : a[m] = Fm(b);
}
function Rf(m, a, d) {
  const g = hs(a) ? a : [
    a
  ], w = g.length;
  if (!yn(m))
    return m;
  d = d || {};
  const b = d.merger || HM;
  let E;
  for (let i = 0; i < w; ++i) {
    if (E = g[i], !yn(E))
      continue;
    const O = Object.keys(E);
    for (let j = 0, Y = O.length; j < Y; ++j)
      b(O[j], m, E, d);
  }
  return m;
}
function Cf(m, a) {
  return Rf(m, a, {
    merger: qM
  });
}
function qM(m, a, d) {
  if (!Sb(m))
    return;
  const g = a[m], w = d[m];
  yn(g) && yn(w) ? Cf(g, w) : Object.prototype.hasOwnProperty.call(a, m) || (a[m] = Fm(w));
}
const Jv = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (m) => m,
  // default resolvers
  x: (m) => m.x,
  y: (m) => m.y
};
function WM(m) {
  const a = m.split("."), d = [];
  let g = "";
  for (const w of a)
    g += w, g.endsWith("\\") ? g = g.slice(0, -1) + "." : (d.push(g), g = "");
  return d;
}
function $M(m) {
  const a = WM(m);
  return (d) => {
    for (const g of a) {
      if (g === "")
        break;
      d = d && d[g];
    }
    return d;
  };
}
function Rc(m, a) {
  return (Jv[a] || (Jv[a] = $M(a)))(m);
}
function hy(m) {
  return m.charAt(0).toUpperCase() + m.slice(1);
}
const Of = (m) => typeof m < "u", Oc = (m) => typeof m == "function", Qv = (m, a) => {
  if (m.size !== a.size)
    return !1;
  for (const d of m)
    if (!a.has(d))
      return !1;
  return !0;
};
function XM(m) {
  return m.type === "mouseup" || m.type === "click" || m.type === "contextmenu";
}
const ds = Math.PI, us = 2 * ds, YM = us + ds, Bm = Number.POSITIVE_INFINITY, KM = ds / 180, Ns = ds / 2, Ah = ds / 4, e1 = ds * 2 / 3, Lc = Math.log10, ll = Math.sign;
function If(m, a, d) {
  return Math.abs(m - a) < d;
}
function t1(m) {
  const a = Math.round(m);
  m = If(m, a, m / 1e3) ? a : m;
  const d = Math.pow(10, Math.floor(Lc(m))), g = m / d;
  return (g <= 1 ? 1 : g <= 2 ? 2 : g <= 5 ? 5 : 10) * d;
}
function JM(m) {
  const a = [], d = Math.sqrt(m);
  let g;
  for (g = 1; g < d; g++)
    m % g === 0 && (a.push(g), a.push(m / g));
  return d === (d | 0) && a.push(d), a.sort((w, b) => w - b).pop(), a;
}
function Xu(m) {
  return !isNaN(parseFloat(m)) && isFinite(m);
}
function QM(m, a) {
  const d = Math.round(m);
  return d - a <= m && d + a >= m;
}
function Eb(m, a, d) {
  let g, w, b;
  for (g = 0, w = m.length; g < w; g++)
    b = m[g][d], isNaN(b) || (a.min = Math.min(a.min, b), a.max = Math.max(a.max, b));
}
function Ia(m) {
  return m * (ds / 180);
}
function uy(m) {
  return m * (180 / ds);
}
function i1(m) {
  if (!Ps(m))
    return;
  let a = 1, d = 0;
  for (; Math.round(m * a) / a !== m; )
    a *= 10, d++;
  return d;
}
function Ab(m, a) {
  const d = a.x - m.x, g = a.y - m.y, w = Math.sqrt(d * d + g * g);
  let b = Math.atan2(g, d);
  return b < -0.5 * ds && (b += us), {
    angle: b,
    distance: w
  };
}
function Zg(m, a) {
  return Math.sqrt(Math.pow(a.x - m.x, 2) + Math.pow(a.y - m.y, 2));
}
function eS(m, a) {
  return (m - a + YM) % us - ds;
}
function No(m) {
  return (m % us + us) % us;
}
function Ff(m, a, d, g) {
  const w = No(m), b = No(a), E = No(d), i = No(b - w), O = No(E - w), j = No(w - b), Y = No(w - E);
  return w === b || w === E || g && b === E || i > O && j < Y;
}
function gr(m, a, d) {
  return Math.max(a, Math.min(d, m));
}
function tS(m) {
  return gr(m, -32768, 32767);
}
function Nl(m, a, d, g = 1e-6) {
  return m >= Math.min(a, d) - g && m <= Math.max(a, d) + g;
}
function dy(m, a, d) {
  d = d || ((E) => m[E] < a);
  let g = m.length - 1, w = 0, b;
  for (; g - w > 1; )
    b = w + g >> 1, d(b) ? w = b : g = b;
  return {
    lo: w,
    hi: g
  };
}
const Vl = (m, a, d, g) => dy(m, d, g ? (w) => {
  const b = m[w][a];
  return b < d || b === d && m[w + 1][a] === d;
} : (w) => m[w][a] < d), iS = (m, a, d) => dy(m, d, (g) => m[g][a] >= d);
function nS(m, a, d) {
  let g = 0, w = m.length;
  for (; g < w && m[g] < a; )
    g++;
  for (; w > g && m[w - 1] > d; )
    w--;
  return g > 0 || w < m.length ? m.slice(g, w) : m;
}
const Pb = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function sS(m, a) {
  if (m._chartjs) {
    m._chartjs.listeners.push(a);
    return;
  }
  Object.defineProperty(m, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        a
      ]
    }
  }), Pb.forEach((d) => {
    const g = "_onData" + hy(d), w = m[d];
    Object.defineProperty(m, d, {
      configurable: !0,
      enumerable: !1,
      value(...b) {
        const E = w.apply(this, b);
        return m._chartjs.listeners.forEach((i) => {
          typeof i[g] == "function" && i[g](...b);
        }), E;
      }
    });
  });
}
function n1(m, a) {
  const d = m._chartjs;
  if (!d)
    return;
  const g = d.listeners, w = g.indexOf(a);
  w !== -1 && g.splice(w, 1), !(g.length > 0) && (Pb.forEach((b) => {
    delete m[b];
  }), delete m._chartjs);
}
function Cb(m) {
  const a = new Set(m);
  return a.size === m.length ? m : Array.from(a);
}
const Ib = function() {
  return typeof window > "u" ? function(m) {
    return m();
  } : window.requestAnimationFrame;
}();
function Lb(m, a) {
  let d = [], g = !1;
  return function(...w) {
    d = w, g || (g = !0, Ib.call(window, () => {
      g = !1, m.apply(a, d);
    }));
  };
}
function rS(m, a) {
  let d;
  return function(...g) {
    return a ? (clearTimeout(d), d = setTimeout(m, a, g)) : m.apply(this, g), a;
  };
}
const fy = (m) => m === "start" ? "left" : m === "end" ? "right" : "center", Ur = (m, a, d) => m === "start" ? a : m === "end" ? d : (a + d) / 2, oS = (m, a, d, g) => m === (g ? "left" : "right") ? d : m === "center" ? (a + d) / 2 : a;
function zb(m, a, d) {
  const g = a.length;
  let w = 0, b = g;
  if (m._sorted) {
    const { iScale: E, _parsed: i } = m, O = E.axis, { min: j, max: Y, minDefined: J, maxDefined: ae } = E.getUserBounds();
    J && (w = gr(Math.min(
      // @ts-expect-error Need to type _parsed
      Vl(i, O, j).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      d ? g : Vl(a, O, E.getPixelForValue(j)).lo
    ), 0, g - 1)), ae ? b = gr(Math.max(
      // @ts-expect-error Need to type _parsed
      Vl(i, E.axis, Y, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      d ? 0 : Vl(a, O, E.getPixelForValue(Y), !0).hi + 1
    ), w, g) - w : b = g - w;
  }
  return {
    start: w,
    count: b
  };
}
function Db(m) {
  const { xScale: a, yScale: d, _scaleRanges: g } = m, w = {
    xmin: a.min,
    xmax: a.max,
    ymin: d.min,
    ymax: d.max
  };
  if (!g)
    return m._scaleRanges = w, !0;
  const b = g.xmin !== a.min || g.xmax !== a.max || g.ymin !== d.min || g.ymax !== d.max;
  return Object.assign(g, w), b;
}
const pm = (m) => m === 0 || m === 1, s1 = (m, a, d) => -(Math.pow(2, 10 * (m -= 1)) * Math.sin((m - a) * us / d)), r1 = (m, a, d) => Math.pow(2, -10 * m) * Math.sin((m - a) * us / d) + 1, Lf = {
  linear: (m) => m,
  easeInQuad: (m) => m * m,
  easeOutQuad: (m) => -m * (m - 2),
  easeInOutQuad: (m) => (m /= 0.5) < 1 ? 0.5 * m * m : -0.5 * (--m * (m - 2) - 1),
  easeInCubic: (m) => m * m * m,
  easeOutCubic: (m) => (m -= 1) * m * m + 1,
  easeInOutCubic: (m) => (m /= 0.5) < 1 ? 0.5 * m * m * m : 0.5 * ((m -= 2) * m * m + 2),
  easeInQuart: (m) => m * m * m * m,
  easeOutQuart: (m) => -((m -= 1) * m * m * m - 1),
  easeInOutQuart: (m) => (m /= 0.5) < 1 ? 0.5 * m * m * m * m : -0.5 * ((m -= 2) * m * m * m - 2),
  easeInQuint: (m) => m * m * m * m * m,
  easeOutQuint: (m) => (m -= 1) * m * m * m * m + 1,
  easeInOutQuint: (m) => (m /= 0.5) < 1 ? 0.5 * m * m * m * m * m : 0.5 * ((m -= 2) * m * m * m * m + 2),
  easeInSine: (m) => -Math.cos(m * Ns) + 1,
  easeOutSine: (m) => Math.sin(m * Ns),
  easeInOutSine: (m) => -0.5 * (Math.cos(ds * m) - 1),
  easeInExpo: (m) => m === 0 ? 0 : Math.pow(2, 10 * (m - 1)),
  easeOutExpo: (m) => m === 1 ? 1 : -Math.pow(2, -10 * m) + 1,
  easeInOutExpo: (m) => pm(m) ? m : m < 0.5 ? 0.5 * Math.pow(2, 10 * (m * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (m * 2 - 1)) + 2),
  easeInCirc: (m) => m >= 1 ? m : -(Math.sqrt(1 - m * m) - 1),
  easeOutCirc: (m) => Math.sqrt(1 - (m -= 1) * m),
  easeInOutCirc: (m) => (m /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - m * m) - 1) : 0.5 * (Math.sqrt(1 - (m -= 2) * m) + 1),
  easeInElastic: (m) => pm(m) ? m : s1(m, 0.075, 0.3),
  easeOutElastic: (m) => pm(m) ? m : r1(m, 0.075, 0.3),
  easeInOutElastic(m) {
    return pm(m) ? m : m < 0.5 ? 0.5 * s1(m * 2, 0.1125, 0.45) : 0.5 + 0.5 * r1(m * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(m) {
    return m * m * ((1.70158 + 1) * m - 1.70158);
  },
  easeOutBack(m) {
    return (m -= 1) * m * ((1.70158 + 1) * m + 1.70158) + 1;
  },
  easeInOutBack(m) {
    let a = 1.70158;
    return (m /= 0.5) < 1 ? 0.5 * (m * m * (((a *= 1.525) + 1) * m - a)) : 0.5 * ((m -= 2) * m * (((a *= 1.525) + 1) * m + a) + 2);
  },
  easeInBounce: (m) => 1 - Lf.easeOutBounce(1 - m),
  easeOutBounce(m) {
    return m < 1 / 2.75 ? 7.5625 * m * m : m < 2 / 2.75 ? 7.5625 * (m -= 1.5 / 2.75) * m + 0.75 : m < 2.5 / 2.75 ? 7.5625 * (m -= 2.25 / 2.75) * m + 0.9375 : 7.5625 * (m -= 2.625 / 2.75) * m + 0.984375;
  },
  easeInOutBounce: (m) => m < 0.5 ? Lf.easeInBounce(m * 2) * 0.5 : Lf.easeOutBounce(m * 2 - 1) * 0.5 + 0.5
};
function py(m) {
  if (m && typeof m == "object") {
    const a = m.toString();
    return a === "[object CanvasPattern]" || a === "[object CanvasGradient]";
  }
  return !1;
}
function o1(m) {
  return py(m) ? m : new kf(m);
}
function Lg(m) {
  return py(m) ? m : new kf(m).saturate(0.5).darken(0.1).hexString();
}
const aS = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], lS = [
  "color",
  "borderColor",
  "backgroundColor"
];
function cS(m) {
  m.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), m.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (a) => a !== "onProgress" && a !== "onComplete" && a !== "fn"
  }), m.set("animations", {
    colors: {
      type: "color",
      properties: lS
    },
    numbers: {
      type: "number",
      properties: aS
    }
  }), m.describe("animations", {
    _fallback: "animation"
  }), m.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (a) => a | 0
        }
      }
    }
  });
}
function hS(m) {
  m.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const a1 = /* @__PURE__ */ new Map();
function uS(m, a) {
  a = a || {};
  const d = m + JSON.stringify(a);
  let g = a1.get(d);
  return g || (g = new Intl.NumberFormat(m, a), a1.set(d, g)), g;
}
function Zf(m, a, d) {
  return uS(a, d).format(m);
}
const kb = {
  values(m) {
    return hs(m) ? m : "" + m;
  },
  numeric(m, a, d) {
    if (m === 0)
      return "0";
    const g = this.chart.options.locale;
    let w, b = m;
    if (d.length > 1) {
      const j = Math.max(Math.abs(d[0].value), Math.abs(d[d.length - 1].value));
      (j < 1e-4 || j > 1e15) && (w = "scientific"), b = dS(m, d);
    }
    const E = Lc(Math.abs(b)), i = isNaN(E) ? 1 : Math.max(Math.min(-1 * Math.floor(E), 20), 0), O = {
      notation: w,
      minimumFractionDigits: i,
      maximumFractionDigits: i
    };
    return Object.assign(O, this.options.ticks.format), Zf(m, g, O);
  },
  logarithmic(m, a, d) {
    if (m === 0)
      return "0";
    const g = d[a].significand || m / Math.pow(10, Math.floor(Lc(m)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(g) || a > 0.8 * d.length ? kb.numeric.call(this, m, a, d) : "";
  }
};
function dS(m, a) {
  let d = a.length > 3 ? a[2].value - a[1].value : a[1].value - a[0].value;
  return Math.abs(d) >= 1 && m !== Math.floor(m) && (d = m - Math.floor(m)), d;
}
var qm = {
  formatters: kb
};
function fS(m) {
  m.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (a, d) => d.lineWidth,
      tickColor: (a, d) => d.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: qm.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), m.route("scale.ticks", "color", "", "color"), m.route("scale.grid", "color", "", "borderColor"), m.route("scale.border", "color", "", "borderColor"), m.route("scale.title", "color", "", "color"), m.describe("scale", {
    _fallback: !1,
    _scriptable: (a) => !a.startsWith("before") && !a.startsWith("after") && a !== "callback" && a !== "parser",
    _indexable: (a) => a !== "borderDash" && a !== "tickBorderDash" && a !== "dash"
  }), m.describe("scales", {
    _fallback: "scale"
  }), m.describe("scale.ticks", {
    _scriptable: (a) => a !== "backdropPadding" && a !== "callback",
    _indexable: (a) => a !== "backdropPadding"
  });
}
const Oh = /* @__PURE__ */ Object.create(null), Hg = /* @__PURE__ */ Object.create(null);
function zf(m, a) {
  if (!a)
    return m;
  const d = a.split(".");
  for (let g = 0, w = d.length; g < w; ++g) {
    const b = d[g];
    m = m[b] || (m[b] = /* @__PURE__ */ Object.create(null));
  }
  return m;
}
function zg(m, a, d) {
  return typeof a == "string" ? Rf(zf(m, a), d) : Rf(zf(m, ""), a);
}
class pS {
  constructor(a, d) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (g) => g.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (g, w) => Lg(w.backgroundColor), this.hoverBorderColor = (g, w) => Lg(w.borderColor), this.hoverColor = (g, w) => Lg(w.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(a), this.apply(d);
  }
  set(a, d) {
    return zg(this, a, d);
  }
  get(a) {
    return zf(this, a);
  }
  describe(a, d) {
    return zg(Hg, a, d);
  }
  override(a, d) {
    return zg(Oh, a, d);
  }
  route(a, d, g, w) {
    const b = zf(this, a), E = zf(this, g), i = "_" + d;
    Object.defineProperties(b, {
      [i]: {
        value: b[d],
        writable: !0
      },
      [d]: {
        enumerable: !0,
        get() {
          const O = this[i], j = E[w];
          return yn(O) ? Object.assign({}, j, O) : en(O, j);
        },
        set(O) {
          this[i] = O;
        }
      }
    });
  }
  apply(a) {
    a.forEach((d) => d(this));
  }
}
var ys = /* @__PURE__ */ new pS({
  _scriptable: (m) => !m.startsWith("on"),
  _indexable: (m) => m !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  cS,
  hS,
  fS
]);
function mS(m) {
  return !m || En(m.size) || En(m.family) ? null : (m.style ? m.style + " " : "") + (m.weight ? m.weight + " " : "") + m.size + "px " + m.family;
}
function Nm(m, a, d, g, w) {
  let b = a[w];
  return b || (b = a[w] = m.measureText(w).width, d.push(w)), b > g && (g = b), g;
}
function _S(m, a, d, g) {
  g = g || {};
  let w = g.data = g.data || {}, b = g.garbageCollect = g.garbageCollect || [];
  g.font !== a && (w = g.data = {}, b = g.garbageCollect = [], g.font = a), m.save(), m.font = a;
  let E = 0;
  const i = d.length;
  let O, j, Y, J, ae;
  for (O = 0; O < i; O++)
    if (J = d[O], J != null && !hs(J))
      E = Nm(m, w, b, E, J);
    else if (hs(J))
      for (j = 0, Y = J.length; j < Y; j++)
        ae = J[j], ae != null && !hs(ae) && (E = Nm(m, w, b, E, ae));
  m.restore();
  const ce = b.length / 2;
  if (ce > d.length) {
    for (O = 0; O < ce; O++)
      delete w[b[O]];
    b.splice(0, ce);
  }
  return E;
}
function Ph(m, a, d) {
  const g = m.currentDevicePixelRatio, w = d !== 0 ? Math.max(d / 2, 0.5) : 0;
  return Math.round((a - w) * g) / g + w;
}
function l1(m, a) {
  !a && !m || (a = a || m.getContext("2d"), a.save(), a.resetTransform(), a.clearRect(0, 0, m.width, m.height), a.restore());
}
function qg(m, a, d, g) {
  Rb(m, a, d, g, null);
}
function Rb(m, a, d, g, w) {
  let b, E, i, O, j, Y, J, ae;
  const ce = a.pointStyle, Te = a.rotation, be = a.radius;
  let Ze = (Te || 0) * KM;
  if (ce && typeof ce == "object" && (b = ce.toString(), b === "[object HTMLImageElement]" || b === "[object HTMLCanvasElement]")) {
    m.save(), m.translate(d, g), m.rotate(Ze), m.drawImage(ce, -ce.width / 2, -ce.height / 2, ce.width, ce.height), m.restore();
    return;
  }
  if (!(isNaN(be) || be <= 0)) {
    switch (m.beginPath(), ce) {
      default:
        w ? m.ellipse(d, g, w / 2, be, 0, 0, us) : m.arc(d, g, be, 0, us), m.closePath();
        break;
      case "triangle":
        Y = w ? w / 2 : be, m.moveTo(d + Math.sin(Ze) * Y, g - Math.cos(Ze) * be), Ze += e1, m.lineTo(d + Math.sin(Ze) * Y, g - Math.cos(Ze) * be), Ze += e1, m.lineTo(d + Math.sin(Ze) * Y, g - Math.cos(Ze) * be), m.closePath();
        break;
      case "rectRounded":
        j = be * 0.516, O = be - j, E = Math.cos(Ze + Ah) * O, J = Math.cos(Ze + Ah) * (w ? w / 2 - j : O), i = Math.sin(Ze + Ah) * O, ae = Math.sin(Ze + Ah) * (w ? w / 2 - j : O), m.arc(d - J, g - i, j, Ze - ds, Ze - Ns), m.arc(d + ae, g - E, j, Ze - Ns, Ze), m.arc(d + J, g + i, j, Ze, Ze + Ns), m.arc(d - ae, g + E, j, Ze + Ns, Ze + ds), m.closePath();
        break;
      case "rect":
        if (!Te) {
          O = Math.SQRT1_2 * be, Y = w ? w / 2 : O, m.rect(d - Y, g - O, 2 * Y, 2 * O);
          break;
        }
        Ze += Ah;
      case "rectRot":
        J = Math.cos(Ze) * (w ? w / 2 : be), E = Math.cos(Ze) * be, i = Math.sin(Ze) * be, ae = Math.sin(Ze) * (w ? w / 2 : be), m.moveTo(d - J, g - i), m.lineTo(d + ae, g - E), m.lineTo(d + J, g + i), m.lineTo(d - ae, g + E), m.closePath();
        break;
      case "crossRot":
        Ze += Ah;
      case "cross":
        J = Math.cos(Ze) * (w ? w / 2 : be), E = Math.cos(Ze) * be, i = Math.sin(Ze) * be, ae = Math.sin(Ze) * (w ? w / 2 : be), m.moveTo(d - J, g - i), m.lineTo(d + J, g + i), m.moveTo(d + ae, g - E), m.lineTo(d - ae, g + E);
        break;
      case "star":
        J = Math.cos(Ze) * (w ? w / 2 : be), E = Math.cos(Ze) * be, i = Math.sin(Ze) * be, ae = Math.sin(Ze) * (w ? w / 2 : be), m.moveTo(d - J, g - i), m.lineTo(d + J, g + i), m.moveTo(d + ae, g - E), m.lineTo(d - ae, g + E), Ze += Ah, J = Math.cos(Ze) * (w ? w / 2 : be), E = Math.cos(Ze) * be, i = Math.sin(Ze) * be, ae = Math.sin(Ze) * (w ? w / 2 : be), m.moveTo(d - J, g - i), m.lineTo(d + J, g + i), m.moveTo(d + ae, g - E), m.lineTo(d - ae, g + E);
        break;
      case "line":
        E = w ? w / 2 : Math.cos(Ze) * be, i = Math.sin(Ze) * be, m.moveTo(d - E, g - i), m.lineTo(d + E, g + i);
        break;
      case "dash":
        m.moveTo(d, g), m.lineTo(d + Math.cos(Ze) * (w ? w / 2 : be), g + Math.sin(Ze) * be);
        break;
      case !1:
        m.closePath();
        break;
    }
    m.fill(), a.borderWidth > 0 && m.stroke();
  }
}
function Ul(m, a, d) {
  return d = d || 0.5, !a || m && m.x > a.left - d && m.x < a.right + d && m.y > a.top - d && m.y < a.bottom + d;
}
function Wm(m, a) {
  m.save(), m.beginPath(), m.rect(a.left, a.top, a.right - a.left, a.bottom - a.top), m.clip();
}
function $m(m) {
  m.restore();
}
function gS(m, a, d, g, w) {
  if (!a)
    return m.lineTo(d.x, d.y);
  if (w === "middle") {
    const b = (a.x + d.x) / 2;
    m.lineTo(b, a.y), m.lineTo(b, d.y);
  } else
    w === "after" != !!g ? m.lineTo(a.x, d.y) : m.lineTo(d.x, a.y);
  m.lineTo(d.x, d.y);
}
function yS(m, a, d, g) {
  if (!a)
    return m.lineTo(d.x, d.y);
  m.bezierCurveTo(g ? a.cp1x : a.cp2x, g ? a.cp1y : a.cp2y, g ? d.cp2x : d.cp1x, g ? d.cp2y : d.cp1y, d.x, d.y);
}
function xS(m, a) {
  a.translation && m.translate(a.translation[0], a.translation[1]), En(a.rotation) || m.rotate(a.rotation), a.color && (m.fillStyle = a.color), a.textAlign && (m.textAlign = a.textAlign), a.textBaseline && (m.textBaseline = a.textBaseline);
}
function vS(m, a, d, g, w) {
  if (w.strikethrough || w.underline) {
    const b = m.measureText(g), E = a - b.actualBoundingBoxLeft, i = a + b.actualBoundingBoxRight, O = d - b.actualBoundingBoxAscent, j = d + b.actualBoundingBoxDescent, Y = w.strikethrough ? (O + j) / 2 : j;
    m.strokeStyle = m.fillStyle, m.beginPath(), m.lineWidth = w.decorationWidth || 2, m.moveTo(E, Y), m.lineTo(i, Y), m.stroke();
  }
}
function bS(m, a) {
  const d = m.fillStyle;
  m.fillStyle = a.color, m.fillRect(a.left, a.top, a.width, a.height), m.fillStyle = d;
}
function Fh(m, a, d, g, w, b = {}) {
  const E = hs(a) ? a : [
    a
  ], i = b.strokeWidth > 0 && b.strokeColor !== "";
  let O, j;
  for (m.save(), m.font = w.string, xS(m, b), O = 0; O < E.length; ++O)
    j = E[O], b.backdrop && bS(m, b.backdrop), i && (b.strokeColor && (m.strokeStyle = b.strokeColor), En(b.strokeWidth) || (m.lineWidth = b.strokeWidth), m.strokeText(j, d, g, b.maxWidth)), m.fillText(j, d, g, b.maxWidth), vS(m, d, g, j, b), g += Number(w.lineHeight);
  m.restore();
}
function Bf(m, a) {
  const { x: d, y: g, w, h: b, radius: E } = a;
  m.arc(d + E.topLeft, g + E.topLeft, E.topLeft, 1.5 * ds, ds, !0), m.lineTo(d, g + b - E.bottomLeft), m.arc(d + E.bottomLeft, g + b - E.bottomLeft, E.bottomLeft, ds, Ns, !0), m.lineTo(d + w - E.bottomRight, g + b), m.arc(d + w - E.bottomRight, g + b - E.bottomRight, E.bottomRight, Ns, 0, !0), m.lineTo(d + w, g + E.topRight), m.arc(d + w - E.topRight, g + E.topRight, E.topRight, 0, -Ns, !0), m.lineTo(d + E.topLeft, g);
}
const wS = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, TS = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function MS(m, a) {
  const d = ("" + m).match(wS);
  if (!d || d[1] === "normal")
    return a * 1.2;
  switch (m = +d[2], d[3]) {
    case "px":
      return m;
    case "%":
      m /= 100;
      break;
  }
  return a * m;
}
const SS = (m) => +m || 0;
function my(m, a) {
  const d = {}, g = yn(a), w = g ? Object.keys(a) : a, b = yn(m) ? g ? (E) => en(m[E], m[a[E]]) : (E) => m[E] : () => m;
  for (const E of w)
    d[E] = SS(b(E));
  return d;
}
function Ob(m) {
  return my(m, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function kh(m) {
  return my(m, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Gr(m) {
  const a = Ob(m);
  return a.width = a.left + a.right, a.height = a.top + a.bottom, a;
}
function ir(m, a) {
  m = m || {}, a = a || ys.font;
  let d = en(m.size, a.size);
  typeof d == "string" && (d = parseInt(d, 10));
  let g = en(m.style, a.style);
  g && !("" + g).match(TS) && (console.warn('Invalid font style specified: "' + g + '"'), g = void 0);
  const w = {
    family: en(m.family, a.family),
    lineHeight: MS(en(m.lineHeight, a.lineHeight), d),
    size: d,
    style: g,
    weight: en(m.weight, a.weight),
    string: ""
  };
  return w.string = mS(w), w;
}
function Tf(m, a, d, g) {
  let w = !0, b, E, i;
  for (b = 0, E = m.length; b < E; ++b)
    if (i = m[b], i !== void 0 && (a !== void 0 && typeof i == "function" && (i = i(a), w = !1), d !== void 0 && hs(i) && (i = i[d % i.length], w = !1), i !== void 0))
      return g && !w && (g.cacheable = !1), i;
}
function ES(m, a, d) {
  const { min: g, max: w } = m, b = Mb(a, (w - g) / 2), E = (i, O) => d && i === 0 ? 0 : i + O;
  return {
    min: E(g, -Math.abs(b)),
    max: E(w, b)
  };
}
function Fc(m, a) {
  return Object.assign(Object.create(m), a);
}
function _y(m, a = [
  ""
], d, g, w = () => m[0]) {
  const b = d || m;
  typeof g > "u" && (g = Vb("_fallback", m));
  const E = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: m,
    _rootScopes: b,
    _fallback: g,
    _getTarget: w,
    override: (i) => _y([
      i,
      ...m
    ], a, b, g)
  };
  return new Proxy(E, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(i, O) {
      return delete i[O], delete i._keys, delete m[0][O], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(i, O) {
      return Bb(i, O, () => kS(O, a, m, i));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(i, O) {
      return Reflect.getOwnPropertyDescriptor(i._scopes[0], O);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(m[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(i, O) {
      return h1(i).includes(O);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(i) {
      return h1(i);
    },
    /**
    * A trap for setting property values.
    */
    set(i, O, j) {
      const Y = i._storage || (i._storage = w());
      return i[O] = Y[O] = j, delete i._keys, !0;
    }
  });
}
function Yu(m, a, d, g) {
  const w = {
    _cacheable: !1,
    _proxy: m,
    _context: a,
    _subProxy: d,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Fb(m, g),
    setContext: (b) => Yu(m, b, d, g),
    override: (b) => Yu(m.override(b), a, d, g)
  };
  return new Proxy(w, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(b, E) {
      return delete b[E], delete m[E], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(b, E, i) {
      return Bb(b, E, () => PS(b, E, i));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(b, E) {
      return b._descriptors.allKeys ? Reflect.has(m, E) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(m, E);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(m);
    },
    /**
    * A trap for the in operator.
    */
    has(b, E) {
      return Reflect.has(m, E);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(m);
    },
    /**
    * A trap for setting property values.
    */
    set(b, E, i) {
      return m[E] = i, delete b[E], !0;
    }
  });
}
function Fb(m, a = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: d = a.scriptable, _indexable: g = a.indexable, _allKeys: w = a.allKeys } = m;
  return {
    allKeys: w,
    scriptable: d,
    indexable: g,
    isScriptable: Oc(d) ? d : () => d,
    isIndexable: Oc(g) ? g : () => g
  };
}
const AS = (m, a) => m ? m + hy(a) : a, gy = (m, a) => yn(a) && m !== "adapters" && (Object.getPrototypeOf(a) === null || a.constructor === Object);
function Bb(m, a, d) {
  if (Object.prototype.hasOwnProperty.call(m, a) || a === "constructor")
    return m[a];
  const g = d();
  return m[a] = g, g;
}
function PS(m, a, d) {
  const { _proxy: g, _context: w, _subProxy: b, _descriptors: E } = m;
  let i = g[a];
  return Oc(i) && E.isScriptable(a) && (i = CS(a, i, m, d)), hs(i) && i.length && (i = IS(a, i, m, E.isIndexable)), gy(a, i) && (i = Yu(i, w, b && b[a], E)), i;
}
function CS(m, a, d, g) {
  const { _proxy: w, _context: b, _subProxy: E, _stack: i } = d;
  if (i.has(m))
    throw new Error("Recursion detected: " + Array.from(i).join("->") + "->" + m);
  i.add(m);
  let O = a(b, E || g);
  return i.delete(m), gy(m, O) && (O = yy(w._scopes, w, m, O)), O;
}
function IS(m, a, d, g) {
  const { _proxy: w, _context: b, _subProxy: E, _descriptors: i } = d;
  if (typeof b.index < "u" && g(m))
    return a[b.index % a.length];
  if (yn(a[0])) {
    const O = a, j = w._scopes.filter((Y) => Y !== O);
    a = [];
    for (const Y of O) {
      const J = yy(j, w, m, Y);
      a.push(Yu(J, b, E && E[m], i));
    }
  }
  return a;
}
function Nb(m, a, d) {
  return Oc(m) ? m(a, d) : m;
}
const LS = (m, a) => m === !0 ? a : typeof m == "string" ? Rc(a, m) : void 0;
function zS(m, a, d, g, w) {
  for (const b of a) {
    const E = LS(d, b);
    if (E) {
      m.add(E);
      const i = Nb(E._fallback, d, w);
      if (typeof i < "u" && i !== d && i !== g)
        return i;
    } else if (E === !1 && typeof g < "u" && d !== g)
      return null;
  }
  return !1;
}
function yy(m, a, d, g) {
  const w = a._rootScopes, b = Nb(a._fallback, d, g), E = [
    ...m,
    ...w
  ], i = /* @__PURE__ */ new Set();
  i.add(g);
  let O = c1(i, E, d, b || d, g);
  return O === null || typeof b < "u" && b !== d && (O = c1(i, E, b, O, g), O === null) ? !1 : _y(Array.from(i), [
    ""
  ], w, b, () => DS(a, d, g));
}
function c1(m, a, d, g, w) {
  for (; d; )
    d = zS(m, a, d, g, w);
  return d;
}
function DS(m, a, d) {
  const g = m._getTarget();
  a in g || (g[a] = {});
  const w = g[a];
  return hs(w) && yn(d) ? d : w || {};
}
function kS(m, a, d, g) {
  let w;
  for (const b of a)
    if (w = Vb(AS(b, m), d), typeof w < "u")
      return gy(m, w) ? yy(d, g, m, w) : w;
}
function Vb(m, a) {
  for (const d of a) {
    if (!d)
      continue;
    const g = d[m];
    if (typeof g < "u")
      return g;
  }
}
function h1(m) {
  let a = m._keys;
  return a || (a = m._keys = RS(m._scopes)), a;
}
function RS(m) {
  const a = /* @__PURE__ */ new Set();
  for (const d of m)
    for (const g of Object.keys(d).filter((w) => !w.startsWith("_")))
      a.add(g);
  return Array.from(a);
}
function Ub(m, a, d, g) {
  const { iScale: w } = m, { key: b = "r" } = this._parsing, E = new Array(g);
  let i, O, j, Y;
  for (i = 0, O = g; i < O; ++i)
    j = i + d, Y = a[j], E[i] = {
      r: w.parse(Rc(Y, b), j)
    };
  return E;
}
const OS = Number.EPSILON || 1e-14, Ku = (m, a) => a < m.length && !m[a].skip && m[a], jb = (m) => m === "x" ? "y" : "x";
function FS(m, a, d, g) {
  const w = m.skip ? a : m, b = a, E = d.skip ? a : d, i = Zg(b, w), O = Zg(E, b);
  let j = i / (i + O), Y = O / (i + O);
  j = isNaN(j) ? 0 : j, Y = isNaN(Y) ? 0 : Y;
  const J = g * j, ae = g * Y;
  return {
    previous: {
      x: b.x - J * (E.x - w.x),
      y: b.y - J * (E.y - w.y)
    },
    next: {
      x: b.x + ae * (E.x - w.x),
      y: b.y + ae * (E.y - w.y)
    }
  };
}
function BS(m, a, d) {
  const g = m.length;
  let w, b, E, i, O, j = Ku(m, 0);
  for (let Y = 0; Y < g - 1; ++Y)
    if (O = j, j = Ku(m, Y + 1), !(!O || !j)) {
      if (If(a[Y], 0, OS)) {
        d[Y] = d[Y + 1] = 0;
        continue;
      }
      w = d[Y] / a[Y], b = d[Y + 1] / a[Y], i = Math.pow(w, 2) + Math.pow(b, 2), !(i <= 9) && (E = 3 / Math.sqrt(i), d[Y] = w * E * a[Y], d[Y + 1] = b * E * a[Y]);
    }
}
function NS(m, a, d = "x") {
  const g = jb(d), w = m.length;
  let b, E, i, O = Ku(m, 0);
  for (let j = 0; j < w; ++j) {
    if (E = i, i = O, O = Ku(m, j + 1), !i)
      continue;
    const Y = i[d], J = i[g];
    E && (b = (Y - E[d]) / 3, i[`cp1${d}`] = Y - b, i[`cp1${g}`] = J - b * a[j]), O && (b = (O[d] - Y) / 3, i[`cp2${d}`] = Y + b, i[`cp2${g}`] = J + b * a[j]);
  }
}
function VS(m, a = "x") {
  const d = jb(a), g = m.length, w = Array(g).fill(0), b = Array(g);
  let E, i, O, j = Ku(m, 0);
  for (E = 0; E < g; ++E)
    if (i = O, O = j, j = Ku(m, E + 1), !!O) {
      if (j) {
        const Y = j[a] - O[a];
        w[E] = Y !== 0 ? (j[d] - O[d]) / Y : 0;
      }
      b[E] = i ? j ? ll(w[E - 1]) !== ll(w[E]) ? 0 : (w[E - 1] + w[E]) / 2 : w[E - 1] : w[E];
    }
  BS(m, w, b), NS(m, b, a);
}
function mm(m, a, d) {
  return Math.max(Math.min(m, d), a);
}
function US(m, a) {
  let d, g, w, b, E, i = Ul(m[0], a);
  for (d = 0, g = m.length; d < g; ++d)
    E = b, b = i, i = d < g - 1 && Ul(m[d + 1], a), b && (w = m[d], E && (w.cp1x = mm(w.cp1x, a.left, a.right), w.cp1y = mm(w.cp1y, a.top, a.bottom)), i && (w.cp2x = mm(w.cp2x, a.left, a.right), w.cp2y = mm(w.cp2y, a.top, a.bottom)));
}
function jS(m, a, d, g, w) {
  let b, E, i, O;
  if (a.spanGaps && (m = m.filter((j) => !j.skip)), a.cubicInterpolationMode === "monotone")
    VS(m, w);
  else {
    let j = g ? m[m.length - 1] : m[0];
    for (b = 0, E = m.length; b < E; ++b)
      i = m[b], O = FS(j, i, m[Math.min(b + 1, E - (g ? 0 : 1)) % E], a.tension), i.cp1x = O.previous.x, i.cp1y = O.previous.y, i.cp2x = O.next.x, i.cp2y = O.next.y, j = i;
  }
  a.capBezierPoints && US(m, d);
}
function xy() {
  return typeof window < "u" && typeof document < "u";
}
function vy(m) {
  let a = m.parentNode;
  return a && a.toString() === "[object ShadowRoot]" && (a = a.host), a;
}
function Vm(m, a, d) {
  let g;
  return typeof m == "string" ? (g = parseInt(m, 10), m.indexOf("%") !== -1 && (g = g / 100 * a.parentNode[d])) : g = m, g;
}
const Xm = (m) => m.ownerDocument.defaultView.getComputedStyle(m, null);
function GS(m, a) {
  return Xm(m).getPropertyValue(a);
}
const ZS = [
  "top",
  "right",
  "bottom",
  "left"
];
function Rh(m, a, d) {
  const g = {};
  d = d ? "-" + d : "";
  for (let w = 0; w < 4; w++) {
    const b = ZS[w];
    g[b] = parseFloat(m[a + "-" + b + d]) || 0;
  }
  return g.width = g.left + g.right, g.height = g.top + g.bottom, g;
}
const HS = (m, a, d) => (m > 0 || a > 0) && (!d || !d.shadowRoot);
function qS(m, a) {
  const d = m.touches, g = d && d.length ? d[0] : m, { offsetX: w, offsetY: b } = g;
  let E = !1, i, O;
  if (HS(w, b, m.target))
    i = w, O = b;
  else {
    const j = a.getBoundingClientRect();
    i = g.clientX - j.left, O = g.clientY - j.top, E = !0;
  }
  return {
    x: i,
    y: O,
    box: E
  };
}
function Lh(m, a) {
  if ("native" in m)
    return m;
  const { canvas: d, currentDevicePixelRatio: g } = a, w = Xm(d), b = w.boxSizing === "border-box", E = Rh(w, "padding"), i = Rh(w, "border", "width"), { x: O, y: j, box: Y } = qS(m, d), J = E.left + (Y && i.left), ae = E.top + (Y && i.top);
  let { width: ce, height: Te } = a;
  return b && (ce -= E.width + i.width, Te -= E.height + i.height), {
    x: Math.round((O - J) / ce * d.width / g),
    y: Math.round((j - ae) / Te * d.height / g)
  };
}
function WS(m, a, d) {
  let g, w;
  if (a === void 0 || d === void 0) {
    const b = m && vy(m);
    if (!b)
      a = m.clientWidth, d = m.clientHeight;
    else {
      const E = b.getBoundingClientRect(), i = Xm(b), O = Rh(i, "border", "width"), j = Rh(i, "padding");
      a = E.width - j.width - O.width, d = E.height - j.height - O.height, g = Vm(i.maxWidth, b, "clientWidth"), w = Vm(i.maxHeight, b, "clientHeight");
    }
  }
  return {
    width: a,
    height: d,
    maxWidth: g || Bm,
    maxHeight: w || Bm
  };
}
const _m = (m) => Math.round(m * 10) / 10;
function $S(m, a, d, g) {
  const w = Xm(m), b = Rh(w, "margin"), E = Vm(w.maxWidth, m, "clientWidth") || Bm, i = Vm(w.maxHeight, m, "clientHeight") || Bm, O = WS(m, a, d);
  let { width: j, height: Y } = O;
  if (w.boxSizing === "content-box") {
    const ae = Rh(w, "border", "width"), ce = Rh(w, "padding");
    j -= ce.width + ae.width, Y -= ce.height + ae.height;
  }
  return j = Math.max(0, j - b.width), Y = Math.max(0, g ? j / g : Y - b.height), j = _m(Math.min(j, E, O.maxWidth)), Y = _m(Math.min(Y, i, O.maxHeight)), j && !Y && (Y = _m(j / 2)), (a !== void 0 || d !== void 0) && g && O.height && Y > O.height && (Y = O.height, j = _m(Math.floor(Y * g))), {
    width: j,
    height: Y
  };
}
function u1(m, a, d) {
  const g = a || 1, w = Math.floor(m.height * g), b = Math.floor(m.width * g);
  m.height = Math.floor(m.height), m.width = Math.floor(m.width);
  const E = m.canvas;
  return E.style && (d || !E.style.height && !E.style.width) && (E.style.height = `${m.height}px`, E.style.width = `${m.width}px`), m.currentDevicePixelRatio !== g || E.height !== w || E.width !== b ? (m.currentDevicePixelRatio = g, E.height = w, E.width = b, m.ctx.setTransform(g, 0, 0, g, 0, 0), !0) : !1;
}
const XS = function() {
  let m = !1;
  try {
    const a = {
      get passive() {
        return m = !0, !1;
      }
    };
    xy() && (window.addEventListener("test", null, a), window.removeEventListener("test", null, a));
  } catch {
  }
  return m;
}();
function d1(m, a) {
  const d = GS(m, a), g = d && d.match(/^(\d+)(\.\d+)?px$/);
  return g ? +g[1] : void 0;
}
function zh(m, a, d, g) {
  return {
    x: m.x + d * (a.x - m.x),
    y: m.y + d * (a.y - m.y)
  };
}
function YS(m, a, d, g) {
  return {
    x: m.x + d * (a.x - m.x),
    y: g === "middle" ? d < 0.5 ? m.y : a.y : g === "after" ? d < 1 ? m.y : a.y : d > 0 ? a.y : m.y
  };
}
function KS(m, a, d, g) {
  const w = {
    x: m.cp2x,
    y: m.cp2y
  }, b = {
    x: a.cp1x,
    y: a.cp1y
  }, E = zh(m, w, d), i = zh(w, b, d), O = zh(b, a, d), j = zh(E, i, d), Y = zh(i, O, d);
  return zh(j, Y, d);
}
const JS = function(m, a) {
  return {
    x(d) {
      return m + m + a - d;
    },
    setWidth(d) {
      a = d;
    },
    textAlign(d) {
      return d === "center" ? d : d === "right" ? "left" : "right";
    },
    xPlus(d, g) {
      return d - g;
    },
    leftForLtr(d, g) {
      return d - g;
    }
  };
}, QS = function() {
  return {
    x(m) {
      return m;
    },
    setWidth(m) {
    },
    textAlign(m) {
      return m;
    },
    xPlus(m, a) {
      return m + a;
    },
    leftForLtr(m, a) {
      return m;
    }
  };
};
function $u(m, a, d) {
  return m ? JS(a, d) : QS();
}
function Gb(m, a) {
  let d, g;
  (a === "ltr" || a === "rtl") && (d = m.canvas.style, g = [
    d.getPropertyValue("direction"),
    d.getPropertyPriority("direction")
  ], d.setProperty("direction", a, "important"), m.prevTextDirection = g);
}
function Zb(m, a) {
  a !== void 0 && (delete m.prevTextDirection, m.canvas.style.setProperty("direction", a[0], a[1]));
}
function Hb(m) {
  return m === "angle" ? {
    between: Ff,
    compare: eS,
    normalize: No
  } : {
    between: Nl,
    compare: (a, d) => a - d,
    normalize: (a) => a
  };
}
function f1({ start: m, end: a, count: d, loop: g, style: w }) {
  return {
    start: m % d,
    end: a % d,
    loop: g && (a - m + 1) % d === 0,
    style: w
  };
}
function eE(m, a, d) {
  const { property: g, start: w, end: b } = d, { between: E, normalize: i } = Hb(g), O = a.length;
  let { start: j, end: Y, loop: J } = m, ae, ce;
  if (J) {
    for (j += O, Y += O, ae = 0, ce = O; ae < ce && E(i(a[j % O][g]), w, b); ++ae)
      j--, Y--;
    j %= O, Y %= O;
  }
  return Y < j && (Y += O), {
    start: j,
    end: Y,
    loop: J,
    style: m.style
  };
}
function qb(m, a, d) {
  if (!d)
    return [
      m
    ];
  const { property: g, start: w, end: b } = d, E = a.length, { compare: i, between: O, normalize: j } = Hb(g), { start: Y, end: J, loop: ae, style: ce } = eE(m, a, d), Te = [];
  let be = !1, Ze = null, je, ot, vt;
  const ht = () => O(w, vt, je) && i(w, vt) !== 0, gt = () => i(b, je) === 0 || O(b, vt, je), Vt = () => be || ht(), pt = () => !be || gt();
  for (let Gt = Y, ui = Y; Gt <= J; ++Gt)
    ot = a[Gt % E], !ot.skip && (je = j(ot[g]), je !== vt && (be = O(je, w, b), Ze === null && Vt() && (Ze = i(je, w) === 0 ? Gt : ui), Ze !== null && pt() && (Te.push(f1({
      start: Ze,
      end: Gt,
      loop: ae,
      count: E,
      style: ce
    })), Ze = null), ui = Gt, vt = je));
  return Ze !== null && Te.push(f1({
    start: Ze,
    end: J,
    loop: ae,
    count: E,
    style: ce
  })), Te;
}
function Wb(m, a) {
  const d = [], g = m.segments;
  for (let w = 0; w < g.length; w++) {
    const b = qb(g[w], m.points, a);
    b.length && d.push(...b);
  }
  return d;
}
function tE(m, a, d, g) {
  let w = 0, b = a - 1;
  if (d && !g)
    for (; w < a && !m[w].skip; )
      w++;
  for (; w < a && m[w].skip; )
    w++;
  for (w %= a, d && (b += w); b > w && m[b % a].skip; )
    b--;
  return b %= a, {
    start: w,
    end: b
  };
}
function iE(m, a, d, g) {
  const w = m.length, b = [];
  let E = a, i = m[a], O;
  for (O = a + 1; O <= d; ++O) {
    const j = m[O % w];
    j.skip || j.stop ? i.skip || (g = !1, b.push({
      start: a % w,
      end: (O - 1) % w,
      loop: g
    }), a = E = j.stop ? O : null) : (E = O, i.skip && (a = O)), i = j;
  }
  return E !== null && b.push({
    start: a % w,
    end: E % w,
    loop: g
  }), b;
}
function nE(m, a) {
  const d = m.points, g = m.options.spanGaps, w = d.length;
  if (!w)
    return [];
  const b = !!m._loop, { start: E, end: i } = tE(d, w, b, g);
  if (g === !0)
    return p1(m, [
      {
        start: E,
        end: i,
        loop: b
      }
    ], d, a);
  const O = i < E ? i + w : i, j = !!m._fullLoop && E === 0 && i === w - 1;
  return p1(m, iE(d, E, O, j), d, a);
}
function p1(m, a, d, g) {
  return !g || !g.setContext || !d ? a : sE(m, a, d, g);
}
function sE(m, a, d, g) {
  const w = m._chart.getContext(), b = m1(m.options), { _datasetIndex: E, options: { spanGaps: i } } = m, O = d.length, j = [];
  let Y = b, J = a[0].start, ae = J;
  function ce(Te, be, Ze, je) {
    const ot = i ? -1 : 1;
    if (Te !== be) {
      for (Te += O; d[Te % O].skip; )
        Te -= ot;
      for (; d[be % O].skip; )
        be += ot;
      Te % O !== be % O && (j.push({
        start: Te % O,
        end: be % O,
        loop: Ze,
        style: je
      }), Y = je, J = be % O);
    }
  }
  for (const Te of a) {
    J = i ? J : Te.start;
    let be = d[J % O], Ze;
    for (ae = J + 1; ae <= Te.end; ae++) {
      const je = d[ae % O];
      Ze = m1(g.setContext(Fc(w, {
        type: "segment",
        p0: be,
        p1: je,
        p0DataIndex: (ae - 1) % O,
        p1DataIndex: ae % O,
        datasetIndex: E
      }))), rE(Ze, Y) && ce(J, ae - 1, Te.loop, Y), be = je, Y = Ze;
    }
    J < ae - 1 && ce(J, ae - 1, Te.loop, Y);
  }
  return j;
}
function m1(m) {
  return {
    backgroundColor: m.backgroundColor,
    borderCapStyle: m.borderCapStyle,
    borderDash: m.borderDash,
    borderDashOffset: m.borderDashOffset,
    borderJoinStyle: m.borderJoinStyle,
    borderWidth: m.borderWidth,
    borderColor: m.borderColor
  };
}
function rE(m, a) {
  if (!a)
    return !1;
  const d = [], g = function(w, b) {
    return py(b) ? (d.includes(b) || d.push(b), d.indexOf(b)) : b;
  };
  return JSON.stringify(m, g) !== JSON.stringify(a, g);
}
/*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class oE {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(a, d, g, w) {
    const b = d.listeners[w], E = d.duration;
    b.forEach((i) => i({
      chart: a,
      initial: d.initial,
      numSteps: E,
      currentStep: Math.min(g - d.start, E)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = Ib.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(a = Date.now()) {
    let d = 0;
    this._charts.forEach((g, w) => {
      if (!g.running || !g.items.length)
        return;
      const b = g.items;
      let E = b.length - 1, i = !1, O;
      for (; E >= 0; --E)
        O = b[E], O._active ? (O._total > g.duration && (g.duration = O._total), O.tick(a), i = !0) : (b[E] = b[b.length - 1], b.pop());
      i && (w.draw(), this._notify(w, g, a, "progress")), b.length || (g.running = !1, this._notify(w, g, a, "complete"), g.initial = !1), d += b.length;
    }), this._lastDate = a, d === 0 && (this._running = !1);
  }
  _getAnims(a) {
    const d = this._charts;
    let g = d.get(a);
    return g || (g = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, d.set(a, g)), g;
  }
  listen(a, d, g) {
    this._getAnims(a).listeners[d].push(g);
  }
  add(a, d) {
    !d || !d.length || this._getAnims(a).items.push(...d);
  }
  has(a) {
    return this._getAnims(a).items.length > 0;
  }
  start(a) {
    const d = this._charts.get(a);
    d && (d.running = !0, d.start = Date.now(), d.duration = d.items.reduce((g, w) => Math.max(g, w._duration), 0), this._refresh());
  }
  running(a) {
    if (!this._running)
      return !1;
    const d = this._charts.get(a);
    return !(!d || !d.running || !d.items.length);
  }
  stop(a) {
    const d = this._charts.get(a);
    if (!d || !d.items.length)
      return;
    const g = d.items;
    let w = g.length - 1;
    for (; w >= 0; --w)
      g[w].cancel();
    d.items = [], this._notify(a, d, Date.now(), "complete");
  }
  remove(a) {
    return this._charts.delete(a);
  }
}
var Rl = /* @__PURE__ */ new oE();
const _1 = "transparent", aE = {
  boolean(m, a, d) {
    return d > 0.5 ? a : m;
  },
  color(m, a, d) {
    const g = o1(m || _1), w = g.valid && o1(a || _1);
    return w && w.valid ? w.mix(g, d).hexString() : a;
  },
  number(m, a, d) {
    return m + (a - m) * d;
  }
};
class lE {
  constructor(a, d, g, w) {
    const b = d[g];
    w = Tf([
      a.to,
      w,
      b,
      a.from
    ]);
    const E = Tf([
      a.from,
      b,
      w
    ]);
    this._active = !0, this._fn = a.fn || aE[a.type || typeof E], this._easing = Lf[a.easing] || Lf.linear, this._start = Math.floor(Date.now() + (a.delay || 0)), this._duration = this._total = Math.floor(a.duration), this._loop = !!a.loop, this._target = d, this._prop = g, this._from = E, this._to = w, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(a, d, g) {
    if (this._active) {
      this._notify(!1);
      const w = this._target[this._prop], b = g - this._start, E = this._duration - b;
      this._start = g, this._duration = Math.floor(Math.max(E, a.duration)), this._total += b, this._loop = !!a.loop, this._to = Tf([
        a.to,
        d,
        w,
        a.from
      ]), this._from = Tf([
        a.from,
        w,
        d
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(a) {
    const d = a - this._start, g = this._duration, w = this._prop, b = this._from, E = this._loop, i = this._to;
    let O;
    if (this._active = b !== i && (E || d < g), !this._active) {
      this._target[w] = i, this._notify(!0);
      return;
    }
    if (d < 0) {
      this._target[w] = b;
      return;
    }
    O = d / g % 2, O = E && O > 1 ? 2 - O : O, O = this._easing(Math.min(1, Math.max(0, O))), this._target[w] = this._fn(b, i, O);
  }
  wait() {
    const a = this._promises || (this._promises = []);
    return new Promise((d, g) => {
      a.push({
        res: d,
        rej: g
      });
    });
  }
  _notify(a) {
    const d = a ? "res" : "rej", g = this._promises || [];
    for (let w = 0; w < g.length; w++)
      g[w][d]();
  }
}
class $b {
  constructor(a, d) {
    this._chart = a, this._properties = /* @__PURE__ */ new Map(), this.configure(d);
  }
  configure(a) {
    if (!yn(a))
      return;
    const d = Object.keys(ys.animation), g = this._properties;
    Object.getOwnPropertyNames(a).forEach((w) => {
      const b = a[w];
      if (!yn(b))
        return;
      const E = {};
      for (const i of d)
        E[i] = b[i];
      (hs(b.properties) && b.properties || [
        w
      ]).forEach((i) => {
        (i === w || !g.has(i)) && g.set(i, E);
      });
    });
  }
  _animateOptions(a, d) {
    const g = d.options, w = hE(a, g);
    if (!w)
      return [];
    const b = this._createAnimations(w, g);
    return g.$shared && cE(a.options.$animations, g).then(() => {
      a.options = g;
    }, () => {
    }), b;
  }
  _createAnimations(a, d) {
    const g = this._properties, w = [], b = a.$animations || (a.$animations = {}), E = Object.keys(d), i = Date.now();
    let O;
    for (O = E.length - 1; O >= 0; --O) {
      const j = E[O];
      if (j.charAt(0) === "$")
        continue;
      if (j === "options") {
        w.push(...this._animateOptions(a, d));
        continue;
      }
      const Y = d[j];
      let J = b[j];
      const ae = g.get(j);
      if (J)
        if (ae && J.active()) {
          J.update(ae, Y, i);
          continue;
        } else
          J.cancel();
      if (!ae || !ae.duration) {
        a[j] = Y;
        continue;
      }
      b[j] = J = new lE(ae, a, j, Y), w.push(J);
    }
    return w;
  }
  update(a, d) {
    if (this._properties.size === 0) {
      Object.assign(a, d);
      return;
    }
    const g = this._createAnimations(a, d);
    if (g.length)
      return Rl.add(this._chart, g), !0;
  }
}
function cE(m, a) {
  const d = [], g = Object.keys(a);
  for (let w = 0; w < g.length; w++) {
    const b = m[g[w]];
    b && b.active() && d.push(b.wait());
  }
  return Promise.all(d);
}
function hE(m, a) {
  if (!a)
    return;
  let d = m.options;
  if (!d) {
    m.options = a;
    return;
  }
  return d.$shared && (m.options = d = Object.assign({}, d, {
    $shared: !1,
    $animations: {}
  })), d;
}
function g1(m, a) {
  const d = m && m.options || {}, g = d.reverse, w = d.min === void 0 ? a : 0, b = d.max === void 0 ? a : 0;
  return {
    start: g ? b : w,
    end: g ? w : b
  };
}
function uE(m, a, d) {
  if (d === !1)
    return !1;
  const g = g1(m, d), w = g1(a, d);
  return {
    top: w.end,
    right: g.end,
    bottom: w.start,
    left: g.start
  };
}
function dE(m) {
  let a, d, g, w;
  return yn(m) ? (a = m.top, d = m.right, g = m.bottom, w = m.left) : a = d = g = w = m, {
    top: a,
    right: d,
    bottom: g,
    left: w,
    disabled: m === !1
  };
}
function Xb(m, a) {
  const d = [], g = m._getSortedDatasetMetas(a);
  let w, b;
  for (w = 0, b = g.length; w < b; ++w)
    d.push(g[w].index);
  return d;
}
function y1(m, a, d, g = {}) {
  const w = m.keys, b = g.mode === "single";
  let E, i, O, j;
  if (a === null)
    return;
  let Y = !1;
  for (E = 0, i = w.length; E < i; ++E) {
    if (O = +w[E], O === d) {
      if (Y = !0, g.all)
        continue;
      break;
    }
    j = m.values[O], Ps(j) && (b || a === 0 || ll(a) === ll(j)) && (a += j);
  }
  return !Y && !g.all ? 0 : a;
}
function fE(m, a) {
  const { iScale: d, vScale: g } = a, w = d.axis === "x" ? "x" : "y", b = g.axis === "x" ? "x" : "y", E = Object.keys(m), i = new Array(E.length);
  let O, j, Y;
  for (O = 0, j = E.length; O < j; ++O)
    Y = E[O], i[O] = {
      [w]: Y,
      [b]: m[Y]
    };
  return i;
}
function Dg(m, a) {
  const d = m && m.options.stacked;
  return d || d === void 0 && a.stack !== void 0;
}
function pE(m, a, d) {
  return `${m.id}.${a.id}.${d.stack || d.type}`;
}
function mE(m) {
  const { min: a, max: d, minDefined: g, maxDefined: w } = m.getUserBounds();
  return {
    min: g ? a : Number.NEGATIVE_INFINITY,
    max: w ? d : Number.POSITIVE_INFINITY
  };
}
function _E(m, a, d) {
  const g = m[a] || (m[a] = {});
  return g[d] || (g[d] = {});
}
function x1(m, a, d, g) {
  for (const w of a.getMatchingVisibleMetas(g).reverse()) {
    const b = m[w.index];
    if (d && b > 0 || !d && b < 0)
      return w.index;
  }
  return null;
}
function v1(m, a) {
  const { chart: d, _cachedMeta: g } = m, w = d._stacks || (d._stacks = {}), { iScale: b, vScale: E, index: i } = g, O = b.axis, j = E.axis, Y = pE(b, E, g), J = a.length;
  let ae;
  for (let ce = 0; ce < J; ++ce) {
    const Te = a[ce], { [O]: be, [j]: Ze } = Te, je = Te._stacks || (Te._stacks = {});
    ae = je[j] = _E(w, Y, be), ae[i] = Ze, ae._top = x1(ae, E, !0, g.type), ae._bottom = x1(ae, E, !1, g.type);
    const ot = ae._visualValues || (ae._visualValues = {});
    ot[i] = Ze;
  }
}
function kg(m, a) {
  const d = m.scales;
  return Object.keys(d).filter((g) => d[g].axis === a).shift();
}
function gE(m, a) {
  return Fc(m, {
    active: !1,
    dataset: void 0,
    datasetIndex: a,
    index: a,
    mode: "default",
    type: "dataset"
  });
}
function yE(m, a, d) {
  return Fc(m, {
    active: !1,
    dataIndex: a,
    parsed: void 0,
    raw: void 0,
    element: d,
    index: a,
    mode: "default",
    type: "data"
  });
}
function gf(m, a) {
  const d = m.controller.index, g = m.vScale && m.vScale.axis;
  if (g) {
    a = a || m._parsed;
    for (const w of a) {
      const b = w._stacks;
      if (!b || b[g] === void 0 || b[g][d] === void 0)
        return;
      delete b[g][d], b[g]._visualValues !== void 0 && b[g]._visualValues[d] !== void 0 && delete b[g]._visualValues[d];
    }
  }
}
const Rg = (m) => m === "reset" || m === "none", b1 = (m, a) => a ? m : Object.assign({}, m), xE = (m, a, d) => m && !a.hidden && a._stacked && {
  keys: Xb(d, !0),
  values: null
};
class za {
  constructor(a, d) {
    this.chart = a, this._ctx = a.ctx, this.index = d, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const a = this._cachedMeta;
    this.configure(), this.linkScales(), a._stacked = Dg(a.vScale, a), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(a) {
    this.index !== a && gf(this._cachedMeta), this.index = a;
  }
  linkScales() {
    const a = this.chart, d = this._cachedMeta, g = this.getDataset(), w = (J, ae, ce, Te) => J === "x" ? ae : J === "r" ? Te : ce, b = d.xAxisID = en(g.xAxisID, kg(a, "x")), E = d.yAxisID = en(g.yAxisID, kg(a, "y")), i = d.rAxisID = en(g.rAxisID, kg(a, "r")), O = d.indexAxis, j = d.iAxisID = w(O, b, E, i), Y = d.vAxisID = w(O, E, b, i);
    d.xScale = this.getScaleForId(b), d.yScale = this.getScaleForId(E), d.rScale = this.getScaleForId(i), d.iScale = this.getScaleForId(j), d.vScale = this.getScaleForId(Y);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(a) {
    return this.chart.scales[a];
  }
  _getOtherScale(a) {
    const d = this._cachedMeta;
    return a === d.iScale ? d.vScale : d.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const a = this._cachedMeta;
    this._data && n1(this._data, this), a._stacked && gf(a);
  }
  _dataCheck() {
    const a = this.getDataset(), d = a.data || (a.data = []), g = this._data;
    if (yn(d)) {
      const w = this._cachedMeta;
      this._data = fE(d, w);
    } else if (g !== d) {
      if (g) {
        n1(g, this);
        const w = this._cachedMeta;
        gf(w), w._parsed = [];
      }
      d && Object.isExtensible(d) && sS(d, this), this._syncList = [], this._data = d;
    }
  }
  addElements() {
    const a = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (a.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(a) {
    const d = this._cachedMeta, g = this.getDataset();
    let w = !1;
    this._dataCheck();
    const b = d._stacked;
    d._stacked = Dg(d.vScale, d), d.stack !== g.stack && (w = !0, gf(d), d.stack = g.stack), this._resyncElements(a), (w || b !== d._stacked) && (v1(this, d._parsed), d._stacked = Dg(d.vScale, d));
  }
  configure() {
    const a = this.chart.config, d = a.datasetScopeKeys(this._type), g = a.getOptionScopes(this.getDataset(), d, !0);
    this.options = a.createResolver(g, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(a, d) {
    const { _cachedMeta: g, _data: w } = this, { iScale: b, _stacked: E } = g, i = b.axis;
    let O = a === 0 && d === w.length ? !0 : g._sorted, j = a > 0 && g._parsed[a - 1], Y, J, ae;
    if (this._parsing === !1)
      g._parsed = w, g._sorted = !0, ae = w;
    else {
      hs(w[a]) ? ae = this.parseArrayData(g, w, a, d) : yn(w[a]) ? ae = this.parseObjectData(g, w, a, d) : ae = this.parsePrimitiveData(g, w, a, d);
      const ce = () => J[i] === null || j && J[i] < j[i];
      for (Y = 0; Y < d; ++Y)
        g._parsed[Y + a] = J = ae[Y], O && (ce() && (O = !1), j = J);
      g._sorted = O;
    }
    E && v1(this, ae);
  }
  parsePrimitiveData(a, d, g, w) {
    const { iScale: b, vScale: E } = a, i = b.axis, O = E.axis, j = b.getLabels(), Y = b === E, J = new Array(w);
    let ae, ce, Te;
    for (ae = 0, ce = w; ae < ce; ++ae)
      Te = ae + g, J[ae] = {
        [i]: Y || b.parse(j[Te], Te),
        [O]: E.parse(d[Te], Te)
      };
    return J;
  }
  parseArrayData(a, d, g, w) {
    const { xScale: b, yScale: E } = a, i = new Array(w);
    let O, j, Y, J;
    for (O = 0, j = w; O < j; ++O)
      Y = O + g, J = d[Y], i[O] = {
        x: b.parse(J[0], Y),
        y: E.parse(J[1], Y)
      };
    return i;
  }
  parseObjectData(a, d, g, w) {
    const { xScale: b, yScale: E } = a, { xAxisKey: i = "x", yAxisKey: O = "y" } = this._parsing, j = new Array(w);
    let Y, J, ae, ce;
    for (Y = 0, J = w; Y < J; ++Y)
      ae = Y + g, ce = d[ae], j[Y] = {
        x: b.parse(Rc(ce, i), ae),
        y: E.parse(Rc(ce, O), ae)
      };
    return j;
  }
  getParsed(a) {
    return this._cachedMeta._parsed[a];
  }
  getDataElement(a) {
    return this._cachedMeta.data[a];
  }
  applyStack(a, d, g) {
    const w = this.chart, b = this._cachedMeta, E = d[a.axis], i = {
      keys: Xb(w, !0),
      values: d._stacks[a.axis]._visualValues
    };
    return y1(i, E, b.index, {
      mode: g
    });
  }
  updateRangeFromParsed(a, d, g, w) {
    const b = g[d.axis];
    let E = b === null ? NaN : b;
    const i = w && g._stacks[d.axis];
    w && i && (w.values = i, E = y1(w, b, this._cachedMeta.index)), a.min = Math.min(a.min, E), a.max = Math.max(a.max, E);
  }
  getMinMax(a, d) {
    const g = this._cachedMeta, w = g._parsed, b = g._sorted && a === g.iScale, E = w.length, i = this._getOtherScale(a), O = xE(d, g, this.chart), j = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: Y, max: J } = mE(i);
    let ae, ce;
    function Te() {
      ce = w[ae];
      const be = ce[i.axis];
      return !Ps(ce[a.axis]) || Y > be || J < be;
    }
    for (ae = 0; ae < E && !(!Te() && (this.updateRangeFromParsed(j, a, ce, O), b)); ++ae)
      ;
    if (b) {
      for (ae = E - 1; ae >= 0; --ae)
        if (!Te()) {
          this.updateRangeFromParsed(j, a, ce, O);
          break;
        }
    }
    return j;
  }
  getAllParsedValues(a) {
    const d = this._cachedMeta._parsed, g = [];
    let w, b, E;
    for (w = 0, b = d.length; w < b; ++w)
      E = d[w][a.axis], Ps(E) && g.push(E);
    return g;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(a) {
    const d = this._cachedMeta, g = d.iScale, w = d.vScale, b = this.getParsed(a);
    return {
      label: g ? "" + g.getLabelForValue(b[g.axis]) : "",
      value: w ? "" + w.getLabelForValue(b[w.axis]) : ""
    };
  }
  _update(a) {
    const d = this._cachedMeta;
    this.update(a || "default"), d._clip = dE(en(this.options.clip, uE(d.xScale, d.yScale, this.getMaxOverflow())));
  }
  update(a) {
  }
  draw() {
    const a = this._ctx, d = this.chart, g = this._cachedMeta, w = g.data || [], b = d.chartArea, E = [], i = this._drawStart || 0, O = this._drawCount || w.length - i, j = this.options.drawActiveElementsOnTop;
    let Y;
    for (g.dataset && g.dataset.draw(a, b, i, O), Y = i; Y < i + O; ++Y) {
      const J = w[Y];
      J.hidden || (J.active && j ? E.push(J) : J.draw(a, b));
    }
    for (Y = 0; Y < E.length; ++Y)
      E[Y].draw(a, b);
  }
  getStyle(a, d) {
    const g = d ? "active" : "default";
    return a === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(g) : this.resolveDataElementOptions(a || 0, g);
  }
  getContext(a, d, g) {
    const w = this.getDataset();
    let b;
    if (a >= 0 && a < this._cachedMeta.data.length) {
      const E = this._cachedMeta.data[a];
      b = E.$context || (E.$context = yE(this.getContext(), a, E)), b.parsed = this.getParsed(a), b.raw = w.data[a], b.index = b.dataIndex = a;
    } else
      b = this.$context || (this.$context = gE(this.chart.getContext(), this.index)), b.dataset = w, b.index = b.datasetIndex = this.index;
    return b.active = !!d, b.mode = g, b;
  }
  resolveDatasetElementOptions(a) {
    return this._resolveElementOptions(this.datasetElementType.id, a);
  }
  resolveDataElementOptions(a, d) {
    return this._resolveElementOptions(this.dataElementType.id, d, a);
  }
  _resolveElementOptions(a, d = "default", g) {
    const w = d === "active", b = this._cachedDataOpts, E = a + "-" + d, i = b[E], O = this.enableOptionSharing && Of(g);
    if (i)
      return b1(i, O);
    const j = this.chart.config, Y = j.datasetElementScopeKeys(this._type, a), J = w ? [
      `${a}Hover`,
      "hover",
      a,
      ""
    ] : [
      a,
      ""
    ], ae = j.getOptionScopes(this.getDataset(), Y), ce = Object.keys(ys.elements[a]), Te = () => this.getContext(g, w, d), be = j.resolveNamedOptions(ae, ce, Te, J);
    return be.$shared && (be.$shared = O, b[E] = Object.freeze(b1(be, O))), be;
  }
  _resolveAnimations(a, d, g) {
    const w = this.chart, b = this._cachedDataOpts, E = `animation-${d}`, i = b[E];
    if (i)
      return i;
    let O;
    if (w.options.animation !== !1) {
      const Y = this.chart.config, J = Y.datasetAnimationScopeKeys(this._type, d), ae = Y.getOptionScopes(this.getDataset(), J);
      O = Y.createResolver(ae, this.getContext(a, g, d));
    }
    const j = new $b(w, O && O.animations);
    return O && O._cacheable && (b[E] = Object.freeze(j)), j;
  }
  getSharedOptions(a) {
    if (a.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, a));
  }
  includeOptions(a, d) {
    return !d || Rg(a) || this.chart._animationsDisabled;
  }
  _getSharedOptions(a, d) {
    const g = this.resolveDataElementOptions(a, d), w = this._sharedOptions, b = this.getSharedOptions(g), E = this.includeOptions(d, b) || b !== w;
    return this.updateSharedOptions(b, d, g), {
      sharedOptions: b,
      includeOptions: E
    };
  }
  updateElement(a, d, g, w) {
    Rg(w) ? Object.assign(a, g) : this._resolveAnimations(d, w).update(a, g);
  }
  updateSharedOptions(a, d, g) {
    a && !Rg(d) && this._resolveAnimations(void 0, d).update(a, g);
  }
  _setStyle(a, d, g, w) {
    a.active = w;
    const b = this.getStyle(d, w);
    this._resolveAnimations(d, g, w).update(a, {
      options: !w && this.getSharedOptions(b) || b
    });
  }
  removeHoverStyle(a, d, g) {
    this._setStyle(a, g, "active", !1);
  }
  setHoverStyle(a, d, g) {
    this._setStyle(a, g, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const a = this._cachedMeta.dataset;
    a && this._setStyle(a, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const a = this._cachedMeta.dataset;
    a && this._setStyle(a, void 0, "active", !0);
  }
  _resyncElements(a) {
    const d = this._data, g = this._cachedMeta.data;
    for (const [i, O, j] of this._syncList)
      this[i](O, j);
    this._syncList = [];
    const w = g.length, b = d.length, E = Math.min(b, w);
    E && this.parse(0, E), b > w ? this._insertElements(w, b - w, a) : b < w && this._removeElements(b, w - b);
  }
  _insertElements(a, d, g = !0) {
    const w = this._cachedMeta, b = w.data, E = a + d;
    let i;
    const O = (j) => {
      for (j.length += d, i = j.length - 1; i >= E; i--)
        j[i] = j[i - d];
    };
    for (O(b), i = a; i < E; ++i)
      b[i] = new this.dataElementType();
    this._parsing && O(w._parsed), this.parse(a, d), g && this.updateElements(b, a, d, "reset");
  }
  updateElements(a, d, g, w) {
  }
  _removeElements(a, d) {
    const g = this._cachedMeta;
    if (this._parsing) {
      const w = g._parsed.splice(a, d);
      g._stacked && gf(g, w);
    }
    g.data.splice(a, d);
  }
  _sync(a) {
    if (this._parsing)
      this._syncList.push(a);
    else {
      const [d, g, w] = a;
      this[d](g, w);
    }
    this.chart._dataChanges.push([
      this.index,
      ...a
    ]);
  }
  _onDataPush() {
    const a = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - a,
      a
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(a, d) {
    d && this._sync([
      "_removeElements",
      a,
      d
    ]);
    const g = arguments.length - 2;
    g && this._sync([
      "_insertElements",
      a,
      g
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
Yt(za, "defaults", {}), Yt(za, "datasetElementType", null), Yt(za, "dataElementType", null);
function vE(m, a) {
  if (!m._cache.$bar) {
    const d = m.getMatchingVisibleMetas(a);
    let g = [];
    for (let w = 0, b = d.length; w < b; w++)
      g = g.concat(d[w].controller.getAllParsedValues(m));
    m._cache.$bar = Cb(g.sort((w, b) => w - b));
  }
  return m._cache.$bar;
}
function bE(m) {
  const a = m.iScale, d = vE(a, m.type);
  let g = a._length, w, b, E, i;
  const O = () => {
    E === 32767 || E === -32768 || (Of(i) && (g = Math.min(g, Math.abs(E - i) || g)), i = E);
  };
  for (w = 0, b = d.length; w < b; ++w)
    E = a.getPixelForValue(d[w]), O();
  for (i = void 0, w = 0, b = a.ticks.length; w < b; ++w)
    E = a.getPixelForTick(w), O();
  return g;
}
function wE(m, a, d, g) {
  const w = d.barThickness;
  let b, E;
  return En(w) ? (b = a.min * d.categoryPercentage, E = d.barPercentage) : (b = w * g, E = 1), {
    chunk: b / g,
    ratio: E,
    start: a.pixels[m] - b / 2
  };
}
function TE(m, a, d, g) {
  const w = a.pixels, b = w[m];
  let E = m > 0 ? w[m - 1] : null, i = m < w.length - 1 ? w[m + 1] : null;
  const O = d.categoryPercentage;
  E === null && (E = b - (i === null ? a.end - a.start : i - b)), i === null && (i = b + b - E);
  const j = b - (b - Math.min(E, i)) / 2 * O;
  return {
    chunk: Math.abs(i - E) / 2 * O / g,
    ratio: d.barPercentage,
    start: j
  };
}
function ME(m, a, d, g) {
  const w = d.parse(m[0], g), b = d.parse(m[1], g), E = Math.min(w, b), i = Math.max(w, b);
  let O = E, j = i;
  Math.abs(E) > Math.abs(i) && (O = i, j = E), a[d.axis] = j, a._custom = {
    barStart: O,
    barEnd: j,
    start: w,
    end: b,
    min: E,
    max: i
  };
}
function Yb(m, a, d, g) {
  return hs(m) ? ME(m, a, d, g) : a[d.axis] = d.parse(m, g), a;
}
function w1(m, a, d, g) {
  const w = m.iScale, b = m.vScale, E = w.getLabels(), i = w === b, O = [];
  let j, Y, J, ae;
  for (j = d, Y = d + g; j < Y; ++j)
    ae = a[j], J = {}, J[w.axis] = i || w.parse(E[j], j), O.push(Yb(ae, J, b, j));
  return O;
}
function Og(m) {
  return m && m.barStart !== void 0 && m.barEnd !== void 0;
}
function SE(m, a, d) {
  return m !== 0 ? ll(m) : (a.isHorizontal() ? 1 : -1) * (a.min >= d ? 1 : -1);
}
function EE(m) {
  let a, d, g, w, b;
  return m.horizontal ? (a = m.base > m.x, d = "left", g = "right") : (a = m.base < m.y, d = "bottom", g = "top"), a ? (w = "end", b = "start") : (w = "start", b = "end"), {
    start: d,
    end: g,
    reverse: a,
    top: w,
    bottom: b
  };
}
function AE(m, a, d, g) {
  let w = a.borderSkipped;
  const b = {};
  if (!w) {
    m.borderSkipped = b;
    return;
  }
  if (w === !0) {
    m.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: E, end: i, reverse: O, top: j, bottom: Y } = EE(m);
  w === "middle" && d && (m.enableBorderRadius = !0, (d._top || 0) === g ? w = j : (d._bottom || 0) === g ? w = Y : (b[T1(Y, E, i, O)] = !0, w = j)), b[T1(w, E, i, O)] = !0, m.borderSkipped = b;
}
function T1(m, a, d, g) {
  return g ? (m = PE(m, a, d), m = M1(m, d, a)) : m = M1(m, a, d), m;
}
function PE(m, a, d) {
  return m === a ? d : m === d ? a : m;
}
function M1(m, a, d) {
  return m === "start" ? a : m === "end" ? d : m;
}
function CE(m, { inflateAmount: a }, d) {
  m.inflateAmount = a === "auto" ? d === 1 ? 0.33 : 0 : a;
}
class Am extends za {
  parsePrimitiveData(a, d, g, w) {
    return w1(a, d, g, w);
  }
  parseArrayData(a, d, g, w) {
    return w1(a, d, g, w);
  }
  parseObjectData(a, d, g, w) {
    const { iScale: b, vScale: E } = a, { xAxisKey: i = "x", yAxisKey: O = "y" } = this._parsing, j = b.axis === "x" ? i : O, Y = E.axis === "x" ? i : O, J = [];
    let ae, ce, Te, be;
    for (ae = g, ce = g + w; ae < ce; ++ae)
      be = d[ae], Te = {}, Te[b.axis] = b.parse(Rc(be, j), ae), J.push(Yb(Rc(be, Y), Te, E, ae));
    return J;
  }
  updateRangeFromParsed(a, d, g, w) {
    super.updateRangeFromParsed(a, d, g, w);
    const b = g._custom;
    b && d === this._cachedMeta.vScale && (a.min = Math.min(a.min, b.min), a.max = Math.max(a.max, b.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(a) {
    const d = this._cachedMeta, { iScale: g, vScale: w } = d, b = this.getParsed(a), E = b._custom, i = Og(E) ? "[" + E.start + ", " + E.end + "]" : "" + w.getLabelForValue(b[w.axis]);
    return {
      label: "" + g.getLabelForValue(b[g.axis]),
      value: i
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const a = this._cachedMeta;
    a.stack = this.getDataset().stack;
  }
  update(a) {
    const d = this._cachedMeta;
    this.updateElements(d.data, 0, d.data.length, a);
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", { index: E, _cachedMeta: { vScale: i } } = this, O = i.getBasePixel(), j = i.isHorizontal(), Y = this._getRuler(), { sharedOptions: J, includeOptions: ae } = this._getSharedOptions(d, w);
    for (let ce = d; ce < d + g; ce++) {
      const Te = this.getParsed(ce), be = b || En(Te[i.axis]) ? {
        base: O,
        head: O
      } : this._calculateBarValuePixels(ce), Ze = this._calculateBarIndexPixels(ce, Y), je = (Te._stacks || {})[i.axis], ot = {
        horizontal: j,
        base: be.base,
        enableBorderRadius: !je || Og(Te._custom) || E === je._top || E === je._bottom,
        x: j ? be.head : Ze.center,
        y: j ? Ze.center : be.head,
        height: j ? Ze.size : Math.abs(be.size),
        width: j ? Math.abs(be.size) : Ze.size
      };
      ae && (ot.options = J || this.resolveDataElementOptions(ce, a[ce].active ? "active" : w));
      const vt = ot.options || a[ce].options;
      AE(ot, vt, je, E), CE(ot, vt, Y.ratio), this.updateElement(a[ce], ce, ot, w);
    }
  }
  _getStacks(a, d) {
    const { iScale: g } = this._cachedMeta, w = g.getMatchingVisibleMetas(this._type).filter((Y) => Y.controller.options.grouped), b = g.options.stacked, E = [], i = this._cachedMeta.controller.getParsed(d), O = i && i[g.axis], j = (Y) => {
      const J = Y._parsed.find((ce) => ce[g.axis] === O), ae = J && J[Y.vScale.axis];
      if (En(ae) || isNaN(ae))
        return !0;
    };
    for (const Y of w)
      if (!(d !== void 0 && j(Y)) && ((b === !1 || E.indexOf(Y.stack) === -1 || b === void 0 && Y.stack === void 0) && E.push(Y.stack), Y.index === a))
        break;
    return E.length || E.push(void 0), E;
  }
  _getStackCount(a) {
    return this._getStacks(void 0, a).length;
  }
  _getStackIndex(a, d, g) {
    const w = this._getStacks(a, g), b = d !== void 0 ? w.indexOf(d) : -1;
    return b === -1 ? w.length - 1 : b;
  }
  _getRuler() {
    const a = this.options, d = this._cachedMeta, g = d.iScale, w = [];
    let b, E;
    for (b = 0, E = d.data.length; b < E; ++b)
      w.push(g.getPixelForValue(this.getParsed(b)[g.axis], b));
    const i = a.barThickness;
    return {
      min: i || bE(d),
      pixels: w,
      start: g._startPixel,
      end: g._endPixel,
      stackCount: this._getStackCount(),
      scale: g,
      grouped: a.grouped,
      ratio: i ? 1 : a.categoryPercentage * a.barPercentage
    };
  }
  _calculateBarValuePixels(a) {
    const { _cachedMeta: { vScale: d, _stacked: g, index: w }, options: { base: b, minBarLength: E } } = this, i = b || 0, O = this.getParsed(a), j = O._custom, Y = Og(j);
    let J = O[d.axis], ae = 0, ce = g ? this.applyStack(d, O, g) : J, Te, be;
    ce !== J && (ae = ce - J, ce = J), Y && (J = j.barStart, ce = j.barEnd - j.barStart, J !== 0 && ll(J) !== ll(j.barEnd) && (ae = 0), ae += J);
    const Ze = !En(b) && !Y ? b : ae;
    let je = d.getPixelForValue(Ze);
    if (this.chart.getDataVisibility(a) ? Te = d.getPixelForValue(ae + ce) : Te = je, be = Te - je, Math.abs(be) < E) {
      be = SE(be, d, i) * E, J === i && (je -= be / 2);
      const ot = d.getPixelForDecimal(0), vt = d.getPixelForDecimal(1), ht = Math.min(ot, vt), gt = Math.max(ot, vt);
      je = Math.max(Math.min(je, gt), ht), Te = je + be, g && !Y && (O._stacks[d.axis]._visualValues[w] = d.getValueForPixel(Te) - d.getValueForPixel(je));
    }
    if (je === d.getPixelForValue(i)) {
      const ot = ll(be) * d.getLineWidthForValue(i) / 2;
      je += ot, be -= ot;
    }
    return {
      size: be,
      base: je,
      head: Te,
      center: Te + be / 2
    };
  }
  _calculateBarIndexPixels(a, d) {
    const g = d.scale, w = this.options, b = w.skipNull, E = en(w.maxBarThickness, 1 / 0);
    let i, O;
    if (d.grouped) {
      const j = b ? this._getStackCount(a) : d.stackCount, Y = w.barThickness === "flex" ? TE(a, d, w, j) : wE(a, d, w, j), J = this._getStackIndex(this.index, this._cachedMeta.stack, b ? a : void 0);
      i = Y.start + Y.chunk * J + Y.chunk / 2, O = Math.min(E, Y.chunk * Y.ratio);
    } else
      i = g.getPixelForValue(this.getParsed(a)[g.axis], a), O = Math.min(E, d.min * d.ratio);
    return {
      base: i - O / 2,
      head: i + O / 2,
      center: i,
      size: O
    };
  }
  draw() {
    const a = this._cachedMeta, d = a.vScale, g = a.data, w = g.length;
    let b = 0;
    for (; b < w; ++b)
      this.getParsed(b)[d.axis] !== null && !g[b].hidden && g[b].draw(this._ctx);
  }
}
Yt(Am, "id", "bar"), Yt(Am, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), Yt(Am, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class Pm extends za {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(a, d, g, w) {
    const b = super.parsePrimitiveData(a, d, g, w);
    for (let E = 0; E < b.length; E++)
      b[E]._custom = this.resolveDataElementOptions(E + g).radius;
    return b;
  }
  parseArrayData(a, d, g, w) {
    const b = super.parseArrayData(a, d, g, w);
    for (let E = 0; E < b.length; E++) {
      const i = d[g + E];
      b[E]._custom = en(i[2], this.resolveDataElementOptions(E + g).radius);
    }
    return b;
  }
  parseObjectData(a, d, g, w) {
    const b = super.parseObjectData(a, d, g, w);
    for (let E = 0; E < b.length; E++) {
      const i = d[g + E];
      b[E]._custom = en(i && i.r && +i.r, this.resolveDataElementOptions(E + g).radius);
    }
    return b;
  }
  getMaxOverflow() {
    const a = this._cachedMeta.data;
    let d = 0;
    for (let g = a.length - 1; g >= 0; --g)
      d = Math.max(d, a[g].size(this.resolveDataElementOptions(g)) / 2);
    return d > 0 && d;
  }
  getLabelAndValue(a) {
    const d = this._cachedMeta, g = this.chart.data.labels || [], { xScale: w, yScale: b } = d, E = this.getParsed(a), i = w.getLabelForValue(E.x), O = b.getLabelForValue(E.y), j = E._custom;
    return {
      label: g[a] || "",
      value: "(" + i + ", " + O + (j ? ", " + j : "") + ")"
    };
  }
  update(a) {
    const d = this._cachedMeta.data;
    this.updateElements(d, 0, d.length, a);
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", { iScale: E, vScale: i } = this._cachedMeta, { sharedOptions: O, includeOptions: j } = this._getSharedOptions(d, w), Y = E.axis, J = i.axis;
    for (let ae = d; ae < d + g; ae++) {
      const ce = a[ae], Te = !b && this.getParsed(ae), be = {}, Ze = be[Y] = b ? E.getPixelForDecimal(0.5) : E.getPixelForValue(Te[Y]), je = be[J] = b ? i.getBasePixel() : i.getPixelForValue(Te[J]);
      be.skip = isNaN(Ze) || isNaN(je), j && (be.options = O || this.resolveDataElementOptions(ae, ce.active ? "active" : w), b && (be.options.radius = 0)), this.updateElement(ce, ae, be, w);
    }
  }
  resolveDataElementOptions(a, d) {
    const g = this.getParsed(a);
    let w = super.resolveDataElementOptions(a, d);
    w.$shared && (w = Object.assign({}, w, {
      $shared: !1
    }));
    const b = w.radius;
    return d !== "active" && (w.radius = 0), w.radius += en(g && g._custom, b), w;
  }
}
Yt(Pm, "id", "bubble"), Yt(Pm, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), Yt(Pm, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function IE(m, a, d) {
  let g = 1, w = 1, b = 0, E = 0;
  if (a < us) {
    const i = m, O = i + a, j = Math.cos(i), Y = Math.sin(i), J = Math.cos(O), ae = Math.sin(O), ce = (vt, ht, gt) => Ff(vt, i, O, !0) ? 1 : Math.max(ht, ht * d, gt, gt * d), Te = (vt, ht, gt) => Ff(vt, i, O, !0) ? -1 : Math.min(ht, ht * d, gt, gt * d), be = ce(0, j, J), Ze = ce(Ns, Y, ae), je = Te(ds, j, J), ot = Te(ds + Ns, Y, ae);
    g = (be - je) / 2, w = (Ze - ot) / 2, b = -(be + je) / 2, E = -(Ze + ot) / 2;
  }
  return {
    ratioX: g,
    ratioY: w,
    offsetX: b,
    offsetY: E
  };
}
class Dh extends za {
  constructor(a, d) {
    super(a, d), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(a, d) {
    const g = this.getDataset().data, w = this._cachedMeta;
    if (this._parsing === !1)
      w._parsed = g;
    else {
      let b = (O) => +g[O];
      if (yn(g[a])) {
        const { key: O = "value" } = this._parsing;
        b = (j) => +Rc(g[j], O);
      }
      let E, i;
      for (E = a, i = a + d; E < i; ++E)
        w._parsed[E] = b(E);
    }
  }
  _getRotation() {
    return Ia(this.options.rotation - 90);
  }
  _getCircumference() {
    return Ia(this.options.circumference);
  }
  _getRotationExtents() {
    let a = us, d = -us;
    for (let g = 0; g < this.chart.data.datasets.length; ++g)
      if (this.chart.isDatasetVisible(g) && this.chart.getDatasetMeta(g).type === this._type) {
        const w = this.chart.getDatasetMeta(g).controller, b = w._getRotation(), E = w._getCircumference();
        a = Math.min(a, b), d = Math.max(d, b + E);
      }
    return {
      rotation: a,
      circumference: d - a
    };
  }
  update(a) {
    const d = this.chart, { chartArea: g } = d, w = this._cachedMeta, b = w.data, E = this.getMaxBorderWidth() + this.getMaxOffset(b) + this.options.spacing, i = Math.max((Math.min(g.width, g.height) - E) / 2, 0), O = Math.min(ZM(this.options.cutout, i), 1), j = this._getRingWeight(this.index), { circumference: Y, rotation: J } = this._getRotationExtents(), { ratioX: ae, ratioY: ce, offsetX: Te, offsetY: be } = IE(J, Y, O), Ze = (g.width - E) / ae, je = (g.height - E) / ce, ot = Math.max(Math.min(Ze, je) / 2, 0), vt = Mb(this.options.radius, ot), ht = Math.max(vt * O, 0), gt = (vt - ht) / this._getVisibleDatasetWeightTotal();
    this.offsetX = Te * vt, this.offsetY = be * vt, w.total = this.calculateTotal(), this.outerRadius = vt - gt * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - gt * j, 0), this.updateElements(b, 0, b.length, a);
  }
  _circumference(a, d) {
    const g = this.options, w = this._cachedMeta, b = this._getCircumference();
    return d && g.animation.animateRotate || !this.chart.getDataVisibility(a) || w._parsed[a] === null || w.data[a].hidden ? 0 : this.calculateCircumference(w._parsed[a] * b / us);
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", E = this.chart, i = E.chartArea, j = E.options.animation, Y = (i.left + i.right) / 2, J = (i.top + i.bottom) / 2, ae = b && j.animateScale, ce = ae ? 0 : this.innerRadius, Te = ae ? 0 : this.outerRadius, { sharedOptions: be, includeOptions: Ze } = this._getSharedOptions(d, w);
    let je = this._getRotation(), ot;
    for (ot = 0; ot < d; ++ot)
      je += this._circumference(ot, b);
    for (ot = d; ot < d + g; ++ot) {
      const vt = this._circumference(ot, b), ht = a[ot], gt = {
        x: Y + this.offsetX,
        y: J + this.offsetY,
        startAngle: je,
        endAngle: je + vt,
        circumference: vt,
        outerRadius: Te,
        innerRadius: ce
      };
      Ze && (gt.options = be || this.resolveDataElementOptions(ot, ht.active ? "active" : w)), je += vt, this.updateElement(ht, ot, gt, w);
    }
  }
  calculateTotal() {
    const a = this._cachedMeta, d = a.data;
    let g = 0, w;
    for (w = 0; w < d.length; w++) {
      const b = a._parsed[w];
      b !== null && !isNaN(b) && this.chart.getDataVisibility(w) && !d[w].hidden && (g += Math.abs(b));
    }
    return g;
  }
  calculateCircumference(a) {
    const d = this._cachedMeta.total;
    return d > 0 && !isNaN(a) ? us * (Math.abs(a) / d) : 0;
  }
  getLabelAndValue(a) {
    const d = this._cachedMeta, g = this.chart, w = g.data.labels || [], b = Zf(d._parsed[a], g.options.locale);
    return {
      label: w[a] || "",
      value: b
    };
  }
  getMaxBorderWidth(a) {
    let d = 0;
    const g = this.chart;
    let w, b, E, i, O;
    if (!a) {
      for (w = 0, b = g.data.datasets.length; w < b; ++w)
        if (g.isDatasetVisible(w)) {
          E = g.getDatasetMeta(w), a = E.data, i = E.controller;
          break;
        }
    }
    if (!a)
      return 0;
    for (w = 0, b = a.length; w < b; ++w)
      O = i.resolveDataElementOptions(w), O.borderAlign !== "inner" && (d = Math.max(d, O.borderWidth || 0, O.hoverBorderWidth || 0));
    return d;
  }
  getMaxOffset(a) {
    let d = 0;
    for (let g = 0, w = a.length; g < w; ++g) {
      const b = this.resolveDataElementOptions(g);
      d = Math.max(d, b.offset || 0, b.hoverOffset || 0);
    }
    return d;
  }
  _getRingWeightOffset(a) {
    let d = 0;
    for (let g = 0; g < a; ++g)
      this.chart.isDatasetVisible(g) && (d += this._getRingWeight(g));
    return d;
  }
  _getRingWeight(a) {
    return Math.max(en(this.chart.data.datasets[a].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Yt(Dh, "id", "doughnut"), Yt(Dh, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), Yt(Dh, "descriptors", {
  _scriptable: (a) => a !== "spacing",
  _indexable: (a) => a !== "spacing" && !a.startsWith("borderDash") && !a.startsWith("hoverBorderDash")
}), Yt(Dh, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(a) {
          const d = a.data;
          if (d.labels.length && d.datasets.length) {
            const { labels: { pointStyle: g, color: w } } = a.legend.options;
            return d.labels.map((b, E) => {
              const O = a.getDatasetMeta(0).controller.getStyle(E);
              return {
                text: b,
                fillStyle: O.backgroundColor,
                strokeStyle: O.borderColor,
                fontColor: w,
                lineWidth: O.borderWidth,
                pointStyle: g,
                hidden: !a.getDataVisibility(E),
                index: E
              };
            });
          }
          return [];
        }
      },
      onClick(a, d, g) {
        g.chart.toggleDataVisibility(d.index), g.chart.update();
      }
    }
  }
});
class Cm extends za {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(a) {
    const d = this._cachedMeta, { dataset: g, data: w = [], _dataset: b } = d, E = this.chart._animationsDisabled;
    let { start: i, count: O } = zb(d, w, E);
    this._drawStart = i, this._drawCount = O, Db(d) && (i = 0, O = w.length), g._chart = this.chart, g._datasetIndex = this.index, g._decimated = !!b._decimated, g.points = w;
    const j = this.resolveDatasetElementOptions(a);
    this.options.showLine || (j.borderWidth = 0), j.segment = this.options.segment, this.updateElement(g, void 0, {
      animated: !E,
      options: j
    }, a), this.updateElements(w, i, O, a);
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", { iScale: E, vScale: i, _stacked: O, _dataset: j } = this._cachedMeta, { sharedOptions: Y, includeOptions: J } = this._getSharedOptions(d, w), ae = E.axis, ce = i.axis, { spanGaps: Te, segment: be } = this.options, Ze = Xu(Te) ? Te : Number.POSITIVE_INFINITY, je = this.chart._animationsDisabled || b || w === "none", ot = d + g, vt = a.length;
    let ht = d > 0 && this.getParsed(d - 1);
    for (let gt = 0; gt < vt; ++gt) {
      const Vt = a[gt], pt = je ? Vt : {};
      if (gt < d || gt >= ot) {
        pt.skip = !0;
        continue;
      }
      const Gt = this.getParsed(gt), ui = En(Gt[ce]), kt = pt[ae] = E.getPixelForValue(Gt[ae], gt), At = pt[ce] = b || ui ? i.getBasePixel() : i.getPixelForValue(O ? this.applyStack(i, Gt, O) : Gt[ce], gt);
      pt.skip = isNaN(kt) || isNaN(At) || ui, pt.stop = gt > 0 && Math.abs(Gt[ae] - ht[ae]) > Ze, be && (pt.parsed = Gt, pt.raw = j.data[gt]), J && (pt.options = Y || this.resolveDataElementOptions(gt, Vt.active ? "active" : w)), je || this.updateElement(Vt, gt, pt, w), ht = Gt;
    }
  }
  getMaxOverflow() {
    const a = this._cachedMeta, d = a.dataset, g = d.options && d.options.borderWidth || 0, w = a.data || [];
    if (!w.length)
      return g;
    const b = w[0].size(this.resolveDataElementOptions(0)), E = w[w.length - 1].size(this.resolveDataElementOptions(w.length - 1));
    return Math.max(g, b, E) / 2;
  }
  draw() {
    const a = this._cachedMeta;
    a.dataset.updateControlPoints(this.chart.chartArea, a.iScale.axis), super.draw();
  }
}
Yt(Cm, "id", "line"), Yt(Cm, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), Yt(Cm, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Df extends za {
  constructor(a, d) {
    super(a, d), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(a) {
    const d = this._cachedMeta, g = this.chart, w = g.data.labels || [], b = Zf(d._parsed[a].r, g.options.locale);
    return {
      label: w[a] || "",
      value: b
    };
  }
  parseObjectData(a, d, g, w) {
    return Ub.bind(this)(a, d, g, w);
  }
  update(a) {
    const d = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(d, 0, d.length, a);
  }
  getMinMax() {
    const a = this._cachedMeta, d = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return a.data.forEach((g, w) => {
      const b = this.getParsed(w).r;
      !isNaN(b) && this.chart.getDataVisibility(w) && (b < d.min && (d.min = b), b > d.max && (d.max = b));
    }), d;
  }
  _updateRadius() {
    const a = this.chart, d = a.chartArea, g = a.options, w = Math.min(d.right - d.left, d.bottom - d.top), b = Math.max(w / 2, 0), E = Math.max(g.cutoutPercentage ? b / 100 * g.cutoutPercentage : 1, 0), i = (b - E) / a.getVisibleDatasetCount();
    this.outerRadius = b - i * this.index, this.innerRadius = this.outerRadius - i;
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", E = this.chart, O = E.options.animation, j = this._cachedMeta.rScale, Y = j.xCenter, J = j.yCenter, ae = j.getIndexAngle(0) - 0.5 * ds;
    let ce = ae, Te;
    const be = 360 / this.countVisibleElements();
    for (Te = 0; Te < d; ++Te)
      ce += this._computeAngle(Te, w, be);
    for (Te = d; Te < d + g; Te++) {
      const Ze = a[Te];
      let je = ce, ot = ce + this._computeAngle(Te, w, be), vt = E.getDataVisibility(Te) ? j.getDistanceFromCenterForValue(this.getParsed(Te).r) : 0;
      ce = ot, b && (O.animateScale && (vt = 0), O.animateRotate && (je = ot = ae));
      const ht = {
        x: Y,
        y: J,
        innerRadius: 0,
        outerRadius: vt,
        startAngle: je,
        endAngle: ot,
        options: this.resolveDataElementOptions(Te, Ze.active ? "active" : w)
      };
      this.updateElement(Ze, Te, ht, w);
    }
  }
  countVisibleElements() {
    const a = this._cachedMeta;
    let d = 0;
    return a.data.forEach((g, w) => {
      !isNaN(this.getParsed(w).r) && this.chart.getDataVisibility(w) && d++;
    }), d;
  }
  _computeAngle(a, d, g) {
    return this.chart.getDataVisibility(a) ? Ia(this.resolveDataElementOptions(a, d).angle || g) : 0;
  }
}
Yt(Df, "id", "polarArea"), Yt(Df, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), Yt(Df, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(a) {
          const d = a.data;
          if (d.labels.length && d.datasets.length) {
            const { labels: { pointStyle: g, color: w } } = a.legend.options;
            return d.labels.map((b, E) => {
              const O = a.getDatasetMeta(0).controller.getStyle(E);
              return {
                text: b,
                fillStyle: O.backgroundColor,
                strokeStyle: O.borderColor,
                fontColor: w,
                lineWidth: O.borderWidth,
                pointStyle: g,
                hidden: !a.getDataVisibility(E),
                index: E
              };
            });
          }
          return [];
        }
      },
      onClick(a, d, g) {
        g.chart.toggleDataVisibility(d.index), g.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class Wg extends Dh {
}
Yt(Wg, "id", "pie"), Yt(Wg, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Im extends za {
  getLabelAndValue(a) {
    const d = this._cachedMeta.vScale, g = this.getParsed(a);
    return {
      label: d.getLabels()[a],
      value: "" + d.getLabelForValue(g[d.axis])
    };
  }
  parseObjectData(a, d, g, w) {
    return Ub.bind(this)(a, d, g, w);
  }
  update(a) {
    const d = this._cachedMeta, g = d.dataset, w = d.data || [], b = d.iScale.getLabels();
    if (g.points = w, a !== "resize") {
      const E = this.resolveDatasetElementOptions(a);
      this.options.showLine || (E.borderWidth = 0);
      const i = {
        _loop: !0,
        _fullLoop: b.length === w.length,
        options: E
      };
      this.updateElement(g, void 0, i, a);
    }
    this.updateElements(w, 0, w.length, a);
  }
  updateElements(a, d, g, w) {
    const b = this._cachedMeta.rScale, E = w === "reset";
    for (let i = d; i < d + g; i++) {
      const O = a[i], j = this.resolveDataElementOptions(i, O.active ? "active" : w), Y = b.getPointPositionForValue(i, this.getParsed(i).r), J = E ? b.xCenter : Y.x, ae = E ? b.yCenter : Y.y, ce = {
        x: J,
        y: ae,
        angle: Y.angle,
        skip: isNaN(J) || isNaN(ae),
        options: j
      };
      this.updateElement(O, i, ce, w);
    }
  }
}
Yt(Im, "id", "radar"), Yt(Im, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), Yt(Im, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class Lm extends za {
  getLabelAndValue(a) {
    const d = this._cachedMeta, g = this.chart.data.labels || [], { xScale: w, yScale: b } = d, E = this.getParsed(a), i = w.getLabelForValue(E.x), O = b.getLabelForValue(E.y);
    return {
      label: g[a] || "",
      value: "(" + i + ", " + O + ")"
    };
  }
  update(a) {
    const d = this._cachedMeta, { data: g = [] } = d, w = this.chart._animationsDisabled;
    let { start: b, count: E } = zb(d, g, w);
    if (this._drawStart = b, this._drawCount = E, Db(d) && (b = 0, E = g.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: i, _dataset: O } = d;
      i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!O._decimated, i.points = g;
      const j = this.resolveDatasetElementOptions(a);
      j.segment = this.options.segment, this.updateElement(i, void 0, {
        animated: !w,
        options: j
      }, a);
    } else
      this.datasetElementType && (delete d.dataset, this.datasetElementType = !1);
    this.updateElements(g, b, E, a);
  }
  addElements() {
    const { showLine: a } = this.options;
    !this.datasetElementType && a && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(a, d, g, w) {
    const b = w === "reset", { iScale: E, vScale: i, _stacked: O, _dataset: j } = this._cachedMeta, Y = this.resolveDataElementOptions(d, w), J = this.getSharedOptions(Y), ae = this.includeOptions(w, J), ce = E.axis, Te = i.axis, { spanGaps: be, segment: Ze } = this.options, je = Xu(be) ? be : Number.POSITIVE_INFINITY, ot = this.chart._animationsDisabled || b || w === "none";
    let vt = d > 0 && this.getParsed(d - 1);
    for (let ht = d; ht < d + g; ++ht) {
      const gt = a[ht], Vt = this.getParsed(ht), pt = ot ? gt : {}, Gt = En(Vt[Te]), ui = pt[ce] = E.getPixelForValue(Vt[ce], ht), kt = pt[Te] = b || Gt ? i.getBasePixel() : i.getPixelForValue(O ? this.applyStack(i, Vt, O) : Vt[Te], ht);
      pt.skip = isNaN(ui) || isNaN(kt) || Gt, pt.stop = ht > 0 && Math.abs(Vt[ce] - vt[ce]) > je, Ze && (pt.parsed = Vt, pt.raw = j.data[ht]), ae && (pt.options = J || this.resolveDataElementOptions(ht, gt.active ? "active" : w)), ot || this.updateElement(gt, ht, pt, w), vt = Vt;
    }
    this.updateSharedOptions(J, w, Y);
  }
  getMaxOverflow() {
    const a = this._cachedMeta, d = a.data || [];
    if (!this.options.showLine) {
      let i = 0;
      for (let O = d.length - 1; O >= 0; --O)
        i = Math.max(i, d[O].size(this.resolveDataElementOptions(O)) / 2);
      return i > 0 && i;
    }
    const g = a.dataset, w = g.options && g.options.borderWidth || 0;
    if (!d.length)
      return w;
    const b = d[0].size(this.resolveDataElementOptions(0)), E = d[d.length - 1].size(this.resolveDataElementOptions(d.length - 1));
    return Math.max(w, b, E) / 2;
  }
}
Yt(Lm, "id", "scatter"), Yt(Lm, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), Yt(Lm, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var LE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: Am,
  BubbleController: Pm,
  DoughnutController: Dh,
  LineController: Cm,
  PieController: Wg,
  PolarAreaController: Df,
  RadarController: Im,
  ScatterController: Lm
});
function Ch() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class by {
  constructor(a) {
    Yt(this, "options");
    this.options = a || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(a) {
    Object.assign(by.prototype, a);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Ch();
  }
  parse() {
    return Ch();
  }
  format() {
    return Ch();
  }
  add() {
    return Ch();
  }
  diff() {
    return Ch();
  }
  startOf() {
    return Ch();
  }
  endOf() {
    return Ch();
  }
}
var zE = {
  _date: by
};
function DE(m, a, d, g) {
  const { controller: w, data: b, _sorted: E } = m, i = w._cachedMeta.iScale;
  if (i && a === i.axis && a !== "r" && E && b.length) {
    const O = i._reversePixels ? iS : Vl;
    if (g) {
      if (w._sharedOptions) {
        const j = b[0], Y = typeof j.getRange == "function" && j.getRange(a);
        if (Y) {
          const J = O(b, a, d - Y), ae = O(b, a, d + Y);
          return {
            lo: J.lo,
            hi: ae.hi
          };
        }
      }
    } else
      return O(b, a, d);
  }
  return {
    lo: 0,
    hi: b.length - 1
  };
}
function Hf(m, a, d, g, w) {
  const b = m.getSortedVisibleDatasetMetas(), E = d[a];
  for (let i = 0, O = b.length; i < O; ++i) {
    const { index: j, data: Y } = b[i], { lo: J, hi: ae } = DE(b[i], a, E, w);
    for (let ce = J; ce <= ae; ++ce) {
      const Te = Y[ce];
      Te.skip || g(Te, j, ce);
    }
  }
}
function kE(m) {
  const a = m.indexOf("x") !== -1, d = m.indexOf("y") !== -1;
  return function(g, w) {
    const b = a ? Math.abs(g.x - w.x) : 0, E = d ? Math.abs(g.y - w.y) : 0;
    return Math.sqrt(Math.pow(b, 2) + Math.pow(E, 2));
  };
}
function Fg(m, a, d, g, w) {
  const b = [];
  return !w && !m.isPointInArea(a) || Hf(m, d, a, function(i, O, j) {
    !w && !Ul(i, m.chartArea, 0) || i.inRange(a.x, a.y, g) && b.push({
      element: i,
      datasetIndex: O,
      index: j
    });
  }, !0), b;
}
function RE(m, a, d, g) {
  let w = [];
  function b(E, i, O) {
    const { startAngle: j, endAngle: Y } = E.getProps([
      "startAngle",
      "endAngle"
    ], g), { angle: J } = Ab(E, {
      x: a.x,
      y: a.y
    });
    Ff(J, j, Y) && w.push({
      element: E,
      datasetIndex: i,
      index: O
    });
  }
  return Hf(m, d, a, b), w;
}
function OE(m, a, d, g, w, b) {
  let E = [];
  const i = kE(d);
  let O = Number.POSITIVE_INFINITY;
  function j(Y, J, ae) {
    const ce = Y.inRange(a.x, a.y, w);
    if (g && !ce)
      return;
    const Te = Y.getCenterPoint(w);
    if (!(!!b || m.isPointInArea(Te)) && !ce)
      return;
    const Ze = i(a, Te);
    Ze < O ? (E = [
      {
        element: Y,
        datasetIndex: J,
        index: ae
      }
    ], O = Ze) : Ze === O && E.push({
      element: Y,
      datasetIndex: J,
      index: ae
    });
  }
  return Hf(m, d, a, j), E;
}
function Bg(m, a, d, g, w, b) {
  return !b && !m.isPointInArea(a) ? [] : d === "r" && !g ? RE(m, a, d, w) : OE(m, a, d, g, w, b);
}
function S1(m, a, d, g, w) {
  const b = [], E = d === "x" ? "inXRange" : "inYRange";
  let i = !1;
  return Hf(m, d, a, (O, j, Y) => {
    O[E] && O[E](a[d], w) && (b.push({
      element: O,
      datasetIndex: j,
      index: Y
    }), i = i || O.inRange(a.x, a.y, w));
  }), g && !i ? [] : b;
}
var FE = {
  evaluateInteractionItems: Hf,
  modes: {
    index(m, a, d, g) {
      const w = Lh(a, m), b = d.axis || "x", E = d.includeInvisible || !1, i = d.intersect ? Fg(m, w, b, g, E) : Bg(m, w, b, !1, g, E), O = [];
      return i.length ? (m.getSortedVisibleDatasetMetas().forEach((j) => {
        const Y = i[0].index, J = j.data[Y];
        J && !J.skip && O.push({
          element: J,
          datasetIndex: j.index,
          index: Y
        });
      }), O) : [];
    },
    dataset(m, a, d, g) {
      const w = Lh(a, m), b = d.axis || "xy", E = d.includeInvisible || !1;
      let i = d.intersect ? Fg(m, w, b, g, E) : Bg(m, w, b, !1, g, E);
      if (i.length > 0) {
        const O = i[0].datasetIndex, j = m.getDatasetMeta(O).data;
        i = [];
        for (let Y = 0; Y < j.length; ++Y)
          i.push({
            element: j[Y],
            datasetIndex: O,
            index: Y
          });
      }
      return i;
    },
    point(m, a, d, g) {
      const w = Lh(a, m), b = d.axis || "xy", E = d.includeInvisible || !1;
      return Fg(m, w, b, g, E);
    },
    nearest(m, a, d, g) {
      const w = Lh(a, m), b = d.axis || "xy", E = d.includeInvisible || !1;
      return Bg(m, w, b, d.intersect, g, E);
    },
    x(m, a, d, g) {
      const w = Lh(a, m);
      return S1(m, w, "x", d.intersect, g);
    },
    y(m, a, d, g) {
      const w = Lh(a, m);
      return S1(m, w, "y", d.intersect, g);
    }
  }
};
const Kb = [
  "left",
  "top",
  "right",
  "bottom"
];
function yf(m, a) {
  return m.filter((d) => d.pos === a);
}
function E1(m, a) {
  return m.filter((d) => Kb.indexOf(d.pos) === -1 && d.box.axis === a);
}
function xf(m, a) {
  return m.sort((d, g) => {
    const w = a ? g : d, b = a ? d : g;
    return w.weight === b.weight ? w.index - b.index : w.weight - b.weight;
  });
}
function BE(m) {
  const a = [];
  let d, g, w, b, E, i;
  for (d = 0, g = (m || []).length; d < g; ++d)
    w = m[d], { position: b, options: { stack: E, stackWeight: i = 1 } } = w, a.push({
      index: d,
      box: w,
      pos: b,
      horizontal: w.isHorizontal(),
      weight: w.weight,
      stack: E && b + E,
      stackWeight: i
    });
  return a;
}
function NE(m) {
  const a = {};
  for (const d of m) {
    const { stack: g, pos: w, stackWeight: b } = d;
    if (!g || !Kb.includes(w))
      continue;
    const E = a[g] || (a[g] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    E.count++, E.weight += b;
  }
  return a;
}
function VE(m, a) {
  const d = NE(m), { vBoxMaxWidth: g, hBoxMaxHeight: w } = a;
  let b, E, i;
  for (b = 0, E = m.length; b < E; ++b) {
    i = m[b];
    const { fullSize: O } = i.box, j = d[i.stack], Y = j && i.stackWeight / j.weight;
    i.horizontal ? (i.width = Y ? Y * g : O && a.availableWidth, i.height = w) : (i.width = g, i.height = Y ? Y * w : O && a.availableHeight);
  }
  return d;
}
function UE(m) {
  const a = BE(m), d = xf(a.filter((j) => j.box.fullSize), !0), g = xf(yf(a, "left"), !0), w = xf(yf(a, "right")), b = xf(yf(a, "top"), !0), E = xf(yf(a, "bottom")), i = E1(a, "x"), O = E1(a, "y");
  return {
    fullSize: d,
    leftAndTop: g.concat(b),
    rightAndBottom: w.concat(O).concat(E).concat(i),
    chartArea: yf(a, "chartArea"),
    vertical: g.concat(w).concat(O),
    horizontal: b.concat(E).concat(i)
  };
}
function A1(m, a, d, g) {
  return Math.max(m[d], a[d]) + Math.max(m[g], a[g]);
}
function Jb(m, a) {
  m.top = Math.max(m.top, a.top), m.left = Math.max(m.left, a.left), m.bottom = Math.max(m.bottom, a.bottom), m.right = Math.max(m.right, a.right);
}
function jE(m, a, d, g) {
  const { pos: w, box: b } = d, E = m.maxPadding;
  if (!yn(w)) {
    d.size && (m[w] -= d.size);
    const J = g[d.stack] || {
      size: 0,
      count: 1
    };
    J.size = Math.max(J.size, d.horizontal ? b.height : b.width), d.size = J.size / J.count, m[w] += d.size;
  }
  b.getPadding && Jb(E, b.getPadding());
  const i = Math.max(0, a.outerWidth - A1(E, m, "left", "right")), O = Math.max(0, a.outerHeight - A1(E, m, "top", "bottom")), j = i !== m.w, Y = O !== m.h;
  return m.w = i, m.h = O, d.horizontal ? {
    same: j,
    other: Y
  } : {
    same: Y,
    other: j
  };
}
function GE(m) {
  const a = m.maxPadding;
  function d(g) {
    const w = Math.max(a[g] - m[g], 0);
    return m[g] += w, w;
  }
  m.y += d("top"), m.x += d("left"), d("right"), d("bottom");
}
function ZE(m, a) {
  const d = a.maxPadding;
  function g(w) {
    const b = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return w.forEach((E) => {
      b[E] = Math.max(a[E], d[E]);
    }), b;
  }
  return g(m ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Mf(m, a, d, g) {
  const w = [];
  let b, E, i, O, j, Y;
  for (b = 0, E = m.length, j = 0; b < E; ++b) {
    i = m[b], O = i.box, O.update(i.width || a.w, i.height || a.h, ZE(i.horizontal, a));
    const { same: J, other: ae } = jE(a, d, i, g);
    j |= J && w.length, Y = Y || ae, O.fullSize || w.push(i);
  }
  return j && Mf(w, a, d, g) || Y;
}
function gm(m, a, d, g, w) {
  m.top = d, m.left = a, m.right = a + g, m.bottom = d + w, m.width = g, m.height = w;
}
function P1(m, a, d, g) {
  const w = d.padding;
  let { x: b, y: E } = a;
  for (const i of m) {
    const O = i.box, j = g[i.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, Y = i.stackWeight / j.weight || 1;
    if (i.horizontal) {
      const J = a.w * Y, ae = j.size || O.height;
      Of(j.start) && (E = j.start), O.fullSize ? gm(O, w.left, E, d.outerWidth - w.right - w.left, ae) : gm(O, a.left + j.placed, E, J, ae), j.start = E, j.placed += J, E = O.bottom;
    } else {
      const J = a.h * Y, ae = j.size || O.width;
      Of(j.start) && (b = j.start), O.fullSize ? gm(O, b, w.top, ae, d.outerHeight - w.bottom - w.top) : gm(O, b, a.top + j.placed, ae, J), j.start = b, j.placed += J, b = O.right;
    }
  }
  a.x = b, a.y = E;
}
var jr = {
  addBox(m, a) {
    m.boxes || (m.boxes = []), a.fullSize = a.fullSize || !1, a.position = a.position || "top", a.weight = a.weight || 0, a._layers = a._layers || function() {
      return [
        {
          z: 0,
          draw(d) {
            a.draw(d);
          }
        }
      ];
    }, m.boxes.push(a);
  },
  removeBox(m, a) {
    const d = m.boxes ? m.boxes.indexOf(a) : -1;
    d !== -1 && m.boxes.splice(d, 1);
  },
  configure(m, a, d) {
    a.fullSize = d.fullSize, a.position = d.position, a.weight = d.weight;
  },
  update(m, a, d, g) {
    if (!m)
      return;
    const w = Gr(m.options.layout.padding), b = Math.max(a - w.width, 0), E = Math.max(d - w.height, 0), i = UE(m.boxes), O = i.vertical, j = i.horizontal;
    Zn(m.boxes, (be) => {
      typeof be.beforeLayout == "function" && be.beforeLayout();
    });
    const Y = O.reduce((be, Ze) => Ze.box.options && Ze.box.options.display === !1 ? be : be + 1, 0) || 1, J = Object.freeze({
      outerWidth: a,
      outerHeight: d,
      padding: w,
      availableWidth: b,
      availableHeight: E,
      vBoxMaxWidth: b / 2 / Y,
      hBoxMaxHeight: E / 2
    }), ae = Object.assign({}, w);
    Jb(ae, Gr(g));
    const ce = Object.assign({
      maxPadding: ae,
      w: b,
      h: E,
      x: w.left,
      y: w.top
    }, w), Te = VE(O.concat(j), J);
    Mf(i.fullSize, ce, J, Te), Mf(O, ce, J, Te), Mf(j, ce, J, Te) && Mf(O, ce, J, Te), GE(ce), P1(i.leftAndTop, ce, J, Te), ce.x += ce.w, ce.y += ce.h, P1(i.rightAndBottom, ce, J, Te), m.chartArea = {
      left: ce.left,
      top: ce.top,
      right: ce.left + ce.w,
      bottom: ce.top + ce.h,
      height: ce.h,
      width: ce.w
    }, Zn(i.chartArea, (be) => {
      const Ze = be.box;
      Object.assign(Ze, m.chartArea), Ze.update(ce.w, ce.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Qb {
  acquireContext(a, d) {
  }
  releaseContext(a) {
    return !1;
  }
  addEventListener(a, d, g) {
  }
  removeEventListener(a, d, g) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(a, d, g, w) {
    return d = Math.max(0, d || a.width), g = g || a.height, {
      width: d,
      height: Math.max(0, w ? Math.floor(d / w) : g)
    };
  }
  isAttached(a) {
    return !0;
  }
  updateConfig(a) {
  }
}
class HE extends Qb {
  acquireContext(a) {
    return a && a.getContext && a.getContext("2d") || null;
  }
  updateConfig(a) {
    a.options.animation = !1;
  }
}
const zm = "$chartjs", qE = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, C1 = (m) => m === null || m === "";
function WE(m, a) {
  const d = m.style, g = m.getAttribute("height"), w = m.getAttribute("width");
  if (m[zm] = {
    initial: {
      height: g,
      width: w,
      style: {
        display: d.display,
        height: d.height,
        width: d.width
      }
    }
  }, d.display = d.display || "block", d.boxSizing = d.boxSizing || "border-box", C1(w)) {
    const b = d1(m, "width");
    b !== void 0 && (m.width = b);
  }
  if (C1(g))
    if (m.style.height === "")
      m.height = m.width / (a || 2);
    else {
      const b = d1(m, "height");
      b !== void 0 && (m.height = b);
    }
  return m;
}
const ew = XS ? {
  passive: !0
} : !1;
function $E(m, a, d) {
  m && m.addEventListener(a, d, ew);
}
function XE(m, a, d) {
  m && m.canvas && m.canvas.removeEventListener(a, d, ew);
}
function YE(m, a) {
  const d = qE[m.type] || m.type, { x: g, y: w } = Lh(m, a);
  return {
    type: d,
    chart: a,
    native: m,
    x: g !== void 0 ? g : null,
    y: w !== void 0 ? w : null
  };
}
function Um(m, a) {
  for (const d of m)
    if (d === a || d.contains(a))
      return !0;
}
function KE(m, a, d) {
  const g = m.canvas, w = new MutationObserver((b) => {
    let E = !1;
    for (const i of b)
      E = E || Um(i.addedNodes, g), E = E && !Um(i.removedNodes, g);
    E && d();
  });
  return w.observe(document, {
    childList: !0,
    subtree: !0
  }), w;
}
function JE(m, a, d) {
  const g = m.canvas, w = new MutationObserver((b) => {
    let E = !1;
    for (const i of b)
      E = E || Um(i.removedNodes, g), E = E && !Um(i.addedNodes, g);
    E && d();
  });
  return w.observe(document, {
    childList: !0,
    subtree: !0
  }), w;
}
const Nf = /* @__PURE__ */ new Map();
let I1 = 0;
function tw() {
  const m = window.devicePixelRatio;
  m !== I1 && (I1 = m, Nf.forEach((a, d) => {
    d.currentDevicePixelRatio !== m && a();
  }));
}
function QE(m, a) {
  Nf.size || window.addEventListener("resize", tw), Nf.set(m, a);
}
function eA(m) {
  Nf.delete(m), Nf.size || window.removeEventListener("resize", tw);
}
function tA(m, a, d) {
  const g = m.canvas, w = g && vy(g);
  if (!w)
    return;
  const b = Lb((i, O) => {
    const j = w.clientWidth;
    d(i, O), j < w.clientWidth && d();
  }, window), E = new ResizeObserver((i) => {
    const O = i[0], j = O.contentRect.width, Y = O.contentRect.height;
    j === 0 && Y === 0 || b(j, Y);
  });
  return E.observe(w), QE(m, b), E;
}
function Ng(m, a, d) {
  d && d.disconnect(), a === "resize" && eA(m);
}
function iA(m, a, d) {
  const g = m.canvas, w = Lb((b) => {
    m.ctx !== null && d(YE(b, m));
  }, m);
  return $E(g, a, w), w;
}
class nA extends Qb {
  acquireContext(a, d) {
    const g = a && a.getContext && a.getContext("2d");
    return g && g.canvas === a ? (WE(a, d), g) : null;
  }
  releaseContext(a) {
    const d = a.canvas;
    if (!d[zm])
      return !1;
    const g = d[zm].initial;
    [
      "height",
      "width"
    ].forEach((b) => {
      const E = g[b];
      En(E) ? d.removeAttribute(b) : d.setAttribute(b, E);
    });
    const w = g.style || {};
    return Object.keys(w).forEach((b) => {
      d.style[b] = w[b];
    }), d.width = d.width, delete d[zm], !0;
  }
  addEventListener(a, d, g) {
    this.removeEventListener(a, d);
    const w = a.$proxies || (a.$proxies = {}), E = {
      attach: KE,
      detach: JE,
      resize: tA
    }[d] || iA;
    w[d] = E(a, d, g);
  }
  removeEventListener(a, d) {
    const g = a.$proxies || (a.$proxies = {}), w = g[d];
    if (!w)
      return;
    ({
      attach: Ng,
      detach: Ng,
      resize: Ng
    }[d] || XE)(a, d, w), g[d] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(a, d, g, w) {
    return $S(a, d, g, w);
  }
  isAttached(a) {
    const d = a && vy(a);
    return !!(d && d.isConnected);
  }
}
function sA(m) {
  return !xy() || typeof OffscreenCanvas < "u" && m instanceof OffscreenCanvas ? HE : nA;
}
var Em;
let jl = (Em = class {
  constructor() {
    Yt(this, "x");
    Yt(this, "y");
    Yt(this, "active", !1);
    Yt(this, "options");
    Yt(this, "$animations");
  }
  tooltipPosition(a) {
    const { x: d, y: g } = this.getProps([
      "x",
      "y"
    ], a);
    return {
      x: d,
      y: g
    };
  }
  hasValue() {
    return Xu(this.x) && Xu(this.y);
  }
  getProps(a, d) {
    const g = this.$animations;
    if (!d || !g)
      return this;
    const w = {};
    return a.forEach((b) => {
      w[b] = g[b] && g[b].active() ? g[b]._to : this[b];
    }), w;
  }
}, Yt(Em, "defaults", {}), Yt(Em, "defaultRoutes"), Em);
function rA(m, a) {
  const d = m.options.ticks, g = oA(m), w = Math.min(d.maxTicksLimit || g, g), b = d.major.enabled ? lA(a) : [], E = b.length, i = b[0], O = b[E - 1], j = [];
  if (E > w)
    return cA(a, j, b, E / w), j;
  const Y = aA(b, a, w);
  if (E > 0) {
    let J, ae;
    const ce = E > 1 ? Math.round((O - i) / (E - 1)) : null;
    for (ym(a, j, Y, En(ce) ? 0 : i - ce, i), J = 0, ae = E - 1; J < ae; J++)
      ym(a, j, Y, b[J], b[J + 1]);
    return ym(a, j, Y, O, En(ce) ? a.length : O + ce), j;
  }
  return ym(a, j, Y), j;
}
function oA(m) {
  const a = m.options.offset, d = m._tickSize(), g = m._length / d + (a ? 0 : 1), w = m._maxLength / d;
  return Math.floor(Math.min(g, w));
}
function aA(m, a, d) {
  const g = hA(m), w = a.length / d;
  if (!g)
    return Math.max(w, 1);
  const b = JM(g);
  for (let E = 0, i = b.length - 1; E < i; E++) {
    const O = b[E];
    if (O > w)
      return O;
  }
  return Math.max(w, 1);
}
function lA(m) {
  const a = [];
  let d, g;
  for (d = 0, g = m.length; d < g; d++)
    m[d].major && a.push(d);
  return a;
}
function cA(m, a, d, g) {
  let w = 0, b = d[0], E;
  for (g = Math.ceil(g), E = 0; E < m.length; E++)
    E === b && (a.push(m[E]), w++, b = d[w * g]);
}
function ym(m, a, d, g, w) {
  const b = en(g, 0), E = Math.min(en(w, m.length), m.length);
  let i = 0, O, j, Y;
  for (d = Math.ceil(d), w && (O = w - g, d = O / Math.floor(O / d)), Y = b; Y < 0; )
    i++, Y = Math.round(b + i * d);
  for (j = Math.max(b, 0); j < E; j++)
    j === Y && (a.push(m[j]), i++, Y = Math.round(b + i * d));
}
function hA(m) {
  const a = m.length;
  let d, g;
  if (a < 2)
    return !1;
  for (g = m[0], d = 1; d < a; ++d)
    if (m[d] - m[d - 1] !== g)
      return !1;
  return g;
}
const uA = (m) => m === "left" ? "right" : m === "right" ? "left" : m, L1 = (m, a, d) => a === "top" || a === "left" ? m[a] + d : m[a] - d, z1 = (m, a) => Math.min(a || m, m);
function D1(m, a) {
  const d = [], g = m.length / a, w = m.length;
  let b = 0;
  for (; b < w; b += g)
    d.push(m[Math.floor(b)]);
  return d;
}
function dA(m, a, d) {
  const g = m.ticks.length, w = Math.min(a, g - 1), b = m._startPixel, E = m._endPixel, i = 1e-6;
  let O = m.getPixelForTick(w), j;
  if (!(d && (g === 1 ? j = Math.max(O - b, E - O) : a === 0 ? j = (m.getPixelForTick(1) - O) / 2 : j = (O - m.getPixelForTick(w - 1)) / 2, O += w < a ? j : -j, O < b - i || O > E + i)))
    return O;
}
function fA(m, a) {
  Zn(m, (d) => {
    const g = d.gc, w = g.length / 2;
    let b;
    if (w > a) {
      for (b = 0; b < w; ++b)
        delete d.data[g[b]];
      g.splice(0, w);
    }
  });
}
function vf(m) {
  return m.drawTicks ? m.tickLength : 0;
}
function k1(m, a) {
  if (!m.display)
    return 0;
  const d = ir(m.font, a), g = Gr(m.padding);
  return (hs(m.text) ? m.text.length : 1) * d.lineHeight + g.height;
}
function pA(m, a) {
  return Fc(m, {
    scale: a,
    type: "scale"
  });
}
function mA(m, a, d) {
  return Fc(m, {
    tick: d,
    index: a,
    type: "tick"
  });
}
function _A(m, a, d) {
  let g = fy(m);
  return (d && a !== "right" || !d && a === "right") && (g = uA(g)), g;
}
function gA(m, a, d, g) {
  const { top: w, left: b, bottom: E, right: i, chart: O } = m, { chartArea: j, scales: Y } = O;
  let J = 0, ae, ce, Te;
  const be = E - w, Ze = i - b;
  if (m.isHorizontal()) {
    if (ce = Ur(g, b, i), yn(d)) {
      const je = Object.keys(d)[0], ot = d[je];
      Te = Y[je].getPixelForValue(ot) + be - a;
    } else
      d === "center" ? Te = (j.bottom + j.top) / 2 + be - a : Te = L1(m, d, a);
    ae = i - b;
  } else {
    if (yn(d)) {
      const je = Object.keys(d)[0], ot = d[je];
      ce = Y[je].getPixelForValue(ot) - Ze + a;
    } else
      d === "center" ? ce = (j.left + j.right) / 2 - Ze + a : ce = L1(m, d, a);
    Te = Ur(g, E, w), J = d === "left" ? -Ns : Ns;
  }
  return {
    titleX: ce,
    titleY: Te,
    maxWidth: ae,
    rotation: J
  };
}
class Bh extends jl {
  constructor(a) {
    super(), this.id = a.id, this.type = a.type, this.options = void 0, this.ctx = a.ctx, this.chart = a.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(a) {
    this.options = a.setContext(this.getContext()), this.axis = a.axis, this._userMin = this.parse(a.min), this._userMax = this.parse(a.max), this._suggestedMin = this.parse(a.suggestedMin), this._suggestedMax = this.parse(a.suggestedMax);
  }
  parse(a, d) {
    return a;
  }
  getUserBounds() {
    let { _userMin: a, _userMax: d, _suggestedMin: g, _suggestedMax: w } = this;
    return a = Bo(a, Number.POSITIVE_INFINITY), d = Bo(d, Number.NEGATIVE_INFINITY), g = Bo(g, Number.POSITIVE_INFINITY), w = Bo(w, Number.NEGATIVE_INFINITY), {
      min: Bo(a, g),
      max: Bo(d, w),
      minDefined: Ps(a),
      maxDefined: Ps(d)
    };
  }
  getMinMax(a) {
    let { min: d, max: g, minDefined: w, maxDefined: b } = this.getUserBounds(), E;
    if (w && b)
      return {
        min: d,
        max: g
      };
    const i = this.getMatchingVisibleMetas();
    for (let O = 0, j = i.length; O < j; ++O)
      E = i[O].controller.getMinMax(this, a), w || (d = Math.min(d, E.min)), b || (g = Math.max(g, E.max));
    return d = b && d > g ? g : d, g = w && d > g ? d : g, {
      min: Bo(d, Bo(g, d)),
      max: Bo(g, Bo(d, g))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const a = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? a.xLabels : a.yLabels) || a.labels || [];
  }
  getLabelItems(a = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(a));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    is(this.options.beforeUpdate, [
      this
    ]);
  }
  update(a, d, g) {
    const { beginAtZero: w, grace: b, ticks: E } = this.options, i = E.sampleSize;
    this.beforeUpdate(), this.maxWidth = a, this.maxHeight = d, this._margins = g = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, g), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + g.left + g.right : this.height + g.top + g.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = ES(this, b, w), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const O = i < this.ticks.length;
    this._convertTicksToLabels(O ? D1(this.ticks, i) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), E.display && (E.autoSkip || E.source === "auto") && (this.ticks = rA(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), O && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let a = this.options.reverse, d, g;
    this.isHorizontal() ? (d = this.left, g = this.right) : (d = this.top, g = this.bottom, a = !a), this._startPixel = d, this._endPixel = g, this._reversePixels = a, this._length = g - d, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    is(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    is(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    is(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(a) {
    this.chart.notifyPlugins(a, this.getContext()), is(this.options[a], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    is(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(a) {
    const d = this.options.ticks;
    let g, w, b;
    for (g = 0, w = a.length; g < w; g++)
      b = a[g], b.label = is(d.callback, [
        b.value,
        g,
        a
      ], this);
  }
  afterTickToLabelConversion() {
    is(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    is(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const a = this.options, d = a.ticks, g = z1(this.ticks.length, a.ticks.maxTicksLimit), w = d.minRotation || 0, b = d.maxRotation;
    let E = w, i, O, j;
    if (!this._isVisible() || !d.display || w >= b || g <= 1 || !this.isHorizontal()) {
      this.labelRotation = w;
      return;
    }
    const Y = this._getLabelSizes(), J = Y.widest.width, ae = Y.highest.height, ce = gr(this.chart.width - J, 0, this.maxWidth);
    i = a.offset ? this.maxWidth / g : ce / (g - 1), J + 6 > i && (i = ce / (g - (a.offset ? 0.5 : 1)), O = this.maxHeight - vf(a.grid) - d.padding - k1(a.title, this.chart.options.font), j = Math.sqrt(J * J + ae * ae), E = uy(Math.min(Math.asin(gr((Y.highest.height + 6) / i, -1, 1)), Math.asin(gr(O / j, -1, 1)) - Math.asin(gr(ae / j, -1, 1)))), E = Math.max(w, Math.min(b, E))), this.labelRotation = E;
  }
  afterCalculateLabelRotation() {
    is(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    is(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const a = {
      width: 0,
      height: 0
    }, { chart: d, options: { ticks: g, title: w, grid: b } } = this, E = this._isVisible(), i = this.isHorizontal();
    if (E) {
      const O = k1(w, d.options.font);
      if (i ? (a.width = this.maxWidth, a.height = vf(b) + O) : (a.height = this.maxHeight, a.width = vf(b) + O), g.display && this.ticks.length) {
        const { first: j, last: Y, widest: J, highest: ae } = this._getLabelSizes(), ce = g.padding * 2, Te = Ia(this.labelRotation), be = Math.cos(Te), Ze = Math.sin(Te);
        if (i) {
          const je = g.mirror ? 0 : Ze * J.width + be * ae.height;
          a.height = Math.min(this.maxHeight, a.height + je + ce);
        } else {
          const je = g.mirror ? 0 : be * J.width + Ze * ae.height;
          a.width = Math.min(this.maxWidth, a.width + je + ce);
        }
        this._calculatePadding(j, Y, Ze, be);
      }
    }
    this._handleMargins(), i ? (this.width = this._length = d.width - this._margins.left - this._margins.right, this.height = a.height) : (this.width = a.width, this.height = this._length = d.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(a, d, g, w) {
    const { ticks: { align: b, padding: E }, position: i } = this.options, O = this.labelRotation !== 0, j = i !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const Y = this.getPixelForTick(0) - this.left, J = this.right - this.getPixelForTick(this.ticks.length - 1);
      let ae = 0, ce = 0;
      O ? j ? (ae = w * a.width, ce = g * d.height) : (ae = g * a.height, ce = w * d.width) : b === "start" ? ce = d.width : b === "end" ? ae = a.width : b !== "inner" && (ae = a.width / 2, ce = d.width / 2), this.paddingLeft = Math.max((ae - Y + E) * this.width / (this.width - Y), 0), this.paddingRight = Math.max((ce - J + E) * this.width / (this.width - J), 0);
    } else {
      let Y = d.height / 2, J = a.height / 2;
      b === "start" ? (Y = 0, J = a.height) : b === "end" && (Y = d.height, J = 0), this.paddingTop = Y + E, this.paddingBottom = J + E;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    is(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: a, position: d } = this.options;
    return d === "top" || d === "bottom" || a === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(a) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(a);
    let d, g;
    for (d = 0, g = a.length; d < g; d++)
      En(a[d].label) && (a.splice(d, 1), g--, d--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let a = this._labelSizes;
    if (!a) {
      const d = this.options.ticks.sampleSize;
      let g = this.ticks;
      d < g.length && (g = D1(g, d)), this._labelSizes = a = this._computeLabelSizes(g, g.length, this.options.ticks.maxTicksLimit);
    }
    return a;
  }
  _computeLabelSizes(a, d, g) {
    const { ctx: w, _longestTextCache: b } = this, E = [], i = [], O = Math.floor(d / z1(d, g));
    let j = 0, Y = 0, J, ae, ce, Te, be, Ze, je, ot, vt, ht, gt;
    for (J = 0; J < d; J += O) {
      if (Te = a[J].label, be = this._resolveTickFontOptions(J), w.font = Ze = be.string, je = b[Ze] = b[Ze] || {
        data: {},
        gc: []
      }, ot = be.lineHeight, vt = ht = 0, !En(Te) && !hs(Te))
        vt = Nm(w, je.data, je.gc, vt, Te), ht = ot;
      else if (hs(Te))
        for (ae = 0, ce = Te.length; ae < ce; ++ae)
          gt = Te[ae], !En(gt) && !hs(gt) && (vt = Nm(w, je.data, je.gc, vt, gt), ht += ot);
      E.push(vt), i.push(ht), j = Math.max(vt, j), Y = Math.max(ht, Y);
    }
    fA(b, d);
    const Vt = E.indexOf(j), pt = i.indexOf(Y), Gt = (ui) => ({
      width: E[ui] || 0,
      height: i[ui] || 0
    });
    return {
      first: Gt(0),
      last: Gt(d - 1),
      widest: Gt(Vt),
      highest: Gt(pt),
      widths: E,
      heights: i
    };
  }
  getLabelForValue(a) {
    return a;
  }
  getPixelForValue(a, d) {
    return NaN;
  }
  getValueForPixel(a) {
  }
  getPixelForTick(a) {
    const d = this.ticks;
    return a < 0 || a > d.length - 1 ? null : this.getPixelForValue(d[a].value);
  }
  getPixelForDecimal(a) {
    this._reversePixels && (a = 1 - a);
    const d = this._startPixel + a * this._length;
    return tS(this._alignToPixels ? Ph(this.chart, d, 0) : d);
  }
  getDecimalForPixel(a) {
    const d = (a - this._startPixel) / this._length;
    return this._reversePixels ? 1 - d : d;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: a, max: d } = this;
    return a < 0 && d < 0 ? d : a > 0 && d > 0 ? a : 0;
  }
  getContext(a) {
    const d = this.ticks || [];
    if (a >= 0 && a < d.length) {
      const g = d[a];
      return g.$context || (g.$context = mA(this.getContext(), a, g));
    }
    return this.$context || (this.$context = pA(this.chart.getContext(), this));
  }
  _tickSize() {
    const a = this.options.ticks, d = Ia(this.labelRotation), g = Math.abs(Math.cos(d)), w = Math.abs(Math.sin(d)), b = this._getLabelSizes(), E = a.autoSkipPadding || 0, i = b ? b.widest.width + E : 0, O = b ? b.highest.height + E : 0;
    return this.isHorizontal() ? O * g > i * w ? i / g : O / w : O * w < i * g ? O / g : i / w;
  }
  _isVisible() {
    const a = this.options.display;
    return a !== "auto" ? !!a : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(a) {
    const d = this.axis, g = this.chart, w = this.options, { grid: b, position: E, border: i } = w, O = b.offset, j = this.isHorizontal(), J = this.ticks.length + (O ? 1 : 0), ae = vf(b), ce = [], Te = i.setContext(this.getContext()), be = Te.display ? Te.width : 0, Ze = be / 2, je = function(Si) {
      return Ph(g, Si, be);
    };
    let ot, vt, ht, gt, Vt, pt, Gt, ui, kt, At, Mi, An;
    if (E === "top")
      ot = je(this.bottom), pt = this.bottom - ae, ui = ot - Ze, At = je(a.top) + Ze, An = a.bottom;
    else if (E === "bottom")
      ot = je(this.top), At = a.top, An = je(a.bottom) - Ze, pt = ot + Ze, ui = this.top + ae;
    else if (E === "left")
      ot = je(this.right), Vt = this.right - ae, Gt = ot - Ze, kt = je(a.left) + Ze, Mi = a.right;
    else if (E === "right")
      ot = je(this.left), kt = a.left, Mi = je(a.right) - Ze, Vt = ot + Ze, Gt = this.left + ae;
    else if (d === "x") {
      if (E === "center")
        ot = je((a.top + a.bottom) / 2 + 0.5);
      else if (yn(E)) {
        const Si = Object.keys(E)[0], Ji = E[Si];
        ot = je(this.chart.scales[Si].getPixelForValue(Ji));
      }
      At = a.top, An = a.bottom, pt = ot + Ze, ui = pt + ae;
    } else if (d === "y") {
      if (E === "center")
        ot = je((a.left + a.right) / 2);
      else if (yn(E)) {
        const Si = Object.keys(E)[0], Ji = E[Si];
        ot = je(this.chart.scales[Si].getPixelForValue(Ji));
      }
      Vt = ot - Ze, Gt = Vt - ae, kt = a.left, Mi = a.right;
    }
    const hn = en(w.ticks.maxTicksLimit, J), Ht = Math.max(1, Math.ceil(J / hn));
    for (vt = 0; vt < J; vt += Ht) {
      const Si = this.getContext(vt), Ji = b.setContext(Si), fi = i.setContext(Si), jt = Ji.lineWidth, ni = Ji.color, Gi = fi.dash || [], an = fi.dashOffset, qt = Ji.tickWidth, ln = Ji.tickColor, Di = Ji.tickBorderDash || [], xi = Ji.tickBorderDashOffset;
      ht = dA(this, vt, O), ht !== void 0 && (gt = Ph(g, ht, jt), j ? Vt = Gt = kt = Mi = gt : pt = ui = At = An = gt, ce.push({
        tx1: Vt,
        ty1: pt,
        tx2: Gt,
        ty2: ui,
        x1: kt,
        y1: At,
        x2: Mi,
        y2: An,
        width: jt,
        color: ni,
        borderDash: Gi,
        borderDashOffset: an,
        tickWidth: qt,
        tickColor: ln,
        tickBorderDash: Di,
        tickBorderDashOffset: xi
      }));
    }
    return this._ticksLength = J, this._borderValue = ot, ce;
  }
  _computeLabelItems(a) {
    const d = this.axis, g = this.options, { position: w, ticks: b } = g, E = this.isHorizontal(), i = this.ticks, { align: O, crossAlign: j, padding: Y, mirror: J } = b, ae = vf(g.grid), ce = ae + Y, Te = J ? -Y : ce, be = -Ia(this.labelRotation), Ze = [];
    let je, ot, vt, ht, gt, Vt, pt, Gt, ui, kt, At, Mi, An = "middle";
    if (w === "top")
      Vt = this.bottom - Te, pt = this._getXAxisLabelAlignment();
    else if (w === "bottom")
      Vt = this.top + Te, pt = this._getXAxisLabelAlignment();
    else if (w === "left") {
      const Ht = this._getYAxisLabelAlignment(ae);
      pt = Ht.textAlign, gt = Ht.x;
    } else if (w === "right") {
      const Ht = this._getYAxisLabelAlignment(ae);
      pt = Ht.textAlign, gt = Ht.x;
    } else if (d === "x") {
      if (w === "center")
        Vt = (a.top + a.bottom) / 2 + ce;
      else if (yn(w)) {
        const Ht = Object.keys(w)[0], Si = w[Ht];
        Vt = this.chart.scales[Ht].getPixelForValue(Si) + ce;
      }
      pt = this._getXAxisLabelAlignment();
    } else if (d === "y") {
      if (w === "center")
        gt = (a.left + a.right) / 2 - ce;
      else if (yn(w)) {
        const Ht = Object.keys(w)[0], Si = w[Ht];
        gt = this.chart.scales[Ht].getPixelForValue(Si);
      }
      pt = this._getYAxisLabelAlignment(ae).textAlign;
    }
    d === "y" && (O === "start" ? An = "top" : O === "end" && (An = "bottom"));
    const hn = this._getLabelSizes();
    for (je = 0, ot = i.length; je < ot; ++je) {
      vt = i[je], ht = vt.label;
      const Ht = b.setContext(this.getContext(je));
      Gt = this.getPixelForTick(je) + b.labelOffset, ui = this._resolveTickFontOptions(je), kt = ui.lineHeight, At = hs(ht) ? ht.length : 1;
      const Si = At / 2, Ji = Ht.color, fi = Ht.textStrokeColor, jt = Ht.textStrokeWidth;
      let ni = pt;
      E ? (gt = Gt, pt === "inner" && (je === ot - 1 ? ni = this.options.reverse ? "left" : "right" : je === 0 ? ni = this.options.reverse ? "right" : "left" : ni = "center"), w === "top" ? j === "near" || be !== 0 ? Mi = -At * kt + kt / 2 : j === "center" ? Mi = -hn.highest.height / 2 - Si * kt + kt : Mi = -hn.highest.height + kt / 2 : j === "near" || be !== 0 ? Mi = kt / 2 : j === "center" ? Mi = hn.highest.height / 2 - Si * kt : Mi = hn.highest.height - At * kt, J && (Mi *= -1), be !== 0 && !Ht.showLabelBackdrop && (gt += kt / 2 * Math.sin(be))) : (Vt = Gt, Mi = (1 - At) * kt / 2);
      let Gi;
      if (Ht.showLabelBackdrop) {
        const an = Gr(Ht.backdropPadding), qt = hn.heights[je], ln = hn.widths[je];
        let Di = Mi - an.top, xi = 0 - an.left;
        switch (An) {
          case "middle":
            Di -= qt / 2;
            break;
          case "bottom":
            Di -= qt;
            break;
        }
        switch (pt) {
          case "center":
            xi -= ln / 2;
            break;
          case "right":
            xi -= ln;
            break;
          case "inner":
            je === ot - 1 ? xi -= ln : je > 0 && (xi -= ln / 2);
            break;
        }
        Gi = {
          left: xi,
          top: Di,
          width: ln + an.width,
          height: qt + an.height,
          color: Ht.backdropColor
        };
      }
      Ze.push({
        label: ht,
        font: ui,
        textOffset: Mi,
        options: {
          rotation: be,
          color: Ji,
          strokeColor: fi,
          strokeWidth: jt,
          textAlign: ni,
          textBaseline: An,
          translation: [
            gt,
            Vt
          ],
          backdrop: Gi
        }
      });
    }
    return Ze;
  }
  _getXAxisLabelAlignment() {
    const { position: a, ticks: d } = this.options;
    if (-Ia(this.labelRotation))
      return a === "top" ? "left" : "right";
    let w = "center";
    return d.align === "start" ? w = "left" : d.align === "end" ? w = "right" : d.align === "inner" && (w = "inner"), w;
  }
  _getYAxisLabelAlignment(a) {
    const { position: d, ticks: { crossAlign: g, mirror: w, padding: b } } = this.options, E = this._getLabelSizes(), i = a + b, O = E.widest.width;
    let j, Y;
    return d === "left" ? w ? (Y = this.right + b, g === "near" ? j = "left" : g === "center" ? (j = "center", Y += O / 2) : (j = "right", Y += O)) : (Y = this.right - i, g === "near" ? j = "right" : g === "center" ? (j = "center", Y -= O / 2) : (j = "left", Y = this.left)) : d === "right" ? w ? (Y = this.left + b, g === "near" ? j = "right" : g === "center" ? (j = "center", Y -= O / 2) : (j = "left", Y -= O)) : (Y = this.left + i, g === "near" ? j = "left" : g === "center" ? (j = "center", Y += O / 2) : (j = "right", Y = this.right)) : j = "right", {
      textAlign: j,
      x: Y
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const a = this.chart, d = this.options.position;
    if (d === "left" || d === "right")
      return {
        top: 0,
        left: this.left,
        bottom: a.height,
        right: this.right
      };
    if (d === "top" || d === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: a.width
      };
  }
  drawBackground() {
    const { ctx: a, options: { backgroundColor: d }, left: g, top: w, width: b, height: E } = this;
    d && (a.save(), a.fillStyle = d, a.fillRect(g, w, b, E), a.restore());
  }
  getLineWidthForValue(a) {
    const d = this.options.grid;
    if (!this._isVisible() || !d.display)
      return 0;
    const w = this.ticks.findIndex((b) => b.value === a);
    return w >= 0 ? d.setContext(this.getContext(w)).lineWidth : 0;
  }
  drawGrid(a) {
    const d = this.options.grid, g = this.ctx, w = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(a));
    let b, E;
    const i = (O, j, Y) => {
      !Y.width || !Y.color || (g.save(), g.lineWidth = Y.width, g.strokeStyle = Y.color, g.setLineDash(Y.borderDash || []), g.lineDashOffset = Y.borderDashOffset, g.beginPath(), g.moveTo(O.x, O.y), g.lineTo(j.x, j.y), g.stroke(), g.restore());
    };
    if (d.display)
      for (b = 0, E = w.length; b < E; ++b) {
        const O = w[b];
        d.drawOnChartArea && i({
          x: O.x1,
          y: O.y1
        }, {
          x: O.x2,
          y: O.y2
        }, O), d.drawTicks && i({
          x: O.tx1,
          y: O.ty1
        }, {
          x: O.tx2,
          y: O.ty2
        }, {
          color: O.tickColor,
          width: O.tickWidth,
          borderDash: O.tickBorderDash,
          borderDashOffset: O.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: a, ctx: d, options: { border: g, grid: w } } = this, b = g.setContext(this.getContext()), E = g.display ? b.width : 0;
    if (!E)
      return;
    const i = w.setContext(this.getContext(0)).lineWidth, O = this._borderValue;
    let j, Y, J, ae;
    this.isHorizontal() ? (j = Ph(a, this.left, E) - E / 2, Y = Ph(a, this.right, i) + i / 2, J = ae = O) : (J = Ph(a, this.top, E) - E / 2, ae = Ph(a, this.bottom, i) + i / 2, j = Y = O), d.save(), d.lineWidth = b.width, d.strokeStyle = b.color, d.beginPath(), d.moveTo(j, J), d.lineTo(Y, ae), d.stroke(), d.restore();
  }
  drawLabels(a) {
    if (!this.options.ticks.display)
      return;
    const g = this.ctx, w = this._computeLabelArea();
    w && Wm(g, w);
    const b = this.getLabelItems(a);
    for (const E of b) {
      const i = E.options, O = E.font, j = E.label, Y = E.textOffset;
      Fh(g, j, 0, Y, O, i);
    }
    w && $m(g);
  }
  drawTitle() {
    const { ctx: a, options: { position: d, title: g, reverse: w } } = this;
    if (!g.display)
      return;
    const b = ir(g.font), E = Gr(g.padding), i = g.align;
    let O = b.lineHeight / 2;
    d === "bottom" || d === "center" || yn(d) ? (O += E.bottom, hs(g.text) && (O += b.lineHeight * (g.text.length - 1))) : O += E.top;
    const { titleX: j, titleY: Y, maxWidth: J, rotation: ae } = gA(this, O, d, i);
    Fh(a, g.text, 0, 0, b, {
      color: g.color,
      maxWidth: J,
      rotation: ae,
      textAlign: _A(i, d, w),
      textBaseline: "middle",
      translation: [
        j,
        Y
      ]
    });
  }
  draw(a) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(a), this.drawBorder(), this.drawTitle(), this.drawLabels(a));
  }
  _layers() {
    const a = this.options, d = a.ticks && a.ticks.z || 0, g = en(a.grid && a.grid.z, -1), w = en(a.border && a.border.z, 0);
    return !this._isVisible() || this.draw !== Bh.prototype.draw ? [
      {
        z: d,
        draw: (b) => {
          this.draw(b);
        }
      }
    ] : [
      {
        z: g,
        draw: (b) => {
          this.drawBackground(), this.drawGrid(b), this.drawTitle();
        }
      },
      {
        z: w,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: d,
        draw: (b) => {
          this.drawLabels(b);
        }
      }
    ];
  }
  getMatchingVisibleMetas(a) {
    const d = this.chart.getSortedVisibleDatasetMetas(), g = this.axis + "AxisID", w = [];
    let b, E;
    for (b = 0, E = d.length; b < E; ++b) {
      const i = d[b];
      i[g] === this.id && (!a || i.type === a) && w.push(i);
    }
    return w;
  }
  _resolveTickFontOptions(a) {
    const d = this.options.ticks.setContext(this.getContext(a));
    return ir(d.font);
  }
  _maxDigits() {
    const a = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / a;
  }
}
class xm {
  constructor(a, d, g) {
    this.type = a, this.scope = d, this.override = g, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(a) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, a.prototype);
  }
  register(a) {
    const d = Object.getPrototypeOf(a);
    let g;
    vA(d) && (g = this.register(d));
    const w = this.items, b = a.id, E = this.scope + "." + b;
    if (!b)
      throw new Error("class does not have id: " + a);
    return b in w || (w[b] = a, yA(a, E, g), this.override && ys.override(a.id, a.overrides)), E;
  }
  get(a) {
    return this.items[a];
  }
  unregister(a) {
    const d = this.items, g = a.id, w = this.scope;
    g in d && delete d[g], w && g in ys[w] && (delete ys[w][g], this.override && delete Oh[g]);
  }
}
function yA(m, a, d) {
  const g = Rf(/* @__PURE__ */ Object.create(null), [
    d ? ys.get(d) : {},
    ys.get(a),
    m.defaults
  ]);
  ys.set(a, g), m.defaultRoutes && xA(a, m.defaultRoutes), m.descriptors && ys.describe(a, m.descriptors);
}
function xA(m, a) {
  Object.keys(a).forEach((d) => {
    const g = d.split("."), w = g.pop(), b = [
      m
    ].concat(g).join("."), E = a[d].split("."), i = E.pop(), O = E.join(".");
    ys.route(b, w, O, i);
  });
}
function vA(m) {
  return "id" in m && "defaults" in m;
}
class bA {
  constructor() {
    this.controllers = new xm(za, "datasets", !0), this.elements = new xm(jl, "elements"), this.plugins = new xm(Object, "plugins"), this.scales = new xm(Bh, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...a) {
    this._each("register", a);
  }
  remove(...a) {
    this._each("unregister", a);
  }
  addControllers(...a) {
    this._each("register", a, this.controllers);
  }
  addElements(...a) {
    this._each("register", a, this.elements);
  }
  addPlugins(...a) {
    this._each("register", a, this.plugins);
  }
  addScales(...a) {
    this._each("register", a, this.scales);
  }
  getController(a) {
    return this._get(a, this.controllers, "controller");
  }
  getElement(a) {
    return this._get(a, this.elements, "element");
  }
  getPlugin(a) {
    return this._get(a, this.plugins, "plugin");
  }
  getScale(a) {
    return this._get(a, this.scales, "scale");
  }
  removeControllers(...a) {
    this._each("unregister", a, this.controllers);
  }
  removeElements(...a) {
    this._each("unregister", a, this.elements);
  }
  removePlugins(...a) {
    this._each("unregister", a, this.plugins);
  }
  removeScales(...a) {
    this._each("unregister", a, this.scales);
  }
  _each(a, d, g) {
    [
      ...d
    ].forEach((w) => {
      const b = g || this._getRegistryForType(w);
      g || b.isForType(w) || b === this.plugins && w.id ? this._exec(a, b, w) : Zn(w, (E) => {
        const i = g || this._getRegistryForType(E);
        this._exec(a, i, E);
      });
    });
  }
  _exec(a, d, g) {
    const w = hy(a);
    is(g["before" + w], [], g), d[a](g), is(g["after" + w], [], g);
  }
  _getRegistryForType(a) {
    for (let d = 0; d < this._typedRegistries.length; d++) {
      const g = this._typedRegistries[d];
      if (g.isForType(a))
        return g;
    }
    return this.plugins;
  }
  _get(a, d, g) {
    const w = d.get(a);
    if (w === void 0)
      throw new Error('"' + a + '" is not a registered ' + g + ".");
    return w;
  }
}
var al = /* @__PURE__ */ new bA();
class wA {
  constructor() {
    this._init = [];
  }
  notify(a, d, g, w) {
    d === "beforeInit" && (this._init = this._createDescriptors(a, !0), this._notify(this._init, a, "install"));
    const b = w ? this._descriptors(a).filter(w) : this._descriptors(a), E = this._notify(b, a, d, g);
    return d === "afterDestroy" && (this._notify(b, a, "stop"), this._notify(this._init, a, "uninstall")), E;
  }
  _notify(a, d, g, w) {
    w = w || {};
    for (const b of a) {
      const E = b.plugin, i = E[g], O = [
        d,
        w,
        b.options
      ];
      if (is(i, O, E) === !1 && w.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    En(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(a) {
    if (this._cache)
      return this._cache;
    const d = this._cache = this._createDescriptors(a);
    return this._notifyStateChanges(a), d;
  }
  _createDescriptors(a, d) {
    const g = a && a.config, w = en(g.options && g.options.plugins, {}), b = TA(g);
    return w === !1 && !d ? [] : SA(a, b, w, d);
  }
  _notifyStateChanges(a) {
    const d = this._oldCache || [], g = this._cache, w = (b, E) => b.filter((i) => !E.some((O) => i.plugin.id === O.plugin.id));
    this._notify(w(d, g), a, "stop"), this._notify(w(g, d), a, "start");
  }
}
function TA(m) {
  const a = {}, d = [], g = Object.keys(al.plugins.items);
  for (let b = 0; b < g.length; b++)
    d.push(al.getPlugin(g[b]));
  const w = m.plugins || [];
  for (let b = 0; b < w.length; b++) {
    const E = w[b];
    d.indexOf(E) === -1 && (d.push(E), a[E.id] = !0);
  }
  return {
    plugins: d,
    localIds: a
  };
}
function MA(m, a) {
  return !a && m === !1 ? null : m === !0 ? {} : m;
}
function SA(m, { plugins: a, localIds: d }, g, w) {
  const b = [], E = m.getContext();
  for (const i of a) {
    const O = i.id, j = MA(g[O], w);
    j !== null && b.push({
      plugin: i,
      options: EA(m.config, {
        plugin: i,
        local: d[O]
      }, j, E)
    });
  }
  return b;
}
function EA(m, { plugin: a, local: d }, g, w) {
  const b = m.pluginScopeKeys(a), E = m.getOptionScopes(g, b);
  return d && a.defaults && E.push(a.defaults), m.createResolver(E, w, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function $g(m, a) {
  const d = ys.datasets[m] || {};
  return ((a.datasets || {})[m] || {}).indexAxis || a.indexAxis || d.indexAxis || "x";
}
function AA(m, a) {
  let d = m;
  return m === "_index_" ? d = a : m === "_value_" && (d = a === "x" ? "y" : "x"), d;
}
function PA(m, a) {
  return m === a ? "_index_" : "_value_";
}
function R1(m) {
  if (m === "x" || m === "y" || m === "r")
    return m;
}
function CA(m) {
  if (m === "top" || m === "bottom")
    return "x";
  if (m === "left" || m === "right")
    return "y";
}
function Xg(m, ...a) {
  if (R1(m))
    return m;
  for (const d of a) {
    const g = d.axis || CA(d.position) || m.length > 1 && R1(m[0].toLowerCase());
    if (g)
      return g;
  }
  throw new Error(`Cannot determine type of '${m}' axis. Please provide 'axis' or 'position' option.`);
}
function O1(m, a, d) {
  if (d[a + "AxisID"] === m)
    return {
      axis: a
    };
}
function IA(m, a) {
  if (a.data && a.data.datasets) {
    const d = a.data.datasets.filter((g) => g.xAxisID === m || g.yAxisID === m);
    if (d.length)
      return O1(m, "x", d[0]) || O1(m, "y", d[0]);
  }
  return {};
}
function LA(m, a) {
  const d = Oh[m.type] || {
    scales: {}
  }, g = a.scales || {}, w = $g(m.type, a), b = /* @__PURE__ */ Object.create(null);
  return Object.keys(g).forEach((E) => {
    const i = g[E];
    if (!yn(i))
      return console.error(`Invalid scale configuration for scale: ${E}`);
    if (i._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${E}`);
    const O = Xg(E, i, IA(E, m), ys.scales[i.type]), j = PA(O, w), Y = d.scales || {};
    b[E] = Cf(/* @__PURE__ */ Object.create(null), [
      {
        axis: O
      },
      i,
      Y[O],
      Y[j]
    ]);
  }), m.data.datasets.forEach((E) => {
    const i = E.type || m.type, O = E.indexAxis || $g(i, a), Y = (Oh[i] || {}).scales || {};
    Object.keys(Y).forEach((J) => {
      const ae = AA(J, O), ce = E[ae + "AxisID"] || ae;
      b[ce] = b[ce] || /* @__PURE__ */ Object.create(null), Cf(b[ce], [
        {
          axis: ae
        },
        g[ce],
        Y[J]
      ]);
    });
  }), Object.keys(b).forEach((E) => {
    const i = b[E];
    Cf(i, [
      ys.scales[i.type],
      ys.scale
    ]);
  }), b;
}
function iw(m) {
  const a = m.options || (m.options = {});
  a.plugins = en(a.plugins, {}), a.scales = LA(m, a);
}
function nw(m) {
  return m = m || {}, m.datasets = m.datasets || [], m.labels = m.labels || [], m;
}
function zA(m) {
  return m = m || {}, m.data = nw(m.data), iw(m), m;
}
const F1 = /* @__PURE__ */ new Map(), sw = /* @__PURE__ */ new Set();
function vm(m, a) {
  let d = F1.get(m);
  return d || (d = a(), F1.set(m, d), sw.add(d)), d;
}
const bf = (m, a, d) => {
  const g = Rc(a, d);
  g !== void 0 && m.add(g);
};
class DA {
  constructor(a) {
    this._config = zA(a), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(a) {
    this._config.type = a;
  }
  get data() {
    return this._config.data;
  }
  set data(a) {
    this._config.data = nw(a);
  }
  get options() {
    return this._config.options;
  }
  set options(a) {
    this._config.options = a;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const a = this._config;
    this.clearCache(), iw(a);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(a) {
    return vm(a, () => [
      [
        `datasets.${a}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(a, d) {
    return vm(`${a}.transition.${d}`, () => [
      [
        `datasets.${a}.transitions.${d}`,
        `transitions.${d}`
      ],
      [
        `datasets.${a}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(a, d) {
    return vm(`${a}-${d}`, () => [
      [
        `datasets.${a}.elements.${d}`,
        `datasets.${a}`,
        `elements.${d}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(a) {
    const d = a.id, g = this.type;
    return vm(`${g}-plugin-${d}`, () => [
      [
        `plugins.${d}`,
        ...a.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(a, d) {
    const g = this._scopeCache;
    let w = g.get(a);
    return (!w || d) && (w = /* @__PURE__ */ new Map(), g.set(a, w)), w;
  }
  getOptionScopes(a, d, g) {
    const { options: w, type: b } = this, E = this._cachedScopes(a, g), i = E.get(d);
    if (i)
      return i;
    const O = /* @__PURE__ */ new Set();
    d.forEach((Y) => {
      a && (O.add(a), Y.forEach((J) => bf(O, a, J))), Y.forEach((J) => bf(O, w, J)), Y.forEach((J) => bf(O, Oh[b] || {}, J)), Y.forEach((J) => bf(O, ys, J)), Y.forEach((J) => bf(O, Hg, J));
    });
    const j = Array.from(O);
    return j.length === 0 && j.push(/* @__PURE__ */ Object.create(null)), sw.has(d) && E.set(d, j), j;
  }
  chartOptionScopes() {
    const { options: a, type: d } = this;
    return [
      a,
      Oh[d] || {},
      ys.datasets[d] || {},
      {
        type: d
      },
      ys,
      Hg
    ];
  }
  resolveNamedOptions(a, d, g, w = [
    ""
  ]) {
    const b = {
      $shared: !0
    }, { resolver: E, subPrefixes: i } = B1(this._resolverCache, a, w);
    let O = E;
    if (RA(E, d)) {
      b.$shared = !1, g = Oc(g) ? g() : g;
      const j = this.createResolver(a, g, i);
      O = Yu(E, g, j);
    }
    for (const j of d)
      b[j] = O[j];
    return b;
  }
  createResolver(a, d, g = [
    ""
  ], w) {
    const { resolver: b } = B1(this._resolverCache, a, g);
    return yn(d) ? Yu(b, d, void 0, w) : b;
  }
}
function B1(m, a, d) {
  let g = m.get(a);
  g || (g = /* @__PURE__ */ new Map(), m.set(a, g));
  const w = d.join();
  let b = g.get(w);
  return b || (b = {
    resolver: _y(a, d),
    subPrefixes: d.filter((i) => !i.toLowerCase().includes("hover"))
  }, g.set(w, b)), b;
}
const kA = (m) => yn(m) && Object.getOwnPropertyNames(m).some((a) => Oc(m[a]));
function RA(m, a) {
  const { isScriptable: d, isIndexable: g } = Fb(m);
  for (const w of a) {
    const b = d(w), E = g(w), i = (E || b) && m[w];
    if (b && (Oc(i) || kA(i)) || E && hs(i))
      return !0;
  }
  return !1;
}
var OA = "4.4.7";
const FA = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function N1(m, a) {
  return m === "top" || m === "bottom" || FA.indexOf(m) === -1 && a === "x";
}
function V1(m, a) {
  return function(d, g) {
    return d[m] === g[m] ? d[a] - g[a] : d[m] - g[m];
  };
}
function U1(m) {
  const a = m.chart, d = a.options.animation;
  a.notifyPlugins("afterRender"), is(d && d.onComplete, [
    m
  ], a);
}
function BA(m) {
  const a = m.chart, d = a.options.animation;
  is(d && d.onProgress, [
    m
  ], a);
}
function rw(m) {
  return xy() && typeof m == "string" ? m = document.getElementById(m) : m && m.length && (m = m[0]), m && m.canvas && (m = m.canvas), m;
}
const Dm = {}, j1 = (m) => {
  const a = rw(m);
  return Object.values(Dm).filter((d) => d.canvas === a).pop();
};
function NA(m, a, d) {
  const g = Object.keys(m);
  for (const w of g) {
    const b = +w;
    if (b >= a) {
      const E = m[w];
      delete m[w], (d > 0 || b > a) && (m[b + d] = E);
    }
  }
}
function VA(m, a, d, g) {
  return !d || m.type === "mouseout" ? null : g ? a : m;
}
function bm(m, a, d) {
  return m.options.clip ? m[d] : a[d];
}
function UA(m, a) {
  const { xScale: d, yScale: g } = m;
  return d && g ? {
    left: bm(d, a, "left"),
    right: bm(d, a, "right"),
    top: bm(g, a, "top"),
    bottom: bm(g, a, "bottom")
  } : a;
}
class Bl {
  static register(...a) {
    al.add(...a), G1();
  }
  static unregister(...a) {
    al.remove(...a), G1();
  }
  constructor(a, d) {
    const g = this.config = new DA(d), w = rw(a), b = j1(w);
    if (b)
      throw new Error("Canvas is already in use. Chart with ID '" + b.id + "' must be destroyed before the canvas with ID '" + b.canvas.id + "' can be reused.");
    const E = g.createResolver(g.chartOptionScopes(), this.getContext());
    this.platform = new (g.platform || sA(w))(), this.platform.updateConfig(g);
    const i = this.platform.acquireContext(w, E.aspectRatio), O = i && i.canvas, j = O && O.height, Y = O && O.width;
    if (this.id = GM(), this.ctx = i, this.canvas = O, this.width = Y, this.height = j, this._options = E, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new wA(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = rS((J) => this.update(J), E.resizeDelay || 0), this._dataChanges = [], Dm[this.id] = this, !i || !O) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Rl.listen(this, "complete", U1), Rl.listen(this, "progress", BA), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: a, maintainAspectRatio: d }, width: g, height: w, _aspectRatio: b } = this;
    return En(a) ? d && b ? b : w ? g / w : null : a;
  }
  get data() {
    return this.config.data;
  }
  set data(a) {
    this.config.data = a;
  }
  get options() {
    return this._options;
  }
  set options(a) {
    this.config.options = a;
  }
  get registry() {
    return al;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : u1(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return l1(this.canvas, this.ctx), this;
  }
  stop() {
    return Rl.stop(this), this;
  }
  resize(a, d) {
    Rl.running(this) ? this._resizeBeforeDraw = {
      width: a,
      height: d
    } : this._resize(a, d);
  }
  _resize(a, d) {
    const g = this.options, w = this.canvas, b = g.maintainAspectRatio && this.aspectRatio, E = this.platform.getMaximumSize(w, a, d, b), i = g.devicePixelRatio || this.platform.getDevicePixelRatio(), O = this.width ? "resize" : "attach";
    this.width = E.width, this.height = E.height, this._aspectRatio = this.aspectRatio, u1(this, i, !0) && (this.notifyPlugins("resize", {
      size: E
    }), is(g.onResize, [
      this,
      E
    ], this), this.attached && this._doResize(O) && this.render());
  }
  ensureScalesHaveIDs() {
    const d = this.options.scales || {};
    Zn(d, (g, w) => {
      g.id = w;
    });
  }
  buildOrUpdateScales() {
    const a = this.options, d = a.scales, g = this.scales, w = Object.keys(g).reduce((E, i) => (E[i] = !1, E), {});
    let b = [];
    d && (b = b.concat(Object.keys(d).map((E) => {
      const i = d[E], O = Xg(E, i), j = O === "r", Y = O === "x";
      return {
        options: i,
        dposition: j ? "chartArea" : Y ? "bottom" : "left",
        dtype: j ? "radialLinear" : Y ? "category" : "linear"
      };
    }))), Zn(b, (E) => {
      const i = E.options, O = i.id, j = Xg(O, i), Y = en(i.type, E.dtype);
      (i.position === void 0 || N1(i.position, j) !== N1(E.dposition)) && (i.position = E.dposition), w[O] = !0;
      let J = null;
      if (O in g && g[O].type === Y)
        J = g[O];
      else {
        const ae = al.getScale(Y);
        J = new ae({
          id: O,
          type: Y,
          ctx: this.ctx,
          chart: this
        }), g[J.id] = J;
      }
      J.init(i, a);
    }), Zn(w, (E, i) => {
      E || delete g[i];
    }), Zn(g, (E) => {
      jr.configure(this, E, E.options), jr.addBox(this, E);
    });
  }
  _updateMetasets() {
    const a = this._metasets, d = this.data.datasets.length, g = a.length;
    if (a.sort((w, b) => w.index - b.index), g > d) {
      for (let w = d; w < g; ++w)
        this._destroyDatasetMeta(w);
      a.splice(d, g - d);
    }
    this._sortedMetasets = a.slice(0).sort(V1("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: a, data: { datasets: d } } = this;
    a.length > d.length && delete this._stacks, a.forEach((g, w) => {
      d.filter((b) => b === g._dataset).length === 0 && this._destroyDatasetMeta(w);
    });
  }
  buildOrUpdateControllers() {
    const a = [], d = this.data.datasets;
    let g, w;
    for (this._removeUnreferencedMetasets(), g = 0, w = d.length; g < w; g++) {
      const b = d[g];
      let E = this.getDatasetMeta(g);
      const i = b.type || this.config.type;
      if (E.type && E.type !== i && (this._destroyDatasetMeta(g), E = this.getDatasetMeta(g)), E.type = i, E.indexAxis = b.indexAxis || $g(i, this.options), E.order = b.order || 0, E.index = g, E.label = "" + b.label, E.visible = this.isDatasetVisible(g), E.controller)
        E.controller.updateIndex(g), E.controller.linkScales();
      else {
        const O = al.getController(i), { datasetElementType: j, dataElementType: Y } = ys.datasets[i];
        Object.assign(O, {
          dataElementType: al.getElement(Y),
          datasetElementType: j && al.getElement(j)
        }), E.controller = new O(this, g), a.push(E.controller);
      }
    }
    return this._updateMetasets(), a;
  }
  _resetElements() {
    Zn(this.data.datasets, (a, d) => {
      this.getDatasetMeta(d).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(a) {
    const d = this.config;
    d.update();
    const g = this._options = d.createResolver(d.chartOptionScopes(), this.getContext()), w = this._animationsDisabled = !g.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: a,
      cancelable: !0
    }) === !1)
      return;
    const b = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let E = 0;
    for (let j = 0, Y = this.data.datasets.length; j < Y; j++) {
      const { controller: J } = this.getDatasetMeta(j), ae = !w && b.indexOf(J) === -1;
      J.buildOrUpdateElements(ae), E = Math.max(+J.getMaxOverflow(), E);
    }
    E = this._minPadding = g.layout.autoPadding ? E : 0, this._updateLayout(E), w || Zn(b, (j) => {
      j.reset();
    }), this._updateDatasets(a), this.notifyPlugins("afterUpdate", {
      mode: a
    }), this._layers.sort(V1("z", "_idx"));
    const { _active: i, _lastEvent: O } = this;
    O ? this._eventHandler(O, !0) : i.length && this._updateHoverStyles(i, i, !0), this.render();
  }
  _updateScales() {
    Zn(this.scales, (a) => {
      jr.removeBox(this, a);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const a = this.options, d = new Set(Object.keys(this._listeners)), g = new Set(a.events);
    (!Qv(d, g) || !!this._responsiveListeners !== a.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: a } = this, d = this._getUniformDataChanges() || [];
    for (const { method: g, start: w, count: b } of d) {
      const E = g === "_removeElements" ? -b : b;
      NA(a, w, E);
    }
  }
  _getUniformDataChanges() {
    const a = this._dataChanges;
    if (!a || !a.length)
      return;
    this._dataChanges = [];
    const d = this.data.datasets.length, g = (b) => new Set(a.filter((E) => E[0] === b).map((E, i) => i + "," + E.splice(1).join(","))), w = g(0);
    for (let b = 1; b < d; b++)
      if (!Qv(w, g(b)))
        return;
    return Array.from(w).map((b) => b.split(",")).map((b) => ({
      method: b[1],
      start: +b[2],
      count: +b[3]
    }));
  }
  _updateLayout(a) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    jr.update(this, this.width, this.height, a);
    const d = this.chartArea, g = d.width <= 0 || d.height <= 0;
    this._layers = [], Zn(this.boxes, (w) => {
      g && w.position === "chartArea" || (w.configure && w.configure(), this._layers.push(...w._layers()));
    }, this), this._layers.forEach((w, b) => {
      w._idx = b;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(a) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: a,
      cancelable: !0
    }) !== !1) {
      for (let d = 0, g = this.data.datasets.length; d < g; ++d)
        this.getDatasetMeta(d).controller.configure();
      for (let d = 0, g = this.data.datasets.length; d < g; ++d)
        this._updateDataset(d, Oc(a) ? a({
          datasetIndex: d
        }) : a);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: a
      });
    }
  }
  _updateDataset(a, d) {
    const g = this.getDatasetMeta(a), w = {
      meta: g,
      index: a,
      mode: d,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", w) !== !1 && (g.controller._update(d), w.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", w));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Rl.has(this) ? this.attached && !Rl.running(this) && Rl.start(this) : (this.draw(), U1({
      chart: this
    })));
  }
  draw() {
    let a;
    if (this._resizeBeforeDraw) {
      const { width: g, height: w } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(g, w);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const d = this._layers;
    for (a = 0; a < d.length && d[a].z <= 0; ++a)
      d[a].draw(this.chartArea);
    for (this._drawDatasets(); a < d.length; ++a)
      d[a].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(a) {
    const d = this._sortedMetasets, g = [];
    let w, b;
    for (w = 0, b = d.length; w < b; ++w) {
      const E = d[w];
      (!a || E.visible) && g.push(E);
    }
    return g;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const a = this.getSortedVisibleDatasetMetas();
    for (let d = a.length - 1; d >= 0; --d)
      this._drawDataset(a[d]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(a) {
    const d = this.ctx, g = a._clip, w = !g.disabled, b = UA(a, this.chartArea), E = {
      meta: a,
      index: a.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", E) !== !1 && (w && Wm(d, {
      left: g.left === !1 ? 0 : b.left - g.left,
      right: g.right === !1 ? this.width : b.right + g.right,
      top: g.top === !1 ? 0 : b.top - g.top,
      bottom: g.bottom === !1 ? this.height : b.bottom + g.bottom
    }), a.controller.draw(), w && $m(d), E.cancelable = !1, this.notifyPlugins("afterDatasetDraw", E));
  }
  isPointInArea(a) {
    return Ul(a, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(a, d, g, w) {
    const b = FE.modes[d];
    return typeof b == "function" ? b(this, a, g, w) : [];
  }
  getDatasetMeta(a) {
    const d = this.data.datasets[a], g = this._metasets;
    let w = g.filter((b) => b && b._dataset === d).pop();
    return w || (w = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: d && d.order || 0,
      index: a,
      _dataset: d,
      _parsed: [],
      _sorted: !1
    }, g.push(w)), w;
  }
  getContext() {
    return this.$context || (this.$context = Fc(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(a) {
    const d = this.data.datasets[a];
    if (!d)
      return !1;
    const g = this.getDatasetMeta(a);
    return typeof g.hidden == "boolean" ? !g.hidden : !d.hidden;
  }
  setDatasetVisibility(a, d) {
    const g = this.getDatasetMeta(a);
    g.hidden = !d;
  }
  toggleDataVisibility(a) {
    this._hiddenIndices[a] = !this._hiddenIndices[a];
  }
  getDataVisibility(a) {
    return !this._hiddenIndices[a];
  }
  _updateVisibility(a, d, g) {
    const w = g ? "show" : "hide", b = this.getDatasetMeta(a), E = b.controller._resolveAnimations(void 0, w);
    Of(d) ? (b.data[d].hidden = !g, this.update()) : (this.setDatasetVisibility(a, g), E.update(b, {
      visible: g
    }), this.update((i) => i.datasetIndex === a ? w : void 0));
  }
  hide(a, d) {
    this._updateVisibility(a, d, !1);
  }
  show(a, d) {
    this._updateVisibility(a, d, !0);
  }
  _destroyDatasetMeta(a) {
    const d = this._metasets[a];
    d && d.controller && d.controller._destroy(), delete this._metasets[a];
  }
  _stop() {
    let a, d;
    for (this.stop(), Rl.remove(this), a = 0, d = this.data.datasets.length; a < d; ++a)
      this._destroyDatasetMeta(a);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: a, ctx: d } = this;
    this._stop(), this.config.clearCache(), a && (this.unbindEvents(), l1(a, d), this.platform.releaseContext(d), this.canvas = null, this.ctx = null), delete Dm[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...a) {
    return this.canvas.toDataURL(...a);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const a = this._listeners, d = this.platform, g = (b, E) => {
      d.addEventListener(this, b, E), a[b] = E;
    }, w = (b, E, i) => {
      b.offsetX = E, b.offsetY = i, this._eventHandler(b);
    };
    Zn(this.options.events, (b) => g(b, w));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const a = this._responsiveListeners, d = this.platform, g = (O, j) => {
      d.addEventListener(this, O, j), a[O] = j;
    }, w = (O, j) => {
      a[O] && (d.removeEventListener(this, O, j), delete a[O]);
    }, b = (O, j) => {
      this.canvas && this.resize(O, j);
    };
    let E;
    const i = () => {
      w("attach", i), this.attached = !0, this.resize(), g("resize", b), g("detach", E);
    };
    E = () => {
      this.attached = !1, w("resize", b), this._stop(), this._resize(0, 0), g("attach", i);
    }, d.isAttached(this.canvas) ? i() : E();
  }
  unbindEvents() {
    Zn(this._listeners, (a, d) => {
      this.platform.removeEventListener(this, d, a);
    }), this._listeners = {}, Zn(this._responsiveListeners, (a, d) => {
      this.platform.removeEventListener(this, d, a);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(a, d, g) {
    const w = g ? "set" : "remove";
    let b, E, i, O;
    for (d === "dataset" && (b = this.getDatasetMeta(a[0].datasetIndex), b.controller["_" + w + "DatasetHoverStyle"]()), i = 0, O = a.length; i < O; ++i) {
      E = a[i];
      const j = E && this.getDatasetMeta(E.datasetIndex).controller;
      j && j[w + "HoverStyle"](E.element, E.datasetIndex, E.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(a) {
    const d = this._active || [], g = a.map(({ datasetIndex: b, index: E }) => {
      const i = this.getDatasetMeta(b);
      if (!i)
        throw new Error("No dataset found at index " + b);
      return {
        datasetIndex: b,
        element: i.data[E],
        index: E
      };
    });
    !Om(g, d) && (this._active = g, this._lastEvent = null, this._updateHoverStyles(g, d));
  }
  notifyPlugins(a, d, g) {
    return this._plugins.notify(this, a, d, g);
  }
  isPluginEnabled(a) {
    return this._plugins._cache.filter((d) => d.plugin.id === a).length === 1;
  }
  _updateHoverStyles(a, d, g) {
    const w = this.options.hover, b = (O, j) => O.filter((Y) => !j.some((J) => Y.datasetIndex === J.datasetIndex && Y.index === J.index)), E = b(d, a), i = g ? a : b(a, d);
    E.length && this.updateHoverStyle(E, w.mode, !1), i.length && w.mode && this.updateHoverStyle(i, w.mode, !0);
  }
  _eventHandler(a, d) {
    const g = {
      event: a,
      replay: d,
      cancelable: !0,
      inChartArea: this.isPointInArea(a)
    }, w = (E) => (E.options.events || this.options.events).includes(a.native.type);
    if (this.notifyPlugins("beforeEvent", g, w) === !1)
      return;
    const b = this._handleEvent(a, d, g.inChartArea);
    return g.cancelable = !1, this.notifyPlugins("afterEvent", g, w), (b || g.changed) && this.render(), this;
  }
  _handleEvent(a, d, g) {
    const { _active: w = [], options: b } = this, E = d, i = this._getActiveElements(a, w, g, E), O = XM(a), j = VA(a, this._lastEvent, g, O);
    g && (this._lastEvent = null, is(b.onHover, [
      a,
      i,
      this
    ], this), O && is(b.onClick, [
      a,
      i,
      this
    ], this));
    const Y = !Om(i, w);
    return (Y || d) && (this._active = i, this._updateHoverStyles(i, w, d)), this._lastEvent = j, Y;
  }
  _getActiveElements(a, d, g, w) {
    if (a.type === "mouseout")
      return [];
    if (!g)
      return d;
    const b = this.options.hover;
    return this.getElementsAtEventForMode(a, b.mode, b, w);
  }
}
Yt(Bl, "defaults", ys), Yt(Bl, "instances", Dm), Yt(Bl, "overrides", Oh), Yt(Bl, "registry", al), Yt(Bl, "version", OA), Yt(Bl, "getChart", j1);
function G1() {
  return Zn(Bl.instances, (m) => m._plugins.invalidate());
}
function jA(m, a, d) {
  const { startAngle: g, pixelMargin: w, x: b, y: E, outerRadius: i, innerRadius: O } = a;
  let j = w / i;
  m.beginPath(), m.arc(b, E, i, g - j, d + j), O > w ? (j = w / O, m.arc(b, E, O, d + j, g - j, !0)) : m.arc(b, E, w, d + Ns, g - Ns), m.closePath(), m.clip();
}
function GA(m) {
  return my(m, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function ZA(m, a, d, g) {
  const w = GA(m.options.borderRadius), b = (d - a) / 2, E = Math.min(b, g * a / 2), i = (O) => {
    const j = (d - Math.min(b, O)) * g / 2;
    return gr(O, 0, Math.min(b, j));
  };
  return {
    outerStart: i(w.outerStart),
    outerEnd: i(w.outerEnd),
    innerStart: gr(w.innerStart, 0, E),
    innerEnd: gr(w.innerEnd, 0, E)
  };
}
function Wu(m, a, d, g) {
  return {
    x: d + m * Math.cos(a),
    y: g + m * Math.sin(a)
  };
}
function jm(m, a, d, g, w, b) {
  const { x: E, y: i, startAngle: O, pixelMargin: j, innerRadius: Y } = a, J = Math.max(a.outerRadius + g + d - j, 0), ae = Y > 0 ? Y + g + d + j : 0;
  let ce = 0;
  const Te = w - O;
  if (g) {
    const Ht = Y > 0 ? Y - g : 0, Si = J > 0 ? J - g : 0, Ji = (Ht + Si) / 2, fi = Ji !== 0 ? Te * Ji / (Ji + g) : Te;
    ce = (Te - fi) / 2;
  }
  const be = Math.max(1e-3, Te * J - d / ds) / J, Ze = (Te - be) / 2, je = O + Ze + ce, ot = w - Ze - ce, { outerStart: vt, outerEnd: ht, innerStart: gt, innerEnd: Vt } = ZA(a, ae, J, ot - je), pt = J - vt, Gt = J - ht, ui = je + vt / pt, kt = ot - ht / Gt, At = ae + gt, Mi = ae + Vt, An = je + gt / At, hn = ot - Vt / Mi;
  if (m.beginPath(), b) {
    const Ht = (ui + kt) / 2;
    if (m.arc(E, i, J, ui, Ht), m.arc(E, i, J, Ht, kt), ht > 0) {
      const jt = Wu(Gt, kt, E, i);
      m.arc(jt.x, jt.y, ht, kt, ot + Ns);
    }
    const Si = Wu(Mi, ot, E, i);
    if (m.lineTo(Si.x, Si.y), Vt > 0) {
      const jt = Wu(Mi, hn, E, i);
      m.arc(jt.x, jt.y, Vt, ot + Ns, hn + Math.PI);
    }
    const Ji = (ot - Vt / ae + (je + gt / ae)) / 2;
    if (m.arc(E, i, ae, ot - Vt / ae, Ji, !0), m.arc(E, i, ae, Ji, je + gt / ae, !0), gt > 0) {
      const jt = Wu(At, An, E, i);
      m.arc(jt.x, jt.y, gt, An + Math.PI, je - Ns);
    }
    const fi = Wu(pt, je, E, i);
    if (m.lineTo(fi.x, fi.y), vt > 0) {
      const jt = Wu(pt, ui, E, i);
      m.arc(jt.x, jt.y, vt, je - Ns, ui);
    }
  } else {
    m.moveTo(E, i);
    const Ht = Math.cos(ui) * J + E, Si = Math.sin(ui) * J + i;
    m.lineTo(Ht, Si);
    const Ji = Math.cos(kt) * J + E, fi = Math.sin(kt) * J + i;
    m.lineTo(Ji, fi);
  }
  m.closePath();
}
function HA(m, a, d, g, w) {
  const { fullCircles: b, startAngle: E, circumference: i } = a;
  let O = a.endAngle;
  if (b) {
    jm(m, a, d, g, O, w);
    for (let j = 0; j < b; ++j)
      m.fill();
    isNaN(i) || (O = E + (i % us || us));
  }
  return jm(m, a, d, g, O, w), m.fill(), O;
}
function qA(m, a, d, g, w) {
  const { fullCircles: b, startAngle: E, circumference: i, options: O } = a, { borderWidth: j, borderJoinStyle: Y, borderDash: J, borderDashOffset: ae } = O, ce = O.borderAlign === "inner";
  if (!j)
    return;
  m.setLineDash(J || []), m.lineDashOffset = ae, ce ? (m.lineWidth = j * 2, m.lineJoin = Y || "round") : (m.lineWidth = j, m.lineJoin = Y || "bevel");
  let Te = a.endAngle;
  if (b) {
    jm(m, a, d, g, Te, w);
    for (let be = 0; be < b; ++be)
      m.stroke();
    isNaN(i) || (Te = E + (i % us || us));
  }
  ce && jA(m, a, Te), b || (jm(m, a, d, g, Te, w), m.stroke());
}
class Sf extends jl {
  constructor(d) {
    super();
    Yt(this, "circumference");
    Yt(this, "endAngle");
    Yt(this, "fullCircles");
    Yt(this, "innerRadius");
    Yt(this, "outerRadius");
    Yt(this, "pixelMargin");
    Yt(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, d && Object.assign(this, d);
  }
  inRange(d, g, w) {
    const b = this.getProps([
      "x",
      "y"
    ], w), { angle: E, distance: i } = Ab(b, {
      x: d,
      y: g
    }), { startAngle: O, endAngle: j, innerRadius: Y, outerRadius: J, circumference: ae } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], w), ce = (this.options.spacing + this.options.borderWidth) / 2, Te = en(ae, j - O), be = Ff(E, O, j) && O !== j, Ze = Te >= us || be, je = Nl(i, Y + ce, J + ce);
    return Ze && je;
  }
  getCenterPoint(d) {
    const { x: g, y: w, startAngle: b, endAngle: E, innerRadius: i, outerRadius: O } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], d), { offset: j, spacing: Y } = this.options, J = (b + E) / 2, ae = (i + O + Y + j) / 2;
    return {
      x: g + Math.cos(J) * ae,
      y: w + Math.sin(J) * ae
    };
  }
  tooltipPosition(d) {
    return this.getCenterPoint(d);
  }
  draw(d) {
    const { options: g, circumference: w } = this, b = (g.offset || 0) / 4, E = (g.spacing || 0) / 2, i = g.circular;
    if (this.pixelMargin = g.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = w > us ? Math.floor(w / us) : 0, w === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    d.save();
    const O = (this.startAngle + this.endAngle) / 2;
    d.translate(Math.cos(O) * b, Math.sin(O) * b);
    const j = 1 - Math.sin(Math.min(ds, w || 0)), Y = b * j;
    d.fillStyle = g.backgroundColor, d.strokeStyle = g.borderColor, HA(d, this, Y, E, i), qA(d, this, Y, E, i), d.restore();
  }
}
Yt(Sf, "id", "arc"), Yt(Sf, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), Yt(Sf, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), Yt(Sf, "descriptors", {
  _scriptable: !0,
  _indexable: (d) => d !== "borderDash"
});
function ow(m, a, d = a) {
  m.lineCap = en(d.borderCapStyle, a.borderCapStyle), m.setLineDash(en(d.borderDash, a.borderDash)), m.lineDashOffset = en(d.borderDashOffset, a.borderDashOffset), m.lineJoin = en(d.borderJoinStyle, a.borderJoinStyle), m.lineWidth = en(d.borderWidth, a.borderWidth), m.strokeStyle = en(d.borderColor, a.borderColor);
}
function WA(m, a, d) {
  m.lineTo(d.x, d.y);
}
function $A(m) {
  return m.stepped ? gS : m.tension || m.cubicInterpolationMode === "monotone" ? yS : WA;
}
function aw(m, a, d = {}) {
  const g = m.length, { start: w = 0, end: b = g - 1 } = d, { start: E, end: i } = a, O = Math.max(w, E), j = Math.min(b, i), Y = w < E && b < E || w > i && b > i;
  return {
    count: g,
    start: O,
    loop: a.loop,
    ilen: j < O && !Y ? g + j - O : j - O
  };
}
function XA(m, a, d, g) {
  const { points: w, options: b } = a, { count: E, start: i, loop: O, ilen: j } = aw(w, d, g), Y = $A(b);
  let { move: J = !0, reverse: ae } = g || {}, ce, Te, be;
  for (ce = 0; ce <= j; ++ce)
    Te = w[(i + (ae ? j - ce : ce)) % E], !Te.skip && (J ? (m.moveTo(Te.x, Te.y), J = !1) : Y(m, be, Te, ae, b.stepped), be = Te);
  return O && (Te = w[(i + (ae ? j : 0)) % E], Y(m, be, Te, ae, b.stepped)), !!O;
}
function YA(m, a, d, g) {
  const w = a.points, { count: b, start: E, ilen: i } = aw(w, d, g), { move: O = !0, reverse: j } = g || {};
  let Y = 0, J = 0, ae, ce, Te, be, Ze, je;
  const ot = (ht) => (E + (j ? i - ht : ht)) % b, vt = () => {
    be !== Ze && (m.lineTo(Y, Ze), m.lineTo(Y, be), m.lineTo(Y, je));
  };
  for (O && (ce = w[ot(0)], m.moveTo(ce.x, ce.y)), ae = 0; ae <= i; ++ae) {
    if (ce = w[ot(ae)], ce.skip)
      continue;
    const ht = ce.x, gt = ce.y, Vt = ht | 0;
    Vt === Te ? (gt < be ? be = gt : gt > Ze && (Ze = gt), Y = (J * Y + ht) / ++J) : (vt(), m.lineTo(ht, gt), Te = Vt, J = 0, be = Ze = gt), je = gt;
  }
  vt();
}
function Yg(m) {
  const a = m.options, d = a.borderDash && a.borderDash.length;
  return !m._decimated && !m._loop && !a.tension && a.cubicInterpolationMode !== "monotone" && !a.stepped && !d ? YA : XA;
}
function KA(m) {
  return m.stepped ? YS : m.tension || m.cubicInterpolationMode === "monotone" ? KS : zh;
}
function JA(m, a, d, g) {
  let w = a._path;
  w || (w = a._path = new Path2D(), a.path(w, d, g) && w.closePath()), ow(m, a.options), m.stroke(w);
}
function QA(m, a, d, g) {
  const { segments: w, options: b } = a, E = Yg(a);
  for (const i of w)
    ow(m, b, i.style), m.beginPath(), E(m, a, i, {
      start: d,
      end: d + g - 1
    }) && m.closePath(), m.stroke();
}
const eP = typeof Path2D == "function";
function tP(m, a, d, g) {
  eP && !a.options.segment ? JA(m, a, d, g) : QA(m, a, d, g);
}
class zc extends jl {
  constructor(a) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, a && Object.assign(this, a);
  }
  updateControlPoints(a, d) {
    const g = this.options;
    if ((g.tension || g.cubicInterpolationMode === "monotone") && !g.stepped && !this._pointsUpdated) {
      const w = g.spanGaps ? this._loop : this._fullLoop;
      jS(this._points, g, a, w, d), this._pointsUpdated = !0;
    }
  }
  set points(a) {
    this._points = a, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = nE(this, this.options.segment));
  }
  first() {
    const a = this.segments, d = this.points;
    return a.length && d[a[0].start];
  }
  last() {
    const a = this.segments, d = this.points, g = a.length;
    return g && d[a[g - 1].end];
  }
  interpolate(a, d) {
    const g = this.options, w = a[d], b = this.points, E = Wb(this, {
      property: d,
      start: w,
      end: w
    });
    if (!E.length)
      return;
    const i = [], O = KA(g);
    let j, Y;
    for (j = 0, Y = E.length; j < Y; ++j) {
      const { start: J, end: ae } = E[j], ce = b[J], Te = b[ae];
      if (ce === Te) {
        i.push(ce);
        continue;
      }
      const be = Math.abs((w - ce[d]) / (Te[d] - ce[d])), Ze = O(ce, Te, be, g.stepped);
      Ze[d] = a[d], i.push(Ze);
    }
    return i.length === 1 ? i[0] : i;
  }
  pathSegment(a, d, g) {
    return Yg(this)(a, this, d, g);
  }
  path(a, d, g) {
    const w = this.segments, b = Yg(this);
    let E = this._loop;
    d = d || 0, g = g || this.points.length - d;
    for (const i of w)
      E &= b(a, this, i, {
        start: d,
        end: d + g - 1
      });
    return !!E;
  }
  draw(a, d, g, w) {
    const b = this.options || {};
    (this.points || []).length && b.borderWidth && (a.save(), tP(a, this, g, w), a.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
Yt(zc, "id", "line"), Yt(zc, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), Yt(zc, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), Yt(zc, "descriptors", {
  _scriptable: !0,
  _indexable: (a) => a !== "borderDash" && a !== "fill"
});
function Z1(m, a, d, g) {
  const w = m.options, { [d]: b } = m.getProps([
    d
  ], g);
  return Math.abs(a - b) < w.radius + w.hitRadius;
}
class km extends jl {
  constructor(d) {
    super();
    Yt(this, "parsed");
    Yt(this, "skip");
    Yt(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, d && Object.assign(this, d);
  }
  inRange(d, g, w) {
    const b = this.options, { x: E, y: i } = this.getProps([
      "x",
      "y"
    ], w);
    return Math.pow(d - E, 2) + Math.pow(g - i, 2) < Math.pow(b.hitRadius + b.radius, 2);
  }
  inXRange(d, g) {
    return Z1(this, d, "x", g);
  }
  inYRange(d, g) {
    return Z1(this, d, "y", g);
  }
  getCenterPoint(d) {
    const { x: g, y: w } = this.getProps([
      "x",
      "y"
    ], d);
    return {
      x: g,
      y: w
    };
  }
  size(d) {
    d = d || this.options || {};
    let g = d.radius || 0;
    g = Math.max(g, g && d.hoverRadius || 0);
    const w = g && d.borderWidth || 0;
    return (g + w) * 2;
  }
  draw(d, g) {
    const w = this.options;
    this.skip || w.radius < 0.1 || !Ul(this, g, this.size(w) / 2) || (d.strokeStyle = w.borderColor, d.lineWidth = w.borderWidth, d.fillStyle = w.backgroundColor, qg(d, w, this.x, this.y));
  }
  getRange() {
    const d = this.options || {};
    return d.radius + d.hitRadius;
  }
}
Yt(km, "id", "point"), /**
* @type {any}
*/
Yt(km, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
Yt(km, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function lw(m, a) {
  const { x: d, y: g, base: w, width: b, height: E } = m.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], a);
  let i, O, j, Y, J;
  return m.horizontal ? (J = E / 2, i = Math.min(d, w), O = Math.max(d, w), j = g - J, Y = g + J) : (J = b / 2, i = d - J, O = d + J, j = Math.min(g, w), Y = Math.max(g, w)), {
    left: i,
    top: j,
    right: O,
    bottom: Y
  };
}
function Dc(m, a, d, g) {
  return m ? 0 : gr(a, d, g);
}
function iP(m, a, d) {
  const g = m.options.borderWidth, w = m.borderSkipped, b = Ob(g);
  return {
    t: Dc(w.top, b.top, 0, d),
    r: Dc(w.right, b.right, 0, a),
    b: Dc(w.bottom, b.bottom, 0, d),
    l: Dc(w.left, b.left, 0, a)
  };
}
function nP(m, a, d) {
  const { enableBorderRadius: g } = m.getProps([
    "enableBorderRadius"
  ]), w = m.options.borderRadius, b = kh(w), E = Math.min(a, d), i = m.borderSkipped, O = g || yn(w);
  return {
    topLeft: Dc(!O || i.top || i.left, b.topLeft, 0, E),
    topRight: Dc(!O || i.top || i.right, b.topRight, 0, E),
    bottomLeft: Dc(!O || i.bottom || i.left, b.bottomLeft, 0, E),
    bottomRight: Dc(!O || i.bottom || i.right, b.bottomRight, 0, E)
  };
}
function sP(m) {
  const a = lw(m), d = a.right - a.left, g = a.bottom - a.top, w = iP(m, d / 2, g / 2), b = nP(m, d / 2, g / 2);
  return {
    outer: {
      x: a.left,
      y: a.top,
      w: d,
      h: g,
      radius: b
    },
    inner: {
      x: a.left + w.l,
      y: a.top + w.t,
      w: d - w.l - w.r,
      h: g - w.t - w.b,
      radius: {
        topLeft: Math.max(0, b.topLeft - Math.max(w.t, w.l)),
        topRight: Math.max(0, b.topRight - Math.max(w.t, w.r)),
        bottomLeft: Math.max(0, b.bottomLeft - Math.max(w.b, w.l)),
        bottomRight: Math.max(0, b.bottomRight - Math.max(w.b, w.r))
      }
    }
  };
}
function Vg(m, a, d, g) {
  const w = a === null, b = d === null, i = m && !(w && b) && lw(m, g);
  return i && (w || Nl(a, i.left, i.right)) && (b || Nl(d, i.top, i.bottom));
}
function rP(m) {
  return m.topLeft || m.topRight || m.bottomLeft || m.bottomRight;
}
function oP(m, a) {
  m.rect(a.x, a.y, a.w, a.h);
}
function Ug(m, a, d = {}) {
  const g = m.x !== d.x ? -a : 0, w = m.y !== d.y ? -a : 0, b = (m.x + m.w !== d.x + d.w ? a : 0) - g, E = (m.y + m.h !== d.y + d.h ? a : 0) - w;
  return {
    x: m.x + g,
    y: m.y + w,
    w: m.w + b,
    h: m.h + E,
    radius: m.radius
  };
}
class Rm extends jl {
  constructor(a) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, a && Object.assign(this, a);
  }
  draw(a) {
    const { inflateAmount: d, options: { borderColor: g, backgroundColor: w } } = this, { inner: b, outer: E } = sP(this), i = rP(E.radius) ? Bf : oP;
    a.save(), (E.w !== b.w || E.h !== b.h) && (a.beginPath(), i(a, Ug(E, d, b)), a.clip(), i(a, Ug(b, -d, E)), a.fillStyle = g, a.fill("evenodd")), a.beginPath(), i(a, Ug(b, d)), a.fillStyle = w, a.fill(), a.restore();
  }
  inRange(a, d, g) {
    return Vg(this, a, d, g);
  }
  inXRange(a, d) {
    return Vg(this, a, null, d);
  }
  inYRange(a, d) {
    return Vg(this, null, a, d);
  }
  getCenterPoint(a) {
    const { x: d, y: g, base: w, horizontal: b } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], a);
    return {
      x: b ? (d + w) / 2 : d,
      y: b ? g : (g + w) / 2
    };
  }
  getRange(a) {
    return a === "x" ? this.width / 2 : this.height / 2;
  }
}
Yt(Rm, "id", "bar"), Yt(Rm, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), Yt(Rm, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var aP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: Sf,
  BarElement: Rm,
  LineElement: zc,
  PointElement: km
});
const Kg = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], H1 = /* @__PURE__ */ Kg.map((m) => m.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function cw(m) {
  return Kg[m % Kg.length];
}
function hw(m) {
  return H1[m % H1.length];
}
function lP(m, a) {
  return m.borderColor = cw(a), m.backgroundColor = hw(a), ++a;
}
function cP(m, a) {
  return m.backgroundColor = m.data.map(() => cw(a++)), a;
}
function hP(m, a) {
  return m.backgroundColor = m.data.map(() => hw(a++)), a;
}
function uP(m) {
  let a = 0;
  return (d, g) => {
    const w = m.getDatasetMeta(g).controller;
    w instanceof Dh ? a = cP(d, a) : w instanceof Df ? a = hP(d, a) : w && (a = lP(d, a));
  };
}
function q1(m) {
  let a;
  for (a in m)
    if (m[a].borderColor || m[a].backgroundColor)
      return !0;
  return !1;
}
function dP(m) {
  return m && (m.borderColor || m.backgroundColor);
}
function fP() {
  return ys.borderColor !== "rgba(0,0,0,0.1)" || ys.backgroundColor !== "rgba(0,0,0,0.1)";
}
var pP = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(m, a, d) {
    if (!d.enabled)
      return;
    const { data: { datasets: g }, options: w } = m.config, { elements: b } = w, E = q1(g) || dP(w) || b && q1(b) || fP();
    if (!d.forceOverride && E)
      return;
    const i = uP(m);
    g.forEach(i);
  }
};
function mP(m, a, d, g, w) {
  const b = w.samples || g;
  if (b >= d)
    return m.slice(a, a + d);
  const E = [], i = (d - 2) / (b - 2);
  let O = 0;
  const j = a + d - 1;
  let Y = a, J, ae, ce, Te, be;
  for (E[O++] = m[Y], J = 0; J < b - 2; J++) {
    let Ze = 0, je = 0, ot;
    const vt = Math.floor((J + 1) * i) + 1 + a, ht = Math.min(Math.floor((J + 2) * i) + 1, d) + a, gt = ht - vt;
    for (ot = vt; ot < ht; ot++)
      Ze += m[ot].x, je += m[ot].y;
    Ze /= gt, je /= gt;
    const Vt = Math.floor(J * i) + 1 + a, pt = Math.min(Math.floor((J + 1) * i) + 1, d) + a, { x: Gt, y: ui } = m[Y];
    for (ce = Te = -1, ot = Vt; ot < pt; ot++)
      Te = 0.5 * Math.abs((Gt - Ze) * (m[ot].y - ui) - (Gt - m[ot].x) * (je - ui)), Te > ce && (ce = Te, ae = m[ot], be = ot);
    E[O++] = ae, Y = be;
  }
  return E[O++] = m[j], E;
}
function _P(m, a, d, g) {
  let w = 0, b = 0, E, i, O, j, Y, J, ae, ce, Te, be;
  const Ze = [], je = a + d - 1, ot = m[a].x, ht = m[je].x - ot;
  for (E = a; E < a + d; ++E) {
    i = m[E], O = (i.x - ot) / ht * g, j = i.y;
    const gt = O | 0;
    if (gt === Y)
      j < Te ? (Te = j, J = E) : j > be && (be = j, ae = E), w = (b * w + i.x) / ++b;
    else {
      const Vt = E - 1;
      if (!En(J) && !En(ae)) {
        const pt = Math.min(J, ae), Gt = Math.max(J, ae);
        pt !== ce && pt !== Vt && Ze.push({
          ...m[pt],
          x: w
        }), Gt !== ce && Gt !== Vt && Ze.push({
          ...m[Gt],
          x: w
        });
      }
      E > 0 && Vt !== ce && Ze.push(m[Vt]), Ze.push(i), Y = gt, b = 0, Te = be = j, J = ae = ce = E;
    }
  }
  return Ze;
}
function uw(m) {
  if (m._decimated) {
    const a = m._data;
    delete m._decimated, delete m._data, Object.defineProperty(m, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    });
  }
}
function W1(m) {
  m.data.datasets.forEach((a) => {
    uw(a);
  });
}
function gP(m, a) {
  const d = a.length;
  let g = 0, w;
  const { iScale: b } = m, { min: E, max: i, minDefined: O, maxDefined: j } = b.getUserBounds();
  return O && (g = gr(Vl(a, b.axis, E).lo, 0, d - 1)), j ? w = gr(Vl(a, b.axis, i).hi + 1, g, d) - g : w = d - g, {
    start: g,
    count: w
  };
}
var yP = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (m, a, d) => {
    if (!d.enabled) {
      W1(m);
      return;
    }
    const g = m.width;
    m.data.datasets.forEach((w, b) => {
      const { _data: E, indexAxis: i } = w, O = m.getDatasetMeta(b), j = E || w.data;
      if (Tf([
        i,
        m.options.indexAxis
      ]) === "y" || !O.controller.supportsDecimation)
        return;
      const Y = m.scales[O.xAxisID];
      if (Y.type !== "linear" && Y.type !== "time" || m.options.parsing)
        return;
      let { start: J, count: ae } = gP(O, j);
      const ce = d.threshold || 4 * g;
      if (ae <= ce) {
        uw(w);
        return;
      }
      En(E) && (w._data = j, delete w.data, Object.defineProperty(w, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(be) {
          this._data = be;
        }
      }));
      let Te;
      switch (d.algorithm) {
        case "lttb":
          Te = mP(j, J, ae, g, d);
          break;
        case "min-max":
          Te = _P(j, J, ae, g);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${d.algorithm}'`);
      }
      w._decimated = Te;
    });
  },
  destroy(m) {
    W1(m);
  }
};
function xP(m, a, d) {
  const g = m.segments, w = m.points, b = a.points, E = [];
  for (const i of g) {
    let { start: O, end: j } = i;
    j = wy(O, j, w);
    const Y = Jg(d, w[O], w[j], i.loop);
    if (!a.segments) {
      E.push({
        source: i,
        target: Y,
        start: w[O],
        end: w[j]
      });
      continue;
    }
    const J = Wb(a, Y);
    for (const ae of J) {
      const ce = Jg(d, b[ae.start], b[ae.end], ae.loop), Te = qb(i, w, ce);
      for (const be of Te)
        E.push({
          source: be,
          target: ae,
          start: {
            [d]: $1(Y, ce, "start", Math.max)
          },
          end: {
            [d]: $1(Y, ce, "end", Math.min)
          }
        });
    }
  }
  return E;
}
function Jg(m, a, d, g) {
  if (g)
    return;
  let w = a[m], b = d[m];
  return m === "angle" && (w = No(w), b = No(b)), {
    property: m,
    start: w,
    end: b
  };
}
function vP(m, a) {
  const { x: d = null, y: g = null } = m || {}, w = a.points, b = [];
  return a.segments.forEach(({ start: E, end: i }) => {
    i = wy(E, i, w);
    const O = w[E], j = w[i];
    g !== null ? (b.push({
      x: O.x,
      y: g
    }), b.push({
      x: j.x,
      y: g
    })) : d !== null && (b.push({
      x: d,
      y: O.y
    }), b.push({
      x: d,
      y: j.y
    }));
  }), b;
}
function wy(m, a, d) {
  for (; a > m; a--) {
    const g = d[a];
    if (!isNaN(g.x) && !isNaN(g.y))
      break;
  }
  return a;
}
function $1(m, a, d, g) {
  return m && a ? g(m[d], a[d]) : m ? m[d] : a ? a[d] : 0;
}
function dw(m, a) {
  let d = [], g = !1;
  return hs(m) ? (g = !0, d = m) : d = vP(m, a), d.length ? new zc({
    points: d,
    options: {
      tension: 0
    },
    _loop: g,
    _fullLoop: g
  }) : null;
}
function X1(m) {
  return m && m.fill !== !1;
}
function bP(m, a, d) {
  let w = m[a].fill;
  const b = [
    a
  ];
  let E;
  if (!d)
    return w;
  for (; w !== !1 && b.indexOf(w) === -1; ) {
    if (!Ps(w))
      return w;
    if (E = m[w], !E)
      return !1;
    if (E.visible)
      return w;
    b.push(w), w = E.fill;
  }
  return !1;
}
function wP(m, a, d) {
  const g = EP(m);
  if (yn(g))
    return isNaN(g.value) ? !1 : g;
  let w = parseFloat(g);
  return Ps(w) && Math.floor(w) === w ? TP(g[0], a, w, d) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(g) >= 0 && g;
}
function TP(m, a, d, g) {
  return (m === "-" || m === "+") && (d = a + d), d === a || d < 0 || d >= g ? !1 : d;
}
function MP(m, a) {
  let d = null;
  return m === "start" ? d = a.bottom : m === "end" ? d = a.top : yn(m) ? d = a.getPixelForValue(m.value) : a.getBasePixel && (d = a.getBasePixel()), d;
}
function SP(m, a, d) {
  let g;
  return m === "start" ? g = d : m === "end" ? g = a.options.reverse ? a.min : a.max : yn(m) ? g = m.value : g = a.getBaseValue(), g;
}
function EP(m) {
  const a = m.options, d = a.fill;
  let g = en(d && d.target, d);
  return g === void 0 && (g = !!a.backgroundColor), g === !1 || g === null ? !1 : g === !0 ? "origin" : g;
}
function AP(m) {
  const { scale: a, index: d, line: g } = m, w = [], b = g.segments, E = g.points, i = PP(a, d);
  i.push(dw({
    x: null,
    y: a.bottom
  }, g));
  for (let O = 0; O < b.length; O++) {
    const j = b[O];
    for (let Y = j.start; Y <= j.end; Y++)
      CP(w, E[Y], i);
  }
  return new zc({
    points: w,
    options: {}
  });
}
function PP(m, a) {
  const d = [], g = m.getMatchingVisibleMetas("line");
  for (let w = 0; w < g.length; w++) {
    const b = g[w];
    if (b.index === a)
      break;
    b.hidden || d.unshift(b.dataset);
  }
  return d;
}
function CP(m, a, d) {
  const g = [];
  for (let w = 0; w < d.length; w++) {
    const b = d[w], { first: E, last: i, point: O } = IP(b, a, "x");
    if (!(!O || E && i)) {
      if (E)
        g.unshift(O);
      else if (m.push(O), !i)
        break;
    }
  }
  m.push(...g);
}
function IP(m, a, d) {
  const g = m.interpolate(a, d);
  if (!g)
    return {};
  const w = g[d], b = m.segments, E = m.points;
  let i = !1, O = !1;
  for (let j = 0; j < b.length; j++) {
    const Y = b[j], J = E[Y.start][d], ae = E[Y.end][d];
    if (Nl(w, J, ae)) {
      i = w === J, O = w === ae;
      break;
    }
  }
  return {
    first: i,
    last: O,
    point: g
  };
}
class fw {
  constructor(a) {
    this.x = a.x, this.y = a.y, this.radius = a.radius;
  }
  pathSegment(a, d, g) {
    const { x: w, y: b, radius: E } = this;
    return d = d || {
      start: 0,
      end: us
    }, a.arc(w, b, E, d.end, d.start, !0), !g.bounds;
  }
  interpolate(a) {
    const { x: d, y: g, radius: w } = this, b = a.angle;
    return {
      x: d + Math.cos(b) * w,
      y: g + Math.sin(b) * w,
      angle: b
    };
  }
}
function LP(m) {
  const { chart: a, fill: d, line: g } = m;
  if (Ps(d))
    return zP(a, d);
  if (d === "stack")
    return AP(m);
  if (d === "shape")
    return !0;
  const w = DP(m);
  return w instanceof fw ? w : dw(w, g);
}
function zP(m, a) {
  const d = m.getDatasetMeta(a);
  return d && m.isDatasetVisible(a) ? d.dataset : null;
}
function DP(m) {
  return (m.scale || {}).getPointPositionForValue ? RP(m) : kP(m);
}
function kP(m) {
  const { scale: a = {}, fill: d } = m, g = MP(d, a);
  if (Ps(g)) {
    const w = a.isHorizontal();
    return {
      x: w ? g : null,
      y: w ? null : g
    };
  }
  return null;
}
function RP(m) {
  const { scale: a, fill: d } = m, g = a.options, w = a.getLabels().length, b = g.reverse ? a.max : a.min, E = SP(d, a, b), i = [];
  if (g.grid.circular) {
    const O = a.getPointPositionForValue(0, b);
    return new fw({
      x: O.x,
      y: O.y,
      radius: a.getDistanceFromCenterForValue(E)
    });
  }
  for (let O = 0; O < w; ++O)
    i.push(a.getPointPositionForValue(O, E));
  return i;
}
function jg(m, a, d) {
  const g = LP(a), { line: w, scale: b, axis: E } = a, i = w.options, O = i.fill, j = i.backgroundColor, { above: Y = j, below: J = j } = O || {};
  g && w.points.length && (Wm(m, d), OP(m, {
    line: w,
    target: g,
    above: Y,
    below: J,
    area: d,
    scale: b,
    axis: E
  }), $m(m));
}
function OP(m, a) {
  const { line: d, target: g, above: w, below: b, area: E, scale: i } = a, O = d._loop ? "angle" : a.axis;
  m.save(), O === "x" && b !== w && (Y1(m, g, E.top), K1(m, {
    line: d,
    target: g,
    color: w,
    scale: i,
    property: O
  }), m.restore(), m.save(), Y1(m, g, E.bottom)), K1(m, {
    line: d,
    target: g,
    color: b,
    scale: i,
    property: O
  }), m.restore();
}
function Y1(m, a, d) {
  const { segments: g, points: w } = a;
  let b = !0, E = !1;
  m.beginPath();
  for (const i of g) {
    const { start: O, end: j } = i, Y = w[O], J = w[wy(O, j, w)];
    b ? (m.moveTo(Y.x, Y.y), b = !1) : (m.lineTo(Y.x, d), m.lineTo(Y.x, Y.y)), E = !!a.pathSegment(m, i, {
      move: E
    }), E ? m.closePath() : m.lineTo(J.x, d);
  }
  m.lineTo(a.first().x, d), m.closePath(), m.clip();
}
function K1(m, a) {
  const { line: d, target: g, property: w, color: b, scale: E } = a, i = xP(d, g, w);
  for (const { source: O, target: j, start: Y, end: J } of i) {
    const { style: { backgroundColor: ae = b } = {} } = O, ce = g !== !0;
    m.save(), m.fillStyle = ae, FP(m, E, ce && Jg(w, Y, J)), m.beginPath();
    const Te = !!d.pathSegment(m, O);
    let be;
    if (ce) {
      Te ? m.closePath() : J1(m, g, J, w);
      const Ze = !!g.pathSegment(m, j, {
        move: Te,
        reverse: !0
      });
      be = Te && Ze, be || J1(m, g, Y, w);
    }
    m.closePath(), m.fill(be ? "evenodd" : "nonzero"), m.restore();
  }
}
function FP(m, a, d) {
  const { top: g, bottom: w } = a.chart.chartArea, { property: b, start: E, end: i } = d || {};
  b === "x" && (m.beginPath(), m.rect(E, g, i - E, w - g), m.clip());
}
function J1(m, a, d, g) {
  const w = a.interpolate(d, g);
  w && m.lineTo(w.x, w.y);
}
var BP = {
  id: "filler",
  afterDatasetsUpdate(m, a, d) {
    const g = (m.data.datasets || []).length, w = [];
    let b, E, i, O;
    for (E = 0; E < g; ++E)
      b = m.getDatasetMeta(E), i = b.dataset, O = null, i && i.options && i instanceof zc && (O = {
        visible: m.isDatasetVisible(E),
        index: E,
        fill: wP(i, E, g),
        chart: m,
        axis: b.controller.options.indexAxis,
        scale: b.vScale,
        line: i
      }), b.$filler = O, w.push(O);
    for (E = 0; E < g; ++E)
      O = w[E], !(!O || O.fill === !1) && (O.fill = bP(w, E, d.propagate));
  },
  beforeDraw(m, a, d) {
    const g = d.drawTime === "beforeDraw", w = m.getSortedVisibleDatasetMetas(), b = m.chartArea;
    for (let E = w.length - 1; E >= 0; --E) {
      const i = w[E].$filler;
      i && (i.line.updateControlPoints(b, i.axis), g && i.fill && jg(m.ctx, i, b));
    }
  },
  beforeDatasetsDraw(m, a, d) {
    if (d.drawTime !== "beforeDatasetsDraw")
      return;
    const g = m.getSortedVisibleDatasetMetas();
    for (let w = g.length - 1; w >= 0; --w) {
      const b = g[w].$filler;
      X1(b) && jg(m.ctx, b, m.chartArea);
    }
  },
  beforeDatasetDraw(m, a, d) {
    const g = a.meta.$filler;
    !X1(g) || d.drawTime !== "beforeDatasetDraw" || jg(m.ctx, g, m.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Q1 = (m, a) => {
  let { boxHeight: d = a, boxWidth: g = a } = m;
  return m.usePointStyle && (d = Math.min(d, a), g = m.pointStyleWidth || Math.min(g, a)), {
    boxWidth: g,
    boxHeight: d,
    itemHeight: Math.max(a, d)
  };
}, NP = (m, a) => m !== null && a !== null && m.datasetIndex === a.datasetIndex && m.index === a.index;
class eb extends jl {
  constructor(a) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(a, d, g) {
    this.maxWidth = a, this.maxHeight = d, this._margins = g, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const a = this.options.labels || {};
    let d = is(a.generateLabels, [
      this.chart
    ], this) || [];
    a.filter && (d = d.filter((g) => a.filter(g, this.chart.data))), a.sort && (d = d.sort((g, w) => a.sort(g, w, this.chart.data))), this.options.reverse && d.reverse(), this.legendItems = d;
  }
  fit() {
    const { options: a, ctx: d } = this;
    if (!a.display) {
      this.width = this.height = 0;
      return;
    }
    const g = a.labels, w = ir(g.font), b = w.size, E = this._computeTitleHeight(), { boxWidth: i, itemHeight: O } = Q1(g, b);
    let j, Y;
    d.font = w.string, this.isHorizontal() ? (j = this.maxWidth, Y = this._fitRows(E, b, i, O) + 10) : (Y = this.maxHeight, j = this._fitCols(E, w, i, O) + 10), this.width = Math.min(j, a.maxWidth || this.maxWidth), this.height = Math.min(Y, a.maxHeight || this.maxHeight);
  }
  _fitRows(a, d, g, w) {
    const { ctx: b, maxWidth: E, options: { labels: { padding: i } } } = this, O = this.legendHitBoxes = [], j = this.lineWidths = [
      0
    ], Y = w + i;
    let J = a;
    b.textAlign = "left", b.textBaseline = "middle";
    let ae = -1, ce = -Y;
    return this.legendItems.forEach((Te, be) => {
      const Ze = g + d / 2 + b.measureText(Te.text).width;
      (be === 0 || j[j.length - 1] + Ze + 2 * i > E) && (J += Y, j[j.length - (be > 0 ? 0 : 1)] = 0, ce += Y, ae++), O[be] = {
        left: 0,
        top: ce,
        row: ae,
        width: Ze,
        height: w
      }, j[j.length - 1] += Ze + i;
    }), J;
  }
  _fitCols(a, d, g, w) {
    const { ctx: b, maxHeight: E, options: { labels: { padding: i } } } = this, O = this.legendHitBoxes = [], j = this.columnSizes = [], Y = E - a;
    let J = i, ae = 0, ce = 0, Te = 0, be = 0;
    return this.legendItems.forEach((Ze, je) => {
      const { itemWidth: ot, itemHeight: vt } = VP(g, d, b, Ze, w);
      je > 0 && ce + vt + 2 * i > Y && (J += ae + i, j.push({
        width: ae,
        height: ce
      }), Te += ae + i, be++, ae = ce = 0), O[je] = {
        left: Te,
        top: ce,
        col: be,
        width: ot,
        height: vt
      }, ae = Math.max(ae, ot), ce += vt + i;
    }), J += ae, j.push({
      width: ae,
      height: ce
    }), J;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const a = this._computeTitleHeight(), { legendHitBoxes: d, options: { align: g, labels: { padding: w }, rtl: b } } = this, E = $u(b, this.left, this.width);
    if (this.isHorizontal()) {
      let i = 0, O = Ur(g, this.left + w, this.right - this.lineWidths[i]);
      for (const j of d)
        i !== j.row && (i = j.row, O = Ur(g, this.left + w, this.right - this.lineWidths[i])), j.top += this.top + a + w, j.left = E.leftForLtr(E.x(O), j.width), O += j.width + w;
    } else {
      let i = 0, O = Ur(g, this.top + a + w, this.bottom - this.columnSizes[i].height);
      for (const j of d)
        j.col !== i && (i = j.col, O = Ur(g, this.top + a + w, this.bottom - this.columnSizes[i].height)), j.top = O, j.left += this.left + w, j.left = E.leftForLtr(E.x(j.left), j.width), O += j.height + w;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const a = this.ctx;
      Wm(a, this), this._draw(), $m(a);
    }
  }
  _draw() {
    const { options: a, columnSizes: d, lineWidths: g, ctx: w } = this, { align: b, labels: E } = a, i = ys.color, O = $u(a.rtl, this.left, this.width), j = ir(E.font), { padding: Y } = E, J = j.size, ae = J / 2;
    let ce;
    this.drawTitle(), w.textAlign = O.textAlign("left"), w.textBaseline = "middle", w.lineWidth = 0.5, w.font = j.string;
    const { boxWidth: Te, boxHeight: be, itemHeight: Ze } = Q1(E, J), je = function(Vt, pt, Gt) {
      if (isNaN(Te) || Te <= 0 || isNaN(be) || be < 0)
        return;
      w.save();
      const ui = en(Gt.lineWidth, 1);
      if (w.fillStyle = en(Gt.fillStyle, i), w.lineCap = en(Gt.lineCap, "butt"), w.lineDashOffset = en(Gt.lineDashOffset, 0), w.lineJoin = en(Gt.lineJoin, "miter"), w.lineWidth = ui, w.strokeStyle = en(Gt.strokeStyle, i), w.setLineDash(en(Gt.lineDash, [])), E.usePointStyle) {
        const kt = {
          radius: be * Math.SQRT2 / 2,
          pointStyle: Gt.pointStyle,
          rotation: Gt.rotation,
          borderWidth: ui
        }, At = O.xPlus(Vt, Te / 2), Mi = pt + ae;
        Rb(w, kt, At, Mi, E.pointStyleWidth && Te);
      } else {
        const kt = pt + Math.max((J - be) / 2, 0), At = O.leftForLtr(Vt, Te), Mi = kh(Gt.borderRadius);
        w.beginPath(), Object.values(Mi).some((An) => An !== 0) ? Bf(w, {
          x: At,
          y: kt,
          w: Te,
          h: be,
          radius: Mi
        }) : w.rect(At, kt, Te, be), w.fill(), ui !== 0 && w.stroke();
      }
      w.restore();
    }, ot = function(Vt, pt, Gt) {
      Fh(w, Gt.text, Vt, pt + Ze / 2, j, {
        strikethrough: Gt.hidden,
        textAlign: O.textAlign(Gt.textAlign)
      });
    }, vt = this.isHorizontal(), ht = this._computeTitleHeight();
    vt ? ce = {
      x: Ur(b, this.left + Y, this.right - g[0]),
      y: this.top + Y + ht,
      line: 0
    } : ce = {
      x: this.left + Y,
      y: Ur(b, this.top + ht + Y, this.bottom - d[0].height),
      line: 0
    }, Gb(this.ctx, a.textDirection);
    const gt = Ze + Y;
    this.legendItems.forEach((Vt, pt) => {
      w.strokeStyle = Vt.fontColor, w.fillStyle = Vt.fontColor;
      const Gt = w.measureText(Vt.text).width, ui = O.textAlign(Vt.textAlign || (Vt.textAlign = E.textAlign)), kt = Te + ae + Gt;
      let At = ce.x, Mi = ce.y;
      O.setWidth(this.width), vt ? pt > 0 && At + kt + Y > this.right && (Mi = ce.y += gt, ce.line++, At = ce.x = Ur(b, this.left + Y, this.right - g[ce.line])) : pt > 0 && Mi + gt > this.bottom && (At = ce.x = At + d[ce.line].width + Y, ce.line++, Mi = ce.y = Ur(b, this.top + ht + Y, this.bottom - d[ce.line].height));
      const An = O.x(At);
      if (je(An, Mi, Vt), At = oS(ui, At + Te + ae, vt ? At + kt : this.right, a.rtl), ot(O.x(At), Mi, Vt), vt)
        ce.x += kt + Y;
      else if (typeof Vt.text != "string") {
        const hn = j.lineHeight;
        ce.y += pw(Vt, hn) + Y;
      } else
        ce.y += gt;
    }), Zb(this.ctx, a.textDirection);
  }
  drawTitle() {
    const a = this.options, d = a.title, g = ir(d.font), w = Gr(d.padding);
    if (!d.display)
      return;
    const b = $u(a.rtl, this.left, this.width), E = this.ctx, i = d.position, O = g.size / 2, j = w.top + O;
    let Y, J = this.left, ae = this.width;
    if (this.isHorizontal())
      ae = Math.max(...this.lineWidths), Y = this.top + j, J = Ur(a.align, J, this.right - ae);
    else {
      const Te = this.columnSizes.reduce((be, Ze) => Math.max(be, Ze.height), 0);
      Y = j + Ur(a.align, this.top, this.bottom - Te - a.labels.padding - this._computeTitleHeight());
    }
    const ce = Ur(i, J, J + ae);
    E.textAlign = b.textAlign(fy(i)), E.textBaseline = "middle", E.strokeStyle = d.color, E.fillStyle = d.color, E.font = g.string, Fh(E, d.text, ce, Y, g);
  }
  _computeTitleHeight() {
    const a = this.options.title, d = ir(a.font), g = Gr(a.padding);
    return a.display ? d.lineHeight + g.height : 0;
  }
  _getLegendItemAt(a, d) {
    let g, w, b;
    if (Nl(a, this.left, this.right) && Nl(d, this.top, this.bottom)) {
      for (b = this.legendHitBoxes, g = 0; g < b.length; ++g)
        if (w = b[g], Nl(a, w.left, w.left + w.width) && Nl(d, w.top, w.top + w.height))
          return this.legendItems[g];
    }
    return null;
  }
  handleEvent(a) {
    const d = this.options;
    if (!GP(a.type, d))
      return;
    const g = this._getLegendItemAt(a.x, a.y);
    if (a.type === "mousemove" || a.type === "mouseout") {
      const w = this._hoveredItem, b = NP(w, g);
      w && !b && is(d.onLeave, [
        a,
        w,
        this
      ], this), this._hoveredItem = g, g && !b && is(d.onHover, [
        a,
        g,
        this
      ], this);
    } else
      g && is(d.onClick, [
        a,
        g,
        this
      ], this);
  }
}
function VP(m, a, d, g, w) {
  const b = UP(g, m, a, d), E = jP(w, g, a.lineHeight);
  return {
    itemWidth: b,
    itemHeight: E
  };
}
function UP(m, a, d, g) {
  let w = m.text;
  return w && typeof w != "string" && (w = w.reduce((b, E) => b.length > E.length ? b : E)), a + d.size / 2 + g.measureText(w).width;
}
function jP(m, a, d) {
  let g = m;
  return typeof a.text != "string" && (g = pw(a, d)), g;
}
function pw(m, a) {
  const d = m.text ? m.text.length : 0;
  return a * d;
}
function GP(m, a) {
  return !!((m === "mousemove" || m === "mouseout") && (a.onHover || a.onLeave) || a.onClick && (m === "click" || m === "mouseup"));
}
var ZP = {
  id: "legend",
  _element: eb,
  start(m, a, d) {
    const g = m.legend = new eb({
      ctx: m.ctx,
      options: d,
      chart: m
    });
    jr.configure(m, g, d), jr.addBox(m, g);
  },
  stop(m) {
    jr.removeBox(m, m.legend), delete m.legend;
  },
  beforeUpdate(m, a, d) {
    const g = m.legend;
    jr.configure(m, g, d), g.options = d;
  },
  afterUpdate(m) {
    const a = m.legend;
    a.buildLabels(), a.adjustHitBoxes();
  },
  afterEvent(m, a) {
    a.replay || m.legend.handleEvent(a.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(m, a, d) {
      const g = a.datasetIndex, w = d.chart;
      w.isDatasetVisible(g) ? (w.hide(g), a.hidden = !0) : (w.show(g), a.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (m) => m.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(m) {
        const a = m.data.datasets, { labels: { usePointStyle: d, pointStyle: g, textAlign: w, color: b, useBorderRadius: E, borderRadius: i } } = m.legend.options;
        return m._getSortedDatasetMetas().map((O) => {
          const j = O.controller.getStyle(d ? 0 : void 0), Y = Gr(j.borderWidth);
          return {
            text: a[O.index].label,
            fillStyle: j.backgroundColor,
            fontColor: b,
            hidden: !O.visible,
            lineCap: j.borderCapStyle,
            lineDash: j.borderDash,
            lineDashOffset: j.borderDashOffset,
            lineJoin: j.borderJoinStyle,
            lineWidth: (Y.width + Y.height) / 4,
            strokeStyle: j.borderColor,
            pointStyle: g || j.pointStyle,
            rotation: j.rotation,
            textAlign: w || j.textAlign,
            borderRadius: E && (i || j.borderRadius),
            datasetIndex: O.index
          };
        }, this);
      }
    },
    title: {
      color: (m) => m.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (m) => !m.startsWith("on"),
    labels: {
      _scriptable: (m) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(m)
    }
  }
};
class Ty extends jl {
  constructor(a) {
    super(), this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(a, d) {
    const g = this.options;
    if (this.left = 0, this.top = 0, !g.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = a, this.height = this.bottom = d;
    const w = hs(g.text) ? g.text.length : 1;
    this._padding = Gr(g.padding);
    const b = w * ir(g.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = b : this.width = b;
  }
  isHorizontal() {
    const a = this.options.position;
    return a === "top" || a === "bottom";
  }
  _drawArgs(a) {
    const { top: d, left: g, bottom: w, right: b, options: E } = this, i = E.align;
    let O = 0, j, Y, J;
    return this.isHorizontal() ? (Y = Ur(i, g, b), J = d + a, j = b - g) : (E.position === "left" ? (Y = g + a, J = Ur(i, w, d), O = ds * -0.5) : (Y = b - a, J = Ur(i, d, w), O = ds * 0.5), j = w - d), {
      titleX: Y,
      titleY: J,
      maxWidth: j,
      rotation: O
    };
  }
  draw() {
    const a = this.ctx, d = this.options;
    if (!d.display)
      return;
    const g = ir(d.font), b = g.lineHeight / 2 + this._padding.top, { titleX: E, titleY: i, maxWidth: O, rotation: j } = this._drawArgs(b);
    Fh(a, d.text, 0, 0, g, {
      color: d.color,
      maxWidth: O,
      rotation: j,
      textAlign: fy(d.align),
      textBaseline: "middle",
      translation: [
        E,
        i
      ]
    });
  }
}
function HP(m, a) {
  const d = new Ty({
    ctx: m.ctx,
    options: a,
    chart: m
  });
  jr.configure(m, d, a), jr.addBox(m, d), m.titleBlock = d;
}
var qP = {
  id: "title",
  _element: Ty,
  start(m, a, d) {
    HP(m, d);
  },
  stop(m) {
    const a = m.titleBlock;
    jr.removeBox(m, a), delete m.titleBlock;
  },
  beforeUpdate(m, a, d) {
    const g = m.titleBlock;
    jr.configure(m, g, d), g.options = d;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const wm = /* @__PURE__ */ new WeakMap();
var WP = {
  id: "subtitle",
  start(m, a, d) {
    const g = new Ty({
      ctx: m.ctx,
      options: d,
      chart: m
    });
    jr.configure(m, g, d), jr.addBox(m, g), wm.set(m, g);
  },
  stop(m) {
    jr.removeBox(m, wm.get(m)), wm.delete(m);
  },
  beforeUpdate(m, a, d) {
    const g = wm.get(m);
    jr.configure(m, g, d), g.options = d;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Ef = {
  average(m) {
    if (!m.length)
      return !1;
    let a, d, g = /* @__PURE__ */ new Set(), w = 0, b = 0;
    for (a = 0, d = m.length; a < d; ++a) {
      const i = m[a].element;
      if (i && i.hasValue()) {
        const O = i.tooltipPosition();
        g.add(O.x), w += O.y, ++b;
      }
    }
    return b === 0 || g.size === 0 ? !1 : {
      x: [
        ...g
      ].reduce((i, O) => i + O) / g.size,
      y: w / b
    };
  },
  nearest(m, a) {
    if (!m.length)
      return !1;
    let d = a.x, g = a.y, w = Number.POSITIVE_INFINITY, b, E, i;
    for (b = 0, E = m.length; b < E; ++b) {
      const O = m[b].element;
      if (O && O.hasValue()) {
        const j = O.getCenterPoint(), Y = Zg(a, j);
        Y < w && (w = Y, i = O);
      }
    }
    if (i) {
      const O = i.tooltipPosition();
      d = O.x, g = O.y;
    }
    return {
      x: d,
      y: g
    };
  }
};
function ol(m, a) {
  return a && (hs(a) ? Array.prototype.push.apply(m, a) : m.push(a)), m;
}
function Ol(m) {
  return (typeof m == "string" || m instanceof String) && m.indexOf(`
`) > -1 ? m.split(`
`) : m;
}
function $P(m, a) {
  const { element: d, datasetIndex: g, index: w } = a, b = m.getDatasetMeta(g).controller, { label: E, value: i } = b.getLabelAndValue(w);
  return {
    chart: m,
    label: E,
    parsed: b.getParsed(w),
    raw: m.data.datasets[g].data[w],
    formattedValue: i,
    dataset: b.getDataset(),
    dataIndex: w,
    datasetIndex: g,
    element: d
  };
}
function tb(m, a) {
  const d = m.chart.ctx, { body: g, footer: w, title: b } = m, { boxWidth: E, boxHeight: i } = a, O = ir(a.bodyFont), j = ir(a.titleFont), Y = ir(a.footerFont), J = b.length, ae = w.length, ce = g.length, Te = Gr(a.padding);
  let be = Te.height, Ze = 0, je = g.reduce((ht, gt) => ht + gt.before.length + gt.lines.length + gt.after.length, 0);
  if (je += m.beforeBody.length + m.afterBody.length, J && (be += J * j.lineHeight + (J - 1) * a.titleSpacing + a.titleMarginBottom), je) {
    const ht = a.displayColors ? Math.max(i, O.lineHeight) : O.lineHeight;
    be += ce * ht + (je - ce) * O.lineHeight + (je - 1) * a.bodySpacing;
  }
  ae && (be += a.footerMarginTop + ae * Y.lineHeight + (ae - 1) * a.footerSpacing);
  let ot = 0;
  const vt = function(ht) {
    Ze = Math.max(Ze, d.measureText(ht).width + ot);
  };
  return d.save(), d.font = j.string, Zn(m.title, vt), d.font = O.string, Zn(m.beforeBody.concat(m.afterBody), vt), ot = a.displayColors ? E + 2 + a.boxPadding : 0, Zn(g, (ht) => {
    Zn(ht.before, vt), Zn(ht.lines, vt), Zn(ht.after, vt);
  }), ot = 0, d.font = Y.string, Zn(m.footer, vt), d.restore(), Ze += Te.width, {
    width: Ze,
    height: be
  };
}
function XP(m, a) {
  const { y: d, height: g } = a;
  return d < g / 2 ? "top" : d > m.height - g / 2 ? "bottom" : "center";
}
function YP(m, a, d, g) {
  const { x: w, width: b } = g, E = d.caretSize + d.caretPadding;
  if (m === "left" && w + b + E > a.width || m === "right" && w - b - E < 0)
    return !0;
}
function KP(m, a, d, g) {
  const { x: w, width: b } = d, { width: E, chartArea: { left: i, right: O } } = m;
  let j = "center";
  return g === "center" ? j = w <= (i + O) / 2 ? "left" : "right" : w <= b / 2 ? j = "left" : w >= E - b / 2 && (j = "right"), YP(j, m, a, d) && (j = "center"), j;
}
function ib(m, a, d) {
  const g = d.yAlign || a.yAlign || XP(m, d);
  return {
    xAlign: d.xAlign || a.xAlign || KP(m, a, d, g),
    yAlign: g
  };
}
function JP(m, a) {
  let { x: d, width: g } = m;
  return a === "right" ? d -= g : a === "center" && (d -= g / 2), d;
}
function QP(m, a, d) {
  let { y: g, height: w } = m;
  return a === "top" ? g += d : a === "bottom" ? g -= w + d : g -= w / 2, g;
}
function nb(m, a, d, g) {
  const { caretSize: w, caretPadding: b, cornerRadius: E } = m, { xAlign: i, yAlign: O } = d, j = w + b, { topLeft: Y, topRight: J, bottomLeft: ae, bottomRight: ce } = kh(E);
  let Te = JP(a, i);
  const be = QP(a, O, j);
  return O === "center" ? i === "left" ? Te += j : i === "right" && (Te -= j) : i === "left" ? Te -= Math.max(Y, ae) + w : i === "right" && (Te += Math.max(J, ce) + w), {
    x: gr(Te, 0, g.width - a.width),
    y: gr(be, 0, g.height - a.height)
  };
}
function Tm(m, a, d) {
  const g = Gr(d.padding);
  return a === "center" ? m.x + m.width / 2 : a === "right" ? m.x + m.width - g.right : m.x + g.left;
}
function sb(m) {
  return ol([], Ol(m));
}
function eC(m, a, d) {
  return Fc(m, {
    tooltip: a,
    tooltipItems: d,
    type: "tooltip"
  });
}
function rb(m, a) {
  const d = a && a.dataset && a.dataset.tooltip && a.dataset.tooltip.callbacks;
  return d ? m.override(d) : m;
}
const mw = {
  beforeTitle: kl,
  title(m) {
    if (m.length > 0) {
      const a = m[0], d = a.chart.data.labels, g = d ? d.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return a.dataset.label || "";
      if (a.label)
        return a.label;
      if (g > 0 && a.dataIndex < g)
        return d[a.dataIndex];
    }
    return "";
  },
  afterTitle: kl,
  beforeBody: kl,
  beforeLabel: kl,
  label(m) {
    if (this && this.options && this.options.mode === "dataset")
      return m.label + ": " + m.formattedValue || m.formattedValue;
    let a = m.dataset.label || "";
    a && (a += ": ");
    const d = m.formattedValue;
    return En(d) || (a += d), a;
  },
  labelColor(m) {
    const d = m.chart.getDatasetMeta(m.datasetIndex).controller.getStyle(m.dataIndex);
    return {
      borderColor: d.borderColor,
      backgroundColor: d.backgroundColor,
      borderWidth: d.borderWidth,
      borderDash: d.borderDash,
      borderDashOffset: d.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(m) {
    const d = m.chart.getDatasetMeta(m.datasetIndex).controller.getStyle(m.dataIndex);
    return {
      pointStyle: d.pointStyle,
      rotation: d.rotation
    };
  },
  afterLabel: kl,
  afterBody: kl,
  beforeFooter: kl,
  footer: kl,
  afterFooter: kl
};
function mo(m, a, d, g) {
  const w = m[a].call(d, g);
  return typeof w > "u" ? mw[a].call(d, g) : w;
}
class Qg extends jl {
  constructor(a) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = a.chart, this.options = a.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(a) {
    this.options = a, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const a = this._cachedAnimations;
    if (a)
      return a;
    const d = this.chart, g = this.options.setContext(this.getContext()), w = g.enabled && d.options.animation && g.animations, b = new $b(this.chart, w);
    return w._cacheable && (this._cachedAnimations = Object.freeze(b)), b;
  }
  getContext() {
    return this.$context || (this.$context = eC(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(a, d) {
    const { callbacks: g } = d, w = mo(g, "beforeTitle", this, a), b = mo(g, "title", this, a), E = mo(g, "afterTitle", this, a);
    let i = [];
    return i = ol(i, Ol(w)), i = ol(i, Ol(b)), i = ol(i, Ol(E)), i;
  }
  getBeforeBody(a, d) {
    return sb(mo(d.callbacks, "beforeBody", this, a));
  }
  getBody(a, d) {
    const { callbacks: g } = d, w = [];
    return Zn(a, (b) => {
      const E = {
        before: [],
        lines: [],
        after: []
      }, i = rb(g, b);
      ol(E.before, Ol(mo(i, "beforeLabel", this, b))), ol(E.lines, mo(i, "label", this, b)), ol(E.after, Ol(mo(i, "afterLabel", this, b))), w.push(E);
    }), w;
  }
  getAfterBody(a, d) {
    return sb(mo(d.callbacks, "afterBody", this, a));
  }
  getFooter(a, d) {
    const { callbacks: g } = d, w = mo(g, "beforeFooter", this, a), b = mo(g, "footer", this, a), E = mo(g, "afterFooter", this, a);
    let i = [];
    return i = ol(i, Ol(w)), i = ol(i, Ol(b)), i = ol(i, Ol(E)), i;
  }
  _createItems(a) {
    const d = this._active, g = this.chart.data, w = [], b = [], E = [];
    let i = [], O, j;
    for (O = 0, j = d.length; O < j; ++O)
      i.push($P(this.chart, d[O]));
    return a.filter && (i = i.filter((Y, J, ae) => a.filter(Y, J, ae, g))), a.itemSort && (i = i.sort((Y, J) => a.itemSort(Y, J, g))), Zn(i, (Y) => {
      const J = rb(a.callbacks, Y);
      w.push(mo(J, "labelColor", this, Y)), b.push(mo(J, "labelPointStyle", this, Y)), E.push(mo(J, "labelTextColor", this, Y));
    }), this.labelColors = w, this.labelPointStyles = b, this.labelTextColors = E, this.dataPoints = i, i;
  }
  update(a, d) {
    const g = this.options.setContext(this.getContext()), w = this._active;
    let b, E = [];
    if (!w.length)
      this.opacity !== 0 && (b = {
        opacity: 0
      });
    else {
      const i = Ef[g.position].call(this, w, this._eventPosition);
      E = this._createItems(g), this.title = this.getTitle(E, g), this.beforeBody = this.getBeforeBody(E, g), this.body = this.getBody(E, g), this.afterBody = this.getAfterBody(E, g), this.footer = this.getFooter(E, g);
      const O = this._size = tb(this, g), j = Object.assign({}, i, O), Y = ib(this.chart, g, j), J = nb(g, j, Y, this.chart);
      this.xAlign = Y.xAlign, this.yAlign = Y.yAlign, b = {
        opacity: 1,
        x: J.x,
        y: J.y,
        width: O.width,
        height: O.height,
        caretX: i.x,
        caretY: i.y
      };
    }
    this._tooltipItems = E, this.$context = void 0, b && this._resolveAnimations().update(this, b), a && g.external && g.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: d
    });
  }
  drawCaret(a, d, g, w) {
    const b = this.getCaretPosition(a, g, w);
    d.lineTo(b.x1, b.y1), d.lineTo(b.x2, b.y2), d.lineTo(b.x3, b.y3);
  }
  getCaretPosition(a, d, g) {
    const { xAlign: w, yAlign: b } = this, { caretSize: E, cornerRadius: i } = g, { topLeft: O, topRight: j, bottomLeft: Y, bottomRight: J } = kh(i), { x: ae, y: ce } = a, { width: Te, height: be } = d;
    let Ze, je, ot, vt, ht, gt;
    return b === "center" ? (ht = ce + be / 2, w === "left" ? (Ze = ae, je = Ze - E, vt = ht + E, gt = ht - E) : (Ze = ae + Te, je = Ze + E, vt = ht - E, gt = ht + E), ot = Ze) : (w === "left" ? je = ae + Math.max(O, Y) + E : w === "right" ? je = ae + Te - Math.max(j, J) - E : je = this.caretX, b === "top" ? (vt = ce, ht = vt - E, Ze = je - E, ot = je + E) : (vt = ce + be, ht = vt + E, Ze = je + E, ot = je - E), gt = vt), {
      x1: Ze,
      x2: je,
      x3: ot,
      y1: vt,
      y2: ht,
      y3: gt
    };
  }
  drawTitle(a, d, g) {
    const w = this.title, b = w.length;
    let E, i, O;
    if (b) {
      const j = $u(g.rtl, this.x, this.width);
      for (a.x = Tm(this, g.titleAlign, g), d.textAlign = j.textAlign(g.titleAlign), d.textBaseline = "middle", E = ir(g.titleFont), i = g.titleSpacing, d.fillStyle = g.titleColor, d.font = E.string, O = 0; O < b; ++O)
        d.fillText(w[O], j.x(a.x), a.y + E.lineHeight / 2), a.y += E.lineHeight + i, O + 1 === b && (a.y += g.titleMarginBottom - i);
    }
  }
  _drawColorBox(a, d, g, w, b) {
    const E = this.labelColors[g], i = this.labelPointStyles[g], { boxHeight: O, boxWidth: j } = b, Y = ir(b.bodyFont), J = Tm(this, "left", b), ae = w.x(J), ce = O < Y.lineHeight ? (Y.lineHeight - O) / 2 : 0, Te = d.y + ce;
    if (b.usePointStyle) {
      const be = {
        radius: Math.min(j, O) / 2,
        pointStyle: i.pointStyle,
        rotation: i.rotation,
        borderWidth: 1
      }, Ze = w.leftForLtr(ae, j) + j / 2, je = Te + O / 2;
      a.strokeStyle = b.multiKeyBackground, a.fillStyle = b.multiKeyBackground, qg(a, be, Ze, je), a.strokeStyle = E.borderColor, a.fillStyle = E.backgroundColor, qg(a, be, Ze, je);
    } else {
      a.lineWidth = yn(E.borderWidth) ? Math.max(...Object.values(E.borderWidth)) : E.borderWidth || 1, a.strokeStyle = E.borderColor, a.setLineDash(E.borderDash || []), a.lineDashOffset = E.borderDashOffset || 0;
      const be = w.leftForLtr(ae, j), Ze = w.leftForLtr(w.xPlus(ae, 1), j - 2), je = kh(E.borderRadius);
      Object.values(je).some((ot) => ot !== 0) ? (a.beginPath(), a.fillStyle = b.multiKeyBackground, Bf(a, {
        x: be,
        y: Te,
        w: j,
        h: O,
        radius: je
      }), a.fill(), a.stroke(), a.fillStyle = E.backgroundColor, a.beginPath(), Bf(a, {
        x: Ze,
        y: Te + 1,
        w: j - 2,
        h: O - 2,
        radius: je
      }), a.fill()) : (a.fillStyle = b.multiKeyBackground, a.fillRect(be, Te, j, O), a.strokeRect(be, Te, j, O), a.fillStyle = E.backgroundColor, a.fillRect(Ze, Te + 1, j - 2, O - 2));
    }
    a.fillStyle = this.labelTextColors[g];
  }
  drawBody(a, d, g) {
    const { body: w } = this, { bodySpacing: b, bodyAlign: E, displayColors: i, boxHeight: O, boxWidth: j, boxPadding: Y } = g, J = ir(g.bodyFont);
    let ae = J.lineHeight, ce = 0;
    const Te = $u(g.rtl, this.x, this.width), be = function(Gt) {
      d.fillText(Gt, Te.x(a.x + ce), a.y + ae / 2), a.y += ae + b;
    }, Ze = Te.textAlign(E);
    let je, ot, vt, ht, gt, Vt, pt;
    for (d.textAlign = E, d.textBaseline = "middle", d.font = J.string, a.x = Tm(this, Ze, g), d.fillStyle = g.bodyColor, Zn(this.beforeBody, be), ce = i && Ze !== "right" ? E === "center" ? j / 2 + Y : j + 2 + Y : 0, ht = 0, Vt = w.length; ht < Vt; ++ht) {
      for (je = w[ht], ot = this.labelTextColors[ht], d.fillStyle = ot, Zn(je.before, be), vt = je.lines, i && vt.length && (this._drawColorBox(d, a, ht, Te, g), ae = Math.max(J.lineHeight, O)), gt = 0, pt = vt.length; gt < pt; ++gt)
        be(vt[gt]), ae = J.lineHeight;
      Zn(je.after, be);
    }
    ce = 0, ae = J.lineHeight, Zn(this.afterBody, be), a.y -= b;
  }
  drawFooter(a, d, g) {
    const w = this.footer, b = w.length;
    let E, i;
    if (b) {
      const O = $u(g.rtl, this.x, this.width);
      for (a.x = Tm(this, g.footerAlign, g), a.y += g.footerMarginTop, d.textAlign = O.textAlign(g.footerAlign), d.textBaseline = "middle", E = ir(g.footerFont), d.fillStyle = g.footerColor, d.font = E.string, i = 0; i < b; ++i)
        d.fillText(w[i], O.x(a.x), a.y + E.lineHeight / 2), a.y += E.lineHeight + g.footerSpacing;
    }
  }
  drawBackground(a, d, g, w) {
    const { xAlign: b, yAlign: E } = this, { x: i, y: O } = a, { width: j, height: Y } = g, { topLeft: J, topRight: ae, bottomLeft: ce, bottomRight: Te } = kh(w.cornerRadius);
    d.fillStyle = w.backgroundColor, d.strokeStyle = w.borderColor, d.lineWidth = w.borderWidth, d.beginPath(), d.moveTo(i + J, O), E === "top" && this.drawCaret(a, d, g, w), d.lineTo(i + j - ae, O), d.quadraticCurveTo(i + j, O, i + j, O + ae), E === "center" && b === "right" && this.drawCaret(a, d, g, w), d.lineTo(i + j, O + Y - Te), d.quadraticCurveTo(i + j, O + Y, i + j - Te, O + Y), E === "bottom" && this.drawCaret(a, d, g, w), d.lineTo(i + ce, O + Y), d.quadraticCurveTo(i, O + Y, i, O + Y - ce), E === "center" && b === "left" && this.drawCaret(a, d, g, w), d.lineTo(i, O + J), d.quadraticCurveTo(i, O, i + J, O), d.closePath(), d.fill(), w.borderWidth > 0 && d.stroke();
  }
  _updateAnimationTarget(a) {
    const d = this.chart, g = this.$animations, w = g && g.x, b = g && g.y;
    if (w || b) {
      const E = Ef[a.position].call(this, this._active, this._eventPosition);
      if (!E)
        return;
      const i = this._size = tb(this, a), O = Object.assign({}, E, this._size), j = ib(d, a, O), Y = nb(a, O, j, d);
      (w._to !== Y.x || b._to !== Y.y) && (this.xAlign = j.xAlign, this.yAlign = j.yAlign, this.width = i.width, this.height = i.height, this.caretX = E.x, this.caretY = E.y, this._resolveAnimations().update(this, Y));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(a) {
    const d = this.options.setContext(this.getContext());
    let g = this.opacity;
    if (!g)
      return;
    this._updateAnimationTarget(d);
    const w = {
      width: this.width,
      height: this.height
    }, b = {
      x: this.x,
      y: this.y
    };
    g = Math.abs(g) < 1e-3 ? 0 : g;
    const E = Gr(d.padding), i = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    d.enabled && i && (a.save(), a.globalAlpha = g, this.drawBackground(b, a, w, d), Gb(a, d.textDirection), b.y += E.top, this.drawTitle(b, a, d), this.drawBody(b, a, d), this.drawFooter(b, a, d), Zb(a, d.textDirection), a.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(a, d) {
    const g = this._active, w = a.map(({ datasetIndex: i, index: O }) => {
      const j = this.chart.getDatasetMeta(i);
      if (!j)
        throw new Error("Cannot find a dataset at index " + i);
      return {
        datasetIndex: i,
        element: j.data[O],
        index: O
      };
    }), b = !Om(g, w), E = this._positionChanged(w, d);
    (b || E) && (this._active = w, this._eventPosition = d, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(a, d, g = !0) {
    if (d && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const w = this.options, b = this._active || [], E = this._getActiveElements(a, b, d, g), i = this._positionChanged(E, a), O = d || !Om(E, b) || i;
    return O && (this._active = E, (w.enabled || w.external) && (this._eventPosition = {
      x: a.x,
      y: a.y
    }, this.update(!0, d))), O;
  }
  _getActiveElements(a, d, g, w) {
    const b = this.options;
    if (a.type === "mouseout")
      return [];
    if (!w)
      return d.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    const E = this.chart.getElementsAtEventForMode(a, b.mode, b, g);
    return b.reverse && E.reverse(), E;
  }
  _positionChanged(a, d) {
    const { caretX: g, caretY: w, options: b } = this, E = Ef[b.position].call(this, a, d);
    return E !== !1 && (g !== E.x || w !== E.y);
  }
}
Yt(Qg, "positioners", Ef);
var tC = {
  id: "tooltip",
  _element: Qg,
  positioners: Ef,
  afterInit(m, a, d) {
    d && (m.tooltip = new Qg({
      chart: m,
      options: d
    }));
  },
  beforeUpdate(m, a, d) {
    m.tooltip && m.tooltip.initialize(d);
  },
  reset(m, a, d) {
    m.tooltip && m.tooltip.initialize(d);
  },
  afterDraw(m) {
    const a = m.tooltip;
    if (a && a._willRender()) {
      const d = {
        tooltip: a
      };
      if (m.notifyPlugins("beforeTooltipDraw", {
        ...d,
        cancelable: !0
      }) === !1)
        return;
      a.draw(m.ctx), m.notifyPlugins("afterTooltipDraw", d);
    }
  },
  afterEvent(m, a) {
    if (m.tooltip) {
      const d = a.replay;
      m.tooltip.handleEvent(a.event, d, a.inChartArea) && (a.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (m, a) => a.bodyFont.size,
    boxWidth: (m, a) => a.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: mw
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (m) => m !== "filter" && m !== "itemSort" && m !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, iC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: pP,
  Decimation: yP,
  Filler: BP,
  Legend: ZP,
  SubTitle: WP,
  Title: qP,
  Tooltip: tC
});
const nC = (m, a, d, g) => (typeof a == "string" ? (d = m.push(a) - 1, g.unshift({
  index: d,
  label: a
})) : isNaN(a) && (d = null), d);
function sC(m, a, d, g) {
  const w = m.indexOf(a);
  if (w === -1)
    return nC(m, a, d, g);
  const b = m.lastIndexOf(a);
  return w !== b ? d : w;
}
const rC = (m, a) => m === null ? null : gr(Math.round(m), 0, a);
function ob(m) {
  const a = this.getLabels();
  return m >= 0 && m < a.length ? a[m] : m;
}
class ey extends Bh {
  constructor(a) {
    super(a), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(a) {
    const d = this._addedLabels;
    if (d.length) {
      const g = this.getLabels();
      for (const { index: w, label: b } of d)
        g[w] === b && g.splice(w, 1);
      this._addedLabels = [];
    }
    super.init(a);
  }
  parse(a, d) {
    if (En(a))
      return null;
    const g = this.getLabels();
    return d = isFinite(d) && g[d] === a ? d : sC(g, a, en(d, a), this._addedLabels), rC(d, g.length - 1);
  }
  determineDataLimits() {
    const { minDefined: a, maxDefined: d } = this.getUserBounds();
    let { min: g, max: w } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (a || (g = 0), d || (w = this.getLabels().length - 1)), this.min = g, this.max = w;
  }
  buildTicks() {
    const a = this.min, d = this.max, g = this.options.offset, w = [];
    let b = this.getLabels();
    b = a === 0 && d === b.length - 1 ? b : b.slice(a, d + 1), this._valueRange = Math.max(b.length - (g ? 0 : 1), 1), this._startValue = this.min - (g ? 0.5 : 0);
    for (let E = a; E <= d; E++)
      w.push({
        value: E
      });
    return w;
  }
  getLabelForValue(a) {
    return ob.call(this, a);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(a) {
    return typeof a != "number" && (a = this.parse(a)), a === null ? NaN : this.getPixelForDecimal((a - this._startValue) / this._valueRange);
  }
  getPixelForTick(a) {
    const d = this.ticks;
    return a < 0 || a > d.length - 1 ? null : this.getPixelForValue(d[a].value);
  }
  getValueForPixel(a) {
    return Math.round(this._startValue + this.getDecimalForPixel(a) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
Yt(ey, "id", "category"), Yt(ey, "defaults", {
  ticks: {
    callback: ob
  }
});
function oC(m, a) {
  const d = [], { bounds: w, step: b, min: E, max: i, precision: O, count: j, maxTicks: Y, maxDigits: J, includeBounds: ae } = m, ce = b || 1, Te = Y - 1, { min: be, max: Ze } = a, je = !En(E), ot = !En(i), vt = !En(j), ht = (Ze - be) / (J + 1);
  let gt = t1((Ze - be) / Te / ce) * ce, Vt, pt, Gt, ui;
  if (gt < 1e-14 && !je && !ot)
    return [
      {
        value: be
      },
      {
        value: Ze
      }
    ];
  ui = Math.ceil(Ze / gt) - Math.floor(be / gt), ui > Te && (gt = t1(ui * gt / Te / ce) * ce), En(O) || (Vt = Math.pow(10, O), gt = Math.ceil(gt * Vt) / Vt), w === "ticks" ? (pt = Math.floor(be / gt) * gt, Gt = Math.ceil(Ze / gt) * gt) : (pt = be, Gt = Ze), je && ot && b && QM((i - E) / b, gt / 1e3) ? (ui = Math.round(Math.min((i - E) / gt, Y)), gt = (i - E) / ui, pt = E, Gt = i) : vt ? (pt = je ? E : pt, Gt = ot ? i : Gt, ui = j - 1, gt = (Gt - pt) / ui) : (ui = (Gt - pt) / gt, If(ui, Math.round(ui), gt / 1e3) ? ui = Math.round(ui) : ui = Math.ceil(ui));
  const kt = Math.max(i1(gt), i1(pt));
  Vt = Math.pow(10, En(O) ? kt : O), pt = Math.round(pt * Vt) / Vt, Gt = Math.round(Gt * Vt) / Vt;
  let At = 0;
  for (je && (ae && pt !== E ? (d.push({
    value: E
  }), pt < E && At++, If(Math.round((pt + At * gt) * Vt) / Vt, E, ab(E, ht, m)) && At++) : pt < E && At++); At < ui; ++At) {
    const Mi = Math.round((pt + At * gt) * Vt) / Vt;
    if (ot && Mi > i)
      break;
    d.push({
      value: Mi
    });
  }
  return ot && ae && Gt !== i ? d.length && If(d[d.length - 1].value, i, ab(i, ht, m)) ? d[d.length - 1].value = i : d.push({
    value: i
  }) : (!ot || Gt === i) && d.push({
    value: Gt
  }), d;
}
function ab(m, a, { horizontal: d, minRotation: g }) {
  const w = Ia(g), b = (d ? Math.sin(w) : Math.cos(w)) || 1e-3, E = 0.75 * a * ("" + m).length;
  return Math.min(a / b, E);
}
class Gm extends Bh {
  constructor(a) {
    super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(a, d) {
    return En(a) || (typeof a == "number" || a instanceof Number) && !isFinite(+a) ? null : +a;
  }
  handleTickRangeOptions() {
    const { beginAtZero: a } = this.options, { minDefined: d, maxDefined: g } = this.getUserBounds();
    let { min: w, max: b } = this;
    const E = (O) => w = d ? w : O, i = (O) => b = g ? b : O;
    if (a) {
      const O = ll(w), j = ll(b);
      O < 0 && j < 0 ? i(0) : O > 0 && j > 0 && E(0);
    }
    if (w === b) {
      let O = b === 0 ? 1 : Math.abs(b * 0.05);
      i(b + O), a || E(w - O);
    }
    this.min = w, this.max = b;
  }
  getTickLimit() {
    const a = this.options.ticks;
    let { maxTicksLimit: d, stepSize: g } = a, w;
    return g ? (w = Math.ceil(this.max / g) - Math.floor(this.min / g) + 1, w > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${g} would result generating up to ${w} ticks. Limiting to 1000.`), w = 1e3)) : (w = this.computeTickLimit(), d = d || 11), d && (w = Math.min(d, w)), w;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const a = this.options, d = a.ticks;
    let g = this.getTickLimit();
    g = Math.max(2, g);
    const w = {
      maxTicks: g,
      bounds: a.bounds,
      min: a.min,
      max: a.max,
      precision: d.precision,
      step: d.stepSize,
      count: d.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: d.minRotation || 0,
      includeBounds: d.includeBounds !== !1
    }, b = this._range || this, E = oC(w, b);
    return a.bounds === "ticks" && Eb(E, this, "value"), a.reverse ? (E.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), E;
  }
  configure() {
    const a = this.ticks;
    let d = this.min, g = this.max;
    if (super.configure(), this.options.offset && a.length) {
      const w = (g - d) / Math.max(a.length - 1, 1) / 2;
      d -= w, g += w;
    }
    this._startValue = d, this._endValue = g, this._valueRange = g - d;
  }
  getLabelForValue(a) {
    return Zf(a, this.chart.options.locale, this.options.ticks.format);
  }
}
class ty extends Gm {
  determineDataLimits() {
    const { min: a, max: d } = this.getMinMax(!0);
    this.min = Ps(a) ? a : 0, this.max = Ps(d) ? d : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const a = this.isHorizontal(), d = a ? this.width : this.height, g = Ia(this.options.ticks.minRotation), w = (a ? Math.sin(g) : Math.cos(g)) || 1e-3, b = this._resolveTickFontOptions(0);
    return Math.ceil(d / Math.min(40, b.lineHeight / w));
  }
  getPixelForValue(a) {
    return a === null ? NaN : this.getPixelForDecimal((a - this._startValue) / this._valueRange);
  }
  getValueForPixel(a) {
    return this._startValue + this.getDecimalForPixel(a) * this._valueRange;
  }
}
Yt(ty, "id", "linear"), Yt(ty, "defaults", {
  ticks: {
    callback: qm.formatters.numeric
  }
});
const Vf = (m) => Math.floor(Lc(m)), Ih = (m, a) => Math.pow(10, Vf(m) + a);
function lb(m) {
  return m / Math.pow(10, Vf(m)) === 1;
}
function cb(m, a, d) {
  const g = Math.pow(10, d), w = Math.floor(m / g);
  return Math.ceil(a / g) - w;
}
function aC(m, a) {
  const d = a - m;
  let g = Vf(d);
  for (; cb(m, a, g) > 10; )
    g++;
  for (; cb(m, a, g) < 10; )
    g--;
  return Math.min(g, Vf(m));
}
function lC(m, { min: a, max: d }) {
  a = Bo(m.min, a);
  const g = [], w = Vf(a);
  let b = aC(a, d), E = b < 0 ? Math.pow(10, Math.abs(b)) : 1;
  const i = Math.pow(10, b), O = w > b ? Math.pow(10, w) : 0, j = Math.round((a - O) * E) / E, Y = Math.floor((a - O) / i / 10) * i * 10;
  let J = Math.floor((j - Y) / Math.pow(10, b)), ae = Bo(m.min, Math.round((O + Y + J * Math.pow(10, b)) * E) / E);
  for (; ae < d; )
    g.push({
      value: ae,
      major: lb(ae),
      significand: J
    }), J >= 10 ? J = J < 15 ? 15 : 20 : J++, J >= 20 && (b++, J = 2, E = b >= 0 ? 1 : E), ae = Math.round((O + Y + J * Math.pow(10, b)) * E) / E;
  const ce = Bo(m.max, ae);
  return g.push({
    value: ce,
    major: lb(ce),
    significand: J
  }), g;
}
class iy extends Bh {
  constructor(a) {
    super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(a, d) {
    const g = Gm.prototype.parse.apply(this, [
      a,
      d
    ]);
    if (g === 0) {
      this._zero = !0;
      return;
    }
    return Ps(g) && g > 0 ? g : null;
  }
  determineDataLimits() {
    const { min: a, max: d } = this.getMinMax(!0);
    this.min = Ps(a) ? Math.max(0, a) : null, this.max = Ps(d) ? Math.max(0, d) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ps(this._userMin) && (this.min = a === Ih(this.min, 0) ? Ih(this.min, -1) : Ih(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: a, maxDefined: d } = this.getUserBounds();
    let g = this.min, w = this.max;
    const b = (i) => g = a ? g : i, E = (i) => w = d ? w : i;
    g === w && (g <= 0 ? (b(1), E(10)) : (b(Ih(g, -1)), E(Ih(w, 1)))), g <= 0 && b(Ih(w, -1)), w <= 0 && E(Ih(g, 1)), this.min = g, this.max = w;
  }
  buildTicks() {
    const a = this.options, d = {
      min: this._userMin,
      max: this._userMax
    }, g = lC(d, this);
    return a.bounds === "ticks" && Eb(g, this, "value"), a.reverse ? (g.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), g;
  }
  getLabelForValue(a) {
    return a === void 0 ? "0" : Zf(a, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const a = this.min;
    super.configure(), this._startValue = Lc(a), this._valueRange = Lc(this.max) - Lc(a);
  }
  getPixelForValue(a) {
    return (a === void 0 || a === 0) && (a = this.min), a === null || isNaN(a) ? NaN : this.getPixelForDecimal(a === this.min ? 0 : (Lc(a) - this._startValue) / this._valueRange);
  }
  getValueForPixel(a) {
    const d = this.getDecimalForPixel(a);
    return Math.pow(10, this._startValue + d * this._valueRange);
  }
}
Yt(iy, "id", "logarithmic"), Yt(iy, "defaults", {
  ticks: {
    callback: qm.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function ny(m) {
  const a = m.ticks;
  if (a.display && m.display) {
    const d = Gr(a.backdropPadding);
    return en(a.font && a.font.size, ys.font.size) + d.height;
  }
  return 0;
}
function cC(m, a, d) {
  return d = hs(d) ? d : [
    d
  ], {
    w: _S(m, a.string, d),
    h: d.length * a.lineHeight
  };
}
function hb(m, a, d, g, w) {
  return m === g || m === w ? {
    start: a - d / 2,
    end: a + d / 2
  } : m < g || m > w ? {
    start: a - d,
    end: a
  } : {
    start: a,
    end: a + d
  };
}
function hC(m) {
  const a = {
    l: m.left + m._padding.left,
    r: m.right - m._padding.right,
    t: m.top + m._padding.top,
    b: m.bottom - m._padding.bottom
  }, d = Object.assign({}, a), g = [], w = [], b = m._pointLabels.length, E = m.options.pointLabels, i = E.centerPointLabels ? ds / b : 0;
  for (let O = 0; O < b; O++) {
    const j = E.setContext(m.getPointLabelContext(O));
    w[O] = j.padding;
    const Y = m.getPointPosition(O, m.drawingArea + w[O], i), J = ir(j.font), ae = cC(m.ctx, J, m._pointLabels[O]);
    g[O] = ae;
    const ce = No(m.getIndexAngle(O) + i), Te = Math.round(uy(ce)), be = hb(Te, Y.x, ae.w, 0, 180), Ze = hb(Te, Y.y, ae.h, 90, 270);
    uC(d, a, ce, be, Ze);
  }
  m.setCenterPoint(a.l - d.l, d.r - a.r, a.t - d.t, d.b - a.b), m._pointLabelItems = pC(m, g, w);
}
function uC(m, a, d, g, w) {
  const b = Math.abs(Math.sin(d)), E = Math.abs(Math.cos(d));
  let i = 0, O = 0;
  g.start < a.l ? (i = (a.l - g.start) / b, m.l = Math.min(m.l, a.l - i)) : g.end > a.r && (i = (g.end - a.r) / b, m.r = Math.max(m.r, a.r + i)), w.start < a.t ? (O = (a.t - w.start) / E, m.t = Math.min(m.t, a.t - O)) : w.end > a.b && (O = (w.end - a.b) / E, m.b = Math.max(m.b, a.b + O));
}
function dC(m, a, d) {
  const g = m.drawingArea, { extra: w, additionalAngle: b, padding: E, size: i } = d, O = m.getPointPosition(a, g + w + E, b), j = Math.round(uy(No(O.angle + Ns))), Y = gC(O.y, i.h, j), J = mC(j), ae = _C(O.x, i.w, J);
  return {
    visible: !0,
    x: O.x,
    y: Y,
    textAlign: J,
    left: ae,
    top: Y,
    right: ae + i.w,
    bottom: Y + i.h
  };
}
function fC(m, a) {
  if (!a)
    return !0;
  const { left: d, top: g, right: w, bottom: b } = m;
  return !(Ul({
    x: d,
    y: g
  }, a) || Ul({
    x: d,
    y: b
  }, a) || Ul({
    x: w,
    y: g
  }, a) || Ul({
    x: w,
    y: b
  }, a));
}
function pC(m, a, d) {
  const g = [], w = m._pointLabels.length, b = m.options, { centerPointLabels: E, display: i } = b.pointLabels, O = {
    extra: ny(b) / 2,
    additionalAngle: E ? ds / w : 0
  };
  let j;
  for (let Y = 0; Y < w; Y++) {
    O.padding = d[Y], O.size = a[Y];
    const J = dC(m, Y, O);
    g.push(J), i === "auto" && (J.visible = fC(J, j), J.visible && (j = J));
  }
  return g;
}
function mC(m) {
  return m === 0 || m === 180 ? "center" : m < 180 ? "left" : "right";
}
function _C(m, a, d) {
  return d === "right" ? m -= a : d === "center" && (m -= a / 2), m;
}
function gC(m, a, d) {
  return d === 90 || d === 270 ? m -= a / 2 : (d > 270 || d < 90) && (m -= a), m;
}
function yC(m, a, d) {
  const { left: g, top: w, right: b, bottom: E } = d, { backdropColor: i } = a;
  if (!En(i)) {
    const O = kh(a.borderRadius), j = Gr(a.backdropPadding);
    m.fillStyle = i;
    const Y = g - j.left, J = w - j.top, ae = b - g + j.width, ce = E - w + j.height;
    Object.values(O).some((Te) => Te !== 0) ? (m.beginPath(), Bf(m, {
      x: Y,
      y: J,
      w: ae,
      h: ce,
      radius: O
    }), m.fill()) : m.fillRect(Y, J, ae, ce);
  }
}
function xC(m, a) {
  const { ctx: d, options: { pointLabels: g } } = m;
  for (let w = a - 1; w >= 0; w--) {
    const b = m._pointLabelItems[w];
    if (!b.visible)
      continue;
    const E = g.setContext(m.getPointLabelContext(w));
    yC(d, E, b);
    const i = ir(E.font), { x: O, y: j, textAlign: Y } = b;
    Fh(d, m._pointLabels[w], O, j + i.lineHeight / 2, i, {
      color: E.color,
      textAlign: Y,
      textBaseline: "middle"
    });
  }
}
function _w(m, a, d, g) {
  const { ctx: w } = m;
  if (d)
    w.arc(m.xCenter, m.yCenter, a, 0, us);
  else {
    let b = m.getPointPosition(0, a);
    w.moveTo(b.x, b.y);
    for (let E = 1; E < g; E++)
      b = m.getPointPosition(E, a), w.lineTo(b.x, b.y);
  }
}
function vC(m, a, d, g, w) {
  const b = m.ctx, E = a.circular, { color: i, lineWidth: O } = a;
  !E && !g || !i || !O || d < 0 || (b.save(), b.strokeStyle = i, b.lineWidth = O, b.setLineDash(w.dash || []), b.lineDashOffset = w.dashOffset, b.beginPath(), _w(m, d, E, g), b.closePath(), b.stroke(), b.restore());
}
function bC(m, a, d) {
  return Fc(m, {
    label: d,
    index: a,
    type: "pointLabel"
  });
}
class Af extends Gm {
  constructor(a) {
    super(a), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const a = this._padding = Gr(ny(this.options) / 2), d = this.width = this.maxWidth - a.width, g = this.height = this.maxHeight - a.height;
    this.xCenter = Math.floor(this.left + d / 2 + a.left), this.yCenter = Math.floor(this.top + g / 2 + a.top), this.drawingArea = Math.floor(Math.min(d, g) / 2);
  }
  determineDataLimits() {
    const { min: a, max: d } = this.getMinMax(!1);
    this.min = Ps(a) && !isNaN(a) ? a : 0, this.max = Ps(d) && !isNaN(d) ? d : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / ny(this.options));
  }
  generateTickLabels(a) {
    Gm.prototype.generateTickLabels.call(this, a), this._pointLabels = this.getLabels().map((d, g) => {
      const w = is(this.options.pointLabels.callback, [
        d,
        g
      ], this);
      return w || w === 0 ? w : "";
    }).filter((d, g) => this.chart.getDataVisibility(g));
  }
  fit() {
    const a = this.options;
    a.display && a.pointLabels.display ? hC(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(a, d, g, w) {
    this.xCenter += Math.floor((a - d) / 2), this.yCenter += Math.floor((g - w) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(a, d, g, w));
  }
  getIndexAngle(a) {
    const d = us / (this._pointLabels.length || 1), g = this.options.startAngle || 0;
    return No(a * d + Ia(g));
  }
  getDistanceFromCenterForValue(a) {
    if (En(a))
      return NaN;
    const d = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - a) * d : (a - this.min) * d;
  }
  getValueForDistanceFromCenter(a) {
    if (En(a))
      return NaN;
    const d = a / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - d : this.min + d;
  }
  getPointLabelContext(a) {
    const d = this._pointLabels || [];
    if (a >= 0 && a < d.length) {
      const g = d[a];
      return bC(this.getContext(), a, g);
    }
  }
  getPointPosition(a, d, g = 0) {
    const w = this.getIndexAngle(a) - Ns + g;
    return {
      x: Math.cos(w) * d + this.xCenter,
      y: Math.sin(w) * d + this.yCenter,
      angle: w
    };
  }
  getPointPositionForValue(a, d) {
    return this.getPointPosition(a, this.getDistanceFromCenterForValue(d));
  }
  getBasePosition(a) {
    return this.getPointPositionForValue(a || 0, this.getBaseValue());
  }
  getPointLabelPosition(a) {
    const { left: d, top: g, right: w, bottom: b } = this._pointLabelItems[a];
    return {
      left: d,
      top: g,
      right: w,
      bottom: b
    };
  }
  drawBackground() {
    const { backgroundColor: a, grid: { circular: d } } = this.options;
    if (a) {
      const g = this.ctx;
      g.save(), g.beginPath(), _w(this, this.getDistanceFromCenterForValue(this._endValue), d, this._pointLabels.length), g.closePath(), g.fillStyle = a, g.fill(), g.restore();
    }
  }
  drawGrid() {
    const a = this.ctx, d = this.options, { angleLines: g, grid: w, border: b } = d, E = this._pointLabels.length;
    let i, O, j;
    if (d.pointLabels.display && xC(this, E), w.display && this.ticks.forEach((Y, J) => {
      if (J !== 0 || J === 0 && this.min < 0) {
        O = this.getDistanceFromCenterForValue(Y.value);
        const ae = this.getContext(J), ce = w.setContext(ae), Te = b.setContext(ae);
        vC(this, ce, O, E, Te);
      }
    }), g.display) {
      for (a.save(), i = E - 1; i >= 0; i--) {
        const Y = g.setContext(this.getPointLabelContext(i)), { color: J, lineWidth: ae } = Y;
        !ae || !J || (a.lineWidth = ae, a.strokeStyle = J, a.setLineDash(Y.borderDash), a.lineDashOffset = Y.borderDashOffset, O = this.getDistanceFromCenterForValue(d.reverse ? this.min : this.max), j = this.getPointPosition(i, O), a.beginPath(), a.moveTo(this.xCenter, this.yCenter), a.lineTo(j.x, j.y), a.stroke());
      }
      a.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const a = this.ctx, d = this.options, g = d.ticks;
    if (!g.display)
      return;
    const w = this.getIndexAngle(0);
    let b, E;
    a.save(), a.translate(this.xCenter, this.yCenter), a.rotate(w), a.textAlign = "center", a.textBaseline = "middle", this.ticks.forEach((i, O) => {
      if (O === 0 && this.min >= 0 && !d.reverse)
        return;
      const j = g.setContext(this.getContext(O)), Y = ir(j.font);
      if (b = this.getDistanceFromCenterForValue(this.ticks[O].value), j.showLabelBackdrop) {
        a.font = Y.string, E = a.measureText(i.label).width, a.fillStyle = j.backdropColor;
        const J = Gr(j.backdropPadding);
        a.fillRect(-E / 2 - J.left, -b - Y.size / 2 - J.top, E + J.width, Y.size + J.height);
      }
      Fh(a, i.label, 0, -b, Y, {
        color: j.color,
        strokeColor: j.textStrokeColor,
        strokeWidth: j.textStrokeWidth
      });
    }), a.restore();
  }
  drawTitle() {
  }
}
Yt(Af, "id", "radialLinear"), Yt(Af, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: qm.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(a) {
      return a;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), Yt(Af, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), Yt(Af, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const Ym = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, go = /* @__PURE__ */ Object.keys(Ym);
function ub(m, a) {
  return m - a;
}
function db(m, a) {
  if (En(a))
    return null;
  const d = m._adapter, { parser: g, round: w, isoWeekday: b } = m._parseOpts;
  let E = a;
  return typeof g == "function" && (E = g(E)), Ps(E) || (E = typeof g == "string" ? d.parse(E, g) : d.parse(E)), E === null ? null : (w && (E = w === "week" && (Xu(b) || b === !0) ? d.startOf(E, "isoWeek", b) : d.startOf(E, w)), +E);
}
function fb(m, a, d, g) {
  const w = go.length;
  for (let b = go.indexOf(m); b < w - 1; ++b) {
    const E = Ym[go[b]], i = E.steps ? E.steps : Number.MAX_SAFE_INTEGER;
    if (E.common && Math.ceil((d - a) / (i * E.size)) <= g)
      return go[b];
  }
  return go[w - 1];
}
function wC(m, a, d, g, w) {
  for (let b = go.length - 1; b >= go.indexOf(d); b--) {
    const E = go[b];
    if (Ym[E].common && m._adapter.diff(w, g, E) >= a - 1)
      return E;
  }
  return go[d ? go.indexOf(d) : 0];
}
function TC(m) {
  for (let a = go.indexOf(m) + 1, d = go.length; a < d; ++a)
    if (Ym[go[a]].common)
      return go[a];
}
function pb(m, a, d) {
  if (!d)
    m[a] = !0;
  else if (d.length) {
    const { lo: g, hi: w } = dy(d, a), b = d[g] >= a ? d[g] : d[w];
    m[b] = !0;
  }
}
function MC(m, a, d, g) {
  const w = m._adapter, b = +w.startOf(a[0].value, g), E = a[a.length - 1].value;
  let i, O;
  for (i = b; i <= E; i = +w.add(i, 1, g))
    O = d[i], O >= 0 && (a[O].major = !0);
  return a;
}
function mb(m, a, d) {
  const g = [], w = {}, b = a.length;
  let E, i;
  for (E = 0; E < b; ++E)
    i = a[E], w[i] = E, g.push({
      value: i,
      major: !1
    });
  return b === 0 || !d ? g : MC(m, g, w, d);
}
class Uf extends Bh {
  constructor(a) {
    super(a), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(a, d = {}) {
    const g = a.time || (a.time = {}), w = this._adapter = new zE._date(a.adapters.date);
    w.init(d), Cf(g.displayFormats, w.formats()), this._parseOpts = {
      parser: g.parser,
      round: g.round,
      isoWeekday: g.isoWeekday
    }, super.init(a), this._normalized = d.normalized;
  }
  parse(a, d) {
    return a === void 0 ? null : db(this, a);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const a = this.options, d = this._adapter, g = a.time.unit || "day";
    let { min: w, max: b, minDefined: E, maxDefined: i } = this.getUserBounds();
    function O(j) {
      !E && !isNaN(j.min) && (w = Math.min(w, j.min)), !i && !isNaN(j.max) && (b = Math.max(b, j.max));
    }
    (!E || !i) && (O(this._getLabelBounds()), (a.bounds !== "ticks" || a.ticks.source !== "labels") && O(this.getMinMax(!1))), w = Ps(w) && !isNaN(w) ? w : +d.startOf(Date.now(), g), b = Ps(b) && !isNaN(b) ? b : +d.endOf(Date.now(), g) + 1, this.min = Math.min(w, b - 1), this.max = Math.max(w + 1, b);
  }
  _getLabelBounds() {
    const a = this.getLabelTimestamps();
    let d = Number.POSITIVE_INFINITY, g = Number.NEGATIVE_INFINITY;
    return a.length && (d = a[0], g = a[a.length - 1]), {
      min: d,
      max: g
    };
  }
  buildTicks() {
    const a = this.options, d = a.time, g = a.ticks, w = g.source === "labels" ? this.getLabelTimestamps() : this._generate();
    a.bounds === "ticks" && w.length && (this.min = this._userMin || w[0], this.max = this._userMax || w[w.length - 1]);
    const b = this.min, E = this.max, i = nS(w, b, E);
    return this._unit = d.unit || (g.autoSkip ? fb(d.minUnit, this.min, this.max, this._getLabelCapacity(b)) : wC(this, i.length, d.minUnit, this.min, this.max)), this._majorUnit = !g.major.enabled || this._unit === "year" ? void 0 : TC(this._unit), this.initOffsets(w), a.reverse && i.reverse(), mb(this, i, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((a) => +a.value));
  }
  initOffsets(a = []) {
    let d = 0, g = 0, w, b;
    this.options.offset && a.length && (w = this.getDecimalForValue(a[0]), a.length === 1 ? d = 1 - w : d = (this.getDecimalForValue(a[1]) - w) / 2, b = this.getDecimalForValue(a[a.length - 1]), a.length === 1 ? g = b : g = (b - this.getDecimalForValue(a[a.length - 2])) / 2);
    const E = a.length < 3 ? 0.5 : 0.25;
    d = gr(d, 0, E), g = gr(g, 0, E), this._offsets = {
      start: d,
      end: g,
      factor: 1 / (d + 1 + g)
    };
  }
  _generate() {
    const a = this._adapter, d = this.min, g = this.max, w = this.options, b = w.time, E = b.unit || fb(b.minUnit, d, g, this._getLabelCapacity(d)), i = en(w.ticks.stepSize, 1), O = E === "week" ? b.isoWeekday : !1, j = Xu(O) || O === !0, Y = {};
    let J = d, ae, ce;
    if (j && (J = +a.startOf(J, "isoWeek", O)), J = +a.startOf(J, j ? "day" : E), a.diff(g, d, E) > 1e5 * i)
      throw new Error(d + " and " + g + " are too far apart with stepSize of " + i + " " + E);
    const Te = w.ticks.source === "data" && this.getDataTimestamps();
    for (ae = J, ce = 0; ae < g; ae = +a.add(ae, i, E), ce++)
      pb(Y, ae, Te);
    return (ae === g || w.bounds === "ticks" || ce === 1) && pb(Y, ae, Te), Object.keys(Y).sort(ub).map((be) => +be);
  }
  getLabelForValue(a) {
    const d = this._adapter, g = this.options.time;
    return g.tooltipFormat ? d.format(a, g.tooltipFormat) : d.format(a, g.displayFormats.datetime);
  }
  format(a, d) {
    const w = this.options.time.displayFormats, b = this._unit, E = d || w[b];
    return this._adapter.format(a, E);
  }
  _tickFormatFunction(a, d, g, w) {
    const b = this.options, E = b.ticks.callback;
    if (E)
      return is(E, [
        a,
        d,
        g
      ], this);
    const i = b.time.displayFormats, O = this._unit, j = this._majorUnit, Y = O && i[O], J = j && i[j], ae = g[d], ce = j && J && ae && ae.major;
    return this._adapter.format(a, w || (ce ? J : Y));
  }
  generateTickLabels(a) {
    let d, g, w;
    for (d = 0, g = a.length; d < g; ++d)
      w = a[d], w.label = this._tickFormatFunction(w.value, d, a);
  }
  getDecimalForValue(a) {
    return a === null ? NaN : (a - this.min) / (this.max - this.min);
  }
  getPixelForValue(a) {
    const d = this._offsets, g = this.getDecimalForValue(a);
    return this.getPixelForDecimal((d.start + g) * d.factor);
  }
  getValueForPixel(a) {
    const d = this._offsets, g = this.getDecimalForPixel(a) / d.factor - d.end;
    return this.min + g * (this.max - this.min);
  }
  _getLabelSize(a) {
    const d = this.options.ticks, g = this.ctx.measureText(a).width, w = Ia(this.isHorizontal() ? d.maxRotation : d.minRotation), b = Math.cos(w), E = Math.sin(w), i = this._resolveTickFontOptions(0).size;
    return {
      w: g * b + i * E,
      h: g * E + i * b
    };
  }
  _getLabelCapacity(a) {
    const d = this.options.time, g = d.displayFormats, w = g[d.unit] || g.millisecond, b = this._tickFormatFunction(a, 0, mb(this, [
      a
    ], this._majorUnit), w), E = this._getLabelSize(b), i = Math.floor(this.isHorizontal() ? this.width / E.w : this.height / E.h) - 1;
    return i > 0 ? i : 1;
  }
  getDataTimestamps() {
    let a = this._cache.data || [], d, g;
    if (a.length)
      return a;
    const w = this.getMatchingVisibleMetas();
    if (this._normalized && w.length)
      return this._cache.data = w[0].controller.getAllParsedValues(this);
    for (d = 0, g = w.length; d < g; ++d)
      a = a.concat(w[d].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(a);
  }
  getLabelTimestamps() {
    const a = this._cache.labels || [];
    let d, g;
    if (a.length)
      return a;
    const w = this.getLabels();
    for (d = 0, g = w.length; d < g; ++d)
      a.push(db(this, w[d]));
    return this._cache.labels = this._normalized ? a : this.normalize(a);
  }
  normalize(a) {
    return Cb(a.sort(ub));
  }
}
Yt(Uf, "id", "time"), Yt(Uf, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function Mm(m, a, d) {
  let g = 0, w = m.length - 1, b, E, i, O;
  d ? (a >= m[g].pos && a <= m[w].pos && ({ lo: g, hi: w } = Vl(m, "pos", a)), { pos: b, time: i } = m[g], { pos: E, time: O } = m[w]) : (a >= m[g].time && a <= m[w].time && ({ lo: g, hi: w } = Vl(m, "time", a)), { time: b, pos: i } = m[g], { time: E, pos: O } = m[w]);
  const j = E - b;
  return j ? i + (O - i) * (a - b) / j : i;
}
class sy extends Uf {
  constructor(a) {
    super(a), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const a = this._getTimestampsForTable(), d = this._table = this.buildLookupTable(a);
    this._minPos = Mm(d, this.min), this._tableRange = Mm(d, this.max) - this._minPos, super.initOffsets(a);
  }
  buildLookupTable(a) {
    const { min: d, max: g } = this, w = [], b = [];
    let E, i, O, j, Y;
    for (E = 0, i = a.length; E < i; ++E)
      j = a[E], j >= d && j <= g && w.push(j);
    if (w.length < 2)
      return [
        {
          time: d,
          pos: 0
        },
        {
          time: g,
          pos: 1
        }
      ];
    for (E = 0, i = w.length; E < i; ++E)
      Y = w[E + 1], O = w[E - 1], j = w[E], Math.round((Y + O) / 2) !== j && b.push({
        time: j,
        pos: E / (i - 1)
      });
    return b;
  }
  _generate() {
    const a = this.min, d = this.max;
    let g = super.getDataTimestamps();
    return (!g.includes(a) || !g.length) && g.splice(0, 0, a), (!g.includes(d) || g.length === 1) && g.push(d), g.sort((w, b) => w - b);
  }
  _getTimestampsForTable() {
    let a = this._cache.all || [];
    if (a.length)
      return a;
    const d = this.getDataTimestamps(), g = this.getLabelTimestamps();
    return d.length && g.length ? a = this.normalize(d.concat(g)) : a = d.length ? d : g, a = this._cache.all = a, a;
  }
  getDecimalForValue(a) {
    return (Mm(this._table, a) - this._minPos) / this._tableRange;
  }
  getValueForPixel(a) {
    const d = this._offsets, g = this.getDecimalForPixel(a) / d.factor - d.end;
    return Mm(this._table, g * this._tableRange + this._minPos, !0);
  }
}
Yt(sy, "id", "timeseries"), Yt(sy, "defaults", Uf.defaults);
var SC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: ey,
  LinearScale: ty,
  LogarithmicScale: iy,
  RadialLinearScale: Af,
  TimeScale: Uf,
  TimeSeriesScale: sy
});
const EC = [
  LE,
  aP,
  iC,
  SC
], Zm = {
  Utils: {
    DividePolylinesPoints(m) {
      let a = 0;
      const d = [], g = m.length;
      for (let w = 0; w < g; w++)
        m[w] === null && (d.push(m.slice(a === 0 ? 0 : a + 1, w)), a = w);
      return g - 1 !== a && d.push(m.slice(a)), d;
    },
    GetItemFromArray(m, a) {
      try {
        return m[a];
      } catch {
        return [0, 0];
      }
    }
  }
};
var Km = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gw(m) {
  return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, "default") ? m.default : m;
}
var Sm = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var _b;
function yw() {
  return _b || (_b = 1, function(m, a) {
    (function(d, g) {
      g(a);
    })(Km, function(d) {
      var g = "1.9.4";
      function w(p) {
        var P, B, X, ne;
        for (B = 1, X = arguments.length; B < X; B++) {
          ne = arguments[B];
          for (P in ne)
            p[P] = ne[P];
        }
        return p;
      }
      var b = Object.create || function() {
        function p() {
        }
        return function(P) {
          return p.prototype = P, new p();
        };
      }();
      function E(p, P) {
        var B = Array.prototype.slice;
        if (p.bind)
          return p.bind.apply(p, B.call(arguments, 1));
        var X = B.call(arguments, 2);
        return function() {
          return p.apply(P, X.length ? X.concat(B.call(arguments)) : arguments);
        };
      }
      var i = 0;
      function O(p) {
        return "_leaflet_id" in p || (p._leaflet_id = ++i), p._leaflet_id;
      }
      function j(p, P, B) {
        var X, ne, ye, We;
        return We = function() {
          X = !1, ne && (ye.apply(B, ne), ne = !1);
        }, ye = function() {
          X ? ne = arguments : (p.apply(B, arguments), setTimeout(We, P), X = !0);
        }, ye;
      }
      function Y(p, P, B) {
        var X = P[1], ne = P[0], ye = X - ne;
        return p === X && B ? p : ((p - ne) % ye + ye) % ye + ne;
      }
      function J() {
        return !1;
      }
      function ae(p, P) {
        if (P === !1)
          return p;
        var B = Math.pow(10, P === void 0 ? 6 : P);
        return Math.round(p * B) / B;
      }
      function ce(p) {
        return p.trim ? p.trim() : p.replace(/^\s+|\s+$/g, "");
      }
      function Te(p) {
        return ce(p).split(/\s+/);
      }
      function be(p, P) {
        Object.prototype.hasOwnProperty.call(p, "options") || (p.options = p.options ? b(p.options) : {});
        for (var B in P)
          p.options[B] = P[B];
        return p.options;
      }
      function Ze(p, P, B) {
        var X = [];
        for (var ne in p)
          X.push(encodeURIComponent(B ? ne.toUpperCase() : ne) + "=" + encodeURIComponent(p[ne]));
        return (!P || P.indexOf("?") === -1 ? "?" : "&") + X.join("&");
      }
      var je = /\{ *([\w_ -]+) *\}/g;
      function ot(p, P) {
        return p.replace(je, function(B, X) {
          var ne = P[X];
          if (ne === void 0)
            throw new Error("No value provided for variable " + B);
          return typeof ne == "function" && (ne = ne(P)), ne;
        });
      }
      var vt = Array.isArray || function(p) {
        return Object.prototype.toString.call(p) === "[object Array]";
      };
      function ht(p, P) {
        for (var B = 0; B < p.length; B++)
          if (p[B] === P)
            return B;
        return -1;
      }
      var gt = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function Vt(p) {
        return window["webkit" + p] || window["moz" + p] || window["ms" + p];
      }
      var pt = 0;
      function Gt(p) {
        var P = +/* @__PURE__ */ new Date(), B = Math.max(0, 16 - (P - pt));
        return pt = P + B, window.setTimeout(p, B);
      }
      var ui = window.requestAnimationFrame || Vt("RequestAnimationFrame") || Gt, kt = window.cancelAnimationFrame || Vt("CancelAnimationFrame") || Vt("CancelRequestAnimationFrame") || function(p) {
        window.clearTimeout(p);
      };
      function At(p, P, B) {
        if (B && ui === Gt)
          p.call(P);
        else
          return ui.call(window, E(p, P));
      }
      function Mi(p) {
        p && kt.call(window, p);
      }
      var An = {
        __proto__: null,
        extend: w,
        create: b,
        bind: E,
        get lastId() {
          return i;
        },
        stamp: O,
        throttle: j,
        wrapNum: Y,
        falseFn: J,
        formatNum: ae,
        trim: ce,
        splitWords: Te,
        setOptions: be,
        getParamString: Ze,
        template: ot,
        isArray: vt,
        indexOf: ht,
        emptyImageUrl: gt,
        requestFn: ui,
        cancelFn: kt,
        requestAnimFrame: At,
        cancelAnimFrame: Mi
      };
      function hn() {
      }
      hn.extend = function(p) {
        var P = function() {
          be(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }, B = P.__super__ = this.prototype, X = b(B);
        X.constructor = P, P.prototype = X;
        for (var ne in this)
          Object.prototype.hasOwnProperty.call(this, ne) && ne !== "prototype" && ne !== "__super__" && (P[ne] = this[ne]);
        return p.statics && w(P, p.statics), p.includes && (Ht(p.includes), w.apply(null, [X].concat(p.includes))), w(X, p), delete X.statics, delete X.includes, X.options && (X.options = B.options ? b(B.options) : {}, w(X.options, p.options)), X._initHooks = [], X.callInitHooks = function() {
          if (!this._initHooksCalled) {
            B.callInitHooks && B.callInitHooks.call(this), this._initHooksCalled = !0;
            for (var ye = 0, We = X._initHooks.length; ye < We; ye++)
              X._initHooks[ye].call(this);
          }
        }, P;
      }, hn.include = function(p) {
        var P = this.prototype.options;
        return w(this.prototype, p), p.options && (this.prototype.options = P, this.mergeOptions(p.options)), this;
      }, hn.mergeOptions = function(p) {
        return w(this.prototype.options, p), this;
      }, hn.addInitHook = function(p) {
        var P = Array.prototype.slice.call(arguments, 1), B = typeof p == "function" ? p : function() {
          this[p].apply(this, P);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(B), this;
      };
      function Ht(p) {
        if (!(typeof L > "u" || !L || !L.Mixin)) {
          p = vt(p) ? p : [p];
          for (var P = 0; P < p.length; P++)
            p[P] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
      var Si = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(p, P, B) {
          if (typeof p == "object")
            for (var X in p)
              this._on(X, p[X], P);
          else {
            p = Te(p);
            for (var ne = 0, ye = p.length; ne < ye; ne++)
              this._on(p[ne], P, B);
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(p, P, B) {
          if (!arguments.length)
            delete this._events;
          else if (typeof p == "object")
            for (var X in p)
              this._off(X, p[X], P);
          else {
            p = Te(p);
            for (var ne = arguments.length === 1, ye = 0, We = p.length; ye < We; ye++)
              ne ? this._off(p[ye]) : this._off(p[ye], P, B);
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(p, P, B, X) {
          if (typeof P != "function") {
            console.warn("wrong listener type: " + typeof P);
            return;
          }
          if (this._listens(p, P, B) === !1) {
            B === this && (B = void 0);
            var ne = { fn: P, ctx: B };
            X && (ne.once = !0), this._events = this._events || {}, this._events[p] = this._events[p] || [], this._events[p].push(ne);
          }
        },
        _off: function(p, P, B) {
          var X, ne, ye;
          if (this._events && (X = this._events[p], !!X)) {
            if (arguments.length === 1) {
              if (this._firingCount)
                for (ne = 0, ye = X.length; ne < ye; ne++)
                  X[ne].fn = J;
              delete this._events[p];
              return;
            }
            if (typeof P != "function") {
              console.warn("wrong listener type: " + typeof P);
              return;
            }
            var We = this._listens(p, P, B);
            if (We !== !1) {
              var at = X[We];
              this._firingCount && (at.fn = J, this._events[p] = X = X.slice()), X.splice(We, 1);
            }
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object  the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(p, P, B) {
          if (!this.listens(p, B))
            return this;
          var X = w({}, P, {
            type: p,
            target: this,
            sourceTarget: P && P.sourceTarget || this
          });
          if (this._events) {
            var ne = this._events[p];
            if (ne) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var ye = 0, We = ne.length; ye < We; ye++) {
                var at = ne[ye], ft = at.fn;
                at.once && this.off(p, ft, at.ctx), ft.call(at.ctx || this, X);
              }
              this._firingCount--;
            }
          }
          return B && this._propagateEvent(X), this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(p, P, B, X) {
          typeof p != "string" && console.warn('"string" type argument expected');
          var ne = P;
          typeof P != "function" && (X = !!P, ne = void 0, B = void 0);
          var ye = this._events && this._events[p];
          if (ye && ye.length && this._listens(p, ne, B) !== !1)
            return !0;
          if (X) {
            for (var We in this._eventParents)
              if (this._eventParents[We].listens(p, P, B, X))
                return !0;
          }
          return !1;
        },
        // returns the index (number) or false
        _listens: function(p, P, B) {
          if (!this._events)
            return !1;
          var X = this._events[p] || [];
          if (!P)
            return !!X.length;
          B === this && (B = void 0);
          for (var ne = 0, ye = X.length; ne < ye; ne++)
            if (X[ne].fn === P && X[ne].ctx === B)
              return ne;
          return !1;
        },
        // @method once(): this
        // Behaves as [`on()`](#evented-on), except the listener will only get fired once and then removed.
        once: function(p, P, B) {
          if (typeof p == "object")
            for (var X in p)
              this._on(X, p[X], P, !0);
          else {
            p = Te(p);
            for (var ne = 0, ye = p.length; ne < ye; ne++)
              this._on(p[ne], P, B, !0);
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(p) {
          return this._eventParents = this._eventParents || {}, this._eventParents[O(p)] = p, this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(p) {
          return this._eventParents && delete this._eventParents[O(p)], this;
        },
        _propagateEvent: function(p) {
          for (var P in this._eventParents)
            this._eventParents[P].fire(p.type, w({
              layer: p.target,
              propagatedFrom: p.target
            }, p), !0);
        }
      };
      Si.addEventListener = Si.on, Si.removeEventListener = Si.clearAllEventListeners = Si.off, Si.addOneTimeEventListener = Si.once, Si.fireEvent = Si.fire, Si.hasEventListeners = Si.listens;
      var Ji = hn.extend(Si);
      function fi(p, P, B) {
        this.x = B ? Math.round(p) : p, this.y = B ? Math.round(P) : P;
      }
      var jt = Math.trunc || function(p) {
        return p > 0 ? Math.floor(p) : Math.ceil(p);
      };
      fi.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new fi(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(p) {
          return this.clone()._add(ni(p));
        },
        _add: function(p) {
          return this.x += p.x, this.y += p.y, this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(p) {
          return this.clone()._subtract(ni(p));
        },
        _subtract: function(p) {
          return this.x -= p.x, this.y -= p.y, this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(p) {
          return this.clone()._divideBy(p);
        },
        _divideBy: function(p) {
          return this.x /= p, this.y /= p, this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(p) {
          return this.clone()._multiplyBy(p);
        },
        _multiplyBy: function(p) {
          return this.x *= p, this.y *= p, this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(p) {
          return new fi(this.x * p.x, this.y * p.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(p) {
          return new fi(this.x / p.x, this.y / p.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          return this.x = jt(this.x), this.y = jt(this.y), this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(p) {
          p = ni(p);
          var P = p.x - this.x, B = p.y - this.y;
          return Math.sqrt(P * P + B * B);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(p) {
          return p = ni(p), p.x === this.x && p.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(p) {
          return p = ni(p), Math.abs(p.x) <= Math.abs(this.x) && Math.abs(p.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + ae(this.x) + ", " + ae(this.y) + ")";
        }
      };
      function ni(p, P, B) {
        return p instanceof fi ? p : vt(p) ? new fi(p[0], p[1]) : p == null ? p : typeof p == "object" && "x" in p && "y" in p ? new fi(p.x, p.y) : new fi(p, P, B);
      }
      function Gi(p, P) {
        if (p)
          for (var B = P ? [p, P] : p, X = 0, ne = B.length; X < ne; X++)
            this.extend(B[X]);
      }
      Gi.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(p) {
          var P, B;
          if (!p)
            return this;
          if (p instanceof fi || typeof p[0] == "number" || "x" in p)
            P = B = ni(p);
          else if (p = an(p), P = p.min, B = p.max, !P || !B)
            return this;
          return !this.min && !this.max ? (this.min = P.clone(), this.max = B.clone()) : (this.min.x = Math.min(P.x, this.min.x), this.max.x = Math.max(B.x, this.max.x), this.min.y = Math.min(P.y, this.min.y), this.max.y = Math.max(B.y, this.max.y)), this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(p) {
          return ni(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            p
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return ni(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return ni(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(p) {
          var P, B;
          return typeof p[0] == "number" || p instanceof fi ? p = ni(p) : p = an(p), p instanceof Gi ? (P = p.min, B = p.max) : P = B = p, P.x >= this.min.x && B.x <= this.max.x && P.y >= this.min.y && B.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(p) {
          p = an(p);
          var P = this.min, B = this.max, X = p.min, ne = p.max, ye = ne.x >= P.x && X.x <= B.x, We = ne.y >= P.y && X.y <= B.y;
          return ye && We;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(p) {
          p = an(p);
          var P = this.min, B = this.max, X = p.min, ne = p.max, ye = ne.x > P.x && X.x < B.x, We = ne.y > P.y && X.y < B.y;
          return ye && We;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(p) {
          var P = this.min, B = this.max, X = Math.abs(P.x - B.x) * p, ne = Math.abs(P.y - B.y) * p;
          return an(
            ni(P.x - X, P.y - ne),
            ni(B.x + X, B.y + ne)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(p) {
          return p ? (p = an(p), this.min.equals(p.getTopLeft()) && this.max.equals(p.getBottomRight())) : !1;
        }
      };
      function an(p, P) {
        return !p || p instanceof Gi ? p : new Gi(p, P);
      }
      function qt(p, P) {
        if (p)
          for (var B = P ? [p, P] : p, X = 0, ne = B.length; X < ne; X++)
            this.extend(B[X]);
      }
      qt.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(p) {
          var P = this._southWest, B = this._northEast, X, ne;
          if (p instanceof Di)
            X = p, ne = p;
          else if (p instanceof qt) {
            if (X = p._southWest, ne = p._northEast, !X || !ne)
              return this;
          } else
            return p ? this.extend(xi(p) || ln(p)) : this;
          return !P && !B ? (this._southWest = new Di(X.lat, X.lng), this._northEast = new Di(ne.lat, ne.lng)) : (P.lat = Math.min(X.lat, P.lat), P.lng = Math.min(X.lng, P.lng), B.lat = Math.max(ne.lat, B.lat), B.lng = Math.max(ne.lng, B.lng)), this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(p) {
          var P = this._southWest, B = this._northEast, X = Math.abs(P.lat - B.lat) * p, ne = Math.abs(P.lng - B.lng) * p;
          return new qt(
            new Di(P.lat - X, P.lng - ne),
            new Di(B.lat + X, B.lng + ne)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new Di(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new Di(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new Di(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(p) {
          typeof p[0] == "number" || p instanceof Di || "lat" in p ? p = xi(p) : p = ln(p);
          var P = this._southWest, B = this._northEast, X, ne;
          return p instanceof qt ? (X = p.getSouthWest(), ne = p.getNorthEast()) : X = ne = p, X.lat >= P.lat && ne.lat <= B.lat && X.lng >= P.lng && ne.lng <= B.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(p) {
          p = ln(p);
          var P = this._southWest, B = this._northEast, X = p.getSouthWest(), ne = p.getNorthEast(), ye = ne.lat >= P.lat && X.lat <= B.lat, We = ne.lng >= P.lng && X.lng <= B.lng;
          return ye && We;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(p) {
          p = ln(p);
          var P = this._southWest, B = this._northEast, X = p.getSouthWest(), ne = p.getNorthEast(), ye = ne.lat > P.lat && X.lat < B.lat, We = ne.lng > P.lng && X.lng < B.lng;
          return ye && We;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(p, P) {
          return p ? (p = ln(p), this._southWest.equals(p.getSouthWest(), P) && this._northEast.equals(p.getNorthEast(), P)) : !1;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function ln(p, P) {
        return p instanceof qt ? p : new qt(p, P);
      }
      function Di(p, P, B) {
        if (isNaN(p) || isNaN(P))
          throw new Error("Invalid LatLng object: (" + p + ", " + P + ")");
        this.lat = +p, this.lng = +P, B !== void 0 && (this.alt = +B);
      }
      Di.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(p, P) {
          if (!p)
            return !1;
          p = xi(p);
          var B = Math.max(
            Math.abs(this.lat - p.lat),
            Math.abs(this.lng - p.lng)
          );
          return B <= (P === void 0 ? 1e-9 : P);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(p) {
          return "LatLng(" + ae(this.lat, p) + ", " + ae(this.lng, p) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(p) {
          return xs.distance(this, xi(p));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return xs.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(p) {
          var P = 180 * p / 40075017, B = P / Math.cos(Math.PI / 180 * this.lat);
          return ln(
            [this.lat - P, this.lng - B],
            [this.lat + P, this.lng + B]
          );
        },
        clone: function() {
          return new Di(this.lat, this.lng, this.alt);
        }
      };
      function xi(p, P, B) {
        return p instanceof Di ? p : vt(p) && typeof p[0] != "object" ? p.length === 3 ? new Di(p[0], p[1], p[2]) : p.length === 2 ? new Di(p[0], p[1]) : null : p == null ? p : typeof p == "object" && "lat" in p ? new Di(p.lat, "lng" in p ? p.lng : p.lon, p.alt) : P === void 0 ? null : new Di(p, P, B);
      }
      var Cs = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(p, P) {
          var B = this.projection.project(p), X = this.scale(P);
          return this.transformation._transform(B, X);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(p, P) {
          var B = this.scale(P), X = this.transformation.untransform(p, B);
          return this.projection.unproject(X);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(p) {
          return this.projection.project(p);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(p) {
          return this.projection.unproject(p);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(p) {
          return 256 * Math.pow(2, p);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(p) {
          return Math.log(p / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(p) {
          if (this.infinite)
            return null;
          var P = this.projection.bounds, B = this.scale(p), X = this.transformation.transform(P.min, B), ne = this.transformation.transform(P.max, B);
          return new Gi(X, ne);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: !1,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(p) {
          var P = this.wrapLng ? Y(p.lng, this.wrapLng, !0) : p.lng, B = this.wrapLat ? Y(p.lat, this.wrapLat, !0) : p.lat, X = p.alt;
          return new Di(B, P, X);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(p) {
          var P = p.getCenter(), B = this.wrapLatLng(P), X = P.lat - B.lat, ne = P.lng - B.lng;
          if (X === 0 && ne === 0)
            return p;
          var ye = p.getSouthWest(), We = p.getNorthEast(), at = new Di(ye.lat - X, ye.lng - ne), ft = new Di(We.lat - X, We.lng - ne);
          return new qt(at, ft);
        }
      }, xs = w({}, Cs, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(p, P) {
          var B = Math.PI / 180, X = p.lat * B, ne = P.lat * B, ye = Math.sin((P.lat - p.lat) * B / 2), We = Math.sin((P.lng - p.lng) * B / 2), at = ye * ye + Math.cos(X) * Math.cos(ne) * We * We, ft = 2 * Math.atan2(Math.sqrt(at), Math.sqrt(1 - at));
          return this.R * ft;
        }
      }), Is = 6378137, De = {
        R: Is,
        MAX_LATITUDE: 85.0511287798,
        project: function(p) {
          var P = Math.PI / 180, B = this.MAX_LATITUDE, X = Math.max(Math.min(B, p.lat), -B), ne = Math.sin(X * P);
          return new fi(
            this.R * p.lng * P,
            this.R * Math.log((1 + ne) / (1 - ne)) / 2
          );
        },
        unproject: function(p) {
          var P = 180 / Math.PI;
          return new Di(
            (2 * Math.atan(Math.exp(p.y / this.R)) - Math.PI / 2) * P,
            p.x * P / this.R
          );
        },
        bounds: function() {
          var p = Is * Math.PI;
          return new Gi([-p, -p], [p, p]);
        }()
      };
      function Vs(p, P, B, X) {
        if (vt(p)) {
          this._a = p[0], this._b = p[1], this._c = p[2], this._d = p[3];
          return;
        }
        this._a = p, this._b = P, this._c = B, this._d = X;
      }
      Vs.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(p, P) {
          return this._transform(p.clone(), P);
        },
        // destructive transform (faster)
        _transform: function(p, P) {
          return P = P || 1, p.x = P * (this._a * p.x + this._b), p.y = P * (this._c * p.y + this._d), p;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(p, P) {
          return P = P || 1, new fi(
            (p.x / P - this._b) / this._a,
            (p.y / P - this._d) / this._c
          );
        }
      };
      function Us(p, P, B, X) {
        return new Vs(p, P, B, X);
      }
      var Zr = w({}, xs, {
        code: "EPSG:3857",
        projection: De,
        transformation: function() {
          var p = 0.5 / (Math.PI * De.R);
          return Us(p, 0.5, -p, 0.5);
        }()
      }), Et = w({}, Zr, {
        code: "EPSG:900913"
      });
      function Ws(p) {
        return document.createElementNS("http://www.w3.org/2000/svg", p);
      }
      function $n(p, P) {
        var B = "", X, ne, ye, We, at, ft;
        for (X = 0, ye = p.length; X < ye; X++) {
          for (at = p[X], ne = 0, We = at.length; ne < We; ne++)
            ft = at[ne], B += (ne ? "L" : "M") + ft.x + " " + ft.y;
          B += P ? Ae.svg ? "z" : "x" : "";
        }
        return B || "M0 0";
      }
      var $s = document.documentElement.style, vi = "ActiveXObject" in window, kn = vi && !document.addEventListener, Xs = "msLaunchUri" in navigator && !("documentMode" in document), Hr = qe("webkit"), qr = qe("android"), Wr = qe("android 2") || qe("android 3"), si = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), fs = qr && qe("Google") && si < 537 && !("AudioNode" in window), zn = !!window.opera, Rn = !Xs && qe("chrome"), Pn = qe("gecko") && !Hr && !zn && !vi, js = !Rn && qe("safari"), yo = qe("phantom"), xo = "OTransition" in $s, vo = navigator.platform.indexOf("Win") === 0, yr = vi && "transition" in $s, Mr = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !Wr, io = "MozPerspective" in $s, Ys = !window.L_DISABLE_3D && (yr || Mr || io) && !xo && !yo, Sr = typeof orientation < "u" || qe("mobile"), mi = Sr && Hr, On = Sr && Mr, Vn = !window.PointerEvent && window.MSPointerEvent, Zi = !!(window.PointerEvent || Vn), Jn = "ontouchstart" in window || !!window.TouchEvent, Fn = !window.L_NO_TOUCH && (Jn || Zi), Ls = Sr && zn, zs = Sr && Pn, Vo = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, Ke = function() {
        var p = !1;
        try {
          var P = Object.defineProperty({}, "passive", {
            get: function() {
              p = !0;
            }
          });
          window.addEventListener("testPassiveEventSupport", J, P), window.removeEventListener("testPassiveEventSupport", J, P);
        } catch {
        }
        return p;
      }(), re = function() {
        return !!document.createElement("canvas").getContext;
      }(), le = !!(document.createElementNS && Ws("svg").createSVGRect), ge = !!le && function() {
        var p = document.createElement("div");
        return p.innerHTML = "<svg/>", (p.firstChild && p.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }(), Le = !le && function() {
        try {
          var p = document.createElement("div");
          p.innerHTML = '<v:shape adj="1"/>';
          var P = p.firstChild;
          return P.style.behavior = "url(#default#VML)", P && typeof P.adj == "object";
        } catch {
          return !1;
        }
      }(), Ce = navigator.platform.indexOf("Mac") === 0, Be = navigator.platform.indexOf("Linux") === 0;
      function qe(p) {
        return navigator.userAgent.toLowerCase().indexOf(p) >= 0;
      }
      var Ae = {
        ie: vi,
        ielt9: kn,
        edge: Xs,
        webkit: Hr,
        android: qr,
        android23: Wr,
        androidStock: fs,
        opera: zn,
        chrome: Rn,
        gecko: Pn,
        safari: js,
        phantom: yo,
        opera12: xo,
        win: vo,
        ie3d: yr,
        webkit3d: Mr,
        gecko3d: io,
        any3d: Ys,
        mobile: Sr,
        mobileWebkit: mi,
        mobileWebkit3d: On,
        msPointer: Vn,
        pointer: Zi,
        touch: Fn,
        touchNative: Jn,
        mobileOpera: Ls,
        mobileGecko: zs,
        retina: Vo,
        passiveEvents: Ke,
        canvas: re,
        svg: le,
        vml: Le,
        inlineSvg: ge,
        mac: Ce,
        linux: Be
      }, Ye = Ae.msPointer ? "MSPointerDown" : "pointerdown", Qe = Ae.msPointer ? "MSPointerMove" : "pointermove", it = Ae.msPointer ? "MSPointerUp" : "pointerup", mt = Ae.msPointer ? "MSPointerCancel" : "pointercancel", Ct = {
        touchstart: Ye,
        touchmove: Qe,
        touchend: it,
        touchcancel: mt
      }, It = {
        touchstart: Xn,
        touchmove: Hi,
        touchend: Hi,
        touchcancel: Hi
      }, Kt = {}, di = !1;
      function li(p, P, B) {
        return P === "touchstart" && $i(), It[P] ? (B = It[P].bind(this, B), p.addEventListener(Ct[P], B, !1), B) : (console.warn("wrong event specified:", P), J);
      }
      function ri(p, P, B) {
        if (!Ct[P]) {
          console.warn("wrong event specified:", P);
          return;
        }
        p.removeEventListener(Ct[P], B, !1);
      }
      function Ki(p) {
        Kt[p.pointerId] = p;
      }
      function Ni(p) {
        Kt[p.pointerId] && (Kt[p.pointerId] = p);
      }
      function Ei(p) {
        delete Kt[p.pointerId];
      }
      function $i() {
        di || (document.addEventListener(Ye, Ki, !0), document.addEventListener(Qe, Ni, !0), document.addEventListener(it, Ei, !0), document.addEventListener(mt, Ei, !0), di = !0);
      }
      function Hi(p, P) {
        if (P.pointerType !== (P.MSPOINTER_TYPE_MOUSE || "mouse")) {
          P.touches = [];
          for (var B in Kt)
            P.touches.push(Kt[B]);
          P.changedTouches = [P], p(P);
        }
      }
      function Xn(p, P) {
        P.MSPOINTER_TYPE_TOUCH && P.pointerType === P.MSPOINTER_TYPE_TOUCH && _s(P), Hi(p, P);
      }
      function Gs(p) {
        var P = {}, B, X;
        for (X in p)
          B = p[X], P[X] = B && B.bind ? B.bind(p) : B;
        return p = P, P.type = "dblclick", P.detail = 2, P.isTrusted = !1, P._simulated = !0, P;
      }
      var ps = 200;
      function vs(p, P) {
        p.addEventListener("dblclick", P);
        var B = 0, X;
        function ne(ye) {
          if (ye.detail !== 1) {
            X = ye.detail;
            return;
          }
          if (!(ye.pointerType === "mouse" || ye.sourceCapabilities && !ye.sourceCapabilities.firesTouchEvents)) {
            var We = Ho(ye);
            if (!(We.some(function(ft) {
              return ft instanceof HTMLLabelElement && ft.attributes.for;
            }) && !We.some(function(ft) {
              return ft instanceof HTMLInputElement || ft instanceof HTMLSelectElement;
            }))) {
              var at = Date.now();
              at - B <= ps ? (X++, X === 2 && P(Gs(ye))) : X = 1, B = at;
            }
          }
        }
        return p.addEventListener("click", ne), {
          dblclick: P,
          simDblclick: ne
        };
      }
      function ra(p, P) {
        p.removeEventListener("dblclick", P.dblclick), p.removeEventListener("click", P.simDblclick);
      }
      var Er = nr(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      ), oa = nr(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      ), cl = oa === "webkitTransition" || oa === "OTransition" ? oa + "End" : "transitionend";
      function Uo(p) {
        return typeof p == "string" ? document.getElementById(p) : p;
      }
      function jo(p, P) {
        var B = p.style[P] || p.currentStyle && p.currentStyle[P];
        if ((!B || B === "auto") && document.defaultView) {
          var X = document.defaultView.getComputedStyle(p, null);
          B = X ? X[P] : null;
        }
        return B === "auto" ? null : B;
      }
      function tn(p, P, B) {
        var X = document.createElement(p);
        return X.className = P || "", B && B.appendChild(X), X;
      }
      function xn(p) {
        var P = p.parentNode;
        P && P.removeChild(p);
      }
      function no(p) {
        for (; p.firstChild; )
          p.removeChild(p.firstChild);
      }
      function Go(p) {
        var P = p.parentNode;
        P && P.lastChild !== p && P.appendChild(p);
      }
      function aa(p) {
        var P = p.parentNode;
        P && P.firstChild !== p && P.insertBefore(p, P.firstChild);
      }
      function Da(p, P) {
        if (p.classList !== void 0)
          return p.classList.contains(P);
        var B = Zs(p);
        return B.length > 0 && new RegExp("(^|\\s)" + P + "(\\s|$)").test(B);
      }
      function Vi(p, P) {
        if (p.classList !== void 0)
          for (var B = Te(P), X = 0, ne = B.length; X < ne; X++)
            p.classList.add(B[X]);
        else if (!Da(p, P)) {
          var ye = Zs(p);
          hl(p, (ye ? ye + " " : "") + P);
        }
      }
      function Hn(p, P) {
        p.classList !== void 0 ? p.classList.remove(P) : hl(p, ce((" " + Zs(p) + " ").replace(" " + P + " ", " ")));
      }
      function hl(p, P) {
        p.className.baseVal === void 0 ? p.className = P : p.className.baseVal = P;
      }
      function Zs(p) {
        return p.correspondingElement && (p = p.correspondingElement), p.className.baseVal === void 0 ? p.className : p.className.baseVal;
      }
      function Qn(p, P) {
        "opacity" in p.style ? p.style.opacity = P : "filter" in p.style && Ar(p, P);
      }
      function Ar(p, P) {
        var B = !1, X = "DXImageTransform.Microsoft.Alpha";
        try {
          B = p.filters.item(X);
        } catch {
          if (P === 1)
            return;
        }
        P = Math.round(P * 100), B ? (B.Enabled = P !== 100, B.Opacity = P) : p.style.filter += " progid:" + X + "(opacity=" + P + ")";
      }
      function nr(p) {
        for (var P = document.documentElement.style, B = 0; B < p.length; B++)
          if (p[B] in P)
            return p[B];
        return !1;
      }
      function Ks(p, P, B) {
        var X = P || new fi(0, 0);
        p.style[Er] = (Ae.ie3d ? "translate(" + X.x + "px," + X.y + "px)" : "translate3d(" + X.x + "px," + X.y + "px,0)") + (B ? " scale(" + B + ")" : "");
      }
      function Yn(p, P) {
        p._leaflet_pos = P, Ae.any3d ? Ks(p, P) : (p.style.left = P.x + "px", p.style.top = P.y + "px");
      }
      function $r(p) {
        return p._leaflet_pos || new fi(0, 0);
      }
      var Pr, Cr, ka;
      if ("onselectstart" in document)
        Pr = function() {
          Bi(window, "selectstart", _s);
        }, Cr = function() {
          Cn(window, "selectstart", _s);
        };
      else {
        var la = nr(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        Pr = function() {
          if (la) {
            var p = document.documentElement.style;
            ka = p[la], p[la] = "none";
          }
        }, Cr = function() {
          la && (document.documentElement.style[la] = ka, ka = void 0);
        };
      }
      function Zo() {
        Bi(window, "dragstart", _s);
      }
      function sr() {
        Cn(window, "dragstart", _s);
      }
      var ca, Ra;
      function ki(p) {
        for (; p.tabIndex === -1; )
          p = p.parentNode;
        p.style && (Gl(), ca = p, Ra = p.style.outlineStyle, p.style.outlineStyle = "none", Bi(window, "keydown", Gl));
      }
      function Gl() {
        ca && (ca.style.outlineStyle = Ra, ca = void 0, Ra = void 0, Cn(window, "keydown", Gl));
      }
      function ei(p) {
        do
          p = p.parentNode;
        while ((!p.offsetWidth || !p.offsetHeight) && p !== document.body);
        return p;
      }
      function ul(p) {
        var P = p.getBoundingClientRect();
        return {
          x: P.width / p.offsetWidth || 1,
          y: P.height / p.offsetHeight || 1,
          boundingClientRect: P
        };
      }
      var Oi = {
        __proto__: null,
        TRANSFORM: Er,
        TRANSITION: oa,
        TRANSITION_END: cl,
        get: Uo,
        getStyle: jo,
        create: tn,
        remove: xn,
        empty: no,
        toFront: Go,
        toBack: aa,
        hasClass: Da,
        addClass: Vi,
        removeClass: Hn,
        setClass: hl,
        getClass: Zs,
        setOpacity: Qn,
        testProp: nr,
        setTransform: Ks,
        setPosition: Yn,
        getPosition: $r,
        get disableTextSelection() {
          return Pr;
        },
        get enableTextSelection() {
          return Cr;
        },
        disableImageDrag: Zo,
        enableImageDrag: sr,
        preventOutline: ki,
        restoreOutline: Gl,
        getSizedParentNode: ei,
        getScale: ul
      };
      function Bi(p, P, B, X) {
        if (P && typeof P == "object")
          for (var ne in P)
            Fi(p, ne, P[ne], B);
        else {
          P = Te(P);
          for (var ye = 0, We = P.length; ye < We; ye++)
            Fi(p, P[ye], B, X);
        }
        return this;
      }
      var ns = "_leaflet_events";
      function Cn(p, P, B, X) {
        if (arguments.length === 1)
          ha(p), delete p[ns];
        else if (P && typeof P == "object")
          for (var ne in P)
            Li(p, ne, P[ne], B);
        else if (P = Te(P), arguments.length === 2)
          ha(p, function(at) {
            return ht(P, at) !== -1;
          });
        else
          for (var ye = 0, We = P.length; ye < We; ye++)
            Li(p, P[ye], B, X);
        return this;
      }
      function ha(p, P) {
        for (var B in p[ns]) {
          var X = B.split(/\d/)[0];
          (!P || P(X)) && Li(p, X, null, null, B);
        }
      }
      var Ot = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function Fi(p, P, B, X) {
        var ne = P + O(B) + (X ? "_" + O(X) : "");
        if (p[ns] && p[ns][ne])
          return this;
        var ye = function(at) {
          return B.call(X || p, at || window.event);
        }, We = ye;
        !Ae.touchNative && Ae.pointer && P.indexOf("touch") === 0 ? ye = li(p, P, ye) : Ae.touch && P === "dblclick" ? ye = vs(p, ye) : "addEventListener" in p ? P === "touchstart" || P === "touchmove" || P === "wheel" || P === "mousewheel" ? p.addEventListener(Ot[P] || P, ye, Ae.passiveEvents ? { passive: !1 } : !1) : P === "mouseenter" || P === "mouseleave" ? (ye = function(at) {
          at = at || window.event, ua(p, at) && We(at);
        }, p.addEventListener(Ot[P], ye, !1)) : p.addEventListener(P, We, !1) : p.attachEvent("on" + P, ye), p[ns] = p[ns] || {}, p[ns][ne] = ye;
      }
      function Li(p, P, B, X, ne) {
        ne = ne || P + O(B) + (X ? "_" + O(X) : "");
        var ye = p[ns] && p[ns][ne];
        if (!ye)
          return this;
        !Ae.touchNative && Ae.pointer && P.indexOf("touch") === 0 ? ri(p, P, ye) : Ae.touch && P === "dblclick" ? ra(p, ye) : "removeEventListener" in p ? p.removeEventListener(Ot[P] || P, ye, !1) : p.detachEvent("on" + P, ye), p[ns][ne] = null;
      }
      function ms(p) {
        return p.stopPropagation ? p.stopPropagation() : p.originalEvent ? p.originalEvent._stopped = !0 : p.cancelBubble = !0, this;
      }
      function bo(p) {
        return Fi(p, "wheel", ms), this;
      }
      function Ai(p) {
        return Bi(p, "mousedown touchstart dblclick contextmenu", ms), p._leaflet_disable_click = !0, this;
      }
      function _s(p) {
        return p.preventDefault ? p.preventDefault() : p.returnValue = !1, this;
      }
      function Js(p) {
        return _s(p), ms(p), this;
      }
      function Ho(p) {
        if (p.composedPath)
          return p.composedPath();
        for (var P = [], B = p.target; B; )
          P.push(B), B = B.parentNode;
        return P;
      }
      function Ss(p, P) {
        if (!P)
          return new fi(p.clientX, p.clientY);
        var B = ul(P), X = B.boundingClientRect;
        return new fi(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (p.clientX - X.left) / B.x - P.clientLeft,
          (p.clientY - X.top) / B.y - P.clientTop
        );
      }
      var un = Ae.linux && Ae.chrome ? window.devicePixelRatio : Ae.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function Bc(p) {
        return Ae.edge ? p.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          p.deltaY && p.deltaMode === 0 ? -p.deltaY / un : (
            // Pixels
            p.deltaY && p.deltaMode === 1 ? -p.deltaY * 20 : (
              // Lines
              p.deltaY && p.deltaMode === 2 ? -p.deltaY * 60 : (
                // Pages
                p.deltaX || p.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  p.wheelDelta ? (p.wheelDeltaY || p.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    p.detail && Math.abs(p.detail) < 32765 ? -p.detail * 20 : (
                      // Legacy Moz lines
                      p.detail ? p.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function ua(p, P) {
        var B = P.relatedTarget;
        if (!B)
          return !0;
        try {
          for (; B && B !== p; )
            B = B.parentNode;
        } catch {
          return !1;
        }
        return B !== p;
      }
      var Zl = {
        __proto__: null,
        on: Bi,
        off: Cn,
        stopPropagation: ms,
        disableScrollPropagation: bo,
        disableClickPropagation: Ai,
        preventDefault: _s,
        stop: Js,
        getPropagationPath: Ho,
        getMousePosition: Ss,
        getWheelDelta: Bc,
        isExternalTarget: ua,
        addListener: Bi,
        removeListener: Cn
      }, da = Ji.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(p, P, B, X) {
          this.stop(), this._el = p, this._inProgress = !0, this._duration = B || 0.25, this._easeOutPower = 1 / Math.max(X || 0.5, 0.2), this._startPos = $r(p), this._offset = P.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          this._inProgress && (this._step(!0), this._complete());
        },
        _animate: function() {
          this._animId = At(this._animate, this), this._step();
        },
        _step: function(p) {
          var P = +/* @__PURE__ */ new Date() - this._startTime, B = this._duration * 1e3;
          P < B ? this._runFrame(this._easeOut(P / B), p) : (this._runFrame(1), this._complete());
        },
        _runFrame: function(p, P) {
          var B = this._startPos.add(this._offset.multiplyBy(p));
          P && B._round(), Yn(this._el, B), this.fire("step");
        },
        _complete: function() {
          Mi(this._animId), this._inProgress = !1, this.fire("end");
        },
        _easeOut: function(p) {
          return 1 - Math.pow(1 - p, this._easeOutPower);
        }
      }), nn = Ji.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: Zr,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: !0,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: !0,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: !0,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: !0
        },
        initialize: function(p, P) {
          P = be(this, P), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(p), this._initLayout(), this._onResize = E(this._onResize, this), this._initEvents(), P.maxBounds && this.setMaxBounds(P.maxBounds), P.zoom !== void 0 && (this._zoom = this._limitZoom(P.zoom)), P.center && P.zoom !== void 0 && this.setView(xi(P.center), P.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = oa && Ae.any3d && !Ae.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Bi(this._proxy, cl, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(p, P, B) {
          if (P = P === void 0 ? this._zoom : this._limitZoom(P), p = this._limitCenter(xi(p), P, this.options.maxBounds), B = B || {}, this._stop(), this._loaded && !B.reset && B !== !0) {
            B.animate !== void 0 && (B.zoom = w({ animate: B.animate }, B.zoom), B.pan = w({ animate: B.animate, duration: B.duration }, B.pan));
            var X = this._zoom !== P ? this._tryAnimatedZoom && this._tryAnimatedZoom(p, P, B.zoom) : this._tryAnimatedPan(p, B.pan);
            if (X)
              return clearTimeout(this._sizeTimer), this;
          }
          return this._resetView(p, P, B.pan && B.pan.noMoveStart), this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(p, P) {
          return this._loaded ? this.setView(this.getCenter(), p, { zoom: P }) : (this._zoom = p, this);
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(p, P) {
          return p = p || (Ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + p, P);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(p, P) {
          return p = p || (Ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - p, P);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(p, P, B) {
          var X = this.getZoomScale(P), ne = this.getSize().divideBy(2), ye = p instanceof fi ? p : this.latLngToContainerPoint(p), We = ye.subtract(ne).multiplyBy(1 - 1 / X), at = this.containerPointToLatLng(ne.add(We));
          return this.setView(at, P, { zoom: B });
        },
        _getBoundsCenterZoom: function(p, P) {
          P = P || {}, p = p.getBounds ? p.getBounds() : ln(p);
          var B = ni(P.paddingTopLeft || P.padding || [0, 0]), X = ni(P.paddingBottomRight || P.padding || [0, 0]), ne = this.getBoundsZoom(p, !1, B.add(X));
          if (ne = typeof P.maxZoom == "number" ? Math.min(P.maxZoom, ne) : ne, ne === 1 / 0)
            return {
              center: p.getCenter(),
              zoom: ne
            };
          var ye = X.subtract(B).divideBy(2), We = this.project(p.getSouthWest(), ne), at = this.project(p.getNorthEast(), ne), ft = this.unproject(We.add(at).divideBy(2).add(ye), ne);
          return {
            center: ft,
            zoom: ne
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(p, P) {
          if (p = ln(p), !p.isValid())
            throw new Error("Bounds are not valid.");
          var B = this._getBoundsCenterZoom(p, P);
          return this.setView(B.center, B.zoom, P);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(p) {
          return this.fitBounds([[-90, -180], [90, 180]], p);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(p, P) {
          return this.setView(p, this._zoom, { pan: P });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(p, P) {
          if (p = ni(p).round(), P = P || {}, !p.x && !p.y)
            return this.fire("moveend");
          if (P.animate !== !0 && !this.getSize().contains(p))
            return this._resetView(this.unproject(this.project(this.getCenter()).add(p)), this.getZoom()), this;
          if (this._panAnim || (this._panAnim = new da(), this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), P.noMoveStart || this.fire("movestart"), P.animate !== !1) {
            Vi(this._mapPane, "leaflet-pan-anim");
            var B = this._getMapPanePos().subtract(p).round();
            this._panAnim.run(this._mapPane, B, P.duration || 0.25, P.easeLinearity);
          } else
            this._rawPanBy(p), this.fire("move").fire("moveend");
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(p, P, B) {
          if (B = B || {}, B.animate === !1 || !Ae.any3d)
            return this.setView(p, P, B);
          this._stop();
          var X = this.project(this.getCenter()), ne = this.project(p), ye = this.getSize(), We = this._zoom;
          p = xi(p), P = P === void 0 ? We : P;
          var at = Math.max(ye.x, ye.y), ft = at * this.getZoomScale(We, P), Rt = ne.distanceTo(X) || 1, ii = 1.42, Ci = ii * ii;
          function Wi(es) {
            var Po = es ? -1 : 1, Yh = es ? ft : at, Kh = ft * ft - at * at + Po * Ci * Ci * Rt * Rt, Yc = 2 * Yh * Ci * Rt, Ha = Kh / Yc, vr = Math.sqrt(Ha * Ha + 1) - Ha, Kc = vr < 1e-9 ? -18 : Math.log(vr);
            return Kc;
          }
          function Hs(es) {
            return (Math.exp(es) - Math.exp(-es)) / 2;
          }
          function ws(es) {
            return (Math.exp(es) + Math.exp(-es)) / 2;
          }
          function Rs(es) {
            return Hs(es) / ws(es);
          }
          var ur = Wi(0);
          function Za(es) {
            return at * (ws(ur) / ws(ur + ii * es));
          }
          function nd(es) {
            return at * (ws(ur) * Rs(ur + ii * es) - Hs(ur)) / Ci;
          }
          function sd(es) {
            return 1 - Math.pow(1 - es, 1.5);
          }
          var rd = Date.now(), Xh = (Wi(1) - ur) / ii, wl = B.duration ? 1e3 * B.duration : 1e3 * Xh * 0.8;
          function ic() {
            var es = (Date.now() - rd) / wl, Po = sd(es) * Xh;
            es <= 1 ? (this._flyToFrame = At(ic, this), this._move(
              this.unproject(X.add(ne.subtract(X).multiplyBy(nd(Po) / Rt)), We),
              this.getScaleZoom(at / Za(Po), We),
              { flyTo: !0 }
            )) : this._move(p, P)._moveEnd(!0);
          }
          return this._moveStart(!0, B.noMoveStart), ic.call(this), this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(p, P) {
          var B = this._getBoundsCenterZoom(p, P);
          return this.flyTo(B.center, B.zoom, P);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(p) {
          return p = ln(p), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), p.isValid() ? (this.options.maxBounds = p, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(p) {
          var P = this.options.minZoom;
          return this.options.minZoom = p, this._loaded && P !== p && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(p) : this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(p) {
          var P = this.options.maxZoom;
          return this.options.maxZoom = p, this._loaded && P !== p && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(p) : this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(p, P) {
          this._enforcingBounds = !0;
          var B = this.getCenter(), X = this._limitCenter(B, this._zoom, ln(p));
          return B.equals(X) || this.panTo(X, P), this._enforcingBounds = !1, this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(p, P) {
          P = P || {};
          var B = ni(P.paddingTopLeft || P.padding || [0, 0]), X = ni(P.paddingBottomRight || P.padding || [0, 0]), ne = this.project(this.getCenter()), ye = this.project(p), We = this.getPixelBounds(), at = an([We.min.add(B), We.max.subtract(X)]), ft = at.getSize();
          if (!at.contains(ye)) {
            this._enforcingBounds = !0;
            var Rt = ye.subtract(at.getCenter()), ii = at.extend(ye).getSize().subtract(ft);
            ne.x += Rt.x < 0 ? -ii.x : ii.x, ne.y += Rt.y < 0 ? -ii.y : ii.y, this.panTo(this.unproject(ne), P), this._enforcingBounds = !1;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so 
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(p) {
          if (!this._loaded)
            return this;
          p = w({
            animate: !1,
            pan: !0
          }, p === !0 ? { animate: !0 } : p);
          var P = this.getSize();
          this._sizeChanged = !0, this._lastCenter = null;
          var B = this.getSize(), X = P.divideBy(2).round(), ne = B.divideBy(2).round(), ye = X.subtract(ne);
          return !ye.x && !ye.y ? this : (p.animate && p.pan ? this.panBy(ye) : (p.pan && this._rawPanBy(ye), this.fire("move"), p.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(E(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
            oldSize: P,
            newSize: B
          }));
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(p) {
          if (p = this._locateOptions = w({
            timeout: 1e4,
            watch: !1
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, p), !("geolocation" in navigator))
            return this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          var P = E(this._handleGeolocationResponse, this), B = E(this._handleGeolocationError, this);
          return p.watch ? this._locationWatchId = navigator.geolocation.watchPosition(P, B, p) : navigator.geolocation.getCurrentPosition(P, B, p), this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
        },
        _handleGeolocationError: function(p) {
          if (this._container._leaflet_id) {
            var P = p.code, B = p.message || (P === 1 ? "permission denied" : P === 2 ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
              code: P,
              message: "Geolocation error: " + B + "."
            });
          }
        },
        _handleGeolocationResponse: function(p) {
          if (this._container._leaflet_id) {
            var P = p.coords.latitude, B = p.coords.longitude, X = new Di(P, B), ne = X.toBounds(p.coords.accuracy * 2), ye = this._locateOptions;
            if (ye.setView) {
              var We = this.getBoundsZoom(ne);
              this.setView(X, ye.maxZoom ? Math.min(We, ye.maxZoom) : We);
            }
            var at = {
              latlng: X,
              bounds: ne,
              timestamp: p.timestamp
            };
            for (var ft in p.coords)
              typeof p.coords[ft] == "number" && (at[ft] = p.coords[ft]);
            this.fire("locationfound", at);
          }
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(p, P) {
          if (!P)
            return this;
          var B = this[p] = new P(this);
          return this._handlers.push(B), this.options[p] && B.enable(), this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
            throw new Error("Map container is being reused by another instance");
          try {
            delete this._container._leaflet_id, delete this._containerId;
          } catch {
            this._container._leaflet_id = void 0, this._containerId = void 0;
          }
          this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), xn(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (Mi(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
          var p;
          for (p in this._layers)
            this._layers[p].remove();
          for (p in this._panes)
            xn(this._panes[p]);
          return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(p, P) {
          var B = "leaflet-pane" + (p ? " leaflet-" + p.replace("Pane", "") + "-pane" : ""), X = tn("div", B, P || this._mapPane);
          return p && (this._panes[p] = X), X;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var p = this.getPixelBounds(), P = this.unproject(p.getBottomLeft()), B = this.unproject(p.getTopRight());
          return new qt(P, B);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(p, P, B) {
          p = ln(p), B = ni(B || [0, 0]);
          var X = this.getZoom() || 0, ne = this.getMinZoom(), ye = this.getMaxZoom(), We = p.getNorthWest(), at = p.getSouthEast(), ft = this.getSize().subtract(B), Rt = an(this.project(at, X), this.project(We, X)).getSize(), ii = Ae.any3d ? this.options.zoomSnap : 1, Ci = ft.x / Rt.x, Wi = ft.y / Rt.y, Hs = P ? Math.max(Ci, Wi) : Math.min(Ci, Wi);
          return X = this.getScaleZoom(Hs, X), ii && (X = Math.round(X / (ii / 100)) * (ii / 100), X = P ? Math.ceil(X / ii) * ii : Math.floor(X / ii) * ii), Math.max(ne, Math.min(ye, X));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          return (!this._size || this._sizeChanged) && (this._size = new fi(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          ), this._sizeChanged = !1), this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(p, P) {
          var B = this._getTopLeftPoint(p, P);
          return new Gi(B, B.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          return this._checkIfLoaded(), this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(p) {
          return this.options.crs.getProjectedBounds(p === void 0 ? this.getZoom() : p);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(p) {
          return typeof p == "string" ? this._panes[p] : p;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(p, P) {
          var B = this.options.crs;
          return P = P === void 0 ? this._zoom : P, B.scale(p) / B.scale(P);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(p, P) {
          var B = this.options.crs;
          P = P === void 0 ? this._zoom : P;
          var X = B.zoom(p * B.scale(P));
          return isNaN(X) ? 1 / 0 : X;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(p, P) {
          return P = P === void 0 ? this._zoom : P, this.options.crs.latLngToPoint(xi(p), P);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(p, P) {
          return P = P === void 0 ? this._zoom : P, this.options.crs.pointToLatLng(ni(p), P);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(p) {
          var P = ni(p).add(this.getPixelOrigin());
          return this.unproject(P);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(p) {
          var P = this.project(xi(p))._round();
          return P._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(p) {
          return this.options.crs.wrapLatLng(xi(p));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(p) {
          return this.options.crs.wrapLatLngBounds(ln(p));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(p, P) {
          return this.options.crs.distance(xi(p), xi(P));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(p) {
          return ni(p).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(p) {
          return ni(p).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(p) {
          var P = this.containerPointToLayerPoint(ni(p));
          return this.layerPointToLatLng(P);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(p) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(xi(p)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(p) {
          return Ss(p, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(p) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(p));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(p) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(p));
        },
        // map initialization methods
        _initContainer: function(p) {
          var P = this._container = Uo(p);
          if (P) {
            if (P._leaflet_id)
              throw new Error("Map container is already initialized.");
          } else
            throw new Error("Map container not found.");
          Bi(P, "scroll", this._onScroll, this), this._containerId = O(P);
        },
        _initLayout: function() {
          var p = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Ae.any3d, Vi(p, "leaflet-container" + (Ae.touch ? " leaflet-touch" : "") + (Ae.retina ? " leaflet-retina" : "") + (Ae.ielt9 ? " leaflet-oldie" : "") + (Ae.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var P = jo(p, "position");
          P !== "absolute" && P !== "relative" && P !== "fixed" && P !== "sticky" && (p.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
        },
        _initPanes: function() {
          var p = this._panes = {};
          this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Yn(this._mapPane, new fi(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (Vi(p.markerPane, "leaflet-zoom-hide"), Vi(p.shadowPane, "leaflet-zoom-hide"));
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(p, P, B) {
          Yn(this._mapPane, new fi(0, 0));
          var X = !this._loaded;
          this._loaded = !0, P = this._limitZoom(P), this.fire("viewprereset");
          var ne = this._zoom !== P;
          this._moveStart(ne, B)._move(p, P)._moveEnd(ne), this.fire("viewreset"), X && this.fire("load");
        },
        _moveStart: function(p, P) {
          return p && this.fire("zoomstart"), P || this.fire("movestart"), this;
        },
        _move: function(p, P, B, X) {
          P === void 0 && (P = this._zoom);
          var ne = this._zoom !== P;
          return this._zoom = P, this._lastCenter = p, this._pixelOrigin = this._getNewPixelOrigin(p), X ? B && B.pinch && this.fire("zoom", B) : ((ne || B && B.pinch) && this.fire("zoom", B), this.fire("move", B)), this;
        },
        _moveEnd: function(p) {
          return p && this.fire("zoomend"), this.fire("moveend");
        },
        _stop: function() {
          return Mi(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
        },
        _rawPanBy: function(p) {
          Yn(this._mapPane, this._getMapPanePos().subtract(p));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
          if (!this._loaded)
            throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(p) {
          this._targets = {}, this._targets[O(this._container)] = this;
          var P = p ? Cn : Bi;
          P(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && P(window, "resize", this._onResize, this), Ae.any3d && this.options.transform3DLimit && (p ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function() {
          Mi(this._resizeRequest), this._resizeRequest = At(
            function() {
              this.invalidateSize({ debounceMoveend: !0 });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0, this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var p = this._getMapPanePos();
          Math.max(Math.abs(p.x), Math.abs(p.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function(p, P) {
          for (var B = [], X, ne = P === "mouseout" || P === "mouseover", ye = p.target || p.srcElement, We = !1; ye; ) {
            if (X = this._targets[O(ye)], X && (P === "click" || P === "preclick") && this._draggableMoved(X)) {
              We = !0;
              break;
            }
            if (X && X.listens(P, !0) && (ne && !ua(ye, p) || (B.push(X), ne)) || ye === this._container)
              break;
            ye = ye.parentNode;
          }
          return !B.length && !We && !ne && this.listens(P, !0) && (B = [this]), B;
        },
        _isClickDisabled: function(p) {
          for (; p && p !== this._container; ) {
            if (p._leaflet_disable_click)
              return !0;
            p = p.parentNode;
          }
        },
        _handleDOMEvent: function(p) {
          var P = p.target || p.srcElement;
          if (!(!this._loaded || P._leaflet_disable_events || p.type === "click" && this._isClickDisabled(P))) {
            var B = p.type;
            B === "mousedown" && ki(P), this._fireDOMEvent(p, B);
          }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(p, P, B) {
          if (p.type === "click") {
            var X = w({}, p);
            X.type = "preclick", this._fireDOMEvent(X, X.type, B);
          }
          var ne = this._findEventTargets(p, P);
          if (B) {
            for (var ye = [], We = 0; We < B.length; We++)
              B[We].listens(P, !0) && ye.push(B[We]);
            ne = ye.concat(ne);
          }
          if (ne.length) {
            P === "contextmenu" && _s(p);
            var at = ne[0], ft = {
              originalEvent: p
            };
            if (p.type !== "keypress" && p.type !== "keydown" && p.type !== "keyup") {
              var Rt = at.getLatLng && (!at._radius || at._radius <= 10);
              ft.containerPoint = Rt ? this.latLngToContainerPoint(at.getLatLng()) : this.mouseEventToContainerPoint(p), ft.layerPoint = this.containerPointToLayerPoint(ft.containerPoint), ft.latlng = Rt ? at.getLatLng() : this.layerPointToLatLng(ft.layerPoint);
            }
            for (We = 0; We < ne.length; We++)
              if (ne[We].fire(P, ft, !0), ft.originalEvent._stopped || ne[We].options.bubblingMouseEvents === !1 && ht(this._mouseEvents, P) !== -1)
                return;
          }
        },
        _draggableMoved: function(p) {
          return p = p.dragging && p.dragging.enabled() ? p : this, p.dragging && p.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var p = 0, P = this._handlers.length; p < P; p++)
            this._handlers[p].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(p, P) {
          return this._loaded ? p.call(P || this, { target: this }) : this.on("load", p, P), this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return $r(this._mapPane) || new fi(0, 0);
        },
        _moved: function() {
          var p = this._getMapPanePos();
          return p && !p.equals([0, 0]);
        },
        _getTopLeftPoint: function(p, P) {
          var B = p && P !== void 0 ? this._getNewPixelOrigin(p, P) : this.getPixelOrigin();
          return B.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(p, P) {
          var B = this.getSize()._divideBy(2);
          return this.project(p, P)._subtract(B)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(p, P, B) {
          var X = this._getNewPixelOrigin(B, P);
          return this.project(p, P)._subtract(X);
        },
        _latLngBoundsToNewLayerBounds: function(p, P, B) {
          var X = this._getNewPixelOrigin(B, P);
          return an([
            this.project(p.getSouthWest(), P)._subtract(X),
            this.project(p.getNorthWest(), P)._subtract(X),
            this.project(p.getSouthEast(), P)._subtract(X),
            this.project(p.getNorthEast(), P)._subtract(X)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(p) {
          return this.latLngToLayerPoint(p).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(p, P, B) {
          if (!B)
            return p;
          var X = this.project(p, P), ne = this.getSize().divideBy(2), ye = new Gi(X.subtract(ne), X.add(ne)), We = this._getBoundsOffset(ye, B, P);
          return Math.abs(We.x) <= 1 && Math.abs(We.y) <= 1 ? p : this.unproject(X.add(We), P);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(p, P) {
          if (!P)
            return p;
          var B = this.getPixelBounds(), X = new Gi(B.min.add(p), B.max.add(p));
          return p.add(this._getBoundsOffset(X, P));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(p, P, B) {
          var X = an(
            this.project(P.getNorthEast(), B),
            this.project(P.getSouthWest(), B)
          ), ne = X.min.subtract(p.min), ye = X.max.subtract(p.max), We = this._rebound(ne.x, -ye.x), at = this._rebound(ne.y, -ye.y);
          return new fi(We, at);
        },
        _rebound: function(p, P) {
          return p + P > 0 ? Math.round(p - P) / 2 : Math.max(0, Math.ceil(p)) - Math.max(0, Math.floor(P));
        },
        _limitZoom: function(p) {
          var P = this.getMinZoom(), B = this.getMaxZoom(), X = Ae.any3d ? this.options.zoomSnap : 1;
          return X && (p = Math.round(p / X) * X), Math.max(P, Math.min(B, p));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          Hn(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
        },
        _tryAnimatedPan: function(p, P) {
          var B = this._getCenterOffset(p)._trunc();
          return (P && P.animate) !== !0 && !this.getSize().contains(B) ? !1 : (this.panBy(B, P), !0);
        },
        _createAnimProxy: function() {
          var p = this._proxy = tn("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(p), this.on("zoomanim", function(P) {
            var B = Er, X = this._proxy.style[B];
            Ks(this._proxy, this.project(P.center, P.zoom), this.getZoomScale(P.zoom, 1)), X === this._proxy.style[B] && this._animatingZoom && this._onZoomTransitionEnd();
          }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          xn(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
        },
        _animMoveEnd: function() {
          var p = this.getCenter(), P = this.getZoom();
          Ks(this._proxy, this.project(p, P), this.getZoomScale(P, 1));
        },
        _catchTransitionEnd: function(p) {
          this._animatingZoom && p.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(p, P, B) {
          if (this._animatingZoom)
            return !0;
          if (B = B || {}, !this._zoomAnimated || B.animate === !1 || this._nothingToAnimate() || Math.abs(P - this._zoom) > this.options.zoomAnimationThreshold)
            return !1;
          var X = this.getZoomScale(P), ne = this._getCenterOffset(p)._divideBy(1 - 1 / X);
          return B.animate !== !0 && !this.getSize().contains(ne) ? !1 : (At(function() {
            this._moveStart(!0, B.noMoveStart || !1)._animateZoom(p, P, !0);
          }, this), !0);
        },
        _animateZoom: function(p, P, B, X) {
          this._mapPane && (B && (this._animatingZoom = !0, this._animateToCenter = p, this._animateToZoom = P, Vi(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
            center: p,
            zoom: P,
            noUpdate: X
          }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(E(this._onZoomTransitionEnd, this), 250));
        },
        _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && Hn(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
        }
      });
      function dl(p, P) {
        return new nn(p, P);
      }
      var Dn = hn.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(p) {
          be(this, p);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(p) {
          var P = this._map;
          return P && P.removeControl(this), this.options.position = p, P && P.addControl(this), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(p) {
          this.remove(), this._map = p;
          var P = this._container = this.onAdd(p), B = this.getPosition(), X = p._controlCorners[B];
          return Vi(P, "leaflet-control"), B.indexOf("bottom") !== -1 ? X.insertBefore(P, X.firstChild) : X.appendChild(P), this._map.on("unload", this.remove, this), this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          return this._map ? (xn(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
        },
        _refocusOnMap: function(p) {
          this._map && p && p.screenX > 0 && p.screenY > 0 && this._map.getContainer().focus();
        }
      }), rr = function(p) {
        return new Dn(p);
      };
      nn.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(p) {
          return p.addTo(this), this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(p) {
          return p.remove(), this;
        },
        _initControlPos: function() {
          var p = this._controlCorners = {}, P = "leaflet-", B = this._controlContainer = tn("div", P + "control-container", this._container);
          function X(ne, ye) {
            var We = P + ne + " " + P + ye;
            p[ne + ye] = tn("div", We, B);
          }
          X("top", "left"), X("top", "right"), X("bottom", "left"), X("bottom", "right");
        },
        _clearControlPos: function() {
          for (var p in this._controlCorners)
            xn(this._controlCorners[p]);
          xn(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
        }
      });
      var ss = Dn.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: !0,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: !0,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: !1,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: !1,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(p, P, B, X) {
            return B < X ? -1 : X < B ? 1 : 0;
          }
        },
        initialize: function(p, P, B) {
          be(this, B), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
          for (var X in p)
            this._addLayer(p[X], X);
          for (X in P)
            this._addLayer(P[X], X, !0);
        },
        onAdd: function(p) {
          this._initLayout(), this._update(), this._map = p, p.on("zoomend", this._checkDisabledLayers, this);
          for (var P = 0; P < this._layers.length; P++)
            this._layers[P].layer.on("add remove", this._onLayerChange, this);
          return this._container;
        },
        addTo: function(p) {
          return Dn.prototype.addTo.call(this, p), this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var p = 0; p < this._layers.length; p++)
            this._layers[p].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(p, P) {
          return this._addLayer(p, P), this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(p, P) {
          return this._addLayer(p, P, !0), this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(p) {
          p.off("add remove", this._onLayerChange, this);
          var P = this._getLayer(O(p));
          return P && this._layers.splice(this._layers.indexOf(P), 1), this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          Vi(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
          var p = this._map.getSize().y - (this._container.offsetTop + 50);
          return p < this._section.clientHeight ? (Vi(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = p + "px") : Hn(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          return Hn(this._container, "leaflet-control-layers-expanded"), this;
        },
        _initLayout: function() {
          var p = "leaflet-control-layers", P = this._container = tn("div", p), B = this.options.collapsed;
          P.setAttribute("aria-haspopup", !0), Ai(P), bo(P);
          var X = this._section = tn("section", p + "-list");
          B && (this._map.on("click", this.collapse, this), Bi(P, {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse
          }, this));
          var ne = this._layersLink = tn("a", p + "-toggle", P);
          ne.href = "#", ne.title = "Layers", ne.setAttribute("role", "button"), Bi(ne, {
            keydown: function(ye) {
              ye.keyCode === 13 && this._expandSafely();
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(ye) {
              _s(ye), this._expandSafely();
            }
          }, this), B || this.expand(), this._baseLayersList = tn("div", p + "-base", X), this._separator = tn("div", p + "-separator", X), this._overlaysList = tn("div", p + "-overlays", X), P.appendChild(X);
        },
        _getLayer: function(p) {
          for (var P = 0; P < this._layers.length; P++)
            if (this._layers[P] && O(this._layers[P].layer) === p)
              return this._layers[P];
        },
        _addLayer: function(p, P, B) {
          this._map && p.on("add remove", this._onLayerChange, this), this._layers.push({
            layer: p,
            name: P,
            overlay: B
          }), this.options.sortLayers && this._layers.sort(E(function(X, ne) {
            return this.options.sortFunction(X.layer, ne.layer, X.name, ne.name);
          }, this)), this.options.autoZIndex && p.setZIndex && (this._lastZIndex++, p.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container)
            return this;
          no(this._baseLayersList), no(this._overlaysList), this._layerControlInputs = [];
          var p, P, B, X, ne = 0;
          for (B = 0; B < this._layers.length; B++)
            X = this._layers[B], this._addItem(X), P = P || X.overlay, p = p || !X.overlay, ne += X.overlay ? 0 : 1;
          return this.options.hideSingleBase && (p = p && ne > 1, this._baseLayersList.style.display = p ? "" : "none"), this._separator.style.display = P && p ? "" : "none", this;
        },
        _onLayerChange: function(p) {
          this._handlingClick || this._update();
          var P = this._getLayer(O(p.target)), B = P.overlay ? p.type === "add" ? "overlayadd" : "overlayremove" : p.type === "add" ? "baselayerchange" : null;
          B && this._map.fire(B, P);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(p, P) {
          var B = '<input type="radio" class="leaflet-control-layers-selector" name="' + p + '"' + (P ? ' checked="checked"' : "") + "/>", X = document.createElement("div");
          return X.innerHTML = B, X.firstChild;
        },
        _addItem: function(p) {
          var P = document.createElement("label"), B = this._map.hasLayer(p.layer), X;
          p.overlay ? (X = document.createElement("input"), X.type = "checkbox", X.className = "leaflet-control-layers-selector", X.defaultChecked = B) : X = this._createRadioElement("leaflet-base-layers_" + O(this), B), this._layerControlInputs.push(X), X.layerId = O(p.layer), Bi(X, "click", this._onInputClick, this);
          var ne = document.createElement("span");
          ne.innerHTML = " " + p.name;
          var ye = document.createElement("span");
          P.appendChild(ye), ye.appendChild(X), ye.appendChild(ne);
          var We = p.overlay ? this._overlaysList : this._baseLayersList;
          return We.appendChild(P), this._checkDisabledLayers(), P;
        },
        _onInputClick: function() {
          if (!this._preventClick) {
            var p = this._layerControlInputs, P, B, X = [], ne = [];
            this._handlingClick = !0;
            for (var ye = p.length - 1; ye >= 0; ye--)
              P = p[ye], B = this._getLayer(P.layerId).layer, P.checked ? X.push(B) : P.checked || ne.push(B);
            for (ye = 0; ye < ne.length; ye++)
              this._map.hasLayer(ne[ye]) && this._map.removeLayer(ne[ye]);
            for (ye = 0; ye < X.length; ye++)
              this._map.hasLayer(X[ye]) || this._map.addLayer(X[ye]);
            this._handlingClick = !1, this._refocusOnMap();
          }
        },
        _checkDisabledLayers: function() {
          for (var p = this._layerControlInputs, P, B, X = this._map.getZoom(), ne = p.length - 1; ne >= 0; ne--)
            P = p[ne], B = this._getLayer(P.layerId).layer, P.disabled = B.options.minZoom !== void 0 && X < B.options.minZoom || B.options.maxZoom !== void 0 && X > B.options.maxZoom;
        },
        _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(), this;
        },
        _expandSafely: function() {
          var p = this._section;
          this._preventClick = !0, Bi(p, "click", _s), this.expand();
          var P = this;
          setTimeout(function() {
            Cn(p, "click", _s), P._preventClick = !1;
          });
        }
      }), fa = function(p, P, B) {
        return new ss(p, P, B);
      }, wo = Dn.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(p) {
          var P = "leaflet-control-zoom", B = tn("div", P + " leaflet-bar"), X = this.options;
          return this._zoomInButton = this._createButton(
            X.zoomInText,
            X.zoomInTitle,
            P + "-in",
            B,
            this._zoomIn
          ), this._zoomOutButton = this._createButton(
            X.zoomOutText,
            X.zoomOutTitle,
            P + "-out",
            B,
            this._zoomOut
          ), this._updateDisabled(), p.on("zoomend zoomlevelschange", this._updateDisabled, this), B;
        },
        onRemove: function(p) {
          p.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          return this._disabled = !0, this._updateDisabled(), this;
        },
        enable: function() {
          return this._disabled = !1, this._updateDisabled(), this;
        },
        _zoomIn: function(p) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (p.shiftKey ? 3 : 1));
        },
        _zoomOut: function(p) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (p.shiftKey ? 3 : 1));
        },
        _createButton: function(p, P, B, X, ne) {
          var ye = tn("a", B, X);
          return ye.innerHTML = p, ye.href = "#", ye.title = P, ye.setAttribute("role", "button"), ye.setAttribute("aria-label", P), Ai(ye), Bi(ye, "click", Js), Bi(ye, "click", ne, this), Bi(ye, "click", this._refocusOnMap, this), ye;
        },
        _updateDisabled: function() {
          var p = this._map, P = "leaflet-disabled";
          Hn(this._zoomInButton, P), Hn(this._zoomOutButton, P), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || p._zoom === p.getMinZoom()) && (Vi(this._zoomOutButton, P), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || p._zoom === p.getMaxZoom()) && (Vi(this._zoomInButton, P), this._zoomInButton.setAttribute("aria-disabled", "true"));
        }
      });
      nn.mergeOptions({
        zoomControl: !0
      }), nn.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new wo(), this.addControl(this.zoomControl));
      });
      var vn = function(p) {
        return new wo(p);
      }, Ir = Dn.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: !0,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: !0
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(p) {
          var P = "leaflet-control-scale", B = tn("div", P), X = this.options;
          return this._addScales(X, P + "-line", B), p.on(X.updateWhenIdle ? "moveend" : "move", this._update, this), p.whenReady(this._update, this), B;
        },
        onRemove: function(p) {
          p.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(p, P, B) {
          p.metric && (this._mScale = tn("div", P, B)), p.imperial && (this._iScale = tn("div", P, B));
        },
        _update: function() {
          var p = this._map, P = p.getSize().y / 2, B = p.distance(
            p.containerPointToLatLng([0, P]),
            p.containerPointToLatLng([this.options.maxWidth, P])
          );
          this._updateScales(B);
        },
        _updateScales: function(p) {
          this.options.metric && p && this._updateMetric(p), this.options.imperial && p && this._updateImperial(p);
        },
        _updateMetric: function(p) {
          var P = this._getRoundNum(p), B = P < 1e3 ? P + " m" : P / 1e3 + " km";
          this._updateScale(this._mScale, B, P / p);
        },
        _updateImperial: function(p) {
          var P = p * 3.2808399, B, X, ne;
          P > 5280 ? (B = P / 5280, X = this._getRoundNum(B), this._updateScale(this._iScale, X + " mi", X / B)) : (ne = this._getRoundNum(P), this._updateScale(this._iScale, ne + " ft", ne / P));
        },
        _updateScale: function(p, P, B) {
          p.style.width = Math.round(this.options.maxWidth * B) + "px", p.innerHTML = P;
        },
        _getRoundNum: function(p) {
          var P = Math.pow(10, (Math.floor(p) + "").length - 1), B = p / P;
          return B = B >= 10 ? 10 : B >= 5 ? 5 : B >= 3 ? 3 : B >= 2 ? 2 : 1, P * B;
        }
      }), Lr = function(p) {
        return new Ir(p);
      }, qn = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', pa = Dn.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Ae.inlineSvg ? qn + " " : "") + "Leaflet</a>"
        },
        initialize: function(p) {
          be(this, p), this._attributions = {};
        },
        onAdd: function(p) {
          p.attributionControl = this, this._container = tn("div", "leaflet-control-attribution"), Ai(this._container);
          for (var P in p._layers)
            p._layers[P].getAttribution && this.addAttribution(p._layers[P].getAttribution());
          return this._update(), p.on("layeradd", this._addAttribution, this), this._container;
        },
        onRemove: function(p) {
          p.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(p) {
          p.layer.getAttribution && (this.addAttribution(p.layer.getAttribution()), p.layer.once("remove", function() {
            this.removeAttribution(p.layer.getAttribution());
          }, this));
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(p) {
          return this.options.prefix = p, this._update(), this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(p) {
          return p ? (this._attributions[p] || (this._attributions[p] = 0), this._attributions[p]++, this._update(), this) : this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(p) {
          return p ? (this._attributions[p] && (this._attributions[p]--, this._update()), this) : this;
        },
        _update: function() {
          if (this._map) {
            var p = [];
            for (var P in this._attributions)
              this._attributions[P] && p.push(P);
            var B = [];
            this.options.prefix && B.push(this.options.prefix), p.length && B.push(p.join(", ")), this._container.innerHTML = B.join(' <span aria-hidden="true">|</span> ');
          }
        }
      });
      nn.mergeOptions({
        attributionControl: !0
      }), nn.addInitHook(function() {
        this.options.attributionControl && new pa().addTo(this);
      });
      var zr = function(p) {
        return new pa(p);
      };
      Dn.Layers = ss, Dn.Zoom = wo, Dn.Scale = Ir, Dn.Attribution = pa, rr.layers = fa, rr.zoom = vn, rr.scale = Lr, rr.attribution = zr;
      var Es = hn.extend({
        initialize: function(p) {
          this._map = p;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Es.addTo = function(p, P) {
        return p.addHandler(P, this), this;
      };
      var Oa = { Events: Si }, qo = Ae.touch ? "touchstart mousedown" : "mousedown", Wo = Ji.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(p, P, B, X) {
          be(this, X), this._element = p, this._dragStartTarget = P || p, this._preventOutline = B;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          this._enabled || (Bi(this._dragStartTarget, qo, this._onDown, this), this._enabled = !0);
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          this._enabled && (Wo._dragging === this && this.finishDrag(!0), Cn(this._dragStartTarget, qo, this._onDown, this), this._enabled = !1, this._moved = !1);
        },
        _onDown: function(p) {
          if (this._enabled && (this._moved = !1, !Da(this._element, "leaflet-zoom-anim"))) {
            if (p.touches && p.touches.length !== 1) {
              Wo._dragging === this && this.finishDrag();
              return;
            }
            if (!(Wo._dragging || p.shiftKey || p.which !== 1 && p.button !== 1 && !p.touches) && (Wo._dragging = this, this._preventOutline && ki(this._element), Zo(), Pr(), !this._moving)) {
              this.fire("down");
              var P = p.touches ? p.touches[0] : p, B = ei(this._element);
              this._startPoint = new fi(P.clientX, P.clientY), this._startPos = $r(this._element), this._parentScale = ul(B);
              var X = p.type === "mousedown";
              Bi(document, X ? "mousemove" : "touchmove", this._onMove, this), Bi(document, X ? "mouseup" : "touchend touchcancel", this._onUp, this);
            }
          }
        },
        _onMove: function(p) {
          if (this._enabled) {
            if (p.touches && p.touches.length > 1) {
              this._moved = !0;
              return;
            }
            var P = p.touches && p.touches.length === 1 ? p.touches[0] : p, B = new fi(P.clientX, P.clientY)._subtract(this._startPoint);
            !B.x && !B.y || Math.abs(B.x) + Math.abs(B.y) < this.options.clickTolerance || (B.x /= this._parentScale.x, B.y /= this._parentScale.y, _s(p), this._moved || (this.fire("dragstart"), this._moved = !0, Vi(document.body, "leaflet-dragging"), this._lastTarget = p.target || p.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), Vi(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(B), this._moving = !0, this._lastEvent = p, this._updatePosition());
          }
        },
        _updatePosition: function() {
          var p = { originalEvent: this._lastEvent };
          this.fire("predrag", p), Yn(this._element, this._newPos), this.fire("drag", p);
        },
        _onUp: function() {
          this._enabled && this.finishDrag();
        },
        finishDrag: function(p) {
          Hn(document.body, "leaflet-dragging"), this._lastTarget && (Hn(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Cn(document, "mousemove touchmove", this._onMove, this), Cn(document, "mouseup touchend touchcancel", this._onUp, this), sr(), Cr();
          var P = this._moved && this._moving;
          this._moving = !1, Wo._dragging = !1, P && this.fire("dragend", {
            noInertia: p,
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
      });
      function so(p, P, B) {
        var X, ne = [1, 4, 2, 8], ye, We, at, ft, Rt, ii, Ci, Wi;
        for (ye = 0, ii = p.length; ye < ii; ye++)
          p[ye]._code = Ds(p[ye], P);
        for (at = 0; at < 4; at++) {
          for (Ci = ne[at], X = [], ye = 0, ii = p.length, We = ii - 1; ye < ii; We = ye++)
            ft = p[ye], Rt = p[We], ft._code & Ci ? Rt._code & Ci || (Wi = _l(Rt, ft, Ci, P, B), Wi._code = Ds(Wi, P), X.push(Wi)) : (Rt._code & Ci && (Wi = _l(Rt, ft, Ci, P, B), Wi._code = Ds(Wi, P), X.push(Wi)), X.push(ft));
          p = X;
        }
        return p;
      }
      function Nc(p, P) {
        var B, X, ne, ye, We, at, ft, Rt, ii;
        if (!p || p.length === 0)
          throw new Error("latlngs not passed");
        rs(p) || (console.warn("latlngs are not flat! Only the first ring will be used"), p = p[0]);
        var Ci = xi([0, 0]), Wi = ln(p), Hs = Wi.getNorthWest().distanceTo(Wi.getSouthWest()) * Wi.getNorthEast().distanceTo(Wi.getNorthWest());
        Hs < 1700 && (Ci = Fa(p));
        var ws = p.length, Rs = [];
        for (B = 0; B < ws; B++) {
          var ur = xi(p[B]);
          Rs.push(P.project(xi([ur.lat - Ci.lat, ur.lng - Ci.lng])));
        }
        for (at = ft = Rt = 0, B = 0, X = ws - 1; B < ws; X = B++)
          ne = Rs[B], ye = Rs[X], We = ne.y * ye.x - ye.y * ne.x, ft += (ne.x + ye.x) * We, Rt += (ne.y + ye.y) * We, at += We * 3;
        at === 0 ? ii = Rs[0] : ii = [ft / at, Rt / at];
        var Za = P.unproject(ni(ii));
        return xi([Za.lat + Ci.lat, Za.lng + Ci.lng]);
      }
      function Fa(p) {
        for (var P = 0, B = 0, X = 0, ne = 0; ne < p.length; ne++) {
          var ye = xi(p[ne]);
          P += ye.lat, B += ye.lng, X++;
        }
        return xi([P / X, B / X]);
      }
      var or = {
        __proto__: null,
        clipPolygon: so,
        polygonCenter: Nc,
        centroid: Fa
      };
      function fl(p, P) {
        if (!P || !p.length)
          return p.slice();
        var B = P * P;
        return p = Qu(p, B), p = ml(p, B), p;
      }
      function pl(p, P, B) {
        return Math.sqrt($o(p, P, B, !0));
      }
      function Nh(p, P, B) {
        return $o(p, P, B);
      }
      function ml(p, P) {
        var B = p.length, X = typeof Uint8Array != void 0 + "" ? Uint8Array : Array, ne = new X(B);
        ne[0] = ne[B - 1] = 1, Vc(p, ne, P, 0, B - 1);
        var ye, We = [];
        for (ye = 0; ye < B; ye++)
          ne[ye] && We.push(p[ye]);
        return We;
      }
      function Vc(p, P, B, X, ne) {
        var ye = 0, We, at, ft;
        for (at = X + 1; at <= ne - 1; at++)
          ft = $o(p[at], p[X], p[ne], !0), ft > ye && (We = at, ye = ft);
        ye > B && (P[We] = 1, Vc(p, P, B, X, We), Vc(p, P, B, We, ne));
      }
      function Qu(p, P) {
        for (var B = [p[0]], X = 1, ne = 0, ye = p.length; X < ye; X++)
          Vh(p[X], p[ne]) > P && (B.push(p[X]), ne = X);
        return ne < ye - 1 && B.push(p[ye - 1]), B;
      }
      var Ba;
      function Na(p, P, B, X, ne) {
        var ye = X ? Ba : Ds(p, B), We = Ds(P, B), at, ft, Rt;
        for (Ba = We; ; ) {
          if (!(ye | We))
            return [p, P];
          if (ye & We)
            return !1;
          at = ye || We, ft = _l(p, P, at, B, ne), Rt = Ds(ft, B), at === ye ? (p = ft, ye = Rt) : (P = ft, We = Rt);
        }
      }
      function _l(p, P, B, X, ne) {
        var ye = P.x - p.x, We = P.y - p.y, at = X.min, ft = X.max, Rt, ii;
        return B & 8 ? (Rt = p.x + ye * (ft.y - p.y) / We, ii = ft.y) : B & 4 ? (Rt = p.x + ye * (at.y - p.y) / We, ii = at.y) : B & 2 ? (Rt = ft.x, ii = p.y + We * (ft.x - p.x) / ye) : B & 1 && (Rt = at.x, ii = p.y + We * (at.x - p.x) / ye), new fi(Rt, ii, ne);
      }
      function Ds(p, P) {
        var B = 0;
        return p.x < P.min.x ? B |= 1 : p.x > P.max.x && (B |= 2), p.y < P.min.y ? B |= 4 : p.y > P.max.y && (B |= 8), B;
      }
      function Vh(p, P) {
        var B = P.x - p.x, X = P.y - p.y;
        return B * B + X * X;
      }
      function $o(p, P, B, X) {
        var ne = P.x, ye = P.y, We = B.x - ne, at = B.y - ye, ft = We * We + at * at, Rt;
        return ft > 0 && (Rt = ((p.x - ne) * We + (p.y - ye) * at) / ft, Rt > 1 ? (ne = B.x, ye = B.y) : Rt > 0 && (ne += We * Rt, ye += at * Rt)), We = p.x - ne, at = p.y - ye, X ? We * We + at * at : new fi(ne, ye);
      }
      function rs(p) {
        return !vt(p[0]) || typeof p[0][0] != "object" && typeof p[0][0] < "u";
      }
      function Uh(p) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), rs(p);
      }
      function jh(p, P) {
        var B, X, ne, ye, We, at, ft, Rt;
        if (!p || p.length === 0)
          throw new Error("latlngs not passed");
        rs(p) || (console.warn("latlngs are not flat! Only the first ring will be used"), p = p[0]);
        var ii = xi([0, 0]), Ci = ln(p), Wi = Ci.getNorthWest().distanceTo(Ci.getSouthWest()) * Ci.getNorthEast().distanceTo(Ci.getNorthWest());
        Wi < 1700 && (ii = Fa(p));
        var Hs = p.length, ws = [];
        for (B = 0; B < Hs; B++) {
          var Rs = xi(p[B]);
          ws.push(P.project(xi([Rs.lat - ii.lat, Rs.lng - ii.lng])));
        }
        for (B = 0, X = 0; B < Hs - 1; B++)
          X += ws[B].distanceTo(ws[B + 1]) / 2;
        if (X === 0)
          Rt = ws[0];
        else
          for (B = 0, ye = 0; B < Hs - 1; B++)
            if (We = ws[B], at = ws[B + 1], ne = We.distanceTo(at), ye += ne, ye > X) {
              ft = (ye - X) / ne, Rt = [
                at.x - ft * (at.x - We.x),
                at.y - ft * (at.y - We.y)
              ];
              break;
            }
        var ur = P.unproject(ni(Rt));
        return xi([ur.lat + ii.lat, ur.lng + ii.lng]);
      }
      var ed = {
        __proto__: null,
        simplify: fl,
        pointToSegmentDistance: pl,
        closestPointOnSegment: Nh,
        clipSegment: Na,
        _getEdgeIntersection: _l,
        _getBitCode: Ds,
        _sqClosestPointOnSegment: $o,
        isFlat: rs,
        _flat: Uh,
        polylineCenter: jh
      }, Hl = {
        project: function(p) {
          return new fi(p.lng, p.lat);
        },
        unproject: function(p) {
          return new Di(p.y, p.x);
        },
        bounds: new Gi([-180, -90], [180, 90])
      }, Xo = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Gi([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(p) {
          var P = Math.PI / 180, B = this.R, X = p.lat * P, ne = this.R_MINOR / B, ye = Math.sqrt(1 - ne * ne), We = ye * Math.sin(X), at = Math.tan(Math.PI / 4 - X / 2) / Math.pow((1 - We) / (1 + We), ye / 2);
          return X = -B * Math.log(Math.max(at, 1e-10)), new fi(p.lng * P * B, X);
        },
        unproject: function(p) {
          for (var P = 180 / Math.PI, B = this.R, X = this.R_MINOR / B, ne = Math.sqrt(1 - X * X), ye = Math.exp(-p.y / B), We = Math.PI / 2 - 2 * Math.atan(ye), at = 0, ft = 0.1, Rt; at < 15 && Math.abs(ft) > 1e-7; at++)
            Rt = ne * Math.sin(We), Rt = Math.pow((1 - Rt) / (1 + Rt), ne / 2), ft = Math.PI / 2 - 2 * Math.atan(ye * Rt) - We, We += ft;
          return new Di(We * P, p.x * P / B);
        }
      }, bi = {
        __proto__: null,
        LonLat: Hl,
        Mercator: Xo,
        SphericalMercator: De
      }, Wt = w({}, xs, {
        code: "EPSG:3395",
        projection: Xo,
        transformation: function() {
          var p = 0.5 / (Math.PI * Xo.R);
          return Us(p, 0.5, -p, 0.5);
        }()
      }), gl = w({}, xs, {
        code: "EPSG:4326",
        projection: Hl,
        transformation: Us(1 / 180, 1, -1 / 180, 0.5)
      }), ci = w({}, Cs, {
        projection: Hl,
        transformation: Us(1, 0, -1, 0),
        scale: function(p) {
          return Math.pow(2, p);
        },
        zoom: function(p) {
          return Math.log(p) / Math.LN2;
        },
        distance: function(p, P) {
          var B = P.lng - p.lng, X = P.lat - p.lat;
          return Math.sqrt(B * B + X * X);
        },
        infinite: !0
      });
      Cs.Earth = xs, Cs.EPSG3395 = Wt, Cs.EPSG3857 = Zr, Cs.EPSG900913 = Et, Cs.EPSG4326 = gl, Cs.Simple = ci;
      var ar = Ji.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. " OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: !0
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(p) {
          return p.addLayer(this), this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(p) {
          return p && p.removeLayer(this), this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(p) {
          return this._map.getPane(p ? this.options[p] || p : this.options.pane);
        },
        addInteractiveTarget: function(p) {
          return this._map._targets[O(p)] = this, this;
        },
        removeInteractiveTarget: function(p) {
          return delete this._map._targets[O(p)], this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(p) {
          var P = p.target;
          if (P.hasLayer(this)) {
            if (this._map = P, this._zoomAnimated = P._zoomAnimated, this.getEvents) {
              var B = this.getEvents();
              P.on(B, this), this.once("remove", function() {
                P.off(B, this);
              }, this);
            }
            this.onAdd(P), this.fire("add"), P.fire("layeradd", { layer: this });
          }
        }
      });
      nn.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(p) {
          if (!p._layerAdd)
            throw new Error("The provided object is not a Layer.");
          var P = O(p);
          return this._layers[P] ? this : (this._layers[P] = p, p._mapToAdd = this, p.beforeAdd && p.beforeAdd(this), this.whenReady(p._layerAdd, p), this);
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(p) {
          var P = O(p);
          return this._layers[P] ? (this._loaded && p.onRemove(this), delete this._layers[P], this._loaded && (this.fire("layerremove", { layer: p }), p.fire("remove")), p._map = p._mapToAdd = null, this) : this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(p) {
          return O(p) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(p, P) {
          for (var B in this._layers)
            p.call(P, this._layers[B]);
          return this;
        },
        _addLayers: function(p) {
          p = p ? vt(p) ? p : [p] : [];
          for (var P = 0, B = p.length; P < B; P++)
            this.addLayer(p[P]);
        },
        _addZoomLimit: function(p) {
          (!isNaN(p.options.maxZoom) || !isNaN(p.options.minZoom)) && (this._zoomBoundLayers[O(p)] = p, this._updateZoomLevels());
        },
        _removeZoomLimit: function(p) {
          var P = O(p);
          this._zoomBoundLayers[P] && (delete this._zoomBoundLayers[P], this._updateZoomLevels());
        },
        _updateZoomLevels: function() {
          var p = 1 / 0, P = -1 / 0, B = this._getZoomSpan();
          for (var X in this._zoomBoundLayers) {
            var ne = this._zoomBoundLayers[X].options;
            p = ne.minZoom === void 0 ? p : Math.min(p, ne.minZoom), P = ne.maxZoom === void 0 ? P : Math.max(P, ne.maxZoom);
          }
          this._layersMaxZoom = P === -1 / 0 ? void 0 : P, this._layersMinZoom = p === 1 / 0 ? void 0 : p, B !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
        }
      });
      var lr = ar.extend({
        initialize: function(p, P) {
          be(this, P), this._layers = {};
          var B, X;
          if (p)
            for (B = 0, X = p.length; B < X; B++)
              this.addLayer(p[B]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(p) {
          var P = this.getLayerId(p);
          return this._layers[P] = p, this._map && this._map.addLayer(p), this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(p) {
          var P = p in this._layers ? p : this.getLayerId(p);
          return this._map && this._layers[P] && this._map.removeLayer(this._layers[P]), delete this._layers[P], this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(p) {
          var P = typeof p == "number" ? p : this.getLayerId(p);
          return P in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, ): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(p) {
          var P = Array.prototype.slice.call(arguments, 1), B, X;
          for (B in this._layers)
            X = this._layers[B], X[p] && X[p].apply(X, P);
          return this;
        },
        onAdd: function(p) {
          this.eachLayer(p.addLayer, p);
        },
        onRemove: function(p) {
          this.eachLayer(p.removeLayer, p);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(p, P) {
          for (var B in this._layers)
            p.call(P, this._layers[B]);
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(p) {
          return this._layers[p];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var p = [];
          return this.eachLayer(p.push, p), p;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(p) {
          return this.invoke("setZIndex", p);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(p) {
          return O(p);
        }
      }), ti = function(p, P) {
        return new lr(p, P);
      }, Xr = lr.extend({
        addLayer: function(p) {
          return this.hasLayer(p) ? this : (p.addEventParent(this), lr.prototype.addLayer.call(this, p), this.fire("layeradd", { layer: p }));
        },
        removeLayer: function(p) {
          return this.hasLayer(p) ? (p in this._layers && (p = this._layers[p]), p.removeEventParent(this), lr.prototype.removeLayer.call(this, p), this.fire("layerremove", { layer: p })) : this;
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(p) {
          return this.invoke("setStyle", p);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var p = new qt();
          for (var P in this._layers) {
            var B = this._layers[P];
            p.extend(B.getBounds ? B.getBounds() : B.getLatLng());
          }
          return p;
        }
      }), ql = function(p, P) {
        return new Xr(p, P);
      }, Yr = hn.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1
        },
        initialize: function(p) {
          be(this, p);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(p) {
          return this._createIcon("icon", p);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(p) {
          return this._createIcon("shadow", p);
        },
        _createIcon: function(p, P) {
          var B = this._getIconUrl(p);
          if (!B) {
            if (p === "icon")
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          }
          var X = this._createImg(B, P && P.tagName === "IMG" ? P : null);
          return this._setIconStyles(X, p), (this.options.crossOrigin || this.options.crossOrigin === "") && (X.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), X;
        },
        _setIconStyles: function(p, P) {
          var B = this.options, X = B[P + "Size"];
          typeof X == "number" && (X = [X, X]);
          var ne = ni(X), ye = ni(P === "shadow" && B.shadowAnchor || B.iconAnchor || ne && ne.divideBy(2, !0));
          p.className = "leaflet-marker-" + P + " " + (B.className || ""), ye && (p.style.marginLeft = -ye.x + "px", p.style.marginTop = -ye.y + "px"), ne && (p.style.width = ne.x + "px", p.style.height = ne.y + "px");
        },
        _createImg: function(p, P) {
          return P = P || document.createElement("img"), P.src = p, P;
        },
        _getIconUrl: function(p) {
          return Ae.retina && this.options[p + "RetinaUrl"] || this.options[p + "Url"];
        }
      });
      function Va(p) {
        return new Yr(p);
      }
      var To = Yr.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(p) {
          return typeof To.imagePath != "string" && (To.imagePath = this._detectIconPath()), (this.options.imagePath || To.imagePath) + Yr.prototype._getIconUrl.call(this, p);
        },
        _stripUrl: function(p) {
          var P = function(B, X, ne) {
            var ye = X.exec(B);
            return ye && ye[ne];
          };
          return p = P(p, /^url\((['"])?(.+)\1\)$/, 2), p && P(p, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var p = tn("div", "leaflet-default-icon-path", document.body), P = jo(p, "background-image") || jo(p, "backgroundImage");
          if (document.body.removeChild(p), P = this._stripUrl(P), P)
            return P;
          var B = document.querySelector('link[href$="leaflet.css"]');
          return B ? B.href.substring(0, B.href.length - 11 - 1) : "";
        }
      }), bs = Es.extend({
        initialize: function(p) {
          this._marker = p;
        },
        addHooks: function() {
          var p = this._marker._icon;
          this._draggable || (this._draggable = new Wo(p, p, !0)), this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable(), Vi(p, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable(), this._marker._icon && Hn(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(p) {
          var P = this._marker, B = P._map, X = this._marker.options.autoPanSpeed, ne = this._marker.options.autoPanPadding, ye = $r(P._icon), We = B.getPixelBounds(), at = B.getPixelOrigin(), ft = an(
            We.min._subtract(at).add(ne),
            We.max._subtract(at).subtract(ne)
          );
          if (!ft.contains(ye)) {
            var Rt = ni(
              (Math.max(ft.max.x, ye.x) - ft.max.x) / (We.max.x - ft.max.x) - (Math.min(ft.min.x, ye.x) - ft.min.x) / (We.min.x - ft.min.x),
              (Math.max(ft.max.y, ye.y) - ft.max.y) / (We.max.y - ft.max.y) - (Math.min(ft.min.y, ye.y) - ft.min.y) / (We.min.y - ft.min.y)
            ).multiplyBy(X);
            B.panBy(Rt, { animate: !1 }), this._draggable._newPos._add(Rt), this._draggable._startPos._add(Rt), Yn(P._icon, this._draggable._newPos), this._onDrag(p), this._panRequest = At(this._adjustPan.bind(this, p));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(p) {
          this._marker.options.autoPan && (Mi(this._panRequest), this._panRequest = At(this._adjustPan.bind(this, p)));
        },
        _onDrag: function(p) {
          var P = this._marker, B = P._shadow, X = $r(P._icon), ne = P._map.layerPointToLatLng(X);
          B && Yn(B, X), P._latlng = ne, p.latlng = ne, p.oldLatLng = this._oldLatLng, P.fire("move", p).fire("drag", p);
        },
        _onDragEnd: function(p) {
          Mi(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", p);
        }
      }), ks = ar.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new To(),
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: !0,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: !1,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !1,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: !0,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: !1,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: !1,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(p, P) {
          be(this, P), this._latlng = xi(p);
        },
        onAdd: function(p) {
          this._zoomAnimated = this._zoomAnimated && p.options.markerZoomAnimation, this._zoomAnimated && p.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
        },
        onRemove: function(p) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && p.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(p) {
          var P = this._latlng;
          return this._latlng = xi(p), this.update(), this.fire("move", { oldLatLng: P, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(p) {
          return this.options.zIndexOffset = p, this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(p) {
          return this.options.icon = p, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var p = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(p);
          }
          return this;
        },
        _initIcon: function() {
          var p = this.options, P = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), B = p.icon.createIcon(this._icon), X = !1;
          B !== this._icon && (this._icon && this._removeIcon(), X = !0, p.title && (B.title = p.title), B.tagName === "IMG" && (B.alt = p.alt || "")), Vi(B, P), p.keyboard && (B.tabIndex = "0", B.setAttribute("role", "button")), this._icon = B, p.riseOnHover && this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Bi(B, "focus", this._panOnFocus, this);
          var ne = p.icon.createShadow(this._shadow), ye = !1;
          ne !== this._shadow && (this._removeShadow(), ye = !0), ne && (Vi(ne, P), ne.alt = ""), this._shadow = ne, p.opacity < 1 && this._updateOpacity(), X && this.getPane().appendChild(this._icon), this._initInteraction(), ne && ye && this.getPane(p.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function() {
          this.options.riseOnHover && this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Cn(this._icon, "focus", this._panOnFocus, this), xn(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
        },
        _removeShadow: function() {
          this._shadow && xn(this._shadow), this._shadow = null;
        },
        _setPos: function(p) {
          this._icon && Yn(this._icon, p), this._shadow && Yn(this._shadow, p), this._zIndex = p.y + this.options.zIndexOffset, this._resetZIndex();
        },
        _updateZIndex: function(p) {
          this._icon && (this._icon.style.zIndex = this._zIndex + p);
        },
        _animateZoom: function(p) {
          var P = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center).round();
          this._setPos(P);
        },
        _initInteraction: function() {
          if (this.options.interactive && (Vi(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), bs)) {
            var p = this.options.draggable;
            this.dragging && (p = this.dragging.enabled(), this.dragging.disable()), this.dragging = new bs(this), p && this.dragging.enable();
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(p) {
          return this.options.opacity = p, this._map && this._updateOpacity(), this;
        },
        _updateOpacity: function() {
          var p = this.options.opacity;
          this._icon && Qn(this._icon, p), this._shadow && Qn(this._shadow, p);
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var p = this._map;
          if (p) {
            var P = this.options.icon.options, B = P.iconSize ? ni(P.iconSize) : ni(0, 0), X = P.iconAnchor ? ni(P.iconAnchor) : ni(0, 0);
            p.panInside(this._latlng, {
              paddingTopLeft: X,
              paddingBottomRight: B.subtract(X)
            });
          }
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function Wl(p, P) {
        return new ks(p, P);
      }
      var Tt = ar.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: !0,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: !1,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !0
        },
        beforeAdd: function(p) {
          this._renderer = p.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          return this._map && this._renderer._updatePath(this), this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(p) {
          return be(this, p), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && p && Object.prototype.hasOwnProperty.call(p, "weight") && this._updateBounds()), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this), this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project(), this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      }), ma = Tt.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: !0,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(p, P) {
          be(this, P), this._latlng = xi(p), this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(p) {
          var P = this._latlng;
          return this._latlng = xi(p), this.redraw(), this.fire("move", { oldLatLng: P, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(p) {
          return this.options.radius = this._radius = p, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(p) {
          var P = p && p.radius || this._radius;
          return Tt.prototype.setStyle.call(this, p), this.setRadius(P), this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
        },
        _updateBounds: function() {
          var p = this._radius, P = this._radiusY || p, B = this._clickTolerance(), X = [p + B, P + B];
          this._pxBounds = new Gi(this._point.subtract(X), this._point.add(X));
        },
        _update: function() {
          this._map && this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function Mo(p, P) {
        return new ma(p, P);
      }
      var gs = ma.extend({
        initialize: function(p, P, B) {
          if (typeof P == "number" && (P = w({}, B, { radius: P })), be(this, P), this._latlng = xi(p), isNaN(this.options.radius))
            throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(p) {
          return this._mRadius = p, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var p = [this._radius, this._radiusY || this._radius];
          return new qt(
            this._map.layerPointToLatLng(this._point.subtract(p)),
            this._map.layerPointToLatLng(this._point.add(p))
          );
        },
        setStyle: Tt.prototype.setStyle,
        _project: function() {
          var p = this._latlng.lng, P = this._latlng.lat, B = this._map, X = B.options.crs;
          if (X.distance === xs.distance) {
            var ne = Math.PI / 180, ye = this._mRadius / xs.R / ne, We = B.project([P + ye, p]), at = B.project([P - ye, p]), ft = We.add(at).divideBy(2), Rt = B.unproject(ft).lat, ii = Math.acos((Math.cos(ye * ne) - Math.sin(P * ne) * Math.sin(Rt * ne)) / (Math.cos(P * ne) * Math.cos(Rt * ne))) / ne;
            (isNaN(ii) || ii === 0) && (ii = ye / Math.cos(Math.PI / 180 * P)), this._point = ft.subtract(B.getPixelOrigin()), this._radius = isNaN(ii) ? 0 : ft.x - B.project([Rt, p - ii]).x, this._radiusY = ft.y - We.y;
          } else {
            var Ci = X.unproject(X.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = B.latLngToLayerPoint(this._latlng), this._radius = this._point.x - B.latLngToLayerPoint(Ci).x;
          }
          this._updateBounds();
        }
      });
      function Gh(p, P, B) {
        return new gs(p, P, B);
      }
      var Dr = Tt.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: !1
        },
        initialize: function(p, P) {
          be(this, P), this._setLatLngs(p);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(p) {
          return this._setLatLngs(p), this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          for (var P = 1 / 0, B = null, X = $o, ne, ye, We = 0, at = this._parts.length; We < at; We++)
            for (var ft = this._parts[We], Rt = 1, ii = ft.length; Rt < ii; Rt++) {
              ne = ft[Rt - 1], ye = ft[Rt];
              var Ci = X(p, ne, ye, !0);
              Ci < P && (P = Ci, B = X(p, ne, ye));
            }
          return B && (B.distance = Math.sqrt(P)), B;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return jh(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(p, P) {
          return P = P || this._defaultShape(), p = xi(p), P.push(p), this._bounds.extend(p), this.redraw();
        },
        _setLatLngs: function(p) {
          this._bounds = new qt(), this._latlngs = this._convertLatLngs(p);
        },
        _defaultShape: function() {
          return rs(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(p) {
          for (var P = [], B = rs(p), X = 0, ne = p.length; X < ne; X++)
            B ? (P[X] = xi(p[X]), this._bounds.extend(P[X])) : P[X] = this._convertLatLngs(p[X]);
          return P;
        },
        _project: function() {
          var p = new Gi();
          this._rings = [], this._projectLatlngs(this._latlngs, this._rings, p), this._bounds.isValid() && p.isValid() && (this._rawPxBounds = p, this._updateBounds());
        },
        _updateBounds: function() {
          var p = this._clickTolerance(), P = new fi(p, p);
          this._rawPxBounds && (this._pxBounds = new Gi([
            this._rawPxBounds.min.subtract(P),
            this._rawPxBounds.max.add(P)
          ]));
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(p, P, B) {
          var X = p[0] instanceof Di, ne = p.length, ye, We;
          if (X) {
            for (We = [], ye = 0; ye < ne; ye++)
              We[ye] = this._map.latLngToLayerPoint(p[ye]), B.extend(We[ye]);
            P.push(We);
          } else
            for (ye = 0; ye < ne; ye++)
              this._projectLatlngs(p[ye], P, B);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var p = this._renderer._bounds;
          if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(p))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var P = this._parts, B, X, ne, ye, We, at, ft;
            for (B = 0, ne = 0, ye = this._rings.length; B < ye; B++)
              for (ft = this._rings[B], X = 0, We = ft.length; X < We - 1; X++)
                at = Na(ft[X], ft[X + 1], p, X, !0), at && (P[ne] = P[ne] || [], P[ne].push(at[0]), (at[1] !== ft[X + 1] || X === We - 2) && (P[ne].push(at[1]), ne++));
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          for (var p = this._parts, P = this.options.smoothFactor, B = 0, X = p.length; B < X; B++)
            p[B] = fl(p[B], P);
        },
        _update: function() {
          this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, P) {
          var B, X, ne, ye, We, at, ft = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p))
            return !1;
          for (B = 0, ye = this._parts.length; B < ye; B++)
            for (at = this._parts[B], X = 0, We = at.length, ne = We - 1; X < We; ne = X++)
              if (!(!P && X === 0) && pl(p, at[ne], at[X]) <= ft)
                return !0;
          return !1;
        }
      });
      function So(p, P) {
        return new Dr(p, P);
      }
      Dr._flat = Uh;
      var Kr = Dr.extend({
        options: {
          fill: !0
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Nc(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(p) {
          var P = Dr.prototype._convertLatLngs.call(this, p), B = P.length;
          return B >= 2 && P[0] instanceof Di && P[0].equals(P[B - 1]) && P.pop(), P;
        },
        _setLatLngs: function(p) {
          Dr.prototype._setLatLngs.call(this, p), rs(this._latlngs) && (this._latlngs = [this._latlngs]);
        },
        _defaultShape: function() {
          return rs(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var p = this._renderer._bounds, P = this.options.weight, B = new fi(P, P);
          if (p = new Gi(p.min.subtract(B), p.max.add(B)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(p))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var X = 0, ne = this._rings.length, ye; X < ne; X++)
              ye = so(this._rings[X], p, !0), ye.length && this._parts.push(ye);
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, !0);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var P = !1, B, X, ne, ye, We, at, ft, Rt;
          if (!this._pxBounds || !this._pxBounds.contains(p))
            return !1;
          for (ye = 0, ft = this._parts.length; ye < ft; ye++)
            for (B = this._parts[ye], We = 0, Rt = B.length, at = Rt - 1; We < Rt; at = We++)
              X = B[We], ne = B[at], X.y > p.y != ne.y > p.y && p.x < (ne.x - X.x) * (p.y - X.y) / (ne.y - X.y) + X.x && (P = !P);
          return P || Dr.prototype._containsPoint.call(this, p, !0);
        }
      });
      function Yo(p, P) {
        return new Kr(p, P);
      }
      var cr = Xr.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(p, P) {
          be(this, P), this._layers = {}, p && this.addData(p);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(p) {
          var P = vt(p) ? p : p.features, B, X, ne;
          if (P) {
            for (B = 0, X = P.length; B < X; B++)
              ne = P[B], (ne.geometries || ne.geometry || ne.features || ne.coordinates) && this.addData(ne);
            return this;
          }
          var ye = this.options;
          if (ye.filter && !ye.filter(p))
            return this;
          var We = Eo(p, ye);
          return We ? (We.feature = ga(p), We.defaultOptions = We.options, this.resetStyle(We), ye.onEachFeature && ye.onEachFeature(p, We), this.addLayer(We)) : this;
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(p) {
          return p === void 0 ? this.eachLayer(this.resetStyle, this) : (p.options = w({}, p.defaultOptions), this._setLayerStyle(p, this.options.style), this);
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(p) {
          return this.eachLayer(function(P) {
            this._setLayerStyle(P, p);
          }, this);
        },
        _setLayerStyle: function(p, P) {
          p.setStyle && (typeof P == "function" && (P = P(p.feature)), p.setStyle(P));
        }
      });
      function Eo(p, P) {
        var B = p.type === "Feature" ? p.geometry : p, X = B ? B.coordinates : null, ne = [], ye = P && P.pointToLayer, We = P && P.coordsToLatLng || Uc, at, ft, Rt, ii;
        if (!X && !B)
          return null;
        switch (B.type) {
          case "Point":
            return at = We(X), Zh(ye, p, at, P);
          case "MultiPoint":
            for (Rt = 0, ii = X.length; Rt < ii; Rt++)
              at = We(X[Rt]), ne.push(Zh(ye, p, at, P));
            return new Xr(ne);
          case "LineString":
          case "MultiLineString":
            return ft = Ua(X, B.type === "LineString" ? 0 : 1, We), new Dr(ft, P);
          case "Polygon":
          case "MultiPolygon":
            return ft = Ua(X, B.type === "Polygon" ? 1 : 2, We), new Kr(ft, P);
          case "GeometryCollection":
            for (Rt = 0, ii = B.geometries.length; Rt < ii; Rt++) {
              var Ci = Eo({
                geometry: B.geometries[Rt],
                type: "Feature",
                properties: p.properties
              }, P);
              Ci && ne.push(Ci);
            }
            return new Xr(ne);
          case "FeatureCollection":
            for (Rt = 0, ii = B.features.length; Rt < ii; Rt++) {
              var Wi = Eo(B.features[Rt], P);
              Wi && ne.push(Wi);
            }
            return new Xr(ne);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function Zh(p, P, B, X) {
        return p ? p(P, B) : new ks(B, X && X.markersInheritOptions && X);
      }
      function Uc(p) {
        return new Di(p[1], p[0], p[2]);
      }
      function Ua(p, P, B) {
        for (var X = [], ne = 0, ye = p.length, We; ne < ye; ne++)
          We = P ? Ua(p[ne], P - 1, B) : (B || Uc)(p[ne]), X.push(We);
        return X;
      }
      function $l(p, P) {
        return p = xi(p), p.alt !== void 0 ? [ae(p.lng, P), ae(p.lat, P), ae(p.alt, P)] : [ae(p.lng, P), ae(p.lat, P)];
      }
      function yl(p, P, B, X) {
        for (var ne = [], ye = 0, We = p.length; ye < We; ye++)
          ne.push(P ? yl(p[ye], rs(p[ye]) ? 0 : P - 1, B, X) : $l(p[ye], X));
        return !P && B && ne.length > 0 && ne.push(ne[0].slice()), ne;
      }
      function _a(p, P) {
        return p.feature ? w({}, p.feature, { geometry: P }) : ga(P);
      }
      function ga(p) {
        return p.type === "Feature" || p.type === "FeatureCollection" ? p : {
          type: "Feature",
          properties: {},
          geometry: p
        };
      }
      var Ao = {
        toGeoJSON: function(p) {
          return _a(this, {
            type: "Point",
            coordinates: $l(this.getLatLng(), p)
          });
        }
      };
      ks.include(Ao), gs.include(Ao), ma.include(Ao), Dr.include({
        toGeoJSON: function(p) {
          var P = !rs(this._latlngs), B = yl(this._latlngs, P ? 1 : 0, !1, p);
          return _a(this, {
            type: (P ? "Multi" : "") + "LineString",
            coordinates: B
          });
        }
      }), Kr.include({
        toGeoJSON: function(p) {
          var P = !rs(this._latlngs), B = P && !rs(this._latlngs[0]), X = yl(this._latlngs, B ? 2 : P ? 1 : 0, !0, p);
          return P || (X = [X]), _a(this, {
            type: (B ? "Multi" : "") + "Polygon",
            coordinates: X
          });
        }
      }), lr.include({
        toMultiPoint: function(p) {
          var P = [];
          return this.eachLayer(function(B) {
            P.push(B.toGeoJSON(p).geometry.coordinates);
          }), _a(this, {
            type: "MultiPoint",
            coordinates: P
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(p) {
          var P = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (P === "MultiPoint")
            return this.toMultiPoint(p);
          var B = P === "GeometryCollection", X = [];
          return this.eachLayer(function(ne) {
            if (ne.toGeoJSON) {
              var ye = ne.toGeoJSON(p);
              if (B)
                X.push(ye.geometry);
              else {
                var We = ga(ye);
                We.type === "FeatureCollection" ? X.push.apply(X, We.features) : X.push(We);
              }
            }
          }), B ? _a(this, {
            geometries: X,
            type: "GeometryCollection"
          }) : {
            type: "FeatureCollection",
            features: X
          };
        }
      });
      function Hh(p, P) {
        return new cr(p, P);
      }
      var td = Hh, ja = ar.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(p, P, B) {
          this._url = p, this._bounds = ln(P), be(this, B);
        },
        onAdd: function() {
          this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (Vi(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
        },
        onRemove: function() {
          xn(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(p) {
          return this.options.opacity = p, this._image && this._updateOpacity(), this;
        },
        setStyle: function(p) {
          return p.opacity && this.setOpacity(p.opacity), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          return this._map && Go(this._image), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          return this._map && aa(this._image), this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(p) {
          return this._url = p, this._image && (this._image.src = p), this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(p) {
          return this._bounds = ln(p), this._map && this._reset(), this;
        },
        getEvents: function() {
          var p = {
            zoom: this._reset,
            viewreset: this._reset
          };
          return this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(p) {
          return this.options.zIndex = p, this._updateZIndex(), this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var p = this._url.tagName === "IMG", P = this._image = p ? this._url : tn("img");
          if (Vi(P, "leaflet-image-layer"), this._zoomAnimated && Vi(P, "leaflet-zoom-animated"), this.options.className && Vi(P, this.options.className), P.onselectstart = J, P.onmousemove = J, P.onload = E(this.fire, this, "load"), P.onerror = E(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (P.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), p) {
            this._url = P.src;
            return;
          }
          P.src = this._url, P.alt = this.options.alt;
        },
        _animateZoom: function(p) {
          var P = this._map.getZoomScale(p.zoom), B = this._map._latLngBoundsToNewLayerBounds(this._bounds, p.zoom, p.center).min;
          Ks(this._image, B, P);
        },
        _reset: function() {
          var p = this._image, P = new Gi(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), B = P.getSize();
          Yn(p, P.min), p.style.width = B.x + "px", p.style.height = B.y + "px";
        },
        _updateOpacity: function() {
          Qn(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
        },
        _overlayOnError: function() {
          this.fire("error");
          var p = this.options.errorOverlayUrl;
          p && this._url !== p && (this._url = p, this._image.src = p);
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      }), jc = function(p, P, B) {
        return new ja(p, P, B);
      }, Gc = ja.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: !0,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: !0,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: !0,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: !1,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: !0
        },
        _initImage: function() {
          var p = this._url.tagName === "VIDEO", P = this._image = p ? this._url : tn("video");
          if (Vi(P, "leaflet-image-layer"), this._zoomAnimated && Vi(P, "leaflet-zoom-animated"), this.options.className && Vi(P, this.options.className), P.onselectstart = J, P.onmousemove = J, P.onloadeddata = E(this.fire, this, "load"), p) {
            for (var B = P.getElementsByTagName("source"), X = [], ne = 0; ne < B.length; ne++)
              X.push(B[ne].src);
            this._url = B.length > 0 ? X : [P.src];
            return;
          }
          vt(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(P.style, "objectFit") && (P.style.objectFit = "fill"), P.autoplay = !!this.options.autoplay, P.loop = !!this.options.loop, P.muted = !!this.options.muted, P.playsInline = !!this.options.playsInline;
          for (var ye = 0; ye < this._url.length; ye++) {
            var We = tn("source");
            We.src = this._url[ye], P.appendChild(We);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function hr(p, P, B) {
        return new Gc(p, P, B);
      }
      var Zc = ja.extend({
        _initImage: function() {
          var p = this._image = this._url;
          Vi(p, "leaflet-image-layer"), this._zoomAnimated && Vi(p, "leaflet-zoom-animated"), this.options.className && Vi(p, this.options.className), p.onselectstart = J, p.onmousemove = J;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function Hc(p, P, B) {
        return new Zc(p, P, B);
      }
      var xr = ar.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: !1,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(p, P) {
          p && (p instanceof Di || vt(p)) ? (this._latlng = xi(p), be(this, P)) : (be(this, p), this._source = P), this.options.content && (this._content = this.options.content);
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(p) {
          return p = arguments.length ? p : this._source._map, p.hasLayer(this) || p.addLayer(this), this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          return this._map && this._map.removeLayer(this), this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(p) {
          return this._map ? this.close() : (arguments.length ? this._source = p : p = this._source, this._prepareOpen(), this.openOn(p._map)), this;
        },
        onAdd: function(p) {
          this._zoomAnimated = p._zoomAnimated, this._container || this._initLayout(), p._fadeAnimated && Qn(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), p._fadeAnimated && Qn(this._container, 1), this.bringToFront(), this.options.interactive && (Vi(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
        },
        onRemove: function(p) {
          p._fadeAnimated ? (Qn(this._container, 0), this._removeTimeout = setTimeout(E(xn, void 0, this._container), 200)) : xn(this._container), this.options.interactive && (Hn(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(p) {
          return this._latlng = xi(p), this._map && (this._updatePosition(), this._adjustPan()), this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(p) {
          return this._content = p, this.update(), this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
        },
        getEvents: function() {
          var p = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          return this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          return this._map && Go(this._container), this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          return this._map && aa(this._container), this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(p) {
          var P = this._source;
          if (!P._map)
            return !1;
          if (P instanceof Xr) {
            P = null;
            var B = this._source._layers;
            for (var X in B)
              if (B[X]._map) {
                P = B[X];
                break;
              }
            if (!P)
              return !1;
            this._source = P;
          }
          if (!p)
            if (P.getCenter)
              p = P.getCenter();
            else if (P.getLatLng)
              p = P.getLatLng();
            else if (P.getBounds)
              p = P.getBounds().getCenter();
            else
              throw new Error("Unable to get source layer LatLng.");
          return this.setLatLng(p), this._map && this.update(), !0;
        },
        _updateContent: function() {
          if (this._content) {
            var p = this._contentNode, P = typeof this._content == "function" ? this._content(this._source || this) : this._content;
            if (typeof P == "string")
              p.innerHTML = P;
            else {
              for (; p.hasChildNodes(); )
                p.removeChild(p.firstChild);
              p.appendChild(P);
            }
            this.fire("contentupdate");
          }
        },
        _updatePosition: function() {
          if (this._map) {
            var p = this._map.latLngToLayerPoint(this._latlng), P = ni(this.options.offset), B = this._getAnchor();
            this._zoomAnimated ? Yn(this._container, p.add(B)) : P = P.add(p).add(B);
            var X = this._containerBottom = -P.y, ne = this._containerLeft = -Math.round(this._containerWidth / 2) + P.x;
            this._container.style.bottom = X + "px", this._container.style.left = ne + "px";
          }
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      nn.include({
        _initOverlay: function(p, P, B, X) {
          var ne = P;
          return ne instanceof p || (ne = new p(X).setContent(P)), B && ne.setLatLng(B), ne;
        }
      }), ar.include({
        _initOverlay: function(p, P, B, X) {
          var ne = B;
          return ne instanceof p ? (be(ne, X), ne._source = this) : (ne = P && !X ? P : new p(X, this), ne.setContent(B)), ne;
        }
      });
      var Ko = xr.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: !0,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: !1,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: !0,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: !0,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: !0,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(p) {
          return p = arguments.length ? p : this._source._map, !p.hasLayer(this) && p._popup && p._popup.options.autoClose && p.removeLayer(p._popup), p._popup = this, xr.prototype.openOn.call(this, p);
        },
        onAdd: function(p) {
          xr.prototype.onAdd.call(this, p), p.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof Tt || this._source.on("preclick", ms));
        },
        onRemove: function(p) {
          xr.prototype.onRemove.call(this, p), p.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof Tt || this._source.off("preclick", ms));
        },
        getEvents: function() {
          var p = xr.prototype.getEvents.call(this);
          return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (p.preclick = this.close), this.options.keepInView && (p.moveend = this._adjustPan), p;
        },
        _initLayout: function() {
          var p = "leaflet-popup", P = this._container = tn(
            "div",
            p + " " + (this.options.className || "") + " leaflet-zoom-animated"
          ), B = this._wrapper = tn("div", p + "-content-wrapper", P);
          if (this._contentNode = tn("div", p + "-content", B), Ai(P), bo(this._contentNode), Bi(P, "contextmenu", ms), this._tipContainer = tn("div", p + "-tip-container", P), this._tip = tn("div", p + "-tip", this._tipContainer), this.options.closeButton) {
            var X = this._closeButton = tn("a", p + "-close-button", P);
            X.setAttribute("role", "button"), X.setAttribute("aria-label", "Close popup"), X.href = "#close", X.innerHTML = '<span aria-hidden="true">&#215;</span>', Bi(X, "click", function(ne) {
              _s(ne), this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var p = this._contentNode, P = p.style;
          P.width = "", P.whiteSpace = "nowrap";
          var B = p.offsetWidth;
          B = Math.min(B, this.options.maxWidth), B = Math.max(B, this.options.minWidth), P.width = B + 1 + "px", P.whiteSpace = "", P.height = "";
          var X = p.offsetHeight, ne = this.options.maxHeight, ye = "leaflet-popup-scrolled";
          ne && X > ne ? (P.height = ne + "px", Vi(p, ye)) : Hn(p, ye), this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(p) {
          var P = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center), B = this._getAnchor();
          Yn(this._container, P.add(B));
        },
        _adjustPan: function() {
          if (this.options.autoPan) {
            if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
              this._autopanning = !1;
              return;
            }
            var p = this._map, P = parseInt(jo(this._container, "marginBottom"), 10) || 0, B = this._container.offsetHeight + P, X = this._containerWidth, ne = new fi(this._containerLeft, -B - this._containerBottom);
            ne._add($r(this._container));
            var ye = p.layerPointToContainerPoint(ne), We = ni(this.options.autoPanPadding), at = ni(this.options.autoPanPaddingTopLeft || We), ft = ni(this.options.autoPanPaddingBottomRight || We), Rt = p.getSize(), ii = 0, Ci = 0;
            ye.x + X + ft.x > Rt.x && (ii = ye.x + X - Rt.x + ft.x), ye.x - ii - at.x < 0 && (ii = ye.x - at.x), ye.y + B + ft.y > Rt.y && (Ci = ye.y + B - Rt.y + ft.y), ye.y - Ci - at.y < 0 && (Ci = ye.y - at.y), (ii || Ci) && (this.options.keepInView && (this._autopanning = !0), p.fire("autopanstart").panBy([ii, Ci]));
          }
        },
        _getAnchor: function() {
          return ni(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      }), Xl = function(p, P) {
        return new Ko(p, P);
      };
      nn.mergeOptions({
        closePopupOnClick: !0
      }), nn.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(p, P, B) {
          return this._initOverlay(Ko, p, P, B).openOn(this), this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(p) {
          return p = arguments.length ? p : this._popup, p && p.close(), this;
        }
      }), ar.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(p, P) {
          return this._popup = this._initOverlay(Ko, this._popup, p, P), this._popupHandlersAdded || (this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !0), this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          return this._popup && (this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !1, this._popup = null), this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(p) {
          return this._popup && (this instanceof Xr || (this._popup._source = this), this._popup._prepareOpen(p || this._latlng) && this._popup.openOn(this._map)), this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          return this._popup && this._popup.close(), this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          return this._popup && this._popup.toggle(this), this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : !1;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(p) {
          return this._popup && this._popup.setContent(p), this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(p) {
          if (!(!this._popup || !this._map)) {
            Js(p);
            var P = p.layer || p.target;
            if (this._popup._source === P && !(P instanceof Tt)) {
              this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(p.latlng);
              return;
            }
            this._popup._source = P, this.openPopup(p.latlng);
          }
        },
        _movePopup: function(p) {
          this._popup.setLatLng(p.latlng);
        },
        _onKeyPress: function(p) {
          p.originalEvent.keyCode === 13 && this._openPopup(p);
        }
      });
      var Jr = xr.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: !1,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: !1,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(p) {
          xr.prototype.onAdd.call(this, p), this.setOpacity(this.options.opacity), p.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
        },
        onRemove: function(p) {
          xr.prototype.onRemove.call(this, p), p.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
        },
        getEvents: function() {
          var p = xr.prototype.getEvents.call(this);
          return this.options.permanent || (p.preclick = this.close), p;
        },
        _initLayout: function() {
          var p = "leaflet-tooltip", P = p + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = tn("div", P), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + O(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(p) {
          var P, B, X = this._map, ne = this._container, ye = X.latLngToContainerPoint(X.getCenter()), We = X.layerPointToContainerPoint(p), at = this.options.direction, ft = ne.offsetWidth, Rt = ne.offsetHeight, ii = ni(this.options.offset), Ci = this._getAnchor();
          at === "top" ? (P = ft / 2, B = Rt) : at === "bottom" ? (P = ft / 2, B = 0) : at === "center" ? (P = ft / 2, B = Rt / 2) : at === "right" ? (P = 0, B = Rt / 2) : at === "left" ? (P = ft, B = Rt / 2) : We.x < ye.x ? (at = "right", P = 0, B = Rt / 2) : (at = "left", P = ft + (ii.x + Ci.x) * 2, B = Rt / 2), p = p.subtract(ni(P, B, !0)).add(ii).add(Ci), Hn(ne, "leaflet-tooltip-right"), Hn(ne, "leaflet-tooltip-left"), Hn(ne, "leaflet-tooltip-top"), Hn(ne, "leaflet-tooltip-bottom"), Vi(ne, "leaflet-tooltip-" + at), Yn(ne, p);
        },
        _updatePosition: function() {
          var p = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(p);
        },
        setOpacity: function(p) {
          this.options.opacity = p, this._container && Qn(this._container, p);
        },
        _animateZoom: function(p) {
          var P = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center);
          this._setPosition(P);
        },
        _getAnchor: function() {
          return ni(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      }), Yl = function(p, P) {
        return new Jr(p, P);
      };
      nn.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(p, P, B) {
          return this._initOverlay(Jr, p, P, B).openOn(this), this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(p) {
          return p.close(), this;
        }
      }), ar.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(p, P) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Jr, this._tooltip, p, P), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
        },
        _initTooltipInteractions: function(p) {
          if (!(!p && this._tooltipHandlersAdded)) {
            var P = p ? "off" : "on", B = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            this._tooltip.options.permanent ? B.add = this._openTooltip : (B.mouseover = this._openTooltip, B.mouseout = this.closeTooltip, B.click = this._openTooltip, this._map ? this._addFocusListeners() : B.add = this._addFocusListeners), this._tooltip.options.sticky && (B.mousemove = this._moveTooltip), this[P](B), this._tooltipHandlersAdded = !p;
          }
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(p) {
          return this._tooltip && (this instanceof Xr || (this._tooltip._source = this), this._tooltip._prepareOpen(p) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip)
            return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this), this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(p) {
          return this._tooltip && this._tooltip.setContent(p), this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
        },
        _addFocusListenersOnLayer: function(p) {
          var P = typeof p.getElement == "function" && p.getElement();
          P && (Bi(P, "focus", function() {
            this._tooltip._source = p, this.openTooltip();
          }, this), Bi(P, "blur", this.closeTooltip, this));
        },
        _setAriaDescribedByOnLayer: function(p) {
          var P = typeof p.getElement == "function" && p.getElement();
          P && P.setAttribute("aria-describedby", this._tooltip._container.id);
        },
        _openTooltip: function(p) {
          if (!(!this._tooltip || !this._map)) {
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = !0;
              var P = this;
              this._map.once("moveend", function() {
                P._openOnceFlag = !1, P._openTooltip(p);
              });
              return;
            }
            this._tooltip._source = p.layer || p.target, this.openTooltip(this._tooltip.options.sticky ? p.latlng : void 0);
          }
        },
        _moveTooltip: function(p) {
          var P = p.latlng, B, X;
          this._tooltip.options.sticky && p.originalEvent && (B = this._map.mouseEventToContainerPoint(p.originalEvent), X = this._map.containerPointToLayerPoint(B), P = this._map.layerPointToLatLng(X)), this._tooltip.setLatLng(P);
        }
      });
      var Kl = Yr.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: !1,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(p) {
          var P = p && p.tagName === "DIV" ? p : document.createElement("div"), B = this.options;
          if (B.html instanceof Element ? (no(P), P.appendChild(B.html)) : P.innerHTML = B.html !== !1 ? B.html : "", B.bgPos) {
            var X = ni(B.bgPos);
            P.style.backgroundPosition = -X.x + "px " + -X.y + "px";
          }
          return this._setIconStyles(P, "icon"), P;
        },
        createShadow: function() {
          return null;
        }
      });
      function ya(p) {
        return new Kl(p);
      }
      Yr.Default = To;
      var ro = ar.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Ae.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: !0,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: !1,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(p) {
          be(this, p);
        },
        onAdd: function() {
          this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
        },
        beforeAdd: function(p) {
          p._addZoomLimit(this);
        },
        onRemove: function(p) {
          this._removeAllTiles(), xn(this._container), p._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          return this._map && (Go(this._container), this._setAutoZIndex(Math.max)), this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          return this._map && (aa(this._container), this._setAutoZIndex(Math.min)), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(p) {
          return this.options.opacity = p, this._updateOpacity(), this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(p) {
          return this.options.zIndex = p, this._updateZIndex(), this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var p = this._clampZoom(this._map.getZoom());
            p !== this._tileZoom && (this._tileZoom = p, this._updateLevels()), this._update();
          }
          return this;
        },
        getEvents: function() {
          var p = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = j(this._onMoveEnd, this.options.updateInterval, this)), p.move = this._onMove), this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var p = this.options.tileSize;
          return p instanceof fi ? p : new fi(p, p);
        },
        _updateZIndex: function() {
          this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
        },
        _setAutoZIndex: function(p) {
          for (var P = this.getPane().children, B = -p(-1 / 0, 1 / 0), X = 0, ne = P.length, ye; X < ne; X++)
            ye = P[X].style.zIndex, P[X] !== this._container && ye && (B = p(B, +ye));
          isFinite(B) && (this.options.zIndex = B + p(-1, 1), this._updateZIndex());
        },
        _updateOpacity: function() {
          if (this._map && !Ae.ielt9) {
            Qn(this._container, this.options.opacity);
            var p = +/* @__PURE__ */ new Date(), P = !1, B = !1;
            for (var X in this._tiles) {
              var ne = this._tiles[X];
              if (!(!ne.current || !ne.loaded)) {
                var ye = Math.min(1, (p - ne.loaded) / 200);
                Qn(ne.el, ye), ye < 1 ? P = !0 : (ne.active ? B = !0 : this._onOpaqueTile(ne), ne.active = !0);
              }
            }
            B && !this._noPrune && this._pruneTiles(), P && (Mi(this._fadeFrame), this._fadeFrame = At(this._updateOpacity, this));
          }
        },
        _onOpaqueTile: J,
        _initContainer: function() {
          this._container || (this._container = tn("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
        },
        _updateLevels: function() {
          var p = this._tileZoom, P = this.options.maxZoom;
          if (p !== void 0) {
            for (var B in this._levels)
              B = Number(B), this._levels[B].el.children.length || B === p ? (this._levels[B].el.style.zIndex = P - Math.abs(p - B), this._onUpdateLevel(B)) : (xn(this._levels[B].el), this._removeTilesAtZoom(B), this._onRemoveLevel(B), delete this._levels[B]);
            var X = this._levels[p], ne = this._map;
            return X || (X = this._levels[p] = {}, X.el = tn("div", "leaflet-tile-container leaflet-zoom-animated", this._container), X.el.style.zIndex = P, X.origin = ne.project(ne.unproject(ne.getPixelOrigin()), p).round(), X.zoom = p, this._setZoomTransform(X, ne.getCenter(), ne.getZoom()), J(X.el.offsetWidth), this._onCreateLevel(X)), this._level = X, X;
          }
        },
        _onUpdateLevel: J,
        _onRemoveLevel: J,
        _onCreateLevel: J,
        _pruneTiles: function() {
          if (this._map) {
            var p, P, B = this._map.getZoom();
            if (B > this.options.maxZoom || B < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (p in this._tiles)
              P = this._tiles[p], P.retain = P.current;
            for (p in this._tiles)
              if (P = this._tiles[p], P.current && !P.active) {
                var X = P.coords;
                this._retainParent(X.x, X.y, X.z, X.z - 5) || this._retainChildren(X.x, X.y, X.z, X.z + 2);
              }
            for (p in this._tiles)
              this._tiles[p].retain || this._removeTile(p);
          }
        },
        _removeTilesAtZoom: function(p) {
          for (var P in this._tiles)
            this._tiles[P].coords.z === p && this._removeTile(P);
        },
        _removeAllTiles: function() {
          for (var p in this._tiles)
            this._removeTile(p);
        },
        _invalidateAll: function() {
          for (var p in this._levels)
            xn(this._levels[p].el), this._onRemoveLevel(Number(p)), delete this._levels[p];
          this._removeAllTiles(), this._tileZoom = void 0;
        },
        _retainParent: function(p, P, B, X) {
          var ne = Math.floor(p / 2), ye = Math.floor(P / 2), We = B - 1, at = new fi(+ne, +ye);
          at.z = +We;
          var ft = this._tileCoordsToKey(at), Rt = this._tiles[ft];
          return Rt && Rt.active ? (Rt.retain = !0, !0) : (Rt && Rt.loaded && (Rt.retain = !0), We > X ? this._retainParent(ne, ye, We, X) : !1);
        },
        _retainChildren: function(p, P, B, X) {
          for (var ne = 2 * p; ne < 2 * p + 2; ne++)
            for (var ye = 2 * P; ye < 2 * P + 2; ye++) {
              var We = new fi(ne, ye);
              We.z = B + 1;
              var at = this._tileCoordsToKey(We), ft = this._tiles[at];
              if (ft && ft.active) {
                ft.retain = !0;
                continue;
              } else
                ft && ft.loaded && (ft.retain = !0);
              B + 1 < X && this._retainChildren(ne, ye, B + 1, X);
            }
        },
        _resetView: function(p) {
          var P = p && (p.pinch || p.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), P, P);
        },
        _animateZoom: function(p) {
          this._setView(p.center, p.zoom, !0, p.noUpdate);
        },
        _clampZoom: function(p) {
          var P = this.options;
          return P.minNativeZoom !== void 0 && p < P.minNativeZoom ? P.minNativeZoom : P.maxNativeZoom !== void 0 && P.maxNativeZoom < p ? P.maxNativeZoom : p;
        },
        _setView: function(p, P, B, X) {
          var ne = Math.round(P);
          this.options.maxZoom !== void 0 && ne > this.options.maxZoom || this.options.minZoom !== void 0 && ne < this.options.minZoom ? ne = void 0 : ne = this._clampZoom(ne);
          var ye = this.options.updateWhenZooming && ne !== this._tileZoom;
          (!X || ye) && (this._tileZoom = ne, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), ne !== void 0 && this._update(p), B || this._pruneTiles(), this._noPrune = !!B), this._setZoomTransforms(p, P);
        },
        _setZoomTransforms: function(p, P) {
          for (var B in this._levels)
            this._setZoomTransform(this._levels[B], p, P);
        },
        _setZoomTransform: function(p, P, B) {
          var X = this._map.getZoomScale(B, p.zoom), ne = p.origin.multiplyBy(X).subtract(this._map._getNewPixelOrigin(P, B)).round();
          Ae.any3d ? Ks(p.el, ne, X) : Yn(p.el, ne);
        },
        _resetGrid: function() {
          var p = this._map, P = p.options.crs, B = this._tileSize = this.getTileSize(), X = this._tileZoom, ne = this._map.getPixelWorldBounds(this._tileZoom);
          ne && (this._globalTileRange = this._pxBoundsToTileRange(ne)), this._wrapX = P.wrapLng && !this.options.noWrap && [
            Math.floor(p.project([0, P.wrapLng[0]], X).x / B.x),
            Math.ceil(p.project([0, P.wrapLng[1]], X).x / B.y)
          ], this._wrapY = P.wrapLat && !this.options.noWrap && [
            Math.floor(p.project([P.wrapLat[0], 0], X).y / B.x),
            Math.ceil(p.project([P.wrapLat[1], 0], X).y / B.y)
          ];
        },
        _onMoveEnd: function() {
          !this._map || this._map._animatingZoom || this._update();
        },
        _getTiledPixelBounds: function(p) {
          var P = this._map, B = P._animatingZoom ? Math.max(P._animateToZoom, P.getZoom()) : P.getZoom(), X = P.getZoomScale(B, this._tileZoom), ne = P.project(p, this._tileZoom).floor(), ye = P.getSize().divideBy(X * 2);
          return new Gi(ne.subtract(ye), ne.add(ye));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(p) {
          var P = this._map;
          if (P) {
            var B = this._clampZoom(P.getZoom());
            if (p === void 0 && (p = P.getCenter()), this._tileZoom !== void 0) {
              var X = this._getTiledPixelBounds(p), ne = this._pxBoundsToTileRange(X), ye = ne.getCenter(), We = [], at = this.options.keepBuffer, ft = new Gi(
                ne.getBottomLeft().subtract([at, -at]),
                ne.getTopRight().add([at, -at])
              );
              if (!(isFinite(ne.min.x) && isFinite(ne.min.y) && isFinite(ne.max.x) && isFinite(ne.max.y)))
                throw new Error("Attempted to load an infinite number of tiles");
              for (var Rt in this._tiles) {
                var ii = this._tiles[Rt].coords;
                (ii.z !== this._tileZoom || !ft.contains(new fi(ii.x, ii.y))) && (this._tiles[Rt].current = !1);
              }
              if (Math.abs(B - this._tileZoom) > 1) {
                this._setView(p, B);
                return;
              }
              for (var Ci = ne.min.y; Ci <= ne.max.y; Ci++)
                for (var Wi = ne.min.x; Wi <= ne.max.x; Wi++) {
                  var Hs = new fi(Wi, Ci);
                  if (Hs.z = this._tileZoom, !!this._isValidTile(Hs)) {
                    var ws = this._tiles[this._tileCoordsToKey(Hs)];
                    ws ? ws.current = !0 : We.push(Hs);
                  }
                }
              if (We.sort(function(ur, Za) {
                return ur.distanceTo(ye) - Za.distanceTo(ye);
              }), We.length !== 0) {
                this._loading || (this._loading = !0, this.fire("loading"));
                var Rs = document.createDocumentFragment();
                for (Wi = 0; Wi < We.length; Wi++)
                  this._addTile(We[Wi], Rs);
                this._level.el.appendChild(Rs);
              }
            }
          }
        },
        _isValidTile: function(p) {
          var P = this._map.options.crs;
          if (!P.infinite) {
            var B = this._globalTileRange;
            if (!P.wrapLng && (p.x < B.min.x || p.x > B.max.x) || !P.wrapLat && (p.y < B.min.y || p.y > B.max.y))
              return !1;
          }
          if (!this.options.bounds)
            return !0;
          var X = this._tileCoordsToBounds(p);
          return ln(this.options.bounds).overlaps(X);
        },
        _keyToBounds: function(p) {
          return this._tileCoordsToBounds(this._keyToTileCoords(p));
        },
        _tileCoordsToNwSe: function(p) {
          var P = this._map, B = this.getTileSize(), X = p.scaleBy(B), ne = X.add(B), ye = P.unproject(X, p.z), We = P.unproject(ne, p.z);
          return [ye, We];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(p) {
          var P = this._tileCoordsToNwSe(p), B = new qt(P[0], P[1]);
          return this.options.noWrap || (B = this._map.wrapLatLngBounds(B)), B;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(p) {
          return p.x + ":" + p.y + ":" + p.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(p) {
          var P = p.split(":"), B = new fi(+P[0], +P[1]);
          return B.z = +P[2], B;
        },
        _removeTile: function(p) {
          var P = this._tiles[p];
          P && (xn(P.el), delete this._tiles[p], this.fire("tileunload", {
            tile: P.el,
            coords: this._keyToTileCoords(p)
          }));
        },
        _initTile: function(p) {
          Vi(p, "leaflet-tile");
          var P = this.getTileSize();
          p.style.width = P.x + "px", p.style.height = P.y + "px", p.onselectstart = J, p.onmousemove = J, Ae.ielt9 && this.options.opacity < 1 && Qn(p, this.options.opacity);
        },
        _addTile: function(p, P) {
          var B = this._getTilePos(p), X = this._tileCoordsToKey(p), ne = this.createTile(this._wrapCoords(p), E(this._tileReady, this, p));
          this._initTile(ne), this.createTile.length < 2 && At(E(this._tileReady, this, p, null, ne)), Yn(ne, B), this._tiles[X] = {
            el: ne,
            coords: p,
            current: !0
          }, P.appendChild(ne), this.fire("tileloadstart", {
            tile: ne,
            coords: p
          });
        },
        _tileReady: function(p, P, B) {
          P && this.fire("tileerror", {
            error: P,
            tile: B,
            coords: p
          });
          var X = this._tileCoordsToKey(p);
          B = this._tiles[X], B && (B.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (Qn(B.el, 0), Mi(this._fadeFrame), this._fadeFrame = At(this._updateOpacity, this)) : (B.active = !0, this._pruneTiles()), P || (Vi(B.el, "leaflet-tile-loaded"), this.fire("tileload", {
            tile: B.el,
            coords: p
          })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Ae.ielt9 || !this._map._fadeAnimated ? At(this._pruneTiles, this) : setTimeout(E(this._pruneTiles, this), 250)));
        },
        _getTilePos: function(p) {
          return p.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(p) {
          var P = new fi(
            this._wrapX ? Y(p.x, this._wrapX) : p.x,
            this._wrapY ? Y(p.y, this._wrapY) : p.y
          );
          return P.z = p.z, P;
        },
        _pxBoundsToTileRange: function(p) {
          var P = this.getTileSize();
          return new Gi(
            p.min.unscaleBy(P).floor(),
            p.max.unscaleBy(P).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var p in this._tiles)
            if (!this._tiles[p].loaded)
              return !1;
          return !0;
        }
      });
      function xl(p) {
        return new ro(p);
      }
      var kr = ro.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: !1,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: !1,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: !1
        },
        initialize: function(p, P) {
          this._url = p, P = be(this, P), P.detectRetina && Ae.retina && P.maxZoom > 0 ? (P.tileSize = Math.floor(P.tileSize / 2), P.zoomReverse ? (P.zoomOffset--, P.minZoom = Math.min(P.maxZoom, P.minZoom + 1)) : (P.zoomOffset++, P.maxZoom = Math.max(P.minZoom, P.maxZoom - 1)), P.minZoom = Math.max(0, P.minZoom)) : P.zoomReverse ? P.minZoom = Math.min(P.maxZoom, P.minZoom) : P.maxZoom = Math.max(P.minZoom, P.maxZoom), typeof P.subdomains == "string" && (P.subdomains = P.subdomains.split("")), this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(p, P) {
          return this._url === p && P === void 0 && (P = !0), this._url = p, P || this.redraw(), this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(p, P) {
          var B = document.createElement("img");
          return Bi(B, "load", E(this._tileOnLoad, this, P, B)), Bi(B, "error", E(this._tileOnError, this, P, B)), (this.options.crossOrigin || this.options.crossOrigin === "") && (B.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (B.referrerPolicy = this.options.referrerPolicy), B.alt = "", B.src = this.getTileUrl(p), B;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(p) {
          var P = {
            r: Ae.retina ? "@2x" : "",
            s: this._getSubdomain(p),
            x: p.x,
            y: p.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var B = this._globalTileRange.max.y - p.y;
            this.options.tms && (P.y = B), P["-y"] = B;
          }
          return ot(this._url, w(P, this.options));
        },
        _tileOnLoad: function(p, P) {
          Ae.ielt9 ? setTimeout(E(p, this, null, P), 0) : p(null, P);
        },
        _tileOnError: function(p, P, B) {
          var X = this.options.errorTileUrl;
          X && P.getAttribute("src") !== X && (P.src = X), p(B, P);
        },
        _onTileRemove: function(p) {
          p.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var p = this._tileZoom, P = this.options.maxZoom, B = this.options.zoomReverse, X = this.options.zoomOffset;
          return B && (p = P - p), p + X;
        },
        _getSubdomain: function(p) {
          var P = Math.abs(p.x + p.y) % this.options.subdomains.length;
          return this.options.subdomains[P];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var p, P;
          for (p in this._tiles)
            if (this._tiles[p].coords.z !== this._tileZoom && (P = this._tiles[p].el, P.onload = J, P.onerror = J, !P.complete)) {
              P.src = gt;
              var B = this._tiles[p].coords;
              xn(P), delete this._tiles[p], this.fire("tileabort", {
                tile: P,
                coords: B
              });
            }
        },
        _removeTile: function(p) {
          var P = this._tiles[p];
          if (P)
            return P.el.setAttribute("src", gt), ro.prototype._removeTile.call(this, p);
        },
        _tileReady: function(p, P, B) {
          if (!(!this._map || B && B.getAttribute("src") === gt))
            return ro.prototype._tileReady.call(this, p, P, B);
        }
      });
      function oo(p, P) {
        return new kr(p, P);
      }
      var Jo = kr.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: !1,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: !1
        },
        initialize: function(p, P) {
          this._url = p;
          var B = w({}, this.defaultWmsParams);
          for (var X in P)
            X in this.options || (B[X] = P[X]);
          P = be(this, P);
          var ne = P.detectRetina && Ae.retina ? 2 : 1, ye = this.getTileSize();
          B.width = ye.x * ne, B.height = ye.y * ne, this.wmsParams = B;
        },
        onAdd: function(p) {
          this._crs = this.options.crs || p.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
          var P = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[P] = this._crs.code, kr.prototype.onAdd.call(this, p);
        },
        getTileUrl: function(p) {
          var P = this._tileCoordsToNwSe(p), B = this._crs, X = an(B.project(P[0]), B.project(P[1])), ne = X.min, ye = X.max, We = (this._wmsVersion >= 1.3 && this._crs === gl ? [ne.y, ne.x, ye.y, ye.x] : [ne.x, ne.y, ye.x, ye.y]).join(","), at = kr.prototype.getTileUrl.call(this, p);
          return at + Ze(this.wmsParams, at, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + We;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(p, P) {
          return w(this.wmsParams, p), P || this.redraw(), this;
        }
      });
      function Jl(p, P) {
        return new Jo(p, P);
      }
      kr.WMS = Jo, oo.wms = Jl;
      var Qr = ar.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(p) {
          be(this, p), O(this), this._layers = this._layers || {};
        },
        onAdd: function() {
          this._container || (this._initContainer(), Vi(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this), this._destroyContainer();
        },
        getEvents: function() {
          var p = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (p.zoomanim = this._onAnimZoom), p;
        },
        _onAnimZoom: function(p) {
          this._updateTransform(p.center, p.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(p, P) {
          var B = this._map.getZoomScale(P, this._zoom), X = this._map.getSize().multiplyBy(0.5 + this.options.padding), ne = this._map.project(this._center, P), ye = X.multiplyBy(-B).add(ne).subtract(this._map._getNewPixelOrigin(p, P));
          Ae.any3d ? Ks(this._container, ye, B) : Yn(this._container, ye);
        },
        _reset: function() {
          this._update(), this._updateTransform(this._center, this._zoom);
          for (var p in this._layers)
            this._layers[p]._reset();
        },
        _onZoomEnd: function() {
          for (var p in this._layers)
            this._layers[p]._project();
        },
        _updatePaths: function() {
          for (var p in this._layers)
            this._layers[p]._update();
        },
        _update: function() {
          var p = this.options.padding, P = this._map.getSize(), B = this._map.containerPointToLayerPoint(P.multiplyBy(-p)).round();
          this._bounds = new Gi(B, B.add(P.multiplyBy(1 + p * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
        }
      }), vl = Qr.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var p = Qr.prototype.getEvents.call(this);
          return p.viewprereset = this._onViewPreReset, p;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = !0;
        },
        onAdd: function() {
          Qr.prototype.onAdd.call(this), this._draw();
        },
        _initContainer: function() {
          var p = this._container = document.createElement("canvas");
          Bi(p, "mousemove", this._onMouseMove, this), Bi(p, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Bi(p, "mouseout", this._handleMouseOut, this), p._leaflet_disable_events = !0, this._ctx = p.getContext("2d");
        },
        _destroyContainer: function() {
          Mi(this._redrawRequest), delete this._ctx, xn(this._container), Cn(this._container), delete this._container;
        },
        _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
            var p;
            this._redrawBounds = null;
            for (var P in this._layers)
              p = this._layers[P], p._update();
            this._redraw();
          }
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Qr.prototype._update.call(this);
            var p = this._bounds, P = this._container, B = p.getSize(), X = Ae.retina ? 2 : 1;
            Yn(P, p.min), P.width = X * B.x, P.height = X * B.y, P.style.width = B.x + "px", P.style.height = B.y + "px", Ae.retina && this._ctx.scale(2, 2), this._ctx.translate(-p.min.x, -p.min.y), this.fire("update");
          }
        },
        _reset: function() {
          Qr.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
        },
        _initPath: function(p) {
          this._updateDashArray(p), this._layers[O(p)] = p;
          var P = p._order = {
            layer: p,
            prev: this._drawLast,
            next: null
          };
          this._drawLast && (this._drawLast.next = P), this._drawLast = P, this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(p) {
          this._requestRedraw(p);
        },
        _removePath: function(p) {
          var P = p._order, B = P.next, X = P.prev;
          B ? B.prev = X : this._drawLast = X, X ? X.next = B : this._drawFirst = B, delete p._order, delete this._layers[O(p)], this._requestRedraw(p);
        },
        _updatePath: function(p) {
          this._extendRedrawBounds(p), p._project(), p._update(), this._requestRedraw(p);
        },
        _updateStyle: function(p) {
          this._updateDashArray(p), this._requestRedraw(p);
        },
        _updateDashArray: function(p) {
          if (typeof p.options.dashArray == "string") {
            var P = p.options.dashArray.split(/[, ]+/), B = [], X, ne;
            for (ne = 0; ne < P.length; ne++) {
              if (X = Number(P[ne]), isNaN(X))
                return;
              B.push(X);
            }
            p.options._dashArray = B;
          } else
            p.options._dashArray = p.options.dashArray;
        },
        _requestRedraw: function(p) {
          this._map && (this._extendRedrawBounds(p), this._redrawRequest = this._redrawRequest || At(this._redraw, this));
        },
        _extendRedrawBounds: function(p) {
          if (p._pxBounds) {
            var P = (p.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Gi(), this._redrawBounds.extend(p._pxBounds.min.subtract([P, P])), this._redrawBounds.extend(p._pxBounds.max.add([P, P]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
        },
        _clear: function() {
          var p = this._redrawBounds;
          if (p) {
            var P = p.getSize();
            this._ctx.clearRect(p.min.x, p.min.y, P.x, P.y);
          } else
            this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
        },
        _draw: function() {
          var p, P = this._redrawBounds;
          if (this._ctx.save(), P) {
            var B = P.getSize();
            this._ctx.beginPath(), this._ctx.rect(P.min.x, P.min.y, B.x, B.y), this._ctx.clip();
          }
          this._drawing = !0;
          for (var X = this._drawFirst; X; X = X.next)
            p = X.layer, (!P || p._pxBounds && p._pxBounds.intersects(P)) && p._updatePath();
          this._drawing = !1, this._ctx.restore();
        },
        _updatePoly: function(p, P) {
          if (this._drawing) {
            var B, X, ne, ye, We = p._parts, at = We.length, ft = this._ctx;
            if (at) {
              for (ft.beginPath(), B = 0; B < at; B++) {
                for (X = 0, ne = We[B].length; X < ne; X++)
                  ye = We[B][X], ft[X ? "lineTo" : "moveTo"](ye.x, ye.y);
                P && ft.closePath();
              }
              this._fillStroke(ft, p);
            }
          }
        },
        _updateCircle: function(p) {
          if (!(!this._drawing || p._empty())) {
            var P = p._point, B = this._ctx, X = Math.max(Math.round(p._radius), 1), ne = (Math.max(Math.round(p._radiusY), 1) || X) / X;
            ne !== 1 && (B.save(), B.scale(1, ne)), B.beginPath(), B.arc(P.x, P.y / ne, X, 0, Math.PI * 2, !1), ne !== 1 && B.restore(), this._fillStroke(B, p);
          }
        },
        _fillStroke: function(p, P) {
          var B = P.options;
          B.fill && (p.globalAlpha = B.fillOpacity, p.fillStyle = B.fillColor || B.color, p.fill(B.fillRule || "evenodd")), B.stroke && B.weight !== 0 && (p.setLineDash && p.setLineDash(P.options && P.options._dashArray || []), p.globalAlpha = B.opacity, p.lineWidth = B.weight, p.strokeStyle = B.color, p.lineCap = B.lineCap, p.lineJoin = B.lineJoin, p.stroke());
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(p) {
          for (var P = this._map.mouseEventToLayerPoint(p), B, X, ne = this._drawFirst; ne; ne = ne.next)
            B = ne.layer, B.options.interactive && B._containsPoint(P) && (!(p.type === "click" || p.type === "preclick") || !this._map._draggableMoved(B)) && (X = B);
          this._fireEvent(X ? [X] : !1, p);
        },
        _onMouseMove: function(p) {
          if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
            var P = this._map.mouseEventToLayerPoint(p);
            this._handleMouseHover(p, P);
          }
        },
        _handleMouseOut: function(p) {
          var P = this._hoveredLayer;
          P && (Hn(this._container, "leaflet-interactive"), this._fireEvent([P], p, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
        },
        _handleMouseHover: function(p, P) {
          if (!this._mouseHoverThrottled) {
            for (var B, X, ne = this._drawFirst; ne; ne = ne.next)
              B = ne.layer, B.options.interactive && B._containsPoint(P) && (X = B);
            X !== this._hoveredLayer && (this._handleMouseOut(p), X && (Vi(this._container, "leaflet-interactive"), this._fireEvent([X], p, "mouseover"), this._hoveredLayer = X)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, p), this._mouseHoverThrottled = !0, setTimeout(E(function() {
              this._mouseHoverThrottled = !1;
            }, this), 32);
          }
        },
        _fireEvent: function(p, P, B) {
          this._map._fireDOMEvent(P, B || P.type, p);
        },
        _bringToFront: function(p) {
          var P = p._order;
          if (P) {
            var B = P.next, X = P.prev;
            if (B)
              B.prev = X;
            else
              return;
            X ? X.next = B : B && (this._drawFirst = B), P.prev = this._drawLast, this._drawLast.next = P, P.next = null, this._drawLast = P, this._requestRedraw(p);
          }
        },
        _bringToBack: function(p) {
          var P = p._order;
          if (P) {
            var B = P.next, X = P.prev;
            if (X)
              X.next = B;
            else
              return;
            B ? B.prev = X : X && (this._drawLast = X), P.prev = null, P.next = this._drawFirst, this._drawFirst.prev = P, this._drawFirst = P, this._requestRedraw(p);
          }
        }
      });
      function ao(p) {
        return Ae.canvas ? new vl(p) : null;
      }
      var Ti = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(p) {
            return document.createElement("<lvml:" + p + ' class="lvml">');
          };
        } catch {
        }
        return function(p) {
          return document.createElement("<" + p + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), qh = {
        _initContainer: function() {
          this._container = tn("div", "leaflet-vml-container");
        },
        _update: function() {
          this._map._animatingZoom || (Qr.prototype._update.call(this), this.fire("update"));
        },
        _initPath: function(p) {
          var P = p._container = Ti("shape");
          Vi(P, "leaflet-vml-shape " + (this.options.className || "")), P.coordsize = "1 1", p._path = Ti("path"), P.appendChild(p._path), this._updateStyle(p), this._layers[O(p)] = p;
        },
        _addPath: function(p) {
          var P = p._container;
          this._container.appendChild(P), p.options.interactive && p.addInteractiveTarget(P);
        },
        _removePath: function(p) {
          var P = p._container;
          xn(P), p.removeInteractiveTarget(P), delete this._layers[O(p)];
        },
        _updateStyle: function(p) {
          var P = p._stroke, B = p._fill, X = p.options, ne = p._container;
          ne.stroked = !!X.stroke, ne.filled = !!X.fill, X.stroke ? (P || (P = p._stroke = Ti("stroke")), ne.appendChild(P), P.weight = X.weight + "px", P.color = X.color, P.opacity = X.opacity, X.dashArray ? P.dashStyle = vt(X.dashArray) ? X.dashArray.join(" ") : X.dashArray.replace(/( *, *)/g, " ") : P.dashStyle = "", P.endcap = X.lineCap.replace("butt", "flat"), P.joinstyle = X.lineJoin) : P && (ne.removeChild(P), p._stroke = null), X.fill ? (B || (B = p._fill = Ti("fill")), ne.appendChild(B), B.color = X.fillColor || X.color, B.opacity = X.fillOpacity) : B && (ne.removeChild(B), p._fill = null);
        },
        _updateCircle: function(p) {
          var P = p._point.round(), B = Math.round(p._radius), X = Math.round(p._radiusY || B);
          this._setPath(p, p._empty() ? "M0 0" : "AL " + P.x + "," + P.y + " " + B + "," + X + " 0," + 65535 * 360);
        },
        _setPath: function(p, P) {
          p._path.v = P;
        },
        _bringToFront: function(p) {
          Go(p._container);
        },
        _bringToBack: function(p) {
          aa(p._container);
        }
      }, bl = Ae.vml ? Ti : Ws, Ga = Qr.extend({
        _initContainer: function() {
          this._container = bl("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = bl("g"), this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          xn(this._container), Cn(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Qr.prototype._update.call(this);
            var p = this._bounds, P = p.getSize(), B = this._container;
            (!this._svgSize || !this._svgSize.equals(P)) && (this._svgSize = P, B.setAttribute("width", P.x), B.setAttribute("height", P.y)), Yn(B, p.min), B.setAttribute("viewBox", [p.min.x, p.min.y, P.x, P.y].join(" ")), this.fire("update");
          }
        },
        // methods below are called by vector layers implementations
        _initPath: function(p) {
          var P = p._path = bl("path");
          p.options.className && Vi(P, p.options.className), p.options.interactive && Vi(P, "leaflet-interactive"), this._updateStyle(p), this._layers[O(p)] = p;
        },
        _addPath: function(p) {
          this._rootGroup || this._initContainer(), this._rootGroup.appendChild(p._path), p.addInteractiveTarget(p._path);
        },
        _removePath: function(p) {
          xn(p._path), p.removeInteractiveTarget(p._path), delete this._layers[O(p)];
        },
        _updatePath: function(p) {
          p._project(), p._update();
        },
        _updateStyle: function(p) {
          var P = p._path, B = p.options;
          P && (B.stroke ? (P.setAttribute("stroke", B.color), P.setAttribute("stroke-opacity", B.opacity), P.setAttribute("stroke-width", B.weight), P.setAttribute("stroke-linecap", B.lineCap), P.setAttribute("stroke-linejoin", B.lineJoin), B.dashArray ? P.setAttribute("stroke-dasharray", B.dashArray) : P.removeAttribute("stroke-dasharray"), B.dashOffset ? P.setAttribute("stroke-dashoffset", B.dashOffset) : P.removeAttribute("stroke-dashoffset")) : P.setAttribute("stroke", "none"), B.fill ? (P.setAttribute("fill", B.fillColor || B.color), P.setAttribute("fill-opacity", B.fillOpacity), P.setAttribute("fill-rule", B.fillRule || "evenodd")) : P.setAttribute("fill", "none"));
        },
        _updatePoly: function(p, P) {
          this._setPath(p, $n(p._parts, P));
        },
        _updateCircle: function(p) {
          var P = p._point, B = Math.max(Math.round(p._radius), 1), X = Math.max(Math.round(p._radiusY), 1) || B, ne = "a" + B + "," + X + " 0 1,0 ", ye = p._empty() ? "M0 0" : "M" + (P.x - B) + "," + P.y + ne + B * 2 + ",0 " + ne + -B * 2 + ",0 ";
          this._setPath(p, ye);
        },
        _setPath: function(p, P) {
          p._path.setAttribute("d", P);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(p) {
          Go(p._path);
        },
        _bringToBack: function(p) {
          aa(p._path);
        }
      });
      Ae.vml && Ga.include(qh);
      function Qo(p) {
        return Ae.svg || Ae.vml ? new Ga(p) : null;
      }
      nn.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(p) {
          var P = p.options.renderer || this._getPaneRenderer(p.options.pane) || this.options.renderer || this._renderer;
          return P || (P = this._renderer = this._createRenderer()), this.hasLayer(P) || this.addLayer(P), P;
        },
        _getPaneRenderer: function(p) {
          if (p === "overlayPane" || p === void 0)
            return !1;
          var P = this._paneRenderers[p];
          return P === void 0 && (P = this._createRenderer({ pane: p }), this._paneRenderers[p] = P), P;
        },
        _createRenderer: function(p) {
          return this.options.preferCanvas && ao(p) || Qo(p);
        }
      });
      var qc = Kr.extend({
        initialize: function(p, P) {
          Kr.prototype.initialize.call(this, this._boundsToLatLngs(p), P);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(p) {
          return this.setLatLngs(this._boundsToLatLngs(p));
        },
        _boundsToLatLngs: function(p) {
          return p = ln(p), [
            p.getSouthWest(),
            p.getNorthWest(),
            p.getNorthEast(),
            p.getSouthEast()
          ];
        }
      });
      function gn(p, P) {
        return new qc(p, P);
      }
      Ga.create = bl, Ga.pointsToPath = $n, cr.geometryToLayer = Eo, cr.coordsToLatLng = Uc, cr.coordsToLatLngs = Ua, cr.latLngToCoords = $l, cr.latLngsToCoords = yl, cr.getFeature = _a, cr.asFeature = ga, nn.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: !0
      });
      var Wh = Es.extend({
        initialize: function(p) {
          this._map = p, this._container = p._container, this._pane = p._panes.overlayPane, this._resetStateTimeout = 0, p.on("unload", this._destroy, this);
        },
        addHooks: function() {
          Bi(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          Cn(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          xn(this._pane), delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0, this._moved = !1;
        },
        _clearDeferredResetState: function() {
          this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
        },
        _onMouseDown: function(p) {
          if (!p.shiftKey || p.which !== 1 && p.button !== 1)
            return !1;
          this._clearDeferredResetState(), this._resetState(), Pr(), Zo(), this._startPoint = this._map.mouseEventToContainerPoint(p), Bi(document, {
            contextmenu: Js,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(p) {
          this._moved || (this._moved = !0, this._box = tn("div", "leaflet-zoom-box", this._container), Vi(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(p);
          var P = new Gi(this._point, this._startPoint), B = P.getSize();
          Yn(this._box, P.min), this._box.style.width = B.x + "px", this._box.style.height = B.y + "px";
        },
        _finish: function() {
          this._moved && (xn(this._box), Hn(this._container, "leaflet-crosshair")), Cr(), sr(), Cn(document, {
            contextmenu: Js,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(p) {
          if (!(p.which !== 1 && p.button !== 1) && (this._finish(), !!this._moved)) {
            this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(E(this._resetState, this), 0);
            var P = new qt(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(P).fire("boxzoomend", { boxZoomBounds: P });
          }
        },
        _onKeyDown: function(p) {
          p.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
        }
      });
      nn.addInitHook("addHandler", "boxZoom", Wh), nn.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: !0
      });
      var $h = Es.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(p) {
          var P = this._map, B = P.getZoom(), X = P.options.zoomDelta, ne = p.originalEvent.shiftKey ? B - X : B + X;
          P.options.doubleClickZoom === "center" ? P.setZoom(ne) : P.setZoomAround(p.containerPoint, ne);
        }
      });
      nn.addInitHook("addHandler", "doubleClickZoom", $h), nn.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: !0,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: !0,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second.
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: 1 / 0,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: !1,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Ql = Es.extend({
        addHooks: function() {
          if (!this._draggable) {
            var p = this._map;
            this._draggable = new Wo(p._mapPane, p._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), p.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), p.on("zoomend", this._onZoomEnd, this), p.whenReady(this._onZoomEnd, this));
          }
          Vi(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
        },
        removeHooks: function() {
          Hn(this._map._container, "leaflet-grab"), Hn(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var p = this._map;
          if (p._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var P = ln(this._map.options.maxBounds);
            this._offsetLimit = an(
              this._map.latLngToContainerPoint(P.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(P.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else
            this._offsetLimit = null;
          p.fire("movestart").fire("dragstart"), p.options.inertia && (this._positions = [], this._times = []);
        },
        _onDrag: function(p) {
          if (this._map.options.inertia) {
            var P = this._lastTime = +/* @__PURE__ */ new Date(), B = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(B), this._times.push(P), this._prunePositions(P);
          }
          this._map.fire("move", p).fire("drag", p);
        },
        _prunePositions: function(p) {
          for (; this._positions.length > 1 && p - this._times[0] > 50; )
            this._positions.shift(), this._times.shift();
        },
        _onZoomEnd: function() {
          var p = this._map.getSize().divideBy(2), P = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = P.subtract(p).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(p, P) {
          return p - (p - P) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!(!this._viscosity || !this._offsetLimit)) {
            var p = this._draggable._newPos.subtract(this._draggable._startPos), P = this._offsetLimit;
            p.x < P.min.x && (p.x = this._viscousLimit(p.x, P.min.x)), p.y < P.min.y && (p.y = this._viscousLimit(p.y, P.min.y)), p.x > P.max.x && (p.x = this._viscousLimit(p.x, P.max.x)), p.y > P.max.y && (p.y = this._viscousLimit(p.y, P.max.y)), this._draggable._newPos = this._draggable._startPos.add(p);
          }
        },
        _onPreDragWrap: function() {
          var p = this._worldWidth, P = Math.round(p / 2), B = this._initialWorldOffset, X = this._draggable._newPos.x, ne = (X - P + B) % p + P - B, ye = (X + P + B) % p - P - B, We = Math.abs(ne + B) < Math.abs(ye + B) ? ne : ye;
          this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = We;
        },
        _onDragEnd: function(p) {
          var P = this._map, B = P.options, X = !B.inertia || p.noInertia || this._times.length < 2;
          if (P.fire("dragend", p), X)
            P.fire("moveend");
          else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var ne = this._lastPos.subtract(this._positions[0]), ye = (this._lastTime - this._times[0]) / 1e3, We = B.easeLinearity, at = ne.multiplyBy(We / ye), ft = at.distanceTo([0, 0]), Rt = Math.min(B.inertiaMaxSpeed, ft), ii = at.multiplyBy(Rt / ft), Ci = Rt / (B.inertiaDeceleration * We), Wi = ii.multiplyBy(-Ci / 2).round();
            !Wi.x && !Wi.y ? P.fire("moveend") : (Wi = P._limitOffset(Wi, P.options.maxBounds), At(function() {
              P.panBy(Wi, {
                duration: Ci,
                easeLinearity: We,
                noMoveStart: !0,
                animate: !0
              });
            }));
          }
        }
      });
      nn.addInitHook("addHandler", "dragging", Ql), nn.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: !0,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var ec = Es.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(p) {
          this._map = p, this._setPanDelta(p.options.keyboardPanDelta), this._setZoomDelta(p.options.zoomDelta);
        },
        addHooks: function() {
          var p = this._map._container;
          p.tabIndex <= 0 && (p.tabIndex = "0"), Bi(p, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks(), Cn(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (!this._focused) {
            var p = document.body, P = document.documentElement, B = p.scrollTop || P.scrollTop, X = p.scrollLeft || P.scrollLeft;
            this._map._container.focus(), window.scrollTo(X, B);
          }
        },
        _onFocus: function() {
          this._focused = !0, this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = !1, this._map.fire("blur");
        },
        _setPanDelta: function(p) {
          var P = this._panKeys = {}, B = this.keyCodes, X, ne;
          for (X = 0, ne = B.left.length; X < ne; X++)
            P[B.left[X]] = [-1 * p, 0];
          for (X = 0, ne = B.right.length; X < ne; X++)
            P[B.right[X]] = [p, 0];
          for (X = 0, ne = B.down.length; X < ne; X++)
            P[B.down[X]] = [0, p];
          for (X = 0, ne = B.up.length; X < ne; X++)
            P[B.up[X]] = [0, -1 * p];
        },
        _setZoomDelta: function(p) {
          var P = this._zoomKeys = {}, B = this.keyCodes, X, ne;
          for (X = 0, ne = B.zoomIn.length; X < ne; X++)
            P[B.zoomIn[X]] = p;
          for (X = 0, ne = B.zoomOut.length; X < ne; X++)
            P[B.zoomOut[X]] = -p;
        },
        _addHooks: function() {
          Bi(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          Cn(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(p) {
          if (!(p.altKey || p.ctrlKey || p.metaKey)) {
            var P = p.keyCode, B = this._map, X;
            if (P in this._panKeys) {
              if (!B._panAnim || !B._panAnim._inProgress)
                if (X = this._panKeys[P], p.shiftKey && (X = ni(X).multiplyBy(3)), B.options.maxBounds && (X = B._limitOffset(ni(X), B.options.maxBounds)), B.options.worldCopyJump) {
                  var ne = B.wrapLatLng(B.unproject(B.project(B.getCenter()).add(X)));
                  B.panTo(ne);
                } else
                  B.panBy(X);
            } else if (P in this._zoomKeys)
              B.setZoom(B.getZoom() + (p.shiftKey ? 3 : 1) * this._zoomKeys[P]);
            else if (P === 27 && B._popup && B._popup.options.closeOnEscapeKey)
              B.closePopup();
            else
              return;
            Js(p);
          }
        }
      });
      nn.addInitHook("addHandler", "keyboard", ec), nn.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: !0,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var tc = Es.extend({
        addHooks: function() {
          Bi(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
        },
        removeHooks: function() {
          Cn(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(p) {
          var P = Bc(p), B = this._map.options.wheelDebounceTime;
          this._delta += P, this._lastMousePos = this._map.mouseEventToContainerPoint(p), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
          var X = Math.max(B - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer), this._timer = setTimeout(E(this._performZoom, this), X), Js(p);
        },
        _performZoom: function() {
          var p = this._map, P = p.getZoom(), B = this._map.options.zoomSnap || 0;
          p._stop();
          var X = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), ne = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(X)))) / Math.LN2, ye = B ? Math.ceil(ne / B) * B : ne, We = p._limitZoom(P + (this._delta > 0 ? ye : -ye)) - P;
          this._delta = 0, this._startTime = null, We && (p.options.scrollWheelZoom === "center" ? p.setZoom(P + We) : p.setZoomAround(this._lastMousePos, P + We));
        }
      });
      nn.addInitHook("addHandler", "scrollWheelZoom", tc);
      var Wc = 600;
      nn.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Ae.touchNative && Ae.safari && Ae.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var $c = Es.extend({
        addHooks: function() {
          Bi(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          Cn(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(p) {
          if (clearTimeout(this._holdTimeout), p.touches.length === 1) {
            var P = p.touches[0];
            this._startPos = this._newPos = new fi(P.clientX, P.clientY), this._holdTimeout = setTimeout(E(function() {
              this._cancel(), this._isTapValid() && (Bi(document, "touchend", _s), Bi(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", P));
            }, this), Wc), Bi(document, "touchend touchcancel contextmenu", this._cancel, this), Bi(document, "touchmove", this._onMove, this);
          }
        },
        _cancelClickPrevent: function p() {
          Cn(document, "touchend", _s), Cn(document, "touchend touchcancel", p);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout), Cn(document, "touchend touchcancel contextmenu", this._cancel, this), Cn(document, "touchmove", this._onMove, this);
        },
        _onMove: function(p) {
          var P = p.touches[0];
          this._newPos = new fi(P.clientX, P.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(p, P) {
          var B = new MouseEvent(p, {
            bubbles: !0,
            cancelable: !0,
            view: window,
            // detail: 1,
            screenX: P.screenX,
            screenY: P.screenY,
            clientX: P.clientX,
            clientY: P.clientY
            // button: 2,
            // buttons: 2
          });
          B._simulated = !0, P.target.dispatchEvent(B);
        }
      });
      nn.addInitHook("addHandler", "tapHold", $c), nn.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Ae.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: !0
      });
      var Xc = Es.extend({
        addHooks: function() {
          Vi(this._map._container, "leaflet-touch-zoom"), Bi(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          Hn(this._map._container, "leaflet-touch-zoom"), Cn(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(p) {
          var P = this._map;
          if (!(!p.touches || p.touches.length !== 2 || P._animatingZoom || this._zooming)) {
            var B = P.mouseEventToContainerPoint(p.touches[0]), X = P.mouseEventToContainerPoint(p.touches[1]);
            this._centerPoint = P.getSize()._divideBy(2), this._startLatLng = P.containerPointToLatLng(this._centerPoint), P.options.touchZoom !== "center" && (this._pinchStartLatLng = P.containerPointToLatLng(B.add(X)._divideBy(2))), this._startDist = B.distanceTo(X), this._startZoom = P.getZoom(), this._moved = !1, this._zooming = !0, P._stop(), Bi(document, "touchmove", this._onTouchMove, this), Bi(document, "touchend touchcancel", this._onTouchEnd, this), _s(p);
          }
        },
        _onTouchMove: function(p) {
          if (!(!p.touches || p.touches.length !== 2 || !this._zooming)) {
            var P = this._map, B = P.mouseEventToContainerPoint(p.touches[0]), X = P.mouseEventToContainerPoint(p.touches[1]), ne = B.distanceTo(X) / this._startDist;
            if (this._zoom = P.getScaleZoom(ne, this._startZoom), !P.options.bounceAtZoomLimits && (this._zoom < P.getMinZoom() && ne < 1 || this._zoom > P.getMaxZoom() && ne > 1) && (this._zoom = P._limitZoom(this._zoom)), P.options.touchZoom === "center") {
              if (this._center = this._startLatLng, ne === 1)
                return;
            } else {
              var ye = B._add(X)._divideBy(2)._subtract(this._centerPoint);
              if (ne === 1 && ye.x === 0 && ye.y === 0)
                return;
              this._center = P.unproject(P.project(this._pinchStartLatLng, this._zoom).subtract(ye), this._zoom);
            }
            this._moved || (P._moveStart(!0, !1), this._moved = !0), Mi(this._animRequest);
            var We = E(P._move, P, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
            this._animRequest = At(We, this, !0), _s(p);
          }
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = !1;
            return;
          }
          this._zooming = !1, Mi(this._animRequest), Cn(document, "touchmove", this._onTouchMove, this), Cn(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      });
      nn.addInitHook("addHandler", "touchZoom", Xc), nn.BoxZoom = Wh, nn.DoubleClickZoom = $h, nn.Drag = Ql, nn.Keyboard = ec, nn.ScrollWheelZoom = tc, nn.TapHold = $c, nn.TouchZoom = Xc, d.Bounds = Gi, d.Browser = Ae, d.CRS = Cs, d.Canvas = vl, d.Circle = gs, d.CircleMarker = ma, d.Class = hn, d.Control = Dn, d.DivIcon = Kl, d.DivOverlay = xr, d.DomEvent = Zl, d.DomUtil = Oi, d.Draggable = Wo, d.Evented = Ji, d.FeatureGroup = Xr, d.GeoJSON = cr, d.GridLayer = ro, d.Handler = Es, d.Icon = Yr, d.ImageOverlay = ja, d.LatLng = Di, d.LatLngBounds = qt, d.Layer = ar, d.LayerGroup = lr, d.LineUtil = ed, d.Map = nn, d.Marker = ks, d.Mixin = Oa, d.Path = Tt, d.Point = fi, d.PolyUtil = or, d.Polygon = Kr, d.Polyline = Dr, d.Popup = Ko, d.PosAnimation = da, d.Projection = bi, d.Rectangle = qc, d.Renderer = Qr, d.SVG = Ga, d.SVGOverlay = Zc, d.TileLayer = kr, d.Tooltip = Jr, d.Transformation = Vs, d.Util = An, d.VideoOverlay = Gc, d.bind = E, d.bounds = an, d.canvas = ao, d.circle = Gh, d.circleMarker = Mo, d.control = rr, d.divIcon = ya, d.extend = w, d.featureGroup = ql, d.geoJSON = Hh, d.geoJson = td, d.gridLayer = xl, d.icon = Va, d.imageOverlay = jc, d.latLng = xi, d.latLngBounds = ln, d.layerGroup = ti, d.map = dl, d.marker = Wl, d.point = ni, d.polygon = Yo, d.polyline = So, d.popup = Xl, d.rectangle = gn, d.setOptions = be, d.stamp = O, d.svg = Qo, d.svgOverlay = Hc, d.tileLayer = oo, d.tooltip = Yl, d.transformation = Us, d.version = g, d.videoOverlay = hr;
      var id = window.L;
      d.noConflict = function() {
        return window.L = id, this;
      }, window.L = d;
    });
  }(Sm, Sm.exports)), Sm.exports;
}
var AC = yw();
const wn = /* @__PURE__ */ gw(AC);
var PC = { exports: {} };
(function(m) {
  (function(a, d) {
    m.exports ? m.exports = d(yw()) : d(a.L);
  })(typeof self < "u" ? self : Km, (a) => {
    if (typeof document > "u")
      return console.warn('"window.document" is undefined; leaflet.fullscreen requires this object to access the DOM'), !1;
    const d = (() => {
      const b = [
        // Standard
        [
          "requestFullscreen",
          "exitFullscreen",
          "fullscreenElement",
          "fullscreenEnabled",
          "fullscreenchange",
          "fullscreenerror"
        ],
        // New WebKit
        [
          "webkitRequestFullscreen",
          "webkitExitFullscreen",
          "webkitFullscreenElement",
          "webkitFullscreenEnabled",
          "webkitfullscreenchange",
          "webkitfullscreenerror"
        ]
      ], E = b[0], i = {};
      for (const O of b)
        if (O[1] in document) {
          for (let j = 0; j < O.length; j++)
            i[E[j]] = O[j];
          return i;
        }
      return !1;
    })(), g = {
      change: d.fullscreenchange,
      error: d.fullscreenerror
    }, w = {
      request(b, E) {
        return new Promise((i, O) => {
          const j = (function() {
            this.off("change", j), i();
          }).bind(this);
          this.on("change", j), b = b || document.documentElement;
          const Y = b[d.requestFullscreen](E);
          Y instanceof Promise && Y.then(j).catch(O);
        });
      },
      exit() {
        return new Promise((b, E) => {
          if (!this.isFullscreen) {
            b();
            return;
          }
          const i = (function() {
            this.off("change", i), b();
          }).bind(this);
          this.on("change", i);
          const O = document[d.exitFullscreen]();
          O instanceof Promise && O.then(i).catch(E);
        });
      },
      on(b, E) {
        const i = g[b];
        i && document.addEventListener(i, E, !1);
      },
      off(b, E) {
        const i = g[b];
        i && document.removeEventListener(i, E, !1);
      },
      nativeAPI: d
    };
    return Object.defineProperties(w, {
      isFullscreen: {
        get() {
          return !!document[d.fullscreenElement];
        }
      },
      isEnabled: {
        enumerable: !0,
        get() {
          return !!document[d.fullscreenEnabled];
        }
      }
    }), a.Control.FullScreen = a.Control.extend({
      options: {
        position: "topleft",
        title: "Full Screen",
        titleCancel: "Exit Full Screen",
        forceSeparateButton: !1,
        forcePseudoFullscreen: !1,
        fullscreenElement: !1
      },
      _screenfull: w,
      onAdd(b) {
        let E = "leaflet-control-zoom-fullscreen", i, O = "";
        return b.zoomControl && !this.options.forceSeparateButton ? i = b.zoomControl._container : i = a.DomUtil.create("div", "leaflet-bar"), this.options.content ? O = this.options.content : E += " fullscreen-icon", this._createButton(this.options.title, E, O, i, this.toggleFullScreen, this), this._map.fullscreenControl = this, this._map.on("enterFullscreen exitFullscreen", this._toggleState, this), i;
      },
      onRemove() {
        a.DomEvent.off(this.link, "click", a.DomEvent.stop).off(this.link, "click", this.toggleFullScreen, this), this._screenfull.isEnabled && (a.DomEvent.off(this._container, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).off(this._container, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this), a.DomEvent.off(document, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).off(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this));
      },
      _createButton(b, E, i, O, j, Y) {
        return this.link = a.DomUtil.create("a", E, O), this.link.href = "#", this.link.title = b, this.link.innerHTML = i, this.link.setAttribute("role", "button"), this.link.setAttribute("aria-label", b), L.DomEvent.disableClickPropagation(O), a.DomEvent.on(this.link, "click", a.DomEvent.stop).on(this.link, "click", j, Y), this._screenfull.isEnabled && (a.DomEvent.on(O, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).on(O, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, Y), a.DomEvent.on(document, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).on(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, Y)), this.link;
      },
      toggleFullScreen() {
        const b = this._map;
        b._exitFired = !1, b._isFullscreen ? (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.exit().then(() => b.invalidateSize()) : (a.DomUtil.removeClass(this.options.fullscreenElement ? this.options.fullscreenElement : b._container, "leaflet-pseudo-fullscreen"), b.invalidateSize()), b.fire("exitFullscreen"), b._exitFired = !0, b._isFullscreen = !1) : (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.request(this.options.fullscreenElement ? this.options.fullscreenElement : b._container).then(() => b.invalidateSize()) : (a.DomUtil.addClass(this.options.fullscreenElement ? this.options.fullscreenElement : b._container, "leaflet-pseudo-fullscreen"), b.invalidateSize()), b.fire("enterFullscreen"), b._isFullscreen = !0);
      },
      _toggleState() {
        this.link.title = this._map._isFullscreen ? this.options.title : this.options.titleCancel, this._map._isFullscreen ? L.DomUtil.removeClass(this.link, "leaflet-fullscreen-on") : L.DomUtil.addClass(this.link, "leaflet-fullscreen-on");
      },
      _handleFullscreenChange(b) {
        const E = this._map;
        b.target === E.getContainer() && !this._screenfull.isFullscreen && !E._exitFired && (this._screenfull.exit().then(() => E.invalidateSize()), E.fire("exitFullscreen"), E._exitFired = !0, E._isFullscreen = !1);
      }
    }), a.Map.include({
      toggleFullscreen() {
        this.fullscreenControl.toggleFullScreen();
      }
    }), a.Map.addInitHook(function() {
      this.options.fullscreenControl && this.addControl(a.control.fullscreen(this.options.fullscreenControlOptions));
    }), a.control.fullscreen = function(b) {
      return new a.Control.FullScreen(b);
    }, { leaflet: a };
  });
})(PC);
var gb = { exports: {} };
(function(m, a) {
  (function(d, g) {
    g(a);
  })(Km, function(d) {
    var g = L.MarkerClusterGroup = L.FeatureGroup.extend({
      options: {
        maxClusterRadius: 80,
        //A cluster will cover at most this many pixels from its center
        iconCreateFunction: null,
        clusterPane: L.Marker.prototype.options.pane,
        spiderfyOnEveryZoom: !1,
        spiderfyOnMaxZoom: !0,
        showCoverageOnHover: !0,
        zoomToBoundsOnClick: !0,
        singleMarkerMode: !1,
        disableClusteringAtZoom: null,
        // Setting this to false prevents the removal of any clusters outside of the viewpoint, which
        // is the default behaviour for performance reasons.
        removeOutsideVisibleBounds: !0,
        // Set to false to disable all animations (zoom and spiderfy).
        // If false, option animateAddingMarkers below has no effect.
        // If L.DomUtil.TRANSITION is falsy, this option has no effect.
        animate: !0,
        //Whether to animate adding markers after adding the MarkerClusterGroup to the map
        // If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
        animateAddingMarkers: !1,
        // Make it possible to provide custom function to calculate spiderfy shape positions
        spiderfyShapePositions: null,
        //Increase to increase the distance away that spiderfied markers appear from the center
        spiderfyDistanceMultiplier: 1,
        // Make it possible to specify a polyline options on a spider leg
        spiderLegPolylineOptions: { weight: 1.5, color: "#222", opacity: 0.5 },
        // When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
        chunkedLoading: !1,
        chunkInterval: 200,
        // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
        chunkDelay: 50,
        // at the end of each interval, give n milliseconds back to system/browser
        chunkProgress: null,
        // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)
        //Options to pass to the L.Polygon constructor
        polygonOptions: {}
      },
      initialize: function(b) {
        L.Util.setOptions(this, b), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
          dragstart: this._childMarkerDragStart,
          move: this._childMarkerMoved,
          dragend: this._childMarkerDragEnd
        };
        var E = L.DomUtil.TRANSITION && this.options.animate;
        L.extend(this, E ? this._withAnimation : this._noAnimation), this._markerCluster = E ? L.MarkerCluster : L.MarkerClusterNonAnimated;
      },
      addLayer: function(b) {
        if (b instanceof L.LayerGroup)
          return this.addLayers([b]);
        if (!b.getLatLng)
          return this._nonPointGroup.addLayer(b), this.fire("layeradd", { layer: b }), this;
        if (!this._map)
          return this._needsClustering.push(b), this.fire("layeradd", { layer: b }), this;
        if (this.hasLayer(b))
          return this;
        this._unspiderfy && this._unspiderfy(), this._addLayer(b, this._maxZoom), this.fire("layeradd", { layer: b }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
        var E = b, i = this._zoom;
        if (b.__parent)
          for (; E.__parent._zoom >= i; )
            E = E.__parent;
        return this._currentShownBounds.contains(E.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(b, E) : this._animationAddLayerNonAnimated(b, E)), this;
      },
      removeLayer: function(b) {
        return b instanceof L.LayerGroup ? this.removeLayers([b]) : b.getLatLng ? this._map ? b.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(b)), this._removeLayer(b, !0), this.fire("layerremove", { layer: b }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), b.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(b) && (this._featureGroup.removeLayer(b), b.clusterShow && b.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, b) && this.hasLayer(b) && this._needsRemoving.push({ layer: b, latlng: b._latlng }), this.fire("layerremove", { layer: b }), this) : (this._nonPointGroup.removeLayer(b), this.fire("layerremove", { layer: b }), this);
      },
      //Takes an array of markers and adds them in bulk
      addLayers: function(b, E) {
        if (!L.Util.isArray(b))
          return this.addLayer(b);
        var i = this._featureGroup, O = this._nonPointGroup, j = this.options.chunkedLoading, Y = this.options.chunkInterval, J = this.options.chunkProgress, ae = b.length, ce = 0, Te = !0, be;
        if (this._map) {
          var Ze = (/* @__PURE__ */ new Date()).getTime(), je = L.bind(function() {
            var vt = (/* @__PURE__ */ new Date()).getTime();
            for (this._map && this._unspiderfy && this._unspiderfy(); ce < ae; ce++) {
              if (j && ce % 200 === 0) {
                var ht = (/* @__PURE__ */ new Date()).getTime() - vt;
                if (ht > Y)
                  break;
              }
              if (be = b[ce], be instanceof L.LayerGroup) {
                Te && (b = b.slice(), Te = !1), this._extractNonGroupLayers(be, b), ae = b.length;
                continue;
              }
              if (!be.getLatLng) {
                O.addLayer(be), E || this.fire("layeradd", { layer: be });
                continue;
              }
              if (!this.hasLayer(be) && (this._addLayer(be, this._maxZoom), E || this.fire("layeradd", { layer: be }), be.__parent && be.__parent.getChildCount() === 2)) {
                var gt = be.__parent.getAllChildMarkers(), Vt = gt[0] === be ? gt[1] : gt[0];
                i.removeLayer(Vt);
              }
            }
            J && J(ce, ae, (/* @__PURE__ */ new Date()).getTime() - Ze), ce === ae ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(je, this.options.chunkDelay);
          }, this);
          je();
        } else
          for (var ot = this._needsClustering; ce < ae; ce++) {
            if (be = b[ce], be instanceof L.LayerGroup) {
              Te && (b = b.slice(), Te = !1), this._extractNonGroupLayers(be, b), ae = b.length;
              continue;
            }
            if (!be.getLatLng) {
              O.addLayer(be);
              continue;
            }
            this.hasLayer(be) || ot.push(be);
          }
        return this;
      },
      //Takes an array of markers and removes them in bulk
      removeLayers: function(b) {
        var E, i, O = b.length, j = this._featureGroup, Y = this._nonPointGroup, J = !0;
        if (!this._map) {
          for (E = 0; E < O; E++) {
            if (i = b[E], i instanceof L.LayerGroup) {
              J && (b = b.slice(), J = !1), this._extractNonGroupLayers(i, b), O = b.length;
              continue;
            }
            this._arraySplice(this._needsClustering, i), Y.removeLayer(i), this.hasLayer(i) && this._needsRemoving.push({ layer: i, latlng: i._latlng }), this.fire("layerremove", { layer: i });
          }
          return this;
        }
        if (this._unspiderfy) {
          this._unspiderfy();
          var ae = b.slice(), ce = O;
          for (E = 0; E < ce; E++) {
            if (i = ae[E], i instanceof L.LayerGroup) {
              this._extractNonGroupLayers(i, ae), ce = ae.length;
              continue;
            }
            this._unspiderfyLayer(i);
          }
        }
        for (E = 0; E < O; E++) {
          if (i = b[E], i instanceof L.LayerGroup) {
            J && (b = b.slice(), J = !1), this._extractNonGroupLayers(i, b), O = b.length;
            continue;
          }
          if (!i.__parent) {
            Y.removeLayer(i), this.fire("layerremove", { layer: i });
            continue;
          }
          this._removeLayer(i, !0, !0), this.fire("layerremove", { layer: i }), j.hasLayer(i) && (j.removeLayer(i), i.clusterShow && i.clusterShow());
        }
        return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this;
      },
      //Removes all layers from the MarkerClusterGroup
      clearLayers: function() {
        return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(b) {
          b.off(this._childMarkerEventHandlers, this), delete b.__parent;
        }, this), this._map && this._generateInitialClusters(), this;
      },
      //Override FeatureGroup.getBounds as it doesn't work
      getBounds: function() {
        var b = new L.LatLngBounds();
        this._topClusterLevel && b.extend(this._topClusterLevel._bounds);
        for (var E = this._needsClustering.length - 1; E >= 0; E--)
          b.extend(this._needsClustering[E].getLatLng());
        return b.extend(this._nonPointGroup.getBounds()), b;
      },
      //Overrides LayerGroup.eachLayer
      eachLayer: function(b, E) {
        var i = this._needsClustering.slice(), O = this._needsRemoving, j, Y, J;
        for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(i), Y = i.length - 1; Y >= 0; Y--) {
          for (j = !0, J = O.length - 1; J >= 0; J--)
            if (O[J].layer === i[Y]) {
              j = !1;
              break;
            }
          j && b.call(E, i[Y]);
        }
        this._nonPointGroup.eachLayer(b, E);
      },
      //Overrides LayerGroup.getLayers
      getLayers: function() {
        var b = [];
        return this.eachLayer(function(E) {
          b.push(E);
        }), b;
      },
      //Overrides LayerGroup.getLayer, WARNING: Really bad performance
      getLayer: function(b) {
        var E = null;
        return b = parseInt(b, 10), this.eachLayer(function(i) {
          L.stamp(i) === b && (E = i);
        }), E;
      },
      //Returns true if the given layer is in this MarkerClusterGroup
      hasLayer: function(b) {
        if (!b)
          return !1;
        var E, i = this._needsClustering;
        for (E = i.length - 1; E >= 0; E--)
          if (i[E] === b)
            return !0;
        for (i = this._needsRemoving, E = i.length - 1; E >= 0; E--)
          if (i[E].layer === b)
            return !1;
        return !!(b.__parent && b.__parent._group === this) || this._nonPointGroup.hasLayer(b);
      },
      //Zoom down to show the given layer (spiderfying if necessary) then calls the callback
      zoomToShowLayer: function(b, E) {
        var i = this._map;
        typeof E != "function" && (E = function() {
        });
        var O = function() {
          (i.hasLayer(b) || i.hasLayer(b.__parent)) && !this._inZoomAnimation && (this._map.off("moveend", O, this), this.off("animationend", O, this), i.hasLayer(b) ? E() : b.__parent._icon && (this.once("spiderfied", E, this), b.__parent.spiderfy()));
        };
        b._icon && this._map.getBounds().contains(b.getLatLng()) ? E() : b.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", O, this), this._map.panTo(b.getLatLng())) : (this._map.on("moveend", O, this), this.on("animationend", O, this), b.__parent.zoomToBounds());
      },
      //Overrides FeatureGroup.onAdd
      onAdd: function(b) {
        this._map = b;
        var E, i, O;
        if (!isFinite(this._map.getMaxZoom()))
          throw "Map has no maxZoom specified";
        for (this._featureGroup.addTo(b), this._nonPointGroup.addTo(b), this._gridClusters || this._generateInitialClusters(), this._maxLat = b.options.crs.projection.MAX_LATITUDE, E = 0, i = this._needsRemoving.length; E < i; E++)
          O = this._needsRemoving[E], O.newlatlng = O.layer._latlng, O.layer._latlng = O.latlng;
        for (E = 0, i = this._needsRemoving.length; E < i; E++)
          O = this._needsRemoving[E], this._removeLayer(O.layer, !0), O.layer._latlng = O.newlatlng;
        this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), i = this._needsClustering, this._needsClustering = [], this.addLayers(i, !0);
      },
      //Overrides FeatureGroup.onRemove
      onRemove: function(b) {
        b.off("zoomend", this._zoomEnd, this), b.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null;
      },
      getVisibleParent: function(b) {
        for (var E = b; E && !E._icon; )
          E = E.__parent;
        return E || null;
      },
      //Remove the given object from the given array
      _arraySplice: function(b, E) {
        for (var i = b.length - 1; i >= 0; i--)
          if (b[i] === E)
            return b.splice(i, 1), !0;
      },
      /**
       * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
       * @param marker to be removed from _gridUnclustered.
       * @param z integer bottom start zoom level (included)
       * @private
       */
      _removeFromGridUnclustered: function(b, E) {
        for (var i = this._map, O = this._gridUnclustered, j = Math.floor(this._map.getMinZoom()); E >= j && O[E].removeObject(b, i.project(b.getLatLng(), E)); E--)
          ;
      },
      _childMarkerDragStart: function(b) {
        b.target.__dragStart = b.target._latlng;
      },
      _childMarkerMoved: function(b) {
        if (!this._ignoreMove && !b.target.__dragStart) {
          var E = b.target._popup && b.target._popup.isOpen();
          this._moveChild(b.target, b.oldLatLng, b.latlng), E && b.target.openPopup();
        }
      },
      _moveChild: function(b, E, i) {
        b._latlng = E, this.removeLayer(b), b._latlng = i, this.addLayer(b);
      },
      _childMarkerDragEnd: function(b) {
        var E = b.target.__dragStart;
        delete b.target.__dragStart, E && this._moveChild(b.target, E, b.target._latlng);
      },
      //Internal function for removing a marker from everything.
      //dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
      _removeLayer: function(b, E, i) {
        var O = this._gridClusters, j = this._gridUnclustered, Y = this._featureGroup, J = this._map, ae = Math.floor(this._map.getMinZoom());
        E && this._removeFromGridUnclustered(b, this._maxZoom);
        var ce = b.__parent, Te = ce._markers, be;
        for (this._arraySplice(Te, b); ce && (ce._childCount--, ce._boundsNeedUpdate = !0, !(ce._zoom < ae)); )
          E && ce._childCount <= 1 ? (be = ce._markers[0] === b ? ce._markers[1] : ce._markers[0], O[ce._zoom].removeObject(ce, J.project(ce._cLatLng, ce._zoom)), j[ce._zoom].addObject(be, J.project(be.getLatLng(), ce._zoom)), this._arraySplice(ce.__parent._childClusters, ce), ce.__parent._markers.push(be), be.__parent = ce.__parent, ce._icon && (Y.removeLayer(ce), i || Y.addLayer(be))) : ce._iconNeedsUpdate = !0, ce = ce.__parent;
        delete b.__parent;
      },
      _isOrIsParent: function(b, E) {
        for (; E; ) {
          if (b === E)
            return !0;
          E = E.parentNode;
        }
        return !1;
      },
      //Override L.Evented.fire
      fire: function(b, E, i) {
        if (E && E.layer instanceof L.MarkerCluster) {
          if (E.originalEvent && this._isOrIsParent(E.layer._icon, E.originalEvent.relatedTarget))
            return;
          b = "cluster" + b;
        }
        L.FeatureGroup.prototype.fire.call(this, b, E, i);
      },
      //Override L.Evented.listens
      listens: function(b, E) {
        return L.FeatureGroup.prototype.listens.call(this, b, E) || L.FeatureGroup.prototype.listens.call(this, "cluster" + b, E);
      },
      //Default functionality
      _defaultIconCreateFunction: function(b) {
        var E = b.getChildCount(), i = " marker-cluster-";
        return E < 10 ? i += "small" : E < 100 ? i += "medium" : i += "large", new L.DivIcon({ html: "<div><span>" + E + "</span></div>", className: "marker-cluster" + i, iconSize: new L.Point(40, 40) });
      },
      _bindEvents: function() {
        var b = this._map, E = this.options.spiderfyOnMaxZoom, i = this.options.showCoverageOnHover, O = this.options.zoomToBoundsOnClick, j = this.options.spiderfyOnEveryZoom;
        (E || O || j) && this.on("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), i && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), b.on("zoomend", this._hideCoverage, this));
      },
      _zoomOrSpiderfy: function(b) {
        var E = b.layer, i = E;
        if (!(b.type === "clusterkeypress" && b.originalEvent && b.originalEvent.keyCode !== 13)) {
          for (; i._childClusters.length === 1; )
            i = i._childClusters[0];
          i._zoom === this._maxZoom && i._childCount === E._childCount && this.options.spiderfyOnMaxZoom ? E.spiderfy() : this.options.zoomToBoundsOnClick && E.zoomToBounds(), this.options.spiderfyOnEveryZoom && E.spiderfy(), b.originalEvent && b.originalEvent.keyCode === 13 && this._map._container.focus();
        }
      },
      _showCoverage: function(b) {
        var E = this._map;
        this._inZoomAnimation || (this._shownPolygon && E.removeLayer(this._shownPolygon), b.layer.getChildCount() > 2 && b.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(b.layer.getConvexHull(), this.options.polygonOptions), E.addLayer(this._shownPolygon)));
      },
      _hideCoverage: function() {
        this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);
      },
      _unbindEvents: function() {
        var b = this.options.spiderfyOnMaxZoom, E = this.options.showCoverageOnHover, i = this.options.zoomToBoundsOnClick, O = this.options.spiderfyOnEveryZoom, j = this._map;
        (b || i || O) && this.off("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), E && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), j.off("zoomend", this._hideCoverage, this));
      },
      _zoomEnd: function() {
        this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds());
      },
      _moveEnd: function() {
        if (!this._inZoomAnimation) {
          var b = this._getExpandedVisibleBounds();
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, b), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), b), this._currentShownBounds = b;
        }
      },
      _generateInitialClusters: function() {
        var b = Math.ceil(this._map.getMaxZoom()), E = Math.floor(this._map.getMinZoom()), i = this.options.maxClusterRadius, O = i;
        typeof i != "function" && (O = function() {
          return i;
        }), this.options.disableClusteringAtZoom !== null && (b = this.options.disableClusteringAtZoom - 1), this._maxZoom = b, this._gridClusters = {}, this._gridUnclustered = {};
        for (var j = b; j >= E; j--)
          this._gridClusters[j] = new L.DistanceGrid(O(j)), this._gridUnclustered[j] = new L.DistanceGrid(O(j));
        this._topClusterLevel = new this._markerCluster(this, E - 1);
      },
      //Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
      _addLayer: function(b, E) {
        var i = this._gridClusters, O = this._gridUnclustered, j = Math.floor(this._map.getMinZoom()), Y, J;
        for (this.options.singleMarkerMode && this._overrideMarkerIcon(b), b.on(this._childMarkerEventHandlers, this); E >= j; E--) {
          Y = this._map.project(b.getLatLng(), E);
          var ae = i[E].getNearObject(Y);
          if (ae) {
            ae._addChild(b), b.__parent = ae;
            return;
          }
          if (ae = O[E].getNearObject(Y), ae) {
            var ce = ae.__parent;
            ce && this._removeLayer(ae, !1);
            var Te = new this._markerCluster(this, E, ae, b);
            i[E].addObject(Te, this._map.project(Te._cLatLng, E)), ae.__parent = Te, b.__parent = Te;
            var be = Te;
            for (J = E - 1; J > ce._zoom; J--)
              be = new this._markerCluster(this, J, be), i[J].addObject(be, this._map.project(ae.getLatLng(), J));
            ce._addChild(be), this._removeFromGridUnclustered(ae, E);
            return;
          }
          O[E].addObject(b, Y);
        }
        this._topClusterLevel._addChild(b), b.__parent = this._topClusterLevel;
      },
      /**
       * Refreshes the icon of all "dirty" visible clusters.
       * Non-visible "dirty" clusters will be updated when they are added to the map.
       * @private
       */
      _refreshClustersIcons: function() {
        this._featureGroup.eachLayer(function(b) {
          b instanceof L.MarkerCluster && b._iconNeedsUpdate && b._updateIcon();
        });
      },
      //Enqueue code to fire after the marker expand/contract has happened
      _enqueue: function(b) {
        this._queue.push(b), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));
      },
      _processQueue: function() {
        for (var b = 0; b < this._queue.length; b++)
          this._queue[b].call(this);
        this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;
      },
      //Merge and split any existing clusters that are too big or small
      _mergeSplitClusters: function() {
        var b = Math.round(this._map._zoom);
        this._processQueue(), this._zoom < b && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, b)) : this._zoom > b ? (this._animationStart(), this._animationZoomOut(this._zoom, b)) : this._moveEnd();
      },
      //Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
      _getExpandedVisibleBounds: function() {
        if (this.options.removeOutsideVisibleBounds) {
          if (L.Browser.mobile)
            return this._checkBoundsMaxLat(this._map.getBounds());
        } else
          return this._mapBoundsInfinite;
        return this._checkBoundsMaxLat(this._map.getBounds().pad(1));
      },
      /**
       * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
       * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
       * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
       * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
       * making the user think that MCG "eats" them and never displays them again.
       * @param bounds L.LatLngBounds
       * @returns {L.LatLngBounds}
       * @private
       */
      _checkBoundsMaxLat: function(b) {
        var E = this._maxLat;
        return E !== void 0 && (b.getNorth() >= E && (b._northEast.lat = 1 / 0), b.getSouth() <= -E && (b._southWest.lat = -1 / 0)), b;
      },
      //Shared animation code
      _animationAddLayerNonAnimated: function(b, E) {
        if (E === b)
          this._featureGroup.addLayer(b);
        else if (E._childCount === 2) {
          E._addToMap();
          var i = E.getAllChildMarkers();
          this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1]);
        } else
          E._updateIcon();
      },
      /**
       * Extracts individual (i.e. non-group) layers from a Layer Group.
       * @param group to extract layers from.
       * @param output {Array} in which to store the extracted layers.
       * @returns {*|Array}
       * @private
       */
      _extractNonGroupLayers: function(b, E) {
        var i = b.getLayers(), O = 0, j;
        for (E = E || []; O < i.length; O++) {
          if (j = i[O], j instanceof L.LayerGroup) {
            this._extractNonGroupLayers(j, E);
            continue;
          }
          E.push(j);
        }
        return E;
      },
      /**
       * Implements the singleMarkerMode option.
       * @param layer Marker to re-style using the Clusters iconCreateFunction.
       * @returns {L.Icon} The newly created icon.
       * @private
       */
      _overrideMarkerIcon: function(b) {
        var E = b.options.icon = this.options.iconCreateFunction({
          getChildCount: function() {
            return 1;
          },
          getAllChildMarkers: function() {
            return [b];
          }
        });
        return E;
      }
    });
    L.MarkerClusterGroup.include({
      _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
    }), L.MarkerClusterGroup.include({
      _noAnimation: {
        //Non Animated versions of everything
        _animationStart: function() {
        },
        _animationZoomIn: function(b, E) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b), this._topClusterLevel._recursivelyAddChildrenToMap(null, E, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationZoomOut: function(b, E) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b), this._topClusterLevel._recursivelyAddChildrenToMap(null, E, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationAddLayer: function(b, E) {
          this._animationAddLayerNonAnimated(b, E);
        }
      },
      _withAnimation: {
        //Animated versions here
        _animationStart: function() {
          this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++;
        },
        _animationZoomIn: function(b, E) {
          var i = this._getExpandedVisibleBounds(), O = this._featureGroup, j = Math.floor(this._map.getMinZoom()), Y;
          this._ignoreMove = !0, this._topClusterLevel._recursively(i, b, j, function(J) {
            var ae = J._latlng, ce = J._markers, Te;
            for (i.contains(ae) || (ae = null), J._isSingleParent() && b + 1 === E ? (O.removeLayer(J), J._recursivelyAddChildrenToMap(null, E, i)) : (J.clusterHide(), J._recursivelyAddChildrenToMap(ae, E, i)), Y = ce.length - 1; Y >= 0; Y--)
              Te = ce[Y], i.contains(Te._latlng) || O.removeLayer(Te);
          }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(i, E), O.eachLayer(function(J) {
            !(J instanceof L.MarkerCluster) && J._icon && J.clusterShow();
          }), this._topClusterLevel._recursively(i, b, E, function(J) {
            J._recursivelyRestoreChildPositions(E);
          }), this._ignoreMove = !1, this._enqueue(function() {
            this._topClusterLevel._recursively(i, b, j, function(J) {
              O.removeLayer(J), J.clusterShow();
            }), this._animationEnd();
          });
        },
        _animationZoomOut: function(b, E) {
          this._animationZoomOutSingle(this._topClusterLevel, b - 1, E), this._topClusterLevel._recursivelyAddChildrenToMap(null, E, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b, this._getExpandedVisibleBounds());
        },
        _animationAddLayer: function(b, E) {
          var i = this, O = this._featureGroup;
          O.addLayer(b), E !== b && (E._childCount > 2 ? (E._updateIcon(), this._forceLayout(), this._animationStart(), b._setPos(this._map.latLngToLayerPoint(E.getLatLng())), b.clusterHide(), this._enqueue(function() {
            O.removeLayer(b), b.clusterShow(), i._animationEnd();
          })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(E, this._map.getMaxZoom(), this._zoom)));
        }
      },
      // Private methods for animated versions.
      _animationZoomOutSingle: function(b, E, i) {
        var O = this._getExpandedVisibleBounds(), j = Math.floor(this._map.getMinZoom());
        b._recursivelyAnimateChildrenInAndAddSelfToMap(O, j, E + 1, i);
        var Y = this;
        this._forceLayout(), b._recursivelyBecomeVisible(O, i), this._enqueue(function() {
          if (b._childCount === 1) {
            var J = b._markers[0];
            this._ignoreMove = !0, J.setLatLng(J.getLatLng()), this._ignoreMove = !1, J.clusterShow && J.clusterShow();
          } else
            b._recursively(O, i, j, function(ae) {
              ae._recursivelyRemoveChildrenFromMap(O, j, E + 1);
            });
          Y._animationEnd();
        });
      },
      _animationEnd: function() {
        this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend");
      },
      //Force a browser layout of stuff in the map
      // Should apply the current opacity and location to all elements so we can update them again for an animation
      _forceLayout: function() {
        L.Util.falseFn(document.body.offsetWidth);
      }
    }), L.markerClusterGroup = function(b) {
      return new L.MarkerClusterGroup(b);
    };
    var w = L.MarkerCluster = L.Marker.extend({
      options: L.Icon.prototype.options,
      initialize: function(b, E, i, O) {
        L.Marker.prototype.initialize.call(
          this,
          i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0),
          { icon: this, pane: b.options.clusterPane }
        ), this._group = b, this._zoom = E, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds(), i && this._addChild(i), O && this._addChild(O);
      },
      //Recursively retrieve all child markers of this cluster
      getAllChildMarkers: function(b, E) {
        b = b || [];
        for (var i = this._childClusters.length - 1; i >= 0; i--)
          this._childClusters[i].getAllChildMarkers(b, E);
        for (var O = this._markers.length - 1; O >= 0; O--)
          E && this._markers[O].__dragStart || b.push(this._markers[O]);
        return b;
      },
      //Returns the count of how many child markers we have
      getChildCount: function() {
        return this._childCount;
      },
      //Zoom to the minimum of showing all of the child markers, or the extents of this cluster
      zoomToBounds: function(b) {
        for (var E = this._childClusters.slice(), i = this._group._map, O = i.getBoundsZoom(this._bounds), j = this._zoom + 1, Y = i.getZoom(), J; E.length > 0 && O > j; ) {
          j++;
          var ae = [];
          for (J = 0; J < E.length; J++)
            ae = ae.concat(E[J]._childClusters);
          E = ae;
        }
        O > j ? this._group._map.setView(this._latlng, j) : O <= Y ? this._group._map.setView(this._latlng, Y + 1) : this._group._map.fitBounds(this._bounds, b);
      },
      getBounds: function() {
        var b = new L.LatLngBounds();
        return b.extend(this._bounds), b;
      },
      _updateIcon: function() {
        this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);
      },
      //Cludge for Icon, we pretend to be an icon for performance
      createIcon: function() {
        return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon();
      },
      createShadow: function() {
        return this._iconObj.createShadow();
      },
      _addChild: function(b, E) {
        this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(b), b instanceof L.MarkerCluster ? (E || (this._childClusters.push(b), b.__parent = this), this._childCount += b._childCount) : (E || this._markers.push(b), this._childCount++), this.__parent && this.__parent._addChild(b, !0);
      },
      /**
       * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
       * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
       * @private
       */
      _setClusterCenter: function(b) {
        this._cLatLng || (this._cLatLng = b._cLatLng || b._latlng);
      },
      /**
       * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
       * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
       * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
       * @private
       */
      _resetBounds: function() {
        var b = this._bounds;
        b._southWest && (b._southWest.lat = 1 / 0, b._southWest.lng = 1 / 0), b._northEast && (b._northEast.lat = -1 / 0, b._northEast.lng = -1 / 0);
      },
      _recalculateBounds: function() {
        var b = this._markers, E = this._childClusters, i = 0, O = 0, j = this._childCount, Y, J, ae, ce;
        if (j !== 0) {
          for (this._resetBounds(), Y = 0; Y < b.length; Y++)
            ae = b[Y]._latlng, this._bounds.extend(ae), i += ae.lat, O += ae.lng;
          for (Y = 0; Y < E.length; Y++)
            J = E[Y], J._boundsNeedUpdate && J._recalculateBounds(), this._bounds.extend(J._bounds), ae = J._wLatLng, ce = J._childCount, i += ae.lat * ce, O += ae.lng * ce;
          this._latlng = this._wLatLng = new L.LatLng(i / j, O / j), this._boundsNeedUpdate = !1;
        }
      },
      //Set our markers position as given and add it to the map
      _addToMap: function(b) {
        b && (this._backupLatlng = this._latlng, this.setLatLng(b)), this._group._featureGroup.addLayer(this);
      },
      _recursivelyAnimateChildrenIn: function(b, E, i) {
        this._recursively(
          b,
          this._group._map.getMinZoom(),
          i - 1,
          function(O) {
            var j = O._markers, Y, J;
            for (Y = j.length - 1; Y >= 0; Y--)
              J = j[Y], J._icon && (J._setPos(E), J.clusterHide());
          },
          function(O) {
            var j = O._childClusters, Y, J;
            for (Y = j.length - 1; Y >= 0; Y--)
              J = j[Y], J._icon && (J._setPos(E), J.clusterHide());
          }
        );
      },
      _recursivelyAnimateChildrenInAndAddSelfToMap: function(b, E, i, O) {
        this._recursively(
          b,
          O,
          E,
          function(j) {
            j._recursivelyAnimateChildrenIn(b, j._group._map.latLngToLayerPoint(j.getLatLng()).round(), i), j._isSingleParent() && i - 1 === O ? (j.clusterShow(), j._recursivelyRemoveChildrenFromMap(b, E, i)) : j.clusterHide(), j._addToMap();
          }
        );
      },
      _recursivelyBecomeVisible: function(b, E) {
        this._recursively(b, this._group._map.getMinZoom(), E, null, function(i) {
          i.clusterShow();
        });
      },
      _recursivelyAddChildrenToMap: function(b, E, i) {
        this._recursively(
          i,
          this._group._map.getMinZoom() - 1,
          E,
          function(O) {
            if (E !== O._zoom)
              for (var j = O._markers.length - 1; j >= 0; j--) {
                var Y = O._markers[j];
                i.contains(Y._latlng) && (b && (Y._backupLatlng = Y.getLatLng(), Y.setLatLng(b), Y.clusterHide && Y.clusterHide()), O._group._featureGroup.addLayer(Y));
              }
          },
          function(O) {
            O._addToMap(b);
          }
        );
      },
      _recursivelyRestoreChildPositions: function(b) {
        for (var E = this._markers.length - 1; E >= 0; E--) {
          var i = this._markers[E];
          i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng);
        }
        if (b - 1 === this._zoom)
          for (var O = this._childClusters.length - 1; O >= 0; O--)
            this._childClusters[O]._restorePosition();
        else
          for (var j = this._childClusters.length - 1; j >= 0; j--)
            this._childClusters[j]._recursivelyRestoreChildPositions(b);
      },
      _restorePosition: function() {
        this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
      },
      //exceptBounds: If set, don't remove any markers/clusters in it
      _recursivelyRemoveChildrenFromMap: function(b, E, i, O) {
        var j, Y;
        this._recursively(
          b,
          E - 1,
          i - 1,
          function(J) {
            for (Y = J._markers.length - 1; Y >= 0; Y--)
              j = J._markers[Y], (!O || !O.contains(j._latlng)) && (J._group._featureGroup.removeLayer(j), j.clusterShow && j.clusterShow());
          },
          function(J) {
            for (Y = J._childClusters.length - 1; Y >= 0; Y--)
              j = J._childClusters[Y], (!O || !O.contains(j._latlng)) && (J._group._featureGroup.removeLayer(j), j.clusterShow && j.clusterShow());
          }
        );
      },
      //Run the given functions recursively to this and child clusters
      // boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
      // zoomLevelToStart: zoom level to start running functions (inclusive)
      // zoomLevelToStop: zoom level to stop running functions (inclusive)
      // runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
      // runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
      _recursively: function(b, E, i, O, j) {
        var Y = this._childClusters, J = this._zoom, ae, ce;
        if (E <= J && (O && O(this), j && J === i && j(this)), J < E || J < i)
          for (ae = Y.length - 1; ae >= 0; ae--)
            ce = Y[ae], ce._boundsNeedUpdate && ce._recalculateBounds(), b.intersects(ce._bounds) && ce._recursively(b, E, i, O, j);
      },
      //Returns true if we are the parent of only one cluster and that cluster is the same as us
      _isSingleParent: function() {
        return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
      }
    });
    L.Marker.include({
      clusterHide: function() {
        var b = this.options.opacity;
        return this.setOpacity(0), this.options.opacity = b, this;
      },
      clusterShow: function() {
        return this.setOpacity(this.options.opacity);
      }
    }), L.DistanceGrid = function(b) {
      this._cellSize = b, this._sqCellSize = b * b, this._grid = {}, this._objectPoint = {};
    }, L.DistanceGrid.prototype = {
      addObject: function(b, E) {
        var i = this._getCoord(E.x), O = this._getCoord(E.y), j = this._grid, Y = j[O] = j[O] || {}, J = Y[i] = Y[i] || [], ae = L.Util.stamp(b);
        this._objectPoint[ae] = E, J.push(b);
      },
      updateObject: function(b, E) {
        this.removeObject(b), this.addObject(b, E);
      },
      //Returns true if the object was found
      removeObject: function(b, E) {
        var i = this._getCoord(E.x), O = this._getCoord(E.y), j = this._grid, Y = j[O] = j[O] || {}, J = Y[i] = Y[i] || [], ae, ce;
        for (delete this._objectPoint[L.Util.stamp(b)], ae = 0, ce = J.length; ae < ce; ae++)
          if (J[ae] === b)
            return J.splice(ae, 1), ce === 1 && delete Y[i], !0;
      },
      eachObject: function(b, E) {
        var i, O, j, Y, J, ae, ce, Te = this._grid;
        for (i in Te) {
          J = Te[i];
          for (O in J)
            for (ae = J[O], j = 0, Y = ae.length; j < Y; j++)
              ce = b.call(E, ae[j]), ce && (j--, Y--);
        }
      },
      getNearObject: function(b) {
        var E = this._getCoord(b.x), i = this._getCoord(b.y), O, j, Y, J, ae, ce, Te, be, Ze = this._objectPoint, je = this._sqCellSize, ot = null;
        for (O = i - 1; O <= i + 1; O++)
          if (J = this._grid[O], J) {
            for (j = E - 1; j <= E + 1; j++)
              if (ae = J[j], ae)
                for (Y = 0, ce = ae.length; Y < ce; Y++)
                  Te = ae[Y], be = this._sqDist(Ze[L.Util.stamp(Te)], b), (be < je || be <= je && ot === null) && (je = be, ot = Te);
          }
        return ot;
      },
      _getCoord: function(b) {
        var E = Math.floor(b / this._cellSize);
        return isFinite(E) ? E : b;
      },
      _sqDist: function(b, E) {
        var i = E.x - b.x, O = E.y - b.y;
        return i * i + O * O;
      }
    }, function() {
      L.QuickHull = {
        /*
         * @param {Object} cpt a point to be measured from the baseline
         * @param {Array} bl the baseline, as represented by a two-element
         *   array of latlng objects.
         * @returns {Number} an approximate distance measure
         */
        getDistant: function(b, E) {
          var i = E[1].lat - E[0].lat, O = E[0].lng - E[1].lng;
          return O * (b.lat - E[0].lat) + i * (b.lng - E[0].lng);
        },
        /*
         * @param {Array} baseLine a two-element array of latlng objects
         *   representing the baseline to project from
         * @param {Array} latLngs an array of latlng objects
         * @returns {Object} the maximum point and all new points to stay
         *   in consideration for the hull.
         */
        findMostDistantPointFromBaseLine: function(b, E) {
          var i = 0, O = null, j = [], Y, J, ae;
          for (Y = E.length - 1; Y >= 0; Y--) {
            if (J = E[Y], ae = this.getDistant(J, b), ae > 0)
              j.push(J);
            else
              continue;
            ae > i && (i = ae, O = J);
          }
          return { maxPoint: O, newPoints: j };
        },
        /*
         * Given a baseline, compute the convex hull of latLngs as an array
         * of latLngs.
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        buildConvexHull: function(b, E) {
          var i = [], O = this.findMostDistantPointFromBaseLine(b, E);
          return O.maxPoint ? (i = i.concat(
            this.buildConvexHull([b[0], O.maxPoint], O.newPoints)
          ), i = i.concat(
            this.buildConvexHull([O.maxPoint, b[1]], O.newPoints)
          ), i) : [b[0]];
        },
        /*
         * Given an array of latlngs, compute a convex hull as an array
         * of latlngs
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        getConvexHull: function(b) {
          var E = !1, i = !1, O = !1, j = !1, Y = null, J = null, ae = null, ce = null, Te = null, be = null, Ze;
          for (Ze = b.length - 1; Ze >= 0; Ze--) {
            var je = b[Ze];
            (E === !1 || je.lat > E) && (Y = je, E = je.lat), (i === !1 || je.lat < i) && (J = je, i = je.lat), (O === !1 || je.lng > O) && (ae = je, O = je.lng), (j === !1 || je.lng < j) && (ce = je, j = je.lng);
          }
          i !== E ? (be = J, Te = Y) : (be = ce, Te = ae);
          var ot = [].concat(
            this.buildConvexHull([be, Te], b),
            this.buildConvexHull([Te, be], b)
          );
          return ot;
        }
      };
    }(), L.MarkerCluster.include({
      getConvexHull: function() {
        var b = this.getAllChildMarkers(), E = [], i, O;
        for (O = b.length - 1; O >= 0; O--)
          i = b[O].getLatLng(), E.push(i);
        return L.QuickHull.getConvexHull(E);
      }
    }), L.MarkerCluster.include({
      _2PI: Math.PI * 2,
      _circleFootSeparation: 25,
      //related to circumference of circle
      _circleStartAngle: 0,
      _spiralFootSeparation: 28,
      //related to size of spiral (experiment!)
      _spiralLengthStart: 11,
      _spiralLengthFactor: 5,
      _circleSpiralSwitchover: 9,
      //show spiral instead of circle from this marker count upwards.
      // 0 -> always spiral; Infinity -> always circle
      spiderfy: function() {
        if (!(this._group._spiderfied === this || this._group._inZoomAnimation)) {
          var b = this.getAllChildMarkers(null, !0), E = this._group, i = E._map, O = i.latLngToLayerPoint(this._latlng), j;
          this._group._unspiderfy(), this._group._spiderfied = this, this._group.options.spiderfyShapePositions ? j = this._group.options.spiderfyShapePositions(b.length, O) : b.length >= this._circleSpiralSwitchover ? j = this._generatePointsSpiral(b.length, O) : (O.y += 10, j = this._generatePointsCircle(b.length, O)), this._animationSpiderfy(b, j);
        }
      },
      unspiderfy: function(b) {
        this._group._inZoomAnimation || (this._animationUnspiderfy(b), this._group._spiderfied = null);
      },
      _generatePointsCircle: function(b, E) {
        var i = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + b), O = i / this._2PI, j = this._2PI / b, Y = [], J, ae;
        for (O = Math.max(O, 35), Y.length = b, J = 0; J < b; J++)
          ae = this._circleStartAngle + J * j, Y[J] = new L.Point(E.x + O * Math.cos(ae), E.y + O * Math.sin(ae))._round();
        return Y;
      },
      _generatePointsSpiral: function(b, E) {
        var i = this._group.options.spiderfyDistanceMultiplier, O = i * this._spiralLengthStart, j = i * this._spiralFootSeparation, Y = i * this._spiralLengthFactor * this._2PI, J = 0, ae = [], ce;
        for (ae.length = b, ce = b; ce >= 0; ce--)
          ce < b && (ae[ce] = new L.Point(E.x + O * Math.cos(J), E.y + O * Math.sin(J))._round()), J += j / O + ce * 5e-4, O += Y / J;
        return ae;
      },
      _noanimationUnspiderfy: function() {
        var b = this._group, E = b._map, i = b._featureGroup, O = this.getAllChildMarkers(null, !0), j, Y;
        for (b._ignoreMove = !0, this.setOpacity(1), Y = O.length - 1; Y >= 0; Y--)
          j = O[Y], i.removeLayer(j), j._preSpiderfyLatlng && (j.setLatLng(j._preSpiderfyLatlng), delete j._preSpiderfyLatlng), j.setZIndexOffset && j.setZIndexOffset(0), j._spiderLeg && (E.removeLayer(j._spiderLeg), delete j._spiderLeg);
        b.fire("unspiderfied", {
          cluster: this,
          markers: O
        }), b._ignoreMove = !1, b._spiderfied = null;
      }
    }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
      _animationSpiderfy: function(b, E) {
        var i = this._group, O = i._map, j = i._featureGroup, Y = this._group.options.spiderLegPolylineOptions, J, ae, ce, Te;
        for (i._ignoreMove = !0, J = 0; J < b.length; J++)
          Te = O.layerPointToLatLng(E[J]), ae = b[J], ce = new L.Polyline([this._latlng, Te], Y), O.addLayer(ce), ae._spiderLeg = ce, ae._preSpiderfyLatlng = ae._latlng, ae.setLatLng(Te), ae.setZIndexOffset && ae.setZIndexOffset(1e6), j.addLayer(ae);
        this.setOpacity(0.3), i._ignoreMove = !1, i.fire("spiderfied", {
          cluster: this,
          markers: b
        });
      },
      _animationUnspiderfy: function() {
        this._noanimationUnspiderfy();
      }
    }), L.MarkerCluster.include({
      _animationSpiderfy: function(b, E) {
        var i = this, O = this._group, j = O._map, Y = O._featureGroup, J = this._latlng, ae = j.latLngToLayerPoint(J), ce = L.Path.SVG, Te = L.extend({}, this._group.options.spiderLegPolylineOptions), be = Te.opacity, Ze, je, ot, vt, ht, gt;
        for (be === void 0 && (be = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), ce ? (Te.opacity = 0, Te.className = (Te.className || "") + " leaflet-cluster-spider-leg") : Te.opacity = be, O._ignoreMove = !0, Ze = 0; Ze < b.length; Ze++)
          je = b[Ze], gt = j.layerPointToLatLng(E[Ze]), ot = new L.Polyline([J, gt], Te), j.addLayer(ot), je._spiderLeg = ot, ce && (vt = ot._path, ht = vt.getTotalLength() + 0.1, vt.style.strokeDasharray = ht, vt.style.strokeDashoffset = ht), je.setZIndexOffset && je.setZIndexOffset(1e6), je.clusterHide && je.clusterHide(), Y.addLayer(je), je._setPos && je._setPos(ae);
        for (O._forceLayout(), O._animationStart(), Ze = b.length - 1; Ze >= 0; Ze--)
          gt = j.layerPointToLatLng(E[Ze]), je = b[Ze], je._preSpiderfyLatlng = je._latlng, je.setLatLng(gt), je.clusterShow && je.clusterShow(), ce && (ot = je._spiderLeg, vt = ot._path, vt.style.strokeDashoffset = 0, ot.setStyle({ opacity: be }));
        this.setOpacity(0.3), O._ignoreMove = !1, setTimeout(function() {
          O._animationEnd(), O.fire("spiderfied", {
            cluster: i,
            markers: b
          });
        }, 200);
      },
      _animationUnspiderfy: function(b) {
        var E = this, i = this._group, O = i._map, j = i._featureGroup, Y = b ? O._latLngToNewLayerPoint(this._latlng, b.zoom, b.center) : O.latLngToLayerPoint(this._latlng), J = this.getAllChildMarkers(null, !0), ae = L.Path.SVG, ce, Te, be, Ze, je, ot;
        for (i._ignoreMove = !0, i._animationStart(), this.setOpacity(1), Te = J.length - 1; Te >= 0; Te--)
          ce = J[Te], ce._preSpiderfyLatlng && (ce.closePopup(), ce.setLatLng(ce._preSpiderfyLatlng), delete ce._preSpiderfyLatlng, ot = !0, ce._setPos && (ce._setPos(Y), ot = !1), ce.clusterHide && (ce.clusterHide(), ot = !1), ot && j.removeLayer(ce), ae && (be = ce._spiderLeg, Ze = be._path, je = Ze.getTotalLength() + 0.1, Ze.style.strokeDashoffset = je, be.setStyle({ opacity: 0 })));
        i._ignoreMove = !1, setTimeout(function() {
          var vt = 0;
          for (Te = J.length - 1; Te >= 0; Te--)
            ce = J[Te], ce._spiderLeg && vt++;
          for (Te = J.length - 1; Te >= 0; Te--)
            ce = J[Te], ce._spiderLeg && (ce.clusterShow && ce.clusterShow(), ce.setZIndexOffset && ce.setZIndexOffset(0), vt > 1 && j.removeLayer(ce), O.removeLayer(ce._spiderLeg), delete ce._spiderLeg);
          i._animationEnd(), i.fire("unspiderfied", {
            cluster: E,
            markers: J
          });
        }, 200);
      }
    }), L.MarkerClusterGroup.include({
      //The MarkerCluster currently spiderfied (if any)
      _spiderfied: null,
      unspiderfy: function() {
        this._unspiderfy.apply(this, arguments);
      },
      _spiderfierOnAdd: function() {
        this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this);
      },
      _spiderfierOnRemove: function() {
        this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy();
      },
      //On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
      //This means we can define the animation they do rather than Markers doing an animation to their actual location
      _unspiderfyZoomStart: function() {
        this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
      },
      _unspiderfyZoomAnim: function(b) {
        L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(b));
      },
      _unspiderfyWrapper: function() {
        this._unspiderfy();
      },
      _unspiderfy: function(b) {
        this._spiderfied && this._spiderfied.unspiderfy(b);
      },
      _noanimationUnspiderfy: function() {
        this._spiderfied && this._spiderfied._noanimationUnspiderfy();
      },
      //If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
      _unspiderfyLayer: function(b) {
        b._spiderLeg && (this._featureGroup.removeLayer(b), b.clusterShow && b.clusterShow(), b.setZIndexOffset && b.setZIndexOffset(0), this._map.removeLayer(b._spiderLeg), delete b._spiderLeg);
      }
    }), L.MarkerClusterGroup.include({
      /**
       * Updates the icon of all clusters which are parents of the given marker(s).
       * In singleMarkerMode, also updates the given marker(s) icon.
       * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
       * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
       * clusters need to be updated. If not provided, retrieves all child markers of this.
       * @returns {L.MarkerClusterGroup}
       */
      refreshClusters: function(b) {
        return b ? b instanceof L.MarkerClusterGroup ? b = b._topClusterLevel.getAllChildMarkers() : b instanceof L.LayerGroup ? b = b._layers : b instanceof L.MarkerCluster ? b = b.getAllChildMarkers() : b instanceof L.Marker && (b = [b]) : b = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(b), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(b), this;
      },
      /**
       * Simply flags all parent clusters of the given markers as having a "dirty" icon.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _flagParentsIconsNeedUpdate: function(b) {
        var E, i;
        for (E in b)
          for (i = b[E].__parent; i; )
            i._iconNeedsUpdate = !0, i = i.__parent;
      },
      /**
       * Re-draws the icon of the supplied markers.
       * To be used in singleMarkerMode only.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _refreshSingleMarkerModeMarkers: function(b) {
        var E, i;
        for (E in b)
          i = b[E], this.hasLayer(i) && i.setIcon(this._overrideMarkerIcon(i));
      }
    }), L.Marker.include({
      /**
       * Updates the given options in the marker's icon and refreshes the marker.
       * @param options map object of icon options.
       * @param directlyRefreshClusters boolean (optional) true to trigger
       * MCG.refreshClustersOf() right away with this single marker.
       * @returns {L.Marker}
       */
      refreshIconOptions: function(b, E) {
        var i = this.options.icon;
        return L.setOptions(i, b), this.setIcon(i), E && this.__parent && this.__parent._group.refreshClusters(this), this;
      }
    }), d.MarkerClusterGroup = g, d.MarkerCluster = w, Object.defineProperty(d, "__esModule", { value: !0 });
  });
})(gb, gb.exports);
class CC {
  constructor() {
    this.Bounds = [], this.lng = null, this.map = null, this.EventSelectChart = null, this.Polylines = [], this.CurrentPositionMarker = null, this.CurrentGPSPositionMarker = null;
  }
  init(a, d, g, w, b) {
    this.map = wn.map(
      a,
      {
        scrollWheelZoom: g
      }
    );
    var E = new wn.Control.FullScreen();
    this.map.addControl(E), wn.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: 'Data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(this.map);
    var i = (w + "").length > 0, O = {}, j = {};
    switch (i ? O["Thunderforest - Cycle"] = wn.tileLayer("https://a.tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }) : O["Open Cycle Map"] = wn.tileLayer("http://a.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Thunderforest - Outdoors"] = wn.tileLayer("https://a.tile.thunderforest.com/outddors/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Thunderforest - Transport"] = wn.tileLayer("https://a.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Thunderforest - Landscape"] = wn.tileLayer("https://a.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Open Street Map"] = wn.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Humanitarian Map Style"] = wn.tileLayer("https://a.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Hike & Bike"] = wn.tileLayer("http://toolserver.org/tiles/hikebike/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://hikebikemap.org/">Hike & Bike Map</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["Open Sea Map"] = wn.tileLayer("http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openseamap.org/">OpenSeaMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), O["GSI Map (Japan)"] = wn.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: '&copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank"></a>, Imagery  <a href="https://www.mapbox.com/">Mapbox</a>'
    }), d) {
      case "OSM1": {
        O["Open Street Map"].addTo(this.map);
        break;
      }
      case "OSM2": {
        O["Thunderforest - Cycle"].addTo(this.map);
        break;
      }
      case "OSM3": {
        O["Thunderforest - Outdoors"].addTo(this.map);
        break;
      }
      case "OSM4": {
        O["Thunderforest - Transport"].addTo(this.map);
        break;
      }
      case "OSM5": {
        O["Thunderforest - Landscape"].addTo(this.map);
        break;
      }
      case "OSM7": {
        O["Humanitarian Map Style"].addTo(this.map);
        break;
      }
      case "OSM9": {
        O["Hike & Bike"].addTo(this.map);
        break;
      }
      case "OSM10": {
        O["Open Sea Map"].addTo(this.map);
        break;
      }
      case "OSM11": {
        O["GSI Map (Japan)"].addTo(this.map);
        break;
      }
      default:
        O["Open Street Map"].addTo(this.map);
    }
    wn.control.layers(O, j).addTo(this.map);
  }
  AppPolylines(a, d, g, w, b) {
    var Y;
    if (this.map != null) {
      var E = Zm.Utils.GetItemFromArray(a, 0);
      if (E != null) {
        (g == "" || g == null) && (g = "https://maps.google.com/mapfiles/kml/pal4/icon25.png");
        var i = wn.marker(wn.latLng(E), {
          icon: wn.icon({
            iconUrl: g,
            iconSize: [32, 32],
            // Size of the icon.
            iconAnchor: [16, 16]
            // Point of the icon which will correspond to marker's location.
          }),
          title: (Y = this.lng) == null ? void 0 : Y.currentPosition
        });
        i.addTo(this.map), this.CurrentPositionMarker = i;
        var O = Zm.Utils.DividePolylinesPoints(a);
        this.lng, this.EventSelectChart, this.Bounds = a.filter((J) => J != null), this.CenterMap();
        for (let J = 0; J < O.length; J++) {
          let ae = "";
          J < d.length ? ae = d[J] : ae = d[d.length - 1];
          try {
            let ce = wn.polyline(O[J], { color: ae }).addTo(this.map);
            this.Polylines.push(ce);
            let Te = this;
            this.Polylines[J].on("mousemove", function(be) {
              Te.MoveMarkerToPosition([be.latlng.lat, be.latlng.lng], !0);
            });
          } catch {
          }
        }
        if (w != "") {
          let J = a[0];
          J != null && wn.marker(wn.latLng(J), {
            icon: wn.icon({
              iconUrl: w + "",
              iconSize: [32, 32],
              // Size of the icon.
              iconAnchor: [16, 16]
              // Point of the icon which will correspond to marker's location.
            }),
            title: "Start"
          }).addTo(this.map);
        }
        if (b != "" && a[a.length - 1] != null) {
          let J = a[a.length - 1];
          if (J != null) {
            var j = wn.marker(wn.latLng(J), {
              icon: wn.icon({
                iconUrl: b + "",
                iconSize: [32, 32],
                // size of the icon
                iconAnchor: [16, 16]
                // point of the icon which will correspond to marker's location
              }),
              title: "End"
            });
            j.addTo(this.map);
          }
        }
      }
    }
  }
  SetCurrentGPSPosition(a, d, g) {
    this.CurrentGPSPositionMarker == null ? (d == "" && (d = "https://maps.google.com/mapfiles/kml/pal4/icon25.png"), this.map != null && (this.CurrentGPSPositionMarker = wn.marker(a, {
      icon: wn.icon({
        iconUrl: d,
        iconSize: [32, 32],
        // Size of the icon.
        iconAnchor: [16, 16]
        // Point of the icon which will correspond to marker's location.
      })
    }).addTo(this.map).bindPopup(g.currentPosition).openPopup())) : this.CurrentGPSPositionMarker.setLatLng(a), this.Bounds.push(a), this.CenterMap();
  }
  AddWaypoints(a, d) {
    var g = wn.icon({
      iconUrl: "https://maps.google.com/mapfiles/ms/micons/flag.png",
      iconSize: [32, 32],
      // Size of the icon.
      iconAnchor: [16, 16]
      // Point of the icon which will correspond to marker's location.
    });
    d != "" && (g = wn.icon({
      iconUrl: "waypointIcon",
      iconSize: [32, 32],
      // Size of the icon.
      iconAnchor: [16, 16]
      // Point of the icon which will correspond to marker's location.
    }));
    for (let j = 0; j < a.length; j++) {
      var w = a[j];
      this.Bounds.push([w.lat, w.lon]);
      var b = w.lat, E = w.lon;
      w.sym, w.type, w.img && (g.iconUrl = w.img + "");
      var i = wn.marker([b, E], { icon: g }), O = "";
      w.name == "" ? O = "<div>" + unescape(w.desc) + "</div>" : O = "<div><b>" + w.name + "</b><br />" + unescape(w.desc) + "</div>", O += "<br /><p><a href='https://maps.google.com?daddr=" + b + "," + E + "' target='_blank'>Itin&eacute;raire</a></p>", this.map != null && i.addTo(this.map).bindPopup(O);
    }
    this.CenterMap();
  }
  MoveMarkerToPosition(a, d) {
    this.CurrentPositionMarker != null && (this.CurrentPositionMarker.setLatLng(a), this.lng && this.CurrentPositionMarker.setTooltipContent(this.lng.currentPosition), d == !0 && this.EventSelectChart && this.EventSelectChart(a));
  }
  CenterMap() {
    var g;
    try {
      if (this.Bounds && this.Bounds.length > 0) {
        let w = {
          minLat: Number.POSITIVE_INFINITY,
          maxLat: Number.NEGATIVE_INFINITY,
          minLng: Number.POSITIVE_INFINITY,
          maxLng: Number.NEGATIVE_INFINITY
        };
        this.Bounds.forEach((b) => {
          if (!Array.isArray(b) || b.length !== 2)
            throw new Error("Each coordinate must be an array with [latitude, longitude].");
          const [E, i] = b;
          w.minLat = Math.min(w.minLat, E), w.maxLat = Math.max(w.maxLat, E), w.minLng = Math.min(w.minLng, i), w.maxLng = Math.max(w.maxLng, i);
        });
        var a = new wn.LatLng(w.minLat, w.minLng), d = new wn.LatLng(w.maxLat, w.maxLng);
        (g = this.map) == null || g.fitBounds(new wn.LatLngBounds(a, d));
      }
    } catch (w) {
      console.log(w);
    }
  }
  AddPhotos(a) {
    for (const d of a) {
      let g = wn.marker(d, {
        icon: wn.divIcon(
          wn.extend(
            {
              html: '<div style="background-image: url(' + d.thumbnail + ');"></div>',
              className: "leaflet-marker-photo"
            },
            d,
            {
              iconSize: [40, 40]
            }
          )
        ),
        title: d.caption || ""
      });
      g.bindPopup('<img src="' + d.url + '" /></a><p>' + d.name + "</p>", { minWidth: 500 }), g.addTo(this.map);
    }
  }
}
var xw = {};
Object.defineProperty(xw, "__esModule", { value: !0 });
class Ju {
  constructor(a, d) {
    this.styles = a || Ju.DEFAULT_STYLES;
    const g = typeof d == "string" ? d : d ? d.defaultStyle : void 0;
    this.defaultStyle = g || Ju.DEFAULT_STYLE, this.onDocumentClick = this.onDocumentClick.bind(this), this.events = typeof d != "string" && d ? d.eventListeners : void 0;
  }
  getDefaultPosition() {
    return "top-right";
  }
  onAdd(a) {
    this.map = a, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("mapboxgl-ctrl"), this.controlContainer.classList.add("mapboxgl-ctrl-group"), this.mapStyleContainer = document.createElement("div"), this.styleButton = document.createElement("button"), this.styleButton.type = "button", this.mapStyleContainer.classList.add("mapboxgl-style-list");
    for (const d of this.styles) {
      const g = document.createElement("button");
      g.type = "button", g.innerText = d.title, g.classList.add(d.title.replace(/[^a-z0-9-]/gi, "_")), g.dataset.uri = JSON.stringify(d.uri), g.addEventListener("click", (w) => {
        const b = w.srcElement;
        if (this.closeModal(), b.classList.contains("active") || this.events && this.events.onOpen && this.events.onOpen(w))
          return;
        const E = JSON.parse(b.dataset.uri);
        this.map.setStyle(E);
        const i = this.mapStyleContainer.getElementsByClassName("active");
        for (; i[0]; )
          i[0].classList.remove("active");
        b.classList.add("active"), this.events && this.events.onChange && this.events.onChange(w, E);
      }), d.title === this.defaultStyle && g.classList.add("active"), this.mapStyleContainer.appendChild(g);
    }
    return this.styleButton.classList.add("mapboxgl-ctrl-icon"), this.styleButton.classList.add("mapboxgl-style-switcher"), this.styleButton.addEventListener("click", (d) => {
      this.events && this.events.onSelect && this.events.onSelect(d) || this.openModal();
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.styleButton), this.controlContainer.appendChild(this.mapStyleContainer), this.controlContainer;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.styleButton || (this.styleButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.map = void 0);
  }
  closeModal() {
    this.mapStyleContainer && this.styleButton && (this.mapStyleContainer.style.display = "none", this.styleButton.style.display = "block");
  }
  openModal() {
    this.mapStyleContainer && this.styleButton && (this.mapStyleContainer.style.display = "block", this.styleButton.style.display = "none");
  }
  onDocumentClick(a) {
    this.controlContainer && !this.controlContainer.contains(a.target) && this.closeModal();
  }
}
Ju.DEFAULT_STYLE = "Streets";
Ju.DEFAULT_STYLES = [
  { title: "Dark", uri: "mapbox://styles/mapbox/dark-v10" },
  { title: "Light", uri: "mapbox://styles/mapbox/light-v10" },
  { title: "Outdoors", uri: "mapbox://styles/mapbox/outdoors-v11" },
  { title: "Satellite", uri: "mapbox://styles/mapbox/satellite-streets-v11" },
  { title: "Streets", uri: "mapbox://styles/mapbox/streets-v11" }
];
var IC = xw.MapboxStyleSwitcherControl = Ju, vw = { exports: {} };
(function(m, a) {
  (function(d, g) {
    m.exports = g();
  })(Km, function() {
    var d, g, w;
    function b(i, O) {
      if (!d)
        d = O;
      else if (!g)
        g = O;
      else {
        var j = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + d + ")(sharedChunk); (" + g + ")(sharedChunk); self.onerror = null;", Y = {};
        d(Y), w = O(Y), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (w.workerUrl = window.URL.createObjectURL(new Blob([j], { type: "text/javascript" })));
      }
    }
    b(["exports"], function(i) {
      function O(r) {
        return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
      }
      var j, Y = {}, J = {};
      function ae() {
        if (j)
          return J;
        j = 1, Object.defineProperty(J, "__esModule", { value: !0 }), J.setMatrixArrayType = function(u) {
          J.ARRAY_TYPE = e = u;
        }, J.toRadian = function(u) {
          return u * o;
        }, J.equals = function(u, l) {
          return Math.abs(u - l) <= r * Math.max(1, Math.abs(u), Math.abs(l));
        }, J.RANDOM = J.ARRAY_TYPE = J.EPSILON = void 0;
        var r = 1e-6;
        J.EPSILON = r;
        var e = typeof Float32Array < "u" ? Float32Array : Array;
        J.ARRAY_TYPE = e;
        var n = Math.random;
        J.RANDOM = n;
        var o = Math.PI / 180;
        return Math.hypot || (Math.hypot = function() {
          for (var u = 0, l = arguments.length; l--; )
            u += arguments[l] * arguments[l];
          return Math.sqrt(u);
        }), J;
      }
      var ce, Te = {};
      function be() {
        if (ce)
          return Te;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
            return typeof f;
          } : function(f) {
            return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
          }, r(l);
        }
        ce = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.create = function() {
          var l = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0), l[0] = 1, l[3] = 1, l;
        }, Te.clone = function(l) {
          var f = new e.ARRAY_TYPE(4);
          return f[0] = l[0], f[1] = l[1], f[2] = l[2], f[3] = l[3], f;
        }, Te.copy = function(l, f) {
          return l[0] = f[0], l[1] = f[1], l[2] = f[2], l[3] = f[3], l;
        }, Te.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l;
        }, Te.fromValues = function(l, f, v, S) {
          var D = new e.ARRAY_TYPE(4);
          return D[0] = l, D[1] = f, D[2] = v, D[3] = S, D;
        }, Te.set = function(l, f, v, S, D) {
          return l[0] = f, l[1] = v, l[2] = S, l[3] = D, l;
        }, Te.transpose = function(l, f) {
          if (l === f) {
            var v = f[1];
            l[1] = f[2], l[2] = v;
          } else
            l[0] = f[0], l[1] = f[2], l[2] = f[1], l[3] = f[3];
          return l;
        }, Te.invert = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = v * x - D * S;
          return A ? (l[0] = x * (A = 1 / A), l[1] = -S * A, l[2] = -D * A, l[3] = v * A, l) : null;
        }, Te.adjoint = function(l, f) {
          var v = f[0];
          return l[0] = f[3], l[1] = -f[1], l[2] = -f[2], l[3] = v, l;
        }, Te.determinant = function(l) {
          return l[0] * l[3] - l[2] * l[1];
        }, Te.multiply = o, Te.rotate = function(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = Math.sin(v), M = Math.cos(v);
          return l[0] = S * M + x * I, l[1] = D * M + A * I, l[2] = S * -I + x * M, l[3] = D * -I + A * M, l;
        }, Te.scale = function(l, f, v) {
          var S = f[1], D = f[2], x = f[3], A = v[0], I = v[1];
          return l[0] = f[0] * A, l[1] = S * A, l[2] = D * I, l[3] = x * I, l;
        }, Te.fromRotation = function(l, f) {
          var v = Math.sin(f), S = Math.cos(f);
          return l[0] = S, l[1] = v, l[2] = -v, l[3] = S, l;
        }, Te.fromScaling = function(l, f) {
          return l[0] = f[0], l[1] = 0, l[2] = 0, l[3] = f[1], l;
        }, Te.str = function(l) {
          return "mat2(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")";
        }, Te.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3]);
        }, Te.LDU = function(l, f, v, S) {
          return l[2] = S[2] / S[0], v[0] = S[0], v[1] = S[1], v[3] = S[3] - l[2] * v[1], [l, f, v];
        }, Te.add = function(l, f, v) {
          return l[0] = f[0] + v[0], l[1] = f[1] + v[1], l[2] = f[2] + v[2], l[3] = f[3] + v[3], l;
        }, Te.subtract = u, Te.exactEquals = function(l, f) {
          return l[0] === f[0] && l[1] === f[1] && l[2] === f[2] && l[3] === f[3];
        }, Te.equals = function(l, f) {
          var v = l[0], S = l[1], D = l[2], x = l[3], A = f[0], I = f[1], M = f[2], C = f[3];
          return Math.abs(v - A) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(A)) && Math.abs(S - I) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(I)) && Math.abs(D - M) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(M)) && Math.abs(x - C) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(C));
        }, Te.multiplyScalar = function(l, f, v) {
          return l[0] = f[0] * v, l[1] = f[1] * v, l[2] = f[2] * v, l[3] = f[3] * v, l;
        }, Te.multiplyScalarAndAdd = function(l, f, v, S) {
          return l[0] = f[0] + v[0] * S, l[1] = f[1] + v[1] * S, l[2] = f[2] + v[2] * S, l[3] = f[3] + v[3] * S, l;
        }, Te.sub = Te.mul = void 0;
        var e = function(l, f) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var S = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var A = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              A && (A.get || A.set) ? Object.defineProperty(S, x, A) : S[x] = l[x];
            }
          return S.default = l, v && v.set(l, S), S;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var f = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(S) {
            return S ? v : f;
          })(l);
        }
        function o(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = v[0], M = v[1], C = v[2], k = v[3];
          return l[0] = S * I + x * M, l[1] = D * I + A * M, l[2] = S * C + x * k, l[3] = D * C + A * k, l;
        }
        function u(l, f, v) {
          return l[0] = f[0] - v[0], l[1] = f[1] - v[1], l[2] = f[2] - v[2], l[3] = f[3] - v[3], l;
        }
        return Te.mul = o, Te.sub = u, Te;
      }
      var Ze, je = {};
      function ot() {
        if (Ze)
          return je;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
            return typeof f;
          } : function(f) {
            return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
          }, r(l);
        }
        Ze = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.create = function() {
          var l = new e.ARRAY_TYPE(6);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0, l[4] = 0, l[5] = 0), l[0] = 1, l[3] = 1, l;
        }, je.clone = function(l) {
          var f = new e.ARRAY_TYPE(6);
          return f[0] = l[0], f[1] = l[1], f[2] = l[2], f[3] = l[3], f[4] = l[4], f[5] = l[5], f;
        }, je.copy = function(l, f) {
          return l[0] = f[0], l[1] = f[1], l[2] = f[2], l[3] = f[3], l[4] = f[4], l[5] = f[5], l;
        }, je.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l[4] = 0, l[5] = 0, l;
        }, je.fromValues = function(l, f, v, S, D, x) {
          var A = new e.ARRAY_TYPE(6);
          return A[0] = l, A[1] = f, A[2] = v, A[3] = S, A[4] = D, A[5] = x, A;
        }, je.set = function(l, f, v, S, D, x, A) {
          return l[0] = f, l[1] = v, l[2] = S, l[3] = D, l[4] = x, l[5] = A, l;
        }, je.invert = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = f[4], I = f[5], M = v * x - S * D;
          return M ? (l[0] = x * (M = 1 / M), l[1] = -S * M, l[2] = -D * M, l[3] = v * M, l[4] = (D * I - x * A) * M, l[5] = (S * A - v * I) * M, l) : null;
        }, je.determinant = function(l) {
          return l[0] * l[3] - l[1] * l[2];
        }, je.multiply = o, je.rotate = function(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = Math.sin(v), k = Math.cos(v);
          return l[0] = S * k + x * C, l[1] = D * k + A * C, l[2] = S * -C + x * k, l[3] = D * -C + A * k, l[4] = I, l[5] = M, l;
        }, je.scale = function(l, f, v) {
          var S = f[1], D = f[2], x = f[3], A = f[4], I = f[5], M = v[0], C = v[1];
          return l[0] = f[0] * M, l[1] = S * M, l[2] = D * C, l[3] = x * C, l[4] = A, l[5] = I, l;
        }, je.translate = function(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = v[0], k = v[1];
          return l[0] = S, l[1] = D, l[2] = x, l[3] = A, l[4] = S * C + x * k + I, l[5] = D * C + A * k + M, l;
        }, je.fromRotation = function(l, f) {
          var v = Math.sin(f), S = Math.cos(f);
          return l[0] = S, l[1] = v, l[2] = -v, l[3] = S, l[4] = 0, l[5] = 0, l;
        }, je.fromScaling = function(l, f) {
          return l[0] = f[0], l[1] = 0, l[2] = 0, l[3] = f[1], l[4] = 0, l[5] = 0, l;
        }, je.fromTranslation = function(l, f) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l[4] = f[0], l[5] = f[1], l;
        }, je.str = function(l) {
          return "mat2d(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ")";
        }, je.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1);
        }, je.add = function(l, f, v) {
          return l[0] = f[0] + v[0], l[1] = f[1] + v[1], l[2] = f[2] + v[2], l[3] = f[3] + v[3], l[4] = f[4] + v[4], l[5] = f[5] + v[5], l;
        }, je.subtract = u, je.multiplyScalar = function(l, f, v) {
          return l[0] = f[0] * v, l[1] = f[1] * v, l[2] = f[2] * v, l[3] = f[3] * v, l[4] = f[4] * v, l[5] = f[5] * v, l;
        }, je.multiplyScalarAndAdd = function(l, f, v, S) {
          return l[0] = f[0] + v[0] * S, l[1] = f[1] + v[1] * S, l[2] = f[2] + v[2] * S, l[3] = f[3] + v[3] * S, l[4] = f[4] + v[4] * S, l[5] = f[5] + v[5] * S, l;
        }, je.exactEquals = function(l, f) {
          return l[0] === f[0] && l[1] === f[1] && l[2] === f[2] && l[3] === f[3] && l[4] === f[4] && l[5] === f[5];
        }, je.equals = function(l, f) {
          var v = l[0], S = l[1], D = l[2], x = l[3], A = l[4], I = l[5], M = f[0], C = f[1], k = f[2], V = f[3], U = f[4], q = f[5];
          return Math.abs(v - M) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(M)) && Math.abs(S - C) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(C)) && Math.abs(D - k) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(k)) && Math.abs(x - V) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(V)) && Math.abs(A - U) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(U)) && Math.abs(I - q) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(q));
        }, je.sub = je.mul = void 0;
        var e = function(l, f) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var S = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var A = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              A && (A.get || A.set) ? Object.defineProperty(S, x, A) : S[x] = l[x];
            }
          return S.default = l, v && v.set(l, S), S;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var f = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(S) {
            return S ? v : f;
          })(l);
        }
        function o(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = v[0], k = v[1], V = v[2], U = v[3], q = v[4], $ = v[5];
          return l[0] = S * C + x * k, l[1] = D * C + A * k, l[2] = S * V + x * U, l[3] = D * V + A * U, l[4] = S * q + x * $ + I, l[5] = D * q + A * $ + M, l;
        }
        function u(l, f, v) {
          return l[0] = f[0] - v[0], l[1] = f[1] - v[1], l[2] = f[2] - v[2], l[3] = f[3] - v[3], l[4] = f[4] - v[4], l[5] = f[5] - v[5], l;
        }
        return je.mul = o, je.sub = u, je;
      }
      var vt, ht = {};
      function gt() {
        if (vt)
          return ht;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
            return typeof f;
          } : function(f) {
            return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
          }, r(l);
        }
        vt = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.create = function() {
          var l = new e.ARRAY_TYPE(9);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0, l[3] = 0, l[5] = 0, l[6] = 0, l[7] = 0), l[0] = 1, l[4] = 1, l[8] = 1, l;
        }, ht.fromMat4 = function(l, f) {
          return l[0] = f[0], l[1] = f[1], l[2] = f[2], l[3] = f[4], l[4] = f[5], l[5] = f[6], l[6] = f[8], l[7] = f[9], l[8] = f[10], l;
        }, ht.clone = function(l) {
          var f = new e.ARRAY_TYPE(9);
          return f[0] = l[0], f[1] = l[1], f[2] = l[2], f[3] = l[3], f[4] = l[4], f[5] = l[5], f[6] = l[6], f[7] = l[7], f[8] = l[8], f;
        }, ht.copy = function(l, f) {
          return l[0] = f[0], l[1] = f[1], l[2] = f[2], l[3] = f[3], l[4] = f[4], l[5] = f[5], l[6] = f[6], l[7] = f[7], l[8] = f[8], l;
        }, ht.fromValues = function(l, f, v, S, D, x, A, I, M) {
          var C = new e.ARRAY_TYPE(9);
          return C[0] = l, C[1] = f, C[2] = v, C[3] = S, C[4] = D, C[5] = x, C[6] = A, C[7] = I, C[8] = M, C;
        }, ht.set = function(l, f, v, S, D, x, A, I, M, C) {
          return l[0] = f, l[1] = v, l[2] = S, l[3] = D, l[4] = x, l[5] = A, l[6] = I, l[7] = M, l[8] = C, l;
        }, ht.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 1, l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ht.transpose = function(l, f) {
          if (l === f) {
            var v = f[1], S = f[2], D = f[5];
            l[1] = f[3], l[2] = f[6], l[3] = v, l[5] = f[7], l[6] = S, l[7] = D;
          } else
            l[0] = f[0], l[1] = f[3], l[2] = f[6], l[3] = f[1], l[4] = f[4], l[5] = f[7], l[6] = f[2], l[7] = f[5], l[8] = f[8];
          return l;
        }, ht.invert = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = f[4], I = f[5], M = f[6], C = f[7], k = f[8], V = k * A - I * C, U = -k * x + I * M, q = C * x - A * M, $ = v * V + S * U + D * q;
          return $ ? (l[0] = V * ($ = 1 / $), l[1] = (-k * S + D * C) * $, l[2] = (I * S - D * A) * $, l[3] = U * $, l[4] = (k * v - D * M) * $, l[5] = (-I * v + D * x) * $, l[6] = q * $, l[7] = (-C * v + S * M) * $, l[8] = (A * v - S * x) * $, l) : null;
        }, ht.adjoint = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = f[4], I = f[5], M = f[6], C = f[7], k = f[8];
          return l[0] = A * k - I * C, l[1] = D * C - S * k, l[2] = S * I - D * A, l[3] = I * M - x * k, l[4] = v * k - D * M, l[5] = D * x - v * I, l[6] = x * C - A * M, l[7] = S * M - v * C, l[8] = v * A - S * x, l;
        }, ht.determinant = function(l) {
          var f = l[3], v = l[4], S = l[5], D = l[6], x = l[7], A = l[8];
          return l[0] * (A * v - S * x) + l[1] * (-A * f + S * D) + l[2] * (x * f - v * D);
        }, ht.multiply = o, ht.translate = function(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = f[6], k = f[7], V = f[8], U = v[0], q = v[1];
          return l[0] = S, l[1] = D, l[2] = x, l[3] = A, l[4] = I, l[5] = M, l[6] = U * S + q * A + C, l[7] = U * D + q * I + k, l[8] = U * x + q * M + V, l;
        }, ht.rotate = function(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = f[6], k = f[7], V = f[8], U = Math.sin(v), q = Math.cos(v);
          return l[0] = q * S + U * A, l[1] = q * D + U * I, l[2] = q * x + U * M, l[3] = q * A - U * S, l[4] = q * I - U * D, l[5] = q * M - U * x, l[6] = C, l[7] = k, l[8] = V, l;
        }, ht.scale = function(l, f, v) {
          var S = v[0], D = v[1];
          return l[0] = S * f[0], l[1] = S * f[1], l[2] = S * f[2], l[3] = D * f[3], l[4] = D * f[4], l[5] = D * f[5], l[6] = f[6], l[7] = f[7], l[8] = f[8], l;
        }, ht.fromTranslation = function(l, f) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 1, l[5] = 0, l[6] = f[0], l[7] = f[1], l[8] = 1, l;
        }, ht.fromRotation = function(l, f) {
          var v = Math.sin(f), S = Math.cos(f);
          return l[0] = S, l[1] = v, l[2] = 0, l[3] = -v, l[4] = S, l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ht.fromScaling = function(l, f) {
          return l[0] = f[0], l[1] = 0, l[2] = 0, l[3] = 0, l[4] = f[1], l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ht.fromMat2d = function(l, f) {
          return l[0] = f[0], l[1] = f[1], l[2] = 0, l[3] = f[2], l[4] = f[3], l[5] = 0, l[6] = f[4], l[7] = f[5], l[8] = 1, l;
        }, ht.fromQuat = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = v + v, I = S + S, M = D + D, C = v * A, k = S * A, V = S * I, U = D * A, q = D * I, $ = D * M, H = x * A, K = x * I, Q = x * M;
          return l[0] = 1 - V - $, l[3] = k - Q, l[6] = U + K, l[1] = k + Q, l[4] = 1 - C - $, l[7] = q - H, l[2] = U - K, l[5] = q + H, l[8] = 1 - C - V, l;
        }, ht.normalFromMat4 = function(l, f) {
          var v = f[0], S = f[1], D = f[2], x = f[3], A = f[4], I = f[5], M = f[6], C = f[7], k = f[8], V = f[9], U = f[10], q = f[11], $ = f[12], H = f[13], K = f[14], Q = f[15], ie = v * I - S * A, fe = v * M - D * A, de = v * C - x * A, ue = S * M - D * I, Se = S * C - x * I, me = D * C - x * M, Ee = k * H - V * $, ze = k * K - U * $, Ie = k * Q - q * $, Re = V * K - U * H, Ve = V * Q - q * H, Ue = U * Q - q * K, Fe = ie * Ue - fe * Ve + de * Re + ue * Ie - Se * ze + me * Ee;
          return Fe ? (l[0] = (I * Ue - M * Ve + C * Re) * (Fe = 1 / Fe), l[1] = (M * Ie - A * Ue - C * ze) * Fe, l[2] = (A * Ve - I * Ie + C * Ee) * Fe, l[3] = (D * Ve - S * Ue - x * Re) * Fe, l[4] = (v * Ue - D * Ie + x * ze) * Fe, l[5] = (S * Ie - v * Ve - x * Ee) * Fe, l[6] = (H * me - K * Se + Q * ue) * Fe, l[7] = (K * de - $ * me - Q * fe) * Fe, l[8] = ($ * Se - H * de + Q * ie) * Fe, l) : null;
        }, ht.projection = function(l, f, v) {
          return l[0] = 2 / f, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = -2 / v, l[5] = 0, l[6] = -1, l[7] = 1, l[8] = 1, l;
        }, ht.str = function(l) {
          return "mat3(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ", " + l[8] + ")";
        }, ht.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8]);
        }, ht.add = function(l, f, v) {
          return l[0] = f[0] + v[0], l[1] = f[1] + v[1], l[2] = f[2] + v[2], l[3] = f[3] + v[3], l[4] = f[4] + v[4], l[5] = f[5] + v[5], l[6] = f[6] + v[6], l[7] = f[7] + v[7], l[8] = f[8] + v[8], l;
        }, ht.subtract = u, ht.multiplyScalar = function(l, f, v) {
          return l[0] = f[0] * v, l[1] = f[1] * v, l[2] = f[2] * v, l[3] = f[3] * v, l[4] = f[4] * v, l[5] = f[5] * v, l[6] = f[6] * v, l[7] = f[7] * v, l[8] = f[8] * v, l;
        }, ht.multiplyScalarAndAdd = function(l, f, v, S) {
          return l[0] = f[0] + v[0] * S, l[1] = f[1] + v[1] * S, l[2] = f[2] + v[2] * S, l[3] = f[3] + v[3] * S, l[4] = f[4] + v[4] * S, l[5] = f[5] + v[5] * S, l[6] = f[6] + v[6] * S, l[7] = f[7] + v[7] * S, l[8] = f[8] + v[8] * S, l;
        }, ht.exactEquals = function(l, f) {
          return l[0] === f[0] && l[1] === f[1] && l[2] === f[2] && l[3] === f[3] && l[4] === f[4] && l[5] === f[5] && l[6] === f[6] && l[7] === f[7] && l[8] === f[8];
        }, ht.equals = function(l, f) {
          var v = l[0], S = l[1], D = l[2], x = l[3], A = l[4], I = l[5], M = l[6], C = l[7], k = l[8], V = f[0], U = f[1], q = f[2], $ = f[3], H = f[4], K = f[5], Q = f[6], ie = f[7], fe = f[8];
          return Math.abs(v - V) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(V)) && Math.abs(S - U) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(U)) && Math.abs(D - q) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(q)) && Math.abs(x - $) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs($)) && Math.abs(A - H) <= e.EPSILON * Math.max(1, Math.abs(A), Math.abs(H)) && Math.abs(I - K) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(K)) && Math.abs(M - Q) <= e.EPSILON * Math.max(1, Math.abs(M), Math.abs(Q)) && Math.abs(C - ie) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(ie)) && Math.abs(k - fe) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(fe));
        }, ht.sub = ht.mul = void 0;
        var e = function(l, f) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var S = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var A = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              A && (A.get || A.set) ? Object.defineProperty(S, x, A) : S[x] = l[x];
            }
          return S.default = l, v && v.set(l, S), S;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var f = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(S) {
            return S ? v : f;
          })(l);
        }
        function o(l, f, v) {
          var S = f[0], D = f[1], x = f[2], A = f[3], I = f[4], M = f[5], C = f[6], k = f[7], V = f[8], U = v[0], q = v[1], $ = v[2], H = v[3], K = v[4], Q = v[5], ie = v[6], fe = v[7], de = v[8];
          return l[0] = U * S + q * A + $ * C, l[1] = U * D + q * I + $ * k, l[2] = U * x + q * M + $ * V, l[3] = H * S + K * A + Q * C, l[4] = H * D + K * I + Q * k, l[5] = H * x + K * M + Q * V, l[6] = ie * S + fe * A + de * C, l[7] = ie * D + fe * I + de * k, l[8] = ie * x + fe * M + de * V, l;
        }
        function u(l, f, v) {
          return l[0] = f[0] - v[0], l[1] = f[1] - v[1], l[2] = f[2] - v[2], l[3] = f[3] - v[3], l[4] = f[4] - v[4], l[5] = f[5] - v[5], l[6] = f[6] - v[6], l[7] = f[7] - v[7], l[8] = f[8] - v[8], l;
        }
        return ht.mul = o, ht.sub = u, ht;
      }
      var Vt, pt = {};
      function Gt() {
        if (Vt)
          return pt;
        function r(x) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
            return typeof A;
          } : function(A) {
            return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
          }, r(x);
        }
        Vt = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.create = function() {
          var x = new e.ARRAY_TYPE(16);
          return e.ARRAY_TYPE != Float32Array && (x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0), x[0] = 1, x[5] = 1, x[10] = 1, x[15] = 1, x;
        }, pt.clone = function(x) {
          var A = new e.ARRAY_TYPE(16);
          return A[0] = x[0], A[1] = x[1], A[2] = x[2], A[3] = x[3], A[4] = x[4], A[5] = x[5], A[6] = x[6], A[7] = x[7], A[8] = x[8], A[9] = x[9], A[10] = x[10], A[11] = x[11], A[12] = x[12], A[13] = x[13], A[14] = x[14], A[15] = x[15], A;
        }, pt.copy = function(x, A) {
          return x[0] = A[0], x[1] = A[1], x[2] = A[2], x[3] = A[3], x[4] = A[4], x[5] = A[5], x[6] = A[6], x[7] = A[7], x[8] = A[8], x[9] = A[9], x[10] = A[10], x[11] = A[11], x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15], x;
        }, pt.fromValues = function(x, A, I, M, C, k, V, U, q, $, H, K, Q, ie, fe, de) {
          var ue = new e.ARRAY_TYPE(16);
          return ue[0] = x, ue[1] = A, ue[2] = I, ue[3] = M, ue[4] = C, ue[5] = k, ue[6] = V, ue[7] = U, ue[8] = q, ue[9] = $, ue[10] = H, ue[11] = K, ue[12] = Q, ue[13] = ie, ue[14] = fe, ue[15] = de, ue;
        }, pt.set = function(x, A, I, M, C, k, V, U, q, $, H, K, Q, ie, fe, de, ue) {
          return x[0] = A, x[1] = I, x[2] = M, x[3] = C, x[4] = k, x[5] = V, x[6] = U, x[7] = q, x[8] = $, x[9] = H, x[10] = K, x[11] = Q, x[12] = ie, x[13] = fe, x[14] = de, x[15] = ue, x;
        }, pt.identity = o, pt.transpose = function(x, A) {
          if (x === A) {
            var I = A[1], M = A[2], C = A[3], k = A[6], V = A[7], U = A[11];
            x[1] = A[4], x[2] = A[8], x[3] = A[12], x[4] = I, x[6] = A[9], x[7] = A[13], x[8] = M, x[9] = k, x[11] = A[14], x[12] = C, x[13] = V, x[14] = U;
          } else
            x[0] = A[0], x[1] = A[4], x[2] = A[8], x[3] = A[12], x[4] = A[1], x[5] = A[5], x[6] = A[9], x[7] = A[13], x[8] = A[2], x[9] = A[6], x[10] = A[10], x[11] = A[14], x[12] = A[3], x[13] = A[7], x[14] = A[11], x[15] = A[15];
          return x;
        }, pt.invert = function(x, A) {
          var I = A[0], M = A[1], C = A[2], k = A[3], V = A[4], U = A[5], q = A[6], $ = A[7], H = A[8], K = A[9], Q = A[10], ie = A[11], fe = A[12], de = A[13], ue = A[14], Se = A[15], me = I * U - M * V, Ee = I * q - C * V, ze = I * $ - k * V, Ie = M * q - C * U, Re = M * $ - k * U, Ve = C * $ - k * q, Ue = H * de - K * fe, Fe = H * ue - Q * fe, et = H * Se - ie * fe, dt = K * ue - Q * de, tt = K * Se - ie * de, Mt = Q * Se - ie * ue, wt = me * Mt - Ee * tt + ze * dt + Ie * et - Re * Fe + Ve * Ue;
          return wt ? (x[0] = (U * Mt - q * tt + $ * dt) * (wt = 1 / wt), x[1] = (C * tt - M * Mt - k * dt) * wt, x[2] = (de * Ve - ue * Re + Se * Ie) * wt, x[3] = (Q * Re - K * Ve - ie * Ie) * wt, x[4] = (q * et - V * Mt - $ * Fe) * wt, x[5] = (I * Mt - C * et + k * Fe) * wt, x[6] = (ue * ze - fe * Ve - Se * Ee) * wt, x[7] = (H * Ve - Q * ze + ie * Ee) * wt, x[8] = (V * tt - U * et + $ * Ue) * wt, x[9] = (M * et - I * tt - k * Ue) * wt, x[10] = (fe * Re - de * ze + Se * me) * wt, x[11] = (K * ze - H * Re - ie * me) * wt, x[12] = (U * Fe - V * dt - q * Ue) * wt, x[13] = (I * dt - M * Fe + C * Ue) * wt, x[14] = (de * Ee - fe * Ie - ue * me) * wt, x[15] = (H * Ie - K * Ee + Q * me) * wt, x) : null;
        }, pt.adjoint = function(x, A) {
          var I = A[0], M = A[1], C = A[2], k = A[3], V = A[4], U = A[5], q = A[6], $ = A[7], H = A[8], K = A[9], Q = A[10], ie = A[11], fe = A[12], de = A[13], ue = A[14], Se = A[15];
          return x[0] = U * (Q * Se - ie * ue) - K * (q * Se - $ * ue) + de * (q * ie - $ * Q), x[1] = -(M * (Q * Se - ie * ue) - K * (C * Se - k * ue) + de * (C * ie - k * Q)), x[2] = M * (q * Se - $ * ue) - U * (C * Se - k * ue) + de * (C * $ - k * q), x[3] = -(M * (q * ie - $ * Q) - U * (C * ie - k * Q) + K * (C * $ - k * q)), x[4] = -(V * (Q * Se - ie * ue) - H * (q * Se - $ * ue) + fe * (q * ie - $ * Q)), x[5] = I * (Q * Se - ie * ue) - H * (C * Se - k * ue) + fe * (C * ie - k * Q), x[6] = -(I * (q * Se - $ * ue) - V * (C * Se - k * ue) + fe * (C * $ - k * q)), x[7] = I * (q * ie - $ * Q) - V * (C * ie - k * Q) + H * (C * $ - k * q), x[8] = V * (K * Se - ie * de) - H * (U * Se - $ * de) + fe * (U * ie - $ * K), x[9] = -(I * (K * Se - ie * de) - H * (M * Se - k * de) + fe * (M * ie - k * K)), x[10] = I * (U * Se - $ * de) - V * (M * Se - k * de) + fe * (M * $ - k * U), x[11] = -(I * (U * ie - $ * K) - V * (M * ie - k * K) + H * (M * $ - k * U)), x[12] = -(V * (K * ue - Q * de) - H * (U * ue - q * de) + fe * (U * Q - q * K)), x[13] = I * (K * ue - Q * de) - H * (M * ue - C * de) + fe * (M * Q - C * K), x[14] = -(I * (U * ue - q * de) - V * (M * ue - C * de) + fe * (M * q - C * U)), x[15] = I * (U * Q - q * K) - V * (M * Q - C * K) + H * (M * q - C * U), x;
        }, pt.determinant = function(x) {
          var A = x[0], I = x[1], M = x[2], C = x[3], k = x[4], V = x[5], U = x[6], q = x[7], $ = x[8], H = x[9], K = x[10], Q = x[11], ie = x[12], fe = x[13], de = x[14], ue = x[15];
          return (A * V - I * k) * (K * ue - Q * de) - (A * U - M * k) * (H * ue - Q * fe) + (A * q - C * k) * (H * de - K * fe) + (I * U - M * V) * ($ * ue - Q * ie) - (I * q - C * V) * ($ * de - K * ie) + (M * q - C * U) * ($ * fe - H * ie);
        }, pt.multiply = u, pt.translate = function(x, A, I) {
          var M, C, k, V, U, q, $, H, K, Q, ie, fe, de = I[0], ue = I[1], Se = I[2];
          return A === x ? (x[12] = A[0] * de + A[4] * ue + A[8] * Se + A[12], x[13] = A[1] * de + A[5] * ue + A[9] * Se + A[13], x[14] = A[2] * de + A[6] * ue + A[10] * Se + A[14], x[15] = A[3] * de + A[7] * ue + A[11] * Se + A[15]) : (C = A[1], k = A[2], V = A[3], U = A[4], q = A[5], $ = A[6], H = A[7], K = A[8], Q = A[9], ie = A[10], fe = A[11], x[0] = M = A[0], x[1] = C, x[2] = k, x[3] = V, x[4] = U, x[5] = q, x[6] = $, x[7] = H, x[8] = K, x[9] = Q, x[10] = ie, x[11] = fe, x[12] = M * de + U * ue + K * Se + A[12], x[13] = C * de + q * ue + Q * Se + A[13], x[14] = k * de + $ * ue + ie * Se + A[14], x[15] = V * de + H * ue + fe * Se + A[15]), x;
        }, pt.scale = function(x, A, I) {
          var M = I[0], C = I[1], k = I[2];
          return x[0] = A[0] * M, x[1] = A[1] * M, x[2] = A[2] * M, x[3] = A[3] * M, x[4] = A[4] * C, x[5] = A[5] * C, x[6] = A[6] * C, x[7] = A[7] * C, x[8] = A[8] * k, x[9] = A[9] * k, x[10] = A[10] * k, x[11] = A[11] * k, x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15], x;
        }, pt.rotate = function(x, A, I, M) {
          var C, k, V, U, q, $, H, K, Q, ie, fe, de, ue, Se, me, Ee, ze, Ie, Re, Ve, Ue, Fe, et, dt, tt = M[0], Mt = M[1], wt = M[2], Pt = Math.hypot(tt, Mt, wt);
          return Pt < e.EPSILON ? null : (tt *= Pt = 1 / Pt, Mt *= Pt, wt *= Pt, C = Math.sin(I), k = Math.cos(I), q = A[1], $ = A[2], H = A[3], Q = A[5], ie = A[6], fe = A[7], ue = A[9], Se = A[10], me = A[11], Ee = tt * tt * (V = 1 - k) + k, Re = tt * Mt * V - wt * C, Ve = Mt * Mt * V + k, Ue = wt * Mt * V + tt * C, Fe = tt * wt * V + Mt * C, et = Mt * wt * V - tt * C, dt = wt * wt * V + k, x[0] = (U = A[0]) * Ee + (K = A[4]) * (ze = Mt * tt * V + wt * C) + (de = A[8]) * (Ie = wt * tt * V - Mt * C), x[1] = q * Ee + Q * ze + ue * Ie, x[2] = $ * Ee + ie * ze + Se * Ie, x[3] = H * Ee + fe * ze + me * Ie, x[4] = U * Re + K * Ve + de * Ue, x[5] = q * Re + Q * Ve + ue * Ue, x[6] = $ * Re + ie * Ve + Se * Ue, x[7] = H * Re + fe * Ve + me * Ue, x[8] = U * Fe + K * et + de * dt, x[9] = q * Fe + Q * et + ue * dt, x[10] = $ * Fe + ie * et + Se * dt, x[11] = H * Fe + fe * et + me * dt, A !== x && (x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15]), x);
        }, pt.rotateX = function(x, A, I) {
          var M = Math.sin(I), C = Math.cos(I), k = A[4], V = A[5], U = A[6], q = A[7], $ = A[8], H = A[9], K = A[10], Q = A[11];
          return A !== x && (x[0] = A[0], x[1] = A[1], x[2] = A[2], x[3] = A[3], x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15]), x[4] = k * C + $ * M, x[5] = V * C + H * M, x[6] = U * C + K * M, x[7] = q * C + Q * M, x[8] = $ * C - k * M, x[9] = H * C - V * M, x[10] = K * C - U * M, x[11] = Q * C - q * M, x;
        }, pt.rotateY = function(x, A, I) {
          var M = Math.sin(I), C = Math.cos(I), k = A[0], V = A[1], U = A[2], q = A[3], $ = A[8], H = A[9], K = A[10], Q = A[11];
          return A !== x && (x[4] = A[4], x[5] = A[5], x[6] = A[6], x[7] = A[7], x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15]), x[0] = k * C - $ * M, x[1] = V * C - H * M, x[2] = U * C - K * M, x[3] = q * C - Q * M, x[8] = k * M + $ * C, x[9] = V * M + H * C, x[10] = U * M + K * C, x[11] = q * M + Q * C, x;
        }, pt.rotateZ = function(x, A, I) {
          var M = Math.sin(I), C = Math.cos(I), k = A[0], V = A[1], U = A[2], q = A[3], $ = A[4], H = A[5], K = A[6], Q = A[7];
          return A !== x && (x[8] = A[8], x[9] = A[9], x[10] = A[10], x[11] = A[11], x[12] = A[12], x[13] = A[13], x[14] = A[14], x[15] = A[15]), x[0] = k * C + $ * M, x[1] = V * C + H * M, x[2] = U * C + K * M, x[3] = q * C + Q * M, x[4] = $ * C - k * M, x[5] = H * C - V * M, x[6] = K * C - U * M, x[7] = Q * C - q * M, x;
        }, pt.fromTranslation = function(x, A) {
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = A[0], x[13] = A[1], x[14] = A[2], x[15] = 1, x;
        }, pt.fromScaling = function(x, A) {
          return x[0] = A[0], x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = A[1], x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = A[2], x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromRotation = function(x, A, I) {
          var M, C, k, V = I[0], U = I[1], q = I[2], $ = Math.hypot(V, U, q);
          return $ < e.EPSILON ? null : (V *= $ = 1 / $, U *= $, q *= $, M = Math.sin(A), C = Math.cos(A), x[0] = V * V * (k = 1 - C) + C, x[1] = U * V * k + q * M, x[2] = q * V * k - U * M, x[3] = 0, x[4] = V * U * k - q * M, x[5] = U * U * k + C, x[6] = q * U * k + V * M, x[7] = 0, x[8] = V * q * k + U * M, x[9] = U * q * k - V * M, x[10] = q * q * k + C, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x);
        }, pt.fromXRotation = function(x, A) {
          var I = Math.sin(A), M = Math.cos(A);
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = M, x[6] = I, x[7] = 0, x[8] = 0, x[9] = -I, x[10] = M, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromYRotation = function(x, A) {
          var I = Math.sin(A), M = Math.cos(A);
          return x[0] = M, x[1] = 0, x[2] = -I, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = I, x[9] = 0, x[10] = M, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromZRotation = function(x, A) {
          var I = Math.sin(A), M = Math.cos(A);
          return x[0] = M, x[1] = I, x[2] = 0, x[3] = 0, x[4] = -I, x[5] = M, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromRotationTranslation = l, pt.fromQuat2 = function(x, A) {
          var I = new e.ARRAY_TYPE(3), M = -A[0], C = -A[1], k = -A[2], V = A[3], U = A[4], q = A[5], $ = A[6], H = A[7], K = M * M + C * C + k * k + V * V;
          return K > 0 ? (I[0] = 2 * (U * V + H * M + q * k - $ * C) / K, I[1] = 2 * (q * V + H * C + $ * M - U * k) / K, I[2] = 2 * ($ * V + H * k + U * C - q * M) / K) : (I[0] = 2 * (U * V + H * M + q * k - $ * C), I[1] = 2 * (q * V + H * C + $ * M - U * k), I[2] = 2 * ($ * V + H * k + U * C - q * M)), l(x, A, I), x;
        }, pt.getTranslation = function(x, A) {
          return x[0] = A[12], x[1] = A[13], x[2] = A[14], x;
        }, pt.getScaling = f, pt.getRotation = function(x, A) {
          var I = new e.ARRAY_TYPE(3);
          f(I, A);
          var M = 1 / I[0], C = 1 / I[1], k = 1 / I[2], V = A[0] * M, U = A[1] * C, q = A[2] * k, $ = A[4] * M, H = A[5] * C, K = A[6] * k, Q = A[8] * M, ie = A[9] * C, fe = A[10] * k, de = V + H + fe, ue = 0;
          return de > 0 ? (ue = 2 * Math.sqrt(de + 1), x[3] = 0.25 * ue, x[0] = (K - ie) / ue, x[1] = (Q - q) / ue, x[2] = (U - $) / ue) : V > H && V > fe ? (ue = 2 * Math.sqrt(1 + V - H - fe), x[3] = (K - ie) / ue, x[0] = 0.25 * ue, x[1] = (U + $) / ue, x[2] = (Q + q) / ue) : H > fe ? (ue = 2 * Math.sqrt(1 + H - V - fe), x[3] = (Q - q) / ue, x[0] = (U + $) / ue, x[1] = 0.25 * ue, x[2] = (K + ie) / ue) : (ue = 2 * Math.sqrt(1 + fe - V - H), x[3] = (U - $) / ue, x[0] = (Q + q) / ue, x[1] = (K + ie) / ue, x[2] = 0.25 * ue), x;
        }, pt.fromRotationTranslationScale = function(x, A, I, M) {
          var C = A[0], k = A[1], V = A[2], U = A[3], q = C + C, $ = k + k, H = V + V, K = C * q, Q = C * $, ie = C * H, fe = k * $, de = k * H, ue = V * H, Se = U * q, me = U * $, Ee = U * H, ze = M[0], Ie = M[1], Re = M[2];
          return x[0] = (1 - (fe + ue)) * ze, x[1] = (Q + Ee) * ze, x[2] = (ie - me) * ze, x[3] = 0, x[4] = (Q - Ee) * Ie, x[5] = (1 - (K + ue)) * Ie, x[6] = (de + Se) * Ie, x[7] = 0, x[8] = (ie + me) * Re, x[9] = (de - Se) * Re, x[10] = (1 - (K + fe)) * Re, x[11] = 0, x[12] = I[0], x[13] = I[1], x[14] = I[2], x[15] = 1, x;
        }, pt.fromRotationTranslationScaleOrigin = function(x, A, I, M, C) {
          var k = A[0], V = A[1], U = A[2], q = A[3], $ = k + k, H = V + V, K = U + U, Q = k * $, ie = k * H, fe = k * K, de = V * H, ue = V * K, Se = U * K, me = q * $, Ee = q * H, ze = q * K, Ie = M[0], Re = M[1], Ve = M[2], Ue = C[0], Fe = C[1], et = C[2], dt = (1 - (de + Se)) * Ie, tt = (ie + ze) * Ie, Mt = (fe - Ee) * Ie, wt = (ie - ze) * Re, Pt = (1 - (Q + Se)) * Re, rt = (ue + me) * Re, Ut = (fe + Ee) * Ve, St = (ue - me) * Ve, Nt = (1 - (Q + de)) * Ve;
          return x[0] = dt, x[1] = tt, x[2] = Mt, x[3] = 0, x[4] = wt, x[5] = Pt, x[6] = rt, x[7] = 0, x[8] = Ut, x[9] = St, x[10] = Nt, x[11] = 0, x[12] = I[0] + Ue - (dt * Ue + wt * Fe + Ut * et), x[13] = I[1] + Fe - (tt * Ue + Pt * Fe + St * et), x[14] = I[2] + et - (Mt * Ue + rt * Fe + Nt * et), x[15] = 1, x;
        }, pt.fromQuat = function(x, A) {
          var I = A[0], M = A[1], C = A[2], k = A[3], V = I + I, U = M + M, q = C + C, $ = I * V, H = M * V, K = M * U, Q = C * V, ie = C * U, fe = C * q, de = k * V, ue = k * U, Se = k * q;
          return x[0] = 1 - K - fe, x[1] = H + Se, x[2] = Q - ue, x[3] = 0, x[4] = H - Se, x[5] = 1 - $ - fe, x[6] = ie + de, x[7] = 0, x[8] = Q + ue, x[9] = ie - de, x[10] = 1 - $ - K, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.frustum = function(x, A, I, M, C, k, V) {
          var U = 1 / (I - A), q = 1 / (C - M), $ = 1 / (k - V);
          return x[0] = 2 * k * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 2 * k * q, x[6] = 0, x[7] = 0, x[8] = (I + A) * U, x[9] = (C + M) * q, x[10] = (V + k) * $, x[11] = -1, x[12] = 0, x[13] = 0, x[14] = V * k * 2 * $, x[15] = 0, x;
        }, pt.perspectiveNO = v, pt.perspectiveZO = function(x, A, I, M, C) {
          var k, V = 1 / Math.tan(A / 2);
          return x[0] = V / I, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = V, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = -1, x[12] = 0, x[13] = 0, x[15] = 0, C != null && C !== 1 / 0 ? (x[10] = C * (k = 1 / (M - C)), x[14] = C * M * k) : (x[10] = -1, x[14] = -M), x;
        }, pt.perspectiveFromFieldOfView = function(x, A, I, M) {
          var C = Math.tan(A.upDegrees * Math.PI / 180), k = Math.tan(A.downDegrees * Math.PI / 180), V = Math.tan(A.leftDegrees * Math.PI / 180), U = Math.tan(A.rightDegrees * Math.PI / 180), q = 2 / (V + U), $ = 2 / (C + k);
          return x[0] = q, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = $, x[6] = 0, x[7] = 0, x[8] = -(V - U) * q * 0.5, x[9] = (C - k) * $ * 0.5, x[10] = M / (I - M), x[11] = -1, x[12] = 0, x[13] = 0, x[14] = M * I / (I - M), x[15] = 0, x;
        }, pt.orthoNO = S, pt.orthoZO = function(x, A, I, M, C, k, V) {
          var U = 1 / (A - I), q = 1 / (M - C), $ = 1 / (k - V);
          return x[0] = -2 * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = -2 * q, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = $, x[11] = 0, x[12] = (A + I) * U, x[13] = (C + M) * q, x[14] = k * $, x[15] = 1, x;
        }, pt.lookAt = function(x, A, I, M) {
          var C, k, V, U, q, $, H, K, Q, ie, fe = A[0], de = A[1], ue = A[2], Se = M[0], me = M[1], Ee = M[2], ze = I[0], Ie = I[1], Re = I[2];
          return Math.abs(fe - ze) < e.EPSILON && Math.abs(de - Ie) < e.EPSILON && Math.abs(ue - Re) < e.EPSILON ? o(x) : (H = fe - ze, K = de - Ie, Q = ue - Re, C = me * (Q *= ie = 1 / Math.hypot(H, K, Q)) - Ee * (K *= ie), k = Ee * (H *= ie) - Se * Q, V = Se * K - me * H, (ie = Math.hypot(C, k, V)) ? (C *= ie = 1 / ie, k *= ie, V *= ie) : (C = 0, k = 0, V = 0), U = K * V - Q * k, q = Q * C - H * V, $ = H * k - K * C, (ie = Math.hypot(U, q, $)) ? (U *= ie = 1 / ie, q *= ie, $ *= ie) : (U = 0, q = 0, $ = 0), x[0] = C, x[1] = U, x[2] = H, x[3] = 0, x[4] = k, x[5] = q, x[6] = K, x[7] = 0, x[8] = V, x[9] = $, x[10] = Q, x[11] = 0, x[12] = -(C * fe + k * de + V * ue), x[13] = -(U * fe + q * de + $ * ue), x[14] = -(H * fe + K * de + Q * ue), x[15] = 1, x);
        }, pt.targetTo = function(x, A, I, M) {
          var C = A[0], k = A[1], V = A[2], U = M[0], q = M[1], $ = M[2], H = C - I[0], K = k - I[1], Q = V - I[2], ie = H * H + K * K + Q * Q;
          ie > 0 && (H *= ie = 1 / Math.sqrt(ie), K *= ie, Q *= ie);
          var fe = q * Q - $ * K, de = $ * H - U * Q, ue = U * K - q * H;
          return (ie = fe * fe + de * de + ue * ue) > 0 && (fe *= ie = 1 / Math.sqrt(ie), de *= ie, ue *= ie), x[0] = fe, x[1] = de, x[2] = ue, x[3] = 0, x[4] = K * ue - Q * de, x[5] = Q * fe - H * ue, x[6] = H * de - K * fe, x[7] = 0, x[8] = H, x[9] = K, x[10] = Q, x[11] = 0, x[12] = C, x[13] = k, x[14] = V, x[15] = 1, x;
        }, pt.str = function(x) {
          return "mat4(" + x[0] + ", " + x[1] + ", " + x[2] + ", " + x[3] + ", " + x[4] + ", " + x[5] + ", " + x[6] + ", " + x[7] + ", " + x[8] + ", " + x[9] + ", " + x[10] + ", " + x[11] + ", " + x[12] + ", " + x[13] + ", " + x[14] + ", " + x[15] + ")";
        }, pt.frob = function(x) {
          return Math.hypot(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15]);
        }, pt.add = function(x, A, I) {
          return x[0] = A[0] + I[0], x[1] = A[1] + I[1], x[2] = A[2] + I[2], x[3] = A[3] + I[3], x[4] = A[4] + I[4], x[5] = A[5] + I[5], x[6] = A[6] + I[6], x[7] = A[7] + I[7], x[8] = A[8] + I[8], x[9] = A[9] + I[9], x[10] = A[10] + I[10], x[11] = A[11] + I[11], x[12] = A[12] + I[12], x[13] = A[13] + I[13], x[14] = A[14] + I[14], x[15] = A[15] + I[15], x;
        }, pt.subtract = D, pt.multiplyScalar = function(x, A, I) {
          return x[0] = A[0] * I, x[1] = A[1] * I, x[2] = A[2] * I, x[3] = A[3] * I, x[4] = A[4] * I, x[5] = A[5] * I, x[6] = A[6] * I, x[7] = A[7] * I, x[8] = A[8] * I, x[9] = A[9] * I, x[10] = A[10] * I, x[11] = A[11] * I, x[12] = A[12] * I, x[13] = A[13] * I, x[14] = A[14] * I, x[15] = A[15] * I, x;
        }, pt.multiplyScalarAndAdd = function(x, A, I, M) {
          return x[0] = A[0] + I[0] * M, x[1] = A[1] + I[1] * M, x[2] = A[2] + I[2] * M, x[3] = A[3] + I[3] * M, x[4] = A[4] + I[4] * M, x[5] = A[5] + I[5] * M, x[6] = A[6] + I[6] * M, x[7] = A[7] + I[7] * M, x[8] = A[8] + I[8] * M, x[9] = A[9] + I[9] * M, x[10] = A[10] + I[10] * M, x[11] = A[11] + I[11] * M, x[12] = A[12] + I[12] * M, x[13] = A[13] + I[13] * M, x[14] = A[14] + I[14] * M, x[15] = A[15] + I[15] * M, x;
        }, pt.exactEquals = function(x, A) {
          return x[0] === A[0] && x[1] === A[1] && x[2] === A[2] && x[3] === A[3] && x[4] === A[4] && x[5] === A[5] && x[6] === A[6] && x[7] === A[7] && x[8] === A[8] && x[9] === A[9] && x[10] === A[10] && x[11] === A[11] && x[12] === A[12] && x[13] === A[13] && x[14] === A[14] && x[15] === A[15];
        }, pt.equals = function(x, A) {
          var I = x[0], M = x[1], C = x[2], k = x[3], V = x[4], U = x[5], q = x[6], $ = x[7], H = x[8], K = x[9], Q = x[10], ie = x[11], fe = x[12], de = x[13], ue = x[14], Se = x[15], me = A[0], Ee = A[1], ze = A[2], Ie = A[3], Re = A[4], Ve = A[5], Ue = A[6], Fe = A[7], et = A[8], dt = A[9], tt = A[10], Mt = A[11], wt = A[12], Pt = A[13], rt = A[14], Ut = A[15];
          return Math.abs(I - me) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(me)) && Math.abs(M - Ee) <= e.EPSILON * Math.max(1, Math.abs(M), Math.abs(Ee)) && Math.abs(C - ze) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(ze)) && Math.abs(k - Ie) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(Ie)) && Math.abs(V - Re) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(Re)) && Math.abs(U - Ve) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(Ve)) && Math.abs(q - Ue) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(Ue)) && Math.abs($ - Fe) <= e.EPSILON * Math.max(1, Math.abs($), Math.abs(Fe)) && Math.abs(H - et) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(et)) && Math.abs(K - dt) <= e.EPSILON * Math.max(1, Math.abs(K), Math.abs(dt)) && Math.abs(Q - tt) <= e.EPSILON * Math.max(1, Math.abs(Q), Math.abs(tt)) && Math.abs(ie - Mt) <= e.EPSILON * Math.max(1, Math.abs(ie), Math.abs(Mt)) && Math.abs(fe - wt) <= e.EPSILON * Math.max(1, Math.abs(fe), Math.abs(wt)) && Math.abs(de - Pt) <= e.EPSILON * Math.max(1, Math.abs(de), Math.abs(Pt)) && Math.abs(ue - rt) <= e.EPSILON * Math.max(1, Math.abs(ue), Math.abs(rt)) && Math.abs(Se - Ut) <= e.EPSILON * Math.max(1, Math.abs(Se), Math.abs(Ut));
        }, pt.sub = pt.mul = pt.ortho = pt.perspective = void 0;
        var e = function(x, A) {
          if (x && x.__esModule)
            return x;
          if (x === null || r(x) !== "object" && typeof x != "function")
            return { default: x };
          var I = n(void 0);
          if (I && I.has(x))
            return I.get(x);
          var M = {}, C = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var k in x)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(x, k)) {
              var V = C ? Object.getOwnPropertyDescriptor(x, k) : null;
              V && (V.get || V.set) ? Object.defineProperty(M, k, V) : M[k] = x[k];
            }
          return M.default = x, I && I.set(x, M), M;
        }(ae());
        function n(x) {
          if (typeof WeakMap != "function")
            return null;
          var A = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap();
          return (n = function(M) {
            return M ? I : A;
          })(x);
        }
        function o(x) {
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }
        function u(x, A, I) {
          var M = A[0], C = A[1], k = A[2], V = A[3], U = A[4], q = A[5], $ = A[6], H = A[7], K = A[8], Q = A[9], ie = A[10], fe = A[11], de = A[12], ue = A[13], Se = A[14], me = A[15], Ee = I[0], ze = I[1], Ie = I[2], Re = I[3];
          return x[0] = Ee * M + ze * U + Ie * K + Re * de, x[1] = Ee * C + ze * q + Ie * Q + Re * ue, x[2] = Ee * k + ze * $ + Ie * ie + Re * Se, x[3] = Ee * V + ze * H + Ie * fe + Re * me, x[4] = (Ee = I[4]) * M + (ze = I[5]) * U + (Ie = I[6]) * K + (Re = I[7]) * de, x[5] = Ee * C + ze * q + Ie * Q + Re * ue, x[6] = Ee * k + ze * $ + Ie * ie + Re * Se, x[7] = Ee * V + ze * H + Ie * fe + Re * me, x[8] = (Ee = I[8]) * M + (ze = I[9]) * U + (Ie = I[10]) * K + (Re = I[11]) * de, x[9] = Ee * C + ze * q + Ie * Q + Re * ue, x[10] = Ee * k + ze * $ + Ie * ie + Re * Se, x[11] = Ee * V + ze * H + Ie * fe + Re * me, x[12] = (Ee = I[12]) * M + (ze = I[13]) * U + (Ie = I[14]) * K + (Re = I[15]) * de, x[13] = Ee * C + ze * q + Ie * Q + Re * ue, x[14] = Ee * k + ze * $ + Ie * ie + Re * Se, x[15] = Ee * V + ze * H + Ie * fe + Re * me, x;
        }
        function l(x, A, I) {
          var M = A[0], C = A[1], k = A[2], V = A[3], U = M + M, q = C + C, $ = k + k, H = M * U, K = M * q, Q = M * $, ie = C * q, fe = C * $, de = k * $, ue = V * U, Se = V * q, me = V * $;
          return x[0] = 1 - (ie + de), x[1] = K + me, x[2] = Q - Se, x[3] = 0, x[4] = K - me, x[5] = 1 - (H + de), x[6] = fe + ue, x[7] = 0, x[8] = Q + Se, x[9] = fe - ue, x[10] = 1 - (H + ie), x[11] = 0, x[12] = I[0], x[13] = I[1], x[14] = I[2], x[15] = 1, x;
        }
        function f(x, A) {
          var I = A[4], M = A[5], C = A[6], k = A[8], V = A[9], U = A[10];
          return x[0] = Math.hypot(A[0], A[1], A[2]), x[1] = Math.hypot(I, M, C), x[2] = Math.hypot(k, V, U), x;
        }
        function v(x, A, I, M, C) {
          var k, V = 1 / Math.tan(A / 2);
          return x[0] = V / I, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = V, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = -1, x[12] = 0, x[13] = 0, x[15] = 0, C != null && C !== 1 / 0 ? (x[10] = (C + M) * (k = 1 / (M - C)), x[14] = 2 * C * M * k) : (x[10] = -1, x[14] = -2 * M), x;
        }
        function S(x, A, I, M, C, k, V) {
          var U = 1 / (A - I), q = 1 / (M - C), $ = 1 / (k - V);
          return x[0] = -2 * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = -2 * q, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 2 * $, x[11] = 0, x[12] = (A + I) * U, x[13] = (C + M) * q, x[14] = (V + k) * $, x[15] = 1, x;
        }
        function D(x, A, I) {
          return x[0] = A[0] - I[0], x[1] = A[1] - I[1], x[2] = A[2] - I[2], x[3] = A[3] - I[3], x[4] = A[4] - I[4], x[5] = A[5] - I[5], x[6] = A[6] - I[6], x[7] = A[7] - I[7], x[8] = A[8] - I[8], x[9] = A[9] - I[9], x[10] = A[10] - I[10], x[11] = A[11] - I[11], x[12] = A[12] - I[12], x[13] = A[13] - I[13], x[14] = A[14] - I[14], x[15] = A[15] - I[15], x;
        }
        return pt.perspective = v, pt.ortho = S, pt.mul = u, pt.sub = D, pt;
      }
      var ui, kt = {}, At = {};
      function Mi() {
        if (ui)
          return At;
        function r(C) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, r(C);
        }
        ui = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.create = o, At.clone = function(C) {
          var k = new e.ARRAY_TYPE(3);
          return k[0] = C[0], k[1] = C[1], k[2] = C[2], k;
        }, At.length = u, At.fromValues = function(C, k, V) {
          var U = new e.ARRAY_TYPE(3);
          return U[0] = C, U[1] = k, U[2] = V, U;
        }, At.copy = function(C, k) {
          return C[0] = k[0], C[1] = k[1], C[2] = k[2], C;
        }, At.set = function(C, k, V, U) {
          return C[0] = k, C[1] = V, C[2] = U, C;
        }, At.add = function(C, k, V) {
          return C[0] = k[0] + V[0], C[1] = k[1] + V[1], C[2] = k[2] + V[2], C;
        }, At.subtract = l, At.multiply = f, At.divide = v, At.ceil = function(C, k) {
          return C[0] = Math.ceil(k[0]), C[1] = Math.ceil(k[1]), C[2] = Math.ceil(k[2]), C;
        }, At.floor = function(C, k) {
          return C[0] = Math.floor(k[0]), C[1] = Math.floor(k[1]), C[2] = Math.floor(k[2]), C;
        }, At.min = function(C, k, V) {
          return C[0] = Math.min(k[0], V[0]), C[1] = Math.min(k[1], V[1]), C[2] = Math.min(k[2], V[2]), C;
        }, At.max = function(C, k, V) {
          return C[0] = Math.max(k[0], V[0]), C[1] = Math.max(k[1], V[1]), C[2] = Math.max(k[2], V[2]), C;
        }, At.round = function(C, k) {
          return C[0] = Math.round(k[0]), C[1] = Math.round(k[1]), C[2] = Math.round(k[2]), C;
        }, At.scale = function(C, k, V) {
          return C[0] = k[0] * V, C[1] = k[1] * V, C[2] = k[2] * V, C;
        }, At.scaleAndAdd = function(C, k, V, U) {
          return C[0] = k[0] + V[0] * U, C[1] = k[1] + V[1] * U, C[2] = k[2] + V[2] * U, C;
        }, At.distance = S, At.squaredDistance = D, At.squaredLength = x, At.negate = function(C, k) {
          return C[0] = -k[0], C[1] = -k[1], C[2] = -k[2], C;
        }, At.inverse = function(C, k) {
          return C[0] = 1 / k[0], C[1] = 1 / k[1], C[2] = 1 / k[2], C;
        }, At.normalize = function(C, k) {
          var V = k[0], U = k[1], q = k[2], $ = V * V + U * U + q * q;
          return $ > 0 && ($ = 1 / Math.sqrt($)), C[0] = k[0] * $, C[1] = k[1] * $, C[2] = k[2] * $, C;
        }, At.dot = A, At.cross = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2], H = V[0], K = V[1], Q = V[2];
          return C[0] = q * Q - $ * K, C[1] = $ * H - U * Q, C[2] = U * K - q * H, C;
        }, At.lerp = function(C, k, V, U) {
          var q = k[0], $ = k[1], H = k[2];
          return C[0] = q + U * (V[0] - q), C[1] = $ + U * (V[1] - $), C[2] = H + U * (V[2] - H), C;
        }, At.hermite = function(C, k, V, U, q, $) {
          var H = $ * $, K = H * (2 * $ - 3) + 1, Q = H * ($ - 2) + $, ie = H * ($ - 1), fe = H * (3 - 2 * $);
          return C[0] = k[0] * K + V[0] * Q + U[0] * ie + q[0] * fe, C[1] = k[1] * K + V[1] * Q + U[1] * ie + q[1] * fe, C[2] = k[2] * K + V[2] * Q + U[2] * ie + q[2] * fe, C;
        }, At.bezier = function(C, k, V, U, q, $) {
          var H = 1 - $, K = H * H, Q = $ * $, ie = K * H, fe = 3 * $ * K, de = 3 * Q * H, ue = Q * $;
          return C[0] = k[0] * ie + V[0] * fe + U[0] * de + q[0] * ue, C[1] = k[1] * ie + V[1] * fe + U[1] * de + q[1] * ue, C[2] = k[2] * ie + V[2] * fe + U[2] * de + q[2] * ue, C;
        }, At.random = function(C, k) {
          k = k || 1;
          var V = 2 * e.RANDOM() * Math.PI, U = 2 * e.RANDOM() - 1, q = Math.sqrt(1 - U * U) * k;
          return C[0] = Math.cos(V) * q, C[1] = Math.sin(V) * q, C[2] = U * k, C;
        }, At.transformMat4 = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2], H = V[3] * U + V[7] * q + V[11] * $ + V[15];
          return C[0] = (V[0] * U + V[4] * q + V[8] * $ + V[12]) / (H = H || 1), C[1] = (V[1] * U + V[5] * q + V[9] * $ + V[13]) / H, C[2] = (V[2] * U + V[6] * q + V[10] * $ + V[14]) / H, C;
        }, At.transformMat3 = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2];
          return C[0] = U * V[0] + q * V[3] + $ * V[6], C[1] = U * V[1] + q * V[4] + $ * V[7], C[2] = U * V[2] + q * V[5] + $ * V[8], C;
        }, At.transformQuat = function(C, k, V) {
          var U = V[0], q = V[1], $ = V[2], H = k[0], K = k[1], Q = k[2], ie = q * Q - $ * K, fe = $ * H - U * Q, de = U * K - q * H, ue = q * de - $ * fe, Se = $ * ie - U * de, me = U * fe - q * ie, Ee = 2 * V[3];
          return fe *= Ee, de *= Ee, Se *= 2, me *= 2, C[0] = H + (ie *= Ee) + (ue *= 2), C[1] = K + fe + Se, C[2] = Q + de + me, C;
        }, At.rotateX = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[0], $[1] = q[1] * Math.cos(U) - q[2] * Math.sin(U), $[2] = q[1] * Math.sin(U) + q[2] * Math.cos(U), C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.rotateY = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[2] * Math.sin(U) + q[0] * Math.cos(U), $[1] = q[1], $[2] = q[2] * Math.cos(U) - q[0] * Math.sin(U), C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.rotateZ = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[0] * Math.cos(U) - q[1] * Math.sin(U), $[1] = q[0] * Math.sin(U) + q[1] * Math.cos(U), $[2] = q[2], C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.angle = function(C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2], Q = Math.sqrt(V * V + U * U + q * q) * Math.sqrt($ * $ + H * H + K * K), ie = Q && A(C, k) / Q;
          return Math.acos(Math.min(Math.max(ie, -1), 1));
        }, At.zero = function(C) {
          return C[0] = 0, C[1] = 0, C[2] = 0, C;
        }, At.str = function(C) {
          return "vec3(" + C[0] + ", " + C[1] + ", " + C[2] + ")";
        }, At.exactEquals = function(C, k) {
          return C[0] === k[0] && C[1] === k[1] && C[2] === k[2];
        }, At.equals = function(C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2];
          return Math.abs(V - $) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs($)) && Math.abs(U - H) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(H)) && Math.abs(q - K) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(K));
        }, At.forEach = At.sqrLen = At.len = At.sqrDist = At.dist = At.div = At.mul = At.sub = void 0;
        var e = function(C, k) {
          if (C && C.__esModule)
            return C;
          if (C === null || r(C) !== "object" && typeof C != "function")
            return { default: C };
          var V = n(void 0);
          if (V && V.has(C))
            return V.get(C);
          var U = {}, q = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var $ in C)
            if ($ !== "default" && Object.prototype.hasOwnProperty.call(C, $)) {
              var H = q ? Object.getOwnPropertyDescriptor(C, $) : null;
              H && (H.get || H.set) ? Object.defineProperty(U, $, H) : U[$] = C[$];
            }
          return U.default = C, V && V.set(C, U), U;
        }(ae());
        function n(C) {
          if (typeof WeakMap != "function")
            return null;
          var k = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap();
          return (n = function(U) {
            return U ? V : k;
          })(C);
        }
        function o() {
          var C = new e.ARRAY_TYPE(3);
          return e.ARRAY_TYPE != Float32Array && (C[0] = 0, C[1] = 0, C[2] = 0), C;
        }
        function u(C) {
          return Math.hypot(C[0], C[1], C[2]);
        }
        function l(C, k, V) {
          return C[0] = k[0] - V[0], C[1] = k[1] - V[1], C[2] = k[2] - V[2], C;
        }
        function f(C, k, V) {
          return C[0] = k[0] * V[0], C[1] = k[1] * V[1], C[2] = k[2] * V[2], C;
        }
        function v(C, k, V) {
          return C[0] = k[0] / V[0], C[1] = k[1] / V[1], C[2] = k[2] / V[2], C;
        }
        function S(C, k) {
          return Math.hypot(k[0] - C[0], k[1] - C[1], k[2] - C[2]);
        }
        function D(C, k) {
          var V = k[0] - C[0], U = k[1] - C[1], q = k[2] - C[2];
          return V * V + U * U + q * q;
        }
        function x(C) {
          var k = C[0], V = C[1], U = C[2];
          return k * k + V * V + U * U;
        }
        function A(C, k) {
          return C[0] * k[0] + C[1] * k[1] + C[2] * k[2];
        }
        At.sub = l, At.mul = f, At.div = v, At.dist = S, At.sqrDist = D, At.len = u, At.sqrLen = x;
        var I, M = (I = o(), function(C, k, V, U, q, $) {
          var H, K;
          for (k || (k = 3), V || (V = 0), K = U ? Math.min(U * k + V, C.length) : C.length, H = V; H < K; H += k)
            I[0] = C[H], I[1] = C[H + 1], I[2] = C[H + 2], q(I, I, $), C[H] = I[0], C[H + 1] = I[1], C[H + 2] = I[2];
          return C;
        });
        return At.forEach = M, At;
      }
      var An, hn, Ht = {};
      function Si() {
        if (An)
          return Ht;
        function r(M) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(M);
        }
        An = 1, Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.create = o, Ht.clone = function(M) {
          var C = new e.ARRAY_TYPE(4);
          return C[0] = M[0], C[1] = M[1], C[2] = M[2], C[3] = M[3], C;
        }, Ht.fromValues = function(M, C, k, V) {
          var U = new e.ARRAY_TYPE(4);
          return U[0] = M, U[1] = C, U[2] = k, U[3] = V, U;
        }, Ht.copy = function(M, C) {
          return M[0] = C[0], M[1] = C[1], M[2] = C[2], M[3] = C[3], M;
        }, Ht.set = function(M, C, k, V, U) {
          return M[0] = C, M[1] = k, M[2] = V, M[3] = U, M;
        }, Ht.add = function(M, C, k) {
          return M[0] = C[0] + k[0], M[1] = C[1] + k[1], M[2] = C[2] + k[2], M[3] = C[3] + k[3], M;
        }, Ht.subtract = u, Ht.multiply = l, Ht.divide = f, Ht.ceil = function(M, C) {
          return M[0] = Math.ceil(C[0]), M[1] = Math.ceil(C[1]), M[2] = Math.ceil(C[2]), M[3] = Math.ceil(C[3]), M;
        }, Ht.floor = function(M, C) {
          return M[0] = Math.floor(C[0]), M[1] = Math.floor(C[1]), M[2] = Math.floor(C[2]), M[3] = Math.floor(C[3]), M;
        }, Ht.min = function(M, C, k) {
          return M[0] = Math.min(C[0], k[0]), M[1] = Math.min(C[1], k[1]), M[2] = Math.min(C[2], k[2]), M[3] = Math.min(C[3], k[3]), M;
        }, Ht.max = function(M, C, k) {
          return M[0] = Math.max(C[0], k[0]), M[1] = Math.max(C[1], k[1]), M[2] = Math.max(C[2], k[2]), M[3] = Math.max(C[3], k[3]), M;
        }, Ht.round = function(M, C) {
          return M[0] = Math.round(C[0]), M[1] = Math.round(C[1]), M[2] = Math.round(C[2]), M[3] = Math.round(C[3]), M;
        }, Ht.scale = function(M, C, k) {
          return M[0] = C[0] * k, M[1] = C[1] * k, M[2] = C[2] * k, M[3] = C[3] * k, M;
        }, Ht.scaleAndAdd = function(M, C, k, V) {
          return M[0] = C[0] + k[0] * V, M[1] = C[1] + k[1] * V, M[2] = C[2] + k[2] * V, M[3] = C[3] + k[3] * V, M;
        }, Ht.distance = v, Ht.squaredDistance = S, Ht.length = D, Ht.squaredLength = x, Ht.negate = function(M, C) {
          return M[0] = -C[0], M[1] = -C[1], M[2] = -C[2], M[3] = -C[3], M;
        }, Ht.inverse = function(M, C) {
          return M[0] = 1 / C[0], M[1] = 1 / C[1], M[2] = 1 / C[2], M[3] = 1 / C[3], M;
        }, Ht.normalize = function(M, C) {
          var k = C[0], V = C[1], U = C[2], q = C[3], $ = k * k + V * V + U * U + q * q;
          return $ > 0 && ($ = 1 / Math.sqrt($)), M[0] = k * $, M[1] = V * $, M[2] = U * $, M[3] = q * $, M;
        }, Ht.dot = function(M, C) {
          return M[0] * C[0] + M[1] * C[1] + M[2] * C[2] + M[3] * C[3];
        }, Ht.cross = function(M, C, k, V) {
          var U = k[0] * V[1] - k[1] * V[0], q = k[0] * V[2] - k[2] * V[0], $ = k[0] * V[3] - k[3] * V[0], H = k[1] * V[2] - k[2] * V[1], K = k[1] * V[3] - k[3] * V[1], Q = k[2] * V[3] - k[3] * V[2], ie = C[0], fe = C[1], de = C[2], ue = C[3];
          return M[0] = fe * Q - de * K + ue * H, M[1] = -ie * Q + de * $ - ue * q, M[2] = ie * K - fe * $ + ue * U, M[3] = -ie * H + fe * q - de * U, M;
        }, Ht.lerp = function(M, C, k, V) {
          var U = C[0], q = C[1], $ = C[2], H = C[3];
          return M[0] = U + V * (k[0] - U), M[1] = q + V * (k[1] - q), M[2] = $ + V * (k[2] - $), M[3] = H + V * (k[3] - H), M;
        }, Ht.random = function(M, C) {
          var k, V, U, q, $, H;
          C = C || 1;
          do
            $ = (k = 2 * e.RANDOM() - 1) * k + (V = 2 * e.RANDOM() - 1) * V;
          while ($ >= 1);
          do
            H = (U = 2 * e.RANDOM() - 1) * U + (q = 2 * e.RANDOM() - 1) * q;
          while (H >= 1);
          var K = Math.sqrt((1 - $) / H);
          return M[0] = C * k, M[1] = C * V, M[2] = C * U * K, M[3] = C * q * K, M;
        }, Ht.transformMat4 = function(M, C, k) {
          var V = C[0], U = C[1], q = C[2], $ = C[3];
          return M[0] = k[0] * V + k[4] * U + k[8] * q + k[12] * $, M[1] = k[1] * V + k[5] * U + k[9] * q + k[13] * $, M[2] = k[2] * V + k[6] * U + k[10] * q + k[14] * $, M[3] = k[3] * V + k[7] * U + k[11] * q + k[15] * $, M;
        }, Ht.transformQuat = function(M, C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2], Q = k[3], ie = Q * V + H * q - K * U, fe = Q * U + K * V - $ * q, de = Q * q + $ * U - H * V, ue = -$ * V - H * U - K * q;
          return M[0] = ie * Q + ue * -$ + fe * -K - de * -H, M[1] = fe * Q + ue * -H + de * -$ - ie * -K, M[2] = de * Q + ue * -K + ie * -H - fe * -$, M[3] = C[3], M;
        }, Ht.zero = function(M) {
          return M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0, M;
        }, Ht.str = function(M) {
          return "vec4(" + M[0] + ", " + M[1] + ", " + M[2] + ", " + M[3] + ")";
        }, Ht.exactEquals = function(M, C) {
          return M[0] === C[0] && M[1] === C[1] && M[2] === C[2] && M[3] === C[3];
        }, Ht.equals = function(M, C) {
          var k = M[0], V = M[1], U = M[2], q = M[3], $ = C[0], H = C[1], K = C[2], Q = C[3];
          return Math.abs(k - $) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs($)) && Math.abs(V - H) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(H)) && Math.abs(U - K) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(K)) && Math.abs(q - Q) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(Q));
        }, Ht.forEach = Ht.sqrLen = Ht.len = Ht.sqrDist = Ht.dist = Ht.div = Ht.mul = Ht.sub = void 0;
        var e = function(M, C) {
          if (M && M.__esModule)
            return M;
          if (M === null || r(M) !== "object" && typeof M != "function")
            return { default: M };
          var k = n(void 0);
          if (k && k.has(M))
            return k.get(M);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in M)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(M, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(M, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = M[q];
            }
          return V.default = M, k && k.set(M, V), V;
        }(ae());
        function n(M) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (n = function(V) {
            return V ? k : C;
          })(M);
        }
        function o() {
          var M = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0, M[2] = 0, M[3] = 0), M;
        }
        function u(M, C, k) {
          return M[0] = C[0] - k[0], M[1] = C[1] - k[1], M[2] = C[2] - k[2], M[3] = C[3] - k[3], M;
        }
        function l(M, C, k) {
          return M[0] = C[0] * k[0], M[1] = C[1] * k[1], M[2] = C[2] * k[2], M[3] = C[3] * k[3], M;
        }
        function f(M, C, k) {
          return M[0] = C[0] / k[0], M[1] = C[1] / k[1], M[2] = C[2] / k[2], M[3] = C[3] / k[3], M;
        }
        function v(M, C) {
          return Math.hypot(C[0] - M[0], C[1] - M[1], C[2] - M[2], C[3] - M[3]);
        }
        function S(M, C) {
          var k = C[0] - M[0], V = C[1] - M[1], U = C[2] - M[2], q = C[3] - M[3];
          return k * k + V * V + U * U + q * q;
        }
        function D(M) {
          return Math.hypot(M[0], M[1], M[2], M[3]);
        }
        function x(M) {
          var C = M[0], k = M[1], V = M[2], U = M[3];
          return C * C + k * k + V * V + U * U;
        }
        Ht.sub = u, Ht.mul = l, Ht.div = f, Ht.dist = v, Ht.sqrDist = S, Ht.len = D, Ht.sqrLen = x;
        var A, I = (A = o(), function(M, C, k, V, U, q) {
          var $, H;
          for (C || (C = 4), k || (k = 0), H = V ? Math.min(V * C + k, M.length) : M.length, $ = k; $ < H; $ += C)
            A[0] = M[$], A[1] = M[$ + 1], A[2] = M[$ + 2], A[3] = M[$ + 3], U(A, A, q), M[$] = A[0], M[$ + 1] = A[1], M[$ + 2] = A[2], M[$ + 3] = A[3];
          return M;
        });
        return Ht.forEach = I, Ht;
      }
      function Ji() {
        if (hn)
          return kt;
        function r(me) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ee) {
            return typeof Ee;
          } : function(Ee) {
            return Ee && typeof Symbol == "function" && Ee.constructor === Symbol && Ee !== Symbol.prototype ? "symbol" : typeof Ee;
          }, r(me);
        }
        hn = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.create = v, kt.identity = function(me) {
          return me[0] = 0, me[1] = 0, me[2] = 0, me[3] = 1, me;
        }, kt.setAxisAngle = S, kt.getAxisAngle = function(me, Ee) {
          var ze = 2 * Math.acos(Ee[3]), Ie = Math.sin(ze / 2);
          return Ie > e.EPSILON ? (me[0] = Ee[0] / Ie, me[1] = Ee[1] / Ie, me[2] = Ee[2] / Ie) : (me[0] = 1, me[1] = 0, me[2] = 0), ze;
        }, kt.getAngle = function(me, Ee) {
          var ze = k(me, Ee);
          return Math.acos(2 * ze * ze - 1);
        }, kt.multiply = D, kt.rotateX = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et + Ue * Fe, me[1] = Re * et + Ve * Fe, me[2] = Ve * et - Re * Fe, me[3] = Ue * et - Ie * Fe, me;
        }, kt.rotateY = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et - Ve * Fe, me[1] = Re * et + Ue * Fe, me[2] = Ve * et + Ie * Fe, me[3] = Ue * et - Re * Fe, me;
        }, kt.rotateZ = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et + Re * Fe, me[1] = Re * et - Ie * Fe, me[2] = Ve * et + Ue * Fe, me[3] = Ue * et - Ve * Fe, me;
        }, kt.calculateW = function(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2];
          return me[0] = ze, me[1] = Ie, me[2] = Re, me[3] = Math.sqrt(Math.abs(1 - ze * ze - Ie * Ie - Re * Re)), me;
        }, kt.exp = x, kt.ln = A, kt.pow = function(me, Ee, ze) {
          return A(me, Ee), C(me, me, ze), x(me, me), me;
        }, kt.slerp = I, kt.random = function(me) {
          var Ee = e.RANDOM(), ze = e.RANDOM(), Ie = e.RANDOM(), Re = Math.sqrt(1 - Ee), Ve = Math.sqrt(Ee);
          return me[0] = Re * Math.sin(2 * Math.PI * ze), me[1] = Re * Math.cos(2 * Math.PI * ze), me[2] = Ve * Math.sin(2 * Math.PI * Ie), me[3] = Ve * Math.cos(2 * Math.PI * Ie), me;
        }, kt.invert = function(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = ze * ze + Ie * Ie + Re * Re + Ve * Ve, Fe = Ue ? 1 / Ue : 0;
          return me[0] = -ze * Fe, me[1] = -Ie * Fe, me[2] = -Re * Fe, me[3] = Ve * Fe, me;
        }, kt.conjugate = function(me, Ee) {
          return me[0] = -Ee[0], me[1] = -Ee[1], me[2] = -Ee[2], me[3] = Ee[3], me;
        }, kt.fromMat3 = M, kt.fromEuler = function(me, Ee, ze, Ie) {
          var Re = 0.5 * Math.PI / 180;
          Ee *= Re, ze *= Re, Ie *= Re;
          var Ve = Math.sin(Ee), Ue = Math.cos(Ee), Fe = Math.sin(ze), et = Math.cos(ze), dt = Math.sin(Ie), tt = Math.cos(Ie);
          return me[0] = Ve * et * tt - Ue * Fe * dt, me[1] = Ue * Fe * tt + Ve * et * dt, me[2] = Ue * et * dt - Ve * Fe * tt, me[3] = Ue * et * tt + Ve * Fe * dt, me;
        }, kt.str = function(me) {
          return "quat(" + me[0] + ", " + me[1] + ", " + me[2] + ", " + me[3] + ")";
        }, kt.setAxes = kt.sqlerp = kt.rotationTo = kt.equals = kt.exactEquals = kt.normalize = kt.sqrLen = kt.squaredLength = kt.len = kt.length = kt.lerp = kt.dot = kt.scale = kt.mul = kt.add = kt.set = kt.copy = kt.fromValues = kt.clone = void 0;
        var e = f(ae()), n = f(gt()), o = f(Mi()), u = f(Si());
        function l(me) {
          if (typeof WeakMap != "function")
            return null;
          var Ee = /* @__PURE__ */ new WeakMap(), ze = /* @__PURE__ */ new WeakMap();
          return (l = function(Ie) {
            return Ie ? ze : Ee;
          })(me);
        }
        function f(me, Ee) {
          if (me && me.__esModule)
            return me;
          if (me === null || r(me) !== "object" && typeof me != "function")
            return { default: me };
          var ze = l(Ee);
          if (ze && ze.has(me))
            return ze.get(me);
          var Ie = {}, Re = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var Ve in me)
            if (Ve !== "default" && Object.prototype.hasOwnProperty.call(me, Ve)) {
              var Ue = Re ? Object.getOwnPropertyDescriptor(me, Ve) : null;
              Ue && (Ue.get || Ue.set) ? Object.defineProperty(Ie, Ve, Ue) : Ie[Ve] = me[Ve];
            }
          return Ie.default = me, ze && ze.set(me, Ie), Ie;
        }
        function v() {
          var me = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (me[0] = 0, me[1] = 0, me[2] = 0), me[3] = 1, me;
        }
        function S(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Math.sin(ze);
          return me[0] = Ie * Ee[0], me[1] = Ie * Ee[1], me[2] = Ie * Ee[2], me[3] = Math.cos(ze), me;
        }
        function D(me, Ee, ze) {
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = ze[0], et = ze[1], dt = ze[2], tt = ze[3];
          return me[0] = Ie * tt + Ue * Fe + Re * dt - Ve * et, me[1] = Re * tt + Ue * et + Ve * Fe - Ie * dt, me[2] = Ve * tt + Ue * dt + Ie * et - Re * Fe, me[3] = Ue * tt - Ie * Fe - Re * et - Ve * dt, me;
        }
        function x(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = Math.sqrt(ze * ze + Ie * Ie + Re * Re), Fe = Math.exp(Ve), et = Ue > 0 ? Fe * Math.sin(Ue) / Ue : 0;
          return me[0] = ze * et, me[1] = Ie * et, me[2] = Re * et, me[3] = Fe * Math.cos(Ue), me;
        }
        function A(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = Math.sqrt(ze * ze + Ie * Ie + Re * Re), Fe = Ue > 0 ? Math.atan2(Ue, Ve) / Ue : 0;
          return me[0] = ze * Fe, me[1] = Ie * Fe, me[2] = Re * Fe, me[3] = 0.5 * Math.log(ze * ze + Ie * Ie + Re * Re + Ve * Ve), me;
        }
        function I(me, Ee, ze, Ie) {
          var Re, Ve, Ue, Fe, et, dt = Ee[0], tt = Ee[1], Mt = Ee[2], wt = Ee[3], Pt = ze[0], rt = ze[1], Ut = ze[2], St = ze[3];
          return (Ve = dt * Pt + tt * rt + Mt * Ut + wt * St) < 0 && (Ve = -Ve, Pt = -Pt, rt = -rt, Ut = -Ut, St = -St), 1 - Ve > e.EPSILON ? (Re = Math.acos(Ve), Ue = Math.sin(Re), Fe = Math.sin((1 - Ie) * Re) / Ue, et = Math.sin(Ie * Re) / Ue) : (Fe = 1 - Ie, et = Ie), me[0] = Fe * dt + et * Pt, me[1] = Fe * tt + et * rt, me[2] = Fe * Mt + et * Ut, me[3] = Fe * wt + et * St, me;
        }
        function M(me, Ee) {
          var ze, Ie = Ee[0] + Ee[4] + Ee[8];
          if (Ie > 0)
            ze = Math.sqrt(Ie + 1), me[3] = 0.5 * ze, me[0] = (Ee[5] - Ee[7]) * (ze = 0.5 / ze), me[1] = (Ee[6] - Ee[2]) * ze, me[2] = (Ee[1] - Ee[3]) * ze;
          else {
            var Re = 0;
            Ee[4] > Ee[0] && (Re = 1), Ee[8] > Ee[3 * Re + Re] && (Re = 2);
            var Ve = (Re + 1) % 3, Ue = (Re + 2) % 3;
            ze = Math.sqrt(Ee[3 * Re + Re] - Ee[3 * Ve + Ve] - Ee[3 * Ue + Ue] + 1), me[Re] = 0.5 * ze, me[3] = (Ee[3 * Ve + Ue] - Ee[3 * Ue + Ve]) * (ze = 0.5 / ze), me[Ve] = (Ee[3 * Ve + Re] + Ee[3 * Re + Ve]) * ze, me[Ue] = (Ee[3 * Ue + Re] + Ee[3 * Re + Ue]) * ze;
          }
          return me;
        }
        kt.clone = u.clone, kt.fromValues = u.fromValues, kt.copy = u.copy, kt.set = u.set, kt.add = u.add, kt.mul = D;
        var C = u.scale;
        kt.scale = C;
        var k = u.dot;
        kt.dot = k, kt.lerp = u.lerp;
        var V = u.length;
        kt.length = V, kt.len = V;
        var U = u.squaredLength;
        kt.squaredLength = U, kt.sqrLen = U;
        var q = u.normalize;
        kt.normalize = q, kt.exactEquals = u.exactEquals, kt.equals = u.equals;
        var $, H, K, Q = ($ = o.create(), H = o.fromValues(1, 0, 0), K = o.fromValues(0, 1, 0), function(me, Ee, ze) {
          var Ie = o.dot(Ee, ze);
          return Ie < -0.999999 ? (o.cross($, H, Ee), o.len($) < 1e-6 && o.cross($, K, Ee), o.normalize($, $), S(me, $, Math.PI), me) : Ie > 0.999999 ? (me[0] = 0, me[1] = 0, me[2] = 0, me[3] = 1, me) : (o.cross($, Ee, ze), me[0] = $[0], me[1] = $[1], me[2] = $[2], me[3] = 1 + Ie, q(me, me));
        });
        kt.rotationTo = Q;
        var ie, fe, de = (ie = v(), fe = v(), function(me, Ee, ze, Ie, Re, Ve) {
          return I(ie, Ee, Re, Ve), I(fe, ze, Ie, Ve), I(me, ie, fe, 2 * Ve * (1 - Ve)), me;
        });
        kt.sqlerp = de;
        var ue, Se = (ue = n.create(), function(me, Ee, ze, Ie) {
          return ue[0] = ze[0], ue[3] = ze[1], ue[6] = ze[2], ue[1] = Ie[0], ue[4] = Ie[1], ue[7] = Ie[2], ue[2] = -Ee[0], ue[5] = -Ee[1], ue[8] = -Ee[2], q(me, M(me, ue));
        });
        return kt.setAxes = Se, kt;
      }
      var fi, jt = {};
      function ni() {
        if (fi)
          return jt;
        function r(I) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(M) {
            return typeof M;
          } : function(M) {
            return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M;
          }, r(I);
        }
        fi = 1, Object.defineProperty(jt, "__esModule", { value: !0 }), jt.create = function() {
          var I = new e.ARRAY_TYPE(8);
          return e.ARRAY_TYPE != Float32Array && (I[0] = 0, I[1] = 0, I[2] = 0, I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0), I[3] = 1, I;
        }, jt.clone = function(I) {
          var M = new e.ARRAY_TYPE(8);
          return M[0] = I[0], M[1] = I[1], M[2] = I[2], M[3] = I[3], M[4] = I[4], M[5] = I[5], M[6] = I[6], M[7] = I[7], M;
        }, jt.fromValues = function(I, M, C, k, V, U, q, $) {
          var H = new e.ARRAY_TYPE(8);
          return H[0] = I, H[1] = M, H[2] = C, H[3] = k, H[4] = V, H[5] = U, H[6] = q, H[7] = $, H;
        }, jt.fromRotationTranslationValues = function(I, M, C, k, V, U, q) {
          var $ = new e.ARRAY_TYPE(8);
          $[0] = I, $[1] = M, $[2] = C, $[3] = k;
          var H = 0.5 * V, K = 0.5 * U, Q = 0.5 * q;
          return $[4] = H * k + K * C - Q * M, $[5] = K * k + Q * I - H * C, $[6] = Q * k + H * M - K * I, $[7] = -H * I - K * M - Q * C, $;
        }, jt.fromRotationTranslation = f, jt.fromTranslation = function(I, M) {
          return I[0] = 0, I[1] = 0, I[2] = 0, I[3] = 1, I[4] = 0.5 * M[0], I[5] = 0.5 * M[1], I[6] = 0.5 * M[2], I[7] = 0, I;
        }, jt.fromRotation = function(I, M) {
          return I[0] = M[0], I[1] = M[1], I[2] = M[2], I[3] = M[3], I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0, I;
        }, jt.fromMat4 = function(I, M) {
          var C = n.create();
          o.getRotation(C, M);
          var k = new e.ARRAY_TYPE(3);
          return o.getTranslation(k, M), f(I, C, k), I;
        }, jt.copy = v, jt.identity = function(I) {
          return I[0] = 0, I[1] = 0, I[2] = 0, I[3] = 1, I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0, I;
        }, jt.set = function(I, M, C, k, V, U, q, $, H) {
          return I[0] = M, I[1] = C, I[2] = k, I[3] = V, I[4] = U, I[5] = q, I[6] = $, I[7] = H, I;
        }, jt.getDual = function(I, M) {
          return I[0] = M[4], I[1] = M[5], I[2] = M[6], I[3] = M[7], I;
        }, jt.setDual = function(I, M) {
          return I[4] = M[0], I[5] = M[1], I[6] = M[2], I[7] = M[3], I;
        }, jt.getTranslation = function(I, M) {
          var C = M[4], k = M[5], V = M[6], U = M[7], q = -M[0], $ = -M[1], H = -M[2], K = M[3];
          return I[0] = 2 * (C * K + U * q + k * H - V * $), I[1] = 2 * (k * K + U * $ + V * q - C * H), I[2] = 2 * (V * K + U * H + C * $ - k * q), I;
        }, jt.translate = function(I, M, C) {
          var k = M[0], V = M[1], U = M[2], q = M[3], $ = 0.5 * C[0], H = 0.5 * C[1], K = 0.5 * C[2], Q = M[4], ie = M[5], fe = M[6], de = M[7];
          return I[0] = k, I[1] = V, I[2] = U, I[3] = q, I[4] = q * $ + V * K - U * H + Q, I[5] = q * H + U * $ - k * K + ie, I[6] = q * K + k * H - V * $ + fe, I[7] = -k * $ - V * H - U * K + de, I;
        }, jt.rotateX = function(I, M, C) {
          var k = -M[0], V = -M[1], U = -M[2], q = M[3], $ = M[4], H = M[5], K = M[6], Q = M[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, ue = Q * q - $ * k - H * V - K * U;
          return n.rotateX(I, M, C), I[4] = ie * (q = I[3]) + ue * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + ue * V + de * k - ie * U, I[6] = de * q + ue * U + ie * V - fe * k, I[7] = ue * q - ie * k - fe * V - de * U, I;
        }, jt.rotateY = function(I, M, C) {
          var k = -M[0], V = -M[1], U = -M[2], q = M[3], $ = M[4], H = M[5], K = M[6], Q = M[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, ue = Q * q - $ * k - H * V - K * U;
          return n.rotateY(I, M, C), I[4] = ie * (q = I[3]) + ue * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + ue * V + de * k - ie * U, I[6] = de * q + ue * U + ie * V - fe * k, I[7] = ue * q - ie * k - fe * V - de * U, I;
        }, jt.rotateZ = function(I, M, C) {
          var k = -M[0], V = -M[1], U = -M[2], q = M[3], $ = M[4], H = M[5], K = M[6], Q = M[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, ue = Q * q - $ * k - H * V - K * U;
          return n.rotateZ(I, M, C), I[4] = ie * (q = I[3]) + ue * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + ue * V + de * k - ie * U, I[6] = de * q + ue * U + ie * V - fe * k, I[7] = ue * q - ie * k - fe * V - de * U, I;
        }, jt.rotateByQuatAppend = function(I, M, C) {
          var k = C[0], V = C[1], U = C[2], q = C[3], $ = M[0], H = M[1], K = M[2], Q = M[3];
          return I[0] = $ * q + Q * k + H * U - K * V, I[1] = H * q + Q * V + K * k - $ * U, I[2] = K * q + Q * U + $ * V - H * k, I[3] = Q * q - $ * k - H * V - K * U, I[4] = ($ = M[4]) * q + (Q = M[7]) * k + (H = M[5]) * U - (K = M[6]) * V, I[5] = H * q + Q * V + K * k - $ * U, I[6] = K * q + Q * U + $ * V - H * k, I[7] = Q * q - $ * k - H * V - K * U, I;
        }, jt.rotateByQuatPrepend = function(I, M, C) {
          var k = M[0], V = M[1], U = M[2], q = M[3], $ = C[0], H = C[1], K = C[2], Q = C[3];
          return I[0] = k * Q + q * $ + V * K - U * H, I[1] = V * Q + q * H + U * $ - k * K, I[2] = U * Q + q * K + k * H - V * $, I[3] = q * Q - k * $ - V * H - U * K, I[4] = k * (Q = C[7]) + q * ($ = C[4]) + V * (K = C[6]) - U * (H = C[5]), I[5] = V * Q + q * H + U * $ - k * K, I[6] = U * Q + q * K + k * H - V * $, I[7] = q * Q - k * $ - V * H - U * K, I;
        }, jt.rotateAroundAxis = function(I, M, C, k) {
          if (Math.abs(k) < e.EPSILON)
            return v(I, M);
          var V = Math.hypot(C[0], C[1], C[2]);
          k *= 0.5;
          var U = Math.sin(k), q = U * C[0] / V, $ = U * C[1] / V, H = U * C[2] / V, K = Math.cos(k), Q = M[0], ie = M[1], fe = M[2], de = M[3];
          I[0] = Q * K + de * q + ie * H - fe * $, I[1] = ie * K + de * $ + fe * q - Q * H, I[2] = fe * K + de * H + Q * $ - ie * q, I[3] = de * K - Q * q - ie * $ - fe * H;
          var ue = M[4], Se = M[5], me = M[6], Ee = M[7];
          return I[4] = ue * K + Ee * q + Se * H - me * $, I[5] = Se * K + Ee * $ + me * q - ue * H, I[6] = me * K + Ee * H + ue * $ - Se * q, I[7] = Ee * K - ue * q - Se * $ - me * H, I;
        }, jt.add = function(I, M, C) {
          return I[0] = M[0] + C[0], I[1] = M[1] + C[1], I[2] = M[2] + C[2], I[3] = M[3] + C[3], I[4] = M[4] + C[4], I[5] = M[5] + C[5], I[6] = M[6] + C[6], I[7] = M[7] + C[7], I;
        }, jt.multiply = S, jt.scale = function(I, M, C) {
          return I[0] = M[0] * C, I[1] = M[1] * C, I[2] = M[2] * C, I[3] = M[3] * C, I[4] = M[4] * C, I[5] = M[5] * C, I[6] = M[6] * C, I[7] = M[7] * C, I;
        }, jt.lerp = function(I, M, C, k) {
          var V = 1 - k;
          return D(M, C) < 0 && (k = -k), I[0] = M[0] * V + C[0] * k, I[1] = M[1] * V + C[1] * k, I[2] = M[2] * V + C[2] * k, I[3] = M[3] * V + C[3] * k, I[4] = M[4] * V + C[4] * k, I[5] = M[5] * V + C[5] * k, I[6] = M[6] * V + C[6] * k, I[7] = M[7] * V + C[7] * k, I;
        }, jt.invert = function(I, M) {
          var C = A(M);
          return I[0] = -M[0] / C, I[1] = -M[1] / C, I[2] = -M[2] / C, I[3] = M[3] / C, I[4] = -M[4] / C, I[5] = -M[5] / C, I[6] = -M[6] / C, I[7] = M[7] / C, I;
        }, jt.conjugate = function(I, M) {
          return I[0] = -M[0], I[1] = -M[1], I[2] = -M[2], I[3] = M[3], I[4] = -M[4], I[5] = -M[5], I[6] = -M[6], I[7] = M[7], I;
        }, jt.normalize = function(I, M) {
          var C = A(M);
          if (C > 0) {
            C = Math.sqrt(C);
            var k = M[0] / C, V = M[1] / C, U = M[2] / C, q = M[3] / C, $ = M[4], H = M[5], K = M[6], Q = M[7], ie = k * $ + V * H + U * K + q * Q;
            I[0] = k, I[1] = V, I[2] = U, I[3] = q, I[4] = ($ - k * ie) / C, I[5] = (H - V * ie) / C, I[6] = (K - U * ie) / C, I[7] = (Q - q * ie) / C;
          }
          return I;
        }, jt.str = function(I) {
          return "quat2(" + I[0] + ", " + I[1] + ", " + I[2] + ", " + I[3] + ", " + I[4] + ", " + I[5] + ", " + I[6] + ", " + I[7] + ")";
        }, jt.exactEquals = function(I, M) {
          return I[0] === M[0] && I[1] === M[1] && I[2] === M[2] && I[3] === M[3] && I[4] === M[4] && I[5] === M[5] && I[6] === M[6] && I[7] === M[7];
        }, jt.equals = function(I, M) {
          var C = I[0], k = I[1], V = I[2], U = I[3], q = I[4], $ = I[5], H = I[6], K = I[7], Q = M[0], ie = M[1], fe = M[2], de = M[3], ue = M[4], Se = M[5], me = M[6], Ee = M[7];
          return Math.abs(C - Q) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(Q)) && Math.abs(k - ie) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(ie)) && Math.abs(V - fe) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(fe)) && Math.abs(U - de) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(de)) && Math.abs(q - ue) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(ue)) && Math.abs($ - Se) <= e.EPSILON * Math.max(1, Math.abs($), Math.abs(Se)) && Math.abs(H - me) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(me)) && Math.abs(K - Ee) <= e.EPSILON * Math.max(1, Math.abs(K), Math.abs(Ee));
        }, jt.sqrLen = jt.squaredLength = jt.len = jt.length = jt.dot = jt.mul = jt.setReal = jt.getReal = void 0;
        var e = l(ae()), n = l(Ji()), o = l(Gt());
        function u(I) {
          if (typeof WeakMap != "function")
            return null;
          var M = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
          return (u = function(k) {
            return k ? C : M;
          })(I);
        }
        function l(I, M) {
          if (I && I.__esModule)
            return I;
          if (I === null || r(I) !== "object" && typeof I != "function")
            return { default: I };
          var C = u(M);
          if (C && C.has(I))
            return C.get(I);
          var k = {}, V = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var U in I)
            if (U !== "default" && Object.prototype.hasOwnProperty.call(I, U)) {
              var q = V ? Object.getOwnPropertyDescriptor(I, U) : null;
              q && (q.get || q.set) ? Object.defineProperty(k, U, q) : k[U] = I[U];
            }
          return k.default = I, C && C.set(I, k), k;
        }
        function f(I, M, C) {
          var k = 0.5 * C[0], V = 0.5 * C[1], U = 0.5 * C[2], q = M[0], $ = M[1], H = M[2], K = M[3];
          return I[0] = q, I[1] = $, I[2] = H, I[3] = K, I[4] = k * K + V * H - U * $, I[5] = V * K + U * q - k * H, I[6] = U * K + k * $ - V * q, I[7] = -k * q - V * $ - U * H, I;
        }
        function v(I, M) {
          return I[0] = M[0], I[1] = M[1], I[2] = M[2], I[3] = M[3], I[4] = M[4], I[5] = M[5], I[6] = M[6], I[7] = M[7], I;
        }
        function S(I, M, C) {
          var k = M[0], V = M[1], U = M[2], q = M[3], $ = C[4], H = C[5], K = C[6], Q = C[7], ie = M[4], fe = M[5], de = M[6], ue = M[7], Se = C[0], me = C[1], Ee = C[2], ze = C[3];
          return I[0] = k * ze + q * Se + V * Ee - U * me, I[1] = V * ze + q * me + U * Se - k * Ee, I[2] = U * ze + q * Ee + k * me - V * Se, I[3] = q * ze - k * Se - V * me - U * Ee, I[4] = k * Q + q * $ + V * K - U * H + ie * ze + ue * Se + fe * Ee - de * me, I[5] = V * Q + q * H + U * $ - k * K + fe * ze + ue * me + de * Se - ie * Ee, I[6] = U * Q + q * K + k * H - V * $ + de * ze + ue * Ee + ie * me - fe * Se, I[7] = q * Q - k * $ - V * H - U * K + ue * ze - ie * Se - fe * me - de * Ee, I;
        }
        jt.getReal = n.copy, jt.setReal = n.copy, jt.mul = S;
        var D = n.dot;
        jt.dot = D;
        var x = n.length;
        jt.length = x, jt.len = x;
        var A = n.squaredLength;
        return jt.squaredLength = A, jt.sqrLen = A, jt;
      }
      var Gi, an, qt = {};
      function ln() {
        if (Gi)
          return qt;
        function r(M) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(M);
        }
        Gi = 1, Object.defineProperty(qt, "__esModule", { value: !0 }), qt.create = o, qt.clone = function(M) {
          var C = new e.ARRAY_TYPE(2);
          return C[0] = M[0], C[1] = M[1], C;
        }, qt.fromValues = function(M, C) {
          var k = new e.ARRAY_TYPE(2);
          return k[0] = M, k[1] = C, k;
        }, qt.copy = function(M, C) {
          return M[0] = C[0], M[1] = C[1], M;
        }, qt.set = function(M, C, k) {
          return M[0] = C, M[1] = k, M;
        }, qt.add = function(M, C, k) {
          return M[0] = C[0] + k[0], M[1] = C[1] + k[1], M;
        }, qt.subtract = u, qt.multiply = l, qt.divide = f, qt.ceil = function(M, C) {
          return M[0] = Math.ceil(C[0]), M[1] = Math.ceil(C[1]), M;
        }, qt.floor = function(M, C) {
          return M[0] = Math.floor(C[0]), M[1] = Math.floor(C[1]), M;
        }, qt.min = function(M, C, k) {
          return M[0] = Math.min(C[0], k[0]), M[1] = Math.min(C[1], k[1]), M;
        }, qt.max = function(M, C, k) {
          return M[0] = Math.max(C[0], k[0]), M[1] = Math.max(C[1], k[1]), M;
        }, qt.round = function(M, C) {
          return M[0] = Math.round(C[0]), M[1] = Math.round(C[1]), M;
        }, qt.scale = function(M, C, k) {
          return M[0] = C[0] * k, M[1] = C[1] * k, M;
        }, qt.scaleAndAdd = function(M, C, k, V) {
          return M[0] = C[0] + k[0] * V, M[1] = C[1] + k[1] * V, M;
        }, qt.distance = v, qt.squaredDistance = S, qt.length = D, qt.squaredLength = x, qt.negate = function(M, C) {
          return M[0] = -C[0], M[1] = -C[1], M;
        }, qt.inverse = function(M, C) {
          return M[0] = 1 / C[0], M[1] = 1 / C[1], M;
        }, qt.normalize = function(M, C) {
          var k = C[0], V = C[1], U = k * k + V * V;
          return U > 0 && (U = 1 / Math.sqrt(U)), M[0] = C[0] * U, M[1] = C[1] * U, M;
        }, qt.dot = function(M, C) {
          return M[0] * C[0] + M[1] * C[1];
        }, qt.cross = function(M, C, k) {
          var V = C[0] * k[1] - C[1] * k[0];
          return M[0] = M[1] = 0, M[2] = V, M;
        }, qt.lerp = function(M, C, k, V) {
          var U = C[0], q = C[1];
          return M[0] = U + V * (k[0] - U), M[1] = q + V * (k[1] - q), M;
        }, qt.random = function(M, C) {
          C = C || 1;
          var k = 2 * e.RANDOM() * Math.PI;
          return M[0] = Math.cos(k) * C, M[1] = Math.sin(k) * C, M;
        }, qt.transformMat2 = function(M, C, k) {
          var V = C[0], U = C[1];
          return M[0] = k[0] * V + k[2] * U, M[1] = k[1] * V + k[3] * U, M;
        }, qt.transformMat2d = function(M, C, k) {
          var V = C[0], U = C[1];
          return M[0] = k[0] * V + k[2] * U + k[4], M[1] = k[1] * V + k[3] * U + k[5], M;
        }, qt.transformMat3 = function(M, C, k) {
          var V = C[0], U = C[1];
          return M[0] = k[0] * V + k[3] * U + k[6], M[1] = k[1] * V + k[4] * U + k[7], M;
        }, qt.transformMat4 = function(M, C, k) {
          var V = C[0], U = C[1];
          return M[0] = k[0] * V + k[4] * U + k[12], M[1] = k[1] * V + k[5] * U + k[13], M;
        }, qt.rotate = function(M, C, k, V) {
          var U = C[0] - k[0], q = C[1] - k[1], $ = Math.sin(V), H = Math.cos(V);
          return M[0] = U * H - q * $ + k[0], M[1] = U * $ + q * H + k[1], M;
        }, qt.angle = function(M, C) {
          var k = M[0], V = M[1], U = C[0], q = C[1], $ = Math.sqrt(k * k + V * V) * Math.sqrt(U * U + q * q);
          return Math.acos(Math.min(Math.max($ && (k * U + V * q) / $, -1), 1));
        }, qt.zero = function(M) {
          return M[0] = 0, M[1] = 0, M;
        }, qt.str = function(M) {
          return "vec2(" + M[0] + ", " + M[1] + ")";
        }, qt.exactEquals = function(M, C) {
          return M[0] === C[0] && M[1] === C[1];
        }, qt.equals = function(M, C) {
          var k = M[0], V = M[1], U = C[0], q = C[1];
          return Math.abs(k - U) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(U)) && Math.abs(V - q) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(q));
        }, qt.forEach = qt.sqrLen = qt.sqrDist = qt.dist = qt.div = qt.mul = qt.sub = qt.len = void 0;
        var e = function(M, C) {
          if (M && M.__esModule)
            return M;
          if (M === null || r(M) !== "object" && typeof M != "function")
            return { default: M };
          var k = n(void 0);
          if (k && k.has(M))
            return k.get(M);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in M)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(M, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(M, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = M[q];
            }
          return V.default = M, k && k.set(M, V), V;
        }(ae());
        function n(M) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (n = function(V) {
            return V ? k : C;
          })(M);
        }
        function o() {
          var M = new e.ARRAY_TYPE(2);
          return e.ARRAY_TYPE != Float32Array && (M[0] = 0, M[1] = 0), M;
        }
        function u(M, C, k) {
          return M[0] = C[0] - k[0], M[1] = C[1] - k[1], M;
        }
        function l(M, C, k) {
          return M[0] = C[0] * k[0], M[1] = C[1] * k[1], M;
        }
        function f(M, C, k) {
          return M[0] = C[0] / k[0], M[1] = C[1] / k[1], M;
        }
        function v(M, C) {
          return Math.hypot(C[0] - M[0], C[1] - M[1]);
        }
        function S(M, C) {
          var k = C[0] - M[0], V = C[1] - M[1];
          return k * k + V * V;
        }
        function D(M) {
          return Math.hypot(M[0], M[1]);
        }
        function x(M) {
          var C = M[0], k = M[1];
          return C * C + k * k;
        }
        qt.len = D, qt.sub = u, qt.mul = l, qt.div = f, qt.dist = v, qt.sqrDist = S, qt.sqrLen = x;
        var A, I = (A = o(), function(M, C, k, V, U, q) {
          var $, H;
          for (C || (C = 2), k || (k = 0), H = V ? Math.min(V * C + k, M.length) : M.length, $ = k; $ < H; $ += C)
            A[0] = M[$], A[1] = M[$ + 1], U(A, A, q), M[$] = A[0], M[$ + 1] = A[1];
          return M;
        });
        return qt.forEach = I, qt;
      }
      function Di() {
        if (an)
          return Y;
        function r(M) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(M);
        }
        an = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.vec4 = Y.vec3 = Y.vec2 = Y.quat2 = Y.quat = Y.mat4 = Y.mat3 = Y.mat2d = Y.mat2 = Y.glMatrix = void 0;
        var e = I(ae());
        Y.glMatrix = e;
        var n = I(be());
        Y.mat2 = n;
        var o = I(ot());
        Y.mat2d = o;
        var u = I(gt());
        Y.mat3 = u;
        var l = I(Gt());
        Y.mat4 = l;
        var f = I(Ji());
        Y.quat = f;
        var v = I(ni());
        Y.quat2 = v;
        var S = I(ln());
        Y.vec2 = S;
        var D = I(Mi());
        Y.vec3 = D;
        var x = I(Si());
        function A(M) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (A = function(V) {
            return V ? k : C;
          })(M);
        }
        function I(M, C) {
          if (M && M.__esModule)
            return M;
          if (M === null || r(M) !== "object" && typeof M != "function")
            return { default: M };
          var k = A(C);
          if (k && k.has(M))
            return k.get(M);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in M)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(M, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(M, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = M[q];
            }
          return V.default = M, k && k.set(M, V), V;
        }
        return Y.vec4 = x, Y;
      }
      var xi, Cs, xs, Is, De = Di(), Vs = function() {
        if (Cs)
          return xi;
        function r(e, n, o, u) {
          this.cx = 3 * e, this.bx = 3 * (o - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = n, this.p2x = o, this.p2y = u;
        }
        return Cs = 1, xi = r, r.prototype = { sampleCurveX: function(e) {
          return ((this.ax * e + this.bx) * e + this.cx) * e;
        }, sampleCurveY: function(e) {
          return ((this.ay * e + this.by) * e + this.cy) * e;
        }, sampleCurveDerivativeX: function(e) {
          return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
        }, solveCurveX: function(e, n) {
          if (n === void 0 && (n = 1e-6), e < 0)
            return 0;
          if (e > 1)
            return 1;
          for (var o = e, u = 0; u < 8; u++) {
            var l = this.sampleCurveX(o) - e;
            if (Math.abs(l) < n)
              return o;
            var f = this.sampleCurveDerivativeX(o);
            if (Math.abs(f) < 1e-6)
              break;
            o -= l / f;
          }
          var v = 0, S = 1;
          for (o = e, u = 0; u < 20 && (l = this.sampleCurveX(o), !(Math.abs(l - e) < n)); u++)
            e > l ? v = o : S = o, o = 0.5 * (S - v) + v;
          return o;
        }, solve: function(e, n) {
          return this.sampleCurveY(this.solveCurveX(e, n));
        } }, xi;
      }(), Us = O(Vs);
      function Zr() {
        if (Is)
          return xs;
        function r(e, n) {
          this.x = e, this.y = n;
        }
        return Is = 1, xs = r, r.prototype = { clone: function() {
          return new r(this.x, this.y);
        }, add: function(e) {
          return this.clone()._add(e);
        }, sub: function(e) {
          return this.clone()._sub(e);
        }, multByPoint: function(e) {
          return this.clone()._multByPoint(e);
        }, divByPoint: function(e) {
          return this.clone()._divByPoint(e);
        }, mult: function(e) {
          return this.clone()._mult(e);
        }, div: function(e) {
          return this.clone()._div(e);
        }, rotate: function(e) {
          return this.clone()._rotate(e);
        }, rotateAround: function(e, n) {
          return this.clone()._rotateAround(e, n);
        }, matMult: function(e) {
          return this.clone()._matMult(e);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(e) {
          return this.x === e.x && this.y === e.y;
        }, dist: function(e) {
          return Math.sqrt(this.distSqr(e));
        }, distSqr: function(e) {
          var n = e.x - this.x, o = e.y - this.y;
          return n * n + o * o;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(e) {
          return Math.atan2(this.y - e.y, this.x - e.x);
        }, angleWith: function(e) {
          return this.angleWithSep(e.x, e.y);
        }, angleWithSep: function(e, n) {
          return Math.atan2(this.x * n - this.y * e, this.x * e + this.y * n);
        }, _matMult: function(e) {
          var n = e[2] * this.x + e[3] * this.y;
          return this.x = e[0] * this.x + e[1] * this.y, this.y = n, this;
        }, _add: function(e) {
          return this.x += e.x, this.y += e.y, this;
        }, _sub: function(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }, _mult: function(e) {
          return this.x *= e, this.y *= e, this;
        }, _div: function(e) {
          return this.x /= e, this.y /= e, this;
        }, _multByPoint: function(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }, _divByPoint: function(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var e = this.y;
          return this.y = this.x, this.x = -e, this;
        }, _rotate: function(e) {
          var n = Math.cos(e), o = Math.sin(e), u = o * this.x + n * this.y;
          return this.x = n * this.x - o * this.y, this.y = u, this;
        }, _rotateAround: function(e, n) {
          var o = Math.cos(e), u = Math.sin(e), l = n.y + u * (this.x - n.x) + o * (this.y - n.y);
          return this.x = n.x + o * (this.x - n.x) - u * (this.y - n.y), this.y = l, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, r.convert = function(e) {
          return e instanceof r ? e : Array.isArray(e) ? new r(e[0], e[1]) : e;
        }, xs;
      }
      var Et = O(Zr());
      function Ws(r, e) {
        if (Array.isArray(r)) {
          if (!Array.isArray(e) || r.length !== e.length)
            return !1;
          for (let n = 0; n < r.length; n++)
            if (!Ws(r[n], e[n]))
              return !1;
          return !0;
        }
        if (typeof r == "object" && r !== null && e !== null) {
          if (typeof e != "object" || Object.keys(r).length !== Object.keys(e).length)
            return !1;
          for (const n in r)
            if (!Ws(r[n], e[n]))
              return !1;
          return !0;
        }
        return r === e;
      }
      const $n = Math.PI / 180, $s = 180 / Math.PI;
      function vi(r) {
        return r * $n;
      }
      function kn(r) {
        return r * $s;
      }
      const Xs = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function Hr(r) {
        if (r <= 0)
          return 0;
        if (r >= 1)
          return 1;
        const e = r * r, n = e * r;
        return 4 * (r < 0.5 ? n : 3 * (r - e) + n - 0.75);
      }
      function qr(r, e, n, o) {
        const u = new Us(r, e, n, o);
        return function(l) {
          return u.solve(l);
        };
      }
      const Wr = qr(0.25, 0.1, 0.25, 1);
      function si(r, e, n) {
        return Math.min(n, Math.max(e, r));
      }
      function fs(r, e, n) {
        return (n = si((n - r) / (e - r), 0, 1)) * n * (3 - 2 * n);
      }
      function zn(r, e, n) {
        const o = n - e, u = ((r - e) % o + o) % o + e;
        return u === e ? n : u;
      }
      function Rn(r, e, n) {
        if (!r.length)
          return n(null, []);
        let o = r.length;
        const u = new Array(r.length);
        let l = null;
        r.forEach((f, v) => {
          e(f, (S, D) => {
            S && (l = S), u[v] = D, --o == 0 && n(l, u);
          });
        });
      }
      function Pn(r, ...e) {
        for (const n of e)
          for (const o in n)
            r[o] = n[o];
        return r;
      }
      let js = 1;
      function yo() {
        return js++;
      }
      function xo(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }
      function vo(r, e) {
        r.forEach((n) => {
          e[n] && (e[n] = e[n].bind(e));
        });
      }
      function yr(r, e) {
        return r.indexOf(e, r.length - e.length) !== -1;
      }
      function Mr(r, e, n) {
        const o = {};
        for (const u in r)
          o[u] = e.call(this, r[u], u, r);
        return o;
      }
      function io(r, e, n) {
        const o = {};
        for (const u in r)
          e.call(this, r[u], u, r) && (o[u] = r[u]);
        return o;
      }
      function Ys(r) {
        return Array.isArray(r) ? r.map(Ys) : typeof r == "object" && r ? Mr(r, Ys) : r;
      }
      const Sr = {};
      function mi(r) {
        Sr[r] || (typeof console < "u" && console.warn(r), Sr[r] = !0);
      }
      function On(r, e, n) {
        return (n.y - r.y) * (e.x - r.x) > (e.y - r.y) * (n.x - r.x);
      }
      function Vn(r) {
        let e = 0;
        for (let n, o, u = 0, l = r.length, f = l - 1; u < l; f = u++)
          n = r[u], o = r[f], e += (o.x - n.x) * (n.y + o.y);
        return e;
      }
      function Zi([r, e, n]) {
        const o = vi(e + 90), u = vi(n);
        return { x: r * Math.cos(o) * Math.sin(u), y: r * Math.sin(o) * Math.sin(u), z: r * Math.cos(u), azimuthal: e, polar: n };
      }
      function Jn() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function Fn(r) {
        const e = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, o, u, l) => {
          const f = u || l;
          return e[o] = !f || f.toLowerCase(), "";
        }), e["max-age"]) {
          const n = parseInt(e["max-age"], 10);
          isNaN(n) ? delete e["max-age"] : e["max-age"] = n;
        }
        return e;
      }
      let Ls = null;
      function zs(r, e) {
        return [r[4 * e], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]];
      }
      function Vo(r, e, n, o) {
        for (; e < n; ) {
          const u = e + n >> 1;
          r[u] < o ? e = u + 1 : n = u;
        }
        return e;
      }
      function Ke(r, e, n, o) {
        for (; e < n; ) {
          const u = e + n >> 1;
          r[u] <= o ? e = u + 1 : n = u;
        }
        return e;
      }
      function re(r) {
        return r > 0 ? 1 / (1.001 - r) : 1 + r;
      }
      function le(r) {
        return r > 0 ? 1 - 1 / (1.001 - r) : -r;
      }
      const ge = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!ge.API_URL)
          return null;
        try {
          const r = new URL(ge.API_URL);
          return r.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : r.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
        } catch {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
      function Le(r) {
        return ge.API_URL_REGEX.test(r);
      }
      function Ce(r) {
        return ge.API_SPRITE_REGEX.test(r);
      }
      let Be, qe, Ae, Ye, Qe, it;
      function mt() {
        return Be == null && (Be = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), Be;
      }
      const Ct = { now: () => Ye !== void 0 ? Ye : performance.now(), setNow(r) {
        Ye = r;
      }, restoreNow() {
        Ye = void 0;
      }, frame(r) {
        const e = requestAnimationFrame(r);
        return { cancel: () => cancelAnimationFrame(e) };
      }, getImageData(r, e = 0) {
        const { width: n, height: o } = r;
        Qe || (Qe = document.createElement("canvas"));
        const u = Qe.getContext("2d", { willReadFrequently: !0 });
        if (!u)
          throw new Error("failed to create canvas 2d context");
        return (n > Qe.width || o > Qe.height) && (Qe.width = n, Qe.height = o), u.clearRect(-e, -e, n + 2 * e, o + 2 * e), u.drawImage(r, 0, 0, n, o), u.getImageData(-e, -e, n + 2 * e, o + 2 * e);
      }, resolveURL: (r) => (qe || (qe = document.createElement("a")), qe.href = r, qe.href), get devicePixelRatio() {
        return window.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!window.matchMedia && (Ae == null && (Ae = window.matchMedia("(prefers-reduced-motion: reduce)")), Ae.matches);
      }, hasCanvasFingerprintNoise() {
        if (it !== void 0)
          return it;
        if (!mt())
          return it = !1, !1;
        const r = new OffscreenCanvas(85, 1), e = r.getContext("2d", { willReadFrequently: !0 });
        let n = 0;
        for (let u = 0; u < r.width; ++u)
          e.fillStyle = `rgba(${n++},${n++},${n++}, 255)`, e.fillRect(u, 0, 1, 1);
        const o = e.getImageData(0, 0, r.width, r.height);
        n = 0;
        for (let u = 0; u < o.data.length; ++u)
          if (u % 4 != 3 && n++ !== o.data[u])
            return it = !0, !0;
        return it = !1, !1;
      } };
      function It(r, e) {
        const n = r.indexOf("?");
        if (n < 0)
          return `${r}?${new URLSearchParams(e).toString()}`;
        const o = new URLSearchParams(r.slice(n));
        for (const u in e)
          o.set(u, e[u]);
        return `${r.slice(0, n)}?${o.toString()}`;
      }
      function Kt(r, e = { persistentParams: [] }) {
        const n = r.indexOf("?");
        if (n < 0)
          return r;
        const o = new URLSearchParams(), u = new URLSearchParams(r.slice(n));
        for (const f of e.persistentParams) {
          const v = u.get(f);
          v && o.set(f, v);
        }
        const l = o.toString();
        return `${r.slice(0, n)}${l.length > 0 ? `?${l}` : ""}`;
      }
      const di = "mapbox-tiles";
      let li = 500, ri = 50;
      const Ki = ["language", "worldview", "jobid"];
      let Ni, Ei;
      function $i() {
        try {
          return caches;
        } catch {
        }
      }
      function Hi() {
        const r = $i();
        r && Ni == null && (Ni = r.open(di));
      }
      let Xn = 1 / 0;
      const Gs = { supported: !1, testSupport: function(r) {
        !ra && vs && (Er ? cl(r) : ps = r);
      } };
      let ps, vs, ra = !1, Er = !1;
      const oa = typeof self < "u" ? self : {};
      function cl(r) {
        const e = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, e);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, vs), r.isContextLost())
            return;
          Gs.supported = !0;
        } catch {
        }
        r.deleteTexture(e), ra = !0;
      }
      oa.document && (vs = oa.document.createElement("img"), vs.onload = function() {
        ps && cl(ps), ps = null, Er = !0;
      }, vs.onerror = function() {
        ra = !0, ps = null;
      }, vs.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const Uo = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
      typeof Object.freeze == "function" && Object.freeze(Uo);
      class jo extends Error {
        constructor(e, n, o) {
          n === 401 && Le(o) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = n, this.url = o;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const tn = Jn() ? () => self.worker && self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href, xn = function(r, e) {
        if (!(/^file:/.test(n = r.url) || /^file:/.test(tn()) && !/^\w+:/.test(n))) {
          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
            return function(o, u) {
              const l = new AbortController(), f = new Request(o.url, { method: o.method || "GET", body: o.body, credentials: o.credentials, headers: o.headers, referrer: tn(), referrerPolicy: o.referrerPolicy, signal: l.signal });
              let v = !1, S = !1;
              const D = (x = f.url).indexOf("sku=") > 0 && Le(x);
              var x;
              o.type === "json" && f.headers.set("Accept", "application/json");
              const A = (M, C, k) => {
                if (S)
                  return;
                if (M && M.message !== "SecurityError" && mi(M.toString()), C && k)
                  return I(C);
                const V = Date.now();
                fetch(f).then((U) => {
                  if (U.ok) {
                    const q = D ? U.clone() : null;
                    return I(U, q, V);
                  }
                  return u(new jo(U.statusText, U.status, o.url));
                }).catch((U) => {
                  U.name !== "AbortError" && u(new Error(`${U.message} ${o.url}`));
                });
              }, I = (M, C, k) => {
                (o.type === "arrayBuffer" ? M.arrayBuffer() : o.type === "json" ? M.json() : M.text()).then((V) => {
                  S || (C && k && function(U, q, $) {
                    if (Hi(), Ni == null)
                      return;
                    const H = Fn(q.headers.get("Cache-Control") || "");
                    if (H["no-store"])
                      return;
                    const K = { status: q.status, statusText: q.statusText, headers: new Headers() };
                    q.headers.forEach((fe, de) => K.headers.set(de, fe)), H["max-age"] && K.headers.set("Expires", new Date($ + 1e3 * H["max-age"]).toUTCString());
                    const Q = K.headers.get("Expires");
                    if (!Q || new Date(Q).getTime() - $ < 42e4)
                      return;
                    let ie = Kt(U.url, { persistentParams: Ki });
                    if (q.status === 206) {
                      const fe = U.headers.get("Range");
                      if (!fe)
                        return;
                      K.status = 200, ie = It(ie, { range: fe });
                    }
                    (function(fe, de) {
                      if (Ei === void 0)
                        try {
                          new Response(new ReadableStream()), Ei = !0;
                        } catch {
                          Ei = !1;
                        }
                      Ei ? de(fe.body) : fe.blob().then(de);
                    })(q, (fe) => {
                      const de = new Response((ue = q.status) !== 200 && ue !== 404 && [101, 103, 204, 205, 304].includes(ue) ? null : fe, K);
                      var ue;
                      Hi(), Ni != null && Ni.then((Se) => Se.put(ie, de)).catch((Se) => mi(Se.message));
                    });
                  }(f, C, k), v = !0, u(null, V, M.headers.get("Cache-Control"), M.headers.get("Expires")));
                }).catch((V) => {
                  S || u(new Error(V.message));
                });
              };
              return D ? function(M, C) {
                if (Hi(), Ni == null)
                  return C(null);
                Ni.then((k) => {
                  let V = Kt(M.url, { persistentParams: Ki });
                  const U = M.headers.get("Range");
                  U && (V = It(V, { range: U })), k.match(V).then((q) => {
                    const $ = function(H) {
                      if (!H)
                        return !1;
                      const K = new Date(H.headers.get("Expires") || 0), Q = Fn(H.headers.get("Cache-Control") || "");
                      return K > Date.now() && !Q["no-cache"];
                    }(q);
                    k.delete(V), $ && k.put(V, q.clone()), C(null, q, $);
                  }).catch(C);
                }).catch(C);
              }(f, A) : A(null, null), { cancel: () => {
                S = !0, v || l.abort();
              } };
            }(r, e);
          if (Jn() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, e, void 0, !0);
        }
        var n;
        return function(o, u) {
          const l = new XMLHttpRequest();
          l.open(o.method || "GET", o.url, !0), o.type === "arrayBuffer" && (l.responseType = "arraybuffer");
          for (const f in o.headers)
            l.setRequestHeader(f, o.headers[f]);
          return o.type === "json" && (l.responseType = "text", l.setRequestHeader("Accept", "application/json")), l.withCredentials = o.credentials === "include", l.onerror = () => {
            u(new Error(l.statusText));
          }, l.onload = () => {
            if ((l.status >= 200 && l.status < 300 || l.status === 0) && l.response !== null) {
              let f = l.response;
              if (o.type === "json")
                try {
                  f = JSON.parse(l.response);
                } catch (v) {
                  return u(v);
                }
              u(null, f, l.getResponseHeader("Cache-Control"), l.getResponseHeader("Expires"));
            } else
              u(new jo(l.statusText, l.status, o.url));
          }, l.send(o.body), { cancel: () => l.abort() };
        }(r, e);
      }, no = function(r, e) {
        return xn(Pn(r, { type: "arrayBuffer" }), e);
      };
      function Go(r) {
        const e = document.createElement("a");
        return e.href = r, e.protocol === location.protocol && e.host === location.host;
      }
      const aa = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Da, Vi;
      Da = [], Vi = 0;
      const Hn = function(r, e) {
        if (Gs.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), Vi >= ge.MAX_PARALLEL_IMAGE_REQUESTS) {
          const l = { requestParameters: r, callback: e, cancelled: !1, cancel() {
            this.cancelled = !0;
          } };
          return Da.push(l), l;
        }
        Vi++;
        let n = !1;
        const o = () => {
          if (!n)
            for (n = !0, Vi--; Da.length && Vi < ge.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const l = Da.shift(), { requestParameters: f, callback: v, cancelled: S } = l;
              S || (l.cancel = Hn(f, v).cancel);
            }
        }, u = no(r, (l, f, v, S) => {
          o(), l ? e(l) : f && (self.createImageBitmap ? function(D, x) {
            const A = new Blob([new Uint8Array(D)], { type: "image/png" });
            createImageBitmap(A).then((I) => {
              x(null, I);
            }).catch((I) => {
              x(new Error(`Could not load image because of ${I.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(f, (D, x) => e(D, x, v, S)) : function(D, x) {
            const A = new Image();
            A.onload = () => {
              x(null, A), URL.revokeObjectURL(A.src), A.onload = null, requestAnimationFrame(() => {
                A.src = aa;
              });
            }, A.onerror = () => x(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const I = new Blob([new Uint8Array(D)], { type: "image/png" });
            A.src = D.byteLength ? URL.createObjectURL(I) : aa;
          }(f, (D, x) => e(D, x, v, S)));
        });
        return { cancel: () => {
          u.cancel(), o();
        } };
      };
      var hl, Zs, Qn, Ar = { exports: {} }, nr = { exports: {} }, Ks = { exports: {} }, Yn = function() {
        if (Qn)
          return Ar.exports;
        Qn = 1;
        var r = (hl || (hl = 1, nr.exports = function(n, o) {
          var u, l, f, v, S, D, x, A;
          for (l = n.length - (u = 3 & n.length), f = o, S = 3432918353, D = 461845907, A = 0; A < l; )
            x = 255 & n.charCodeAt(A) | (255 & n.charCodeAt(++A)) << 8 | (255 & n.charCodeAt(++A)) << 16 | (255 & n.charCodeAt(++A)) << 24, ++A, f = 27492 + (65535 & (v = 5 * (65535 & (f = (f ^= x = (65535 & (x = (x = (65535 & x) * S + (((x >>> 16) * S & 65535) << 16) & 4294967295) << 15 | x >>> 17)) * D + (((x >>> 16) * D & 65535) << 16) & 4294967295) << 13 | f >>> 19)) + ((5 * (f >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
          switch (x = 0, u) {
            case 3:
              x ^= (255 & n.charCodeAt(A + 2)) << 16;
            case 2:
              x ^= (255 & n.charCodeAt(A + 1)) << 8;
            case 1:
              f ^= x = (65535 & (x = (x = (65535 & (x ^= 255 & n.charCodeAt(A))) * S + (((x >>> 16) * S & 65535) << 16) & 4294967295) << 15 | x >>> 17)) * D + (((x >>> 16) * D & 65535) << 16) & 4294967295;
          }
          return f ^= n.length, f = 2246822507 * (65535 & (f ^= f >>> 16)) + ((2246822507 * (f >>> 16) & 65535) << 16) & 4294967295, f = 3266489909 * (65535 & (f ^= f >>> 13)) + ((3266489909 * (f >>> 16) & 65535) << 16) & 4294967295, (f ^= f >>> 16) >>> 0;
        }), nr.exports), e = (Zs || (Zs = 1, Ks.exports = function(n, o) {
          for (var u, l = n.length, f = o ^ l, v = 0; l >= 4; )
            u = 1540483477 * (65535 & (u = 255 & n.charCodeAt(v) | (255 & n.charCodeAt(++v)) << 8 | (255 & n.charCodeAt(++v)) << 16 | (255 & n.charCodeAt(++v)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), f = 1540483477 * (65535 & f) + ((1540483477 * (f >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), l -= 4, ++v;
          switch (l) {
            case 3:
              f ^= (255 & n.charCodeAt(v + 2)) << 16;
            case 2:
              f ^= (255 & n.charCodeAt(v + 1)) << 8;
            case 1:
              f = 1540483477 * (65535 & (f ^= 255 & n.charCodeAt(v))) + ((1540483477 * (f >>> 16) & 65535) << 16);
          }
          return f = 1540483477 * (65535 & (f ^= f >>> 13)) + ((1540483477 * (f >>> 16) & 65535) << 16), (f ^= f >>> 15) >>> 0;
        }), Ks.exports);
        return Ar.exports = r, Ar.exports.murmur3 = r, Ar.exports.murmur2 = e, Ar.exports;
      }(), $r = O(Yn);
      class Pr {
        constructor(e, ...n) {
          Pn(this, n[0] || {}), this.type = e;
        }
      }
      class Cr extends Pr {
        constructor(e, n = {}) {
          super("error", Pn({ error: e }, n));
        }
      }
      function ka(r, e, n) {
        n[r] && n[r].indexOf(e) !== -1 || (n[r] = n[r] || [], n[r].push(e));
      }
      function la(r, e, n) {
        if (n && n[r]) {
          const o = n[r].indexOf(e);
          o !== -1 && n[r].splice(o, 1);
        }
      }
      class Zo {
        on(e, n) {
          return this._listeners = this._listeners || {}, ka(e, n, this._listeners), this;
        }
        off(e, n) {
          return la(e, n, this._listeners), la(e, n, this._oneTimeListeners), this;
        }
        once(e, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, ka(e, n, this._oneTimeListeners), this) : new Promise((o) => this.once(e, o));
        }
        fire(e, n) {
          const o = typeof e == "string" ? new Pr(e, n) : e, u = o.type;
          if (this.listens(u)) {
            o.target = this;
            const l = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
            for (const S of l)
              S.call(this, o);
            const f = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
            for (const S of f)
              la(u, S, this._oneTimeListeners), S.call(this, o);
            const v = this._eventedParent;
            v && (Pn(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(o));
          } else
            o instanceof Cr && console.error(o.error);
          return this;
        }
        listens(e) {
          return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e));
        }
        setEventedParent(e, n) {
          return this._eventedParent = e, this._eventedParentData = n, this;
        }
      }
      var sr, ca = {}, Ra = function() {
        if (sr)
          return ca;
        sr = 1;
        var r = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function e(l) {
          return (l = Math.round(l)) < 0 ? 0 : l > 255 ? 255 : l;
        }
        function n(l) {
          return e(l[l.length - 1] === "%" ? parseFloat(l) / 100 * 255 : parseInt(l));
        }
        function o(l) {
          return (f = l[l.length - 1] === "%" ? parseFloat(l) / 100 : parseFloat(l)) < 0 ? 0 : f > 1 ? 1 : f;
          var f;
        }
        function u(l, f, v) {
          return v < 0 ? v += 1 : v > 1 && (v -= 1), 6 * v < 1 ? l + (f - l) * v * 6 : 2 * v < 1 ? f : 3 * v < 2 ? l + (f - l) * (2 / 3 - v) * 6 : l;
        }
        try {
          ca.parseCSSColor = function(l) {
            var f, v = l.replace(/ /g, "").toLowerCase();
            if (v in r)
              return r[v].slice();
            if (v[0] === "#")
              return v.length === 4 ? (f = parseInt(v.substr(1), 16)) >= 0 && f <= 4095 ? [(3840 & f) >> 4 | (3840 & f) >> 8, 240 & f | (240 & f) >> 4, 15 & f | (15 & f) << 4, 1] : null : v.length === 7 && (f = parseInt(v.substr(1), 16)) >= 0 && f <= 16777215 ? [(16711680 & f) >> 16, (65280 & f) >> 8, 255 & f, 1] : null;
            var S = v.indexOf("("), D = v.indexOf(")");
            if (S !== -1 && D + 1 === v.length) {
              var x = v.substr(0, S), A = v.substr(S + 1, D - (S + 1)).split(","), I = 1;
              switch (x) {
                case "rgba":
                  if (A.length !== 4)
                    return null;
                  I = o(A.pop());
                case "rgb":
                  return A.length !== 3 ? null : [n(A[0]), n(A[1]), n(A[2]), I];
                case "hsla":
                  if (A.length !== 4)
                    return null;
                  I = o(A.pop());
                case "hsl":
                  if (A.length !== 3)
                    return null;
                  var M = (parseFloat(A[0]) % 360 + 360) % 360 / 360, C = o(A[1]), k = o(A[2]), V = k <= 0.5 ? k * (C + 1) : k + C - k * C, U = 2 * k - V;
                  return [e(255 * u(U, V, M + 1 / 3)), e(255 * u(U, V, M)), e(255 * u(U, V, M - 1 / 3)), I];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
        return ca;
      }();
      class ki {
        constructor(e, n, o, u = 1) {
          this.r = e, this.g = n, this.b = o, this.a = u;
        }
        static parse(e) {
          if (!e)
            return;
          if (e instanceof ki)
            return e;
          if (typeof e != "string")
            return;
          const n = Ra.parseCSSColor(e);
          return n ? new ki(n[0] / 255 * n[3], n[1] / 255 * n[3], n[2] / 255 * n[3], n[3]) : void 0;
        }
        toStringPremultipliedAlpha() {
          const [e, n, o, u] = this.a === 0 ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
          return `rgba(${Math.round(e)},${Math.round(n)},${Math.round(o)},${u})`;
        }
        toString() {
          const [e, n, o, u] = [this.r, this.g, this.b, this.a];
          return `rgba(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * o)},${u})`;
        }
        toRenderColor(e) {
          const { r: n, g: o, b: u, a: l } = this;
          return new Gl(e, n, o, u, l);
        }
        clone() {
          return new ki(this.r, this.g, this.b, this.a);
        }
      }
      class Gl {
        constructor(e, n, o, u, l) {
          if (e) {
            const f = e.image.height, v = f * f;
            n = l === 0 ? 0 : n / l * (f - 1), o = l === 0 ? 0 : o / l * (f - 1), u = l === 0 ? 0 : u / l * (f - 1);
            const S = Math.floor(n), D = Math.floor(o), x = Math.floor(u), A = Math.ceil(n), I = Math.ceil(o), M = Math.ceil(u), C = n - S, k = o - D, V = u - x, U = e.image.data, q = 4 * (S + D * v + x * f), $ = 4 * (S + D * v + M * f), H = 4 * (S + I * v + x * f), K = 4 * (S + I * v + M * f), Q = 4 * (A + D * v + x * f), ie = 4 * (A + D * v + M * f), fe = 4 * (A + I * v + x * f), de = 4 * (A + I * v + M * f);
            if (q < 0 || de >= U.length)
              throw new Error("out of range");
            this.r = ei(ei(ei(U[q], U[$], V), ei(U[H], U[K], V), k), ei(ei(U[Q], U[ie], V), ei(U[fe], U[de], V), k), C) / 255 * l, this.g = ei(ei(ei(U[q + 1], U[$ + 1], V), ei(U[H + 1], U[K + 1], V), k), ei(ei(U[Q + 1], U[ie + 1], V), ei(U[fe + 1], U[de + 1], V), k), C) / 255 * l, this.b = ei(ei(ei(U[q + 2], U[$ + 2], V), ei(U[H + 2], U[K + 2], V), k), ei(ei(U[Q + 2], U[ie + 2], V), ei(U[fe + 2], U[de + 2], V), k), C) / 255 * l, this.a = l;
          } else
            this.r = n, this.g = o, this.b = u, this.a = l;
        }
        toArray() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [255 * e / u, 255 * n / u, 255 * o / u, u];
        }
        toHslaArray() {
          if (this.a === 0)
            return [0, 0, 0, 0];
          const { r: e, g: n, b: o, a: u } = this, l = Math.min(Math.max(e / u, 0), 1), f = Math.min(Math.max(n / u, 0), 1), v = Math.min(Math.max(o / u, 0), 1), S = Math.min(l, f, v), D = Math.max(l, f, v), x = (S + D) / 2;
          if (S === D)
            return [0, 0, 100 * x, u];
          const A = D - S, I = x > 0.5 ? A / (2 - D - S) : A / (D + S);
          let M = 0;
          return D === l ? M = (f - v) / A + (f < v ? 6 : 0) : D === f ? M = (v - l) / A + 2 : D === v && (M = (l - f) / A + 4), M *= 60, [Math.min(Math.max(M, 0), 360), Math.min(Math.max(100 * I, 0), 100), Math.min(Math.max(100 * x, 0), 100), u];
        }
        toArray01() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [e / u, n / u, o / u, u];
        }
        toArray01Scaled(e) {
          const { r: n, g: o, b: u, a: l } = this;
          return l === 0 ? [0, 0, 0] : [n / l * e, o / l * e, u / l * e];
        }
        toArray01PremultipliedAlpha() {
          const { r: e, g: n, b: o, a: u } = this;
          return [e, n, o, u];
        }
        toArray01Linear() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [Math.pow(e / u, 2.2), Math.pow(n / u, 2.2), Math.pow(o / u, 2.2), u];
        }
      }
      function ei(r, e, n) {
        return r * (1 - n) + e * n;
      }
      function ul(r, e, n) {
        return r.map((o, u) => ei(o, e[u], n));
      }
      ki.black = new ki(0, 0, 0, 1), ki.white = new ki(1, 1, 1, 1), ki.transparent = new ki(0, 0, 0, 0), ki.red = new ki(1, 0, 0, 1), ki.blue = new ki(0, 0, 1, 1);
      var Oi = Object.freeze({ __proto__: null, array: ul, color: function(r, e, n) {
        return new ki(ei(r.r, e.r, n), ei(r.g, e.g, n), ei(r.b, e.b, n), ei(r.a, e.a, n));
      }, number: ei });
      function Bi(r, ...e) {
        for (const n of e)
          for (const o in n)
            r[o] = n[o];
        return r;
      }
      class ns extends Error {
        constructor(e, n) {
          super(n), this.message = n, this.key = e;
        }
      }
      class Cn {
        constructor(e, n = []) {
          this.parent = e, this.bindings = {};
          for (const [o, u] of n)
            this.bindings[o] = u;
        }
        concat(e) {
          return new Cn(this, e);
        }
        get(e) {
          if (this.bindings[e])
            return this.bindings[e];
          if (this.parent)
            return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      const ha = { kind: "null" }, Ot = { kind: "number" }, Fi = { kind: "string" }, Li = { kind: "boolean" }, ms = { kind: "color" }, bo = { kind: "object" }, Ai = { kind: "value" }, _s = { kind: "collator" }, Js = { kind: "formatted" }, Ho = { kind: "resolvedImage" };
      function Ss(r, e) {
        return { kind: "array", itemType: r, N: e };
      }
      function un(r) {
        if (r.kind === "array") {
          const e = un(r.itemType);
          return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return r.kind;
      }
      const Bc = [ha, Ot, Fi, Li, ms, Js, bo, Ss(Ai), Ho];
      function ua(r, e) {
        if (e.kind === "error")
          return null;
        if (r.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ua(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
            return null;
        } else {
          if (r.kind === e.kind)
            return null;
          if (r.kind === "value") {
            for (const n of Bc)
              if (!ua(n, e))
                return null;
          }
        }
        return `Expected ${un(r)} but found ${un(e)} instead.`;
      }
      function Zl(r, e) {
        return e.some((n) => n.kind === r.kind);
      }
      function da(r, e) {
        return e.some((n) => n === "null" ? r === null : n === "array" ? Array.isArray(r) : n === "object" ? r && !Array.isArray(r) && typeof r == "object" : n === typeof r);
      }
      class nn {
        constructor(e, n, o) {
          this.sensitivity = e ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, n) {
          return this.collator.compare(e, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class dl {
        constructor(e, n, o, u, l) {
          this.text = e.normalize ? e.normalize() : e, this.image = n, this.scale = o, this.fontStack = u, this.textColor = l;
        }
      }
      class Dn {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new Dn([new dl(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.namePrimary);
        }
        static factory(e) {
          return e instanceof Dn ? e : Dn.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
        serialize() {
          const e = ["format"];
          for (const n of this.sections) {
            if (n.image) {
              e.push(["image", n.image.namePrimary]);
              continue;
            }
            e.push(n.text);
            const o = {};
            n.fontStack && (o["text-font"] = ["literal", n.fontStack.split(",")]), n.scale && (o["font-scale"] = n.scale), n.textColor && (o["text-color"] = ["rgba"].concat(n.textColor.toRenderColor(null).toArray())), e.push(o);
          }
          return e;
        }
      }
      class rr {
        constructor(e, n) {
          if (this.id = e, this.options = n || { params: {} }, this.options.transform) {
            const { a: o, b: u, c: l, d: f, e: v, f: S } = this.options.transform;
            this.options.transform = new DOMMatrix([o, u, l, f, v, S]);
          } else
            this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
        }
        static deserializeId(e) {
          return JSON.parse(e).id;
        }
        static deserializeFromString(e) {
          const n = JSON.parse(e), { a: o, b: u, c: l, d: f, e: v, f: S } = n.options.transform;
          return new DOMMatrix([o, u, l, f, v, S]), new rr(n.id, n.options);
        }
        scaleSelf(e) {
          return this.options.transform = this.options.transform.scale(e), this;
        }
        serialize() {
          const e = { id: this.id };
          this.options && (e.options = this.options);
          const { a: n, b: o, c: u, d: l, e: f, f: v } = this.options.transform;
          return e.options.transform = { a: n, b: o, c: u, d: l, e: f, f: v }, JSON.stringify(e);
        }
      }
      class ss {
        constructor(e) {
          this.namePrimary = e.namePrimary, e.nameSecondary && (this.nameSecondary = e.nameSecondary), e.optionsPrimary && (this.optionsPrimary = e.optionsPrimary), e.optionsSecondary && (this.optionsSecondary = e.optionsSecondary), this.available = e.available;
        }
        toString() {
          return this.namePrimary && this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
        }
        getPrimary() {
          return new rr(this.namePrimary, { params: this.optionsPrimary && this.optionsPrimary.params || {} });
        }
        getSerializedPrimary() {
          return this.getPrimary().serialize();
        }
        getSecondary() {
          return this.nameSecondary ? new rr(this.nameSecondary, { params: this.optionsSecondary && this.optionsSecondary.params || {} }) : null;
        }
        static from(e) {
          return typeof e == "string" ? ss.build(e) : e;
        }
        static build(e, n, o, u) {
          return e ? new ss({ namePrimary: e, nameSecondary: n, optionsPrimary: o, optionsSecondary: u, available: !1 }) : null;
        }
      }
      function fa(r, e, n, o) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[r, e, n, o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o == "number" ? [r, e, n, o] : [r, e, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function wo(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof ki || r instanceof nn || r instanceof Dn || r instanceof ss)
          return !0;
        if (Array.isArray(r)) {
          for (const e of r)
            if (!wo(e))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (const e in r)
            if (!wo(r[e]))
              return !1;
          return !0;
        }
        return !1;
      }
      function vn(r) {
        if (r === null)
          return ha;
        if (typeof r == "string")
          return Fi;
        if (typeof r == "boolean")
          return Li;
        if (typeof r == "number")
          return Ot;
        if (r instanceof ki)
          return ms;
        if (r instanceof nn)
          return _s;
        if (r instanceof Dn)
          return Js;
        if (r instanceof ss)
          return Ho;
        if (Array.isArray(r)) {
          const e = r.length;
          let n;
          for (const o of r) {
            const u = vn(o);
            if (n) {
              if (n === u)
                continue;
              n = Ai;
              break;
            }
            n = u;
          }
          return Ss(n || Ai, e);
        }
        return bo;
      }
      function Ir(r) {
        const e = typeof r;
        return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof ki ? r.toStringPremultipliedAlpha() : r instanceof Dn || r instanceof ss ? r.toString() : JSON.stringify(r);
      }
      class Lr {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!wo(e[1]))
            return n.error("invalid value");
          const o = e[1];
          let u = vn(o);
          const l = n.expectedType;
          return u.kind !== "array" || u.N !== 0 || !l || l.kind !== "array" || typeof l.N == "number" && l.N !== 0 || (u = l), new Lr(u, o);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof ki ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Dn ? this.value.serialize() : this.value;
        }
      }
      class qn {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      }
      const pa = { string: Fi, number: Ot, boolean: Li, object: bo };
      class zr {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          let o, u = 1;
          const l = e[0];
          if (l === "array") {
            let v, S;
            if (e.length > 2) {
              const D = e[1];
              if (typeof D != "string" || !(D in pa) || D === "object")
                return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              v = pa[D], u++;
            } else
              v = Ai;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
                return n.error('The length argument to "array" must be a positive integer literal', 2);
              S = e[2], u++;
            }
            o = Ss(v, S);
          } else
            o = pa[l];
          const f = [];
          for (; u < e.length; u++) {
            const v = n.parse(e[u], u, Ai);
            if (!v)
              return null;
            f.push(v);
          }
          return new zr(o, f);
        }
        evaluate(e) {
          for (let n = 0; n < this.args.length; n++) {
            const o = this.args[n].evaluate(e);
            if (!ua(this.type, vn(o)))
              return o;
            if (n === this.args.length - 1)
              throw new qn(`The expression ${JSON.stringify(this.args[n].serialize())} evaluated to ${un(vn(o))} but was expected to be of type ${un(this.type)}.`);
          }
          return null;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = this.type, n = [e.kind];
          if (e.kind === "array") {
            const o = e.itemType;
            if (o.kind === "string" || o.kind === "number" || o.kind === "boolean") {
              n.push(o.kind);
              const u = e.N;
              (typeof u == "number" || this.args.length > 1) && n.push(u);
            }
          }
          return n.concat(this.args.map((o) => o.serialize()));
        }
      }
      class Es {
        constructor(e) {
          this.type = Js, this.sections = e;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          const o = e[1];
          if (!Array.isArray(o) && typeof o == "object")
            return n.error("First argument must be an image or text section.");
          const u = [];
          let l = !1;
          for (let f = 1; f <= e.length - 1; ++f) {
            const v = e[f];
            if (l && typeof v == "object" && !Array.isArray(v)) {
              l = !1;
              let S = null;
              if (v["font-scale"] && (S = n.parseObjectValue(v["font-scale"], f, "font-scale", Ot), !S))
                return null;
              let D = null;
              if (v["text-font"] && (D = n.parseObjectValue(v["text-font"], f, "text-font", Ss(Fi)), !D))
                return null;
              let x = null;
              if (v["text-color"] && (x = n.parseObjectValue(v["text-color"], f, "text-color", ms), !x))
                return null;
              const A = u[u.length - 1];
              A.scale = S, A.font = D, A.textColor = x;
            } else {
              const S = n.parse(e[f], f, Ai);
              if (!S)
                return null;
              const D = S.type.kind;
              if (D !== "string" && D !== "value" && D !== "null" && D !== "resolvedImage")
                return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              l = !0, u.push({ content: S, scale: null, font: null, textColor: null });
            }
          }
          return new Es(u);
        }
        evaluate(e) {
          return new Dn(this.sections.map((n) => {
            const o = n.content.evaluate(e);
            return vn(o) === Ho ? new dl("", o, null, null, null) : new dl(Ir(o), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const n of this.sections)
            e(n.content), n.scale && e(n.scale), n.font && e(n.font), n.textColor && e(n.textColor);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["format"];
          for (const n of this.sections) {
            e.push(n.content.serialize());
            const o = {};
            n.scale && (o["font-scale"] = n.scale.serialize()), n.font && (o["text-font"] = n.font.serialize()), n.textColor && (o["text-color"] = n.textColor.serialize()), e.push(o);
          }
          return e;
        }
      }
      class Oa {
        constructor(e, n, o, u) {
          this._imageWarnHistory = {}, this.type = Ho, this.inputPrimary = e, this.inputSecondary = n, this.inputPrimaryParams = o, this.inputSecondaryParams = u;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected two or more arguments.");
          let o = 1;
          const u = [];
          function l() {
            if (o < e.length) {
              const v = n.parse(e[o], o++, Fi);
              return v ? (u.push({ image: v, options: void 0 }), !0) : (n.error(u.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
            }
            return !0;
          }
          function f() {
            if (o < e.length) {
              if ((v = e[o]) === null || typeof v != "object" || Array.isArray(v))
                return !0;
              const S = e[o].params, D = n.concat(o);
              if (!S)
                return o++, !0;
              if (typeof S != "object" || S.constructor !== Object)
                return D.error('Image options "params" should be an object'), !1;
              const x = {}, A = D.concat(void 0, "params");
              for (const I in S) {
                if (!I)
                  return A.error("Image parameter name should be non-empty"), !1;
                const M = A.concat(void 0, I).parse(S[I], void 0, ms, void 0, { typeAnnotation: "coerce" });
                if (!M)
                  return !1;
                x[I] = M;
              }
              return u[u.length - 1].options = x, o++, !0;
            }
            var v;
            return !0;
          }
          for (let v = 0; v < 2; v++)
            if (!l() || !f())
              return;
          return new Oa(u[0].image, u[1] ? u[1].image : void 0, u[0].options, u[1] ? u[1].options : void 0);
        }
        evaluateParams(e, n) {
          const o = {};
          if (n) {
            for (const u in n)
              if (n[u])
                try {
                  const l = n[u].evaluate(e), f = `Ignoring image parameter "${u}" with semi-transparent color ${l.toString()}`;
                  if (l.a !== 1) {
                    this._imageWarnHistory[f] || (console.warn(f), this._imageWarnHistory[f] = !0);
                    continue;
                  }
                  o[u] = l;
                } catch {
                  continue;
                }
            if (Object.keys(o).length !== 0)
              return { params: o };
          }
        }
        evaluate(e) {
          const n = ss.build(this.inputPrimary.evaluate(e), this.inputSecondary ? this.inputSecondary.evaluate(e) : void 0, this.inputPrimaryParams ? this.evaluateParams(e, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(e, this.inputSecondaryParams) : void 0);
          return n && e.availableImages && (n.available = e.availableImages.indexOf(n.namePrimary) > -1, n.nameSecondary && n.available && e.availableImages && (n.available = e.availableImages.indexOf(n.nameSecondary) > -1)), n;
        }
        eachChild(e) {
          if (e(this.inputPrimary), this.inputPrimaryParams)
            for (const n in this.inputPrimaryParams)
              this.inputPrimaryParams[n] && e(this.inputPrimaryParams[n]);
          if (this.inputSecondary && (e(this.inputSecondary), this.inputSecondaryParams))
            for (const n in this.inputSecondaryParams)
              this.inputSecondaryParams[n] && e(this.inputSecondaryParams[n]);
        }
        outputDefined() {
          return !1;
        }
        serializeParams(e) {
          const n = {};
          if (e) {
            for (const o in e)
              e[o] && (n[o] = e[o].serialize());
            return { params: n };
          }
        }
        serialize() {
          const e = ["image", this.inputPrimary.serialize()];
          return this.inputPrimaryParams && e.push(this.serializeParams(this.inputPrimaryParams)), this.inputSecondary && (e.push(this.inputSecondary.serialize()), this.inputSecondaryParams && e.push(this.serializeParams(this.inputSecondaryParams))), e;
        }
      }
      function qo(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      const Wo = { "to-boolean": Li, "to-color": ms, "to-number": Ot, "to-string": Fi };
      class so {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          const o = e[0], u = [];
          let l = ha;
          if (o === "to-array") {
            if (!Array.isArray(e[1]))
              return null;
            const f = e[1].length;
            if (n.expectedType) {
              if (n.expectedType.kind !== "array")
                return n.error(`Expected ${n.expectedType.kind} but found array.`);
              l = Ss(n.expectedType.itemType, f);
            } else {
              if (!(f > 0 && wo(e[1][0])))
                return null;
              l = Ss(vn(e[1][0]), f);
            }
            for (let v = 0; v < f; v++) {
              const S = e[1][v];
              let D;
              if (qo(S) === "array")
                D = n.parse(S, void 0, l.itemType);
              else {
                const x = qo(S);
                if (x !== l.itemType.kind)
                  return n.error(`Expected ${l.itemType.kind} but found ${x}.`);
                D = n.registry.literal.parse(["literal", S === void 0 ? null : S], n);
              }
              if (!D)
                return null;
              u.push(D);
            }
          } else {
            if ((o === "to-boolean" || o === "to-string") && e.length !== 2)
              return n.error("Expected one argument.");
            l = Wo[o];
            for (let f = 1; f < e.length; f++) {
              const v = n.parse(e[f], f, Ai);
              if (!v)
                return null;
              u.push(v);
            }
          }
          return new so(l, u);
        }
        evaluate(e) {
          if (this.type.kind === "boolean")
            return !!this.args[0].evaluate(e);
          if (this.type.kind === "color") {
            let n, o;
            for (const u of this.args) {
              if (n = u.evaluate(e), o = null, n instanceof ki)
                return n;
              if (typeof n == "string") {
                const l = e.parseColor(n);
                if (l)
                  return l;
              } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : fa(n[0], n[1], n[2], n[3]), !o))
                return new ki(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
            }
            throw new qn(o || `Could not parse color from value '${typeof n == "string" ? n : String(JSON.stringify(n))}'`);
          }
          if (this.type.kind === "number") {
            let n = null;
            for (const o of this.args) {
              if (n = o.evaluate(e), n === null)
                return 0;
              const u = Number(n);
              if (!isNaN(u))
                return u;
            }
            throw new qn(`Could not convert ${JSON.stringify(n)} to number.`);
          }
          return this.type.kind === "formatted" ? Dn.fromString(Ir(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? ss.build(Ir(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map((n) => n.evaluate(e)) : Ir(this.args[0].evaluate(e));
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          if (this.type.kind === "formatted")
            return new Es([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage")
            return new Oa(this.args[0]).serialize();
          const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      const Nc = ["Unknown", "Point", "LineString", "Polygon"];
      class Fa {
        constructor(e, n) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = n;
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Nc[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(e) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const e = this.featureDistanceData.center, n = this.featureDistanceData.scale, { x: o, y: u } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (o * n - e[0]) + this.featureDistanceData.bearing[1] * (u * n - e[1]);
          }
          return 0;
        }
        parseColor(e) {
          let n = this._parseColorCache[e];
          return n || (n = this._parseColorCache[e] = ki.parse(e)), n;
        }
        getConfig(e) {
          return this.options ? this.options.get(e) : null;
        }
      }
      class or {
        constructor(e, n, o, u, l) {
          this.name = e, this.type = n, this._evaluate = o, this.args = u, this._overloadIndex = l;
        }
        evaluate(e) {
          if (!this._evaluate) {
            const n = or.definitions[this.name];
            this._evaluate = Array.isArray(n) ? n[2] : n.overloads[this._overloadIndex][1];
          }
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return [this.name].concat(this.args.map((e) => e.serialize()));
        }
        static parse(e, n) {
          const o = e[0], u = or.definitions[o];
          if (!u)
            return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const l = Array.isArray(u) ? u[0] : u.type, f = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, v = [];
          let S = null, D = -1;
          for (const [x, A] of f) {
            if (Array.isArray(x) && x.length !== e.length - 1)
              continue;
            v.push(x), D++, S = new Qr(n.registry, n.path, null, n.scope, void 0, n._scope, n.options);
            const I = [];
            let M = !1;
            for (let C = 1; C < e.length; C++) {
              const k = e[C], V = Array.isArray(x) ? x[C - 1] : x.type, U = S.parse(k, 1 + I.length, V);
              if (!U) {
                M = !0;
                break;
              }
              I.push(U);
            }
            if (!M)
              if (Array.isArray(x) && x.length !== I.length)
                S.error(`Expected ${x.length} arguments, but found ${I.length} instead.`);
              else {
                for (let C = 0; C < I.length; C++) {
                  const k = Array.isArray(x) ? x[C] : x.type, V = I[C];
                  S.concat(C + 1).checkSubtype(k, V.type);
                }
                if (S.errors.length === 0)
                  return new or(o, l, A, I, D);
              }
          }
          if (v.length === 1)
            n.errors.push(...S.errors);
          else {
            const x = (v.length ? v : f.map(([I]) => I)).map(fl).join(" | "), A = [];
            for (let I = 1; I < e.length; I++) {
              const M = n.parse(e[I], 1 + A.length);
              if (!M)
                return null;
              A.push(un(M.type));
            }
            n.error(`Expected arguments of type ${x}, but found (${A.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, n) {
          or.definitions = n;
          for (const o in n)
            e[o] = or;
        }
      }
      function fl(r) {
        return Array.isArray(r) ? `(${r.map(un).join(", ")})` : `(${un(r.type)}...)`;
      }
      class pl {
        constructor(e, n, o) {
          this.type = _s, this.locale = o, this.caseSensitive = e, this.diacriticSensitive = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error("Expected one argument.");
          const o = e[1];
          if (typeof o != "object" || Array.isArray(o))
            return n.error("Collator options argument must be an object.");
          const u = o["case-sensitive"] === void 0 ? n.parse(!1, 1, Li) : n.parseObjectValue(o["case-sensitive"], 1, "case-sensitive", Li);
          if (!u)
            return null;
          const l = o["diacritic-sensitive"] === void 0 ? n.parse(!1, 1, Li) : n.parseObjectValue(o["diacritic-sensitive"], 1, "diacritic-sensitive", Li);
          if (!l)
            return null;
          let f = null;
          return o.locale && (f = n.parseObjectValue(o.locale, 1, "locale", Fi), !f) ? null : new pl(u, l, f);
        }
        evaluate(e) {
          return new nn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e];
        }
      }
      function Nh(r, e, n = 0, o = r.length - 1, u = Vc) {
        for (; o > n; ) {
          if (o - n > 600) {
            const S = o - n + 1, D = e - n + 1, x = Math.log(S), A = 0.5 * Math.exp(2 * x / 3), I = 0.5 * Math.sqrt(x * A * (S - A) / S) * (D - S / 2 < 0 ? -1 : 1);
            Nh(r, e, Math.max(n, Math.floor(e - D * A / S + I)), Math.min(o, Math.floor(e + (S - D) * A / S + I)), u);
          }
          const l = r[e];
          let f = n, v = o;
          for (ml(r, n, e), u(r[o], l) > 0 && ml(r, n, o); f < v; ) {
            for (ml(r, f, v), f++, v--; u(r[f], l) < 0; )
              f++;
            for (; u(r[v], l) > 0; )
              v--;
          }
          u(r[n], l) === 0 ? ml(r, n, v) : (v++, ml(r, v, o)), v <= e && (n = v + 1), e <= v && (o = v - 1);
        }
      }
      function ml(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      function Vc(r, e) {
        return r < e ? -1 : r > e ? 1 : 0;
      }
      function Qu(r) {
        let e = 0;
        for (let n, o, u = 0, l = r.length, f = l - 1; u < l; f = u++)
          n = r[u], o = r[f], e += (o.x - n.x) * (n.y + o.y);
        return e;
      }
      function Ba(r, e) {
        r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
      }
      function Na(r, e) {
        return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
      }
      function _l(r, e, n) {
        const o = r[0] - e[0], u = r[1] - e[1], l = r[0] - n[0], f = r[1] - n[1];
        return o * f - l * u == 0 && o * l <= 0 && u * f <= 0;
      }
      function Ds(r, e, n = !1) {
        let o = !1;
        for (let v = 0, S = e.length; v < S; v++) {
          const D = e[v];
          for (let x = 0, A = D.length, I = A - 1; x < A; I = x++) {
            const M = D[I], C = D[x];
            if (_l(r, M, C))
              return n;
            (l = M)[1] > (u = r)[1] != (f = C)[1] > u[1] && u[0] < (f[0] - l[0]) * (u[1] - l[1]) / (f[1] - l[1]) + l[0] && (o = !o);
          }
        }
        var u, l, f;
        return o;
      }
      function Vh(r, e, n, o) {
        const u = o[0] - n[0], l = o[1] - n[1], f = (r[0] - n[0]) * l - u * (r[1] - n[1]), v = (e[0] - n[0]) * l - u * (e[1] - n[1]);
        return f > 0 && v < 0 || f < 0 && v > 0;
      }
      function $o(r, e, n, o) {
        return (u = [o[0] - n[0], o[1] - n[1]])[0] * (l = [e[0] - r[0], e[1] - r[1]])[1] - u[1] * l[0] != 0 && !(!Vh(r, e, n, o) || !Vh(n, o, r, e));
        var u, l;
      }
      const rs = 8192;
      function Uh(r, e) {
        const n = (180 + r[0]) / 360, o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, u = Math.pow(2, e.z);
        return [Math.round(n * u * rs), Math.round(o * u * rs)];
      }
      function jh(r, e) {
        for (let n = 0; n < e.length; n++)
          if (Ds(r, e[n]))
            return !0;
        return !1;
      }
      function ed(r, e, n) {
        for (const o of n)
          for (let u = 0, l = o.length, f = l - 1; u < l; f = u++)
            if ($o(r, e, o[f], o[u]))
              return !0;
        return !1;
      }
      function Hl(r, e) {
        for (let n = 0; n < r.length; ++n)
          if (!Ds(r[n], e))
            return !1;
        for (let n = 0; n < r.length - 1; ++n)
          if (ed(r[n], r[n + 1], e))
            return !1;
        return !0;
      }
      function Xo(r, e) {
        for (let n = 0; n < e.length; n++)
          if (Hl(r, e[n]))
            return !0;
        return !1;
      }
      function bi(r, e, n) {
        const o = [];
        for (let u = 0; u < r.length; u++) {
          const l = [];
          for (let f = 0; f < r[u].length; f++) {
            const v = Uh(r[u][f], n);
            Ba(e, v), l.push(v);
          }
          o.push(l);
        }
        return o;
      }
      function Wt(r, e, n) {
        const o = [];
        for (let u = 0; u < r.length; u++) {
          const l = bi(r[u], e, n);
          o.push(l);
        }
        return o;
      }
      function gl(r, e, n, o) {
        if (r[0] < n[0] || r[0] > n[2]) {
          const u = 0.5 * o;
          let l = r[0] - n[0] > u ? -o : n[0] - r[0] > u ? o : 0;
          l === 0 && (l = r[0] - n[2] > u ? -o : n[2] - r[0] > u ? o : 0), r[0] += l;
        }
        Ba(e, r);
      }
      function ci(r, e, n, o) {
        const u = Math.pow(2, o.z) * rs, l = [o.x * rs, o.y * rs], f = [];
        if (!r)
          return f;
        for (const v of r)
          for (const S of v) {
            const D = [S.x + l[0], S.y + l[1]];
            gl(D, e, n, u), f.push(D);
          }
        return f;
      }
      function ar(r, e, n, o) {
        const u = Math.pow(2, o.z) * rs, l = [o.x * rs, o.y * rs], f = [];
        if (!r)
          return f;
        for (const S of r) {
          const D = [];
          for (const x of S) {
            const A = [x.x + l[0], x.y + l[1]];
            Ba(e, A), D.push(A);
          }
          f.push(D);
        }
        if (e[2] - e[0] <= u / 2) {
          (v = e)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
          for (const S of f)
            for (const D of S)
              gl(D, e, n, u);
        }
        var v;
        return f;
      }
      class lr {
        constructor(e, n) {
          this.type = Li, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (wo(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection")
              for (let u = 0; u < o.features.length; ++u) {
                const l = o.features[u].geometry.type;
                if (l === "Polygon" || l === "MultiPolygon")
                  return new lr(o, o.features[u].geometry);
              }
            else if (o.type === "Feature") {
              const u = o.geometry.type;
              if (u === "Polygon" || u === "MultiPolygon")
                return new lr(o, o.geometry);
            } else if (o.type === "Polygon" || o.type === "MultiPolygon")
              return new lr(o, o);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point")
              return function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = n.canonicalID();
                if (!f)
                  return !1;
                if (o.type === "Polygon") {
                  const v = bi(o.coordinates, l, f), S = ci(n.geometry(), u, l, f);
                  if (!Na(u, l))
                    return !1;
                  for (const D of S)
                    if (!Ds(D, v))
                      return !1;
                }
                if (o.type === "MultiPolygon") {
                  const v = Wt(o.coordinates, l, f), S = ci(n.geometry(), u, l, f);
                  if (!Na(u, l))
                    return !1;
                  for (const D of S)
                    if (!jh(D, v))
                      return !1;
                }
                return !0;
              }(e, this.geometries);
            if (e.geometryType() === "LineString")
              return function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], f = n.canonicalID();
                if (!f)
                  return !1;
                if (o.type === "Polygon") {
                  const v = bi(o.coordinates, l, f), S = ar(n.geometry(), u, l, f);
                  if (!Na(u, l))
                    return !1;
                  for (const D of S)
                    if (!Hl(D, v))
                      return !1;
                }
                if (o.type === "MultiPolygon") {
                  const v = Wt(o.coordinates, l, f), S = ar(n.geometry(), u, l, f);
                  if (!Na(u, l))
                    return !1;
                  for (const D of S)
                    if (!Xo(D, v))
                      return !1;
                }
                return !0;
              }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      const ti = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, Xr = 1 / 298.257223563, ql = Xr * (2 - Xr), Yr = Math.PI / 180;
      class Va {
        static fromTile(e, n, o) {
          const u = Math.PI * (1 - 2 * (e + 0.5) / Math.pow(2, n)), l = Math.atan(0.5 * (Math.exp(u) - Math.exp(-u))) / Yr;
          return new Va(l, o);
        }
        static get units() {
          return ti;
        }
        constructor(e, n) {
          if (e === void 0)
            throw new Error("No latitude given.");
          if (n && !ti[n])
            throw new Error(`Unknown unit ${n}. Use one of: ${Object.keys(ti).join(", ")}`);
          const o = 6378.137 * Yr * (n ? ti[n] : 1), u = Math.cos(e * Yr), l = 1 / (1 - ql * (1 - u * u)), f = Math.sqrt(l);
          this.kx = o * f * u, this.ky = o * f * l * (1 - ql);
        }
        distance(e, n) {
          const o = ks(e[0] - n[0]) * this.kx, u = (e[1] - n[1]) * this.ky;
          return Math.sqrt(o * o + u * u);
        }
        bearing(e, n) {
          const o = ks(n[0] - e[0]) * this.kx;
          return Math.atan2(o, (n[1] - e[1]) * this.ky) / Yr;
        }
        destination(e, n, o) {
          const u = o * Yr;
          return this.offset(e, Math.sin(u) * n, Math.cos(u) * n);
        }
        offset(e, n, o) {
          return [e[0] + n / this.kx, e[1] + o / this.ky];
        }
        lineDistance(e) {
          let n = 0;
          for (let o = 0; o < e.length - 1; o++)
            n += this.distance(e[o], e[o + 1]);
          return n;
        }
        area(e) {
          let n = 0;
          for (let o = 0; o < e.length; o++) {
            const u = e[o];
            for (let l = 0, f = u.length, v = f - 1; l < f; v = l++)
              n += ks(u[l][0] - u[v][0]) * (u[l][1] + u[v][1]) * (o ? -1 : 1);
          }
          return Math.abs(n) / 2 * this.kx * this.ky;
        }
        along(e, n) {
          let o = 0;
          if (n <= 0)
            return e[0];
          for (let u = 0; u < e.length - 1; u++) {
            const l = e[u], f = e[u + 1], v = this.distance(l, f);
            if (o += v, o > n)
              return bs(l, f, (n - (o - v)) / v);
          }
          return e[e.length - 1];
        }
        pointToSegmentDistance(e, n, o) {
          let [u, l] = n, f = ks(o[0] - u) * this.kx, v = (o[1] - l) * this.ky;
          if (f !== 0 || v !== 0) {
            const S = (ks(e[0] - u) * this.kx * f + (e[1] - l) * this.ky * v) / (f * f + v * v);
            S > 1 ? (u = o[0], l = o[1]) : S > 0 && (u += f / this.kx * S, l += v / this.ky * S);
          }
          return f = ks(e[0] - u) * this.kx, v = (e[1] - l) * this.ky, Math.sqrt(f * f + v * v);
        }
        pointOnLine(e, n) {
          let o = 1 / 0, u = e[0][0], l = e[0][1], f = 0, v = 0;
          for (let S = 0; S < e.length - 1; S++) {
            let D = e[S][0], x = e[S][1], A = ks(e[S + 1][0] - D) * this.kx, I = (e[S + 1][1] - x) * this.ky, M = 0;
            A === 0 && I === 0 || (M = (ks(n[0] - D) * this.kx * A + (n[1] - x) * this.ky * I) / (A * A + I * I), M > 1 ? (D = e[S + 1][0], x = e[S + 1][1]) : M > 0 && (D += A / this.kx * M, x += I / this.ky * M)), A = ks(n[0] - D) * this.kx, I = (n[1] - x) * this.ky;
            const C = A * A + I * I;
            C < o && (o = C, u = D, l = x, f = S, v = M);
          }
          return { point: [u, l], index: f, t: Math.max(0, Math.min(1, v)) };
        }
        lineSlice(e, n, o) {
          let u = this.pointOnLine(o, e), l = this.pointOnLine(o, n);
          if (u.index > l.index || u.index === l.index && u.t > l.t) {
            const D = u;
            u = l, l = D;
          }
          const f = [u.point], v = u.index + 1, S = l.index;
          !To(o[v], f[0]) && v <= S && f.push(o[v]);
          for (let D = v + 1; D <= S; D++)
            f.push(o[D]);
          return To(o[S], l.point) || f.push(l.point), f;
        }
        lineSliceAlong(e, n, o) {
          let u = 0;
          const l = [];
          for (let f = 0; f < o.length - 1; f++) {
            const v = o[f], S = o[f + 1], D = this.distance(v, S);
            if (u += D, u > e && l.length === 0 && l.push(bs(v, S, (e - (u - D)) / D)), u >= n)
              return l.push(bs(v, S, (n - (u - D)) / D)), l;
            u > e && l.push(S);
          }
          return l;
        }
        bufferPoint(e, n) {
          const o = n / this.ky, u = n / this.kx;
          return [e[0] - u, e[1] - o, e[0] + u, e[1] + o];
        }
        bufferBBox(e, n) {
          const o = n / this.ky, u = n / this.kx;
          return [e[0] - u, e[1] - o, e[2] + u, e[3] + o];
        }
        insideBBox(e, n) {
          return ks(e[0] - n[0]) >= 0 && ks(e[0] - n[2]) <= 0 && e[1] >= n[1] && e[1] <= n[3];
        }
      }
      function To(r, e) {
        return r[0] === e[0] && r[1] === e[1];
      }
      function bs(r, e, n) {
        const o = ks(e[0] - r[0]);
        return [r[0] + o * n, r[1] + (e[1] - r[1]) * n];
      }
      function ks(r) {
        for (; r < -180; )
          r += 360;
        for (; r > 180; )
          r -= 360;
        return r;
      }
      class Wl {
        constructor(e = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
          if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0)
            for (let o = (this.length >> 1) - 1; o >= 0; o--)
              this._down(o);
        }
        push(e) {
          this.data.push(e), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const e = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: n, compare: o } = this, u = n[e];
          for (; e > 0; ) {
            const l = e - 1 >> 1, f = n[l];
            if (o(u, f) >= 0)
              break;
            n[e] = f, e = l;
          }
          n[e] = u;
        }
        _down(e) {
          const { data: n, compare: o } = this, u = this.length >> 1, l = n[e];
          for (; e < u; ) {
            let f = 1 + (e << 1);
            const v = f + 1;
            if (v < this.length && o(n[v], n[f]) < 0 && (f = v), o(n[f], l) >= 0)
              break;
            n[e] = n[f], e = f;
          }
          n[e] = l;
        }
      }
      var Tt = 8192;
      function ma(r, e) {
        return e.dist - r.dist;
      }
      const Mo = 100, gs = 50;
      function Gh(r) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (e.length !== r.length)
          return !1;
        for (let n = 0; n < e.length; n++)
          if (e[n] !== r[n])
            return !1;
        return !0;
      }
      function Dr(r) {
        return r[1] - r[0] + 1;
      }
      function So(r, e) {
        const n = r[1] >= r[0] && r[1] < e;
        return n || console.warn("Distance Expression: Index is out of range"), n;
      }
      function Kr(r, e) {
        if (r[0] > r[1])
          return [null, null];
        const n = Dr(r);
        if (e) {
          if (n === 2)
            return [r, null];
          const o = Math.floor(n / 2);
          return [[r[0], r[0] + o], [r[0] + o, r[1]]];
        }
        {
          if (n === 1)
            return [r, null];
          const o = Math.floor(n / 2) - 1;
          return [[r[0], r[0] + o], [r[0] + o + 1, r[1]]];
        }
      }
      function Yo(r, e) {
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!So(e, r.length))
          return n;
        for (let o = e[0]; o <= e[1]; ++o)
          Ba(n, r[o]);
        return n;
      }
      function cr(r) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n = 0; n < r.length; ++n)
          for (let o = 0; o < r[n].length; ++o)
            Ba(e, r[n][o]);
        return e;
      }
      function Eo(r, e, n) {
        if (Gh(r) || Gh(e))
          return NaN;
        let o = 0, u = 0;
        return r[2] < e[0] && (o = e[0] - r[2]), r[0] > e[2] && (o = r[0] - e[2]), r[1] > e[3] && (u = r[1] - e[3]), r[3] < e[1] && (u = e[1] - r[3]), n.distance([0, 0], [o, u]);
      }
      function Zh(r) {
        return 360 * r - 180;
      }
      function Uc(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      function Ua(r, e) {
        const n = Math.pow(2, e.z), o = (r.y / Tt + e.y) / n;
        return [Zh((r.x / Tt + e.x) / n), Uc(o)];
      }
      function $l(r, e) {
        const n = [];
        for (let o = 0; o < r.length; ++o)
          n.push(Ua(r[o], e));
        return n;
      }
      function yl(r, e, n) {
        const o = n.pointOnLine(e, r).point;
        return n.distance(r, o);
      }
      function _a(r, e, n, o, u) {
        const l = n.slice(o[0], o[1] + 1);
        let f = 1 / 0;
        for (let v = e[0]; v <= e[1]; ++v)
          if ((f = Math.min(f, yl(r[v], l, u))) === 0)
            return 0;
        return f;
      }
      function ga(r, e, n, o, u) {
        const l = Math.min(u.pointToSegmentDistance(r, n, o), u.pointToSegmentDistance(e, n, o)), f = Math.min(u.pointToSegmentDistance(n, r, e), u.pointToSegmentDistance(o, r, e));
        return Math.min(l, f);
      }
      function Ao(r, e, n, o, u) {
        if (!So(e, r.length) || !So(o, n.length))
          return NaN;
        let l = 1 / 0;
        for (let f = e[0]; f < e[1]; ++f)
          for (let v = o[0]; v < o[1]; ++v) {
            if ($o(r[f], r[f + 1], n[v], n[v + 1]))
              return 0;
            l = Math.min(l, ga(r[f], r[f + 1], n[v], n[v + 1], u));
          }
        return l;
      }
      function Hh(r, e, n, o, u) {
        if (!So(e, r.length) || !So(o, n.length))
          return NaN;
        let l = 1 / 0;
        for (let f = e[0]; f <= e[1]; ++f)
          for (let v = o[0]; v <= o[1]; ++v)
            if ((l = Math.min(l, u.distance(r[f], n[v]))) === 0)
              return l;
        return l;
      }
      function td(r, e, n) {
        if (Ds(r, e, !0))
          return 0;
        let o = 1 / 0;
        for (const u of e) {
          const l = u.length;
          if (l < 2)
            return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (u[0] !== u[l - 1] && (o = Math.min(o, n.pointToSegmentDistance(r, u[l - 1], u[0]))) === 0 || (o = Math.min(o, yl(r, u, n))) === 0)
            return o;
        }
        return o;
      }
      function ja(r, e, n, o) {
        if (!So(e, r.length))
          return NaN;
        for (let l = e[0]; l <= e[1]; ++l)
          if (Ds(r[l], n, !0))
            return 0;
        let u = 1 / 0;
        for (let l = e[0]; l < e[1]; ++l)
          for (const f of n)
            for (let v = 0, S = f.length, D = S - 1; v < S; D = v++) {
              if ($o(r[l], r[l + 1], f[D], f[v]))
                return 0;
              u = Math.min(u, ga(r[l], r[l + 1], f[D], f[v], o));
            }
        return u;
      }
      function jc(r, e) {
        for (const n of r)
          for (let o = 0; o <= n.length - 1; ++o)
            if (Ds(n[o], e, !0))
              return !0;
        return !1;
      }
      function Gc(r, e, n, o = 1 / 0) {
        const u = cr(r), l = cr(e);
        if (o !== 1 / 0 && Eo(u, l, n) >= o)
          return o;
        if (Na(u, l)) {
          if (jc(r, e))
            return 0;
        } else if (jc(e, r))
          return 0;
        let f = o;
        for (const v of r)
          for (let S = 0, D = v.length, x = D - 1; S < D; x = S++)
            for (const A of e)
              for (let I = 0, M = A.length, C = M - 1; I < M; C = I++) {
                if ($o(v[x], v[S], A[C], A[I]))
                  return 0;
                f = Math.min(f, ga(v[x], v[S], A[C], A[I], n));
              }
        return f;
      }
      function hr(r, e, n, o, u, l, f) {
        if (l === null || f === null)
          return;
        const v = Eo(Yo(o, l), Yo(u, f), n);
        v < e && r.push({ dist: v, range1: l, range2: f });
      }
      function Zc(r, e, n, o, u = 1 / 0) {
        let l = Math.min(o.distance(r[0], n[0][0]), u);
        if (l === 0)
          return l;
        const f = new Wl([{ dist: 0, range1: [0, r.length - 1], range2: [0, 0] }], ma), v = e ? gs : Mo, S = cr(n);
        for (; f.length; ) {
          const D = f.pop();
          if (D.dist >= l)
            continue;
          const x = D.range1;
          if (Dr(x) <= v) {
            if (!So(x, r.length))
              return NaN;
            if (e) {
              const A = ja(r, x, n, o);
              if ((l = Math.min(l, A)) === 0)
                return l;
            } else
              for (let A = x[0]; A <= x[1]; ++A) {
                const I = td(r[A], n, o);
                if ((l = Math.min(l, I)) === 0)
                  return l;
              }
          } else {
            const A = Kr(x, e);
            if (A[0] !== null) {
              const I = Eo(Yo(r, A[0]), S, o);
              I < l && f.push({ dist: I, range1: A[0], range2: [0, 0] });
            }
            if (A[1] !== null) {
              const I = Eo(Yo(r, A[1]), S, o);
              I < l && f.push({ dist: I, range1: A[1], range2: [0, 0] });
            }
          }
        }
        return l;
      }
      function Hc(r, e, n, o, u, l = 1 / 0) {
        let f = Math.min(l, u.distance(r[0], n[0]));
        if (f === 0)
          return f;
        const v = new Wl([{ dist: 0, range1: [0, r.length - 1], range2: [0, n.length - 1] }], ma), S = e ? gs : Mo, D = o ? gs : Mo;
        for (; v.length; ) {
          const x = v.pop();
          if (x.dist >= f)
            continue;
          const A = x.range1, I = x.range2;
          if (Dr(A) <= S && Dr(I) <= D) {
            if (!So(A, r.length) || !So(I, n.length))
              return NaN;
            if (e && o ? f = Math.min(f, Ao(r, A, n, I, u)) : e || o ? e && !o ? f = Math.min(f, _a(n, I, r, A, u)) : !e && o && (f = Math.min(f, _a(r, A, n, I, u))) : f = Math.min(f, Hh(r, A, n, I, u)), f === 0)
              return f;
          } else {
            const M = Kr(A, e), C = Kr(I, o);
            hr(v, f, u, r, n, M[0], C[0]), hr(v, f, u, r, n, M[0], C[1]), hr(v, f, u, r, n, M[1], C[0]), hr(v, f, u, r, n, M[1], C[1]);
          }
        }
        return f;
      }
      function xr(r, e, n, o, u = 1 / 0) {
        let l = u;
        const f = Yo(r, [0, r.length - 1]);
        for (const v of n)
          if (!(l !== 1 / 0 && Eo(f, Yo(v, [0, v.length - 1]), o) >= l) && (l = Math.min(l, Hc(r, e, v, !0, o, l)), l === 0))
            return l;
        return l;
      }
      function Ko(r, e, n, o, u = 1 / 0) {
        let l = u;
        const f = Yo(r, [0, r.length - 1]);
        for (const v of n) {
          if (l !== 1 / 0 && Eo(f, cr(v), o) >= l)
            continue;
          const S = Zc(r, e, v, o, l);
          if (isNaN(S))
            return S;
          if ((l = Math.min(l, S)) === 0)
            return l;
        }
        return l;
      }
      function Xl(r) {
        return r === "Point" || r === "MultiPoint" || r === "LineString" || r === "MultiLineString" || r === "Polygon" || r === "MultiPolygon";
      }
      class Jr {
        constructor(e, n) {
          this.type = Ot, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`);
          if (wo(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection") {
              for (let u = 0; u < o.features.length; ++u)
                if (Xl(o.features[u].geometry.type))
                  return new Jr(o, o.features[u].geometry);
            } else if (o.type === "Feature") {
              if (Xl(o.geometry.type))
                return new Jr(o, o.geometry);
            } else if (Xl(o.type))
              return new Jr(o, o);
          }
          return n.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(e) {
          const n = e.geometry(), o = e.canonicalID();
          if (n != null && o != null) {
            if (e.geometryType() === "Point")
              return function(u, l, f) {
                const v = [];
                for (const D of u)
                  for (const x of D)
                    v.push(Ua(x, l));
                const S = new Va(v[0][1], "meters");
                return f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString" ? Hc(v, !1, f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", S) : f.type === "MultiLineString" ? xr(v, !1, f.coordinates, S) : f.type === "Polygon" || f.type === "MultiPolygon" ? Ko(v, !1, f.type === "Polygon" ? [f.coordinates] : f.coordinates, S) : null;
              }(n, o, this.geometries);
            if (e.geometryType() === "LineString")
              return function(u, l, f) {
                const v = [];
                for (const D of u) {
                  const x = [];
                  for (const A of D)
                    x.push(Ua(A, l));
                  v.push(x);
                }
                const S = new Va(v[0][0][1], "meters");
                if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString")
                  return xr(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", v, S);
                if (f.type === "MultiLineString") {
                  let D = 1 / 0;
                  for (let x = 0; x < f.coordinates.length; x++) {
                    const A = xr(f.coordinates[x], !0, v, S, D);
                    if (isNaN(A))
                      return A;
                    if ((D = Math.min(D, A)) === 0)
                      return D;
                  }
                  return D;
                }
                if (f.type === "Polygon" || f.type === "MultiPolygon") {
                  let D = 1 / 0;
                  for (let x = 0; x < v.length; x++) {
                    const A = Ko(v[x], !0, f.type === "Polygon" ? [f.coordinates] : f.coordinates, S, D);
                    if (isNaN(A))
                      return A;
                    if ((D = Math.min(D, A)) === 0)
                      return D;
                  }
                  return D;
                }
                return null;
              }(n, o, this.geometries);
            if (e.geometryType() === "Polygon")
              return function(u, l, f) {
                const v = [];
                for (const D of function(x, A) {
                  const I = x.length;
                  if (I <= 1)
                    return [x];
                  const M = [];
                  let C, k;
                  for (let V = 0; V < I; V++) {
                    const U = Qu(x[V]);
                    U !== 0 && (x[V].area = Math.abs(U), k === void 0 && (k = U < 0), k === U < 0 ? (C && M.push(C), C = [x[V]]) : C.push(x[V]));
                  }
                  return C && M.push(C), M;
                }(u)) {
                  const x = [];
                  for (let A = 0; A < D.length; ++A)
                    x.push($l(D[A], l));
                  v.push(x);
                }
                const S = new Va(v[0][0][0][1], "meters");
                if (f.type === "Point" || f.type === "MultiPoint" || f.type === "LineString")
                  return Ko(f.type === "Point" ? [f.coordinates] : f.coordinates, f.type === "LineString", v, S);
                if (f.type === "MultiLineString") {
                  let D = 1 / 0;
                  for (let x = 0; x < f.coordinates.length; x++) {
                    const A = Ko(f.coordinates[x], !0, v, S, D);
                    if (isNaN(A))
                      return A;
                    if ((D = Math.min(D, A)) === 0)
                      return D;
                  }
                  return D;
                }
                return f.type === "Polygon" || f.type === "MultiPolygon" ? function(D, x, A) {
                  let I = 1 / 0;
                  for (const M of D)
                    for (const C of x) {
                      const k = Gc(M, C, A, I);
                      if (isNaN(k))
                        return k;
                      if ((I = Math.min(I, k)) === 0)
                        return I;
                    }
                  return I;
                }(f.type === "Polygon" ? [f.coordinates] : f.coordinates, v, S) : null;
              }(n, o, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else
            console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      function Yl(r, e) {
        switch (r) {
          case "string":
            return Ir(e);
          case "number":
            return +e;
          case "boolean":
            return !!e;
          case "color":
            return ki.parse(e);
          case "formatted":
            return Dn.fromString(Ir(e));
          case "resolvedImage":
            return ss.build(Ir(e));
        }
        return e;
      }
      function Kl(r, e, n, o) {
        return o !== void 0 && (r = o * Math.round(r / o)), e !== void 0 && r < e && (r = e), n !== void 0 && r > n && (r = n), r;
      }
      class ya {
        constructor(e, n, o) {
          this.type = e, this.key = n, this.scope = o;
        }
        static parse(e, n) {
          let o = n.expectedType;
          if (o == null && (o = Ai), e.length < 2 || e.length > 3)
            return n.error("Invalid number of arguments for 'config' expression.");
          const u = n.parse(e[1], 1);
          if (!(u instanceof Lr))
            return n.error("Key name of 'config' expression must be a string literal.");
          if (e.length >= 3) {
            const l = n.parse(e[2], 2);
            return l instanceof Lr ? new ya(o, Ir(u.value), Ir(l.value)) : n.error("Scope of 'config' expression must be a string literal.");
          }
          return new ya(o, Ir(u.value));
        }
        evaluate(e) {
          const n = [this.key, this.scope, e.scope].filter(Boolean).join(""), o = e.getConfig(n);
          if (!o)
            return null;
          const { type: u, value: l, values: f, minValue: v, maxValue: S, stepValue: D } = o, x = o.default.evaluate(e);
          let A = x;
          if (l) {
            const I = e.scope;
            e.scope = (I || "").split("").slice(1).join(""), A = l.evaluate(e), e.scope = I;
          }
          return u && (A = Yl(u, A)), A === void 0 || v === void 0 && S === void 0 && D === void 0 || (typeof A == "number" ? A = Kl(A, v, S, D) : Array.isArray(A) && (A = A.map((I) => typeof I == "number" ? Kl(I, v, S, D) : I))), l !== void 0 && A !== void 0 && f && !f.includes(A) && (A = x, u && (A = Yl(u, A))), (u && u !== this.type || A !== void 0 && vn(A) !== this.type) && (A = Yl(this.type.kind, A)), A;
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["config", this.key];
          return this.scope && e.concat(this.key), e;
        }
      }
      function ro(r) {
        if (r instanceof or && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof lr || r instanceof Jr)
          return !1;
        let e = !0;
        return r.eachChild((n) => {
          e && !ro(n) && (e = !1);
        }), e;
      }
      function xl(r) {
        if (r instanceof or && r.name === "feature-state")
          return !1;
        let e = !0;
        return r.eachChild((n) => {
          e && !xl(n) && (e = !1);
        }), e;
      }
      function kr(r) {
        if (r instanceof ya)
          return /* @__PURE__ */ new Set([r.key]);
        let e = /* @__PURE__ */ new Set();
        return r.eachChild((n) => {
          e = /* @__PURE__ */ new Set([...e, ...kr(n)]);
        }), e;
      }
      function oo(r, e) {
        if (r instanceof or && e.indexOf(r.name) >= 0)
          return !1;
        let n = !0;
        return r.eachChild((o) => {
          n && !oo(o, e) && (n = !1);
        }), n;
      }
      class Jo {
        constructor(e, n) {
          this.type = n.type, this.name = e, this.boundExpression = n;
        }
        static parse(e, n) {
          if (e.length !== 2 || typeof e[1] != "string")
            return n.error("'var' expression requires exactly one string literal argument.");
          const o = e[1];
          return n.scope.has(o) ? new Jo(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      class Jl {
        constructor(e, n = [], o, u = new Cn(), l = [], f, v) {
          this.registry = e, this.path = n, this.key = n.map((S) => typeof S == "string" ? `['${S}']` : `[${S}]`).join(""), this.scope = u, this.errors = l, this.expectedType = o, this._scope = f, this.options = v;
        }
        parse(e, n, o, u, l = {}) {
          return n || o ? this.concat(n, null, o, u)._parse(e, l) : this._parse(e, l);
        }
        parseObjectValue(e, n, o, u, l, f = {}) {
          return this.concat(n, o, u, l)._parse(e, f);
        }
        _parse(e, n) {
          function o(u, l, f) {
            return f === "assert" ? new zr(l, [u]) : f === "coerce" ? new so(l, [u]) : u;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const u = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
            if (u) {
              let l = u.parse(e, this);
              if (!l)
                return null;
              if (this.expectedType) {
                const f = this.expectedType, v = l.type;
                if (f.kind !== "string" && f.kind !== "number" && f.kind !== "boolean" && f.kind !== "object" && f.kind !== "array" || v.kind !== "value")
                  if (f.kind !== "color" && f.kind !== "formatted" && f.kind !== "resolvedImage" || v.kind !== "value" && v.kind !== "string") {
                    if (this.checkSubtype(f, v))
                      return null;
                  } else
                    l = o(l, f, n.typeAnnotation || "coerce");
                else
                  l = o(l, f, n.typeAnnotation || "assert");
              }
              if (!(l instanceof Lr) && l.type.kind !== "resolvedImage" && vl(l)) {
                const f = new Fa(this._scope, this.options);
                try {
                  l = new Lr(l.type, l.evaluate(f));
                } catch (v) {
                  return this.error(v.message), null;
                }
              }
              return l;
            }
            return so.parse(["to-array", e], this);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, n, o, u) {
          let l = typeof e == "number" ? this.path.concat(e) : this.path;
          l = typeof n == "string" ? l.concat(n) : l;
          const f = u ? this.scope.concat(u) : this.scope;
          return new Jl(this.registry, l, o || null, f, this.errors, this._scope, this.options);
        }
        error(e, ...n) {
          const o = `${this.key}${n.map((u) => `[${u}]`).join("")}`;
          this.errors.push(new ns(o, e));
        }
        checkSubtype(e, n) {
          const o = ua(e, n);
          return o && this.error(o), o;
        }
      }
      var Qr = Jl;
      function vl(r) {
        if (r instanceof Jo)
          return vl(r.boundExpression);
        if (r instanceof or && r.name === "error" || r instanceof pl || r instanceof lr || r instanceof Jr || r instanceof ya)
          return !1;
        const e = r instanceof so || r instanceof zr;
        let n = !0;
        return r.eachChild((o) => {
          n = e ? n && vl(o) : n && o instanceof Lr;
        }), !!n && ro(r) && oo(r, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
      }
      function ao(r, e) {
        const n = r.length - 1;
        let o, u, l = 0, f = n, v = 0;
        for (; l <= f; )
          if (v = Math.floor((l + f) / 2), o = r[v], u = r[v + 1], o <= e) {
            if (v === n || e < u)
              return v;
            l = v + 1;
          } else {
            if (!(o > e))
              throw new qn("Input is not a number.");
            f = v - 1;
          }
        return 0;
      }
      class Ti {
        constructor(e, n, o) {
          this.type = e, this.input = n, this.labels = [], this.outputs = [];
          for (const [u, l] of o)
            this.labels.push(u), this.outputs.push(l);
        }
        static parse(e, n) {
          if (e.length - 1 < 4)
            return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0)
            return n.error("Expected an even number of arguments.");
          const o = n.parse(e[1], 1, Ot);
          if (!o)
            return null;
          const u = [];
          let l = null;
          n.expectedType && n.expectedType.kind !== "value" && (l = n.expectedType);
          for (let f = 1; f < e.length; f += 2) {
            const v = f === 1 ? -1 / 0 : e[f], S = e[f + 1], D = f, x = f + 1;
            if (typeof v != "number")
              return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', D);
            if (u.length && u[u.length - 1][0] >= v)
              return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', D);
            const A = n.parse(S, x, l);
            if (!A)
              return null;
            l = l || A.type, u.push([v, A]);
          }
          return new Ti(l, o, u);
        }
        evaluate(e) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1)
            return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0])
            return o[0].evaluate(e);
          const l = n.length;
          return u >= n[l - 1] ? o[l - 1].evaluate(e) : o[ao(n, u)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs)
            e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["step", this.input.serialize()];
          for (let n = 0; n < this.labels.length; n++)
            n > 0 && e.push(this.labels[n]), e.push(this.outputs[n].serialize());
          return e;
        }
      }
      const qh = 0.95047, bl = 1.08883, Ga = 4 / 29, Qo = 6 / 29, qc = 3 * Qo * Qo, gn = Qo * Qo * Qo, Wh = Math.PI / 180, $h = 180 / Math.PI;
      function Ql(r) {
        return r > gn ? Math.pow(r, 1 / 3) : r / qc + Ga;
      }
      function ec(r) {
        return r > Qo ? r * r * r : qc * (r - Ga);
      }
      function tc(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Wc(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function $c(r) {
        const e = Wc(r.r), n = Wc(r.g), o = Wc(r.b), u = Ql((0.4124564 * e + 0.3575761 * n + 0.1804375 * o) / qh), l = Ql((0.2126729 * e + 0.7151522 * n + 0.072175 * o) / 1);
        return { l: 116 * l - 16, a: 500 * (u - l), b: 200 * (l - Ql((0.0193339 * e + 0.119192 * n + 0.9503041 * o) / bl)), alpha: r.a };
      }
      function Xc(r) {
        let e = (r.l + 16) / 116, n = isNaN(r.a) ? e : e + r.a / 500, o = isNaN(r.b) ? e : e - r.b / 200;
        return e = 1 * ec(e), n = qh * ec(n), o = bl * ec(o), new ki(tc(3.2404542 * n - 1.5371385 * e - 0.4985314 * o), tc(-0.969266 * n + 1.8760108 * e + 0.041556 * o), tc(0.0556434 * n - 0.2040259 * e + 1.0572252 * o), r.alpha);
      }
      function id(r, e, n) {
        const o = e - r;
        return r + n * (o > 180 || o < -180 ? o - 360 * Math.round(o / 360) : o);
      }
      const p = { forward: $c, reverse: Xc, interpolate: function(r, e, n) {
        return { l: ei(r.l, e.l, n), a: ei(r.a, e.a, n), b: ei(r.b, e.b, n), alpha: ei(r.alpha, e.alpha, n) };
      } }, P = { forward: function(r) {
        const { l: e, a: n, b: o } = $c(r), u = Math.atan2(o, n) * $h;
        return { h: u < 0 ? u + 360 : u, c: Math.sqrt(n * n + o * o), l: e, alpha: r.a };
      }, reverse: function(r) {
        const e = r.h * Wh, n = r.c;
        return Xc({ l: r.l, a: Math.cos(e) * n, b: Math.sin(e) * n, alpha: r.alpha });
      }, interpolate: function(r, e, n) {
        return { h: id(r.h, e.h, n), c: ei(r.c, e.c, n), l: ei(r.l, e.l, n), alpha: ei(r.alpha, e.alpha, n) };
      } };
      var B = Object.freeze({ __proto__: null, hcl: P, lab: p });
      class X {
        constructor(e, n, o, u, l, f) {
          this.type = e, this.operator = n, this.interpolation = o, this.input = u, this.dynamicStops = l, this.labels = [], this.outputs = [];
          for (const [v, S] of f)
            this.labels.push(v), this.outputs.push(S);
        }
        static interpolationFactor(e, n, o, u) {
          let l = 0;
          if (e.name === "exponential")
            l = ne(n, e.base, o, u);
          else if (e.name === "linear")
            l = ne(n, 1, o, u);
          else if (e.name === "cubic-bezier") {
            const f = e.controlPoints;
            l = new Us(f[0], f[1], f[2], f[3]).solve(ne(n, 1, o, u));
          }
          return l;
        }
        static parse(e, n) {
          let [o, u, l, ...f] = e;
          if (!Array.isArray(u) || u.length === 0)
            return n.error("Expected an interpolation type expression.", 1);
          if (u[0] === "linear")
            u = { name: "linear" };
          else if (u[0] === "exponential") {
            const D = u[1];
            if (typeof D != "number")
              return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            u = { name: "exponential", base: D };
          } else {
            if (u[0] !== "cubic-bezier")
              return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
            {
              const D = u.slice(1);
              if (D.length !== 4 || D.some((x) => typeof x != "number" || x < 0 || x > 1))
                return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              u = { name: "cubic-bezier", controlPoints: D };
            }
          }
          if (e.length - 1 < 3)
            return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length - 1 > 3 && (e.length - 1) % 2 != 0)
            return n.error("Expected an even number of arguments.");
          if (l = n.parse(l, 2, Ot), !l)
            return null;
          const v = [];
          let S = null;
          if (o === "interpolate-hcl" || o === "interpolate-lab" ? S = ms : n.expectedType && n.expectedType.kind !== "value" && (S = n.expectedType), e.length - 1 == 3) {
            const D = n.parse(f[0], 3, Ai);
            return D ? new X(S, o, u, l, D, v) : null;
          }
          for (let D = 0; D < f.length; D += 2) {
            const x = f[D], A = f[D + 1], I = D + 3, M = D + 4;
            if (typeof x != "number")
              return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
            if (v.length && v[v.length - 1][0] >= x)
              return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', I);
            const C = n.parse(A, M, S);
            if (!C)
              return null;
            S = S || C.type, v.push([x, C]);
          }
          return S.kind === "number" || S.kind === "color" || S.kind === "array" && S.itemType.kind === "number" && typeof S.N == "number" ? new X(S, o, u, l, null, v) : n.error(`Type ${un(S)} is not interpolatable.`);
        }
        evaluate(e) {
          let n = this.labels, o = this.outputs;
          if (this.dynamicStops) {
            const x = this.dynamicStops.evaluate(e);
            if (x.length % 2 != 0)
              throw new qn("Expected an even number of arguments.");
            n = [], o = [];
            for (let A = 0; A < x.length; A += 2) {
              const I = x[A], M = new Lr(Ot, x[A + 1]);
              if (typeof I != "number")
                throw new qn('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
              if (n.length && n[n.length - 1] >= I)
                throw new qn('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
              n.push(I), o.push(M);
            }
            if (n.length === 0)
              throw new qn("Expected at least one input/output pair.");
          }
          if (n.length === 1)
            return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0])
            return o[0].evaluate(e);
          const l = n.length;
          if (u >= n[l - 1])
            return o[l - 1].evaluate(e);
          const f = ao(n, u), v = X.interpolationFactor(this.interpolation, u, n[f], n[f + 1]), S = o[f].evaluate(e), D = o[f + 1].evaluate(e);
          return this.operator === "interpolate" ? Oi[this.type.kind.toLowerCase()](S, D, v) : this.operator === "interpolate-hcl" ? P.reverse(P.interpolate(P.forward(S), P.forward(D), v)) : p.reverse(p.interpolate(p.forward(S), p.forward(D), v));
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs)
            e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          let e;
          e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const n = [this.operator, e, this.input.serialize()];
          if (this.dynamicStops)
            n.push(this.dynamicStops.serialize());
          else
            for (let o = 0; o < this.labels.length; o++)
              n.push(this.labels[o], this.outputs[o].serialize());
          return n;
        }
      }
      function ne(r, e, n, o) {
        const u = o - n, l = r - n;
        return u === 0 ? 0 : e === 1 ? l / u : (Math.pow(e, l) - 1) / (Math.pow(e, u) - 1);
      }
      class ye {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expectected at least one argument.");
          let o = null;
          const u = n.expectedType;
          u && u.kind !== "value" && (o = u);
          const l = [];
          for (const v of e.slice(1)) {
            const S = n.parse(v, 1 + l.length, o, void 0, { typeAnnotation: "omit" });
            if (!S)
              return null;
            o = o || S.type, l.push(S);
          }
          const f = u && l.some((v) => ua(u, v.type));
          return new ye(f ? Ai : o, l);
        }
        evaluate(e) {
          let n, o = null, u = 0;
          for (const l of this.args) {
            if (u++, o = l.evaluate(e), o && o instanceof ss && !o.available && (n || (n = o), o = null, u === this.args.length))
              return n;
            if (o !== null)
              break;
          }
          return o;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["coalesce"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      class We {
        constructor(e, n) {
          this.type = n.type, this.bindings = [].concat(e), this.result = n;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const n of this.bindings)
            e(n[1]);
          e(this.result);
        }
        static parse(e, n) {
          if (e.length < 4)
            return n.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const o = [];
          for (let l = 1; l < e.length - 1; l += 2) {
            const f = e[l];
            if (typeof f != "string")
              return n.error(`Expected string, but found ${typeof f} instead.`, l);
            if (/[^a-zA-Z0-9_]/.test(f))
              return n.error("Variable names must contain only alphanumeric characters or '_'.", l);
            const v = n.parse(e[l + 1], l + 1);
            if (!v)
              return null;
            o.push([f, v]);
          }
          const u = n.parse(e[e.length - 1], e.length - 1, n.expectedType, o);
          return u ? new We(o, u) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const e = ["let"];
          for (const [n, o] of this.bindings)
            e.push(n, o.serialize());
          return e.push(this.result.serialize()), e;
        }
      }
      class at {
        constructor(e, n, o) {
          this.type = e, this.index = n, this.input = o;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ot), u = n.parse(e[2], 2, Ss(n.expectedType || Ai));
          return o && u ? new at(u.type.itemType, o, u) : null;
        }
        evaluate(e) {
          const n = this.index.evaluate(e), o = this.input.evaluate(e);
          if (n < 0)
            throw new qn(`Array index out of bounds: ${n} < 0.`);
          if (n > o.length - 1)
            throw new qn(`Array index out of bounds: ${n} > ${o.length - 1}.`);
          if (n === Math.floor(n))
            return o[n];
          const u = Math.floor(n), l = Math.ceil(n), f = o[u], v = o[l];
          if (typeof f != "number" || typeof v != "number")
            throw new qn(`Cannot interpolate between non-number values at index ${n}.`);
          const S = n - u;
          return f * (1 - S) + v * S;
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      class ft {
        constructor(e, n) {
          this.type = Li, this.needle = e, this.haystack = n;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ai);
          return o && u ? Zl(o.type, [Li, Fi, Ot, ha, Ai]) ? new ft(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${un(o.type)} instead`) : null;
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (o == null)
            return !1;
          if (!da(n, ["boolean", "string", "number", "null"]))
            throw new qn(`Expected first argument to be of type boolean, string, number or null, but found ${un(vn(n))} instead.`);
          if (!da(o, ["string", "array"]))
            throw new qn(`Expected second argument to be of type array or string, but found ${un(vn(o))} instead.`);
          return o.indexOf(n) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class Rt {
        constructor(e, n, o) {
          this.type = Ot, this.needle = e, this.haystack = n, this.fromIndex = o;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5)
            return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ai);
          if (!o || !u)
            return null;
          if (!Zl(o.type, [Li, Fi, Ot, ha, Ai]))
            return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${un(o.type)} instead`);
          if (e.length === 4) {
            const l = n.parse(e[3], 3, Ot);
            return l ? new Rt(o, u, l) : null;
          }
          return new Rt(o, u);
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (!da(n, ["boolean", "string", "number", "null"]))
            throw new qn(`Expected first argument to be of type boolean, string, number or null, but found ${un(vn(n))} instead.`);
          if (!da(o, ["string", "array"]))
            throw new qn(`Expected second argument to be of type array or string, but found ${un(vn(o))} instead.`);
          if (this.fromIndex) {
            const u = this.fromIndex.evaluate(e);
            return o.indexOf(n, u);
          }
          return o.indexOf(n);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const e = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class ii {
        constructor(e, n, o, u, l, f) {
          this.inputType = e, this.type = n, this.input = o, this.cases = u, this.outputs = l, this.otherwise = f;
        }
        static parse(e, n) {
          if (e.length < 5)
            return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1)
            return n.error("Expected an even number of arguments.");
          let o, u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const l = {}, f = [];
          for (let D = 2; D < e.length - 1; D += 2) {
            let x = e[D];
            const A = e[D + 1];
            Array.isArray(x) || (x = [x]);
            const I = n.concat(D);
            if (x.length === 0)
              return I.error("Expected at least one branch label.");
            for (const C of x) {
              if (typeof C != "number" && typeof C != "string")
                return I.error("Branch labels must be numbers or strings.");
              if (typeof C == "number" && Math.abs(C) > Number.MAX_SAFE_INTEGER)
                return I.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof C == "number" && Math.floor(C) !== C)
                return I.error("Numeric branch labels must be integer values.");
              if (o) {
                if (I.checkSubtype(o, vn(C)))
                  return null;
              } else
                o = vn(C);
              if (l[String(C)] !== void 0)
                return I.error("Branch labels must be unique.");
              l[String(C)] = f.length;
            }
            const M = n.parse(A, D, u);
            if (!M)
              return null;
            u = u || M.type, f.push(M);
          }
          const v = n.parse(e[1], 1, Ai);
          if (!v)
            return null;
          const S = n.parse(e[e.length - 1], e.length - 1, u);
          return S ? v.type.kind !== "value" && n.concat(1).checkSubtype(o, v.type) ? null : new ii(o, u, v, l, f, S) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          return (vn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["match", this.input.serialize()], n = Object.keys(this.cases).sort(), o = [], u = {};
          for (const f of n) {
            const v = u[this.cases[f]];
            v === void 0 ? (u[this.cases[f]] = o.length, o.push([this.cases[f], [f]])) : o[v][1].push(f);
          }
          const l = (f) => this.inputType.kind === "number" ? Number(f) : f;
          for (const [f, v] of o)
            e.push(v.length === 1 ? l(v[0]) : v.map(l)), e.push(this.outputs[f].serialize());
          return e.push(this.otherwise.serialize()), e;
        }
      }
      class Ci {
        constructor(e, n, o) {
          this.type = e, this.branches = n, this.otherwise = o;
        }
        static parse(e, n) {
          if (e.length < 4)
            return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0)
            return n.error("Expected an odd number of arguments.");
          let o;
          n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
          const u = [];
          for (let f = 1; f < e.length - 1; f += 2) {
            const v = n.parse(e[f], f, Li);
            if (!v)
              return null;
            const S = n.parse(e[f + 1], f + 1, o);
            if (!S)
              return null;
            u.push([v, S]), o = o || S.type;
          }
          const l = n.parse(e[e.length - 1], e.length - 1, o);
          return l ? new Ci(o, u, l) : null;
        }
        evaluate(e) {
          for (const [n, o] of this.branches)
            if (n.evaluate(e))
              return o.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [n, o] of this.branches)
            e(n), e(o);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["case"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      class Wi {
        constructor(e, n, o, u) {
          this.type = e, this.input = n, this.beginIndex = o, this.endIndex = u;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5)
            return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ot);
          if (!o || !u)
            return null;
          if (!Zl(o.type, [Ss(Ai), Fi, Ai]))
            return n.error(`Expected first argument to be of type array or string, but found ${un(o.type)} instead`);
          if (e.length === 4) {
            const l = n.parse(e[3], 3, Ot);
            return l ? new Wi(o.type, o, u, l) : null;
          }
          return new Wi(o.type, o, u);
        }
        evaluate(e) {
          const n = this.input.evaluate(e), o = this.beginIndex.evaluate(e);
          if (!da(n, ["string", "array"]))
            throw new qn(`Expected first argument to be of type array or string, but found ${un(vn(n))} instead.`);
          if (this.endIndex) {
            const u = this.endIndex.evaluate(e);
            return n.slice(o, u);
          }
          return n.slice(o);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const e = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      function Hs(r, e) {
        return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function ws(r, e, n, o) {
        return o.compare(e, n) === 0;
      }
      function Rs(r, e, n) {
        const o = r !== "==" && r !== "!=";
        return class bw {
          constructor(l, f, v) {
            this.type = Li, this.lhs = l, this.rhs = f, this.collator = v, this.hasUntypedArgument = l.type.kind === "value" || f.type.kind === "value";
          }
          static parse(l, f) {
            if (l.length !== 3 && l.length !== 4)
              return f.error("Expected two or three arguments.");
            const v = l[0];
            let S = f.parse(l[1], 1, Ai);
            if (!S)
              return null;
            if (!Hs(v, S.type))
              return f.concat(1).error(`"${v}" comparisons are not supported for type '${un(S.type)}'.`);
            let D = f.parse(l[2], 2, Ai);
            if (!D)
              return null;
            if (!Hs(v, D.type))
              return f.concat(2).error(`"${v}" comparisons are not supported for type '${un(D.type)}'.`);
            if (S.type.kind !== D.type.kind && S.type.kind !== "value" && D.type.kind !== "value")
              return f.error(`Cannot compare types '${un(S.type)}' and '${un(D.type)}'.`);
            o && (S.type.kind === "value" && D.type.kind !== "value" ? S = new zr(D.type, [S]) : S.type.kind !== "value" && D.type.kind === "value" && (D = new zr(S.type, [D])));
            let x = null;
            if (l.length === 4) {
              if (S.type.kind !== "string" && D.type.kind !== "string" && S.type.kind !== "value" && D.type.kind !== "value")
                return f.error("Cannot use collator to compare non-string types.");
              if (x = f.parse(l[3], 3, _s), !x)
                return null;
            }
            return new bw(S, D, x);
          }
          evaluate(l) {
            const f = this.lhs.evaluate(l), v = this.rhs.evaluate(l);
            if (o && this.hasUntypedArgument) {
              const S = vn(f), D = vn(v);
              if (S.kind !== D.kind || S.kind !== "string" && S.kind !== "number")
                throw new qn(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${S.kind}, ${D.kind}) instead.`);
            }
            if (this.collator && !o && this.hasUntypedArgument) {
              const S = vn(f), D = vn(v);
              if (S.kind !== "string" || D.kind !== "string")
                return e(l, f, v);
            }
            return this.collator ? n(l, f, v, this.collator.evaluate(l)) : e(l, f, v);
          }
          eachChild(l) {
            l(this.lhs), l(this.rhs), this.collator && l(this.collator);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            const l = [r];
            return this.eachChild((f) => {
              l.push(f.serialize());
            }), l;
          }
        };
      }
      const ur = Rs("==", function(r, e, n) {
        return e === n;
      }, ws), Za = Rs("!=", function(r, e, n) {
        return e !== n;
      }, function(r, e, n, o) {
        return !ws(0, e, n, o);
      }), nd = Rs("<", function(r, e, n) {
        return e < n;
      }, function(r, e, n, o) {
        return o.compare(e, n) < 0;
      }), sd = Rs(">", function(r, e, n) {
        return e > n;
      }, function(r, e, n, o) {
        return o.compare(e, n) > 0;
      }), rd = Rs("<=", function(r, e, n) {
        return e <= n;
      }, function(r, e, n, o) {
        return o.compare(e, n) <= 0;
      }), Xh = Rs(">=", function(r, e, n) {
        return e >= n;
      }, function(r, e, n, o) {
        return o.compare(e, n) >= 0;
      });
      class wl {
        constructor(e, n, o, u, l, f) {
          this.type = Fi, this.number = e, this.locale = n, this.currency = o, this.unit = u, this.minFractionDigits = l, this.maxFractionDigits = f;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error("Expected two arguments.");
          const o = n.parse(e[1], 1, Ot);
          if (!o)
            return null;
          const u = e[2];
          if (typeof u != "object" || Array.isArray(u))
            return n.error("NumberFormat options argument must be an object.");
          let l = null;
          if (u.locale && (l = n.parseObjectValue(u.locale, 2, "locale", Fi), !l))
            return null;
          let f = null;
          if (u.currency && (f = n.parseObjectValue(u.currency, 2, "currency", Fi), !f))
            return null;
          let v = null;
          if (u.unit && (v = n.parseObjectValue(u.unit, 2, "unit", Fi), !v))
            return null;
          let S = null;
          if (u["min-fraction-digits"] && (S = n.parseObjectValue(u["min-fraction-digits"], 2, "min-fraction-digits", Ot), !S))
            return null;
          let D = null;
          return u["max-fraction-digits"] && (D = n.parseObjectValue(u["max-fraction-digits"], 2, "max-fraction-digits", Ot), !D) ? null : new wl(o, l, f, v, S, D);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e];
        }
      }
      class ic {
        constructor(e) {
          this.type = Ot, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1);
          return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${un(o.type)} instead.`) : new ic(o) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          if (typeof n == "string" || Array.isArray(n))
            return n.length;
          throw new qn(`Expected value to be of type string or array, but found ${un(vn(n))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["length"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      function es(r) {
        return function() {
          r = 1831565813 + (r |= 0) | 0;
          let e = Math.imul(r ^ r >>> 15, 1 | r);
          return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
        };
      }
      const Po = { "==": ur, "!=": Za, ">": sd, "<": nd, ">=": Xh, "<=": rd, array: zr, at, boolean: zr, case: Ci, coalesce: ye, collator: pl, format: Es, image: Oa, in: ft, "index-of": Rt, interpolate: X, "interpolate-hcl": X, "interpolate-lab": X, length: ic, let: We, literal: Lr, match: ii, number: zr, "number-format": wl, object: zr, slice: Wi, step: Ti, string: zr, "to-boolean": so, "to-color": so, "to-number": so, "to-string": so, var: Jo, within: lr, distance: Jr, config: ya };
      function Yh(r, [e, n, o, u]) {
        e = e.evaluate(r), n = n.evaluate(r), o = o.evaluate(r);
        const l = u ? u.evaluate(r) : 1, f = fa(e, n, o, l);
        if (f)
          throw new qn(f);
        return new ki(e / 255 * l, n / 255 * l, o / 255 * l, l);
      }
      function Kh(r, [e, n, o, u]) {
        e = e.evaluate(r), n = n.evaluate(r), o = o.evaluate(r);
        const l = u ? u.evaluate(r) : 1, f = function(D, x, A, I) {
          return typeof D == "number" && D >= 0 && D <= 360 ? typeof x == "number" && x >= 0 && x <= 100 && typeof A == "number" && A >= 0 && A <= 100 ? I === void 0 || typeof I == "number" && I >= 0 && I <= 1 ? null : `Invalid hsla value [${[D, x, A, I].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof I == "number" ? [D, x, A, I] : [D, x, A]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof I == "number" ? [D, x, A, I] : [D, x, A]).join(", ")}]: 'h' must be between 0 and 360.`;
        }(e, n, o, l);
        if (f)
          throw new qn(f);
        const v = `hsla(${e}, ${n}%, ${o}%, ${l})`, S = ki.parse(v);
        if (!S)
          throw new qn(`Failed to parse HSLA color: ${v}`);
        return S;
      }
      function Yc(r, e) {
        return r in e;
      }
      function Ha(r, e) {
        const n = e[r];
        return n === void 0 ? null : n;
      }
      function vr(r) {
        return { type: r };
      }
      function Kc(r) {
        return { result: "success", value: r };
      }
      function xa(r) {
        return { result: "error", value: r };
      }
      function od(r, e) {
        return !!r && !!r.parameters && r.parameters.indexOf(e) > -1;
      }
      function nc(r) {
        return r["property-type"] === "data-driven";
      }
      function Jh(r) {
        return od(r.expression, "measure-light");
      }
      function qf(r) {
        return od(r.expression, "zoom");
      }
      function ad(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Qh(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function Wf(r) {
        return r;
      }
      function $f(r, e) {
        const n = e.type === "color", o = r.stops && typeof r.stops[0][0] == "object", u = o || !(o || r.property !== void 0), l = r.type || (ad(e) ? "exponential" : "interval");
        if (n && ((r = Bi({}, r)).stops && (r.stops = r.stops.map((D) => [D[0], ki.parse(D[1])])), r.default = ki.parse(r.default ? r.default : e.default)), r.colorSpace && r.colorSpace !== "rgb" && !B[r.colorSpace])
          throw new Error(`Unknown color space: ${r.colorSpace}`);
        let f, v, S;
        if (l === "exponential")
          f = ld;
        else if (l === "interval")
          f = Xf;
        else if (l === "categorical") {
          f = Jm, v = /* @__PURE__ */ Object.create(null);
          for (const D of r.stops)
            v[D[0]] = D[1];
          S = typeof r.stops[0][0];
        } else {
          if (l !== "identity")
            throw new Error(`Unknown function type "${l}"`);
          f = eu;
        }
        if (o) {
          const D = {}, x = [];
          for (let M = 0; M < r.stops.length; M++) {
            const C = r.stops[M], k = C[0].zoom;
            D[k] === void 0 && (D[k] = { zoom: k, type: r.type, property: r.property, default: r.default, stops: [] }, x.push(k)), D[k].stops.push([C[0].value, C[1]]);
          }
          const A = [];
          for (const M of x)
            A.push([D[M].zoom, $f(D[M], e)]);
          const I = { name: "linear" };
          return { kind: "composite", interpolationType: I, interpolationFactor: X.interpolationFactor.bind(void 0, I), zoomStops: A.map((M) => M[0]), evaluate: ({ zoom: M }, C) => ld({ stops: A, base: r.base }, e, M).evaluate(M, C) };
        }
        if (u) {
          const D = l === "exponential" ? { name: "exponential", base: r.base !== void 0 ? r.base : 1 } : null;
          return { kind: "camera", interpolationType: D, interpolationFactor: X.interpolationFactor.bind(void 0, D), zoomStops: r.stops.map((x) => x[0]), evaluate: ({ zoom: x }) => f(r, e, x, v, S) };
        }
        return { kind: "source", evaluate(D, x) {
          const A = x && x.properties ? x.properties[r.property] : void 0;
          return A === void 0 ? Jc(r.default, e.default) : f(r, e, A, v, S);
        } };
      }
      function Jc(r, e, n) {
        return r !== void 0 ? r : e !== void 0 ? e : n !== void 0 ? n : void 0;
      }
      function Jm(r, e, n, o, u) {
        return Jc(typeof n === u ? o[n] : void 0, r.default, e.default);
      }
      function Xf(r, e, n) {
        if (qo(n) !== "number")
          return Jc(r.default, e.default);
        const o = r.stops.length;
        if (o === 1 || n <= r.stops[0][0])
          return r.stops[0][1];
        if (n >= r.stops[o - 1][0])
          return r.stops[o - 1][1];
        const u = ao(r.stops.map((l) => l[0]), n);
        return r.stops[u][1];
      }
      function ld(r, e, n) {
        const o = r.base !== void 0 ? r.base : 1;
        if (qo(n) !== "number")
          return Jc(r.default, e.default);
        const u = r.stops.length;
        if (u === 1 || n <= r.stops[0][0])
          return r.stops[0][1];
        if (n >= r.stops[u - 1][0])
          return r.stops[u - 1][1];
        const l = ao(r.stops.map((x) => x[0]), n), f = function(x, A, I, M) {
          const C = M - I, k = x - I;
          return C === 0 ? 0 : A === 1 ? k / C : (Math.pow(A, k) - 1) / (Math.pow(A, C) - 1);
        }(n, o, r.stops[l][0], r.stops[l + 1][0]), v = r.stops[l][1], S = r.stops[l + 1][1];
        let D = Oi[e.type] || Wf;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          const x = B[r.colorSpace];
          D = (A, I) => x.reverse(x.interpolate(x.forward(A), x.forward(I), f));
        }
        return typeof v.evaluate == "function" ? { evaluate(...x) {
          const A = v.evaluate.apply(void 0, x), I = S.evaluate.apply(void 0, x);
          if (A !== void 0 && I !== void 0)
            return D(A, I, f);
        } } : D(v, S, f);
      }
      function eu(r, e, n) {
        return e.type === "color" ? n = ki.parse(n) : e.type === "formatted" ? n = Dn.fromString(n.toString()) : e.type === "resolvedImage" ? n = ss.build(n.toString()) : qo(n) === e.type || e.type === "enum" && e.values[n] || (n = void 0), Jc(n, r.default, e.default);
      }
      or.register(Po, { error: [{ kind: "error" }, [Fi], (r, [e]) => {
        throw new qn(e.evaluate(r));
      }], typeof: [Fi, [Ai], (r, [e]) => un(vn(e.evaluate(r)))], "to-rgba": [Ss(Ot, 4), [ms], (r, [e]) => e.evaluate(r).toRenderColor(null).toArray()], "to-hsla": [Ss(Ot, 4), [ms], (r, [e]) => e.evaluate(r).toRenderColor(null).toHslaArray()], rgb: [ms, [Ot, Ot, Ot], Yh], rgba: [ms, [Ot, Ot, Ot, Ot], Yh], hsl: [ms, [Ot, Ot, Ot], Kh], hsla: [ms, [Ot, Ot, Ot, Ot], Kh], has: { type: Li, overloads: [[[Fi], (r, [e]) => Yc(e.evaluate(r), r.properties())], [[Fi, bo], (r, [e, n]) => Yc(e.evaluate(r), n.evaluate(r))]] }, get: { type: Ai, overloads: [[[Fi], (r, [e]) => Ha(e.evaluate(r), r.properties())], [[Fi, bo], (r, [e, n]) => Ha(e.evaluate(r), n.evaluate(r))]] }, "feature-state": [Ai, [Fi], (r, [e]) => Ha(e.evaluate(r), r.featureState || {})], properties: [bo, [], (r) => r.properties()], "geometry-type": [Fi, [], (r) => r.geometryType()], id: [Ai, [], (r) => r.id()], zoom: [Ot, [], (r) => r.globals.zoom], pitch: [Ot, [], (r) => r.globals.pitch || 0], "distance-from-center": [Ot, [], (r) => r.distanceFromCenter()], "measure-light": [Ot, [Fi], (r, [e]) => r.measureLight(e.evaluate(r))], "heatmap-density": [Ot, [], (r) => r.globals.heatmapDensity || 0], "line-progress": [Ot, [], (r) => r.globals.lineProgress || 0], "raster-value": [Ot, [], (r) => r.globals.rasterValue || 0], "raster-particle-speed": [Ot, [], (r) => r.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Ot, [], (r) => r.globals.skyRadialProgress || 0], accumulated: [Ai, [], (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated], "+": [Ot, vr(Ot), (r, e) => {
        let n = 0;
        for (const o of e)
          n += o.evaluate(r);
        return n;
      }], "*": [Ot, vr(Ot), (r, e) => {
        let n = 1;
        for (const o of e)
          n *= o.evaluate(r);
        return n;
      }], "-": { type: Ot, overloads: [[[Ot, Ot], (r, [e, n]) => e.evaluate(r) - n.evaluate(r)], [[Ot], (r, [e]) => -e.evaluate(r)]] }, "/": [Ot, [Ot, Ot], (r, [e, n]) => e.evaluate(r) / n.evaluate(r)], "%": [Ot, [Ot, Ot], (r, [e, n]) => e.evaluate(r) % n.evaluate(r)], ln2: [Ot, [], () => Math.LN2], pi: [Ot, [], () => Math.PI], e: [Ot, [], () => Math.E], "^": [Ot, [Ot, Ot], (r, [e, n]) => Math.pow(e.evaluate(r), n.evaluate(r))], sqrt: [Ot, [Ot], (r, [e]) => Math.sqrt(e.evaluate(r))], log10: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10], ln: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r))], log2: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2], sin: [Ot, [Ot], (r, [e]) => Math.sin(e.evaluate(r))], cos: [Ot, [Ot], (r, [e]) => Math.cos(e.evaluate(r))], tan: [Ot, [Ot], (r, [e]) => Math.tan(e.evaluate(r))], asin: [Ot, [Ot], (r, [e]) => Math.asin(e.evaluate(r))], acos: [Ot, [Ot], (r, [e]) => Math.acos(e.evaluate(r))], atan: [Ot, [Ot], (r, [e]) => Math.atan(e.evaluate(r))], min: [Ot, vr(Ot), (r, e) => Math.min(...e.map((n) => n.evaluate(r)))], max: [Ot, vr(Ot), (r, e) => Math.max(...e.map((n) => n.evaluate(r)))], abs: [Ot, [Ot], (r, [e]) => Math.abs(e.evaluate(r))], round: [Ot, [Ot], (r, [e]) => {
        const n = e.evaluate(r);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [Ot, [Ot], (r, [e]) => Math.floor(e.evaluate(r))], ceil: [Ot, [Ot], (r, [e]) => Math.ceil(e.evaluate(r))], "filter-==": [Li, [Fi, Ai], (r, [e, n]) => r.properties()[e.value] === n.value], "filter-id-==": [Li, [Ai], (r, [e]) => r.id() === e.value], "filter-type-==": [Li, [Fi], (r, [e]) => r.geometryType() === e.value], "filter-<": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o < u;
      }], "filter-id-<": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n < o;
      }], "filter->": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o > u;
      }], "filter-id->": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n > o;
      }], "filter-<=": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o <= u;
      }], "filter-id-<=": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n <= o;
      }], "filter->=": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o >= u;
      }], "filter-id->=": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n >= o;
      }], "filter-has": [Li, [Ai], (r, [e]) => e.value in r.properties()], "filter-has-id": [Li, [], (r) => r.id() !== null && r.id() !== void 0], "filter-type-in": [Li, [Ss(Fi)], (r, [e]) => e.value.indexOf(r.geometryType()) >= 0], "filter-id-in": [Li, [Ss(Ai)], (r, [e]) => e.value.indexOf(r.id()) >= 0], "filter-in-small": [Li, [Fi, Ss(Ai)], (r, [e, n]) => n.value.indexOf(r.properties()[e.value]) >= 0], "filter-in-large": [Li, [Fi, Ss(Ai)], (r, [e, n]) => function(o, u, l, f) {
        for (; l <= f; ) {
          const v = l + f >> 1;
          if (u[v] === o)
            return !0;
          u[v] > o ? f = v - 1 : l = v + 1;
        }
        return !1;
      }(r.properties()[e.value], n.value, 0, n.value.length - 1)], all: { type: Li, overloads: [[[Li, Li], (r, [e, n]) => e.evaluate(r) && n.evaluate(r)], [vr(Li), (r, e) => {
        for (const n of e)
          if (!n.evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: Li, overloads: [[[Li, Li], (r, [e, n]) => e.evaluate(r) || n.evaluate(r)], [vr(Li), (r, e) => {
        for (const n of e)
          if (n.evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [Li, [Li], (r, [e]) => !e.evaluate(r)], "is-supported-script": [Li, [Fi], (r, [e]) => {
        const n = r.globals && r.globals.isSupportedScript;
        return !n || n(e.evaluate(r));
      }], upcase: [Fi, [Fi], (r, [e]) => e.evaluate(r).toUpperCase()], downcase: [Fi, [Fi], (r, [e]) => e.evaluate(r).toLowerCase()], concat: [Fi, vr(Ai), (r, e) => e.map((n) => Ir(n.evaluate(r))).join("")], "resolved-locale": [Fi, [_s], (r, [e]) => e.evaluate(r).resolvedLocale()], random: [Ot, [Ot, Ot, Ai], (r, e) => {
        const [n, o, u] = e.map((f) => f.evaluate(r));
        if (n > o || n === o)
          return n;
        let l;
        if (typeof u == "string")
          l = function(f) {
            let v = 0;
            if (f.length === 0)
              return v;
            for (let S = 0; S < f.length; S++)
              v = (v << 5) - v + f.charCodeAt(S), v |= 0;
            return v;
          }(u);
        else {
          if (typeof u != "number")
            throw new qn(`Invalid seed input: ${u}`);
          l = u;
        }
        return n + es(l)() * (o - n);
      }] });
      class cd {
        constructor(e, n, o, u) {
          this.expression = e, this._warningHistory = {}, this._evaluator = new Fa(o, u), this._defaultValue = n ? function(l) {
            return l.type === "color" && (Qh(l.default) || Array.isArray(l.default)) ? new ki(0, 0, 0, 0) : l.type === "color" ? ki.parse(l.default) || null : l.default === void 0 ? null : l.default;
          }(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this.configDependencies = kr(e);
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, f, v, S) {
          return this._evaluator.globals = e, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u || null, this._evaluator.availableImages = l || null, this._evaluator.formattedSection = f, this._evaluator.featureTileCoord = v || null, this._evaluator.featureDistanceData = S || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, n, o, u, l, f, v, S) {
          this._evaluator.globals = e, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u || null, this._evaluator.availableImages = l || null, this._evaluator.formattedSection = f || null, this._evaluator.featureTileCoord = v || null, this._evaluator.featureDistanceData = S || null;
          try {
            const D = this.expression.evaluate(this._evaluator);
            if (D == null || typeof D == "number" && D != D)
              return this._defaultValue;
            if (this._enumValues && !(D in this._enumValues))
              throw new qn(`Expected value to be one of ${Object.keys(this._enumValues).map((x) => JSON.stringify(x)).join(", ")}, but found ${JSON.stringify(D)} instead.`);
            return D;
          } catch (D) {
            return this._warningHistory[D.message] || (this._warningHistory[D.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${D.message}`)), this._defaultValue;
          }
        }
      }
      function tu(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Po;
      }
      function Qc(r, e, n, o) {
        const u = new Qr(Po, [], e ? function(f) {
          const v = { color: ms, string: Fi, number: Ot, enum: Fi, boolean: Li, formatted: Js, resolvedImage: Ho };
          return f.type === "array" ? Ss(v[f.value] || Ai, f.length) : v[f.type];
        }(e) : void 0, void 0, void 0, n, o), l = u.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return l ? Kc(new cd(l, e, n, o)) : xa(u.errors);
      }
      class hd {
        constructor(e, n, o, u) {
          this.kind = e, this._styleExpression = n, this.isLightConstant = o, this.isLineProgressConstant = u, this.isStateDependent = e !== "constant" && !xl(n.expression), this.configDependencies = kr(n.expression);
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, f) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, l, f);
        }
        evaluate(e, n, o, u, l, f) {
          return this._styleExpression.evaluate(e, n, o, u, l, f);
        }
      }
      class sc {
        constructor(e, n, o, u, l, f) {
          this.kind = e, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = e !== "camera" && !xl(n.expression), this.isLightConstant = l, this.isLineProgressConstant = f, this.configDependencies = kr(n.expression), this.interpolationType = u;
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, f) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, l, f);
        }
        evaluate(e, n, o, u, l, f) {
          return this._styleExpression.evaluate(e, n, o, u, l, f);
        }
        interpolationFactor(e, n, o) {
          return this.interpolationType ? X.interpolationFactor(this.interpolationType, e, n, o) : 0;
        }
      }
      function ud(r, e, n, o) {
        if ((r = Qc(r, e, n, o)).result === "error")
          return r;
        const u = r.value.expression, l = ro(u);
        if (!l && !nc(e))
          return xa([new ns("", "data expressions not supported")]);
        const f = oo(u, ["zoom", "pitch", "distance-from-center"]);
        if (!f && !qf(e))
          return xa([new ns("", "zoom expressions not supported")]);
        const v = oo(u, ["measure-light"]);
        if (!v && !Jh(e))
          return xa([new ns("", "measure-light expression not supported")]);
        const S = oo(u, ["line-progress"]);
        if (!S && !function(A) {
          return od(A.expression, "line-progress");
        }(e))
          return xa([new ns("", "line-progress expression not supported")]);
        const D = e.expression && e.expression.relaxZoomRestriction, x = nu(u);
        return x || f || D ? x instanceof ns ? xa([x]) : x instanceof X && !ad(e) ? xa([new ns("", '"interpolate" expressions cannot be used with this property')]) : Kc(x ? new sc(l && S ? "camera" : "composite", r.value, x.labels, x instanceof X ? x.interpolation : void 0, v, S) : new hd(l && S ? "constant" : "source", r.value, v, S)) : xa([new ns("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class iu {
        constructor(e, n) {
          this._parameters = e, this._specification = n, Bi(this, $f(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new iu(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function nu(r) {
        let e = null;
        if (r instanceof We)
          e = nu(r.result);
        else if (r instanceof ye) {
          for (const n of r.args)
            if (e = nu(n), e)
              break;
        } else
          (r instanceof Ti || r instanceof X) && r.input instanceof or && r.input.name === "zoom" && (e = r);
        return e instanceof ns || r.eachChild((n) => {
          const o = nu(n);
          o instanceof ns ? e = o : e && o && e !== o && (e = new ns("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      var dd, fd, Qm = function() {
        if (fd)
          return dd;
        fd = 1, dd = e;
        var r = 3;
        function e(n, o, u) {
          var l = this.cells = [];
          if (n instanceof ArrayBuffer) {
            this.arrayBuffer = n;
            var f = new Int32Array(this.arrayBuffer);
            n = f[0], this.d = (o = f[1]) + 2 * (u = f[2]);
            for (var v = 0; v < this.d * this.d; v++) {
              var S = f[r + v], D = f[r + v + 1];
              l.push(S === D ? null : f.subarray(S, D));
            }
            var x = f[r + l.length + 1];
            this.keys = f.subarray(f[r + l.length], x), this.bboxes = f.subarray(x), this.insert = this._insertReadonly;
          } else {
            this.d = o + 2 * u;
            for (var A = 0; A < this.d * this.d; A++)
              l.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = o, this.extent = n, this.padding = u, this.scale = o / n, this.uid = 0;
          var I = u / o * n;
          this.min = -I, this.max = n + I;
        }
        return e.prototype.insert = function(n, o, u, l, f) {
          this._forEachCell(o, u, l, f, this._insertCell, this.uid++), this.keys.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(l), this.bboxes.push(f);
        }, e.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, e.prototype._insertCell = function(n, o, u, l, f, v) {
          this.cells[f].push(v);
        }, e.prototype.query = function(n, o, u, l, f) {
          var v = this.min, S = this.max;
          if (n <= v && o <= v && S <= u && S <= l && !f)
            return Array.prototype.slice.call(this.keys);
          var D = [];
          return this._forEachCell(n, o, u, l, this._queryCell, D, {}, f), D;
        }, e.prototype._queryCell = function(n, o, u, l, f, v, S, D) {
          var x = this.cells[f];
          if (x !== null)
            for (var A = this.keys, I = this.bboxes, M = 0; M < x.length; M++) {
              var C = x[M];
              if (S[C] === void 0) {
                var k = 4 * C;
                (D ? D(I[k + 0], I[k + 1], I[k + 2], I[k + 3]) : n <= I[k + 2] && o <= I[k + 3] && u >= I[k + 0] && l >= I[k + 1]) ? (S[C] = !0, v.push(A[C])) : S[C] = !1;
              }
            }
        }, e.prototype._forEachCell = function(n, o, u, l, f, v, S, D) {
          for (var x = this._convertToCellCoord(n), A = this._convertToCellCoord(o), I = this._convertToCellCoord(u), M = this._convertToCellCoord(l), C = x; C <= I; C++)
            for (var k = A; k <= M; k++) {
              var V = this.d * k + C;
              if ((!D || D(this._convertFromCellCoord(C), this._convertFromCellCoord(k), this._convertFromCellCoord(C + 1), this._convertFromCellCoord(k + 1))) && f.call(this, n, o, u, l, V, v, S, D))
                return;
            }
        }, e.prototype._convertFromCellCoord = function(n) {
          return (n - this.padding) / this.scale;
        }, e.prototype._convertToCellCoord = function(n) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(n * this.scale) + this.padding));
        }, e.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var n = this.cells, o = r + this.cells.length + 1 + 1, u = 0, l = 0; l < this.cells.length; l++)
            u += this.cells[l].length;
          var f = new Int32Array(o + u + this.keys.length + this.bboxes.length);
          f[0] = this.extent, f[1] = this.n, f[2] = this.padding;
          for (var v = o, S = 0; S < n.length; S++) {
            var D = n[S];
            f[r + S] = v, f.set(D, v), v += D.length;
          }
          return f[r + n.length] = v, f.set(this.keys, v), f[r + n.length + 1] = v += this.keys.length, f.set(this.bboxes, v), v += this.bboxes.length, f.buffer;
        }, dd;
      }(), rc = O(Qm);
      const eh = {};
      function Ft(r, e, n = {}) {
        Object.defineProperty(r, "_classRegistryKey", { value: e, writable: !1 }), eh[e] = { klass: r, omit: n.omit || [] };
      }
      Ft(Object, "Object"), rc.serialize = function(r, e) {
        const n = r.toArrayBuffer();
        return e && e.add(n), { buffer: n };
      }, rc.deserialize = function(r) {
        return new rc(r.buffer);
      }, Object.defineProperty(rc, "name", { value: "Grid" }), Ft(rc, "Grid"), typeof DOMMatrix < "u" && Ft(DOMMatrix, "DOMMatrix"), Ft(ki, "Color"), Ft(Error, "Error"), Ft(Dn, "Formatted"), Ft(dl, "FormattedSection"), Ft(jo, "AJAXError"), Ft(ss, "ResolvedImage"), Ft(iu, "StylePropertyFunction"), Ft(cd, "StyleExpression", { omit: ["_evaluator"] }), Ft(rr, "ImageIdWithOptions"), Ft(sc, "ZoomDependentExpression"), Ft(hd, "ZoomConstantExpression"), Ft(or, "CompoundExpression", { omit: ["_evaluate"] });
      for (const r in Po)
        eh[Po[r]._classRegistryKey] || Ft(Po[r], `Expression${r}`);
      function pd(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function Yf(r) {
        return self.ImageBitmap && r instanceof ImageBitmap;
      }
      function lo(r, e) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (pd(r) || Yf(r))
          return e && e.add(r), r;
        if (ArrayBuffer.isView(r))
          return e && e.add(r.buffer), r;
        if (r instanceof ImageData)
          return e && e.add(r.data.buffer), r;
        if (Array.isArray(r)) {
          const n = [];
          for (const o of r)
            n.push(lo(o, e));
          return n;
        }
        if (r instanceof Map) {
          const n = { $name: "Map" };
          for (const [o, u] of r.entries())
            n[o] = lo(u);
          return n;
        }
        if (r instanceof Set) {
          const n = { $name: "Set" };
          let o = 0;
          for (const u of r.values())
            n[++o] = lo(u);
          return n;
        }
        if (typeof r == "object") {
          const n = r.constructor, o = n._classRegistryKey;
          if (!o)
            throw new Error(`Can't serialize object of unregistered class "${o}".`);
          const u = n.serialize ? n.serialize(r, e) : {};
          if (!n.serialize) {
            for (const l in r)
              r.hasOwnProperty(l) && (eh[o].omit.indexOf(l) >= 0 || (u[l] = lo(r[l], e)));
            r instanceof Error && (u.message = r.message);
          }
          if (u.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return o !== "Object" && (u.$name = o), u;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function Tl(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || pd(r) || Yf(r) || ArrayBuffer.isView(r) || r instanceof ImageData)
          return r;
        if (Array.isArray(r))
          return r.map(Tl);
        if (typeof r == "object") {
          const e = r.$name || "Object";
          if (e === "Map") {
            const u = /* @__PURE__ */ new Map();
            for (const l of Object.keys(r))
              l !== "$name" && u.set(l, Tl(r[l]));
            return u;
          }
          if (e === "Set") {
            const u = /* @__PURE__ */ new Set();
            for (const l of Object.keys(r))
              l !== "$name" && u.add(Tl(r[l]));
            return u;
          }
          const { klass: n } = eh[e];
          if (!n)
            throw new Error(`Can't deserialize unregistered class "${e}".`);
          if (n.deserialize)
            return n.deserialize(r);
          const o = Object.create(n.prototype);
          for (const u of Object.keys(r))
            u !== "$name" && (o[u] = Tl(r[u]));
          return o;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      const Zt = { "Latin-1 Supplement": (r) => r >= 128 && r <= 255, Arabic: (r) => r >= 1536 && r <= 1791, "Arabic Supplement": (r) => r >= 1872 && r <= 1919, "Arabic Extended-A": (r) => r >= 2208 && r <= 2303, "Hangul Jamo": (r) => r >= 4352 && r <= 4607, "Unified Canadian Aboriginal Syllabics": (r) => r >= 5120 && r <= 5759, Khmer: (r) => r >= 6016 && r <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (r) => r >= 6320 && r <= 6399, "General Punctuation": (r) => r >= 8192 && r <= 8303, "Letterlike Symbols": (r) => r >= 8448 && r <= 8527, "Number Forms": (r) => r >= 8528 && r <= 8591, "Miscellaneous Technical": (r) => r >= 8960 && r <= 9215, "Control Pictures": (r) => r >= 9216 && r <= 9279, "Optical Character Recognition": (r) => r >= 9280 && r <= 9311, "Enclosed Alphanumerics": (r) => r >= 9312 && r <= 9471, "Geometric Shapes": (r) => r >= 9632 && r <= 9727, "Miscellaneous Symbols": (r) => r >= 9728 && r <= 9983, "Miscellaneous Symbols and Arrows": (r) => r >= 11008 && r <= 11263, "CJK Radicals Supplement": (r) => r >= 11904 && r <= 12031, "Kangxi Radicals": (r) => r >= 12032 && r <= 12255, "Ideographic Description Characters": (r) => r >= 12272 && r <= 12287, "CJK Symbols and Punctuation": (r) => r >= 12288 && r <= 12351, Hiragana: (r) => r >= 12352 && r <= 12447, Katakana: (r) => r >= 12448 && r <= 12543, Bopomofo: (r) => r >= 12544 && r <= 12591, "Hangul Compatibility Jamo": (r) => r >= 12592 && r <= 12687, Kanbun: (r) => r >= 12688 && r <= 12703, "Bopomofo Extended": (r) => r >= 12704 && r <= 12735, "CJK Strokes": (r) => r >= 12736 && r <= 12783, "Katakana Phonetic Extensions": (r) => r >= 12784 && r <= 12799, "Enclosed CJK Letters and Months": (r) => r >= 12800 && r <= 13055, "CJK Compatibility": (r) => r >= 13056 && r <= 13311, "CJK Unified Ideographs Extension A": (r) => r >= 13312 && r <= 19903, "Yijing Hexagram Symbols": (r) => r >= 19904 && r <= 19967, "CJK Unified Ideographs": (r) => r >= 19968 && r <= 40959, "Yi Syllables": (r) => r >= 40960 && r <= 42127, "Yi Radicals": (r) => r >= 42128 && r <= 42191, "Hangul Jamo Extended-A": (r) => r >= 43360 && r <= 43391, "Hangul Syllables": (r) => r >= 44032 && r <= 55215, "Hangul Jamo Extended-B": (r) => r >= 55216 && r <= 55295, "Private Use Area": (r) => r >= 57344 && r <= 63743, "CJK Compatibility Ideographs": (r) => r >= 63744 && r <= 64255, "Arabic Presentation Forms-A": (r) => r >= 64336 && r <= 65023, "Vertical Forms": (r) => r >= 65040 && r <= 65055, "CJK Compatibility Forms": (r) => r >= 65072 && r <= 65103, "Small Form Variants": (r) => r >= 65104 && r <= 65135, "Arabic Presentation Forms-B": (r) => r >= 65136 && r <= 65279, "Halfwidth and Fullwidth Forms": (r) => r >= 65280 && r <= 65519, Osage: (r) => r >= 66736 && r <= 66815, "CJK Unified Ideographs Extension B": (r) => r >= 131072 && r <= 173791 };
      function md(r) {
        for (const e of r)
          if (su(e.charCodeAt(0)))
            return !0;
        return !1;
      }
      function Kf(r) {
        for (const e of r)
          if (!Jf(e.charCodeAt(0)))
            return !1;
        return !0;
      }
      function Jf(r) {
        return !(Zt.Arabic(r) || Zt["Arabic Supplement"](r) || Zt["Arabic Extended-A"](r) || Zt["Arabic Presentation Forms-A"](r) || Zt["Arabic Presentation Forms-B"](r));
      }
      function su(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(Zt["Bopomofo Extended"](r) || Zt.Bopomofo(r) || Zt["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || Zt["CJK Compatibility Ideographs"](r) || Zt["CJK Compatibility"](r) || Zt["CJK Radicals Supplement"](r) || Zt["CJK Strokes"](r) || !(!Zt["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || Zt["CJK Unified Ideographs Extension A"](r) || Zt["CJK Unified Ideographs"](r) || Zt["Enclosed CJK Letters and Months"](r) || Zt["Hangul Compatibility Jamo"](r) || Zt["Hangul Jamo Extended-A"](r) || Zt["Hangul Jamo Extended-B"](r) || Zt["Hangul Jamo"](r) || Zt["Hangul Syllables"](r) || Zt.Hiragana(r) || Zt["Ideographic Description Characters"](r) || Zt.Kanbun(r) || Zt["Kangxi Radicals"](r) || Zt["Katakana Phonetic Extensions"](r) || Zt.Katakana(r) && r !== 12540 || !(!Zt["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!Zt["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || Zt["Unified Canadian Aboriginal Syllabics"](r) || Zt["Unified Canadian Aboriginal Syllabics Extended"](r) || Zt["Vertical Forms"](r) || Zt["Yijing Hexagram Symbols"](r) || Zt["Yi Syllables"](r) || Zt["Yi Radicals"](r))));
      }
      function _d(r) {
        return !(su(r) || function(e) {
          return !!(Zt["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || Zt["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || Zt["Letterlike Symbols"](e) || Zt["Number Forms"](e) || Zt["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || Zt["Control Pictures"](e) && e !== 9251 || Zt["Optical Character Recognition"](e) || Zt["Enclosed Alphanumerics"](e) || Zt["Geometric Shapes"](e) || Zt["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || Zt["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Zt["CJK Symbols and Punctuation"](e) || Zt.Katakana(e) || Zt["Private Use Area"](e) || Zt["CJK Compatibility Forms"](e) || Zt["Small Form Variants"](e) || Zt["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(r));
      }
      function ru(r) {
        return r >= 1424 && r <= 2303 || Zt["Arabic Presentation Forms-A"](r) || Zt["Arabic Presentation Forms-B"](r);
      }
      function gd(r, e) {
        return !(!e && ru(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || Zt.Khmer(r));
      }
      function Qf(r) {
        for (const e of r)
          if (ru(e.charCodeAt(0)))
            return !0;
        return !1;
      }
      const yd = "deferred", ea = "loading", xd = "loaded";
      let vd = null, br = "unavailable", qa = null;
      const th = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (br = "error"), vd && vd(r);
      };
      function ou() {
        oc.fire(new Pr("pluginStateChange", { pluginStatus: br, pluginURL: qa }));
      }
      const oc = new Zo(), au = function() {
        return br;
      }, ep = function() {
        if (br !== yd || !qa)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        br = ea, ou(), qa && no({ url: qa }, (r) => {
          r ? th(r) : (br = xd, ou());
        });
      }, co = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => br === xd || co.applyArabicShaping != null, isLoading: () => br === ea, setState(r) {
        br = r.pluginStatus, qa = r.pluginURL;
      }, isParsed: () => co.applyArabicShaping != null && co.processBidirectionalText != null && co.processStyledBidirectionalText != null, getPluginURL: () => qa };
      class Tn {
        constructor(e, n) {
          this.zoom = e, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.transition = n.transition, this.pitch = n.pitch, this.brightness = n.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(e) {
          return function(n, o) {
            for (const u of n)
              if (!gd(u.charCodeAt(0), o))
                return !1;
            return !0;
          }(e, co.isLoaded());
        }
      }
      class ac {
        constructor(e, n, o, u) {
          this.property = e, this.value = n, this.expression = function(l, f, v, S) {
            if (Qh(l))
              return new iu(l, f);
            if (tu(l) || Array.isArray(l) && l.length > 0) {
              const D = ud(l, f, v, S);
              if (D.result === "error")
                throw new Error(D.value.map((x) => `${x.key}: ${x.message}`).join(", "));
              return D.value;
            }
            {
              let D = l;
              return typeof l == "string" && f.type === "color" && (D = ki.parse(l)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => D };
            }
          }(n === void 0 ? e.specification.default : n, e.specification, o, u);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, n, o) {
          return this.property.possiblyEvaluate(this, e, n, o);
        }
      }
      class lu {
        constructor(e, n, o) {
          this.property = e, this.value = new ac(e, void 0, n, o);
        }
        transitioned(e, n) {
          return new Ml(this.property, this.value, n, Pn({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new Ml(this.property, this.value, null, {}, 0);
        }
      }
      class ih {
        constructor(e, n, o) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = n, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(e) {
          return Ys(this._values[e].value.value);
        }
        setValue(e, n) {
          this._values.hasOwnProperty(e) || (this._values[e] = new lu(this._values[e].property, this._scope, this._options)), this._values[e].value = new ac(this._values[e].property, n === null ? void 0 : Ys(n), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]));
        }
        setTransitionOrValue(e, n) {
          n && (this._options = n);
          const o = this._properties.properties;
          if (e)
            for (const u in e) {
              const l = e[u];
              if (yr(u, "-transition")) {
                const f = u.slice(0, -11);
                o[f] && this.setTransition(f, l);
              } else
                o.hasOwnProperty(u) && this.setValue(u, l);
            }
        }
        getTransition(e) {
          return Ys(this._values[e].transition);
        }
        setTransition(e, n) {
          this._values.hasOwnProperty(e) || (this._values[e] = new lu(this._values[e].property)), this._values[e].transition = Ys(n) || void 0;
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
            const u = this.getTransition(n);
            u !== void 0 && (e[`${n}-transition`] = u);
          }
          return e;
        }
        transitioned(e, n) {
          const o = new tp(this._properties);
          for (const u of Object.keys(this._values))
            o._values[u] = this._values[u].transitioned(e, n._values[u]);
          return o;
        }
        untransitioned() {
          const e = new tp(this._properties);
          for (const n of Object.keys(this._values))
            e._values[n] = this._values[n].untransitioned();
          return e;
        }
      }
      class Ml {
        constructor(e, n, o, u, l) {
          const f = u.delay || 0, v = u.duration || 0;
          l = l || 0, this.property = e, this.value = n, this.begin = l + f, this.end = this.begin + v, e.specification.transition && (u.delay || u.duration) && (this.prior = o);
        }
        possiblyEvaluate(e, n, o) {
          const u = e.now || 0, l = this.value.possiblyEvaluate(e, n, o), f = this.prior;
          if (f) {
            if (u > this.end)
              return this.prior = null, l;
            if (this.value.isDataDriven())
              return this.prior = null, l;
            if (u < this.begin)
              return f.possiblyEvaluate(e, n, o);
            {
              const v = (u - this.begin) / (this.end - this.begin);
              return this.property.interpolate(f.possiblyEvaluate(e, n, o), l, Hr(v));
            }
          }
          return l;
        }
      }
      class tp {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, n, o) {
          const u = new cc(this._properties);
          for (const l of Object.keys(this._values))
            u._values[l] = this._values[l].possiblyEvaluate(e, n, o);
          return u;
        }
        hasTransition() {
          for (const e of Object.keys(this._values))
            if (this._values[e].prior)
              return !0;
          return !1;
        }
      }
      class e_ {
        constructor(e, n, o) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = n, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(e) {
          return Ys(this._values[e].value);
        }
        setValue(e, n) {
          this._values[e] = new ac(this._values[e].property, n === null ? void 0 : Ys(n), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]));
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
          }
          return e;
        }
        possiblyEvaluate(e, n, o) {
          const u = new cc(this._properties);
          for (const l of Object.keys(this._values))
            u._values[l] = this._values[l].possiblyEvaluate(e, n, o);
          return u;
        }
      }
      class lc {
        constructor(e, n, o) {
          this.property = e, this.value = n, this.parameters = o;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, n, o, u) {
          return this.property.evaluate(this.value, this.parameters, e, n, o, u);
        }
      }
      class cc {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class yt {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n) {
          return e.expression.evaluate(n);
        }
        interpolate(e, n, o) {
          const u = Oi[this.specification.type];
          return u ? u(e, n, o) : e;
        }
      }
      class Dt {
        constructor(e, n) {
          this.specification = e, this.overrides = n;
        }
        possiblyEvaluate(e, n, o, u) {
          return new lc(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(n, null, {}, o, u) } : e.expression, n);
        }
        interpolate(e, n, o) {
          if (e.value.kind !== "constant" || n.value.kind !== "constant")
            return e;
          if (e.value.value === void 0 || n.value.value === void 0)
            return new lc(this, { kind: "constant", value: void 0 }, e.parameters);
          const u = Oi[this.specification.type];
          return u ? new lc(this, { kind: "constant", value: u(e.value.value, n.value.value, o) }, e.parameters) : e;
        }
        evaluate(e, n, o, u, l, f) {
          return e.kind === "constant" ? e.value : e.evaluate(n, o, u, l, f);
        }
      }
      class Wa {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, o, u) {
          return !!e.expression.evaluate(n, null, {}, o, u);
        }
        interpolate() {
          return !1;
        }
      }
      class Bn {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const n = new Tn(0, {});
          for (const o in e) {
            const u = e[o];
            u.specification.overridable && this.overridableProperties.push(o);
            const l = this.defaultPropertyValues[o] = new ac(u, void 0), f = this.defaultTransitionablePropertyValues[o] = new lu(u);
            this.defaultTransitioningPropertyValues[o] = f.untransitioned(), this.defaultPossiblyEvaluatedValues[o] = l.possiblyEvaluate(n);
          }
        }
      }
      Ft(Dt, "DataDrivenProperty"), Ft(yt, "DataConstantProperty"), Ft(Wa, "ColorRampProperty");
      var $e = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function ip(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function cu(r) {
        if (Array.isArray(r))
          return r.map(cu);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          const e = {};
          for (const n in r)
            e[n] = cu(r[n]);
          return e;
        }
        return ip(r);
      }
      function bd(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (const e of r.slice(1))
              if (!bd(e) && typeof e != "boolean")
                return !1;
            return !0;
          default:
            return !0;
        }
      }
      function np(r, e = "", n = null, o = "fill") {
        if (r == null)
          return { filter: () => !0, needGeometry: !1, needFeature: !1 };
        bd(r) || (r = nh(r));
        const u = r;
        let l = !0;
        try {
          l = function(x) {
            if (!hc(x))
              return x;
            let A = cu(x);
            return rp(A), A = sp(A), A;
          }(u);
        } catch {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(u, null, 2)}
        `);
        }
        let f = null, v = null;
        if (o !== "background" && o !== "sky" && o !== "slot") {
          v = $e[`filter_${o}`];
          const x = Qc(l, v, e, n);
          if (x.result === "error")
            throw new Error(x.value.map((A) => `${A.key}: ${A.message}`).join(", "));
          f = (A, I, M) => x.value.evaluate(A, I, {}, M);
        }
        let S = null, D = null;
        if (l !== u) {
          const x = Qc(u, v, e, n);
          if (x.result === "error")
            throw new Error(x.value.map((A) => `${A.key}: ${A.message}`).join(", "));
          S = (A, I, M, C, k) => x.value.evaluate(A, I, {}, M, void 0, void 0, C, k), D = !ro(x.value.expression);
        }
        return { filter: f, dynamicFilter: S || void 0, needGeometry: Sl(l), needFeature: !!D };
      }
      function sp(r) {
        if (!Array.isArray(r))
          return r;
        const e = function(n) {
          if (t_.has(n[0])) {
            for (let o = 1; o < n.length; o++)
              if (hc(n[o]))
                return !0;
          }
          return n;
        }(r);
        return e === !0 ? e : e.map((n) => sp(n));
      }
      function rp(r) {
        let e = !1;
        const n = [];
        if (r[0] === "case") {
          for (let o = 1; o < r.length - 1; o += 2)
            e = e || hc(r[o]), n.push(r[o + 1]);
          n.push(r[r.length - 1]);
        } else if (r[0] === "match") {
          e = e || hc(r[1]);
          for (let o = 2; o < r.length - 1; o += 2)
            n.push(r[o + 1]);
          n.push(r[r.length - 1]);
        } else if (r[0] === "step") {
          e = e || hc(r[1]);
          for (let o = 1; o < r.length - 1; o += 2)
            n.push(r[o + 1]);
        }
        e && (r.length = 0, r.push("any", ...n));
        for (let o = 1; o < r.length; o++)
          rp(r[o]);
      }
      function hc(r) {
        if (!Array.isArray(r))
          return !1;
        if ((e = r[0]) === "pitch" || e === "distance-from-center")
          return !0;
        var e;
        for (let n = 1; n < r.length; n++)
          if (hc(r[n]))
            return !0;
        return !1;
      }
      const t_ = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function i_(r, e) {
        return r < e ? -1 : r > e ? 1 : 0;
      }
      function Sl(r) {
        if (!Array.isArray(r))
          return !1;
        if (r[0] === "within" || r[0] === "distance")
          return !0;
        for (let e = 1; e < r.length; e++)
          if (Sl(r[e]))
            return !0;
        return !1;
      }
      function nh(r) {
        if (!r)
          return !0;
        const e = r[0];
        return r.length <= 1 ? e !== "any" : e === "==" ? hu(r[1], r[2], "==") : e === "!=" ? uu(hu(r[1], r[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? hu(r[1], r[2], e) : e === "any" ? (n = r.slice(1), ["any"].concat(n.map(nh))) : e === "all" ? ["all"].concat(r.slice(1).map(nh)) : e === "none" ? ["all"].concat(r.slice(1).map(nh).map(uu)) : e === "in" ? sh(r[1], r.slice(2)) : e === "!in" ? uu(sh(r[1], r.slice(2))) : e === "has" ? op(r[1]) : e !== "!has" || uu(op(r[1]));
        var n;
      }
      function hu(r, e, n) {
        switch (r) {
          case "$type":
            return [`filter-type-${n}`, e];
          case "$id":
            return [`filter-id-${n}`, e];
          default:
            return [`filter-${n}`, r, e];
        }
      }
      function sh(r, e) {
        if (e.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((n) => typeof n != typeof e[0]) ? ["filter-in-large", r, ["literal", e.sort(i_)]] : ["filter-in-small", r, ["literal", e]];
        }
      }
      function op(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function uu(r) {
        return ["!", r];
      }
      const Co = "";
      function Io(r, e) {
        return e ? `${r}${Co}${e}` : r;
      }
      const El = "-transition", n_ = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class wr extends Zo {
        constructor(e, n, o, u, l) {
          if (super(), this.id = e.id, this.fqid = Io(this.id, o), this.type = e.type, this.scope = o, this.lut = u, this.options = l, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, this.configDependencies = /* @__PURE__ */ new Set(), e.type !== "custom") {
            if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
              this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
              const f = Qc(this.filter, $e[`filter_${e.type}`]);
              f.result !== "error" && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...f.value.configDependencies]));
            }
            if (e.slot && (this.slot = e.slot), n.layout && (this._unevaluatedLayout = new e_(n.layout, this.scope, l), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), n.paint) {
              this._transitionablePaint = new ih(n.paint, this.scope, l);
              for (const f in e.paint)
                this.setPaintProperty(f, e.paint[f]);
              for (const f in e.layout)
                this.setLayoutProperty(f, e.layout[f]);
              this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new cc(n.paint);
            }
          }
        }
        onAdd(e) {
        }
        onRemove(e) {
        }
        isDraped(e) {
          return !this.is3D() && n_.has(this.type);
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, n) {
          if (this.type === "custom" && e === "visibility")
            return void (this.visibility = n);
          const o = this._unevaluatedLayout;
          o._properties.properties[e] && (o.setValue(e, n), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
        }
        getPaintProperty(e) {
          return yr(e, El) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, n) {
          const o = this._transitionablePaint, u = o._properties.properties;
          if (yr(e, El)) {
            const A = e.slice(0, -11);
            return u[A] && o.setTransition(A, n || void 0), !1;
          }
          if (!u[e])
            return !1;
          const l = o._values[e], f = l.value.isDataDriven(), v = l.value;
          o.setValue(e, n), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), this._handleSpecialPaintPropertyUpdate(e);
          const S = o._values[e].value, D = S.isDataDriven(), x = yr(e, "pattern") || e === "line-dasharray";
          return D || f || x || this._handleOverridablePaintPropertyUpdate(e, v, S);
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(e, n, o) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, n) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, n);
        }
        serialize() {
          return io({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e, n) => !(e === void 0 || n === "layout" && !Object.keys(e).length || n === "paint" && !Object.keys(e).length));
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        hasShadowPass() {
          return !1;
        }
        canCastShadows() {
          return !1;
        }
        hasLightBeamPass() {
          return !1;
        }
        cutoffRange() {
          return 0;
        }
        tileCoverLift() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const n = this.paint.get(e);
            if (n instanceof lc && nc(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent)
              return !0;
          }
          return !1;
        }
        compileFilter(e) {
          this._filterCompiled || (this._featureFilter = np(this.filter, this.scope, e), this._filterCompiled = !0);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = !1;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats(e) {
          this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
        }
        queryRadius(e) {
        }
        queryIntersectsFeature(e, n, o, u, l, f, v, S, D) {
        }
      }
      const s_ = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class rh {
        constructor(e, n) {
          this._structArray = e, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class bn {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, n) {
          return e._trim(), n && (e.isTransferred = !0, n.add(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = e.arrayBuffer, n.length = e.length, n.capacity = e.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
        }
        emplace(...e) {
          throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
        }
        emplaceBack(...e) {
          throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function qi(r, e = 1) {
        let n = 0, o = 0;
        return { members: r.map((u) => {
          const l = s_[u.type].BYTES_PER_ELEMENT, f = n = du(n, Math.max(e, l)), v = u.components || 1;
          return o = Math.max(o, l), n += l * v, { name: u.name, type: u.type, components: v, offset: f };
        }), size: du(n, Math.max(o, e)), alignment: e };
      }
      function du(r, e) {
        return Math.ceil(r / e) * e;
      }
      class Lo extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.int16[u + 0] = n, this.int16[u + 1] = o, e;
        }
      }
      Lo.prototype.bytesPerElement = 4, Ft(Lo, "StructArrayLayout2i4");
      class oh extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.int16[l + 0] = n, this.int16[l + 1] = o, this.int16[l + 2] = u, e;
        }
      }
      oh.prototype.bytesPerElement = 6, Ft(oh, "StructArrayLayout3i6");
      class $a extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const f = 4 * e;
          return this.int16[f + 0] = n, this.int16[f + 1] = o, this.int16[f + 2] = u, this.int16[f + 3] = l, e;
        }
      }
      $a.prototype.bytesPerElement = 8, Ft($a, "StructArrayLayout4i8");
      class wd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, f) {
          const v = 5 * e;
          return this.int16[v + 0] = n, this.int16[v + 1] = o, this.int16[v + 2] = u, this.int16[v + 3] = l, this.int16[v + 4] = f, e;
        }
      }
      wd.prototype.bytesPerElement = 10, Ft(wd, "StructArrayLayout5i10");
      class ho extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, l, f, v);
        }
        emplace(e, n, o, u, l, f, v, S) {
          const D = 6 * e, x = 12 * e, A = 3 * e;
          return this.int16[D + 0] = n, this.int16[D + 1] = o, this.uint8[x + 4] = u, this.uint8[x + 5] = l, this.uint8[x + 6] = f, this.uint8[x + 7] = v, this.float32[A + 2] = S, e;
        }
      }
      ho.prototype.bytesPerElement = 12, Ft(ho, "StructArrayLayout2i4ub1f12");
      class Xa extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const f = 4 * e;
          return this.float32[f + 0] = n, this.float32[f + 1] = o, this.float32[f + 2] = u, this.float32[f + 3] = l, e;
        }
      }
      Xa.prototype.bytesPerElement = 16, Ft(Xa, "StructArrayLayout4f16");
      class va extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.float32[l + 0] = n, this.float32[l + 1] = o, this.float32[l + 2] = u, e;
        }
      }
      va.prototype.bytesPerElement = 12, Ft(va, "StructArrayLayout3f12");
      class Ya extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, f) {
          const v = 6 * e, S = 3 * e;
          return this.uint16[v + 0] = n, this.uint16[v + 1] = o, this.uint16[v + 2] = u, this.uint16[v + 3] = l, this.float32[S + 2] = f, e;
        }
      }
      Ya.prototype.bytesPerElement = 12, Ft(Ya, "StructArrayLayout4ui1f12");
      class fu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const f = 4 * e;
          return this.uint16[f + 0] = n, this.uint16[f + 1] = o, this.uint16[f + 2] = u, this.uint16[f + 3] = l, e;
        }
      }
      fu.prototype.bytesPerElement = 8, Ft(fu, "StructArrayLayout4ui8");
      class pu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, f);
        }
        emplace(e, n, o, u, l, f, v) {
          const S = 6 * e;
          return this.int16[S + 0] = n, this.int16[S + 1] = o, this.int16[S + 2] = u, this.int16[S + 3] = l, this.int16[S + 4] = f, this.int16[S + 5] = v, e;
        }
      }
      pu.prototype.bytesPerElement = 12, Ft(pu, "StructArrayLayout6i12");
      class Td extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A, I) {
          const M = this.length;
          return this.resize(M + 1), this.emplace(M, e, n, o, u, l, f, v, S, D, x, A, I);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I, M) {
          const C = 12 * e;
          return this.int16[C + 0] = n, this.int16[C + 1] = o, this.int16[C + 2] = u, this.int16[C + 3] = l, this.uint16[C + 4] = f, this.uint16[C + 5] = v, this.uint16[C + 6] = S, this.uint16[C + 7] = D, this.int16[C + 8] = x, this.int16[C + 9] = A, this.int16[C + 10] = I, this.int16[C + 11] = M, e;
        }
      }
      Td.prototype.bytesPerElement = 24, Ft(Td, "StructArrayLayout4i4ui4i24");
      class Md extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, f);
        }
        emplace(e, n, o, u, l, f, v) {
          const S = 10 * e, D = 5 * e;
          return this.int16[S + 0] = n, this.int16[S + 1] = o, this.int16[S + 2] = u, this.float32[D + 2] = l, this.float32[D + 3] = f, this.float32[D + 4] = v, e;
        }
      }
      Md.prototype.bytesPerElement = 20, Ft(Md, "StructArrayLayout3i3f20");
      class Sd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint32[1 * e + 0] = n, e;
        }
      }
      Sd.prototype.bytesPerElement = 4, Ft(Sd, "StructArrayLayout1ul4");
      class Ka extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.uint16[u + 0] = n, this.uint16[u + 1] = o, e;
        }
      }
      Ka.prototype.bytesPerElement = 4, Ft(Ka, "StructArrayLayout2ui4");
      class Ed extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A, I, M) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, e, n, o, u, l, f, v, S, D, x, A, I, M);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I, M, C) {
          const k = 20 * e, V = 10 * e;
          return this.int16[k + 0] = n, this.int16[k + 1] = o, this.int16[k + 2] = u, this.int16[k + 3] = l, this.int16[k + 4] = f, this.float32[V + 3] = v, this.float32[V + 4] = S, this.float32[V + 5] = D, this.float32[V + 6] = x, this.int16[k + 14] = A, this.uint32[V + 8] = I, this.uint16[k + 18] = M, this.uint16[k + 19] = C, e;
        }
      }
      Ed.prototype.bytesPerElement = 40, Ft(Ed, "StructArrayLayout5i4f1i1ul2ui40");
      class mu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, l, f, v);
        }
        emplace(e, n, o, u, l, f, v, S) {
          const D = 8 * e;
          return this.int16[D + 0] = n, this.int16[D + 1] = o, this.int16[D + 2] = u, this.int16[D + 4] = l, this.int16[D + 5] = f, this.int16[D + 6] = v, this.int16[D + 7] = S, e;
        }
      }
      mu.prototype.bytesPerElement = 16, Ft(mu, "StructArrayLayout3i2i2i16");
      class _u extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, f) {
          const v = 4 * e, S = 8 * e;
          return this.float32[v + 0] = n, this.float32[v + 1] = o, this.float32[v + 2] = u, this.int16[S + 6] = l, this.int16[S + 7] = f, e;
        }
      }
      _u.prototype.bytesPerElement = 16, Ft(_u, "StructArrayLayout2f1f2i16");
      class Ad extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, f);
        }
        emplace(e, n, o, u, l, f, v) {
          const S = 20 * e, D = 5 * e;
          return this.uint8[S + 0] = n, this.uint8[S + 1] = o, this.float32[D + 1] = u, this.float32[D + 2] = l, this.float32[D + 3] = f, this.float32[D + 4] = v, e;
        }
      }
      Ad.prototype.bytesPerElement = 20, Ft(Ad, "StructArrayLayout2ub4f20");
      class qs extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.uint16[l + 0] = n, this.uint16[l + 1] = o, this.uint16[l + 2] = u, e;
        }
      }
      qs.prototype.bytesPerElement = 6, Ft(qs, "StructArrayLayout3ui6");
      class Pd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K) {
          const Q = this.length;
          return this.resize(Q + 1), this.emplace(Q, e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K, Q) {
          const ie = 30 * e, fe = 15 * e, de = 60 * e;
          return this.int16[ie + 0] = n, this.int16[ie + 1] = o, this.int16[ie + 2] = u, this.float32[fe + 2] = l, this.float32[fe + 3] = f, this.uint16[ie + 8] = v, this.uint16[ie + 9] = S, this.uint32[fe + 5] = D, this.uint32[fe + 6] = x, this.uint32[fe + 7] = A, this.uint16[ie + 16] = I, this.uint16[ie + 17] = M, this.uint16[ie + 18] = C, this.float32[fe + 10] = k, this.float32[fe + 11] = V, this.uint8[de + 48] = U, this.uint8[de + 49] = q, this.uint8[de + 50] = $, this.uint32[fe + 13] = H, this.int16[ie + 28] = K, this.uint8[de + 58] = Q, e;
        }
      }
      Pd.prototype.bytesPerElement = 60, Ft(Pd, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class gu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K, Q, ie, fe, de, ue, Se, me, Ee, ze, Ie, Re) {
          const Ve = this.length;
          return this.resize(Ve + 1), this.emplace(Ve, e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K, Q, ie, fe, de, ue, Se, me, Ee, ze, Ie, Re);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U, q, $, H, K, Q, ie, fe, de, ue, Se, me, Ee, ze, Ie, Re, Ve) {
          const Ue = 20 * e, Fe = 40 * e, et = 80 * e;
          return this.float32[Ue + 0] = n, this.float32[Ue + 1] = o, this.int16[Fe + 4] = u, this.int16[Fe + 5] = l, this.int16[Fe + 6] = f, this.int16[Fe + 7] = v, this.int16[Fe + 8] = S, this.int16[Fe + 9] = D, this.int16[Fe + 10] = x, this.int16[Fe + 11] = A, this.int16[Fe + 12] = I, this.uint16[Fe + 13] = M, this.uint16[Fe + 14] = C, this.uint16[Fe + 15] = k, this.uint16[Fe + 16] = V, this.uint16[Fe + 17] = U, this.uint16[Fe + 18] = q, this.uint16[Fe + 19] = $, this.uint16[Fe + 20] = H, this.uint16[Fe + 21] = K, this.uint16[Fe + 22] = Q, this.uint16[Fe + 23] = ie, this.uint16[Fe + 24] = fe, this.uint16[Fe + 25] = de, this.uint16[Fe + 26] = ue, this.uint16[Fe + 27] = Se, this.uint32[Ue + 14] = me, this.float32[Ue + 15] = Ee, this.float32[Ue + 16] = ze, this.float32[Ue + 17] = Ie, this.float32[Ue + 18] = Re, this.uint8[et + 76] = Ve, e;
        }
      }
      gu.prototype.bytesPerElement = 80, Ft(gu, "StructArrayLayout2f9i15ui1ul4f1ub80");
      class uc extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.float32[1 * e + 0] = n, e;
        }
      }
      uc.prototype.bytesPerElement = 4, Ft(uc, "StructArrayLayout1f4");
      class Rr extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, f) {
          const v = 5 * e;
          return this.float32[v + 0] = n, this.float32[v + 1] = o, this.float32[v + 2] = u, this.float32[v + 3] = l, this.float32[v + 4] = f, e;
        }
      }
      Rr.prototype.bytesPerElement = 20, Ft(Rr, "StructArrayLayout5f20");
      class yu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, l, f, v);
        }
        emplace(e, n, o, u, l, f, v, S) {
          const D = 7 * e;
          return this.float32[D + 0] = n, this.float32[D + 1] = o, this.float32[D + 2] = u, this.float32[D + 3] = l, this.float32[D + 4] = f, this.float32[D + 5] = v, this.float32[D + 6] = S, e;
        }
      }
      yu.prototype.bytesPerElement = 28, Ft(yu, "StructArrayLayout7f28");
      class Cd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A) {
          const I = this.length;
          return this.resize(I + 1), this.emplace(I, e, n, o, u, l, f, v, S, D, x, A);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I) {
          const M = 11 * e;
          return this.float32[M + 0] = n, this.float32[M + 1] = o, this.float32[M + 2] = u, this.float32[M + 3] = l, this.float32[M + 4] = f, this.float32[M + 5] = v, this.float32[M + 6] = S, this.float32[M + 7] = D, this.float32[M + 8] = x, this.float32[M + 9] = A, this.float32[M + 10] = I, e;
        }
      }
      Cd.prototype.bytesPerElement = 44, Ft(Cd, "StructArrayLayout11f44");
      class Id extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, e, n, o, u, l, f, v, S, D);
        }
        emplace(e, n, o, u, l, f, v, S, D, x) {
          const A = 9 * e;
          return this.float32[A + 0] = n, this.float32[A + 1] = o, this.float32[A + 2] = u, this.float32[A + 3] = l, this.float32[A + 4] = f, this.float32[A + 5] = v, this.float32[A + 6] = S, this.float32[A + 7] = D, this.float32[A + 8] = x, e;
        }
      }
      Id.prototype.bytesPerElement = 36, Ft(Id, "StructArrayLayout9f36");
      class Al extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.float32[u + 0] = n, this.float32[u + 1] = o, e;
        }
      }
      Al.prototype.bytesPerElement = 8, Ft(Al, "StructArrayLayout2f8");
      class ah extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const f = 6 * e;
          return this.uint32[3 * e + 0] = n, this.uint16[f + 2] = o, this.uint16[f + 3] = u, this.uint16[f + 4] = l, e;
        }
      }
      ah.prototype.bytesPerElement = 12, Ft(ah, "StructArrayLayout1ul3ui12");
      class xu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint16[1 * e + 0] = n, e;
        }
      }
      xu.prototype.bytesPerElement = 2, Ft(xu, "StructArrayLayout1ui2");
      class Ld extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V) {
          const U = this.length;
          return this.resize(U + 1), this.emplace(U, e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V);
        }
        emplace(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U) {
          const q = 16 * e;
          return this.float32[q + 0] = n, this.float32[q + 1] = o, this.float32[q + 2] = u, this.float32[q + 3] = l, this.float32[q + 4] = f, this.float32[q + 5] = v, this.float32[q + 6] = S, this.float32[q + 7] = D, this.float32[q + 8] = x, this.float32[q + 9] = A, this.float32[q + 10] = I, this.float32[q + 11] = M, this.float32[q + 12] = C, this.float32[q + 13] = k, this.float32[q + 14] = V, this.float32[q + 15] = U, e;
        }
      }
      Ld.prototype.bytesPerElement = 64, Ft(Ld, "StructArrayLayout16f64");
      class lh extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, f, v) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, l, f, v);
        }
        emplace(e, n, o, u, l, f, v, S) {
          const D = 10 * e, x = 5 * e;
          return this.uint16[D + 0] = n, this.uint16[D + 1] = o, this.uint16[D + 2] = u, this.uint16[D + 3] = l, this.float32[x + 2] = f, this.float32[x + 3] = v, this.float32[x + 4] = S, e;
        }
      }
      lh.prototype.bytesPerElement = 20, Ft(lh, "StructArrayLayout4ui3f20");
      class zd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.int16[1 * e + 0] = n, e;
        }
      }
      zd.prototype.bytesPerElement = 2, Ft(zd, "StructArrayLayout1i2");
      class vu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint8[1 * e + 0] = n, e;
        }
      }
      vu.prototype.bytesPerElement = 1, Ft(vu, "StructArrayLayout1ub1");
      class ch extends rh {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      ch.prototype.size = 40;
      class ap extends Ed {
        get(e) {
          return new ch(this, e);
        }
      }
      Ft(ap, "CollisionBoxArray");
      class lp extends rh {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 49] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 50] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 13] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(e) {
          this._structArray.uint8[this._pos1 + 58] = e;
        }
      }
      lp.prototype.size = 60;
      class cp extends Pd {
        get(e) {
          return new lp(this, e);
        }
      }
      Ft(cp, "PlacedSymbolArray");
      class hp extends rh {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 14] = e;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(e) {
          this._structArray.float32[this._pos4 + 18] = e;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      hp.prototype.size = 80;
      class up extends gu {
        get(e) {
          return new hp(this, e);
        }
      }
      Ft(up, "SymbolInstanceArray");
      class hh extends uc {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      Ft(hh, "GlyphOffsetArray");
      class uh extends Lo {
        getx(e) {
          return this.int16[2 * e + 0];
        }
        gety(e) {
          return this.int16[2 * e + 1];
        }
      }
      Ft(uh, "SymbolLineVertexArray");
      class Or extends rh {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Or.prototype.size = 12;
      class dh extends ah {
        get(e) {
          return new Or(this, e);
        }
      }
      Ft(dh, "FeatureIndexArray");
      class dp extends Ka {
        geta_centroid_pos0(e) {
          return this.uint16[2 * e + 0];
        }
        geta_centroid_pos1(e) {
          return this.uint16[2 * e + 1];
        }
      }
      Ft(dp, "FillExtrusionCentroidArray");
      class fp extends rh {
        get a_join_normal_inside0() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_join_normal_inside1() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_join_normal_inside2() {
          return this._structArray.int16[this._pos2 + 2];
        }
      }
      fp.prototype.size = 6;
      class pp extends oh {
        get(e) {
          return new fp(this, e);
        }
      }
      Ft(pp, "FillExtrusionWallArray");
      const r_ = qi([{ name: "a_pos", components: 2, type: "Int16" }], 4), Dd = qi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class Wn {
        constructor(e = []) {
          this.segments = e;
        }
        _prepareSegment(e, n, o, u) {
          let l = this.segments[this.segments.length - 1];
          return e > Wn.MAX_VERTEX_ARRAY_LENGTH && mi(`Max vertices per segment is ${Wn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!l || l.vertexLength + e > Wn.MAX_VERTEX_ARRAY_LENGTH || l.sortKey !== u) && (l = { vertexOffset: n, primitiveOffset: o, vertexLength: 0, primitiveLength: 0 }, u !== void 0 && (l.sortKey = u), this.segments.push(l)), l;
        }
        prepareSegment(e, n, o, u) {
          return this._prepareSegment(e, n.length, o.length, u);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments)
            for (const n in e.vaos)
              e.vaos[n].destroy();
        }
        static simpleSegment(e, n, o, u) {
          return new Wn([{ vertexOffset: e, primitiveOffset: n, vertexLength: o, primitiveLength: u, vaos: {}, sortKey: 0 }]);
        }
      }
      function bu(r, e) {
        return 256 * (r = si(Math.floor(r), 0, 255)) + si(Math.floor(e), 0, 255);
      }
      Wn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ft(Wn, "SegmentVector");
      const o_ = qi([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), a_ = qi([{ name: "a_dash", components: 4, type: "Uint16" }]);
      class Pl {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
        }
        add(e, n, o, u) {
          this.ids.push(mp(e)), this.positions.push(n, o, u);
        }
        eachPosition(e, n) {
          const o = mp(e);
          let u = 0, l = this.ids.length - 1;
          for (; u < l; ) {
            const f = u + l >> 1;
            this.ids[f] >= o ? l = f : u = f + 1;
          }
          for (; this.ids[u] === o; )
            n(this.positions[3 * u], this.positions[3 * u + 1], this.positions[3 * u + 2]), u++;
        }
        static serialize(e, n) {
          const o = new Float64Array(e.ids), u = new Uint32Array(e.positions);
          return wu(o, u, 0, o.length - 1), n && (n.add(o.buffer), n.add(u.buffer)), { ids: o, positions: u };
        }
        static deserialize(e) {
          const n = new Pl();
          let o;
          n.ids = e.ids, n.positions = e.positions;
          for (const u of n.ids)
            u !== o && n.uniqueIds.push(u), o = u;
          return n.indexed = !0, n;
        }
      }
      function mp(r) {
        const e = +r;
        return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : $r(String(r));
      }
      function wu(r, e, n, o) {
        for (; n < o; ) {
          const u = r[n + o >> 1];
          let l = n - 1, f = o + 1;
          for (; ; ) {
            do
              l++;
            while (r[l] < u);
            do
              f--;
            while (r[f] > u);
            if (l >= f)
              break;
            fh(r, l, f), fh(e, 3 * l, 3 * f), fh(e, 3 * l + 1, 3 * f + 1), fh(e, 3 * l + 2, 3 * f + 2);
          }
          f - n < o - f ? (wu(r, e, n, f), n = f + 1) : (wu(r, e, f + 1, o), o = f);
        }
      }
      function fh(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      Ft(Pl, "FeaturePositionMap");
      class ba {
        constructor(e) {
          this.gl = e.gl, this.initialized = !1;
        }
        fetchUniformLocation(e, n) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, n), this.initialized = !0), !!this.location;
        }
        set(e, n, o) {
          throw new Error("Uniform#set() must be implemented by each concrete Uniform");
        }
      }
      class dc extends ba {
        constructor(e) {
          super(e), this.current = 0;
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
        }
      }
      class Nn extends ba {
        constructor(e) {
          super(e), this.current = 0;
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
        }
      }
      class zo extends ba {
        constructor(e) {
          super(e), this.current = [0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1])));
        }
      }
      class kd extends ba {
        constructor(e) {
          super(e), this.current = [0, 0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2])));
        }
      }
      class ph extends ba {
        constructor(e) {
          super(e), this.current = [0, 0, 0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3])));
        }
      }
      class _p extends ba {
        constructor(e) {
          super(e), this.current = ki.transparent.toRenderColor(null);
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a)));
        }
      }
      const Rd = new Float32Array(16);
      class mh extends ba {
        constructor(e) {
          super(e), this.current = Rd;
        }
        set(e, n, o) {
          if (this.fetchUniformLocation(e, n)) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0])
              return this.current = o, void this.gl.uniformMatrix4fv(this.location, !1, o);
            for (let u = 1; u < 16; u++)
              if (o[u] !== this.current[u]) {
                this.current = o, this.gl.uniformMatrix4fv(this.location, !1, o);
                break;
              }
          }
        }
      }
      const l_ = new Float32Array(9), c_ = new Float32Array(4);
      class Od extends ba {
        constructor(e) {
          super(e), this.current = c_;
        }
        set(e, n, o) {
          if (this.fetchUniformLocation(e, n)) {
            for (let u = 0; u < 4; u++)
              if (o[u] !== this.current[u]) {
                this.current = o, this.gl.uniformMatrix2fv(this.location, !1, o);
                break;
              }
          }
        }
      }
      function Tu(r) {
        return [bu(255 * r.r, 255 * r.g), bu(255 * r.b, 255 * r.a)];
      }
      class fc {
        constructor(e, n, o, u) {
          this.value = e, this.uniformNames = n.map((l) => `u_${l}`), this.type = o, this.context = u;
        }
        setUniform(e, n, o, u, l) {
          const f = u.constantOr(this.value);
          n.set(e, l, f instanceof ki ? f.toRenderColor(this.ignoreLut ? null : this.context.lut) : f);
        }
        getBinding(e, n) {
          return this.type === "color" ? new _p(e) : new Nn(e);
        }
      }
      class pc {
        constructor(e, n) {
          this.uniformNames = n.map((o) => `u_${o}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(e) {
          this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br);
        }
        setUniform(e, n, o, u, l) {
          const f = l === "u_pattern" || l === "u_dash" ? this.pattern : l === "u_pixel_ratio" ? this.pixelRatio : null;
          f && n.set(e, l, f);
        }
        getBinding(e, n) {
          return n === "u_pattern" || n === "u_dash" ? new ph(e) : new Nn(e);
        }
      }
      class wa {
        constructor(e, n, o, u) {
          this.expression = e, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((l) => ({ name: `a_${l}`, type: "Float32", components: o === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, o, u, l, f, v) {
          const S = this.paintVertexArray.length, D = this.expression.evaluate(new Tn(0, { brightness: f }), n, {}, l, u, v);
          this.paintVertexArray.resize(e), this._setPaintValue(S, e, D, this.context);
        }
        updatePaintArray(e, n, o, u, l, f, v) {
          const S = this.expression.evaluate({ zoom: 0, brightness: v }, o, u, void 0, l);
          this._setPaintValue(e, n, S, this.context);
        }
        _setPaintValue(e, n, o, u) {
          if (this.type === "color") {
            const l = Tu(o.toRenderColor(this.ignoreLut ? null : u.lut));
            for (let f = e; f < n; f++)
              this.paintVertexArray.emplace(f, l[0], l[1]);
          } else {
            for (let l = e; l < n; l++)
              this.paintVertexArray.emplace(l, o);
            this.maxValue = Math.max(this.maxValue, Math.abs(o));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Do {
        constructor(e, n, o, u, l, f) {
          this.expression = e, this.uniformNames = n.map((v) => `u_${v}_t`), this.type = o, this.useIntegerZoom = u, this.context = l, this.maxValue = 0, this.paintVertexAttributes = n.map((v) => ({ name: `a_${v}`, type: "Float32", components: o === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new f();
        }
        populatePaintArray(e, n, o, u, l, f, v) {
          const S = this.expression.evaluate(new Tn(this.context.zoom, { brightness: f }), n, {}, l, u, v), D = this.expression.evaluate(new Tn(this.context.zoom + 1, { brightness: f }), n, {}, l, u, v), x = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(x, e, S, D, this.context);
        }
        updatePaintArray(e, n, o, u, l, f, v) {
          const S = this.expression.evaluate({ zoom: this.context.zoom, brightness: v }, o, u, void 0, l), D = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: v }, o, u, void 0, l);
          this._setPaintValue(e, n, S, D, this.context);
        }
        _setPaintValue(e, n, o, u, l) {
          if (this.type === "color") {
            const f = Tu(o.toRenderColor(this.ignoreLut ? null : l.lut)), v = Tu(o.toRenderColor(this.ignoreLut ? null : l.lut));
            for (let S = e; S < n; S++)
              this.paintVertexArray.emplace(S, f[0], f[1], v[0], v[1]);
          } else {
            for (let f = e; f < n; f++)
              this.paintVertexArray.emplace(f, o, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, n, o, u, l) {
          const f = this.useIntegerZoom ? Math.floor(o.zoom) : o.zoom, v = si(this.expression.interpolationFactor(f, this.context.zoom, this.context.zoom + 1), 0, 1);
          n.set(e, l, v);
        }
        getBinding(e, n) {
          return new Nn(e);
        }
      }
      class Ja {
        constructor(e, n, o, u, l) {
          this.expression = e, this.layerId = l, this.paintVertexAttributes = (o === "array" ? a_ : o_).members;
          for (let f = 0; f < n.length; ++f)
            ;
          this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, o, u) {
          const l = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValues(l, e, n.patterns && n.patterns[this.layerId], o);
        }
        updatePaintArray(e, n, o, u, l, f, v) {
          this._setPaintValues(e, n, o.patterns && o.patterns[this.layerId], f);
        }
        _setPaintValues(e, n, o, u) {
          if (!u || !o)
            return;
          const l = u[o];
          if (!l)
            return;
          const { tl: f, br: v, pixelRatio: S } = l;
          for (let D = e; D < n; D++)
            this.paintVertexArray.emplace(D, f[0], f[1], v[0], v[1], S);
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Cl {
        constructor(e, n, o = () => !0) {
          this.binders = {}, this._buffers = [], this.context = n;
          const u = [];
          for (const l in e.paint._values) {
            const f = e.paint.get(l), v = e.paint.get(`${l}-use-theme`);
            if (l.endsWith("-use-theme") || !o(l) || !(f instanceof lc && nc(f.property.specification)))
              continue;
            const S = Mu(l, e.type), D = f.value, x = f.property.specification.type, A = !!f.property.useIntegerZoom, I = l === "line-dasharray" || l.endsWith("pattern"), M = l === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant";
            if (D.kind !== "constant" || M)
              if (D.kind === "source" || M || I) {
                const C = _h(l, x, "source");
                this.binders[l] = I ? new Ja(D, S, x, C, e.id) : new wa(D, S, x, C), u.push(`/a_${l}`);
              } else {
                const C = _h(l, x, "composite");
                this.binders[l] = new Do(D, S, x, A, n, C), u.push(`/z_${l}`);
              }
            else
              this.binders[l] = I ? new pc(D.value, S) : new fc(D.value, S, x, n), u.push(`/u_${l}`);
            v && (this.binders[l].ignoreLut = v.constantOr("default") === "none", this.binders[l].checkUseTheme = !0);
          }
          this.cacheKey = u.sort().join("");
        }
        getMaxValue(e) {
          const n = this.binders[e];
          return n instanceof wa || n instanceof Do ? n.maxValue : 0;
        }
        populatePaintArrays(e, n, o, u, l, f, v) {
          for (const S in this.binders) {
            const D = this.binders[S];
            D.context = this.context, (D instanceof wa || D instanceof Do || D instanceof Ja) && D.populatePaintArray(e, n, o, u, l, f, v);
          }
        }
        setConstantPatternPositions(e) {
          for (const n in this.binders) {
            const o = this.binders[n];
            o instanceof pc && o.setConstantPatternPositions(e);
          }
        }
        updatePaintArrays(e, n, o, u, l, f, v, S, D) {
          let x = !1;
          const A = Object.keys(e), I = A.length !== 0 && !S, M = I ? A : n.uniqueIds;
          this.context.lut = l.lut;
          for (const C in this.binders) {
            const k = this.binders[C];
            if (k.context = this.context, (k instanceof wa || k instanceof Do || k instanceof Ja) && (k.expression.isStateDependent === !0 || k.expression.isLightConstant === !1)) {
              const V = l.paint.get(C);
              k.expression = V.value;
              for (const U of M) {
                const q = e[U.toString()];
                n.eachPosition(U, ($, H, K) => {
                  const Q = u.feature($);
                  k.updatePaintArray(H, K, Q, q, f, v, D);
                });
              }
              if (!I)
                for (const U of o.uniqueIds) {
                  const q = e[U.toString()];
                  o.eachPosition(U, ($, H, K) => {
                    const Q = u.feature($);
                    k.updatePaintArray(H, K, Q, q, f, v, D);
                  });
                }
              x = !0;
            }
          }
          return x;
        }
        defines() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof fc || o instanceof pc) && e.push(...o.uniformNames.map((u) => `#define HAS_UNIFORM_${u}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof wa || o instanceof Do || o instanceof Ja)
              for (let u = 0; u < o.paintVertexAttributes.length; u++)
                e.push(o.paintVertexAttributes[u].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof fc || o instanceof pc || o instanceof Do)
              for (const u of o.uniformNames)
                e.push(u);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e) {
          const n = [];
          for (const o in this.binders) {
            const u = this.binders[o];
            if (u instanceof fc || u instanceof pc || u instanceof Do)
              for (const l of u.uniformNames)
                n.push({ name: l, property: o, binding: u.getBinding(e, l) });
          }
          return n;
        }
        setUniforms(e, n, o, u, l) {
          for (const { name: f, property: v, binding: S } of o) {
            if (this.binders[v].checkUseTheme && this.binders[v] instanceof fc) {
              const D = u.get(`${v}-use-theme`);
              D.isConstant() && (this.binders[v].ignoreLut = D.constantOr("default") === "none");
            }
            this.binders[v].setUniform(e, S, l, u.get(v), f);
          }
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof wa || n instanceof Do || n instanceof Ja) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof wa || o instanceof Do || o instanceof Ja) && o.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof wa || n instanceof Do || n instanceof Ja) && n.destroy();
          }
        }
      }
      class Qa {
        constructor(e, n, o = () => !0) {
          this.programConfigurations = {};
          for (const u of e)
            this.programConfigurations[u.id] = new Cl(u, n, o);
          this.needsUpload = !1, this._featureMap = new Pl(), this._featureMapWithoutIds = new Pl(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(e, n, o, u, l, f, v, S) {
          for (const D in this.programConfigurations)
            this.programConfigurations[D].populatePaintArrays(e, n, u, l, f, v, S);
          n.id !== void 0 ? this._featureMap.add(n.id, o, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, o, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, n, o, u, l, f, v) {
          for (const S of o)
            this.needsUpload = this.programConfigurations[S.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, n, S, u, l, f, v || 0) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations)
              this.programConfigurations[n].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations)
            this.programConfigurations[e].destroy();
        }
      }
      const h_ = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function Mu(r, e) {
        return h_[r] || [r.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      const u_ = { "line-pattern": { source: Ya, composite: Ya }, "fill-pattern": { source: Ya, composite: Ya }, "fill-extrusion-pattern": { source: Ya, composite: Ya }, "line-dasharray": { source: fu, composite: fu } }, d_ = { color: { source: Al, composite: Xa }, number: { source: uc, composite: Al } };
      function _h(r, e, n) {
        const o = u_[r];
        return o && o[n] || d_[e][n];
      }
      Ft(fc, "ConstantBinder"), Ft(pc, "PatternConstantBinder"), Ft(wa, "SourceExpressionBinder"), Ft(Ja, "PatternCompositeBinder"), Ft(Do, "CompositeExpressionBinder"), Ft(Cl, "ProgramConfiguration", { omit: ["_buffers"] }), Ft(Qa, "ProgramConfigurationSet");
      const dr = Tt / Math.PI / 2, Su = 5, gp = 6, yp = 16383, Il = 64, Eu = [Il, 32, 16], uo = -dr, fo = dr;
      function mc(r, e, n, o = dr) {
        return n = vi(n), [r * Math.sin(n) * o, -e * o, r * Math.cos(n) * o];
      }
      function el(r, e, n) {
        return mc(Math.cos(vi(r)), Math.sin(vi(r)), e, n);
      }
      const _c = 63710088e-1, Fd = 2 * Math.PI * _c;
      class Ui {
        constructor(e, n) {
          if (isNaN(e) || isNaN(n))
            throw new Error(`Invalid LngLat object: (${e}, ${n})`);
          if (this.lng = +e, this.lat = +n, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Ui(zn(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const n = Math.PI / 180, o = this.lat * n, u = e.lat * n, l = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((e.lng - this.lng) * n);
          return _c * Math.acos(Math.min(l, 1));
        }
        toBounds(e = 0) {
          const n = 360 * e / 40075017, o = n / Math.cos(Math.PI / 180 * this.lat);
          return new tl({ lng: this.lng - o, lat: this.lat - n }, { lng: this.lng + o, lat: this.lat + n });
        }
        toEcef(e) {
          return el(this.lat, this.lng, dr + e * dr / _c);
        }
        static convert(e) {
          if (e instanceof Ui)
            return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3))
            return new Ui(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null)
            return new Ui(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      class tl {
        constructor(e, n) {
          if (e)
            if (n)
              this.setSouthWest(e).setNorthEast(n);
            else if (e.length === 4) {
              const o = e;
              this.setSouthWest([o[0], o[1]]).setNorthEast([o[2], o[3]]);
            } else {
              const o = e;
              this.setSouthWest(o[0]).setNorthEast(o[1]);
            }
        }
        setNorthEast(e) {
          return this._ne = e instanceof Ui ? new Ui(e.lng, e.lat) : Ui.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof Ui ? new Ui(e.lng, e.lat) : Ui.convert(e), this;
        }
        extend(e) {
          const n = this._sw, o = this._ne;
          let u, l;
          if (e instanceof Ui)
            u = e, l = e;
          else {
            if (!(e instanceof tl))
              return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(tl.convert(e)) : this.extend(Ui.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(Ui.convert(e)) : this;
            if (u = e._sw, l = e._ne, !u || !l)
              return this;
          }
          return n || o ? (n.lng = Math.min(u.lng, n.lng), n.lat = Math.min(u.lat, n.lat), o.lng = Math.max(l.lng, o.lng), o.lat = Math.max(l.lat, o.lat)) : (this._sw = new Ui(u.lng, u.lat), this._ne = new Ui(l.lng, l.lat)), this;
        }
        getCenter() {
          return new Ui((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Ui(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Ui(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: n, lat: o } = Ui.convert(e);
          let u = this._sw.lng <= n && n <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (u = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && u;
        }
        static convert(e) {
          if (e)
            return e instanceof tl ? e : new tl(e);
        }
      }
      const f_ = 0, xp = 25.5;
      function gh(r) {
        return Fd * Math.cos(r * Math.PI / 180);
      }
      function ta(r) {
        return (180 + r) / 360;
      }
      function Ta(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function fr(r, e) {
        return r / gh(e);
      }
      function Fr(r) {
        return 360 * r - 180;
      }
      function Os(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      function vp(r, e) {
        return r * gh(Os(e));
      }
      const Un = 85.051129;
      function p_(r) {
        return Math.cos(vi(si(r, -Un, Un)));
      }
      function c(r, e) {
        const n = si(e, f_, xp), o = Math.pow(2, n);
        return p_(r) * Fd / (512 * o);
      }
      function t(r) {
        return 1 / Math.cos(r * Math.PI / 180);
      }
      function s(r, e = 0) {
        const n = Math.exp(Math.PI * (1 - (r.y + e / Tt) / (1 << r.z) * 2));
        return 80150034 * n / (n * n + 1) / Tt / (1 << r.z);
      }
      class h {
        constructor(e, n, o = 0) {
          this.x = +e, this.y = +n, this.z = +o;
        }
        static fromLngLat(e, n = 0) {
          const o = Ui.convert(e);
          return new h(ta(o.lng), Ta(o.lat), fr(n, o.lat));
        }
        toLngLat() {
          return new Ui(Fr(this.x), Os(this.y));
        }
        toAltitude() {
          return vp(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Fd * t(Os(this.y));
        }
      }
      function _(r, e, n, o, u, l, f, v, S) {
        const D = (e + o) / 2, x = (n + u) / 2, A = new Et(D, x);
        v(A), function(I, M, C, k, V, U) {
          const q = C - V, $ = k - U;
          return Math.abs((k - M) * q - (C - I) * $) / Math.hypot(q, $);
        }(A.x, A.y, l.x, l.y, f.x, f.y) >= S ? (_(r, e, n, D, x, l, A, v, S), _(r, D, x, o, u, A, f, v, S)) : r.push(f);
      }
      function y(r, e, n) {
        let o = r[0], u = o.x, l = o.y;
        e(o);
        const f = [o];
        for (let v = 1; v < r.length; v++) {
          const S = r[v], { x: D, y: x } = S;
          e(S), _(f, u, l, D, x, o, S, e, n), u = D, l = x, o = S;
        }
        return f;
      }
      function T(r, e, n, o) {
        if (o(e, n)) {
          const u = e.add(n)._mult(0.5);
          T(r, e, u, o), T(r, u, n, o);
        } else
          r.push(n);
      }
      function z(r, e) {
        let n = r[0];
        const o = [n];
        for (let u = 1; u < r.length; u++) {
          const l = r[u];
          T(o, n, l, e), n = l;
        }
        return o;
      }
      const R = Math.pow(2, 14) - 1, F = -R - 1;
      function N(r, e) {
        const n = Math.round(r.x * e), o = Math.round(r.y * e);
        return r.x = si(n, F, R), r.y = si(o, F, R), (n < r.x || n > r.x + 1 || o < r.y || o > r.y + 1) && mi("Geometry exceeds allowed extent, reduce your vector tile buffer size"), r;
      }
      function G(r, e, n) {
        const o = r.loadGeometry(), u = r.extent, l = Tt / u;
        if (e && n && n.projection.isReprojectedInTileSpace) {
          const f = 1 << e.z, { scale: v, x: S, y: D, projection: x } = n, A = (I) => {
            const M = Fr((e.x + I.x / u) / f), C = Os((e.y + I.y / u) / f), k = x.project(M, C);
            I.x = (k.x * v - S) * u, I.y = (k.y * v - D) * u;
          };
          for (let I = 0; I < o.length; I++)
            if (r.type !== 1)
              o[I] = y(o[I], A, 1);
            else {
              const M = [];
              for (const C of o[I])
                C.x < 0 || C.x >= u || C.y < 0 || C.y >= u || (A(C), M.push(C));
              o[I] = M;
            }
        }
        for (const f of o)
          for (const v of f)
            N(v, l);
        return o;
      }
      function Z(r, e) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: e ? G(r) : [] };
      }
      function W(r, e, n, o, u) {
        r.emplaceBack(2 * e + (o + 1) / 2, 2 * n + (u + 1) / 2);
      }
      function te(r, e, n) {
        r.emplaceBack(e.x, e.y, e.z, n[0] * 16384, n[1] * 16384, n[2] * 16384);
      }
      class ee {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Lo(), this.indexArray = new qs(), this.segments = new Wn(), this.programConfigurations = new Qa(e.layers, { zoom: e.zoom, lut: e.lut }), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          const l = this.layers[0], f = [];
          let v = null;
          l.type === "circle" && (v = l.layout.get("circle-sort-key"));
          for (const { feature: D, id: x, index: A, sourceLayerIndex: I } of e) {
            const M = this.layers[0]._featureFilter.needGeometry, C = Z(D, M);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), C, o))
              continue;
            const k = v ? v.evaluate(C, {}, o) : void 0, V = { id: x, properties: D.properties, type: D.type, sourceLayerIndex: I, index: A, geometry: M ? C.geometry : G(D, o, u), patterns: {}, sortKey: k };
            f.push(V);
          }
          v && f.sort((D, x) => D.sortKey - x.sortKey);
          let S = null;
          u.projection.name === "globe" && (this.globeExtVertexArray = new pu(), S = u.projection);
          for (const D of f) {
            const { geometry: x, index: A, sourceLayerIndex: I } = D, M = e[A].feature;
            this.addFeature(D, x, A, n.availableImages, o, S, n.brightness), n.featureIndex.insert(M, x, A, I, this.index);
          }
        }
        update(e, n, o, u, l, f, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, r_.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Dd.members))), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(e, n, o, u, l, f, v) {
          for (const S of n)
            for (const D of S) {
              const x = D.x, A = D.y;
              if (x < 0 || x >= Tt || A < 0 || A >= Tt)
                continue;
              if (f) {
                const C = f.projectTilePoint(x, A, l), k = f.upVector(l, x, A), V = this.globeExtVertexArray;
                te(V, C, k), te(V, C, k), te(V, C, k), te(V, C, k);
              }
              const I = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), M = I.vertexLength;
              W(this.layoutVertexArray, x, A, -1, -1), W(this.layoutVertexArray, x, A, 1, -1), W(this.layoutVertexArray, x, A, 1, 1), W(this.layoutVertexArray, x, A, -1, 1), this.indexArray.emplaceBack(M, M + 1, M + 2), this.indexArray.emplaceBack(M, M + 2, M + 3), I.vertexLength += 4, I.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, {}, u, l, v);
        }
      }
      function se(r, e) {
        for (let n = 0; n < r.length; n++)
          if (Pe(e, r[n]))
            return !0;
        for (let n = 0; n < e.length; n++)
          if (Pe(r, e[n]))
            return !0;
        return !!pe(r, e);
      }
      function oe(r, e, n) {
        return !!Pe(r, e) || !!xe(e, r, n);
      }
      function he(r, e) {
        if (r.length === 1)
          return ve(e, r[0]);
        for (let n = 0; n < e.length; n++) {
          const o = e[n];
          for (let u = 0; u < o.length; u++)
            if (Pe(r, o[u]))
              return !0;
        }
        for (let n = 0; n < r.length; n++)
          if (ve(e, r[n]))
            return !0;
        for (let n = 0; n < e.length; n++)
          if (pe(r, e[n]))
            return !0;
        return !1;
      }
      function _e(r, e, n) {
        if (r.length > 1) {
          if (pe(r, e))
            return !0;
          for (let o = 0; o < e.length; o++)
            if (xe(e[o], r, n))
              return !0;
        }
        for (let o = 0; o < r.length; o++)
          if (xe(r[o], e, n))
            return !0;
        return !1;
      }
      function pe(r, e) {
        if (r.length === 0 || e.length === 0)
          return !1;
        for (let n = 0; n < r.length - 1; n++) {
          const o = r[n], u = r[n + 1];
          for (let l = 0; l < e.length - 1; l++)
            if (Me(o, u, e[l], e[l + 1]))
              return !0;
        }
        return !1;
      }
      function Me(r, e, n, o) {
        return On(r, n, o) !== On(e, n, o) && On(r, e, n) !== On(r, e, o);
      }
      function xe(r, e, n) {
        const o = n * n;
        if (e.length === 1)
          return r.distSqr(e[0]) < o;
        for (let u = 1; u < e.length; u++)
          if (we(r, e[u - 1], e[u]) < o)
            return !0;
        return !1;
      }
      function we(r, e, n) {
        const o = e.distSqr(n);
        if (o === 0)
          return r.distSqr(e);
        const u = ((r.x - e.x) * (n.x - e.x) + (r.y - e.y) * (n.y - e.y)) / o;
        return r.distSqr(u < 0 ? e : u > 1 ? n : n.sub(e)._mult(u)._add(e));
      }
      function ve(r, e) {
        let n, o, u, l = !1;
        for (let f = 0; f < r.length; f++) {
          n = r[f];
          for (let v = 0, S = n.length - 1; v < n.length; S = v++)
            o = n[v], u = n[S], o.y > e.y != u.y > e.y && e.x < (u.x - o.x) * (e.y - o.y) / (u.y - o.y) + o.x && (l = !l);
        }
        return l;
      }
      function Pe(r, e) {
        let n = !1;
        for (let o = 0, u = r.length - 1; o < r.length; u = o++) {
          const l = r[o], f = r[u];
          l.y > e.y != f.y > e.y && e.x < (f.x - l.x) * (e.y - l.y) / (f.y - l.y) + l.x && (n = !n);
        }
        return n;
      }
      function Oe(r, e, n, o, u) {
        for (const f of r)
          if (e <= f.x && n <= f.y && o >= f.x && u >= f.y)
            return !0;
        const l = [new Et(e, n), new Et(e, u), new Et(o, u), new Et(o, n)];
        if (r.length > 2) {
          for (const f of l)
            if (Pe(r, f))
              return !0;
        }
        for (let f = 0; f < r.length - 1; f++)
          if (Xe(r[f], r[f + 1], l))
            return !0;
        return !1;
      }
      function Xe(r, e, n) {
        const o = n[0], u = n[2];
        if (r.x < o.x && e.x < o.x || r.x > u.x && e.x > u.x || r.y < o.y && e.y < o.y || r.y > u.y && e.y > u.y)
          return !1;
        const l = On(r, e, n[0]);
        return l !== On(r, e, n[1]) || l !== On(r, e, n[2]) || l !== On(r, e, n[3]);
      }
      function He(r, e, n, o, u, l) {
        let f = e.y - r.y, v = r.x - e.x;
        if (l = l || 0) {
          const S = f * f + v * v;
          if (S === 0)
            return !0;
          const D = Math.sqrt(S);
          f /= D, v /= D;
        }
        return !((n.x - r.x) * f + (n.y - r.y) * v - l < 0 || (o.x - r.x) * f + (o.y - r.y) * v - l < 0 || (u.x - r.x) * f + (u.y - r.y) * v - l < 0);
      }
      function ke(r, e, n, o, u, l, f) {
        return !(He(r, e, o, u, l, f) || He(e, n, o, u, l, f) || He(n, r, o, u, l, f) || He(o, u, r, e, n, f) || He(u, l, r, e, n, f) || He(l, o, r, e, n, f));
      }
      function Ne(r, e, n) {
        const o = e.paint.get(r).value;
        return o.kind === "constant" ? o.value : n.programConfigurations.get(e.id).getMaxValue(r);
      }
      function st(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function ut(r, e, n, o, u) {
        if (!e[0] && !e[1])
          return r;
        const l = Et.convert(e)._mult(u);
        n === "viewport" && l._rotate(-o);
        const f = [];
        for (let v = 0; v < r.length; v++)
          f.push(r[v].sub(l));
        return f;
      }
      function xt(r, e, n, o) {
        const u = Et.convert(r)._mult(o);
        return e === "viewport" && u._rotate(-n), u;
      }
      let Ge, lt;
      Ft(ee, "CircleBucket", { omit: ["layers"] });
      var Je, _t = { exports: {} }, ct = (Je || (Je = 1, function(r, e) {
        (function(n) {
          function o(l, f, v) {
            var S = u(256 * l, 256 * (f = Math.pow(2, v) - f - 1), v), D = u(256 * (l + 1), 256 * (f + 1), v);
            return S[0] + "," + S[1] + "," + D[0] + "," + D[1];
          }
          function u(l, f, v) {
            var S = 2 * Math.PI * 6378137 / 256 / Math.pow(2, v);
            return [l * S - 2 * Math.PI * 6378137 / 2, f * S - 2 * Math.PI * 6378137 / 2];
          }
          n.getURL = function(l, f, v, S, D, x) {
            return x = x || {}, l + "?" + ["bbox=" + o(v, S, D), "format=" + (x.format || "image/png"), "service=" + (x.service || "WMS"), "version=" + (x.version || "1.1.1"), "request=" + (x.request || "GetMap"), "srs=" + (x.srs || "EPSG:3857"), "width=" + (x.width || 256), "height=" + (x.height || 256), "layers=" + f].join("&");
          }, n.getTileBBox = o, n.getMercCoords = u, Object.defineProperty(n, "__esModule", { value: !0 });
        })(e);
      }(0, _t.exports)), _t.exports);
      class nt {
        constructor(e, n, o) {
          this.z = e, this.x = n, this.y = o, this.key = zt(0, e, e, n, o);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, n) {
          const o = ct.getTileBBox(this.x, this.y, this.z), u = function(l, f, v) {
            let S, D = "";
            for (let x = l; x > 0; x--)
              S = 1 << x - 1, D += (f & S ? 1 : 0) + (v & S ? 2 : 0);
            return D;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", o);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Lt {
        constructor(e, n) {
          this.wrap = e, this.canonical = n, this.key = zt(e, n.z, n.z, n.x, n.y);
        }
      }
      class bt {
        constructor(e, n, o, u, l) {
          this.overscaledZ = e, this.wrap = n, this.canonical = new nt(o, +u, +l), this.key = n === 0 && e === o ? this.canonical.key : zt(n, e, o, u, l);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          const n = this.canonical.z - e;
          return e > this.canonical.z ? new bt(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new bt(e, this.wrap, e, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(e, n = !0) {
          if (this.overscaledZ === e && n)
            return this.key;
          if (e > this.canonical.z)
            return zt(this.wrap * +n, e, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const o = this.canonical.z - e;
            return zt(this.wrap * +n, e, e, this.canonical.x >> o, this.canonical.y >> o);
          }
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap)
            return !1;
          const n = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> n && e.canonical.y === this.canonical.y >> n;
        }
        children(e) {
          if (this.overscaledZ >= e)
            return [new bt(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, o = 2 * this.canonical.x, u = 2 * this.canonical.y;
          return [new bt(n, this.wrap, n, o, u), new bt(n, this.wrap, n, o + 1, u), new bt(n, this.wrap, n, o, u + 1), new bt(n, this.wrap, n, o + 1, u + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new bt(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new bt(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Lt(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function zt(r, e, n, o, u) {
        const l = 1 << Math.min(n, 22);
        let f = l * (u % l) + o % l;
        return r && n < 22 && (f += l * l * ((r < 0 ? -2 * r - 1 : 2 * r) % (1 << 2 * (22 - n)))), 16 * (32 * f + n) + (e - n);
      }
      const Bt = [(r) => {
        let e = r.canonical.x - 1, n = r.wrap;
        return e < 0 && (e = (1 << r.canonical.z) - 1, n--), new bt(r.overscaledZ, n, r.canonical.z, e, r.canonical.y);
      }, (r) => {
        let e = r.canonical.x + 1, n = r.wrap;
        return e === 1 << r.canonical.z && (e = 0, n++), new bt(r.overscaledZ, n, r.canonical.z, e, r.canonical.y);
      }, (r) => new bt(r.overscaledZ, r.wrap, r.canonical.z, r.canonical.x, (r.canonical.y === 0 ? 1 << r.canonical.z : r.canonical.y) - 1), (r) => new bt(r.overscaledZ, r.wrap, r.canonical.z, r.canonical.x, r.canonical.y === (1 << r.canonical.z) - 1 ? 0 : r.canonical.y + 1)];
      Ft(nt, "CanonicalTileID"), Ft(bt, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      const oi = qi([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: $t } = oi, Xt = qi([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var ai = qi([{ name: "a_pos", type: "Int16", components: 2 }]);
      class zi {
        constructor(e, n) {
          this.pos = e, this.dir = n;
        }
        intersectsPlane(e, n, o) {
          const u = De.vec3.dot(n, this.dir);
          if (Math.abs(u) < 1e-6)
            return !1;
          const l = ((e[0] - this.pos[0]) * n[0] + (e[1] - this.pos[1]) * n[1] + (e[2] - this.pos[2]) * n[2]) / u;
          return o[0] = this.pos[0] + this.dir[0] * l, o[1] = this.pos[1] + this.dir[1] * l, o[2] = this.pos[2] + this.dir[2] * l, !0;
        }
        closestPointOnSphere(e, n, o) {
          if (De.vec3.equals(this.pos, e) || n === 0)
            return o[0] = o[1] = o[2] = 0, !1;
          const [u, l, f] = this.dir, v = this.pos[0] - e[0], S = this.pos[1] - e[1], D = this.pos[2] - e[2], x = u * u + l * l + f * f, A = 2 * (v * u + S * l + D * f), I = A * A - 4 * x * (v * v + S * S + D * D - n * n);
          if (I < 0) {
            const M = Math.max(-A / 2, 0), C = v + u * M, k = S + l * M, V = D + f * M, U = Math.hypot(C, k, V);
            return o[0] = C * n / U, o[1] = k * n / U, o[2] = V * n / U, !1;
          }
          {
            const M = (-A - Math.sqrt(I)) / (2 * x);
            if (M < 0) {
              const C = Math.hypot(v, S, D);
              return o[0] = v * n / C, o[1] = S * n / C, o[2] = D * n / C, !1;
            }
            return o[0] = v + u * M, o[1] = S + l * M, o[2] = D + f * M, !0;
          }
        }
      }
      class wi {
        constructor(e, n, o, u, l) {
          this.TL = e, this.TR = n, this.BR = o, this.BL = u, this.horizon = l;
        }
        static fromInvProjectionMatrix(e, n, o) {
          const u = [-1, 1, 1], l = [1, 1, 1], f = [1, -1, 1], v = [-1, -1, 1], S = De.vec3.transformMat4(u, u, e), D = De.vec3.transformMat4(l, l, e), x = De.vec3.transformMat4(f, f, e), A = De.vec3.transformMat4(v, v, e);
          return new wi(S, D, x, A, n / o);
        }
      }
      function mn(r, e, n) {
        let o = 1 / 0, u = -1 / 0;
        const l = [];
        for (const f of r) {
          De.vec3.sub(l, f, e);
          const v = De.vec3.dot(l, n);
          o = Math.min(o, v), u = Math.max(u, v);
        }
        return [o, u];
      }
      function Mn(r, e) {
        let n = !0;
        for (let o = 0; o < r.planes.length; o++) {
          const u = r.planes[o];
          let l = 0;
          for (let f = 0; f < e.length; f++)
            l += De.vec3.dot(u, e[f]) + u[3] >= 0;
          if (l === 0)
            return 0;
          l !== e.length && (n = !1);
        }
        return n ? 2 : 1;
      }
      function Xi(r, e) {
        for (const n of r.projections) {
          const o = mn(e, r.points[0], n.axis);
          if (n.projection[1] < o[0] || n.projection[0] > o[1])
            return 0;
        }
        return 1;
      }
      function sn(r, e) {
        let n = 0;
        const o = [0, 0, 0, 0];
        for (let u = 0; u < r.length; u++)
          o[0] = r[u][0], o[1] = r[u][1], o[2] = r[u][2], o[3] = 1, De.vec4.dot(o, e) >= 0 && n++;
        return n;
      }
      class _i {
        constructor(e, n) {
          this.points = e || new Array(8).fill([0, 0, 0]), this.planes = n || new Array(6).fill([0, 0, 0, 0]), this.bounds = Jt.fromPoints(this.points), this.projections = [], this.frustumEdges = [De.vec3.sub([], this.points[2], this.points[3]), De.vec3.sub([], this.points[0], this.points[3]), De.vec3.sub([], this.points[4], this.points[0]), De.vec3.sub([], this.points[5], this.points[1]), De.vec3.sub([], this.points[6], this.points[2]), De.vec3.sub([], this.points[7], this.points[3])];
          for (const o of this.frustumEdges) {
            const u = [0, -o[2], o[1]], l = [o[2], 0, -o[0]];
            this.projections.push({ axis: u, projection: mn(this.points, this.points[0], u) }), this.projections.push({ axis: l, projection: mn(this.points, this.points[0], l) });
          }
        }
        static fromInvProjectionMatrix(e, n, o, u) {
          const l = Math.pow(2, o), f = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((D) => {
            const x = De.vec4.transformMat4([], D, e), A = 1 / x[3] / n * l;
            return De.vec4.mul(x, x, [A, A, u ? 1 / x[3] : A, A]);
          }), v = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((D) => {
            const x = De.vec3.sub([], f[D[0]], f[D[1]]), A = De.vec3.sub([], f[D[2]], f[D[1]]), I = De.vec3.normalize([], De.vec3.cross([], x, A)), M = -De.vec3.dot(I, f[D[1]]);
            return I.concat(M);
          }), S = [];
          for (let D = 0; D < f.length; D++)
            S.push([f[D][0], f[D][1], f[D][2]]);
          return new _i(S, v);
        }
        intersectsPrecise(e, n, o) {
          for (let u = 0; u < n.length; u++)
            if (!sn(e, n[u]))
              return 0;
          for (let u = 0; u < this.planes.length; u++)
            if (!sn(e, this.planes[u]))
              return 0;
          for (const u of o)
            for (const l of this.frustumEdges) {
              const f = De.vec3.cross([], u, l), v = De.vec3.length(f);
              if (v === 0)
                continue;
              De.vec3.scale(f, f, 1 / v);
              const S = mn(this.points, this.points[0], f), D = mn(e, this.points[0], f);
              if (S[0] > D[1] || D[0] > S[1])
                return 0;
            }
          return 1;
        }
        containsPoint(e) {
          for (const n of this.planes) {
            const o = n[3];
            if (De.vec3.dot([n[0], n[1], n[2]], e) + o < 0)
              return !1;
          }
          return !0;
        }
      }
      class Jt {
        static fromPoints(e) {
          const n = [1 / 0, 1 / 0, 1 / 0], o = [-1 / 0, -1 / 0, -1 / 0];
          for (const u of e)
            De.vec3.min(n, n, u), De.vec3.max(o, o, u);
          return new Jt(n, o);
        }
        static fromTileIdAndHeight(e, n, o) {
          const u = 1 << e.canonical.z, l = e.canonical.x, f = e.canonical.y;
          return new Jt([l / u, f / u, n], [(l + 1) / u, (f + 1) / u, o]);
        }
        static applyTransform(e, n) {
          const o = e.getCorners();
          for (let u = 0; u < o.length; ++u)
            De.vec3.transformMat4(o[u], o[u], n);
          return Jt.fromPoints(o);
        }
        static applyTransformFast(e, n) {
          const o = [n[12], n[13], n[14]], u = [...o];
          for (let l = 0; l < 3; l++)
            for (let f = 0; f < 3; f++) {
              const v = n[4 * f + l], S = v * e.min[f], D = v * e.max[f];
              o[l] += Math.min(S, D), u[l] += Math.max(S, D);
            }
          return new Jt(o, u);
        }
        static projectAabbCorners(e, n) {
          const o = e.getCorners();
          for (let u = 0; u < o.length; ++u)
            De.vec3.transformMat4(o[u], o[u], n);
          return o;
        }
        constructor(e, n) {
          this.min = e, this.max = n, this.center = De.vec3.scale([], De.vec3.add([], this.min, this.max), 0.5);
        }
        quadrant(e) {
          const n = [e % 2 == 0, e < 2], o = De.vec3.clone(this.min), u = De.vec3.clone(this.max);
          for (let l = 0; l < n.length; l++)
            o[l] = n[l] ? this.min[l] : this.center[l], u[l] = n[l] ? this.center[l] : this.max[l];
          return u[2] = this.max[2], new Jt(o, u);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        distanceZ(e) {
          return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2];
        }
        getCorners() {
          const e = this.min, n = this.max;
          return [[e[0], e[1], e[2]], [n[0], e[1], e[2]], [n[0], n[1], e[2]], [e[0], n[1], e[2]], [e[0], e[1], n[2]], [n[0], e[1], n[2]], [n[0], n[1], n[2]], [e[0], n[1], n[2]]];
        }
        intersects(e) {
          return this.intersectsAabb(e.bounds) ? Mn(e, this.getCorners()) : 0;
        }
        intersectsFlat(e) {
          return this.intersectsAabb(e.bounds) ? Mn(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(e, n) {
          return n || this.intersects(e) ? Xi(e, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(e, n) {
          return n || this.intersectsFlat(e) ? Xi(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(e) {
          for (let n = 0; n < 3; ++n)
            if (this.min[n] > e.max[n] || e.min[n] > this.max[n])
              return !1;
          return !0;
        }
        intersectsAabbXY(e) {
          return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1]);
        }
        encapsulate(e) {
          for (let n = 0; n < 3; n++)
            this.min[n] = Math.min(this.min[n], e.min[n]), this.max[n] = Math.max(this.max[n], e.max[n]);
        }
        encapsulatePoint(e) {
          for (let n = 0; n < 3; n++)
            this.min[n] = Math.min(this.min[n], e[n]), this.max[n] = Math.max(this.max[n], e[n]);
        }
        closestPoint(e) {
          return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])];
        }
      }
      function ji(r) {
        return r * dr / _c;
      }
      Ft(Jt, "Aabb");
      const Yi = [new Jt([uo, uo, uo], [fo, fo, fo]), new Jt([uo, uo, uo], [0, 0, fo]), new Jt([0, uo, uo], [fo, 0, fo]), new Jt([uo, 0, uo], [0, fo, fo]), new Jt([0, 0, uo], [fo, fo, fo])];
      function In(r, e, n, o = !0) {
        const u = De.vec3.scale([], r._camera.position, r.worldSize), l = [e, n, 1, 1];
        De.vec4.transformMat4(l, l, r.pixelMatrixInverse), De.vec4.scale(l, l, 1 / l[3]);
        const f = De.vec3.sub([], l, u), v = De.vec3.normalize([], f), S = r.globeMatrix, D = [S[12], S[13], S[14]], x = De.vec3.sub([], D, u), A = De.vec3.length(x), I = De.vec3.normalize([], x), M = r.worldSize / (2 * Math.PI), C = De.vec3.dot(I, v), k = Math.asin(M / A);
        if (k < Math.acos(C)) {
          if (!o)
            return null;
          const Se = [], me = [];
          De.vec3.scale(Se, v, A / C), De.vec3.normalize(me, De.vec3.sub(me, Se, x)), De.vec3.normalize(v, De.vec3.add(v, x, De.vec3.scale(v, me, Math.tan(k) * A)));
        }
        const V = [];
        new zi(u, v).closestPointOnSphere(D, M, V);
        const U = De.vec3.normalize([], zs(S, 0)), q = De.vec3.normalize([], zs(S, 1)), $ = De.vec3.normalize([], zs(S, 2)), H = De.vec3.dot(U, V), K = De.vec3.dot(q, V), Q = De.vec3.dot($, V), ie = kn(Math.asin(-K / M));
        let fe = kn(Math.atan2(H, Q));
        fe = r.center.lng + function(Se, me) {
          const Ee = (me - Se + 180) % 360 - 180;
          return Ee < -180 ? Ee + 360 : Ee;
        }(r.center.lng, fe);
        const de = ta(fe), ue = si(Ta(ie), 0, 1);
        return new h(de, ue);
      }
      class Fs {
        constructor(e, n, o) {
          this.a = De.vec3.sub([], e, o), this.b = De.vec3.sub([], n, o), this.center = o;
          const u = De.vec3.normalize([], this.a), l = De.vec3.normalize([], this.b);
          this.angle = Math.acos(De.vec3.dot(u, l));
        }
      }
      function pr(r, e) {
        if (r.angle === 0)
          return null;
        let n;
        return n = r.a[e] === 0 ? 1 / r.angle * 0.5 * Math.PI : 1 / r.angle * Math.atan(r.b[e] / r.a[e] / Math.sin(r.angle) - 1 / Math.tan(r.angle)), n < 0 || n > 1 ? null : function(o, u, l, f) {
          const v = Math.sin(l);
          return o * (Math.sin((1 - f) * l) / v) + u * (Math.sin(f * l) / v);
        }(r.a[e], r.b[e], r.angle, si(n, 0, 1)) + r.center[e];
      }
      function ts(r) {
        if (r.z <= 1)
          return Yi[r.z + 2 * r.y + r.x];
        const e = _n(dn(r));
        return Jt.fromPoints(e);
      }
      function As(r, e, n) {
        return De.vec3.scale(r, r, 1 - n), De.vec3.scaleAndAdd(r, r, e, n);
      }
      function Qs(r, e, n) {
        for (const o of r)
          De.vec3.transformMat4(o, o, e), De.vec3.scale(o, o, n);
      }
      function jn(r, e, n, o) {
        const u = e / r.worldSize, l = r.globeMatrix;
        if (n.z <= 1) {
          const de = ts(n).getCorners();
          return Qs(de, l, u), Jt.fromPoints(de);
        }
        const f = dn(n, o), v = _n(f, dr + ji(r._tileCoverLift));
        Qs(v, l, u);
        const S = Number.MAX_VALUE, D = [-S, -S, -S], x = [S, S, S];
        if (f.contains(r.center)) {
          for (const Se of v)
            De.vec3.min(x, x, Se), De.vec3.max(D, D, Se);
          D[2] = 0;
          const de = r.point, ue = [de.x * u, de.y * u, 0];
          return De.vec3.min(x, x, ue), De.vec3.max(D, D, ue), new Jt(x, D);
        }
        if (r._tileCoverLift > 0) {
          for (const de of v)
            De.vec3.min(x, x, de), De.vec3.max(D, D, de);
          return new Jt(x, D);
        }
        const A = [l[12] * u, l[13] * u, l[14] * u], I = f.getCenter(), M = si(r.center.lat, -Un, Un), C = si(I.lat, -Un, Un), k = ta(r.center.lng), V = Ta(M);
        let U = k - ta(I.lng);
        const q = V - Ta(C);
        U > 0.5 ? U -= 1 : U < -0.5 && (U += 1);
        let $ = 0;
        if (Math.abs(U) > Math.abs(q))
          $ = U >= 0 ? 1 : 3;
        else {
          $ = q >= 0 ? 0 : 2;
          const de = [l[4] * u, l[5] * u, l[6] * u], ue = -Math.sin(vi(q >= 0 ? f.getSouth() : f.getNorth())) * dr;
          De.vec3.scaleAndAdd(A, A, de, ue);
        }
        const H = v[$], K = v[($ + 1) % 4], Q = new Fs(H, K, A), ie = [pr(Q, 0) || H[0], pr(Q, 1) || H[1], pr(Q, 2) || H[2]], fe = mr(r.zoom);
        if (fe > 0) {
          const de = function({ x: Se, y: me, z: Ee }, ze, Ie, Re, Ve) {
            const Ue = 1 / (1 << Ee);
            let Fe = Se * Ue, et = Fe + Ue, dt = me * Ue, tt = dt + Ue, Mt = 0;
            const wt = (Fe + et) / 2 - Re;
            return wt > 0.5 ? Mt = -1 : wt < -0.5 && (Mt = 1), Fe = ((Fe + Mt) * ze - (Re *= ze)) * Ie + Re, et = ((et + Mt) * ze - Re) * Ie + Re, dt = (dt * ze - (Ve *= ze)) * Ie + Ve, tt = (tt * ze - Ve) * Ie + Ve, [[Fe, tt, 0], [et, tt, 0], [et, dt, 0], [Fe, dt, 0]];
          }(n, e, r._pixelsPerMercatorPixel, k, V);
          for (let Se = 0; Se < v.length; Se++)
            As(v[Se], de[Se], fe);
          const ue = De.vec3.add([], de[$], de[($ + 1) % 4]);
          De.vec3.scale(ue, ue, 0.5), As(ie, ue, fe);
        }
        for (const de of v)
          De.vec3.min(x, x, de), De.vec3.max(D, D, de);
        return x[2] = Math.min(H[2], K[2]), De.vec3.min(x, x, ie), De.vec3.max(D, D, ie), new Jt(x, D);
      }
      function dn({ x: r, y: e, z: n }, o = !1) {
        const u = 1 / (1 << n), l = new Ui(Fr(r * u), e === (1 << n) - 1 && o ? -90 : Os((e + 1) * u)), f = new Ui(Fr((r + 1) * u), e === 0 && o ? 90 : Os(e * u));
        return new tl(l, f);
      }
      function _n(r, e = dr) {
        const n = vi(r.getNorth()), o = vi(r.getSouth()), u = Math.cos(n), l = Math.cos(o), f = Math.sin(n), v = Math.sin(o), S = r.getWest(), D = r.getEast();
        return [mc(l, v, S, e), mc(l, v, D, e), mc(u, f, D, e), mc(u, f, S, e)];
      }
      function Ri(r, e, n, o) {
        const u = 1 << n.z, l = (r / Tt + n.x) / u;
        return el(Os((e / Tt + n.y) / u), Fr(l), o);
      }
      function Gn({ min: r, max: e }) {
        return yp / Math.max(e[0] - r[0], e[1] - r[1], e[2] - r[2]);
      }
      const Bs = new Float64Array(16);
      function cn(r) {
        const e = Gn(r), n = De.mat4.fromScaling(Bs, [e, e, e]);
        return De.mat4.translate(n, n, De.vec3.negate([], r.min));
      }
      function er(r) {
        const e = De.mat4.fromTranslation(Bs, r.min), n = 1 / Gn(r);
        return De.mat4.scale(e, e, [n, n, n]);
      }
      function eo(r) {
        const e = Tt / (2 * Math.PI);
        return r / (2 * Math.PI) / e;
      }
      function Br(r, e) {
        return Tt / (512 * Math.pow(2, r)) * Gn(ts(e));
      }
      function Ma(r, e, n, o, u) {
        const l = eo(n), f = [r, e, -n / (2 * Math.PI)], v = De.mat4.identity(new Float64Array(16));
        return De.mat4.translate(v, v, f), De.mat4.scale(v, v, [l, l, l]), De.mat4.rotateX(v, v, vi(-u)), De.mat4.rotateY(v, v, vi(-o)), v;
      }
      function mr(r) {
        return fs(Su, gp, r);
      }
      function ko(r, e) {
        const n = el(e.lat, e.lng), o = function(l) {
          const f = el(l._center.lat, l._center.lng), v = De.vec3.fromValues(0, 1, 0);
          let S = De.vec3.cross([], v, f);
          const D = De.mat4.fromRotation([], -l.angle, f);
          S = De.vec3.transformMat4(S, S, D), De.mat4.fromRotation(D, -l._pitch, S);
          const x = De.vec3.normalize([], f);
          return De.vec3.scale(x, x, ji(l.cameraToCenterDistance / l.pixelsPerMeter)), De.vec3.transformMat4(x, x, D), De.vec3.add([], f, x);
        }(r), u = De.vec3.subtract([], o, n);
        return De.vec3.angle(u, n);
      }
      function Nr(r, e) {
        return ko(r, e) > Math.PI / 2 * 1.01;
      }
      const il = vi(85), ia = Math.cos(il), Ll = Math.sin(il), yh = De.mat4.create(), Au = (r) => {
        const e = [];
        return r.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), r.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e;
      };
      function Pu(r, e, n, o, u, l, f, v, S) {
        if (l && r.queryGeometry.isAboveHorizon)
          return !1;
        l && (S *= r.pixelToTileUnitsFactor);
        const D = r.tileID.canonical, x = n.projection.upVectorScale(D, n.center.lat, n.worldSize).metersToTile;
        for (const A of e)
          for (const I of A) {
            const M = I.add(v), C = u && n.elevation ? n.elevation.exaggeration() * u.getElevationAt(M.x, M.y, !0) : 0, k = n.projection.projectTilePoint(M.x, M.y, D);
            if (C > 0) {
              const $ = n.projection.upVector(D, M.x, M.y);
              k.x += $[0] * x * C, k.y += $[1] * x * C, k.z += $[2] * x * C;
            }
            const V = l ? M : Ew(k.x, k.y, k.z, o), U = l ? r.tilespaceRays.map(($) => Pw($, C)) : r.queryGeometry.screenGeometry, q = De.vec4.transformMat4([], [k.x, k.y, k.z, 1], o);
            if (!f && l ? S *= q[3] / n.cameraToCenterDistance : f && !l && (S *= n.cameraToCenterDistance / q[3]), l) {
              const $ = Os((I.y / Tt + D.y) / (1 << D.z));
              S /= n.projection.pixelsPerMeter($, 1) / fr(1, $);
            }
            if (oe(U, V, S))
              return !0;
          }
        return !1;
      }
      function Ew(r, e, n, o) {
        const u = De.vec4.transformMat4([], [r, e, n, 1], o);
        return new Et(u[0] / u[3], u[1] / u[3]);
      }
      const My = De.vec3.fromValues(0, 0, 0), Aw = De.vec3.fromValues(0, 0, 1);
      function Pw(r, e) {
        const n = De.vec3.create();
        return My[2] = e, r.intersectsPlane(My, Aw, n), new Et(n[0], n[1]);
      }
      class Sy extends ee {
      }
      let Ey, Ay, Py, Cy;
      function Iy(r, { width: e, height: n }, o, u) {
        if (u) {
          if (u instanceof Uint8ClampedArray)
            u = new Uint8Array(u.buffer);
          else if (u.length !== e * n * o)
            throw new RangeError("mismatched image size");
        } else
          u = new Uint8Array(e * n * o);
        return r.width = e, r.height = n, r.data = u, r;
      }
      function Ly(r, e, n) {
        const { width: o, height: u } = e;
        o === r.width && u === r.height || (m_(r, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, o), height: Math.min(r.height, u) }, n, null), r.width = o, r.height = u, r.data = e.data);
      }
      function m_(r, e, n, o, u, l, f, v) {
        if (u.width === 0 || u.height === 0)
          return e;
        if (u.width > r.width || u.height > r.height || n.x > r.width - u.width || n.y > r.height - u.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (u.width > e.width || u.height > e.height || o.x > e.width - u.width || o.y > e.height - u.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const S = r.data, D = e.data, x = l === 4 && v;
        for (let A = 0; A < u.height; A++) {
          const I = ((n.y + A) * r.width + n.x) * l, M = ((o.y + A) * e.width + o.x) * l;
          if (x)
            for (let C = 0; C < u.width; C++) {
              const k = I + C * l + 3, V = M + C * l;
              D[V + 0] = 255, D[V + 1] = 255, D[V + 2] = 255, D[V + 3] = S[k];
            }
          else if (f)
            for (let C = 0; C < u.width; C++) {
              const k = I + C * l, V = M + C * l, U = S[k + 3], q = new ki(S[k + 0] / 255 * U, S[k + 1] / 255 * U, S[k + 2] / 255 * U, U).toRenderColor(f).toArray();
              D[V + 0] = q[0], D[V + 1] = q[1], D[V + 2] = q[2], D[V + 3] = q[3];
            }
          else
            for (let C = 0; C < u.width * l; C++)
              D[M + C] = S[I + C];
        }
        return e;
      }
      Ft(Sy, "HeatmapBucket", { omit: ["layers"] });
      class gc {
        constructor(e, n) {
          Iy(this, e, 1, n);
        }
        resize(e) {
          Ly(this, new gc(e), 1);
        }
        clone() {
          return new gc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, l) {
          m_(e, n, o, u, l, 1, null);
        }
      }
      class _r {
        constructor(e, n) {
          Iy(this, e, 4, n);
        }
        resize(e) {
          Ly(this, new _r(e), 4);
        }
        replace(e, n) {
          n ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new _r({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, l, f, v) {
          m_(e, n, o, u, l, 4, f, v);
        }
      }
      class zy {
        constructor(e, n) {
          this.width = e.width, this.height = e.height, this.data = n instanceof Uint8Array ? new Float32Array(n.buffer) : n;
        }
      }
      function Bd(r) {
        const e = {}, n = r.resolution || 256, o = r.clips ? r.clips.length : 1, u = r.image || new _r({ width: n, height: o }), l = (f, v, S) => {
          e[r.evaluationKey] = S;
          const D = r.expression.evaluate(e);
          D && (u.data[f + v + 0] = Math.floor(255 * D.r / D.a), u.data[f + v + 1] = Math.floor(255 * D.g / D.a), u.data[f + v + 2] = Math.floor(255 * D.b / D.a), u.data[f + v + 3] = Math.floor(255 * D.a));
        };
        if (r.clips)
          for (let f = 0, v = 0; f < o; ++f, v += 4 * n)
            for (let S = 0, D = 0; S < n; S++, D += 4) {
              const x = S / (n - 1), { start: A, end: I } = r.clips[f];
              l(v, D, A * (1 - x) + I * x);
            }
        else
          for (let f = 0, v = 0; f < n; f++, v += 4)
            l(0, v, f / (n - 1));
        return u;
      }
      Ft(gc, "AlphaImage"), Ft(_r, "RGBAImage");
      const Cw = qi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Iw } = Cw;
      function Nd(r, e, n = 2) {
        const o = e && e.length, u = o ? e[0] * n : r.length;
        let l = Dy(r, 0, u, n, !0);
        const f = [];
        if (!l || l.next === l.prev)
          return f;
        let v, S, D;
        if (o && (l = function(x, A, I, M) {
          const C = [];
          for (let k = 0, V = A.length; k < V; k++) {
            const U = Dy(x, A[k] * M, k < V - 1 ? A[k + 1] * M : x.length, M, !1);
            U === U.next && (U.steiner = !0), C.push(Bw(U));
          }
          C.sort(Rw);
          for (let k = 0; k < C.length; k++)
            I = Ow(C[k], I);
          return I;
        }(r, e, l, n)), r.length > 80 * n) {
          v = 1 / 0, S = 1 / 0;
          let x = -1 / 0, A = -1 / 0;
          for (let I = n; I < u; I += n) {
            const M = r[I], C = r[I + 1];
            M < v && (v = M), C < S && (S = C), M > x && (x = M), C > A && (A = C);
          }
          D = Math.max(x - v, A - S), D = D !== 0 ? 32767 / D : 0;
        }
        return Vd(l, f, n, v, S, D, 0), f;
      }
      function Dy(r, e, n, o, u) {
        let l;
        if (u === function(f, v, S, D) {
          let x = 0;
          for (let A = v, I = S - D; A < S; A += D)
            x += (f[I] - f[A]) * (f[A + 1] + f[I + 1]), I = A;
          return x;
        }(r, e, n, o) > 0)
          for (let f = e; f < n; f += o)
            l = Oy(f / o | 0, r[f], r[f + 1], l);
        else
          for (let f = n - o; f >= e; f -= o)
            l = Oy(f / o | 0, r[f], r[f + 1], l);
        return l && bp(l, l.next) && (jd(l), l = l.next), l;
      }
      function xh(r, e) {
        if (!r)
          return r;
        e || (e = r);
        let n, o = r;
        do
          if (n = !1, o.steiner || !bp(o, o.next) && Ts(o.prev, o, o.next) !== 0)
            o = o.next;
          else {
            if (jd(o), o = e = o.prev, o === o.next)
              break;
            n = !0;
          }
        while (n || o !== e);
        return e;
      }
      function Vd(r, e, n, o, u, l, f) {
        if (!r)
          return;
        !f && l && function(S, D, x, A) {
          let I = S;
          do
            I.z === 0 && (I.z = __(I.x, I.y, D, x, A)), I.prevZ = I.prev, I.nextZ = I.next, I = I.next;
          while (I !== S);
          I.prevZ.nextZ = null, I.prevZ = null, function(M) {
            let C, k = 1;
            do {
              let V, U = M;
              M = null;
              let q = null;
              for (C = 0; U; ) {
                C++;
                let $ = U, H = 0;
                for (let Q = 0; Q < k && (H++, $ = $.nextZ, $); Q++)
                  ;
                let K = k;
                for (; H > 0 || K > 0 && $; )
                  H !== 0 && (K === 0 || !$ || U.z <= $.z) ? (V = U, U = U.nextZ, H--) : (V = $, $ = $.nextZ, K--), q ? q.nextZ = V : M = V, V.prevZ = q, q = V;
                U = $;
              }
              q.nextZ = null, k *= 2;
            } while (C > 1);
          }(I);
        }(r, o, u, l);
        let v = r;
        for (; r.prev !== r.next; ) {
          const S = r.prev, D = r.next;
          if (l ? zw(r, o, u, l) : Lw(r))
            e.push(S.i, r.i, D.i), jd(r), r = D.next, v = D.next;
          else if ((r = D) === v) {
            f ? f === 1 ? Vd(r = Dw(xh(r), e), e, n, o, u, l, 2) : f === 2 && kw(r, e, n, o, u, l) : Vd(xh(r), e, n, o, u, l, 1);
            break;
          }
        }
      }
      function Lw(r) {
        const e = r.prev, n = r, o = r.next;
        if (Ts(e, n, o) >= 0)
          return !1;
        const u = e.x, l = n.x, f = o.x, v = e.y, S = n.y, D = o.y, x = u < l ? u < f ? u : f : l < f ? l : f, A = v < S ? v < D ? v : D : S < D ? S : D, I = u > l ? u > f ? u : f : l > f ? l : f, M = v > S ? v > D ? v : D : S > D ? S : D;
        let C = o.next;
        for (; C !== e; ) {
          if (C.x >= x && C.x <= I && C.y >= A && C.y <= M && Cu(u, v, l, S, f, D, C.x, C.y) && Ts(C.prev, C, C.next) >= 0)
            return !1;
          C = C.next;
        }
        return !0;
      }
      function zw(r, e, n, o) {
        const u = r.prev, l = r, f = r.next;
        if (Ts(u, l, f) >= 0)
          return !1;
        const v = u.x, S = l.x, D = f.x, x = u.y, A = l.y, I = f.y, M = v < S ? v < D ? v : D : S < D ? S : D, C = x < A ? x < I ? x : I : A < I ? A : I, k = v > S ? v > D ? v : D : S > D ? S : D, V = x > A ? x > I ? x : I : A > I ? A : I, U = __(M, C, e, n, o), q = __(k, V, e, n, o);
        let $ = r.prevZ, H = r.nextZ;
        for (; $ && $.z >= U && H && H.z <= q; ) {
          if ($.x >= M && $.x <= k && $.y >= C && $.y <= V && $ !== u && $ !== f && Cu(v, x, S, A, D, I, $.x, $.y) && Ts($.prev, $, $.next) >= 0 || ($ = $.prevZ, H.x >= M && H.x <= k && H.y >= C && H.y <= V && H !== u && H !== f && Cu(v, x, S, A, D, I, H.x, H.y) && Ts(H.prev, H, H.next) >= 0))
            return !1;
          H = H.nextZ;
        }
        for (; $ && $.z >= U; ) {
          if ($.x >= M && $.x <= k && $.y >= C && $.y <= V && $ !== u && $ !== f && Cu(v, x, S, A, D, I, $.x, $.y) && Ts($.prev, $, $.next) >= 0)
            return !1;
          $ = $.prevZ;
        }
        for (; H && H.z <= q; ) {
          if (H.x >= M && H.x <= k && H.y >= C && H.y <= V && H !== u && H !== f && Cu(v, x, S, A, D, I, H.x, H.y) && Ts(H.prev, H, H.next) >= 0)
            return !1;
          H = H.nextZ;
        }
        return !0;
      }
      function Dw(r, e) {
        let n = r;
        do {
          const o = n.prev, u = n.next.next;
          !bp(o, u) && ky(o, n, n.next, u) && Ud(o, u) && Ud(u, o) && (e.push(o.i, n.i, u.i), jd(n), jd(n.next), n = r = u), n = n.next;
        } while (n !== r);
        return xh(n);
      }
      function kw(r, e, n, o, u, l) {
        let f = r;
        do {
          let v = f.next.next;
          for (; v !== f.prev; ) {
            if (f.i !== v.i && Nw(f, v)) {
              let S = Ry(f, v);
              return f = xh(f, f.next), S = xh(S, S.next), Vd(f, e, n, o, u, l, 0), void Vd(S, e, n, o, u, l, 0);
            }
            v = v.next;
          }
          f = f.next;
        } while (f !== r);
      }
      function Rw(r, e) {
        return r.x - e.x;
      }
      function Ow(r, e) {
        const n = function(u, l) {
          let f = l;
          const v = u.x, S = u.y;
          let D, x = -1 / 0;
          do {
            if (S <= f.y && S >= f.next.y && f.next.y !== f.y) {
              const k = f.x + (S - f.y) * (f.next.x - f.x) / (f.next.y - f.y);
              if (k <= v && k > x && (x = k, D = f.x < f.next.x ? f : f.next, k === v))
                return D;
            }
            f = f.next;
          } while (f !== l);
          if (!D)
            return null;
          const A = D, I = D.x, M = D.y;
          let C = 1 / 0;
          f = D;
          do {
            if (v >= f.x && f.x >= I && v !== f.x && Cu(S < M ? v : x, S, I, M, S < M ? x : v, S, f.x, f.y)) {
              const k = Math.abs(S - f.y) / (v - f.x);
              Ud(f, u) && (k < C || k === C && (f.x > D.x || f.x === D.x && Fw(D, f))) && (D = f, C = k);
            }
            f = f.next;
          } while (f !== A);
          return D;
        }(r, e);
        if (!n)
          return e;
        const o = Ry(n, r);
        return xh(o, o.next), xh(n, n.next);
      }
      function Fw(r, e) {
        return Ts(r.prev, r, e.prev) < 0 && Ts(e.next, r, r.next) < 0;
      }
      function __(r, e, n, o, u) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - n) * u | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - o) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function Bw(r) {
        let e = r, n = r;
        do
          (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
        while (e !== r);
        return n;
      }
      function Cu(r, e, n, o, u, l, f, v) {
        return (u - f) * (e - v) >= (r - f) * (l - v) && (r - f) * (o - v) >= (n - f) * (e - v) && (n - f) * (l - v) >= (u - f) * (o - v);
      }
      function Nw(r, e) {
        return r.next.i !== e.i && r.prev.i !== e.i && !function(n, o) {
          let u = n;
          do {
            if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && ky(u, u.next, n, o))
              return !0;
            u = u.next;
          } while (u !== n);
          return !1;
        }(r, e) && (Ud(r, e) && Ud(e, r) && function(n, o) {
          let u = n, l = !1;
          const f = (n.x + o.x) / 2, v = (n.y + o.y) / 2;
          do
            u.y > v != u.next.y > v && u.next.y !== u.y && f < (u.next.x - u.x) * (v - u.y) / (u.next.y - u.y) + u.x && (l = !l), u = u.next;
          while (u !== n);
          return l;
        }(r, e) && (Ts(r.prev, r, e.prev) || Ts(r, e.prev, e)) || bp(r, e) && Ts(r.prev, r, r.next) > 0 && Ts(e.prev, e, e.next) > 0);
      }
      function Ts(r, e, n) {
        return (e.y - r.y) * (n.x - e.x) - (e.x - r.x) * (n.y - e.y);
      }
      function bp(r, e) {
        return r.x === e.x && r.y === e.y;
      }
      function ky(r, e, n, o) {
        const u = Tp(Ts(r, e, n)), l = Tp(Ts(r, e, o)), f = Tp(Ts(n, o, r)), v = Tp(Ts(n, o, e));
        return u !== l && f !== v || !(u !== 0 || !wp(r, n, e)) || !(l !== 0 || !wp(r, o, e)) || !(f !== 0 || !wp(n, r, o)) || !(v !== 0 || !wp(n, e, o));
      }
      function wp(r, e, n) {
        return e.x <= Math.max(r.x, n.x) && e.x >= Math.min(r.x, n.x) && e.y <= Math.max(r.y, n.y) && e.y >= Math.min(r.y, n.y);
      }
      function Tp(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function Ud(r, e) {
        return Ts(r.prev, r, r.next) < 0 ? Ts(r, e, r.next) >= 0 && Ts(r, r.prev, e) >= 0 : Ts(r, e, r.prev) < 0 || Ts(r, r.next, e) < 0;
      }
      function Ry(r, e) {
        const n = g_(r.i, r.x, r.y), o = g_(e.i, e.x, e.y), u = r.next, l = e.prev;
        return r.next = e, e.prev = r, n.next = u, u.prev = n, o.next = n, n.prev = o, l.next = o, o.prev = l, o;
      }
      function Oy(r, e, n, o) {
        const u = g_(r, e, n);
        return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u;
      }
      function jd(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function g_(r, e, n) {
        return { i: r, x: e, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function Mp(r, e) {
        const n = r.length;
        if (n <= 1)
          return [r];
        const o = [];
        let u, l;
        for (let f = 0; f < n; f++) {
          const v = Vn(r[f]);
          v !== 0 && (r[f].area = Math.abs(v), l === void 0 && (l = v < 0), l === v < 0 ? (u && o.push(u), u = [r[f]]) : u.push(r[f]));
        }
        if (u && o.push(u), e > 1)
          for (let f = 0; f < o.length; f++)
            o[f].length <= e || (Nh(o[f], e, 1, o[f].length - 1, Vw), o[f] = o[f].slice(0, e));
        return o;
      }
      function Vw(r, e) {
        return e.area - r.area;
      }
      function Fy(r, e) {
        if (!r)
          return null;
        const n = typeof r == "string" ? r : r.getPrimary().id;
        e[n] || (e[n] = []);
        const o = ss.from(r).getPrimary();
        return e[n].push(o), o.serialize();
      }
      function y_(r, e, n) {
        const o = n.patternDependencies;
        let u = !1;
        for (const l of e) {
          const f = l.paint.get(`${r}-pattern`);
          f.isConstant() || (u = !0), Fy(f.constantOr(null), o) && (u = !0);
        }
        return u;
      }
      function x_(r, e, n, o, u) {
        const l = u.patternDependencies;
        for (const f of e) {
          const v = f.paint.get(`${r}-pattern`).value;
          if (v.kind !== "constant") {
            let S = v.evaluate({ zoom: o }, n, {}, u.availableImages);
            S = S && S.name ? S.name : S;
            const D = Fy(S, l);
            D && (n.patterns[f.id] = D);
          }
        }
        return n;
      }
      class v_ {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Lo(), this.indexArray = new qs(), this.indexArray2 = new Ka(), this.programConfigurations = new Qa(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Wn(), this.segments2 = new Wn(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.projection = e.projection;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.hasPattern = y_("fill", this.layers, n);
          const l = this.layers[0].layout.get("fill-sort-key"), f = [];
          for (const { feature: v, id: S, index: D, sourceLayerIndex: x } of e) {
            const A = this.layers[0]._featureFilter.needGeometry, I = Z(v, A);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), I, o))
              continue;
            const M = l ? l.evaluate(I, {}, o, n.availableImages) : void 0, C = { id: S, properties: v.properties, type: v.type, sourceLayerIndex: x, index: D, geometry: A ? I.geometry : G(v, o, u), patterns: {}, sortKey: M };
            f.push(C);
          }
          l && f.sort((v, S) => v.sortKey - S.sortKey);
          for (const v of f) {
            const { geometry: S, index: D, sourceLayerIndex: x } = v;
            if (this.hasPattern) {
              const A = x_("fill", this.layers, v, this.zoom, n);
              this.patternFeatures.push(A);
            } else
              this.addFeature(v, S, D, o, {}, n.availableImages, n.brightness);
            n.featureIndex.insert(e[D].feature, S, D, x, this.index);
          }
        }
        update(e, n, o, u, l, f, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v);
        }
        addFeatures(e, n, o, u, l, f) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, n, o, u, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Iw), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, n, o, u, l, f = [], v) {
          for (const S of Mp(n, 500)) {
            let D = 0;
            for (const k of S)
              D += k.length;
            const x = this.segments.prepareSegment(D, this.layoutVertexArray, this.indexArray), A = x.vertexLength, I = [], M = [];
            for (const k of S) {
              if (k.length === 0)
                continue;
              k !== S[0] && M.push(I.length / 2);
              const V = this.segments2.prepareSegment(k.length, this.layoutVertexArray, this.indexArray2), U = V.vertexLength;
              this.layoutVertexArray.emplaceBack(k[0].x, k[0].y), this.indexArray2.emplaceBack(U + k.length - 1, U), I.push(k[0].x), I.push(k[0].y);
              for (let q = 1; q < k.length; q++)
                this.layoutVertexArray.emplaceBack(k[q].x, k[q].y), this.indexArray2.emplaceBack(U + q - 1, U + q), I.push(k[q].x), I.push(k[q].y);
              V.vertexLength += k.length, V.primitiveLength += k.length;
            }
            const C = Nd(I, M);
            for (let k = 0; k < C.length; k += 3)
              this.indexArray.emplaceBack(A + C[k], A + C[k + 1], A + C[k + 2]);
            x.vertexLength += D, x.primitiveLength += C.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, f, u, v);
        }
      }
      let By, Ny, Vy, Uy;
      Ft(v_, "FillBucket", { omit: ["layers", "patternFeatures"] });
      class b_ {
        constructor(e, n, o, u) {
          if (this.triangleCount = n.length / 3, this.min = new Et(0, 0), this.max = new Et(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0)
            return;
          const [l, f] = [e[0].clone(), e[0].clone()];
          for (let A = 1; A < e.length; ++A) {
            const I = e[A];
            l.x = Math.min(l.x, I.x), l.y = Math.min(l.y, I.y), f.x = Math.max(f.x, I.x), f.y = Math.max(f.y, I.y);
          }
          if (u) {
            const A = Math.ceil(Math.max(f.x - l.x, f.y - l.y) / u);
            o = Math.max(o, A);
          }
          if (o === 0)
            return;
          this.min = l, this.max = f;
          const v = this.max.sub(this.min);
          v.x = Math.max(v.x, 1), v.y = Math.max(v.y, 1);
          const S = Math.max(v.x, v.y) / o;
          this.cellsX = Math.max(1, Math.ceil(v.x / S)), this.cellsY = Math.max(1, Math.ceil(v.y / S)), this.xScale = 1 / S, this.yScale = 1 / S;
          const D = [];
          for (let A = 0; A < this.triangleCount; A++) {
            const I = e[n[3 * A + 0]].sub(this.min), M = e[n[3 * A + 1]].sub(this.min), C = e[n[3 * A + 2]].sub(this.min), k = nl(Math.floor(Math.min(I.x, M.x, C.x)), this.xScale, this.cellsX), V = nl(Math.floor(Math.max(I.x, M.x, C.x)), this.xScale, this.cellsX), U = nl(Math.floor(Math.min(I.y, M.y, C.y)), this.yScale, this.cellsY), q = nl(Math.floor(Math.max(I.y, M.y, C.y)), this.yScale, this.cellsY), $ = new Et(0, 0), H = new Et(0, 0), K = new Et(0, 0), Q = new Et(0, 0);
            for (let ie = U; ie <= q; ++ie) {
              $.y = H.y = ie * S, K.y = Q.y = (ie + 1) * S;
              for (let fe = k; fe <= V; ++fe)
                $.x = K.x = fe * S, H.x = Q.x = (fe + 1) * S, (ke(I, M, C, $, H, Q) || ke(I, M, C, $, Q, K)) && D.push({ cellIdx: ie * this.cellsX + fe, triIdx: A });
            }
          }
          if (D.length === 0)
            return;
          D.sort((A, I) => A.cellIdx - I.cellIdx || A.triIdx - I.triIdx);
          let x = 0;
          for (; x < D.length; ) {
            const A = D[x].cellIdx, I = { start: this.payload.length, len: 0 };
            for (; x < D.length && D[x].cellIdx === A; )
              ++I.len, this.payload.push(D[x++].triIdx);
            this.cells[A] = I;
          }
        }
        _lazyInitLookup() {
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
        }
        queryPoint(e, n) {
          if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y)
            return;
          const o = nl(e.x - this.min.x, this.xScale, this.cellsX), u = nl(e.y - this.min.y, this.yScale, this.cellsY), l = this.cells[u * this.cellsX + o];
          if (l) {
            this._lazyInitLookup();
            for (let f = 0; f < l.len; f++) {
              const v = this.payload[l.start + f], S = Math.floor(v / 8), D = 1 << v % 8;
              if (!(this.lookup[S] & D) && (this.lookup[S] |= D, n.push(v), n.length === this.triangleCount))
                return;
            }
          }
        }
        query(e, n, o) {
          if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > n.x || e.y > this.max.y || this.min.y > n.y)
            return;
          this._lazyInitLookup();
          const u = nl(e.x - this.min.x, this.xScale, this.cellsX), l = nl(n.x - this.min.x, this.xScale, this.cellsX), f = nl(e.y - this.min.y, this.yScale, this.cellsY), v = nl(n.y - this.min.y, this.yScale, this.cellsY);
          for (let S = f; S <= v; S++)
            for (let D = u; D <= l; D++) {
              const x = this.cells[S * this.cellsX + D];
              if (x)
                for (let A = 0; A < x.len; A++) {
                  const I = this.payload[x.start + A], M = Math.floor(I / 8), C = 1 << I % 8;
                  if (!(this.lookup[M] & C) && (this.lookup[M] |= C, o.push(I), o.length === this.triangleCount))
                    return;
                }
            }
        }
      }
      function nl(r, e, n) {
        return Math.max(0, Math.min(n - 1, Math.floor(r * e)));
      }
      Ft(b_, "TriangleGridIndex");
      class jy {
        constructor(e) {
          this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.footprints = [];
        }
        updateFootprints(e, n) {
          for (const o of this.footprints)
            n.push({ footprint: o, id: e });
        }
        populate(e, n, o, u) {
          const l = [];
          for (const { feature: f, id: v, index: S, sourceLayerIndex: D } of e) {
            const x = this.layers[0]._featureFilter.needGeometry, A = Z(f, x);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), A, o))
              continue;
            const I = { id: v, properties: f.properties, type: f.type, sourceLayerIndex: D, index: S, geometry: x ? A.geometry : G(f, o, u), patterns: {} };
            l.push(I);
          }
          for (const f of l) {
            const { geometry: v, index: S, sourceLayerIndex: D } = f;
            this.addFeature(f, v, S, o, {}, n.availableImages, n.brightness), n.featureIndex.insert(e[S].feature, v, S, D, this.index);
          }
        }
        isEmpty() {
          return this.footprints.length === 0;
        }
        uploadPending() {
          return !1;
        }
        upload(e) {
        }
        update(e, n, o, u, l, f, v) {
        }
        destroy() {
        }
        addFeature(e, n, o, u, l, f = [], v) {
          for (const S of Mp(n, 2)) {
            const D = [], x = [], A = [], I = new Et(1 / 0, 1 / 0), M = new Et(-1 / 0, -1 / 0);
            for (const V of S)
              if (V.length !== 0) {
                V !== S[0] && A.push(x.length / 2);
                for (let U = 0; U < V.length; U++)
                  x.push(V[U].x), x.push(V[U].y), D.push(V[U]), I.x = Math.min(I.x, V[U].x), I.y = Math.min(I.y, V[U].y), M.x = Math.max(M.x, V[U].x), M.y = Math.max(M.y, V[U].y);
              }
            const C = Nd(x, A), k = new b_(D, C, 8, 256);
            this.footprints.push({ vertices: D, indices: C, grid: k, min: I, max: M });
          }
        }
      }
      Ft(jy, "ClipBucket", { omit: ["layers"] });
      const Uw = qi([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), jw = qi([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Gw = qi([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Zw = qi([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Hw = qi([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), qw = qi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Ww } = Uw;
      var w_, Gy, T_, Zy, M_, Hy, qy, Sp = {};
      function Wy() {
        if (Gy)
          return w_;
        Gy = 1;
        var r = Zr();
        function e(u, l, f, v, S) {
          this.properties = {}, this.extent = f, this.type = 0, this._pbf = u, this._geometry = -1, this._keys = v, this._values = S, u.readFields(n, this, l);
        }
        function n(u, l, f) {
          u == 1 ? l.id = f.readVarint() : u == 2 ? function(v, S) {
            for (var D = v.readVarint() + v.pos; v.pos < D; ) {
              var x = S._keys[v.readVarint()], A = S._values[v.readVarint()];
              S.properties[x] = A;
            }
          }(f, l) : u == 3 ? l.type = f.readVarint() : u == 4 && (l._geometry = f.pos);
        }
        function o(u) {
          for (var l, f, v = 0, S = 0, D = u.length, x = D - 1; S < D; x = S++)
            v += ((f = u[x]).x - (l = u[S]).x) * (l.y + f.y);
          return v;
        }
        return w_ = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function() {
          var u = this._pbf;
          u.pos = this._geometry;
          for (var l, f = u.readVarint() + u.pos, v = 1, S = 0, D = 0, x = 0, A = []; u.pos < f; ) {
            if (S <= 0) {
              var I = u.readVarint();
              v = 7 & I, S = I >> 3;
            }
            if (S--, v === 1 || v === 2)
              D += u.readSVarint(), x += u.readSVarint(), v === 1 && (l && A.push(l), l = []), l.push(new r(D, x));
            else {
              if (v !== 7)
                throw new Error("unknown command " + v);
              l && l.push(l[0].clone());
            }
          }
          return l && A.push(l), A;
        }, e.prototype.bbox = function() {
          var u = this._pbf;
          u.pos = this._geometry;
          for (var l = u.readVarint() + u.pos, f = 1, v = 0, S = 0, D = 0, x = 1 / 0, A = -1 / 0, I = 1 / 0, M = -1 / 0; u.pos < l; ) {
            if (v <= 0) {
              var C = u.readVarint();
              f = 7 & C, v = C >> 3;
            }
            if (v--, f === 1 || f === 2)
              (S += u.readSVarint()) < x && (x = S), S > A && (A = S), (D += u.readSVarint()) < I && (I = D), D > M && (M = D);
            else if (f !== 7)
              throw new Error("unknown command " + f);
          }
          return [x, I, A, M];
        }, e.prototype.toGeoJSON = function(u, l, f) {
          var v, S, D = this.extent * Math.pow(2, f), x = this.extent * u, A = this.extent * l, I = this.loadGeometry(), M = e.types[this.type];
          function C(U) {
            for (var q = 0; q < U.length; q++) {
              var $ = U[q];
              U[q] = [360 * ($.x + x) / D - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * ($.y + A) / D) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var k = [];
              for (v = 0; v < I.length; v++)
                k[v] = I[v][0];
              C(I = k);
              break;
            case 2:
              for (v = 0; v < I.length; v++)
                C(I[v]);
              break;
            case 3:
              for (I = function(U) {
                var q = U.length;
                if (q <= 1)
                  return [U];
                for (var $, H, K = [], Q = 0; Q < q; Q++) {
                  var ie = o(U[Q]);
                  ie !== 0 && (H === void 0 && (H = ie < 0), H === ie < 0 ? ($ && K.push($), $ = [U[Q]]) : $.push(U[Q]));
                }
                return $ && K.push($), K;
              }(I), v = 0; v < I.length; v++)
                for (S = 0; S < I[v].length; S++)
                  C(I[v][S]);
          }
          I.length === 1 ? I = I[0] : M = "Multi" + M;
          var V = { type: "Feature", geometry: { type: M, coordinates: I }, properties: this.properties };
          return "id" in this && (V.id = this.id), V;
        }, w_;
      }
      function $y() {
        if (Zy)
          return T_;
        Zy = 1;
        var r = Wy();
        function e(o, u) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = o, this._keys = [], this._values = [], this._features = [], o.readFields(n, this, u), this.length = this._features.length;
        }
        function n(o, u, l) {
          o === 15 ? u.version = l.readVarint() : o === 1 ? u.name = l.readString() : o === 5 ? u.extent = l.readVarint() : o === 2 ? u._features.push(l.pos) : o === 3 ? u._keys.push(l.readString()) : o === 4 && u._values.push(function(f) {
            for (var v = null, S = f.readVarint() + f.pos; f.pos < S; ) {
              var D = f.readVarint() >> 3;
              v = D === 1 ? f.readString() : D === 2 ? f.readFloat() : D === 3 ? f.readDouble() : D === 4 ? f.readVarint64() : D === 5 ? f.readVarint() : D === 6 ? f.readSVarint() : D === 7 ? f.readBoolean() : null;
            }
            return v;
          }(l));
        }
        return T_ = e, e.prototype.feature = function(o) {
          if (o < 0 || o >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[o];
          var u = this._pbf.readVarint() + this._pbf.pos;
          return new r(this._pbf, u, this.extent, this._keys, this._values);
        }, T_;
      }
      function Xy() {
        return qy || (qy = 1, Sp.VectorTile = function() {
          if (Hy)
            return M_;
          Hy = 1;
          var r = $y();
          function e(n, o, u) {
            if (n === 3) {
              var l = new r(u, u.readVarint() + u.pos);
              l.length && (o[l.name] = l);
            }
          }
          return M_ = function(n, o) {
            this.layers = n.readFields(e, {}, o);
          }, M_;
        }(), Sp.VectorTileFeature = Wy(), Sp.VectorTileLayer = $y()), Sp;
      }
      var Iu = Xy();
      class vh extends Et {
        constructor(e, n, o) {
          super(e, n), this.z = o;
        }
      }
      class Yy extends vh {
        constructor(e, n, o, u) {
          super(e, n, o), this.w = u;
        }
      }
      function Ep(r, e, n, o) {
        const u = [], l = o === 0 ? (f, v, S, D, x, A) => {
          f.push(new Et(A, S + (A - v) / (D - v) * (x - S)));
        } : (f, v, S, D, x, A) => {
          f.push(new Et(v + (A - S) / (x - S) * (D - v), A));
        };
        for (const f of r) {
          const v = [];
          for (const S of f) {
            if (S.length <= 2)
              continue;
            const D = [];
            for (let I = 0; I < S.length - 1; I++) {
              const M = S[I].x, C = S[I].y, k = S[I + 1].x, V = S[I + 1].y, U = o === 0 ? M : C, q = o === 0 ? k : V;
              U < e ? q > e && l(D, M, C, k, V, e) : U > n ? q < n && l(D, M, C, k, V, n) : D.push(S[I]), q < e && U >= e && l(D, M, C, k, V, e), q > n && U <= n && l(D, M, C, k, V, n);
            }
            let x = S[S.length - 1];
            const A = o === 0 ? x.x : x.y;
            A >= e && A <= n && D.push(x), D.length && (x = D[D.length - 1], D[0].x === x.x && D[0].y === x.y || D.push(D[0]), v.push(D));
          }
          v.length && u.push(v);
        }
        return u;
      }
      function Ky(r, e, n, o) {
        const u = n === "x" ? "y" : "x", l = (o - r[n]) / (e[n] - r[n]);
        r[u] = r[u] + (e[u] - r[u]) * l, r[n] = o, r.hasOwnProperty("z") && (r.z = ei(r.z, e.z, l)), r.hasOwnProperty("w") && (r.w = ei(r.w, e.w, l));
      }
      function Jy(r, e, n, o) {
        const u = n, l = o;
        for (const f of ["x", "y"]) {
          let v = r, S = e;
          v[f] >= S[f] && (v = e, S = r), v[f] < u && S[f] > u && Ky(v, S, f, u), v[f] < l && S[f] > l && Ky(S, v, f, l);
        }
      }
      const Ap = Number.MAX_SAFE_INTEGER;
      function Qy(r, e, n, o) {
        return r.order < e || r.order === Ap || !(r.clipMask & n) || function(u, l) {
          return l.length !== 0 && l.find((f) => f === u) === void 0;
        }(o, r.clipScope);
      }
      function Pp(r, e) {
        return r.x - e.x || r.y - e.y;
      }
      function e0(r, e) {
        return Pp(r.min, e.min) === 0 && Pp(r.max, e.max) === 0;
      }
      function S_(r, e) {
        return !(r.min.x > e.max.x || r.max.x < e.min.x || r.min.y > e.max.y || r.max.y < e.min.y);
      }
      function E_(r, e) {
        if (r.length !== e.length)
          return !1;
        for (let n = 0; n < r.length; n++)
          if (r[n].sourceId !== e[n].sourceId || !e0(r[n], e[n]) || r[n].order !== e[n].order || r[n].clipMask !== e[n].clipMask || !Ws(r[n].clipScope, e[n].clipScope))
            return !1;
        return !0;
      }
      function t0(r, e, n) {
        const o = 1 / Tt, u = 1 / (1 << n.canonical.z), l = (e.x * o + n.canonical.x) * u + n.wrap, f = (e.y * o + n.canonical.y) * u;
        return { min: new Et((r.x * o + n.canonical.x) * u + n.wrap, (r.y * o + n.canonical.y) * u), max: new Et(l, f) };
      }
      function $w(r, e, n) {
        const o = 1 << n.canonical.z, u = ((e.x - n.wrap) * o - n.canonical.x) * Tt, l = (e.y * o - n.canonical.y) * Tt;
        return { min: new Et(((r.x - n.wrap) * o - n.canonical.x) * Tt, (r.y * o - n.canonical.y) * Tt), max: new Et(u, l) };
      }
      function i0(r, e, n, o, u, l, f) {
        const v = r.indices, S = r.vertices, D = [];
        for (let x = o; x < o + u; x += 3) {
          const A = e[n[x + 0] + l], I = e[n[x + 1] + l], M = e[n[x + 2] + l], C = Math.min(A.x, I.x, M.x), k = Math.max(A.x, I.x, M.x), V = Math.min(A.y, I.y, M.y), U = Math.max(A.y, I.y, M.y);
          D.length = 0, r.grid.query(new Et(C, V), new Et(k, U), D);
          for (let q = 0; q < D.length; q++) {
            const $ = D[q];
            if (ke(S[v[3 * $ + 0]], S[v[3 * $ + 1]], S[v[3 * $ + 2]], A, I, M, f))
              return !0;
          }
        }
        return !1;
      }
      function n0(r, e, n, o) {
        if (!r || !n)
          return !1;
        let u = r.vertices;
        if (!e.canonical.equals(o.canonical) || e.wrap !== o.wrap) {
          if (n.vertices.length < r.vertices.length)
            return n0(n, o, r, e);
          const l = e.canonical, f = o.canonical, v = Math.pow(2, f.z - l.z);
          u = r.vertices.map((S) => new Et((S.x + l.x * Tt) * v - f.x * Tt, (S.y + l.y * Tt) * v - f.y * Tt));
        }
        return i0(n, u, r.indices, 0, r.indices.length, 0, 0);
      }
      function s0(r, e, n, o) {
        const u = Math.pow(2, o.z - n.z);
        return new Et((r + n.x * Tt) * u - o.x * Tt, (e + n.y * Tt) * u - o.y * Tt);
      }
      function r0(r, e) {
        const n = [];
        e.grid.queryPoint(r, n);
        const o = e.indices, u = e.vertices;
        for (let l = 0; l < n.length; l++) {
          const f = n[l];
          if (Pe([u[o[3 * f + 0]], u[o[3 * f + 1]], u[o[3 * f + 2]]], r))
            return !0;
        }
        return !1;
      }
      const A_ = [new Et(0, 0), new Et(Tt, 0), new Et(Tt, Tt), new Et(0, Tt)];
      function o0(r, e) {
        const n = [];
        let o = [];
        if (!e || r.length < 2)
          return [r];
        if (r.length === 2)
          return Xe(r[0], r[1], A_) ? [r] : [];
        for (let u = 0; u < r.length + 2; u++) {
          const l = r[u % r.length], f = r[(u + 1) % r.length], v = Xe(u === 0 ? r[r.length - 1] : r[(u - 1) % r.length], l, A_), S = Xe(l, f, A_), D = v || S;
          D && o.push(l), D && S || o.length > 0 && (o.length > 1 && n.push(o), o = []);
        }
        return o.length > 1 && n.push(o), n;
      }
      const P_ = Iu.VectorTileFeature.types, Xw = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], Yw = ["fill-extrusion-flood-light-ground-radius"], Kw = Math.pow(2, 13), Jw = Math.pow(2, 15) - 1, a0 = new Et(0, 1), yc = 2147483648;
      function Gd(r, e, n, o, u, l, f, v) {
        r.emplaceBack((e << 1) + f, (n << 1) + l, (Math.floor(o * Kw) << 1) + u, Math.round(v));
      }
      function Zd(r, e, n) {
        r.emplaceBack(e.x * Tt, e.y * Tt, n ? 1 : 0);
      }
      function Cp(r, e, n, o, u, l) {
        r.emplaceBack(e.x, e.y, (n.x << 1) + o, (n.y << 1) + u, l);
      }
      function Hd(r, e, n) {
        r.emplaceBack(e.x, e.y, e.z, n[0] * 16384, n[1] * 16384, n[2] * 16384);
      }
      class l0 {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class c0 {
        constructor() {
          this.centroidXY = new Et(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Et(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Et(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new Et(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class h0 {
        constructor() {
          this.acc = new Et(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(e, n) {
          e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = n.x, e.min.y = e.max.y = n.y);
        }
        appendEdge(e, n, o) {
          this.accCount++, this.acc._add(n);
          let u = !!this.borders;
          n.x < e.min.x ? (e.min.x = n.x, u = !0) : n.x > e.max.x && (e.max.x = n.x, u = !0), n.y < e.min.y ? (e.min.y = n.y, u = !0) : n.y > e.max.y && (e.max.y = n.y, u = !0), ((n.x === 0 || n.x === Tt) && n.x === o.x) != ((n.y === 0 || n.y === Tt) && n.y === o.y) && this.processBorderOverlap(n, o), u && this.checkBorderIntersection(n, o);
        }
        checkBorderIntersection(e, n) {
          n.x < 0 != e.x < 0 && this.addBorderIntersection(0, ei(n.y, e.y, (0 - n.x) / (e.x - n.x))), n.x > Tt != e.x > Tt && this.addBorderIntersection(1, ei(n.y, e.y, (Tt - n.x) / (e.x - n.x))), n.y < 0 != e.y < 0 && this.addBorderIntersection(2, ei(n.x, e.x, (0 - n.y) / (e.y - n.y))), n.y > Tt != e.y > Tt && this.addBorderIntersection(3, ei(n.x, e.x, (Tt - n.y) / (e.y - n.y)));
        }
        addBorderIntersection(e, n) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const o = this.borders[e];
          n < o[0] && (o[0] = n), n > o[1] && (o[1] = n);
        }
        processBorderOverlap(e, n) {
          if (e.x === n.x) {
            if (e.y === n.y)
              return;
            const o = e.x === 0 ? 0 : 1;
            this.addBorderIntersection(o, n.y), this.addBorderIntersection(o, e.y);
          } else {
            const o = e.y === 0 ? 2 : 3;
            this.addBorderIntersection(o, n.x), this.addBorderIntersection(o, e.x);
          }
        }
        centroid() {
          return this.accCount === 0 ? new Et(0, 0) : new Et(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((e, n) => e + +(n[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function u0(r, e) {
        const n = r.add(e)._unit(), o = si(r.x * n.x + r.y * n.y, -1, 1);
        var u, l, f;
        return f = Math.acos(o), Math.min(4, Math.max(-4, Math.tan(f))) / 4 * Jw * ((u = r).x * (l = e).y - u.y * l.x < 0 ? -1 : 1);
      }
      const Qw = [(r) => r.x < 0, (r) => r.x > Tt, (r) => r.y < 0, (r) => r.y > Tt];
      function eT(r, e, n, o) {
        const u = [4];
        if (o === 0)
          return u;
        n._mult(o);
        const l = r.sub(n), f = e.sub(n), v = [r, e, l, f];
        for (let S = 0; S < 4; S++)
          for (const D of v)
            if (Qw[S](D)) {
              u.push(S);
              break;
            }
        return u;
      }
      class d0 {
        constructor(e) {
          this.vertexArray = new wd(), this.indexArray = new qs(), this.programConfigurations = new Qa(e.layers, { zoom: e.zoom, lut: e.lut }, (n) => Yw.includes(n)), this._segments = new Wn(), this.hiddenByLandmarkVertexArray = new vu(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Wn();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return this.vertexArray.length !== 0;
        }
        addData(e, n, o, u = !1) {
          const l = e.length;
          if (l > 2) {
            let f = Math.max(0, this._segments.get().length - 1);
            const v = this._segments._prepareSegment(4 * l, this.vertexArray.length, 2 * this._segmentToGroundQuads[f].length);
            let S;
            f !== this._segments.get().length - 1 && (f++, this._segmentToGroundQuads[f] = [], this._segmentToRegionTriCounts[f] = [0, 0, 0, 0, 0]);
            {
              const D = e[0], x = e[1];
              S = u0(D.sub(e[l - 1])._perp()._unit(), x.sub(D)._perp()._unit());
            }
            for (let D = 0; D < l; D++) {
              const x = D === l - 1 ? 0 : D + 1, A = e[D], I = e[x], M = e[x === l - 1 ? 0 : x + 1], C = I.sub(A)._perp()._unit(), k = u0(C, M.sub(I)._perp()._unit()), V = S, U = k;
              if (C_(A, I, n) || u && m0(A, n) && m0(I, n)) {
                S = k;
                continue;
              }
              const q = v.vertexLength;
              Cp(this.vertexArray, A, I, 1, 1, V), Cp(this.vertexArray, A, I, 1, 0, V), Cp(this.vertexArray, A, I, 0, 1, U), Cp(this.vertexArray, A, I, 0, 0, U), v.vertexLength += 4;
              const $ = eT(A, I, C, o);
              for (const H of $)
                this._segmentToGroundQuads[f].push({ id: q, region: H }), this._segmentToRegionTriCounts[f][H] += 2, v.primitiveLength += 2;
              S = k;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData())
            return;
          const e = this._segments.get(), n = e.length;
          for (let o = 0; o < n; o++)
            this._segmentToGroundQuads[o].sort((u, l) => u.region - l.region);
          for (let o = 0; o < n; o++) {
            const u = this._segmentToGroundQuads[o], l = e[o], f = this._segmentToRegionTriCounts[o];
            f.reduce((S, D) => S + D, 0);
            let v = 0;
            for (let S = 0; S <= 4; S++) {
              const D = f[S];
              if (D !== 0) {
                let x = this.regionSegments[S];
                x || (x = this.regionSegments[S] = new Wn());
                const A = { vertexOffset: l.vertexOffset, primitiveOffset: l.primitiveOffset + v, vertexLength: l.vertexLength, primitiveLength: D };
                x.get().push(A);
              }
              v += D;
            }
            for (let S = 0; S < u.length; S++) {
              const D = u[S].id;
              this.indexArray.emplaceBack(D, D + 1, D + 3), this.indexArray.emplaceBack(D, D + 3, D + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(e, n, o, u, l, f) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, n, o, u, l, f);
        }
        upload(e) {
          this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, jw.members), this.indexBuffer = e.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(e) {
          this.hasData() && this.programConfigurations.upload(e);
        }
        update(e, n, o, u, l, f, v) {
          this.hasData() && this.programConfigurations.updatePaintArrays(e, n, o, u, l, f, v);
        }
        updateHiddenByLandmark(e) {
          if (!this.hasData())
            return;
          const n = e.groundVertexCount + e.groundVertexArrayOffset;
          if (e.groundVertexCount === 0)
            return;
          const o = e.flags & yc ? 1 : 0;
          for (let u = e.groundVertexArrayOffset; u < n; ++u)
            this.hiddenByLandmarkVertexArray.emplace(u, o);
          this._needsHiddenByLandmarkUpdate = !0;
        }
        uploadHiddenByLandmark(e) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, Hw.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let e = 0; e <= 4; e++) {
              const n = this.regionSegments[e];
              n && n.destroy();
            }
          }
        }
      }
      class Ip {
        constructor(e) {
          this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new qs(), this.footprintVertices = new Lo(), this.footprintSegments = [], this.layoutVertexArray = new $a(), this.centroidVertexArray = new dp(), this.wallVertexArray = new pp(), this.indexArray = new qs(), this.programConfigurations = new Qa(e.layers, { zoom: e.zoom, lut: e.lut }, (n) => Xw.includes(n)), this.segments = new Wn(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.groundEffect = new d0(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.features = [], this.hasPattern = y_("fill-extrusion", this.layers, n), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = s(o), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0;
          for (const { feature: l, id: f, index: v, sourceLayerIndex: S } of e) {
            const D = this.layers[0]._featureFilter.needGeometry, x = Z(l, D);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), x, o))
              continue;
            const A = { id: f, sourceLayerIndex: S, index: v, geometry: D ? x.geometry : G(l, o, u), properties: l.properties, type: l.type, patterns: {} }, I = this.layoutVertexArray.length, M = P_[A.type] === "Polygon";
            if (this.hasPattern)
              this.features.push(x_("fill-extrusion", this.layers, A, this.zoom, n));
            else if (this.wallMode)
              for (const C of A.geometry)
                for (const k of o0(C, M))
                  this.addFeature(A, [k], v, o, {}, n.availableImages, u, n.brightness);
            else
              this.addFeature(A, A.geometry, v, o, {}, n.availableImages, u, n.brightness);
            n.featureIndex.insert(l, A.geometry, v, S, this.index, I);
          }
          this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(e, n, o, u, l, f) {
          for (const v of this.features) {
            const S = P_[v.type] === "Polygon", { geometry: D } = v;
            if (this.wallMode)
              for (const x of D)
                for (const A of o0(x, S))
                  this.addFeature(v, [A], v.index, n, o, u, l, f);
            else
              this.addFeature(v, D, v.index, n, o, u, l, f);
          }
          this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles();
        }
        update(e, n, o, u, l, f, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v), this.groundEffect.update(e, n, l, o, u, f, v);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Ww), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, Zw.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, qw.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        uploadCentroid(e) {
          this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Gw.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, n, o, u, l, f, v, S) {
          const D = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, x = [new Et(0, 0), new Et(Tt, Tt)], A = v.projection, I = A.name === "globe", M = this.wallMode || P_[e.type] === "Polygon", C = new h0();
          C.centroidDataIndex = this.centroidData.length;
          const k = new c0(), V = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, u) <= 0, U = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, u);
          let q;
          if (k.height = U, k.vertexArrayOffset = this.layoutVertexArray.length, k.groundVertexArrayOffset = this.groundEffect.vertexArray.length, I && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pu()), this.wallMode) {
            if (I)
              return void mi("Non zero fill-extrusion-line-width is not yet supported on globe.");
            if (n.length !== 1)
              return;
            q = function(ue) {
              const Se = ue[0].x === ue[ue.length - 1].x && ue[0].y === ue[ue.length - 1].y;
              (function(Pt) {
                let rt = 0;
                const Ut = Pt.length;
                for (let St = 0; St < Ut; St++)
                  rt += (Pt[(St + 1) % Ut].x - Pt[St].x) * (Pt[(St + 1) % Ut].y + Pt[St].y);
                return rt >= 0;
              })(ue) || (ue = ue.reverse());
              const Ee = { geometry: [], joinNormals: [], indices: [] }, ze = [], Ie = [], Re = [];
              let Ve = ue.length;
              for (; Ve >= 2 && ue[Ve - 1].equals(ue[Ve - 2]); )
                Ve--;
              if (Ve < (Se ? 3 : 2))
                return Ee;
              let Ue, Fe, et, dt, tt, Mt = 0;
              for (; Mt < Ve - 1 && ue[Mt].equals(ue[Mt + 1]); )
                Mt++;
              Se && (Ue = ue[Ve - 2], tt = ue[Mt].sub(Ue)._unit()._perp());
              for (let Pt = Mt; Pt < Ve; Pt++) {
                if (et = Pt === Ve - 1 ? Se ? ue[Mt + 1] : void 0 : ue[Pt + 1], et && ue[Pt].equals(et))
                  continue;
                tt && (dt = tt), Ue && (Fe = Ue), Ue = ue[Pt], tt = et ? et.sub(Ue)._unit()._perp() : dt, dt = dt || tt;
                let rt = dt.add(tt);
                rt.x === 0 && rt.y === 0 || rt._unit();
                const Ut = rt.x * tt.x + rt.y * tt.y, St = Ut !== 0 ? 1 / Ut : 1 / 0, Nt = dt.x * tt.y - dt.y * tt.x > 0;
                let Qt = "miter";
                const pi = 2;
                Qt === "miter" && St > pi && (Qt = "bevel"), Qt === "bevel" && (St > 100 && (Qt = "flipbevel"), St < pi && (Qt = "miter"));
                const gi = (Pi, yi, Ii, fn) => {
                  const rn = new Et(Pi.x, Pi.y), hi = new Et(Pi.x, Pi.y);
                  rn.x += yi.x * fn, rn.y += yi.y * fn, hi.x -= yi.x * Math.max(Ii, 1), hi.y -= yi.y * Math.max(Ii, 1), Re.push(yi), ze.push(rn), Ie.push(hi);
                };
                if (Qt === "miter")
                  rt._mult(St), gi(Ue, rt, 0, 0);
                else if (Qt === "flipbevel")
                  rt = tt.mult(-1), gi(Ue, rt, 0, 0), gi(Ue, rt.mult(-1), 0, 0);
                else {
                  const Pi = -Math.sqrt(St * St - 1), yi = Nt ? Pi : 0, Ii = Nt ? 0 : Pi;
                  Fe && gi(Ue, dt, yi, Ii), et && gi(Ue, tt, yi, Ii);
                }
              }
              Ee.geometry = [...ze, ...Ie.reverse(), ze[0]], Ee.joinNormals = [...Re, ...Re.reverse(), Re[Re.length - 1]];
              const wt = Ee.geometry.length - 1;
              for (let Pt = 0; Pt < wt / 2; Pt++)
                if (Pt + 1 < wt / 2) {
                  let rt = Pt, Ut = Pt + 1, St = wt - 1 - Pt, Nt = wt - 2 - Pt;
                  rt = rt === 0 ? wt - 1 : rt - 1, Ut = Ut === 0 ? wt - 1 : Ut - 1, St = St === 0 ? wt - 1 : St - 1, Nt = Nt === 0 ? wt - 1 : Nt - 1, Ee.indices.push(St), Ee.indices.push(Ut), Ee.indices.push(rt), Ee.indices.push(St), Ee.indices.push(Nt), Ee.indices.push(Ut);
                }
              return Ee;
            }(n[0]), n = [q.geometry];
          }
          const $ = (ue, Se) => ue < (Se.length - 1) / 2 || ue === Se.length - 1, H = this.wallMode ? [n] : Mp(n, 500);
          for (let ue = H.length - 1; ue >= 0; ue--) {
            const Se = H[ue];
            (Se.length === 0 || (K = Se[0]).every((me) => me.x <= 0) || K.every((me) => me.x >= Tt) || K.every((me) => me.y <= 0) || K.every((me) => me.y >= Tt)) && H.splice(ue, 1);
          }
          var K;
          let Q;
          if (I)
            Q = x0(H, x, u);
          else {
            Q = [];
            for (const ue of H)
              Q.push({ polygon: ue, bounds: x });
          }
          const ie = M ? this.edgeRadius : 0, fe = ie > 0 && this.zoom < 17, de = (ue, Se) => {
            if (ue.length === 0)
              return !1;
            const me = ue[ue.length - 1];
            return Se.x === me.x && Se.y === me.y;
          };
          for (const { polygon: ue, bounds: Se } of Q) {
            let me = 0, Ee = 0;
            for (const Ve of ue)
              M && !Ve[0].equals(Ve[Ve.length - 1]) && Ve.push(Ve[0]), Ee += M ? Ve.length - 1 : Ve.length;
            const ze = this.segments.prepareSegment((M ? 5 : 4) * Ee, this.layoutVertexArray, this.indexArray);
            k.footprintSegIdx < 0 && (k.footprintSegIdx = this.footprintSegments.length), k.polygonSegIdx < 0 && (k.polygonSegIdx = this.polygonSegments.length);
            const Ie = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, Re = new l0();
            if (Re.vertexOffset = this.footprintVertices.length, Re.indexOffset = 3 * this.footprintIndices.length, Re.ringIndices = [], M) {
              const Ve = [], Ue = [];
              me = ze.vertexLength;
              for (let et = 0; et < ue.length; et++) {
                const dt = ue[et];
                dt.length && et !== 0 && Ue.push(Ve.length / 2);
                const tt = [];
                let Mt, wt;
                Mt = dt[1].sub(dt[0])._perp()._unit(), Re.ringIndices.push(dt.length - 1);
                for (let Pt = 1; Pt < dt.length; Pt++) {
                  const rt = dt[Pt], Ut = dt[Pt === dt.length - 1 ? 1 : Pt + 1], St = rt.clone();
                  if (ie) {
                    wt = Ut.sub(rt)._perp()._unit();
                    const Nt = Mt.add(wt)._unit(), Qt = ie * Math.min(4, 1 / (Mt.x * Nt.x + Mt.y * Nt.y));
                    St.x += Qt * Nt.x, St.y += Qt * Nt.y, St.x = Math.round(St.x), St.y = Math.round(St.y), Mt = wt;
                  }
                  if (!V || ie !== 0 && !fe || de(tt, St) || tt.push(St), Gd(this.layoutVertexArray, St.x, St.y, 0, 0, 1, 1, 0), this.wallMode) {
                    const Nt = $(Pt, dt);
                    Zd(this.wallVertexArray, q.joinNormals[Pt], !Nt);
                  }
                  ze.vertexLength++, this.footprintVertices.emplaceBack(rt.x, rt.y), Ve.push(rt.x, rt.y), I && Hd(this.layoutVertexExtArray, A.projectTilePoint(St.x, St.y, u), A.upVector(u, St.x, St.y));
                }
                V && (ie === 0 || fe) && (tt.length !== 0 && de(tt, tt[0]) && tt.pop(), this.groundEffect.addData(tt, Se, D));
              }
              const Fe = this.wallMode ? q.indices : Nd(Ve, Ue);
              for (let et = 0; et < Fe.length; et += 3)
                this.footprintIndices.emplaceBack(Re.vertexOffset + Fe[et + 0], Re.vertexOffset + Fe[et + 1], Re.vertexOffset + Fe[et + 2]), this.indexArray.emplaceBack(me + Fe[et], me + Fe[et + 2], me + Fe[et + 1]), ze.primitiveLength++;
              Re.indexCount += Fe.length, Re.vertexCount += this.footprintVertices.length - Re.vertexOffset;
            }
            for (let Ve = 0; Ve < ue.length; Ve++) {
              const Ue = ue[Ve];
              C.startRing(k, Ue[0]);
              let Fe = Ue.length > 4 && _0(Ue[Ue.length - 2], Ue[0], Ue[1]), et = ie ? tT(Ue[Ue.length - 2], Ue[0], Ue[1], ie) : 0;
              const dt = [];
              let tt, Mt, wt;
              Mt = Ue[1].sub(Ue[0])._perp()._unit();
              let Pt = !0;
              for (let rt = 1, Ut = 0; rt < Ue.length; rt++) {
                let St = Ue[rt - 1], Nt = Ue[rt];
                const Qt = Ue[rt === Ue.length - 1 ? 1 : rt + 1];
                if (C.appendEdge(k, Nt, St), C_(Nt, St, Se)) {
                  ie && (Mt = Qt.sub(Nt)._perp()._unit(), Pt = !Pt);
                  continue;
                }
                const pi = Nt.sub(St)._perp(), gi = pi.x / (Math.abs(pi.x) + Math.abs(pi.y)), Pi = pi.y > 0 ? 1 : 0, yi = St.dist(Nt);
                if (Ut + yi > 32768 && (Ut = 0), ie) {
                  wt = Qt.sub(Nt)._perp()._unit();
                  let hi = p0(St, Nt, Qt, f0(Mt, wt), ie);
                  isNaN(hi) && (hi = 0);
                  const on = Nt.sub(St)._unit();
                  St = St.add(on.mult(et))._round(), Nt = Nt.add(on.mult(-hi))._round(), et = hi, Mt = wt, V && this.zoom >= 17 && (de(dt, St) || dt.push(St), de(dt, Nt) || dt.push(Nt));
                }
                const Ii = ze.vertexLength, fn = Ue.length > 4 && _0(St, Nt, Qt);
                let rn = g0(Ut, Fe, Pt);
                if (Gd(this.layoutVertexArray, St.x, St.y, gi, Pi, 0, 0, rn), Gd(this.layoutVertexArray, St.x, St.y, gi, Pi, 0, 1, rn), this.wallMode) {
                  const hi = $(rt - 1, Ue), on = q.joinNormals[rt - 1];
                  Zd(this.wallVertexArray, on, hi), Zd(this.wallVertexArray, on, hi);
                }
                if (Ut += yi, rn = g0(Ut, fn, !Pt), Fe = fn, Gd(this.layoutVertexArray, Nt.x, Nt.y, gi, Pi, 0, 0, rn), Gd(this.layoutVertexArray, Nt.x, Nt.y, gi, Pi, 0, 1, rn), this.wallMode) {
                  const hi = $(rt, Ue), on = q.joinNormals[rt];
                  Zd(this.wallVertexArray, on, hi), Zd(this.wallVertexArray, on, hi);
                }
                if (ze.vertexLength += 4, this.indexArray.emplaceBack(Ii + 0, Ii + 1, Ii + 2), this.indexArray.emplaceBack(Ii + 1, Ii + 3, Ii + 2), ze.primitiveLength += 2, ie) {
                  const hi = me + (rt === 1 ? Ue.length - 2 : rt - 2), on = rt === 1 ? me : hi + 1;
                  if (this.indexArray.emplaceBack(Ii + 1, hi, Ii + 3), this.indexArray.emplaceBack(hi, on, Ii + 3), ze.primitiveLength += 2, tt === void 0 && (tt = Ii), !C_(Qt, Ue[rt], Se)) {
                    const Qi = rt === Ue.length - 1 ? tt : ze.vertexLength;
                    this.indexArray.emplaceBack(Ii + 2, Ii + 3, Qi), this.indexArray.emplaceBack(Ii + 3, Qi + 1, Qi), this.indexArray.emplaceBack(Ii + 3, on, Qi + 1), ze.primitiveLength += 3;
                  }
                  Pt = !Pt;
                }
                if (I) {
                  const hi = this.layoutVertexExtArray, on = A.projectTilePoint(St.x, St.y, u), Qi = A.projectTilePoint(Nt.x, Nt.y, u), pn = A.upVector(u, St.x, St.y), as = A.upVector(u, Nt.x, Nt.y);
                  Hd(hi, on, pn), Hd(hi, on, pn), Hd(hi, Qi, as), Hd(hi, Qi, as);
                }
              }
              M && (me += Ue.length - 1), V && ie && this.zoom >= 17 && (dt.length !== 0 && de(dt, dt[0]) && dt.pop(), this.groundEffect.addData(dt, Se, D, ie > 0));
            }
            this.footprintSegments.push(Re), Ie.triangleCount = this.indexArray.length - Ie.triangleArrayOffset, this.polygonSegments.push(Ie), ++k.footprintSegLen, ++k.polygonSegLen;
          }
          if (k.vertexCount = this.layoutVertexArray.length - k.vertexArrayOffset, k.groundVertexCount = this.groundEffect.vertexArray.length - k.groundVertexArrayOffset, k.vertexCount !== 0) {
            if (k.centroidXY = C.borders ? a0 : this.encodeCentroid(C, k), this.centroidData.push(k), C.borders) {
              this.featuresOnBorder.push(C);
              const ue = this.featuresOnBorder.length - 1;
              for (let Se = 0; Se < C.borders.length; Se++)
                C.borders[Se][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Se].push(ue);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, f, u, S), this.groundEffect.addPaintPropertiesData(e, o, l, f, u, S), this.maxHeight = Math.max(this.maxHeight, U);
          }
        }
        sortBorders() {
          for (let e = 0; e < this.borderFeatureIndices.length; e++)
            this.borderFeatureIndices[e].sort((n, o) => this.featuresOnBorder[n].borders[e][0] - this.featuresOnBorder[o].borders[e][0]);
        }
        splitToSubtiles() {
          const e = [];
          for (let v = 0; v < this.centroidData.length; v++) {
            const S = this.centroidData[v], D = +(S.min.y + S.max.y > Tt), x = 2 * D + (+(S.min.x + S.max.x > Tt) ^ D);
            for (let A = 0; A < S.polygonSegLen; A++) {
              const I = S.polygonSegIdx + A;
              e.push({ centroidIdx: v, subtile: x, polygonSegmentIdx: I, triangleSegmentIdx: this.polygonSegments[I].triangleSegIdx });
            }
          }
          const n = new qs();
          e.sort((v, S) => v.triangleSegmentIdx === S.triangleSegmentIdx ? v.subtile - S.subtile : v.triangleSegmentIdx - S.triangleSegmentIdx);
          let o = 0, u = 0, l = 0;
          for (const v of e) {
            if (v.triangleSegmentIdx !== o)
              break;
            l++;
          }
          const f = e.length;
          for (; u !== e.length; ) {
            o = e[u].triangleSegmentIdx;
            let v = 0, S = u, D = u;
            for (let x = S; x < l && e[x].subtile === v; x++)
              D++;
            for (; S !== l; ) {
              const x = e[S];
              v = x.subtile;
              const A = this.centroidData[x.centroidIdx].min.clone(), I = this.centroidData[x.centroidIdx].max.clone(), M = { vertexOffset: this.segments.segments[o].vertexOffset, primitiveOffset: n.length, vertexLength: this.segments.segments[o].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let C = S; C < D; C++) {
                const k = e[C], V = this.polygonSegments[k.polygonSegmentIdx], U = this.centroidData[k.centroidIdx].min, q = this.centroidData[k.centroidIdx].max, $ = this.indexArray.uint16;
                for (let H = V.triangleArrayOffset; H < V.triangleArrayOffset + V.triangleCount; H++)
                  n.emplaceBack($[3 * H], $[3 * H + 1], $[3 * H + 2]);
                M.primitiveLength += V.triangleCount, A.x = Math.min(A.x, U.x), A.y = Math.min(A.y, U.y), I.x = Math.max(I.x, q.x), I.y = Math.max(I.y, q.y);
              }
              M.primitiveLength > 0 && this.triangleSubSegments.push({ segment: M, min: A, max: I }), S = D;
              for (let C = S; C < l && e[C].subtile === e[S].subtile; C++)
                D++;
            }
            u = l;
            for (let x = u; x < f && e[x].triangleSegmentIdx === e[u].triangleSegmentIdx; x++)
              l++;
          }
          n._trim(), this.indexArray = n;
        }
        getVisibleSegments(e, n, o) {
          const u = new Wn();
          if (this.wallMode) {
            for (const k of this.triangleSubSegments)
              u.segments.push(k.segment);
            return u;
          }
          let l = 0, f = 0;
          const v = 1 << e.canonical.z;
          if (n) {
            const k = n.getMinMaxForTile(e);
            k && (l = k.min, f = k.max);
          }
          f += this.maxHeight;
          const S = e.toUnwrapped();
          let D;
          const x = [S.canonical.x / v + S.wrap, S.canonical.y / v], A = [(S.canonical.x + 1) / v + S.wrap, (S.canonical.y + 1) / v], I = (k, V, U) => [k[0] * (1 - U[0]) + V[0] * U[0], k[1] * (1 - U[1]) + V[1] * U[1]], M = [], C = [];
          for (const k of this.triangleSubSegments) {
            M[0] = k.min.x / Tt, M[1] = k.min.y / Tt, C[0] = k.max.x / Tt, C[1] = k.max.y / Tt;
            const V = I(x, A, M), U = I(x, A, C);
            if (new Jt([V[0], V[1], l], [U[0], U[1], f]).intersectsPrecise(o) === 0) {
              D && (u.segments.push(D), D = void 0);
              continue;
            }
            const q = k.segment;
            D && D.vertexOffset !== q.vertexOffset && (u.segments.push(D), D = void 0), D ? (D.vertexLength += q.vertexLength, D.primitiveLength += q.primitiveLength) : D = { vertexOffset: q.vertexOffset, primitiveLength: q.primitiveLength, vertexLength: q.vertexLength, primitiveOffset: q.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return D && u.segments.push(D), u;
        }
        encodeCentroid(e, n) {
          const o = e.centroid(), u = n.span(), l = Math.min(7, Math.round(u.x * this.tileToMeter / 10)), f = Math.min(7, Math.round(u.y * this.tileToMeter / 10));
          return new Et(si(o.x, 1, Tt - 1) << 3 | l, si(o.y, 1, Tt - 1) << 3 | f);
        }
        encodeBorderCentroid(e) {
          if (!e.borders)
            return new Et(0, 0);
          const n = e.borders, o = Number.MAX_VALUE;
          if (n[0][0] !== o || n[1][0] !== o) {
            const u = n[0][0] !== o ? 0 : 1;
            return new Et(6 | (n[0][0] !== o ? 0 : 65528), (n[u][0] + n[u][1]) / 2 << 3 | 6);
          }
          {
            const u = n[2][0] !== o ? 2 : 3;
            return new Et((n[u][0] + n[u][1]) / 2 << 3 | 6, 6 | (n[2][0] !== o ? 0 : 65528));
          }
        }
        showCentroid(e) {
          const n = this.centroidData[e.centroidDataIndex];
          n.flags &= yc, n.centroidXY.x = 0, n.centroidXY.y = 0, this.writeCentroidToBuffer(n);
        }
        writeCentroidToBuffer(e) {
          this.groundEffect.updateHiddenByLandmark(e);
          const n = e.vertexArrayOffset, o = e.vertexCount + e.vertexArrayOffset, u = e.flags & yc ? a0 : e.centroidXY, l = this.centroidVertexArray.geta_centroid_pos0(n);
          if (this.centroidVertexArray.geta_centroid_pos1(n) !== u.y || l !== u.x) {
            for (let f = n; f < o; ++f)
              this.centroidVertexArray.emplace(f, u.x, u.y);
            this.needsCentroidUpdate = !0;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const e of this.centroidData)
            this.writeCentroidToBuffer(e);
        }
        updateReplacement(e, n, o) {
          if (n.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = n.updateTime;
          const u = n.getReplacementRegionsForTile(e.toUnwrapped());
          if (E_(this.activeReplacements, u))
            return;
          if (this.activeReplacements = u, this.centroidVertexArray.length === 0)
            this.createCentroidsBuffer();
          else
            for (const f of this.centroidData)
              f.flags &= 2147483647;
          const l = [];
          for (const f of this.activeReplacements) {
            if (f.order < o)
              continue;
            const v = Math.max(1, Math.pow(2, f.footprintTileId.canonical.z - e.canonical.z));
            for (const S of this.centroidData)
              if (!(S.flags & yc || f.min.x > S.max.x || S.min.x > f.max.x || f.min.y > S.max.y || S.min.y > f.max.y))
                for (let D = 0; D < S.footprintSegLen; D++) {
                  const x = this.footprintSegments[S.footprintSegIdx + D];
                  if (l.length = 0, iT(this.footprintVertices, x.vertexOffset, x.vertexCount, f.footprintTileId.canonical, e.canonical, l), i0(f.footprint, l, this.footprintIndices.uint16, x.indexOffset, x.indexCount, -x.vertexOffset, -v)) {
                    S.flags |= yc;
                    break;
                  }
                }
          }
          for (const f of this.centroidData)
            this.writeCentroidToBuffer(f);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(e, n, o) {
          let u = !1;
          for (let l = 0; l < o.footprintSegLen; l++) {
            const f = this.footprintSegments[o.footprintSegIdx + l];
            let v = 0;
            for (const S of f.ringIndices) {
              for (let D = v, x = S + v - 1; D < S + v; x = D++) {
                const A = this.footprintVertices.int16[2 * (D + f.vertexOffset) + 0], I = this.footprintVertices.int16[2 * (D + f.vertexOffset) + 1], M = this.footprintVertices.int16[2 * (x + f.vertexOffset) + 1];
                I > n != M > n && e < (this.footprintVertices.int16[2 * (x + f.vertexOffset) + 0] - A) * (n - I) / (M - I) + A && (u = !u);
              }
              v = S;
            }
          }
          return u;
        }
        getHeightAtTileCoord(e, n) {
          let o = Number.NEGATIVE_INFINITY, u = !0;
          const l = 4 * (e + Tt) * Tt + (n + Tt);
          if (this.partLookup.hasOwnProperty(l)) {
            const f = this.partLookup[l];
            return f ? { height: f.height, hidden: !!(f.flags & yc) } : void 0;
          }
          for (const f of this.centroidData)
            e > f.max.x || f.min.x > e || n > f.max.y || f.min.y > n || this.footprintContainsPoint(e, n, f) && f && f.height > o && (o = f.height, this.partLookup[l] = f, u = !!(f.flags & yc));
          if (o !== Number.NEGATIVE_INFINITY)
            return { height: o, hidden: u };
          this.partLookup[l] = void 0;
        }
      }
      function f0(r, e) {
        const n = r.add(e)._unit();
        return r.x * n.x + r.y * n.y;
      }
      function tT(r, e, n, o) {
        const u = e.sub(r)._perp()._unit(), l = n.sub(e)._perp()._unit();
        return p0(r, e, n, f0(u, l), o);
      }
      function p0(r, e, n, o, u) {
        const l = Math.sqrt(1 - o * o);
        return Math.min(r.dist(e) / 3, e.dist(n) / 3, u * l / o);
      }
      function C_(r, e, n) {
        return r.x < n[0].x && e.x < n[0].x || r.x > n[1].x && e.x > n[1].x || r.y < n[0].y && e.y < n[0].y || r.y > n[1].y && e.y > n[1].y;
      }
      function m0(r, e) {
        return r.x < e[0].x || r.x > e[1].x || r.y < e[0].y || r.y > e[1].y;
      }
      function _0(r, e, n) {
        if (r.x < 0 || r.x >= Tt || e.x < 0 || e.x >= Tt || n.x < 0 || n.x >= Tt)
          return !1;
        const o = n.sub(e), u = o.perp(), l = r.sub(e);
        return (o.x * l.x + o.y * l.y) / Math.sqrt((o.x * o.x + o.y * o.y) * (l.x * l.x + l.y * l.y)) > -0.866 && u.x * l.x + u.y * l.y < 0;
      }
      function g0(r, e, n) {
        const o = e ? 2 | r : -3 & r;
        return n ? 1 | o : -2 & o;
      }
      function y0() {
        const r = Math.PI / 32, e = Math.tan(r), n = _c;
        return n * Math.sqrt(1 + 2 * e * e) - n;
      }
      function x0(r, e, n) {
        const o = 1 << n.z, u = Fr(n.x / o), l = Fr((n.x + 1) / o), f = Os(n.y / o), v = Os((n.y + 1) / o);
        return function(S, D, x, A, I = 0, M) {
          const C = [];
          if (!S.length || !x || !A)
            return C;
          const k = (Q, ie) => {
            for (const fe of Q)
              C.push({ polygon: fe, bounds: ie });
          }, V = Math.ceil(Math.log2(x)), U = Math.ceil(Math.log2(A)), q = V - U, $ = [];
          for (let Q = 0; Q < Math.abs(q); Q++)
            $.push(q > 0 ? 0 : 1);
          for (let Q = 0; Q < Math.min(V, U); Q++)
            $.push(0), $.push(1);
          let H = S;
          if (H = Ep(H, D[0].y - I, D[1].y + I, 1), H = Ep(H, D[0].x - I, D[1].x + I, 0), !H.length)
            return C;
          const K = [];
          for ($.length ? K.push({ polygons: H, bounds: D, depth: 0 }) : k(H, D); K.length; ) {
            const Q = K.pop(), ie = Q.depth, fe = $[ie], de = Q.bounds[0], ue = Q.bounds[1], Se = fe === 0 ? de.x : de.y, me = fe === 0 ? ue.x : ue.y, Ee = M ? M(fe, Se, me) : 0.5 * (Se + me), ze = Ep(Q.polygons, Se - I, Ee + I, fe), Ie = Ep(Q.polygons, Ee - I, me + I, fe);
            if (ze.length) {
              const Re = [de, new Et(fe === 0 ? Ee : ue.x, fe === 1 ? Ee : ue.y)];
              $.length > ie + 1 ? K.push({ polygons: ze, bounds: Re, depth: ie + 1 }) : k(ze, Re);
            }
            if (Ie.length) {
              const Re = [new Et(fe === 0 ? Ee : de.x, fe === 1 ? Ee : de.y), ue];
              $.length > ie + 1 ? K.push({ polygons: Ie, bounds: Re, depth: ie + 1 }) : k(Ie, Re);
            }
          }
          return C;
        }(r, e, Math.ceil((l - u) / 11.25), Math.ceil((f - v) / 11.25), 1, (S, D, x) => {
          if (S === 0)
            return 0.5 * (D + x);
          {
            const A = Os((n.y + D / Tt) / o);
            return (Ta(0.5 * (Os((n.y + x / Tt) / o) + A)) * o - n.y) * Tt;
          }
        });
      }
      function iT(r, e, n, o, u, l) {
        const f = Math.pow(2, o.z - u.z);
        for (let v = 0; v < n; v++) {
          let S = r.int16[2 * (v + e) + 0], D = r.int16[2 * (v + e) + 1];
          S = (S + u.x * Tt) * f - o.x * Tt, D = (D + u.y * Tt) * f - o.y * Tt, l.push(new Et(S, D));
        }
      }
      let v0, b0;
      function qd(r, e) {
        return r.x * e.x + r.y * e.y;
      }
      function w0(r, e) {
        if (r.length === 1) {
          let n = 0;
          const o = e[n++];
          let u;
          for (; !u || o.equals(u); )
            if (u = e[n++], !u)
              return 1 / 0;
          for (; n < e.length; n++) {
            const l = e[n], f = r[0], v = u.sub(o), S = l.sub(o), D = f.sub(o), x = qd(v, v), A = qd(v, S), I = qd(S, S), M = qd(D, v), C = qd(D, S), k = x * I - A * A, V = (I * M - A * C) / k, U = (x * C - A * M) / k, q = o.z * (1 - V - U) + u.z * V + l.z * U;
            if (isFinite(q))
              return q;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const o of e)
            n = Math.min(n, o.z);
          return n;
        }
      }
      function T0(r, e, n, o, u, l, f, v) {
        const S = f * u.getElevationAt(r, e, !0, !0), D = l[0] !== 0, x = D ? l[1] === 0 ? f * (l[0] / 7 - 450) : f * function(A, I, M) {
          const C = Math.floor(I[0] / 8), k = Math.floor(I[1] / 8), V = 10 * (I[0] - 8 * C), U = 10 * (I[1] - 8 * k), q = A.getElevationAt(C, k, !0, !0), $ = A.getMeterToDEM(M), H = Math.floor(0.5 * (V * $ - 1)), K = Math.floor(0.5 * (U * $ - 1)), Q = A.tileCoordToPixel(C, k), ie = 2 * H + 1, fe = 2 * K + 1, de = function(Ie, Re, Ve, Ue, Fe) {
            return [Ie.getElevationAtPixel(Re, Ve, !0), Ie.getElevationAtPixel(Re + Fe, Ve, !0), Ie.getElevationAtPixel(Re, Ve + Fe, !0), Ie.getElevationAtPixel(Re + Ue, Ve + Fe, !0)];
          }(A, Q.x - H, Q.y - K, ie, fe), ue = Math.abs(de[0] - de[1]), Se = Math.abs(de[2] - de[3]), me = Math.abs(de[0] - de[2]) + Math.abs(de[1] - de[3]), Ee = Math.min(0.25, 0.5 * $ * (ue + Se) / ie), ze = Math.min(0.25, 0.5 * $ * me / fe);
          return q + Math.max(Ee * V, ze * U);
        }(u, l, v) : S;
        return { base: S + (n === 0 ? -1 : n), top: D ? Math.max(x + o, S + n + 2) : S + o };
      }
      Ft(Ip, "FillExtrusionBucket", { omit: ["layers", "features"] }), Ft(c0, "PartData"), Ft(l0, "FootprintSegment"), Ft(h0, "BorderCentroidData"), Ft(d0, "GroundEffect");
      const nT = qi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), sT = qi([{ name: "a_z_offset_width", components: 2, type: "Float32" }], 4), { members: rT } = nT, oT = qi([{ name: "a_packed", components: 4, type: "Float32" }]), { members: aT } = oT, lT = qi([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: cT } = lT;
      class M0 {
        constructor(e, n) {
          this.width = e, this.height = n, this.nextRow = 0, this.image = new gc({ width: e, height: n }), this.positions = {}, this.uploaded = !1;
        }
        getDash(e, n) {
          const o = this.getKey(e, n);
          return this.positions[o];
        }
        trim() {
          const e = this.width, n = this.height = xo(this.nextRow);
          this.image.resize({ width: e, height: n });
        }
        getKey(e, n) {
          return e.join(",") + n;
        }
        getDashRanges(e, n, o) {
          const u = [];
          let l = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, f = e[0] * o, v = !0;
          u.push({ left: l, right: f, isDash: v, zeroLength: e[0] === 0 });
          let S = e[0];
          for (let D = 1; D < e.length; D++) {
            v = !v;
            const x = e[D];
            l = S * o, S += x, f = S * o, u.push({ left: l, right: f, isDash: v, zeroLength: x === 0 });
          }
          return u;
        }
        addRoundDash(e, n, o) {
          const u = n / 2;
          for (let l = -o; l <= o; l++) {
            const f = this.width * (this.nextRow + o + l);
            let v = 0, S = e[v];
            for (let D = 0; D < this.width; D++) {
              D / S.right > 1 && (S = e[++v]);
              const x = Math.abs(D - S.left), A = Math.abs(D - S.right), I = Math.min(x, A);
              let M;
              const C = l / o * (u + 1);
              if (S.isDash) {
                const k = u - Math.abs(C);
                M = Math.sqrt(I * I + k * k);
              } else
                M = u - Math.sqrt(I * I + C * C);
              this.image.data[f + D] = Math.max(0, Math.min(255, M + 128));
            }
          }
        }
        addRegularDash(e, n) {
          for (let S = e.length - 1; S >= 0; --S) {
            const D = e[S], x = e[S + 1];
            D.zeroLength ? e.splice(S, 1) : x && x.isDash === D.isDash && (x.left = D.left, e.splice(S, 1));
          }
          const o = e[0], u = e[e.length - 1];
          o.isDash === u.isDash && (o.left = u.left - this.width, u.right = o.right + this.width);
          const l = this.width * this.nextRow;
          let f = 0, v = e[f];
          for (let S = 0; S < this.width; S++) {
            S / v.right > 1 && (v = e[++f]);
            const D = Math.abs(S - v.left), x = Math.abs(S - v.right), A = Math.min(D, x);
            this.image.data[l + S] = Math.max(0, Math.min(255, (v.isDash ? A : -A) + n + 128));
          }
        }
        addDash(e, n) {
          const o = this.getKey(e, n);
          if (this.positions[o])
            return this.positions[o];
          const u = n === "round", l = u ? 7 : 0, f = 2 * l + 1;
          if (this.nextRow + f > this.height)
            return mi("LineAtlas out of space"), null;
          e.length === 0 && e.push(1);
          let v = 0;
          for (let x = 0; x < e.length; x++)
            e[x] < 0 && (mi("Negative value is found in line dasharray, replacing values with 0"), e[x] = 0), v += e[x];
          if (v !== 0) {
            const x = this.width / v, A = this.getDashRanges(e, this.width, x);
            u ? this.addRoundDash(A, x, l) : this.addRegularDash(A, n === "square" ? 0.5 * x : 0);
          }
          const S = this.nextRow + l;
          this.nextRow += f;
          const D = { tl: [S, l], br: [v, 0] };
          return this.positions[o] = D, D;
        }
      }
      Ft(M0, "LineAtlas");
      const hT = Iu.VectorTileFeature.types, uT = Math.cos(Math.PI / 180 * 37.5), dT = Math.cos(Math.PI / 180 * 5);
      class I_ {
        constructor(e) {
          this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new ho(), this.layoutVertexArray2 = new Xa(), this.patternVertexArray = new va(), this.indexArray = new qs(), this.programConfigurations = new Qa(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Wn(), this.maxLineLength = 0, this.zOffsetVertexArray = new Al(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : Tt / 64;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.hasPattern = y_("line", this.layers, n);
          const l = this.layers[0].layout.get("line-sort-key");
          this.tileToMeter = s(o), this.hasZOffset = !this.layers[0].isDraped();
          const f = this.layers[0].layout.get("line-elevation-reference");
          this.hasZOffset && f === "none" && mi(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
          const v = this.layers[0].layout.get("line-cross-slope");
          this.hasCrossSlope = this.hasZOffset && v !== void 0;
          const S = [];
          for (const { feature: I, id: M, index: C, sourceLayerIndex: k } of e) {
            const V = this.layers[0]._featureFilter.needGeometry, U = Z(I, V);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), U, o))
              continue;
            const q = l ? l.evaluate(U, {}, o) : void 0, $ = { id: M, properties: I.properties, type: I.type, sourceLayerIndex: k, index: C, geometry: V ? U.geometry : G(I, o, u), patterns: {}, sortKey: q };
            S.push($);
          }
          l && S.sort((I, M) => I.sortKey - M.sortKey);
          const { lineAtlas: D, featureIndex: x } = n, A = this.addConstantDashes(D);
          for (const I of S) {
            const { geometry: M, index: C, sourceLayerIndex: k } = I;
            if (A && this.addFeatureDashes(I, D), this.hasPattern) {
              const V = x_("line", this.layers, I, this.zoom, n);
              this.patternFeatures.push(V);
            } else
              this.addFeature(I, M, C, o, D.positions, n.availableImages, n.brightness);
            x.insert(e[C].feature, M, C, k, this.index);
          }
        }
        addConstantDashes(e) {
          let n = !1;
          for (const o of this.layers) {
            const u = o.paint.get("line-dasharray").value, l = o.layout.get("line-cap").value;
            if (u.kind !== "constant" || l.kind !== "constant")
              n = !0;
            else {
              const f = l.value, v = u.value;
              if (!v)
                continue;
              e.addDash(v, f);
            }
          }
          return n;
        }
        addFeatureDashes(e, n) {
          const o = this.zoom;
          for (const u of this.layers) {
            const l = u.paint.get("line-dasharray").value, f = u.layout.get("line-cap").value;
            if (l.kind === "constant" && f.kind === "constant")
              continue;
            let v, S;
            if (l.kind === "constant") {
              if (v = l.value, !v)
                continue;
            } else
              v = l.evaluate({ zoom: o }, e);
            S = f.kind === "constant" ? f.value : f.evaluate({ zoom: o }, e), n.addDash(v, S), e.patterns[u.id] = n.getKey(v, S);
          }
        }
        update(e, n, o, u, l, f, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v);
        }
        addFeatures(e, n, o, u, l, f) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, n, o, u, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, aT)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, cT)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, sT.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, rT), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, n, o, u, l, f, v) {
          const S = this.layers[0].layout, D = S.get("line-join").evaluate(e, {}), x = S.get("line-cap").evaluate(e, {}), A = S.get("line-miter-limit"), I = S.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = S.get("line-z-offset").value;
          const M = this.layers[0].paint.get("line-width").value;
          M.kind !== "constant" && M.isLineProgressConstant === !1 && (this.variableWidthValue = M);
          for (const C of n)
            this.addLine(C, e, u, D, x, A, I);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, f, u, v);
        }
        addLine(e, n, o, u, l, f, v) {
          this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
          const S = u === "none";
          if (this.patternJoinNone = this.hasPattern && S, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let $ = 0; $ < e.length - 1; $++)
              this.totalDistance += e[$].dist(e[$ + 1]);
            this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const D = hT[n.type] === "Polygon";
          let x = e.length;
          for (; x >= 2 && e[x - 1].equals(e[x - 2]); )
            x--;
          let A = 0;
          for (; A < x - 1 && e[A].equals(e[A + 1]); )
            A++;
          if (x < (D ? 3 : 2))
            return;
          u === "bevel" && (f = 1.05);
          const I = this.segments.prepareSegment(10 * x, this.layoutVertexArray, this.indexArray);
          let M, C, k, V, U, q;
          this.e1 = this.e2 = -1, D && (M = e[x - 2], U = e[A].sub(M)._unit()._perp());
          for (let $ = A; $ < x; $++) {
            if (k = $ === x - 1 ? D ? e[A + 1] : void 0 : e[$ + 1], k && e[$].equals(k))
              continue;
            U && (V = U), M && (C = M), M = e[$], q = this.evaluateLineProgressFeatures(C ? C.dist(M) : 0), U = k ? k.sub(M)._unit()._perp() : V, V = V || U;
            const H = C && k;
            let K = H ? u : D || S ? "butt" : l;
            const Q = V.x * U.x + V.y * U.y;
            if (S) {
              const ze = function(Ie) {
                if (Ie.patternJoinNone) {
                  const Re = Ie.segmentPoints.length / 2, Ve = Ie.lineSoFar - Ie.segmentStart;
                  for (let Ue = 0; Ue < Re; ++Ue) {
                    const Fe = Ie.segmentPoints[2 * Ue + 1], et = Math.round(Ie.segmentPoints[2 * Ue]) + 0.5 + 0.25 * Fe;
                    Ie.patternVertexArray.emplaceBack(et, Ve, Ie.segmentStart), Ie.patternVertexArray.emplaceBack(et, Ve, Ie.segmentStart);
                  }
                  Ie.segmentPoints.length = 0;
                }
                Ie.e1 = Ie.e2 = -1;
              };
              if (H && Q < dT) {
                this.updateDistance(C, M), this.addCurrentVertex(M, V, 1, 1, I, q), ze(this), this.addCurrentVertex(M, U, -1, -1, I, q);
                continue;
              }
              if (C) {
                if (!k) {
                  this.updateDistance(C, M), this.addCurrentVertex(M, V, 1, 1, I, q), ze(this);
                  continue;
                }
                K = "miter";
              }
            }
            let ie = V.add(U);
            ie.x === 0 && ie.y === 0 || ie._unit();
            const fe = ie.x * U.x + ie.y * U.y, de = fe !== 0 ? 1 / fe : 1 / 0, ue = 2 * Math.sqrt(2 - 2 * fe), Se = fe < uT && C && k, me = V.x * U.y - V.y * U.x > 0, Ee = this.overscaling <= 16 ? 15 * Tt / (512 * this.overscaling) : 0;
            if (H && K === "round") {
              if (de < v)
                K = "miter";
              else if (de <= 2) {
                const ze = L_(M, -10, Tt + 10);
                K = this.hasZOffset && (ze || this.hasCrossSlope) ? "miter" : "fakeround";
              }
            }
            if (K === "miter" && de > f && (K = "bevel"), K === "bevel" && (de > 2 && (K = "flipbevel"), de < f && (K = "miter")), C && !(K === "miter" && Se) && this.updateDistance(C, M), K === "miter")
              if (Se) {
                const ze = M.dist(C);
                if (ze > 2 * Ee) {
                  const Re = M.sub(M.sub(C)._mult(Ee / ze)._round());
                  this.updateDistance(C, Re), this.addCurrentVertex(Re, V, 0, 0, I, q), C = Re;
                }
                this.updateDistance(C, M), ie._mult(de), this.addCurrentVertex(M, ie, 0, 0, I, q);
                const Ie = M.dist(k);
                if (Ie > 2 * Ee) {
                  const Re = M.add(k.sub(M)._mult(Ee / Ie)._round());
                  this.updateDistance(M, Re), this.addCurrentVertex(Re, U, 0, 0, I, q), M = Re;
                }
              } else
                ie._mult(de), this.addCurrentVertex(M, ie, 0, 0, I, q);
            else if (K === "flipbevel") {
              if (de > 100)
                ie = U.mult(-1);
              else {
                const ze = de * V.add(U).mag() / V.sub(U).mag();
                ie._perp()._mult(ze * (me ? -1 : 1));
              }
              this.addCurrentVertex(M, ie, 0, 0, I, q), this.addCurrentVertex(M, ie.mult(-1), 0, 0, I, q);
            } else if (K === "bevel" || K === "fakeround") {
              q != null && C && this.addCurrentVertex(M, V, -1, -1, I, q);
              const ze = M.dist(C) <= 2 * Ee && K !== "bevel", Ie = ie.mult(me ? 1 : -1);
              Ie._mult(de);
              const Re = U.mult(me ? -1 : 1), Ve = V.mult(me ? -1 : 1), Ue = this.evaluateLineProgressFeatures(this.distance);
              if (q == null && (this.addHalfVertex(M, Ie.x, Ie.y, !1, !me, 0, I, Ue), ze || this.addHalfVertex(M, Ie.x + 2 * Ve.x, Ie.y + 2 * Ve.y, !1, me, 0, I, Ue)), K === "fakeround") {
                const Fe = Math.round(180 * ue / Math.PI / 20);
                this.addHalfVertex(M, Ve.x, Ve.y, !1, me, 0, I, Ue);
                for (let et = 0; et < Fe; et++) {
                  let dt = et / Fe;
                  if (dt !== 0.5) {
                    const Mt = dt - 0.5;
                    dt += dt * Mt * (dt - 1) * ((1.0904 + Q * (Q * (3.55645 - 1.43519 * Q) - 3.2452)) * Mt * Mt + (0.848013 + Q * (0.215638 * Q - 1.06021)));
                  }
                  const tt = Re.sub(Ve)._mult(dt)._add(Ve)._unit();
                  this.addHalfVertex(M, tt.x, tt.y, !1, me, 0, I, Ue);
                }
                this.addHalfVertex(M, Re.x, Re.y, !1, me, 0, I, Ue);
              }
              ze || q != null || this.addHalfVertex(M, Ie.x + 2 * Re.x, Ie.y + 2 * Re.y, !1, me, 0, I, Ue), q != null && k && this.addCurrentVertex(M, U, 1, 1, I, q);
            } else
              K === "butt" ? this.addCurrentVertex(M, ie, 0, 0, I, q) : K === "square" ? (C || this.addCurrentVertex(M, ie, -1, -1, I, q), this.addCurrentVertex(M, ie, 0, 0, I, q), C && this.addCurrentVertex(M, ie, 1, 1, I, q)) : K === "round" && (C && (this.addCurrentVertex(M, V, 0, 0, I, q), this.addCurrentVertex(M, V, 1, 1, I, q, !0)), k && (this.addCurrentVertex(M, U, -1, -1, I, q, !0), this.addCurrentVertex(M, U, 0, 0, I, q)));
          }
        }
        addVerticesTo(e, n, o, u, l, f, v, S, D, x) {
          const A = (n.w - e.w) / this.tessellationStep | 0;
          let I = 0;
          const M = this.scaledDistance;
          if (A > 1) {
            this.lineSoFar = e.w;
            const k = (n.x - e.x) / A, V = (n.y - e.y) / A, U = (n.z - e.z) / A, q = (n.w - e.w) / A;
            for (let $ = 1; $ < A; ++$) {
              e.x += k, e.y += V, e.z += U, this.lineSoFar += q, I += q;
              const H = this.evaluateLineProgressFeatures(this.prevDistance + I);
              this.scaledDistance = (this.prevDistance + I) / this.totalDistance, this.addHalfVertex(e, o, u, x, !1, v, D, H), this.addHalfVertex(e, l, f, x, !0, -S, D, H);
            }
          }
          this.lineSoFar = n.w, this.scaledDistance = M;
          const C = this.evaluateLineProgressFeatures(this.distance);
          this.addHalfVertex(n, o, u, x, !1, v, D, C), this.addHalfVertex(n, l, f, x, !0, -S, D, C);
        }
        evaluateLineProgressFeatures(e) {
          if (!this.variableWidthValue && !this.hasZOffset)
            return null;
          this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : mi(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
          let n = 0;
          return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (n = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? this.zOffsetValue.kind === "constant" ? { zOffset: this.zOffsetValue.value, variableWidth: n } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: n } : { zOffset: 0, variableWidth: n };
        }
        addCurrentVertex(e, n, o, u, l, f, v = !1) {
          const S = n.x + n.y * o, D = n.y - n.x * o, x = n.y * u - n.x, A = -n.y - n.x * u;
          if (f != null) {
            const I = this.hasZOffset, M = -10, C = Tt + 10, k = f.zOffset, V = new Yy(e.x, e.y, k, this.lineSoFar), U = !!I && L_(e, M, C), q = this.lineSoFar, $ = this.distance;
            if (this.currentVertex)
              if (U) {
                const H = this.currentVertexIsOutside, K = this.currentVertex, Q = new Yy(e.x, e.y, k, this.lineSoFar);
                if (Jy(K, Q, M, C), !L_(Q, M, C)) {
                  if (H) {
                    this.e1 = this.e2 = -1, this.distance -= K.dist(V), this.lineSoFar = K.w;
                    const ie = this.evaluateLineProgressFeatures(K.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(K, S, D, v, !1, o, l, ie), this.addHalfVertex(K, x, A, v, !0, -u, l, ie), this.prevDistance = this.distance;
                  }
                  this.distance = this.prevDistance + K.dist(Q), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(K, Q, S, D, x, A, o, u, l, v), this.distance = $, this.scaledDistance = this.distance / this.totalDistance;
                }
              } else {
                const H = this.currentVertex;
                if (this.currentVertexIsOutside) {
                  Jy(H, V, M, C), this.e1 = this.e2 = -1, this.distance -= H.dist(V), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = H.w;
                  const K = this.evaluateLineProgressFeatures(H.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(H, S, D, v, !1, o, l, K), this.addHalfVertex(H, x, A, v, !0, -u, l, K), this.prevDistance = this.distance, this.distance = $, this.scaledDistance = this.distance / this.totalDistance;
                }
                this.addVerticesTo(H, V, S, D, x, A, o, u, l, v);
              }
            else
              U || (this.addHalfVertex(e, S, D, v, !1, o, l, f), this.addHalfVertex(e, x, A, v, !0, -u, l, f));
            this.currentVertex = V, this.currentVertexIsOutside = U, this.lineSoFar = q;
          } else
            this.addHalfVertex(e, S, D, v, !1, o, l, f), this.addHalfVertex(e, x, A, v, !0, -u, l, f);
        }
        addHalfVertex({ x: e, y: n }, o, u, l, f, v, S, D) {
          this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), f || this.segmentPoints.push(this.lineSoFar - this.segmentStart, v)), this.layoutVertexArray.emplaceBack((e << 1) + (l ? 1 : 0), (n << 1) + (f ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const x = S.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, x), S.primitiveLength++), f ? this.e2 = x : this.e1 = x, D != null && this.zOffsetVertexArray.emplaceBack(D.zOffset, D.variableWidth);
        }
        updateScaledDistance() {
          this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
        }
        updateDistance(e, n) {
          this.prevDistance = this.distance, this.distance += e.dist(n), this.updateScaledDistance();
        }
      }
      function L_(r, e, n) {
        return r.x < e || r.x > n || r.y < e || r.y > n;
      }
      let S0, E0;
      function A0(r, e, n) {
        return e * (Tt / (r.tileSize * Math.pow(2, n - r.tileID.overscaledZ)));
      }
      Ft(I_, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
      const P0 = (r, e, n) => (1 - n) * r + n * e;
      function C0(r, e) {
        return 1 / A0(r, 1, e.tileZoom);
      }
      function I0(r, e, n, o) {
        return r.translatePosMatrix(o || e.tileID.projMatrix, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"));
      }
      const L0 = (r) => {
        const e = [];
        z0(r) && e.push("RENDER_LINE_DASH"), r.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
        const n = r.paint.get("line-trim-offset");
        n[0] === 0 && n[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), r.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER");
        const o = r.layout.get("line-join").constantOr("miter") === "none", u = !!r.paint.get("line-pattern").constantOr(1);
        return o && u && e.push("LINE_JOIN_NONE"), e;
      };
      function z0(r) {
        const e = r.paint.get("line-dasharray").value;
        return e.value || e.kind !== "constant";
      }
      let z_;
      const D0 = () => z_ || (z_ = { layout: S0 || (S0 = new Bn({ "line-cap": new Dt($e.layout_line["line-cap"]), "line-join": new Dt($e.layout_line["line-join"]), "line-miter-limit": new yt($e.layout_line["line-miter-limit"]), "line-round-limit": new yt($e.layout_line["line-round-limit"]), "line-sort-key": new Dt($e.layout_line["line-sort-key"]), "line-z-offset": new Dt($e.layout_line["line-z-offset"]), "line-elevation-reference": new yt($e.layout_line["line-elevation-reference"]), "line-cross-slope": new yt($e.layout_line["line-cross-slope"]), visibility: new yt($e.layout_line.visibility), "line-width-unit": new yt($e.layout_line["line-width-unit"]) })), paint: E0 || (E0 = new Bn({ "line-opacity": new Dt($e.paint_line["line-opacity"]), "line-color": new Dt($e.paint_line["line-color"]), "line-translate": new yt($e.paint_line["line-translate"]), "line-translate-anchor": new yt($e.paint_line["line-translate-anchor"]), "line-width": new Dt($e.paint_line["line-width"]), "line-gap-width": new Dt($e.paint_line["line-gap-width"]), "line-offset": new Dt($e.paint_line["line-offset"]), "line-blur": new Dt($e.paint_line["line-blur"]), "line-dasharray": new Dt($e.paint_line["line-dasharray"]), "line-pattern": new Dt($e.paint_line["line-pattern"]), "line-gradient": new Wa($e.paint_line["line-gradient"]), "line-trim-offset": new yt($e.paint_line["line-trim-offset"]), "line-trim-fade-range": new yt($e.paint_line["line-trim-fade-range"]), "line-trim-color": new yt($e.paint_line["line-trim-color"]), "line-emissive-strength": new yt($e.paint_line["line-emissive-strength"]), "line-border-width": new Dt($e.paint_line["line-border-width"]), "line-border-color": new Dt($e.paint_line["line-border-color"]), "line-occlusion-opacity": new yt($e.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, z_);
      class fT extends Dt {
        possiblyEvaluate(e, n) {
          return n = new Tn(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, transition: n.transition }), super.possiblyEvaluate(e, n);
        }
        evaluate(e, n, o, u) {
          return n = Pn({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(e, n, o, u);
        }
      }
      let Wd;
      function k0(r, e) {
        return e > 0 ? e + 2 * r : r;
      }
      const pT = qi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), mT = qi([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), _T = qi([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      qi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const gT = qi([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), yT = qi([{ name: "a_texb", components: 2, type: "Uint16" }]), xT = qi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), vT = qi([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
      qi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const R0 = qi([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), bT = qi([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      qi([{ name: "triangle", components: 3, type: "Uint16" }]), qi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), qi([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), qi([{ type: "Float32", name: "offsetX" }]), qi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var tr = 24;
      const Sa = 128;
      function Lp(r, e, n, o, u) {
        if (r.kind === "camera")
          return r.maxSize;
        if (r.kind === "composite") {
          const l = e.possiblyEvaluate(new Tn(r.maxZoom), n).evaluate(u, {}, n), f = e.possiblyEvaluate(new Tn(r.minZoom), n).evaluate(u, {}, n);
          return Math.max(l, f);
        }
        return e.possiblyEvaluate(new Tn(o)).evaluate(u, {}, n);
      }
      function D_(r, e) {
        const { expression: n } = e;
        if (n.kind === "constant")
          return { kind: "constant", layoutSize: n.evaluate(new Tn(r + 1)) };
        if (n.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: o, interpolationType: u } = n;
          let l = 0;
          for (; l < o.length && o[l] <= r; )
            l++;
          l = Math.max(0, l - 1);
          let f = l;
          for (; f < o.length && o[f] < r + 1; )
            f++;
          f = Math.min(o.length - 1, f);
          const v = o[l], S = o[f];
          return n.kind === "composite" ? { kind: "composite", minZoom: v, maxZoom: S, interpolationType: u } : { kind: "camera", minZoom: v, maxZoom: S, minSize: n.evaluate(new Tn(v)), maxSize: n.evaluate(new Tn(S)), interpolationType: u };
        }
      }
      function zp(r, { uSize: e, uSizeT: n }, { lowerSize: o, upperSize: u }) {
        return r.kind === "source" ? o / Sa : r.kind === "composite" ? ei(o / Sa, u / Sa, n) : e;
      }
      function Lu(r, e, n = 1) {
        let o = 0, u = 0;
        if (r.kind === "constant")
          u = r.layoutSize * n;
        else if (r.kind !== "source") {
          const { interpolationType: l, minZoom: f, maxZoom: v } = r, S = l ? si(X.interpolationFactor(l, e, f, v), 0, 1) : 0;
          r.kind === "camera" ? u = ei(r.minSize, r.maxSize, S) * n : o = S * n;
        }
        return { uSizeT: o, uSize: u };
      }
      var wT = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Sa, evaluateSizeForFeature: zp, evaluateSizeForZoom: Lu, getRasterizedIconSize: Lp, getSizeData: D_ });
      function TT(r, e, n) {
        return r.sections.forEach((o) => {
          o.text = function(u, l, f) {
            const v = l.layout.get("text-transform").evaluate(f, {});
            return v === "uppercase" ? u = u.toLocaleUpperCase() : v === "lowercase" && (u = u.toLocaleLowerCase()), co.applyArabicShaping && (u = co.applyArabicShaping(u)), u;
          }(o.text, e, n);
        }), r;
      }
      const $d = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      function MT(r) {
        return r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "";
      }
      function ST(r) {
        return r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "" || r === "";
      }
      var O0, k_, F0, R_ = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function ET() {
        return O0 || (O0 = 1, R_.read = function(r, e, n, o, u) {
          var l, f, v = 8 * u - o - 1, S = (1 << v) - 1, D = S >> 1, x = -7, A = n ? u - 1 : 0, I = n ? -1 : 1, M = r[e + A];
          for (A += I, l = M & (1 << -x) - 1, M >>= -x, x += v; x > 0; l = 256 * l + r[e + A], A += I, x -= 8)
            ;
          for (f = l & (1 << -x) - 1, l >>= -x, x += o; x > 0; f = 256 * f + r[e + A], A += I, x -= 8)
            ;
          if (l === 0)
            l = 1 - D;
          else {
            if (l === S)
              return f ? NaN : 1 / 0 * (M ? -1 : 1);
            f += Math.pow(2, o), l -= D;
          }
          return (M ? -1 : 1) * f * Math.pow(2, l - o);
        }, R_.write = function(r, e, n, o, u, l) {
          var f, v, S, D = 8 * l - u - 1, x = (1 << D) - 1, A = x >> 1, I = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, M = o ? 0 : l - 1, C = o ? 1 : -1, k = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
          for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (v = isNaN(e) ? 1 : 0, f = x) : (f = Math.floor(Math.log(e) / Math.LN2), e * (S = Math.pow(2, -f)) < 1 && (f--, S *= 2), (e += f + A >= 1 ? I / S : I * Math.pow(2, 1 - A)) * S >= 2 && (f++, S /= 2), f + A >= x ? (v = 0, f = x) : f + A >= 1 ? (v = (e * S - 1) * Math.pow(2, u), f += A) : (v = e * Math.pow(2, A - 1) * Math.pow(2, u), f = 0)); u >= 8; r[n + M] = 255 & v, M += C, v /= 256, u -= 8)
            ;
          for (f = f << u | v, D += u; D > 0; r[n + M] = 255 & f, M += C, f /= 256, D -= 8)
            ;
          r[n + M - C] |= 128 * k;
        }), R_;
      }
      function B0() {
        if (F0)
          return k_;
        F0 = 1, k_ = e;
        var r = ET();
        function e(H) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(H) ? H : new Uint8Array(H || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
        var n = 4294967296, o = 1 / n, u = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
        function l(H) {
          return H.type === e.Bytes ? H.readVarint() + H.pos : H.pos + 1;
        }
        function f(H, K, Q) {
          return Q ? 4294967296 * K + (H >>> 0) : 4294967296 * (K >>> 0) + (H >>> 0);
        }
        function v(H, K, Q) {
          var ie = K <= 16383 ? 1 : K <= 2097151 ? 2 : K <= 268435455 ? 3 : Math.floor(Math.log(K) / (7 * Math.LN2));
          Q.realloc(ie);
          for (var fe = Q.pos - 1; fe >= H; fe--)
            Q.buf[fe + ie] = Q.buf[fe];
        }
        function S(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeVarint(H[Q]);
        }
        function D(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSVarint(H[Q]);
        }
        function x(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFloat(H[Q]);
        }
        function A(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeDouble(H[Q]);
        }
        function I(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeBoolean(H[Q]);
        }
        function M(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFixed32(H[Q]);
        }
        function C(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSFixed32(H[Q]);
        }
        function k(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFixed64(H[Q]);
        }
        function V(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSFixed64(H[Q]);
        }
        function U(H, K) {
          return (H[K] | H[K + 1] << 8 | H[K + 2] << 16) + 16777216 * H[K + 3];
        }
        function q(H, K, Q) {
          H[Q] = K, H[Q + 1] = K >>> 8, H[Q + 2] = K >>> 16, H[Q + 3] = K >>> 24;
        }
        function $(H, K) {
          return (H[K] | H[K + 1] << 8 | H[K + 2] << 16) + (H[K + 3] << 24);
        }
        return e.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(H, K, Q) {
          for (Q = Q || this.length; this.pos < Q; ) {
            var ie = this.readVarint(), fe = ie >> 3, de = this.pos;
            this.type = 7 & ie, H(fe, K, this), this.pos === de && this.skip(ie);
          }
          return K;
        }, readMessage: function(H, K) {
          return this.readFields(H, K, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var H = U(this.buf, this.pos);
          return this.pos += 4, H;
        }, readSFixed32: function() {
          var H = $(this.buf, this.pos);
          return this.pos += 4, H;
        }, readFixed64: function() {
          var H = U(this.buf, this.pos) + U(this.buf, this.pos + 4) * n;
          return this.pos += 8, H;
        }, readSFixed64: function() {
          var H = U(this.buf, this.pos) + $(this.buf, this.pos + 4) * n;
          return this.pos += 8, H;
        }, readFloat: function() {
          var H = r.read(this.buf, this.pos, !0, 23, 4);
          return this.pos += 4, H;
        }, readDouble: function() {
          var H = r.read(this.buf, this.pos, !0, 52, 8);
          return this.pos += 8, H;
        }, readVarint: function(H) {
          var K, Q, ie = this.buf;
          return K = 127 & (Q = ie[this.pos++]), Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 7, Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 14, Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 21, Q < 128 ? K : function(fe, de, ue) {
            var Se, me, Ee = ue.buf;
            if (Se = (112 & (me = Ee[ue.pos++])) >> 4, me < 128 || (Se |= (127 & (me = Ee[ue.pos++])) << 3, me < 128) || (Se |= (127 & (me = Ee[ue.pos++])) << 10, me < 128) || (Se |= (127 & (me = Ee[ue.pos++])) << 17, me < 128) || (Se |= (127 & (me = Ee[ue.pos++])) << 24, me < 128) || (Se |= (1 & (me = Ee[ue.pos++])) << 31, me < 128))
              return f(fe, Se, de);
            throw new Error("Expected varint not more than 10 bytes");
          }(K |= (15 & (Q = ie[this.pos])) << 28, H, this))));
        }, readVarint64: function() {
          return this.readVarint(!0);
        }, readSVarint: function() {
          var H = this.readVarint();
          return H % 2 == 1 ? (H + 1) / -2 : H / 2;
        }, readBoolean: function() {
          return !!this.readVarint();
        }, readString: function() {
          var H = this.readVarint() + this.pos, K = this.pos;
          return this.pos = H, H - K >= 12 && u ? function(Q, ie, fe) {
            return u.decode(Q.subarray(ie, fe));
          }(this.buf, K, H) : function(Q, ie, fe) {
            for (var de = "", ue = ie; ue < fe; ) {
              var Se, me, Ee, ze = Q[ue], Ie = null, Re = ze > 239 ? 4 : ze > 223 ? 3 : ze > 191 ? 2 : 1;
              if (ue + Re > fe)
                break;
              Re === 1 ? ze < 128 && (Ie = ze) : Re === 2 ? (192 & (Se = Q[ue + 1])) == 128 && (Ie = (31 & ze) << 6 | 63 & Se) <= 127 && (Ie = null) : Re === 3 ? (me = Q[ue + 2], (192 & (Se = Q[ue + 1])) == 128 && (192 & me) == 128 && ((Ie = (15 & ze) << 12 | (63 & Se) << 6 | 63 & me) <= 2047 || Ie >= 55296 && Ie <= 57343) && (Ie = null)) : Re === 4 && (me = Q[ue + 2], Ee = Q[ue + 3], (192 & (Se = Q[ue + 1])) == 128 && (192 & me) == 128 && (192 & Ee) == 128 && ((Ie = (15 & ze) << 18 | (63 & Se) << 12 | (63 & me) << 6 | 63 & Ee) <= 65535 || Ie >= 1114112) && (Ie = null)), Ie === null ? (Ie = 65533, Re = 1) : Ie > 65535 && (Ie -= 65536, de += String.fromCharCode(Ie >>> 10 & 1023 | 55296), Ie = 56320 | 1023 & Ie), de += String.fromCharCode(Ie), ue += Re;
            }
            return de;
          }(this.buf, K, H);
        }, readBytes: function() {
          var H = this.readVarint() + this.pos, K = this.buf.subarray(this.pos, H);
          return this.pos = H, K;
        }, readPackedVarint: function(H, K) {
          if (this.type !== e.Bytes)
            return H.push(this.readVarint(K));
          var Q = l(this);
          for (H = H || []; this.pos < Q; )
            H.push(this.readVarint(K));
          return H;
        }, readPackedSVarint: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSVarint());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSVarint());
          return H;
        }, readPackedBoolean: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readBoolean());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readBoolean());
          return H;
        }, readPackedFloat: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFloat());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFloat());
          return H;
        }, readPackedDouble: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readDouble());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readDouble());
          return H;
        }, readPackedFixed32: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFixed32());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFixed32());
          return H;
        }, readPackedSFixed32: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSFixed32());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSFixed32());
          return H;
        }, readPackedFixed64: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFixed64());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFixed64());
          return H;
        }, readPackedSFixed64: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSFixed64());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSFixed64());
          return H;
        }, skip: function(H) {
          var K = 7 & H;
          if (K === e.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (K === e.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (K === e.Fixed32)
            this.pos += 4;
          else {
            if (K !== e.Fixed64)
              throw new Error("Unimplemented type: " + K);
            this.pos += 8;
          }
        }, writeTag: function(H, K) {
          this.writeVarint(H << 3 | K);
        }, realloc: function(H) {
          for (var K = this.length || 16; K < this.pos + H; )
            K *= 2;
          if (K !== this.length) {
            var Q = new Uint8Array(K);
            Q.set(this.buf), this.buf = Q, this.length = K;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(H) {
          this.realloc(4), q(this.buf, H, this.pos), this.pos += 4;
        }, writeSFixed32: function(H) {
          this.realloc(4), q(this.buf, H, this.pos), this.pos += 4;
        }, writeFixed64: function(H) {
          this.realloc(8), q(this.buf, -1 & H, this.pos), q(this.buf, Math.floor(H * o), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(H) {
          this.realloc(8), q(this.buf, -1 & H, this.pos), q(this.buf, Math.floor(H * o), this.pos + 4), this.pos += 8;
        }, writeVarint: function(H) {
          (H = +H || 0) > 268435455 || H < 0 ? function(K, Q) {
            var ie, fe;
            if (K >= 0 ? (ie = K % 4294967296 | 0, fe = K / 4294967296 | 0) : (fe = ~(-K / 4294967296), 4294967295 ^ (ie = ~(-K % 4294967296)) ? ie = ie + 1 | 0 : (ie = 0, fe = fe + 1 | 0)), K >= 18446744073709552e3 || K < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            Q.realloc(10), function(de, ue, Se) {
              Se.buf[Se.pos++] = 127 & de | 128, de >>>= 7, Se.buf[Se.pos++] = 127 & de | 128, de >>>= 7, Se.buf[Se.pos++] = 127 & de | 128, de >>>= 7, Se.buf[Se.pos++] = 127 & de | 128, Se.buf[Se.pos] = 127 & (de >>>= 7);
            }(ie, 0, Q), function(de, ue) {
              var Se = (7 & de) << 4;
              ue.buf[ue.pos++] |= Se | ((de >>>= 3) ? 128 : 0), de && (ue.buf[ue.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (ue.buf[ue.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (ue.buf[ue.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (ue.buf[ue.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (ue.buf[ue.pos++] = 127 & de)))));
            }(fe, Q);
          }(H, this) : (this.realloc(4), this.buf[this.pos++] = 127 & H | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = 127 & (H >>>= 7) | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = 127 & (H >>>= 7) | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = H >>> 7 & 127))));
        }, writeSVarint: function(H) {
          this.writeVarint(H < 0 ? 2 * -H - 1 : 2 * H);
        }, writeBoolean: function(H) {
          this.writeVarint(!!H);
        }, writeString: function(H) {
          H = String(H), this.realloc(4 * H.length), this.pos++;
          var K = this.pos;
          this.pos = function(ie, fe, de) {
            for (var ue, Se, me = 0; me < fe.length; me++) {
              if ((ue = fe.charCodeAt(me)) > 55295 && ue < 57344) {
                if (!Se) {
                  ue > 56319 || me + 1 === fe.length ? (ie[de++] = 239, ie[de++] = 191, ie[de++] = 189) : Se = ue;
                  continue;
                }
                if (ue < 56320) {
                  ie[de++] = 239, ie[de++] = 191, ie[de++] = 189, Se = ue;
                  continue;
                }
                ue = Se - 55296 << 10 | ue - 56320 | 65536, Se = null;
              } else
                Se && (ie[de++] = 239, ie[de++] = 191, ie[de++] = 189, Se = null);
              ue < 128 ? ie[de++] = ue : (ue < 2048 ? ie[de++] = ue >> 6 | 192 : (ue < 65536 ? ie[de++] = ue >> 12 | 224 : (ie[de++] = ue >> 18 | 240, ie[de++] = ue >> 12 & 63 | 128), ie[de++] = ue >> 6 & 63 | 128), ie[de++] = 63 & ue | 128);
            }
            return de;
          }(this.buf, H, this.pos);
          var Q = this.pos - K;
          Q >= 128 && v(K, Q, this), this.pos = K - 1, this.writeVarint(Q), this.pos += Q;
        }, writeFloat: function(H) {
          this.realloc(4), r.write(this.buf, H, this.pos, !0, 23, 4), this.pos += 4;
        }, writeDouble: function(H) {
          this.realloc(8), r.write(this.buf, H, this.pos, !0, 52, 8), this.pos += 8;
        }, writeBytes: function(H) {
          var K = H.length;
          this.writeVarint(K), this.realloc(K);
          for (var Q = 0; Q < K; Q++)
            this.buf[this.pos++] = H[Q];
        }, writeRawMessage: function(H, K) {
          this.pos++;
          var Q = this.pos;
          H(K, this);
          var ie = this.pos - Q;
          ie >= 128 && v(Q, ie, this), this.pos = Q - 1, this.writeVarint(ie), this.pos += ie;
        }, writeMessage: function(H, K, Q) {
          this.writeTag(H, e.Bytes), this.writeRawMessage(K, Q);
        }, writePackedVarint: function(H, K) {
          K.length && this.writeMessage(H, S, K);
        }, writePackedSVarint: function(H, K) {
          K.length && this.writeMessage(H, D, K);
        }, writePackedBoolean: function(H, K) {
          K.length && this.writeMessage(H, I, K);
        }, writePackedFloat: function(H, K) {
          K.length && this.writeMessage(H, x, K);
        }, writePackedDouble: function(H, K) {
          K.length && this.writeMessage(H, A, K);
        }, writePackedFixed32: function(H, K) {
          K.length && this.writeMessage(H, M, K);
        }, writePackedSFixed32: function(H, K) {
          K.length && this.writeMessage(H, C, K);
        }, writePackedFixed64: function(H, K) {
          K.length && this.writeMessage(H, k, K);
        }, writePackedSFixed64: function(H, K) {
          K.length && this.writeMessage(H, V, K);
        }, writeBytesField: function(H, K) {
          this.writeTag(H, e.Bytes), this.writeBytes(K);
        }, writeFixed32Field: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeFixed32(K);
        }, writeSFixed32Field: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeSFixed32(K);
        }, writeFixed64Field: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeFixed64(K);
        }, writeSFixed64Field: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeSFixed64(K);
        }, writeVarintField: function(H, K) {
          this.writeTag(H, e.Varint), this.writeVarint(K);
        }, writeSVarintField: function(H, K) {
          this.writeTag(H, e.Varint), this.writeSVarint(K);
        }, writeStringField: function(H, K) {
          this.writeTag(H, e.Bytes), this.writeString(K);
        }, writeFloatField: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeFloat(K);
        }, writeDoubleField: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeDouble(K);
        }, writeBooleanField: function(H, K) {
          this.writeVarintField(H, !!K);
        } }, k_;
      }
      var Dp = O(B0());
      const O_ = 3;
      function AT(r, e, n) {
        e.glyphs = [], r === 1 && n.readMessage(PT, e);
      }
      function PT(r, e, n) {
        if (r === 3) {
          const { id: o, bitmap: u, width: l, height: f, left: v, top: S, advance: D } = n.readMessage(CT, {});
          e.glyphs.push({ id: o, bitmap: new gc({ width: l + 2 * O_, height: f + 2 * O_ }, u), metrics: { width: l, height: f, left: v, top: S, advance: D } });
        } else
          r === 4 ? e.ascender = n.readSVarint() : r === 5 && (e.descender = n.readSVarint());
      }
      function CT(r, e, n) {
        r === 1 ? e.id = n.readVarint() : r === 2 ? e.bitmap = n.readBytes() : r === 3 ? e.width = n.readVarint() : r === 4 ? e.height = n.readVarint() : r === 5 ? e.left = n.readSVarint() : r === 6 ? e.top = n.readSVarint() : r === 7 && (e.advance = n.readVarint());
      }
      const N0 = O_, Ro = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class Xd {
        constructor() {
          this.scale = 1, this.fontStack = "", this.image = null;
        }
        static forText(e, n) {
          const o = new Xd();
          return o.scale = e || 1, o.fontStack = n, o;
        }
        static forImage(e) {
          const n = new Xd();
          return n.image = e, n;
        }
      }
      class zu {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, n) {
          const o = new zu();
          for (let u = 0; u < e.sections.length; u++) {
            const l = e.sections[u];
            l.image ? o.addImageSection(l) : o.addTextSection(l, n);
          }
          return o;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCodePoint(e) {
          return this.text.codePointAt(e);
        }
        verticalizePunctuation(e) {
          this.text = function(n, o) {
            let u = "";
            for (let l = 0; l < n.length; l++) {
              const f = n.charCodeAt(l + 1) || null, v = n.charCodeAt(l - 1) || null;
              u += !o && (f && _d(f) && !$d[n[l + 1]] || v && _d(v) && !$d[n[l - 1]]) || !$d[n[l]] ? n[l] : $d[n[l]];
            }
            return u;
          }(this.text, e);
        }
        trim() {
          let e = 0;
          for (let o = 0; o < this.text.length && kp[this.text.charCodeAt(o)]; o++)
            e++;
          let n = this.text.length;
          for (let o = this.text.length - 1; o >= 0 && o >= e && kp[this.text.charCodeAt(o)]; o--)
            n--;
          this.text = this.text.substring(e, n), this.sectionIndex = this.sectionIndex.slice(e, n);
        }
        substring(e, n) {
          const o = new zu();
          return o.text = this.text.substring(e, n), o.sectionIndex = this.sectionIndex.slice(e, n), o.sections = this.sections, o;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, n) => Math.max(e, this.sections[n].scale), 0);
        }
        addTextSection(e, n) {
          this.text += e.text, this.sections.push(Xd.forText(e.scale, e.fontStack || n));
          const o = this.sections.length - 1;
          for (let u = 0; u < e.text.length; ++u)
            this.sectionIndex.push(o);
        }
        addImageSection(e) {
          const n = e.image && e.image.namePrimary ? e.image.getPrimary() : null;
          if (!n)
            return void mi("Can't add FormattedSection with an empty image.");
          const o = this.getNextImageSectionCharCode();
          o ? (this.text += String.fromCodePoint(o), this.sections.push(Xd.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : mi("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function F_(r, e, n, o, u, l, f, v, S, D, x, A, I, M, C) {
        const k = zu.fromFeature(r, u);
        A === Ro.vertical && k.verticalizePunctuation(I);
        let V = [];
        const U = function(Q, ie, fe, de, ue, Se) {
          if (!Q)
            return [];
          const me = [], Ee = function(Ve, Ue, Fe, et, dt, tt) {
            let Mt = 0;
            for (let wt = 0; wt < Ve.length(); wt++) {
              const Pt = Ve.getSection(wt);
              Mt += V0(Ve.getCodePoint(wt), Pt, et, dt, Ue, tt);
            }
            return Mt / Math.max(1, Math.ceil(Mt / Fe));
          }(Q, ie, fe, de, ue, Se), ze = Q.text.indexOf("") >= 0;
          let Ie = 0;
          for (let Ve = 0; Ve < Q.length(); Ve++) {
            const Ue = Q.getSection(Ve), Fe = Q.getCodePoint(Ve);
            if (kp[Fe] || (Ie += V0(Fe, Ue, de, ue, ie, Se)), Ve < Q.length() - 1) {
              const et = !((Re = Fe) < 11904 || !(Zt["Bopomofo Extended"](Re) || Zt.Bopomofo(Re) || Zt["CJK Compatibility Forms"](Re) || Zt["CJK Compatibility Ideographs"](Re) || Zt["CJK Compatibility"](Re) || Zt["CJK Radicals Supplement"](Re) || Zt["CJK Strokes"](Re) || Zt["CJK Symbols and Punctuation"](Re) || Zt["CJK Unified Ideographs Extension A"](Re) || Zt["CJK Unified Ideographs"](Re) || Zt["Enclosed CJK Letters and Months"](Re) || Zt["Halfwidth and Fullwidth Forms"](Re) || Zt.Hiragana(Re) || Zt["Ideographic Description Characters"](Re) || Zt["Kangxi Radicals"](Re) || Zt["Katakana Phonetic Extensions"](Re) || Zt.Katakana(Re) || Zt["Vertical Forms"](Re) || Zt["Yi Radicals"](Re) || Zt["Yi Syllables"](Re)));
              (IT[Fe] || et || Ue.image) && me.push(j0(Ve + 1, Ie, Ee, me, LT(Fe, Q.getCodePoint(Ve + 1), et && ze), !1));
            }
          }
          var Re;
          return G0(j0(Q.length(), Ie, Ee, me, 0, !0));
        }(k, D, l, e, o, M), { processBidirectionalText: q, processStyledBidirectionalText: $ } = co;
        if (q && k.sections.length === 1) {
          const Q = q(k.toString(), U);
          for (const ie of Q) {
            const fe = new zu();
            fe.text = ie, fe.sections = k.sections;
            for (let de = 0; de < ie.length; de++)
              fe.sectionIndex.push(0);
            V.push(fe);
          }
        } else if ($) {
          const Q = $(k.text, k.sectionIndex, U);
          for (const ie of Q) {
            const fe = new zu();
            fe.text = ie[0], fe.sectionIndex = ie[1], fe.sections = k.sections, V.push(fe);
          }
        } else
          V = function(Q, ie) {
            const fe = [], de = Q.text;
            let ue = 0;
            for (const Se of ie)
              fe.push(Q.substring(ue, Se)), ue = Se;
            return ue < de.length && fe.push(Q.substring(ue, de.length)), fe;
          }(k, U);
        const H = [], K = { positionedLines: H, text: k.toString(), top: x[1], bottom: x[1], left: x[0], right: x[0], writingMode: A, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
        return function(Q, ie, fe, de, ue, Se, me, Ee, ze, Ie, Re, Ve) {
          let Ue = 0, Fe = 0, et = 0;
          const dt = Ee === "right" ? 1 : Ee === "left" ? 0 : 0.5;
          let tt = !1;
          for (const St of ue) {
            const Nt = St.getSections();
            for (const Qt of Nt) {
              if (Qt.image)
                continue;
              const pi = ie[Qt.fontStack];
              if (pi && (tt = pi.ascender !== void 0 && pi.descender !== void 0, !tt))
                break;
            }
            if (!tt)
              break;
          }
          let Mt = 0;
          for (const St of ue) {
            St.trim();
            const Nt = St.getMaxScale(), Qt = (Nt - 1) * tr, pi = { positionedGlyphs: [], lineOffset: 0 };
            Q.positionedLines[Mt] = pi;
            const gi = pi.positionedGlyphs;
            let Pi = 0;
            if (!St.length()) {
              Fe += Se, ++Mt;
              continue;
            }
            let yi = 0, Ii = 0;
            for (let rn = 0; rn < St.length(); rn++) {
              const hi = St.getSection(rn), on = St.getSectionIndex(rn), Qi = St.getCodePoint(rn);
              let pn = hi.scale, as = null, ls = null, Kn = null, Vr = tr, Sn = 0;
              const Ln = !(ze === Ro.horizontal || !Re && !su(Qi) || Re && (kp[Qi] || (wt = Qi, Zt.Arabic(wt) || Zt["Arabic Supplement"](wt) || Zt["Arabic Extended-A"](wt) || Zt["Arabic Presentation Forms-A"](wt) || Zt["Arabic Presentation Forms-B"](wt))));
              if (hi.image) {
                const Tr = de[hi.image.serialize()];
                if (!Tr)
                  continue;
                Kn = hi.image.id, Q.iconsInText = Q.iconsInText || !0, ls = Tr.paddedRect;
                const cs = Tr.displaySize;
                pn = pn * tr / Ve, as = { width: cs[0], height: cs[1], left: 0, top: -N0, advance: Ln ? cs[1] : cs[0], localGlyph: !1 }, Sn = tt ? -as.height * pn : Nt * tr - 17 - cs[1] * pn, Vr = as.advance;
                const to = (Ln ? cs[0] : cs[1]) * pn - tr * Nt;
                to > 0 && to > Pi && (Pi = to);
              } else {
                const Tr = fe[hi.fontStack];
                if (!Tr)
                  continue;
                Tr[Qi] && (ls = Tr[Qi]);
                const cs = ie[hi.fontStack];
                if (!cs)
                  continue;
                const to = cs.glyphs[Qi];
                if (!to)
                  continue;
                if (as = to.metrics, Vr = Qi !== 8203 ? tr : 0, tt) {
                  const Ms = cs.ascender !== void 0 ? Math.abs(cs.ascender) : 0, sl = cs.descender !== void 0 ? Math.abs(cs.descender) : 0, Mc = (Ms + sl) * pn;
                  yi < Mc && (yi = Mc, Ii = (Ms - sl) / 2 * pn), Sn = -Ms * pn;
                } else
                  Sn = (Nt - pn) * tr - 17;
              }
              Ln ? (Q.verticalizable = !0, gi.push({ glyph: Qi, imageName: Kn, x: Ue, y: Fe + Sn, vertical: Ln, scale: pn, localGlyph: as.localGlyph, fontStack: hi.fontStack, sectionIndex: on, metrics: as, rect: ls }), Ue += Vr * pn + Ie) : (gi.push({ glyph: Qi, imageName: Kn, x: Ue, y: Fe + Sn, vertical: Ln, scale: pn, localGlyph: as.localGlyph, fontStack: hi.fontStack, sectionIndex: on, metrics: as, rect: ls }), Ue += as.advance * pn + Ie);
            }
            gi.length !== 0 && (et = Math.max(Ue - Ie, et), tt ? Z0(gi, dt, Pi, Ii, Se * Nt / 2) : Z0(gi, dt, Pi, 0, Se / 2)), Ue = 0;
            const fn = Se * Nt + Pi;
            pi.lineOffset = Math.max(Pi, Qt), Fe += fn, ++Mt;
          }
          var wt;
          const Pt = Fe, { horizontalAlign: rt, verticalAlign: Ut } = B_(me);
          (function(St, Nt, Qt, pi, gi, Pi) {
            const yi = (Nt - Qt) * gi, Ii = -Pi * pi;
            for (const fn of St)
              for (const rn of fn.positionedGlyphs)
                rn.x += yi, rn.y += Ii;
          })(Q.positionedLines, dt, rt, Ut, et, Pt), Q.top += -Ut * Pt, Q.bottom = Q.top + Pt, Q.left += -rt * et, Q.right = Q.left + et, Q.hasBaseline = tt;
        }(K, e, n, o, V, f, v, S, A, D, I, C), !function(Q) {
          for (const ie of Q)
            if (ie.positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(H) && K;
      }
      const kp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, IT = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
      function V0(r, e, n, o, u, l) {
        if (e.image) {
          const f = o[e.image.serialize()];
          return f ? f.displaySize[0] * e.scale * tr / l + u : 0;
        }
        {
          const f = n[e.fontStack], v = f && f.glyphs[r];
          return v ? v.metrics.advance * e.scale + u : 0;
        }
      }
      function U0(r, e, n, o) {
        const u = Math.pow(r - e, 2);
        return o ? r < e ? u / 2 : 2 * u : u + Math.abs(n) * n;
      }
      function LT(r, e, n) {
        let o = 0;
        return r === 10 && (o -= 1e4), n && (o += 150), r !== 40 && r !== 65288 || (o += 50), e !== 41 && e !== 65289 || (o += 50), o;
      }
      function j0(r, e, n, o, u, l) {
        let f = null, v = U0(e, n, u, l);
        for (const S of o) {
          const D = U0(e - S.x, n, u, l) + S.badness;
          D <= v && (f = S, v = D);
        }
        return { index: r, x: e, priorBreak: f, badness: v };
      }
      function G0(r) {
        return r ? G0(r.priorBreak).concat(r.index) : [];
      }
      function B_(r) {
        let e = 0.5, n = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: e, verticalAlign: n };
      }
      function Z0(r, e, n, o, u) {
        if (!(e || n || o || u))
          return;
        const l = r.length - 1, f = r[l], v = (f.x + f.metrics.advance * f.scale) * e;
        for (let S = 0; S <= l; S++)
          r[S].x -= v, r[S].y += n + o + u;
      }
      function zT(r, e, n, o) {
        const { horizontalAlign: u, verticalAlign: l } = B_(o), f = n[0] - r.displaySize[0] * u, v = n[1] - r.displaySize[1] * l;
        return { imagePrimary: r, imageSecondary: e, top: v, bottom: v + r.displaySize[1], left: f, right: f + r.displaySize[0] };
      }
      function H0(r, e, n, o, u, l) {
        const f = r.imagePrimary;
        let v;
        if (f.content) {
          const V = f.content, U = f.pixelRatio || 1;
          v = [V[0] / U, V[1] / U, f.displaySize[0] - V[2] / U, f.displaySize[1] - V[3] / U];
        }
        const S = e.left * l, D = e.right * l;
        let x, A, I, M;
        n === "width" || n === "both" ? (M = u[0] + S - o[3], A = u[0] + D + o[1]) : (M = u[0] + (S + D - f.displaySize[0]) / 2, A = M + f.displaySize[0]);
        const C = e.top * l, k = e.bottom * l;
        return n === "height" || n === "both" ? (x = u[1] + C - o[0], I = u[1] + k + o[2]) : (x = u[1] + (C + k - f.displaySize[1]) / 2, I = x + f.displaySize[1]), { imagePrimary: f, imageSecondary: void 0, top: x, right: A, bottom: I, left: M, collisionPadding: v };
      }
      class zl extends Et {
        constructor(e, n, o, u, l) {
          super(e, n), this.angle = u, this.z = o, l !== void 0 && (this.segment = l);
        }
        clone() {
          return new zl(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function q0(r, e, n, o, u) {
        if (e.segment === void 0)
          return !0;
        let l = e, f = e.segment + 1, v = 0;
        for (; v > -n / 2; ) {
          if (f--, f < 0)
            return !1;
          v -= r[f].dist(l), l = r[f];
        }
        v += r[f].dist(r[f + 1]), f++;
        const S = [];
        let D = 0;
        for (; v < n / 2; ) {
          const x = r[f], A = r[f + 1];
          if (!A)
            return !1;
          let I = r[f - 1].angleTo(x) - x.angleTo(A);
          for (I = Math.abs((I + 3 * Math.PI) % (2 * Math.PI) - Math.PI), S.push({ distance: v, angleDelta: I }), D += I; v - S[0].distance > o; )
            D -= S.shift().angleDelta;
          if (D > u)
            return !1;
          f++, v += x.dist(A);
        }
        return !0;
      }
      function W0(r) {
        let e = 0;
        for (let n = 0; n < r.length - 1; n++)
          e += r[n].dist(r[n + 1]);
        return e;
      }
      function $0(r, e, n) {
        return r ? 0.6 * e * n : 0;
      }
      function X0(r, e) {
        return Math.max(r ? r.right - r.left : 0, e ? e.right - e.left : 0);
      }
      function DT(r, e, n, o, u, l) {
        const f = $0(n, u, l), v = X0(n, o) * l;
        let S = 0;
        const D = W0(r) / 2;
        for (let x = 0; x < r.length - 1; x++) {
          const A = r[x], I = r[x + 1], M = A.dist(I);
          if (S + M > D) {
            const C = (D - S) / M, k = ei(A.x, I.x, C), V = ei(A.y, I.y, C), U = new zl(k, V, 0, I.angleTo(A), x);
            return !f || q0(r, U, v, f, e) ? U : void 0;
          }
          S += M;
        }
      }
      function kT(r, e, n, o, u, l, f, v, S) {
        const D = $0(o, l, f), x = X0(o, u), A = x * f, I = r[0].x === 0 || r[0].x === S || r[0].y === 0 || r[0].y === S;
        return e - A < e / 4 && (e = A + e / 4), Y0(r, I ? e / 2 * v % e : (x / 2 + 2 * l) * f * v % e, e, D, n, A, I, !1, S);
      }
      function Y0(r, e, n, o, u, l, f, v, S) {
        const D = l / 2, x = W0(r);
        let A = 0, I = e - n, M = [];
        for (let C = 0; C < r.length - 1; C++) {
          const k = r[C], V = r[C + 1], U = k.dist(V), q = V.angleTo(k);
          for (; I + n < A + U; ) {
            I += n;
            const $ = (I - A) / U, H = ei(k.x, V.x, $), K = ei(k.y, V.y, $);
            if (H >= 0 && H < S && K >= 0 && K < S && I - D >= 0 && I + D <= x) {
              const Q = new zl(H, K, 0, q, C);
              o && !q0(r, Q, l, o, u) || M.push(Q);
            }
          }
          A += U;
        }
        return v || M.length || f || (M = Y0(r, A / 2, n, o, u, l, f, !0, S)), M;
      }
      function K0(r, e, n, o, u) {
        const l = [];
        for (let f = 0; f < r.length; f++) {
          const v = r[f];
          let S;
          for (let D = 0; D < v.length - 1; D++) {
            let x = v[D], A = v[D + 1];
            x.x < e && A.x < e || (x.x < e ? x = new Et(e, x.y + (e - x.x) / (A.x - x.x) * (A.y - x.y))._round() : A.x < e && (A = new Et(e, x.y + (e - x.x) / (A.x - x.x) * (A.y - x.y))._round()), x.y < n && A.y < n || (x.y < n ? x = new Et(x.x + (n - x.y) / (A.y - x.y) * (A.x - x.x), n)._round() : A.y < n && (A = new Et(x.x + (n - x.y) / (A.y - x.y) * (A.x - x.x), n)._round()), x.x >= o && A.x >= o || (x.x >= o ? x = new Et(o, x.y + (o - x.x) / (A.x - x.x) * (A.y - x.y))._round() : A.x >= o && (A = new Et(o, x.y + (o - x.x) / (A.x - x.x) * (A.y - x.y))._round()), x.y >= u && A.y >= u || (x.y >= u ? x = new Et(x.x + (u - x.y) / (A.y - x.y) * (A.x - x.x), u)._round() : A.y >= u && (A = new Et(x.x + (u - x.y) / (A.y - x.y) * (A.x - x.x), u)._round()), S && x.equals(S[S.length - 1]) || (S = [x], l.push(S)), S.push(A)))));
          }
        }
        return l;
      }
      function J0(r) {
        let e = 0, n = 0;
        for (const f of r)
          e += f.w * f.h, n = Math.max(n, f.w);
        r.sort((f, v) => v.h - f.h);
        const o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), n), h: 1 / 0 }];
        let u = 0, l = 0;
        for (const f of r)
          for (let v = o.length - 1; v >= 0; v--) {
            const S = o[v];
            if (!(f.w > S.w || f.h > S.h)) {
              if (f.x = S.x, f.y = S.y, l = Math.max(l, f.y + f.h), u = Math.max(u, f.x + f.w), f.w === S.w && f.h === S.h) {
                const D = o.pop();
                v < o.length && (o[v] = D);
              } else
                f.h === S.h ? (S.x += f.w, S.w -= f.w) : f.w === S.w ? (S.y += f.h, S.h -= f.h) : (o.push({ x: S.x + f.w, y: S.y, w: S.w - f.w, h: f.h }), S.y += f.h, S.h -= f.h);
              break;
            }
          }
        return { w: u, h: l, fill: e / (u * l) || 0 };
      }
      Ft(zl, "Anchor");
      const Yd = 1;
      class N_ {
        constructor(e, { pixelRatio: n, version: o, stretchX: u, stretchY: l, content: f }, v) {
          this.paddedRect = e, this.pixelRatio = n, this.stretchX = u, this.stretchY = l, this.content = f, this.version = o, this.padding = v;
        }
        get tl() {
          return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio];
        }
      }
      class Q0 {
        constructor(e, n, o) {
          const u = {}, l = {};
          this.haveRenderCallbacks = [];
          const f = [];
          this.addImages(e, u, Yd, f), this.addImages(n, l, 2, f);
          const { w: v, h: S } = J0(f), D = new _r({ width: v || 1, height: S || 1 });
          for (const x in e) {
            const A = e[x], I = u[x].paddedRect;
            _r.copy(A.data, D, { x: 0, y: 0 }, { x: I.x + Yd, y: I.y + Yd }, A.data, o, A.sdf);
          }
          for (const x in n) {
            const A = n[x], I = l[x].paddedRect;
            let M = l[x].padding;
            const C = I.x + M, k = I.y + M, V = A.data.width, U = A.data.height;
            M = M > 1 ? M - 1 : M, _r.copy(A.data, D, { x: 0, y: 0 }, { x: C, y: k }, A.data, o), _r.copy(A.data, D, { x: 0, y: U - M }, { x: C, y: k - M }, { width: V, height: M }, o), _r.copy(A.data, D, { x: 0, y: 0 }, { x: C, y: k + U }, { width: V, height: M }, o), _r.copy(A.data, D, { x: V - M, y: 0 }, { x: C - M, y: k }, { width: M, height: U }, o), _r.copy(A.data, D, { x: 0, y: 0 }, { x: C + V, y: k }, { width: M, height: U }, o), _r.copy(A.data, D, { x: V - M, y: U - M }, { x: C - M, y: k - M }, { width: M, height: M }, o), _r.copy(A.data, D, { x: 0, y: U - M }, { x: C + V, y: k - M }, { width: M, height: M }, o), _r.copy(A.data, D, { x: 0, y: 0 }, { x: C + V, y: k + U }, { width: M, height: M }, o), _r.copy(A.data, D, { x: V - M, y: 0 }, { x: C - M, y: k + U }, { width: M, height: M }, o);
          }
          this.image = D, this.iconPositions = u, this.patternPositions = l;
        }
        addImages(e, n, o, u) {
          for (const l in e) {
            const f = e[l], v = { x: 0, y: 0, w: f.data.width + 2 * o, h: f.data.height + 2 * o };
            u.push(v), n[l] = new N_(v, f, o), f.hasRenderCallback && this.haveRenderCallbacks.push(rr.deserializeId(l));
          }
        }
        patchUpdatedImages(e, n, o) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((u) => e.hasImage(u, o)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, o);
          for (const u in e.getUpdatedImages(o)) {
            for (const l of Object.keys(this.iconPositions))
              rr.deserializeId(l) === u && this.patchUpdatedImage(this.iconPositions[l], e.getImage(u, o), n);
            for (const l of Object.keys(this.patternPositions))
              rr.deserializeId(l) === u && this.patchUpdatedImage(this.patternPositions[l], e.getImage(u, o), n);
          }
        }
        patchUpdatedImage(e, n, o) {
          if (!e || !n || e.version === n.version)
            return;
          e.version = n.version;
          const [u, l] = e.tl;
          o.update(n.data, { position: { x: u, y: l } });
        }
      }
      Ft(N_, "ImagePosition"), Ft(Q0, "ImageAtlas");
      const Kd = 1e20;
      function ex(r, e, n, o, u, l, f, v, S) {
        for (let D = e; D < e + o; D++)
          tx(r, n * l + D, l, u, f, v, S);
        for (let D = n; D < n + u; D++)
          tx(r, D * l + e, 1, o, f, v, S);
      }
      function tx(r, e, n, o, u, l, f) {
        l[0] = 0, f[0] = -Kd, f[1] = Kd, u[0] = r[e];
        for (let v = 1, S = 0, D = 0; v < o; v++) {
          u[v] = r[e + v * n];
          const x = v * v;
          do {
            const A = l[S];
            D = (u[v] - u[A] + x - A * A) / (v - A) / 2;
          } while (D <= f[S] && --S > -1);
          S++, l[S] = v, f[S] = D, f[S + 1] = Kd;
        }
        for (let v = 0, S = 0; v < o; v++) {
          for (; f[S + 1] < v; )
            S++;
          const D = l[S], x = v - D;
          r[e + v * n] = u[D] + x * x;
        }
      }
      const Ea = 2, V_ = { none: 0, ideographs: 1, all: 2 };
      class Du {
        constructor(e, n, o) {
          this.requestManager = e, this.localGlyphMode = n, this.localFontFamily = o, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(e, n) {
          this.urls[n] = e;
        }
        getGlyphs(e, n, o) {
          const u = [], l = this.urls[n] || ge.GLYPHS_URL;
          for (const f in e)
            for (const v of e[f])
              u.push({ stack: f, id: v });
          Rn(u, ({ stack: f, id: v }, S) => {
            let D = this.entries[f];
            D || (D = this.entries[f] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let x = D.glyphs[v];
            if (x !== void 0)
              return void S(null, { stack: f, id: v, glyph: x });
            if (x = this._tinySDF(D, f, v), x)
              return D.glyphs[v] = x, void S(null, { stack: f, id: v, glyph: x });
            const A = Math.floor(v / 256);
            if (256 * A > 65535)
              return mi("glyphs > 65535 not supported"), void S(null, { stack: f, id: v, glyph: x });
            if (D.ranges[A])
              return void S(null, { stack: f, id: v, glyph: x });
            let I = D.requests[A];
            I || (I = D.requests[A] = [], Du.loadGlyphRange(f, A, l, this.requestManager, (M, C) => {
              if (C) {
                D.ascender = C.ascender, D.descender = C.descender;
                for (const k in C.glyphs)
                  this._doesCharSupportLocalGlyph(+k) || (D.glyphs[+k] = C.glyphs[+k]);
                D.ranges[A] = !0;
              }
              for (const k of I)
                k(M, C);
              delete D.requests[A];
            })), I.push((M, C) => {
              M ? S(M) : C && S(null, { stack: f, id: v, glyph: C.glyphs[v] || null });
            });
          }, (f, v) => {
            if (f)
              o(f);
            else if (v) {
              const S = {};
              for (const { stack: D, id: x, glyph: A } of v)
                S[D] === void 0 && (S[D] = {}), S[D].glyphs === void 0 && (S[D].glyphs = {}), S[D].glyphs[x] = A && { id: A.id, bitmap: A.bitmap.clone(), metrics: A.metrics }, S[D].ascender = this.entries[D].ascender, S[D].descender = this.entries[D].descender;
              o(null, S);
            }
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return this.localGlyphMode !== V_.none && (this.localGlyphMode === V_.all ? !!this.localFontFamily : !!this.localFontFamily && (Zt["CJK Unified Ideographs"](e) || Zt["Hangul Syllables"](e) || Zt.Hiragana(e) || Zt.Katakana(e) || Zt["CJK Symbols and Punctuation"](e) || Zt["CJK Unified Ideographs Extension A"](e) || Zt["CJK Unified Ideographs Extension B"](e) || Zt.Osage(e)));
        }
        _tinySDF(e, n, o) {
          const u = this.localFontFamily;
          if (!u || !this._doesCharSupportLocalGlyph(o))
            return;
          let l = e.tinySDF;
          if (!l) {
            let k = "400";
            /bold/i.test(n) ? k = "900" : /medium/i.test(n) ? k = "500" : /light/i.test(n) && (k = "200"), l = e.tinySDF = new Du.TinySDF({ fontFamily: u, fontWeight: k, fontSize: 24 * Ea, buffer: 3 * Ea, radius: 8 * Ea }), l.fontWeight = k;
          }
          if (this.localGlyphs[l.fontWeight][o])
            return this.localGlyphs[l.fontWeight][o];
          const f = String.fromCodePoint(o), { data: v, width: S, height: D, glyphWidth: x, glyphHeight: A, glyphLeft: I, glyphTop: M, glyphAdvance: C } = l.draw(f);
          return this.localGlyphs[l.fontWeight][o] = { id: o, bitmap: new gc({ width: S, height: D }, v), metrics: { width: x / Ea, height: A / Ea, left: I / Ea, top: M / Ea - 27, advance: C / Ea, localGlyph: !0 } };
        }
      }
      Du.loadGlyphRange = function(r, e, n, o, u) {
        const l = 256 * e, f = l + 255, v = o.transformRequest(o.normalizeGlyphsURL(n).replace("{fontstack}", r).replace("{range}", `${l}-${f}`), Uo.Glyphs);
        no(v, (S, D) => {
          if (S)
            u(S);
          else if (D) {
            const x = {}, A = function(I) {
              return new Dp(I).readFields(AT, {});
            }(D);
            for (const I of A.glyphs)
              x[I.id] = I;
            u(null, { glyphs: x, ascender: A.ascender, descender: A.descender });
          }
        });
      }, Du.TinySDF = class {
        constructor({ fontSize: r = 24, buffer: e = 3, radius: n = 8, cutoff: o = 0.25, fontFamily: u = "sans-serif", fontWeight: l = "normal", fontStyle: f = "normal" } = {}) {
          this.buffer = e, this.cutoff = o, this.radius = n;
          const v = this.size = r + 4 * e, S = this._createCanvas(v), D = this.ctx = S.getContext("2d", { willReadFrequently: !0 });
          D.font = `${f} ${l} ${r}px ${u}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(v * v), this.gridInner = new Float64Array(v * v), this.f = new Float64Array(v), this.z = new Float64Array(v + 1), this.v = new Uint16Array(v);
        }
        _createCanvas(r) {
          const e = document.createElement("canvas");
          return e.width = e.height = r, e;
        }
        draw(r) {
          const { width: e, actualBoundingBoxAscent: n, actualBoundingBoxDescent: o, actualBoundingBoxLeft: u, actualBoundingBoxRight: l } = this.ctx.measureText(r), f = Math.ceil(n), v = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(l - u))), S = Math.min(this.size - this.buffer, f + Math.ceil(o)), D = v + 2 * this.buffer, x = S + 2 * this.buffer, A = Math.max(D * x, 0), I = new Uint8ClampedArray(A), M = { data: I, width: D, height: x, glyphWidth: v, glyphHeight: S, glyphTop: f, glyphLeft: 0, glyphAdvance: e };
          if (v === 0 || S === 0)
            return M;
          const { ctx: C, buffer: k, gridInner: V, gridOuter: U } = this;
          C.clearRect(k, k, v, S), C.fillText(r, k, k + f);
          const q = C.getImageData(k, k, v, S);
          U.fill(Kd, 0, A), V.fill(0, 0, A);
          for (let $ = 0; $ < S; $++)
            for (let H = 0; H < v; H++) {
              const K = q.data[4 * ($ * v + H) + 3] / 255;
              if (K === 0)
                continue;
              const Q = ($ + k) * D + H + k;
              if (K === 1)
                U[Q] = 0, V[Q] = Kd;
              else {
                const ie = 0.5 - K;
                U[Q] = ie > 0 ? ie * ie : 0, V[Q] = ie < 0 ? ie * ie : 0;
              }
            }
          ex(U, 0, 0, D, x, D, this.f, this.v, this.z), ex(V, k, k, v, S, D, this.f, this.v, this.z);
          for (let $ = 0; $ < A; $++) {
            const H = Math.sqrt(U[$]) - Math.sqrt(V[$]);
            I[$] = Math.round(255 - 255 * (H / this.radius + this.cutoff));
          }
          return M;
        }
      };
      const xc = Yd;
      function ix(r, e) {
        return r + e[1] - e[0];
      }
      function nx(r, e, n, o, u = 1) {
        const l = [], f = r.imagePrimary, v = f.pixelRatio, S = f.paddedRect.w - 2 * xc, D = f.paddedRect.h - 2 * xc, x = (r.right - r.left) * u, A = (r.bottom - r.top) * u, I = f.stretchX || [[0, S]], M = f.stretchY || [[0, D]], C = I.reduce(ix, 0), k = M.reduce(ix, 0), V = S - C, U = D - k;
        let q = 0, $ = C, H = 0, K = k, Q = 0, ie = V, fe = 0, de = U;
        if (f.content && o) {
          const Se = f.content;
          q = Rp(I, 0, Se[0]), H = Rp(M, 0, Se[1]), $ = Rp(I, Se[0], Se[2]), K = Rp(M, Se[1], Se[3]), Q = Se[0] - q, fe = Se[1] - H, ie = Se[2] - Se[0] - $, de = Se[3] - Se[1] - K;
        }
        const ue = (Se, me, Ee, ze) => {
          const Ie = Op(Se.stretch - q, $, x, r.left * u), Re = Fp(Se.fixed - Q, ie, Se.stretch, C), Ve = Op(me.stretch - H, K, A, r.top * u), Ue = Fp(me.fixed - fe, de, me.stretch, k), Fe = Op(Ee.stretch - q, $, x, r.left * u), et = Fp(Ee.fixed - Q, ie, Ee.stretch, C), dt = Op(ze.stretch - H, K, A, r.top * u), tt = Fp(ze.fixed - fe, de, ze.stretch, k), Mt = new Et(Ie, Ve), wt = new Et(Fe, Ve), Pt = new Et(Fe, dt), rt = new Et(Ie, dt), Ut = new Et(Re / v, Ue / v), St = new Et(et / v, tt / v), Nt = e * Math.PI / 180;
          if (Nt) {
            const Ii = Math.sin(Nt), fn = Math.cos(Nt), rn = [fn, -Ii, Ii, fn];
            Mt._matMult(rn), wt._matMult(rn), rt._matMult(rn), Pt._matMult(rn);
          }
          const Qt = Se.stretch + Se.fixed, pi = Ee.stretch + Ee.fixed, gi = me.stretch + me.fixed, Pi = ze.stretch + ze.fixed, yi = r.imageSecondary;
          return { tl: Mt, tr: wt, bl: rt, br: Pt, texPrimary: { x: f.paddedRect.x + xc + Qt, y: f.paddedRect.y + xc + gi, w: pi - Qt, h: Pi - gi }, texSecondary: yi ? { x: yi.paddedRect.x + xc + Qt, y: yi.paddedRect.y + xc + gi, w: pi - Qt, h: Pi - gi } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Ut, pixelOffsetBR: St, minFontScaleX: ie / v / x, minFontScaleY: de / v / A, isSDF: n };
        };
        if (o && (f.stretchX || f.stretchY)) {
          const Se = sx(I, V, C), me = sx(M, U, k);
          for (let Ee = 0; Ee < Se.length - 1; Ee++) {
            const ze = Se[Ee], Ie = Se[Ee + 1];
            for (let Re = 0; Re < me.length - 1; Re++)
              l.push(ue(ze, me[Re], Ie, me[Re + 1]));
          }
        } else
          l.push(ue({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: S + 1 }, { fixed: 0, stretch: D + 1 }));
        return l;
      }
      function Rp(r, e, n) {
        let o = 0;
        for (const u of r)
          o += Math.max(e, Math.min(n, u[1])) - Math.max(e, Math.min(n, u[0]));
        return o;
      }
      function sx(r, e, n) {
        const o = [{ fixed: -xc, stretch: 0 }];
        for (const [u, l] of r) {
          const f = o[o.length - 1];
          o.push({ fixed: u - f.stretch, stretch: f.stretch }), o.push({ fixed: u - f.stretch, stretch: f.stretch + (l - u) });
        }
        return o.push({ fixed: e + xc, stretch: n }), o;
      }
      function Op(r, e, n, o) {
        return r / e * n + o;
      }
      function Fp(r, e, n, o) {
        return r - e * n / o;
      }
      function RT(r, e, n, o) {
        const u = e + r.positionedLines[o].lineOffset;
        return o === 0 ? n + u / 2 : n + (u + (e + r.positionedLines[o - 1].lineOffset)) / 2;
      }
      function OT(r, e = 1, n = !1) {
        let o = 1 / 0, u = 1 / 0, l = -1 / 0, f = -1 / 0;
        const v = r[0];
        for (let M = 0; M < v.length; M++) {
          const C = v[M];
          (!M || C.x < o) && (o = C.x), (!M || C.y < u) && (u = C.y), (!M || C.x > l) && (l = C.x), (!M || C.y > f) && (f = C.y);
        }
        const S = Math.min(l - o, f - u);
        let D = S / 2;
        const x = new Wl([], FT);
        if (S === 0)
          return new Et(o, u);
        for (let M = o; M < l; M += S)
          for (let C = u; C < f; C += S)
            x.push(new ku(M + D, C + D, D, r));
        let A = function(M) {
          let C = 0, k = 0, V = 0;
          const U = M[0];
          for (let q = 0, $ = U.length, H = $ - 1; q < $; H = q++) {
            const K = U[q], Q = U[H], ie = K.x * Q.y - Q.x * K.y;
            k += (K.x + Q.x) * ie, V += (K.y + Q.y) * ie, C += 3 * ie;
          }
          return new ku(k / C, V / C, 0, M);
        }(r), I = x.length;
        for (; x.length; ) {
          const M = x.pop();
          (M.d > A.d || !A.d) && (A = M, n && console.log("found best %d after %d probes", Math.round(1e4 * M.d) / 1e4, I)), M.max - A.d <= e || (D = M.h / 2, x.push(new ku(M.p.x - D, M.p.y - D, D, r)), x.push(new ku(M.p.x + D, M.p.y - D, D, r)), x.push(new ku(M.p.x - D, M.p.y + D, D, r)), x.push(new ku(M.p.x + D, M.p.y + D, D, r)), I += 4);
        }
        return n && (console.log(`num probes: ${I}`), console.log(`best distance: ${A.d}`)), A.p;
      }
      function FT(r, e) {
        return e.max - r.max;
      }
      class ku {
        constructor(e, n, o, u) {
          this.p = new Et(e, n), this.h = o, this.d = function(l, f) {
            let v = !1, S = 1 / 0;
            for (let D = 0; D < f.length; D++) {
              const x = f[D];
              for (let A = 0, I = x.length, M = I - 1; A < I; M = A++) {
                const C = x[A], k = x[M];
                C.y > l.y != k.y > l.y && l.x < (k.x - C.x) * (l.y - C.y) / (k.y - C.y) + C.x && (v = !v), S = Math.min(S, we(l, C, k));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(S);
          }(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const U_ = Number.POSITIVE_INFINITY, BT = Math.sqrt(2);
      function rx(r, [e, n]) {
        let o = 0, u = 0;
        if (n === U_) {
          e < 0 && (e = 0);
          const l = e / BT;
          switch (r) {
            case "top-right":
            case "top-left":
              u = l - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              u = 7 - l;
              break;
            case "bottom":
              u = 7 - e;
              break;
            case "top":
              u = e - 7;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
              o = -l;
              break;
            case "top-left":
            case "bottom-left":
              o = l;
              break;
            case "left":
              o = e;
              break;
            case "right":
              o = -e;
          }
        } else {
          switch (e = Math.abs(e), n = Math.abs(n), r) {
            case "top-right":
            case "top-left":
            case "top":
              u = n - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              u = 7 - n;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
            case "right":
              o = -e;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              o = e;
          }
        }
        return [o, u];
      }
      function j_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function NT(r, e, n, o, u, l, f, v, S, D, x, A, I, M, C, k) {
        let V = l.textMaxSize.evaluate(e, {}, I);
        V === void 0 ? V = f * l.textScaleFactor : V *= l.textScaleFactor;
        const U = r.layers[0].layout, q = U.get("icon-offset").evaluate(e, {}, I), $ = ax(n.horizontal) || n.vertical, H = M.name === "globe", K = tr, Q = f * l.textScaleFactor / K, ie = r.tilePixelRatio * V / K, fe = (Re = r.overscaling, r.zoom > 18 && Re > 2 && (Re >>= 1), Math.max(Tt / (512 * Re), 1) * U.get("symbol-spacing")), de = U.get("text-padding") * r.tilePixelRatio, ue = U.get("icon-padding") * r.tilePixelRatio, Se = vi(U.get("text-max-angle")), me = U.get("text-rotation-alignment") === "map" && U.get("symbol-placement") !== "point", Ee = U.get("icon-rotation-alignment") === "map" && U.get("symbol-placement") !== "point", ze = U.get("symbol-placement"), Ie = fe / 2;
        var Re;
        const Ve = U.get("icon-text-fit").evaluate(e, {}, I), Ue = U.get("icon-text-fit-padding").evaluate(e, {}, I), Fe = Ve !== "none";
        let et;
        r.hasAnyIconTextFit === !1 && Fe && (r.hasAnyIconTextFit = !0), o && Fe && (r.allowVerticalPlacement && n.vertical && (et = H0(o, n.vertical, Ve, Ue, q, Q)), $ && (o = H0(o, $, Ve, Ue, q, Q)));
        const dt = (tt, Mt, wt) => {
          if (Mt.x < 0 || Mt.x >= Tt || Mt.y < 0 || Mt.y >= Tt)
            return;
          let Pt = null;
          if (H) {
            const { x: rt, y: Ut, z: St } = M.projectTilePoint(Mt.x, Mt.y, wt);
            Pt = { anchor: new zl(rt, Ut, St, 0, void 0), up: M.upVector(wt, Mt.x, Mt.y) };
          }
          (function(rt, Ut, St, Nt, Qt, pi, gi, Pi, yi, Ii, fn, rn, hi, on, Qi, pn, as, ls, Kn, Vr, Sn, Ln, Tr, cs, to, Ms, sl, Mc) {
            const Sc = rt.addToLineVertexArray(Ut, Nt);
            let Dl, Ec, Ac, hm, Nv, Vv, Uv, jv = 0, Gv = 0, Zv = 0, Hv = 0, Tg = -1, Mg = -1;
            const rl = {};
            let qv = $r("");
            const Sh = St ? St.anchor : Ut, Sg = yi.layout.get("icon-text-fit").evaluate(Sn, {}, Ms) !== "none";
            let Eg = 0, Ag = 0;
            if (yi._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [Eg, Ag] = yi.layout.get("text-offset").evaluate(Sn, {}, Ms).map((Fo) => Fo * tr) : (Eg = yi.layout.get("text-radial-offset").evaluate(Sn, {}, Ms) * tr, Ag = U_), rt.allowVerticalPlacement && Qt.vertical) {
              const Fo = Qt.vertical;
              if (Qi)
                Vv = G_(Fo), Pi && (Uv = G_(Pi));
              else {
                const po = yi.layout.get("text-rotate").evaluate(Sn, {}, Ms) + 90;
                Ac = Bp(Ii, Sh, Ut, fn, rn, hi, Fo, on, po, pn), Pi && (hm = Bp(Ii, Sh, Ut, fn, rn, hi, Pi, ls, po));
              }
            }
            if (pi) {
              const Fo = rt.iconSizeData, po = cs ? Lp(rt.iconSizeData, rt.layers[0]._unevaluatedLayout._values["icon-size"], Ms, rt.zoom, Sn) : 1, Hu = yi.layout.get("icon-rotate").evaluate(Sn, {}, Ms), Wv = nx(pi, Hu, Tr, Sg, cs ? 1 / po : Ln.iconScaleFactor), Cg = Pi ? nx(Pi, Hu, Tr, Sg, Ln.iconScaleFactor) : void 0;
              Ec = Bp(Ii, Sh, Ut, fn, rn, hi, pi, ls, Hu, null, cs ? Ln.iconScaleFactor * po : 1), jv = 4 * Wv.length;
              let Eh = null;
              Fo.kind === "source" ? (Eh = [Sa * yi.layout.get("icon-size").evaluate(Sn, {}, Ms) * Ln.iconScaleFactor], Eh[0] > vc && mi(`${rt.layerIds[0]}: Value for "icon-size" is >= ${Jd}. Reduce your "icon-size".`)) : Fo.kind === "composite" && (Eh = [Sa * Ln.compositeIconSizes[0].evaluate(Sn, {}, Ms) * Ln.iconScaleFactor, Sa * Ln.compositeIconSizes[1].evaluate(Sn, {}, Ms) * Ln.iconScaleFactor], (Eh[0] > vc || Eh[1] > vc) && mi(`${rt.layerIds[0]}: Value for "icon-size" is >= ${Jd}. Reduce your "icon-size".`)), rt.addSymbols(rt.icon, Wv, Eh, Vr, Kn, Sn, !1, St, Ut, Sc.lineStartIndex, Sc.lineLength, -1, to, Ms, sl, Mc), Tg = rt.icon.placedSymbolArray.length - 1, Cg && (Gv = 4 * Cg.length, rt.addSymbols(rt.icon, Cg, Eh, Vr, Kn, Sn, Ro.vertical, St, Ut, Sc.lineStartIndex, Sc.lineLength, -1, to, Ms, sl, Mc), Mg = rt.icon.placedSymbolArray.length - 1);
            }
            for (const Fo in Qt.horizontal) {
              const po = Qt.horizontal[Fo];
              Dl || (qv = $r(po.text), Qi ? Nv = G_(po) : Dl = Bp(Ii, Sh, Ut, fn, rn, hi, po, on, yi.layout.get("text-rotate").evaluate(Sn, {}, Ms), pn));
              const Hu = po.positionedLines.length === 1;
              if (Zv += ox(rt, St, Ut, po, gi, yi, Qi, Sn, pn, Sc, Qt.vertical ? Ro.horizontal : Ro.horizontalOnly, Hu ? Object.keys(Qt.horizontal) : [Fo], rl, Tg, Ln, to, Ms, sl), Hu)
                break;
            }
            Qt.vertical && (Hv += ox(rt, St, Ut, Qt.vertical, gi, yi, Qi, Sn, pn, Sc, Ro.vertical, ["vertical"], rl, Mg, Ln, to, Ms, sl));
            let Pc = -1;
            const Pg = (Fo, po) => Fo ? Math.max(Fo, po) : po;
            Pc = Pg(Nv, Pc), Pc = Pg(Vv, Pc), Pc = Pg(Uv, Pc);
            const yM = Pc > -1 ? 1 : 0;
            rt.glyphOffsetArray.length >= 65535 && mi("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Sn.sortKey !== void 0 && rt.addToSortKeyRanges(rt.symbolInstances.length, Sn.sortKey), rt.symbolInstances.emplaceBack(Ut.x, Ut.y, Sh.x, Sh.y, Sh.z, rl.right >= 0 ? rl.right : -1, rl.center >= 0 ? rl.center : -1, rl.left >= 0 ? rl.left : -1, rl.vertical >= 0 ? rl.vertical : -1, Tg, Mg, qv, Dl !== void 0 ? Dl : rt.collisionBoxArray.length, Dl !== void 0 ? Dl + 1 : rt.collisionBoxArray.length, Ac !== void 0 ? Ac : rt.collisionBoxArray.length, Ac !== void 0 ? Ac + 1 : rt.collisionBoxArray.length, Ec !== void 0 ? Ec : rt.collisionBoxArray.length, Ec !== void 0 ? Ec + 1 : rt.collisionBoxArray.length, hm || rt.collisionBoxArray.length, hm ? hm + 1 : rt.collisionBoxArray.length, fn, Zv, Hv, jv, Gv, yM, 0, Eg, Ag, Pc, 0, Sg ? 1 : 0);
          })(r, Mt, Pt, tt, n, o, u, et, r.layers[0], r.collisionBoxArray, e.index, e.sourceLayerIndex, r.index, de, me, S, 0, ue, Ee, q, e, l, D, x, A, I, C, k);
        };
        if (ze === "line")
          for (const tt of K0(e.geometry, 0, 0, Tt, Tt)) {
            const Mt = kT(tt, fe, Se, n.vertical || $, o, K, ie, r.overscaling, Tt);
            for (const wt of Mt)
              $ && VT(r, $.text, Ie, wt) || dt(tt, wt, I);
          }
        else if (ze === "line-center") {
          for (const tt of e.geometry)
            if (tt.length > 1) {
              const Mt = DT(tt, Se, n.vertical || $, o, K, ie);
              Mt && dt(tt, Mt, I);
            }
        } else if (e.type === "Polygon")
          for (const tt of Mp(e.geometry, 0)) {
            const Mt = OT(tt, 16);
            dt(tt[0], new zl(Mt.x, Mt.y, 0, 0, void 0), I);
          }
        else if (e.type === "LineString")
          for (const tt of e.geometry)
            dt(tt, new zl(tt[0].x, tt[0].y, 0, 0, void 0), I);
        else if (e.type === "Point")
          for (const tt of e.geometry)
            for (const Mt of tt)
              dt([Mt], new zl(Mt.x, Mt.y, 0, 0, void 0), I);
      }
      const Jd = 255, vc = Jd * Sa;
      function ox(r, e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V, U) {
        const q = function(K, Q, ie, fe, de, ue, Se, me) {
          const Ee = [];
          if (Q.positionedLines.length === 0)
            return Ee;
          const ze = fe.layout.get("text-rotate").evaluate(ue, {}) * Math.PI / 180, Ie = function(et) {
            const dt = et[0], tt = et[1], Mt = dt * tt;
            return Mt > 0 ? [dt, -tt] : Mt < 0 ? [-dt, tt] : dt === 0 ? [tt, dt] : [tt, -dt];
          }(ie);
          let Re = Math.abs(Q.top - Q.bottom);
          for (const et of Q.positionedLines)
            Re -= et.lineOffset;
          const Ve = Q.positionedLines.length, Ue = Re / Ve;
          let Fe = Q.top - ie[1];
          for (let et = 0; et < Ve; ++et) {
            const dt = Q.positionedLines[et];
            Fe = RT(Q, Ue, Fe, et);
            for (const tt of dt.positionedGlyphs) {
              if (!tt.rect)
                continue;
              const Mt = tt.rect || {};
              let wt = N0 + 1, Pt = !0, rt = 1, Ut = 0;
              if (tt.imageName) {
                const Kn = Se[ss.build(tt.imageName).getSerializedPrimary()];
                if (!Kn)
                  continue;
                if (Kn.sdf) {
                  mi("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                Pt = !1, rt = Kn.pixelRatio, wt = Yd / rt;
              }
              const St = (de || me) && tt.vertical, Nt = tt.metrics.advance * tt.scale / 2, Qt = tt.metrics, pi = tt.rect;
              if (pi === null)
                continue;
              me && Q.verticalizable && (Ut = tt.imageName ? Nt - tt.metrics.width * tt.scale / 2 : 0);
              const gi = de ? [tt.x + Nt, tt.y] : [0, 0];
              let Pi = [0, 0], yi = [0, 0], Ii = !1;
              de || (St ? (yi = [tt.x + Nt + Ie[0], tt.y + Ie[1] - Ut], Ii = !0) : Pi = [tt.x + Nt + ie[0], tt.y + ie[1] - Ut]);
              const fn = pi.w * tt.scale / (rt * (tt.localGlyph ? Ea : 1)), rn = pi.h * tt.scale / (rt * (tt.localGlyph ? Ea : 1));
              let hi, on, Qi, pn;
              if (St) {
                const Kn = tt.y - Fe, Vr = new Et(-Nt, Nt - Kn), Sn = -Math.PI / 2, Ln = new Et(...yi);
                hi = new Et(-Nt + Pi[0], Pi[1]), hi._rotateAround(Sn, Vr)._add(Ln), hi.x += -Kn + Nt, hi.y -= (Qt.left - wt) * tt.scale;
                const Tr = tt.imageName ? Qt.advance * tt.scale : tr * tt.scale, cs = String.fromCodePoint(tt.glyph);
                MT(cs) ? hi.x += (1 - wt) * tt.scale : ST(cs) ? hi.x += Tr - Qt.height * tt.scale + (-wt - 1) * tt.scale : hi.x += tt.imageName || Qt.width + 2 * wt === pi.w && Qt.height + 2 * wt === pi.h ? (Tr - rn) / 2 : (Tr - (Qt.height + 2 * wt) * tt.scale) / 2, on = new Et(hi.x, hi.y - fn), Qi = new Et(hi.x + rn, hi.y), pn = new Et(hi.x + rn, hi.y - fn);
              } else {
                const Kn = (Qt.left - wt) * tt.scale - Nt + Pi[0], Vr = (-Qt.top - wt) * tt.scale + Pi[1], Sn = Kn + fn, Ln = Vr + rn;
                hi = new Et(Kn, Vr), on = new Et(Sn, Vr), Qi = new Et(Kn, Ln), pn = new Et(Sn, Ln);
              }
              if (ze) {
                let Kn;
                Kn = de ? new Et(0, 0) : Ii ? new Et(Ie[0], Ie[1]) : new Et(ie[0], ie[1]), hi._rotateAround(ze, Kn), on._rotateAround(ze, Kn), Qi._rotateAround(ze, Kn), pn._rotateAround(ze, Kn);
              }
              const as = new Et(0, 0), ls = new Et(0, 0);
              Ee.push({ tl: hi, tr: on, bl: Qi, br: pn, texPrimary: Mt, texSecondary: void 0, writingMode: Q.writingMode, glyphOffset: gi, sectionIndex: tt.sectionIndex, isSDF: Pt, pixelOffsetTL: as, pixelOffsetBR: ls, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return Ee;
        }(0, o, S, l, f, v, u, r.allowVerticalPlacement), $ = r.textSizeData;
        let H = null;
        $.kind === "source" ? (H = [Sa * l.layout.get("text-size").evaluate(v, {}, V) * C.textScaleFactor], H[0] > vc && mi(`${r.layerIds[0]}: Value for "text-size" is >= ${Jd}. Reduce your "text-size".`)) : $.kind === "composite" && (H = [Sa * C.compositeTextSizes[0].evaluate(v, {}, V) * C.textScaleFactor, Sa * C.compositeTextSizes[1].evaluate(v, {}, V) * C.textScaleFactor], (H[0] > vc || H[1] > vc) && mi(`${r.layerIds[0]}: Value for "text-size" is >= ${Jd}. Reduce your "text-size".`)), r.addSymbols(r.text, q, H, S, f, v, x, e, n, D.lineStartIndex, D.lineLength, M, k, V, U, !1);
        for (const K of A)
          I[K] = r.text.placedSymbolArray.length - 1;
        return 4 * q.length;
      }
      function ax(r) {
        for (const e in r)
          return r[e];
        return null;
      }
      function Bp(r, e, n, o, u, l, f, v, S, D, x = 1) {
        let A = f.top / x, I = f.bottom / x, M = f.left / x, C = f.right / x;
        const k = f.collisionPadding;
        if (k && (M -= k[0], A -= k[1], C += k[2], I += k[3]), S) {
          const V = new Et(M, A), U = new Et(C, A), q = new Et(M, I), $ = new Et(C, I), H = vi(S);
          let K = new Et(0, 0);
          D && (K = new Et(D[0], D[1])), V._rotateAround(H, K), U._rotateAround(H, K), q._rotateAround(H, K), $._rotateAround(H, K), M = Math.min(V.x, U.x, q.x, $.x), C = Math.max(V.x, U.x, q.x, $.x), A = Math.min(V.y, U.y, q.y, $.y), I = Math.max(V.y, U.y, q.y, $.y);
        }
        return r.emplaceBack(e.x, e.y, e.z, n.x, n.y, M, A, C, I, v, o, u, l), r.length - 1;
      }
      function G_(r) {
        r.collisionPadding && (r.top -= r.collisionPadding[1], r.bottom += r.collisionPadding[3]);
        const e = r.bottom - r.top;
        return e > 0 ? Math.max(10, e) : null;
      }
      function VT(r, e, n, o) {
        const u = r.compareText;
        if (e in u) {
          const l = u[e];
          for (let f = l.length - 1; f >= 0; f--)
            if (o.dist(l[f]) < n)
              return !0;
        } else
          u[e] = [];
        return u[e].push(o), !1;
      }
      function lx(r, e) {
        const n = r.fovAboveCenter, o = r.elevation ? r.elevation.getMinElevationBelowMSL() * e : 0, u = (r._camera.position[2] * r.worldSize - o) / Math.cos(r._pitch), l = Math.sin(n) * u / Math.sin(Math.max(Math.PI / 2 - r._pitch - n, 0.01));
        let f = Math.sin(r._pitch) * l + u;
        const v = u * (1 / r._horizonShift);
        return r.elevation && r.elevation.exaggeration() !== 0 || (f *= 1 + Math.max(r.zoom - 17, 0)), Math.min(1.01 * f, v);
      }
      function Qd(r, e) {
        if (!e.isReprojectedInTileSpace)
          return { scale: 1 << r.z, x: r.x, y: r.y, x2: r.x + 1, y2: r.y + 1, projection: e };
        const n = Math.pow(2, -r.z), o = r.x * n, u = (r.x + 1) * n, l = r.y * n, f = (r.y + 1) * n, v = Fr(o), S = Fr(u), D = Os(l), x = Os(f), A = e.project(v, D), I = e.project(S, D), M = e.project(S, x), C = e.project(v, x);
        let k = Math.min(A.x, I.x, M.x, C.x), V = Math.min(A.y, I.y, M.y, C.y), U = Math.max(A.x, I.x, M.x, C.x), q = Math.max(A.y, I.y, M.y, C.y);
        const $ = n / 16;
        function H(Q, ie, fe, de, ue, Se) {
          const me = (fe + ue) / 2, Ee = (de + Se) / 2, ze = e.project(Fr(me), Os(Ee)), Ie = Math.max(0, k - ze.x, V - ze.y, ze.x - U, ze.y - q);
          k = Math.min(k, ze.x), U = Math.max(U, ze.x), V = Math.min(V, ze.y), q = Math.max(q, ze.y), Ie > $ && (H(Q, ze, fe, de, me, Ee), H(ze, ie, me, Ee, ue, Se));
        }
        H(A, I, o, l, u, l), H(I, M, u, l, u, f), H(M, C, u, f, o, f), H(C, A, o, f, o, l), k -= $, V -= $, U += $, q += $;
        const K = 1 / Math.max(U - k, q - V);
        return { scale: K, x: k * K, y: V * K, x2: U * K, y2: q * K, projection: e };
      }
      function cx(r, { x: e, y: n }, o = 0) {
        return new Et(((e - o) * r.scale - r.x) * Tt, (n * r.scale - r.y) * Tt);
      }
      const UT = De.mat4.identity(new Float32Array(16));
      class bc {
        constructor(e) {
          this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(e, n) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(e, n) {
          return new Ui(0, 0);
        }
        projectTilePoint(e, n, o) {
          return { x: e, y: n, z: 0 };
        }
        locationPoint(e, n, o = !0) {
          return e._coordinatePoint(e.locationCoordinate(n), o);
        }
        pixelsPerMeter(e, n) {
          return fr(1, e) * n;
        }
        pixelSpaceConversion(e, n, o) {
          return 1;
        }
        farthestPixelDistance(e) {
          return lx(e, e.pixelsPerMeter);
        }
        pointCoordinate(e, n, o, u) {
          const l = e.horizonLineFromTop(!1), f = new Et(n, Math.max(l, o));
          return e.rayIntersectionCoordinate(e.pointRayIntersection(f, u));
        }
        pointCoordinate3D(e, n, o) {
          const u = new Et(n, o);
          if (e.elevation)
            return e.elevation.pointCoordinate(u);
          {
            const l = this.pointCoordinate(e, u.x, u.y, 0);
            return [l.x, l.y, l.z];
          }
        }
        isPointAboveHorizon(e, n) {
          if (e.elevation && e.elevation.visibleDemTiles.length)
            return !this.pointCoordinate3D(e, n.x, n.y);
          const o = e.horizonLineFromTop();
          return n.y < o;
        }
        createInversionMatrix(e, n) {
          return UT;
        }
        createTileMatrix(e, n, o) {
          let u, l, f;
          const v = o.canonical, S = De.mat4.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const D = Qd(v, this);
            u = 1, l = D.x + o.wrap * D.scale, f = D.y, De.mat4.scale(S, S, [u / D.scale, u / D.scale, e.pixelsPerMeter / n]);
          } else
            u = n / e.zoomScale(v.z), l = (v.x + Math.pow(2, v.z) * o.wrap) * u, f = v.y * u;
          return De.mat4.translate(S, S, [l, f, 0]), De.mat4.scale(S, S, [u / Tt, u / Tt, 1]), S;
        }
        upVector(e, n, o) {
          return [0, 0, 1];
        }
        upVectorScale(e, n, o) {
          return { metersToTile: 1 };
        }
      }
      class jT extends bc {
        constructor(e) {
          super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
          const [n, o] = this.parallels = e.parallels || [29.5, 45.5], u = Math.sin(vi(n));
          this.n = (u + Math.sin(vi(o))) / 2, this.c = 1 + u * (2 * this.n - u), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(e, n) {
          const { n: o, c: u, r0: l } = this, f = vi(e - this.center[0]), v = vi(n), S = Math.sqrt(u - 2 * o * Math.sin(v)) / o;
          return { x: S * Math.sin(f * o), y: S * Math.cos(f * o) - l, z: 0 };
        }
        unproject(e, n) {
          const { n: o, c: u, r0: l } = this, f = l + n;
          let v = Math.atan2(e, Math.abs(f)) * Math.sign(f);
          f * o < 0 && (v -= Math.PI * Math.sign(e) * Math.sign(f));
          const S = vi(this.center[0]) * o;
          v = zn(v, -Math.PI - S, Math.PI - S);
          const D = si(kn(v / o) + this.center[0], -180, 180), x = Math.asin(si((u - (e * e + f * f) * o * o) / (2 * o), -1, 1)), A = si(kn(x), -Un, Un);
          return new Ui(D, A);
        }
      }
      const ef = 1.340264, tf = -0.081106, nf = 893e-6, sf = 3796e-6, Np = Math.sqrt(3) / 2;
      class GT extends bc {
        project(e, n) {
          n = n / 180 * Math.PI, e = e / 180 * Math.PI;
          const o = Math.asin(Np * Math.sin(n)), u = o * o, l = u * u * u;
          return { x: 0.5 * (e * Math.cos(o) / (Np * (ef + 3 * tf * u + l * (7 * nf + 9 * sf * u))) / Math.PI + 0.5), y: 1 - 0.5 * (o * (ef + tf * u + l * (nf + sf * u)) / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI;
          let o = n = (2 * (1 - n) - 1) * Math.PI, u = o * o, l = u * u * u;
          for (let x, A, I, M = 0; M < 12 && (A = o * (ef + tf * u + l * (nf + sf * u)) - n, I = ef + 3 * tf * u + l * (7 * nf + 9 * sf * u), x = A / I, o = si(o - x, -Math.PI / 3, Math.PI / 3), u = o * o, l = u * u * u, !(Math.abs(x) < 1e-12)); ++M)
            ;
          const f = Np * e * (ef + 3 * tf * u + l * (7 * nf + 9 * sf * u)) / Math.cos(o), v = Math.asin(Math.sin(o) / Np), S = si(180 * f / Math.PI, -180, 180), D = si(180 * v / Math.PI, -Un, Un);
          return new Ui(S, D);
        }
      }
      class ZT extends bc {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, n) {
          return { x: 0.5 + e / 360, y: 0.5 - n / 360, z: 0 };
        }
        unproject(e, n) {
          const o = 360 * (e - 0.5), u = si(360 * (0.5 - n), -Un, Un);
          return new Ui(o, u);
        }
      }
      const Ru = Math.PI / 2;
      function Vp(r) {
        return Math.tan((Ru + r) / 2);
      }
      class HT extends bc {
        constructor(e) {
          super(e), this.center = e.center || [0, 30];
          const [n, o] = this.parallels = e.parallels || [30, 30];
          let u = vi(n), l = vi(o);
          this.southernCenter = u + l < 0, this.southernCenter && (u = -u, l = -l);
          const f = Math.cos(u), v = Vp(u);
          this.n = u === l ? Math.sin(u) : Math.log(f / Math.cos(l)) / Math.log(Vp(l) / v), this.f = f * Math.pow(Vp(u), this.n) / this.n;
        }
        project(e, n) {
          n = vi(n), this.southernCenter && (n = -n), e = vi(e - this.center[0]);
          const o = 1e-6, { n: u, f: l } = this;
          l > 0 ? n < -Ru + o && (n = -Ru + o) : n > Ru - o && (n = Ru - o);
          const f = l / Math.pow(Vp(n), u);
          let v = f * Math.sin(u * e), S = l - f * Math.cos(u * e);
          return v = 0.5 * (v / Math.PI + 0.5), S = 0.5 * (S / Math.PI + 0.5), { x: v, y: this.southernCenter ? S : 1 - S, z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI, this.southernCenter && (n = 1 - n), n = (2 * (1 - n) - 0.5) * Math.PI;
          const { n: o, f: u } = this, l = u - n, f = Math.sign(l), v = Math.sign(o) * Math.sqrt(e * e + l * l);
          let S = Math.atan2(e, Math.abs(l)) * f;
          l * o < 0 && (S -= Math.PI * Math.sign(e) * f);
          const D = si(kn(S / o) + this.center[0], -180, 180), x = si(kn(2 * Math.atan(Math.pow(u / v, 1 / o)) - Ru), -Un, Un);
          return new Ui(D, this.southernCenter ? -x : x);
        }
      }
      class hx extends bc {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
        }
        project(e, n) {
          return { x: ta(e), y: Ta(n), z: 0 };
        }
        unproject(e, n) {
          const o = Fr(e), u = Os(n);
          return new Ui(o, u);
        }
      }
      const ux = vi(Un);
      class qT extends bc {
        project(e, n) {
          const o = (n = vi(n)) * n, u = o * o;
          return { x: 0.5 * ((e = vi(e)) * (0.8707 - 0.131979 * o + u * (u * (3971e-6 * o - 1529e-6 * u) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (n * (1.007226 + o * (0.015085 + u * (0.028874 * o - 0.044475 - 5916e-6 * u))) / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI;
          let o = n = (2 * (1 - n) - 1) * Math.PI, u = 25, l = 0, f = o * o;
          do {
            f = o * o;
            const D = f * f;
            l = (o * (1.007226 + f * (0.015085 + D * (0.028874 * f - 0.044475 - 5916e-6 * D))) - n) / (1.007226 + f * (0.045255 + D * (0.259866 * f - 0.311325 - 5916e-6 * 11 * D))), o = si(o - l, -ux, ux);
          } while (Math.abs(l) > 1e-6 && --u > 0);
          f = o * o;
          const v = si(kn(e / (0.8707 + f * (f * (f * f * f * (3971e-6 - 1529e-6 * f) - 0.013791) - 0.131979))), -180, 180), S = kn(o);
          return new Ui(v, S);
        }
      }
      const dx = vi(Un);
      class WT extends bc {
        project(e, n) {
          n = vi(n), e = vi(e);
          const o = Math.cos(n), u = 2 / Math.PI, l = Math.acos(o * Math.cos(e / 2)), f = Math.sin(l) / l, v = 0.5 * (e * u + 2 * o * Math.sin(e / 2) / f) || 0, S = 0.5 * (n + Math.sin(n) / f) || 0;
          return { x: 0.5 * (v / Math.PI + 0.5), y: 1 - 0.5 * (S / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          let o = e = (2 * e - 0.5) * Math.PI, u = n = (2 * (1 - n) - 1) * Math.PI, l = 25;
          const f = 1e-6;
          let v = 0, S = 0;
          do {
            const D = Math.cos(u), x = Math.sin(u), A = 2 * x * D, I = x * x, M = D * D, C = Math.cos(o / 2), k = Math.sin(o / 2), V = 2 * C * k, U = k * k, q = 1 - M * C * C, $ = q ? 1 / q : 0, H = q ? Math.acos(D * C) * Math.sqrt(1 / q) : 0, K = 0.5 * (2 * H * D * k + 2 * o / Math.PI) - e, Q = 0.5 * (H * x + u) - n, ie = 0.5 * $ * (M * U + H * D * C * I) + 1 / Math.PI, fe = $ * (V * A / 4 - H * x * k), de = 0.125 * $ * (A * k - H * x * M * V), ue = 0.5 * $ * (I * C + H * U * D) + 0.5, Se = fe * de - ue * ie;
            v = (Q * fe - K * ue) / Se, S = (K * de - Q * ie) / Se, o = si(o - v, -Math.PI, Math.PI), u = si(u - S, -dx, dx);
          } while ((Math.abs(v) > f || Math.abs(S) > f) && --l > 0);
          return new Ui(kn(o), kn(u));
        }
      }
      class fx extends bc {
        constructor(e) {
          super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(vi(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, n) {
          const { scale: o, cosPhi: u } = this;
          return { x: vi(e) * u * o + 0.5, y: -Math.sin(vi(n)) / u * o + 0.5, z: 0 };
        }
        unproject(e, n) {
          const { scale: o, cosPhi: u } = this, l = -(n - 0.5) / o, f = si(kn((e - 0.5) / o) / u, -180, 180), v = Math.asin(si(l * u, -1, 1)), S = si(kn(v), -Un, Un);
          return new Ui(f, S);
        }
      }
      class $T extends hx {
        constructor(e) {
          super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(e, n, o) {
          const u = Ri(e, n, o), l = cn(ts(o));
          return De.vec3.transformMat4(u, u, l), { x: u[0], y: u[1], z: u[2] };
        }
        locationPoint(e, n) {
          const o = el(n.lat, n.lng), u = De.vec3.normalize([], o), l = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(n), e._centerAltitude) : e._centerAltitude, f = fr(1, 0) * Tt * l;
          De.vec3.scaleAndAdd(o, o, u, f);
          const v = De.mat4.identity(new Float64Array(16));
          return De.mat4.multiply(v, e.pixelMatrix, e.globeMatrix), De.vec3.transformMat4(o, o, v), new Et(o[0], o[1]);
        }
        pixelsPerMeter(e, n) {
          return fr(1, 0) * n;
        }
        pixelSpaceConversion(e, n, o) {
          const u = fr(1, e) * n, l = ei(fr(1, 45) * n, u, o);
          return this.pixelsPerMeter(e, n) / l;
        }
        createTileMatrix(e, n, o) {
          const u = er(ts(o.canonical));
          return De.mat4.multiply(new Float64Array(16), e.globeMatrix, u);
        }
        createInversionMatrix(e, n) {
          const { center: o } = e, u = cn(ts(n));
          return De.mat4.rotateY(u, u, vi(o.lng)), De.mat4.rotateX(u, u, vi(o.lat)), De.mat4.scale(u, u, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(u);
        }
        pointCoordinate(e, n, o, u) {
          return In(e, n, o, !0) || new h(0, 0);
        }
        pointCoordinate3D(e, n, o) {
          const u = this.pointCoordinate(e, n, o, 0);
          return [u.x, u.y, u.z];
        }
        isPointAboveHorizon(e, n) {
          return !In(e, n.x, n.y, !1);
        }
        farthestPixelDistance(e) {
          const n = function(u, l) {
            const f = u.cameraToCenterDistance, v = u._centerAltitude * l, S = u._camera, D = u._camera.forward(), x = De.vec3.add([], De.vec3.scale([], D, -f), [0, 0, v]), A = u.worldSize / (2 * Math.PI), I = [0, 0, -A], M = u.width / u.height, C = Math.tan(u.fovAboveCenter), k = De.vec3.scale([], S.up(), C), V = De.vec3.scale([], S.right(), C * M), U = De.vec3.normalize([], De.vec3.add([], De.vec3.add([], D, k), V)), q = [];
            let $;
            if (new zi(x, U).closestPointOnSphere(I, A, q)) {
              const H = De.vec3.add([], q, I), K = De.vec3.sub([], H, x);
              $ = Math.cos(u.fovAboveCenter) * De.vec3.length(K);
            } else {
              const H = De.vec3.sub([], x, I), K = De.vec3.sub([], I, x);
              De.vec3.normalize(K, K);
              const Q = De.vec3.length(H) - A;
              $ = Math.sqrt(Q * (Q + 2 * A));
              const ie = Math.acos($ / (A + Q)) - Math.acos(De.vec3.dot(D, K));
              $ *= Math.cos(ie);
            }
            return 1.01 * $;
          }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), o = mr(e.zoom);
          if (o > 0) {
            const u = lx(e, fr(1, e.center.lat) * e.worldSize), l = e.worldSize / (2 * Math.PI), f = Math.max(e.width, e.height) / e.worldSize * Math.PI;
            return ei(n, u + l * (1 - Math.cos(f)), Math.pow(o, 10));
          }
          return n;
        }
        upVector(e, n, o) {
          return Ri(n, o, e, 1);
        }
        upVectorScale(e) {
          return { metersToTile: ji(Gn(ts(e))) };
        }
      }
      function px(r) {
        const e = r.parallels, n = !!e && Math.abs(e[0] + e[1]) < 0.01;
        switch (r.name) {
          case "mercator":
            return new hx(r);
          case "equirectangular":
            return new ZT(r);
          case "naturalEarth":
            return new qT(r);
          case "equalEarth":
            return new GT(r);
          case "winkelTripel":
            return new WT(r);
          case "albers":
            return n ? new fx(r) : new jT(r);
          case "lambertConformalConic":
            return n ? new fx(r) : new HT(r);
          case "globe":
            return new $T(r);
        }
        throw new Error(`Invalid projection name: ${r.name}`);
      }
      const XT = Iu.VectorTileFeature.types, YT = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Up(r, e, n, o, u, l, f, v, S, D, x, A, I) {
        const M = v ? Math.min(vc, Math.round(v[0])) : 0, C = v ? Math.min(vc, Math.round(v[1])) : 0;
        r.emplaceBack(e, n, Math.round(32 * o), Math.round(32 * u), l, f, (M << 1) + (S ? 1 : 0), C, 16 * D, 16 * x, 256 * A, 256 * I);
      }
      function jp(r, e, n) {
        r.emplaceBack(e, n);
      }
      function Gp(r, e, n, o, u, l, f) {
        r.emplaceBack(e, n, o, u, l, f);
      }
      function Zp(r, e, n, o, u) {
        r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u);
      }
      function KT(r) {
        for (const e of r.sections)
          if (Qf(e.text))
            return !0;
        return !1;
      }
      class Z_ {
        constructor(e) {
          this.layoutVertexArray = new Td(), this.indexArray = new qs(), this.programConfigurations = e, this.segments = new Wn(), this.dynamicLayoutVertexArray = new Xa(), this.opacityVertexArray = new Sd(), this.placedSymbolArray = new cp(), this.iconTransitioningVertexArray = new Ka(), this.globeExtVertexArray = new Md(), this.zOffsetVertexArray = new uc();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0;
        }
        upload(e, n, o, u, l) {
          this.isEmpty() || (o && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, pT.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, _T.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, YT, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, yT.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, mT.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || l) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, gT.members, !0)), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      Ft(Z_, "SymbolBuffers");
      class H_ {
        constructor(e, n, o) {
          this.layoutVertexArray = new e(), this.layoutAttributes = n, this.indexArray = new o(), this.segments = new Wn(), this.collisionVertexArray = new Ad(), this.collisionVertexArrayExt = new Xa();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, xT.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, vT.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Ft(H_, "CollisionBuffers");
      class Hp {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((f) => f.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = De.mat4.identity([]), this.placementViewportMatrix = De.mat4.identity([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = D_(this.zoom, n["text-size"]), this.iconSizeData = D_(this.zoom, n["icon-size"]);
          const o = this.layers[0].layout, u = o.get("symbol-sort-key"), l = o.get("symbol-z-order");
          this.canOverlap = o.get("text-allow-overlap") || o.get("icon-allow-overlap") || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = l !== "viewport-y" && u.constantOr(1) !== void 0, this.sortFeaturesByY = (l === "viewport-y" || l === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = o.get("text-writing-mode").map((f) => Ro[f]), this.stateDependentLayerIds = this.layers.filter((f) => f.isStateDependent()).map((f) => f.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = o.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        createArrays() {
          this.text = new Z_(new Qa(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new Z_(new Qa(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new hh(), this.lineVertexArray = new uh(), this.symbolInstances = new up();
        }
        calculateGlyphDependencies(e, n, o, u, l) {
          for (const f of e) {
            const v = f.codePointAt(0);
            if (v === void 0)
              break;
            if (n[v] = !0, u && l && v <= 65535) {
              const S = $d[f];
              S && (n[S.charCodeAt(0)] = !0);
            }
          }
        }
        updateFootprints(e, n) {
        }
        updateReplacement(e, n) {
          if (n.updateTime === this.replacementUpdateTime)
            return !1;
          this.replacementUpdateTime = n.updateTime;
          const o = n.getReplacementRegionsForTile(e.toUnwrapped(), !0);
          return !E_(this.activeReplacements, o) && (this.activeReplacements = o, !0);
        }
        populate(e, n, o, u) {
          const l = this.layers[0], f = l.layout, v = this.projection.name === "globe", S = f.get("text-font"), D = f.get("text-field"), x = f.get("icon-image"), [A, I] = f.get("icon-size-scale-range"), M = si(n.scaleFactor || 1, A, I), C = (D.value.kind !== "constant" || D.value.value instanceof Dn && !D.value.value.isEmpty() || D.value.value.toString().length > 0) && (S.value.kind !== "constant" || S.value.value.length > 0), k = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0, V = f.get("symbol-sort-key");
          if (this.features = [], !C && !k)
            return;
          const U = n.iconDependencies, q = n.glyphDependencies, $ = n.availableImages, H = new Tn(this.zoom);
          for (const { feature: K, id: Q, index: ie, sourceLayerIndex: fe } of e) {
            const de = l._featureFilter.needGeometry, ue = Z(K, de);
            if (!l._featureFilter.filter(H, ue, o))
              continue;
            if (de || (ue.geometry = G(K, o, u)), v && K.type !== 1 && o.z <= 5) {
              const Ie = ue.geometry, Re = 0.98078528056, Ve = (Ue, Fe) => {
                const et = Ri(Ue.x, Ue.y, o, 1), dt = Ri(Fe.x, Fe.y, o, 1);
                return De.vec3.dot(et, dt) < Re;
              };
              for (let Ue = 0; Ue < Ie.length; Ue++)
                Ie[Ue] = z(Ie[Ue], Ve);
            }
            let Se, me;
            if (C) {
              const Ie = l.getValueAndResolveTokens("text-field", ue, o, $), Re = Dn.factory(Ie);
              KT(Re) && (this.hasRTLText = !0), (!this.hasRTLText || au() === "unavailable" || this.hasRTLText && co.isParsed()) && (Se = TT(Re, l, ue));
            }
            if (k) {
              const Ie = l.getValueAndResolveTokens("icon-image", ue, o, $);
              me = Ie instanceof ss ? Ie : ss.build(Ie);
            }
            if (!Se && !me)
              continue;
            const Ee = this.sortFeaturesByKey ? V.evaluate(ue, {}, o) : void 0, ze = { id: Q, text: Se, icon: me, index: ie, sourceLayerIndex: fe, geometry: ue.geometry, properties: K.properties, type: XT[K.type], sortKey: Ee };
            if (this.features.push(ze), me) {
              const Ie = Lp(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], o, this.zoom, ze) * M * this.pixelRatio, Re = me.getPrimary().scaleSelf(Ie);
              if (U[Re.id] = U[Re.id] || [], U[Re.id].push(Re), me.nameSecondary) {
                const Ve = me.getSecondary().scaleSelf(Ie);
                U[Ve.id] = U[Ve.id] || [], U[Ve.id].push(Ve);
              }
            }
            if (Se) {
              const Ie = S.evaluate(ue, {}, o).join(","), Re = f.get("text-rotation-alignment") === "map" && f.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ro.vertical) >= 0;
              for (const Ve of Se.sections)
                if (Ve.image) {
                  const Ue = Ve.image.getPrimary().scaleSelf(this.pixelRatio);
                  U[Ue.id] = U[Ue.id] || [], U[Ue.id].push(Ue);
                } else {
                  const Ue = md(Se.toString()), Fe = Ve.fontStack || Ie, et = q[Fe] = q[Fe] || {};
                  this.calculateGlyphDependencies(Ve.text, et, Re, this.allowVerticalPlacement, Ue);
                }
            }
          }
          f.get("symbol-placement") === "line" && (this.features = function(K) {
            const Q = {}, ie = {}, fe = [];
            let de = 0;
            function ue(ze) {
              fe.push(K[ze]), de++;
            }
            function Se(ze, Ie, Re) {
              const Ve = ie[ze];
              return delete ie[ze], ie[Ie] = Ve, fe[Ve].geometry[0].pop(), fe[Ve].geometry[0] = fe[Ve].geometry[0].concat(Re[0]), Ve;
            }
            function me(ze, Ie, Re) {
              const Ve = Q[Ie];
              return delete Q[Ie], Q[ze] = Ve, fe[Ve].geometry[0].shift(), fe[Ve].geometry[0] = Re[0].concat(fe[Ve].geometry[0]), Ve;
            }
            function Ee(ze, Ie, Re) {
              const Ve = Re ? Ie[0][Ie[0].length - 1] : Ie[0][0];
              return `${ze}:${Ve.x}:${Ve.y}`;
            }
            for (let ze = 0; ze < K.length; ze++) {
              const Ie = K[ze], Re = Ie.geometry, Ve = Ie.text ? Ie.text.toString() : null;
              if (!Ve) {
                ue(ze);
                continue;
              }
              const Ue = Ee(Ve, Re), Fe = Ee(Ve, Re, !0);
              if (Ue in ie && Fe in Q && ie[Ue] !== Q[Fe]) {
                const et = me(Ue, Fe, Re), dt = Se(Ue, Fe, fe[et].geometry);
                delete Q[Ue], delete ie[Fe], ie[Ee(Ve, fe[dt].geometry, !0)] = dt, fe[et].geometry = null;
              } else
                Ue in ie ? Se(Ue, Fe, Re) : Fe in Q ? me(Ue, Fe, Re) : (ue(ze), Q[Ue] = de - 1, ie[Fe] = de - 1);
            }
            return fe.filter((ze) => ze.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((K, Q) => K.sortKey - Q.sortKey);
        }
        update(e, n, o, u, l, f, v) {
          this.text.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v), this.icon.programConfigurations.updatePaintArrays(e, n, l, o, u, f, v);
        }
        updateZOffset() {
          const e = (l, f, v) => {
            o += f, o > l.length && l.resize(o);
            for (let S = -f; S < 0; S++)
              l.emplace(S + o, v);
          }, n = (l, f, v) => {
            u += f, u > l.length && l.resize(u);
            for (let S = -f; S < 0; S++)
              l.emplace(S + u, v);
          };
          if (!this.zOffsetBuffersNeedUpload)
            return;
          this.zOffsetBuffersNeedUpload = !1;
          let o = 0, u = 0;
          for (let l = 0; l < this.symbolInstances.length; l++) {
            const f = this.symbolInstances.get(l), { numHorizontalGlyphVertices: v, numVerticalGlyphVertices: S, numIconVertices: D } = f, x = f.zOffset, A = D > 0;
            if ((v > 0 || S > 0) && (e(this.text.zOffsetVertexArray, v, x), e(this.text.zOffsetVertexArray, S, x)), A) {
              const { placedIconSymbolIndex: I, verticalPlacedIconSymbolIndex: M } = f;
              I >= 0 && n(this.icon.zOffsetVertexArray, D, x), M >= 0 && n(this.icon.zOffsetVertexArray, f.numVerticalIconVertices, x);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = px(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, n) {
          const o = this.lineVertexArray.length;
          if (e.segment !== void 0)
            for (const { x: u, y: l } of n)
              this.lineVertexArray.emplaceBack(u, l);
          return { lineStartIndex: o, lineLength: this.lineVertexArray.length - o };
        }
        addSymbols(e, n, o, u, l, f, v, S, D, x, A, I, M, C, k, V) {
          const U = e.indexArray, q = e.layoutVertexArray, $ = e.globeExtVertexArray, H = e.segments.prepareSegment(4 * n.length, q, U, this.canOverlap ? f.sortKey : void 0), K = this.glyphOffsetArray.length, Q = H.vertexLength, ie = this.allowVerticalPlacement && v === Ro.vertical ? Math.PI / 2 : 0, fe = f.text && f.text.sections;
          for (let ue = 0; ue < n.length; ue++) {
            const { tl: Se, tr: me, bl: Ee, br: ze, texPrimary: Ie, texSecondary: Re, pixelOffsetTL: Ve, pixelOffsetBR: Ue, minFontScaleX: Fe, minFontScaleY: et, glyphOffset: dt, isSDF: tt, sectionIndex: Mt } = n[ue], wt = H.vertexLength, Pt = dt[1];
            if (Up(q, D.x, D.y, Se.x, Pt + Se.y, Ie.x, Ie.y, o, tt, Ve.x, Ve.y, Fe, et), Up(q, D.x, D.y, me.x, Pt + me.y, Ie.x + Ie.w, Ie.y, o, tt, Ue.x, Ve.y, Fe, et), Up(q, D.x, D.y, Ee.x, Pt + Ee.y, Ie.x, Ie.y + Ie.h, o, tt, Ve.x, Ue.y, Fe, et), Up(q, D.x, D.y, ze.x, Pt + ze.y, Ie.x + Ie.w, Ie.y + Ie.h, o, tt, Ue.x, Ue.y, Fe, et), S) {
              const { x: rt, y: Ut, z: St } = S.anchor, [Nt, Qt, pi] = S.up;
              Gp($, rt, Ut, St, Nt, Qt, pi), Gp($, rt, Ut, St, Nt, Qt, pi), Gp($, rt, Ut, St, Nt, Qt, pi), Gp($, rt, Ut, St, Nt, Qt, pi), Zp(e.dynamicLayoutVertexArray, rt, Ut, St, ie);
            } else
              Zp(e.dynamicLayoutVertexArray, D.x, D.y, D.z, ie);
            if (V) {
              const rt = Re || Ie;
              jp(e.iconTransitioningVertexArray, rt.x, rt.y), jp(e.iconTransitioningVertexArray, rt.x + rt.w, rt.y), jp(e.iconTransitioningVertexArray, rt.x, rt.y + rt.h), jp(e.iconTransitioningVertexArray, rt.x + rt.w, rt.y + rt.h);
            }
            U.emplaceBack(wt, wt + 1, wt + 2), U.emplaceBack(wt + 1, wt + 2, wt + 3), H.vertexLength += 4, H.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), ue !== n.length - 1 && Mt === n[ue + 1].sectionIndex || e.programConfigurations.populatePaintArrays(q.length, f, f.index, {}, M, C, k, fe && fe[Mt]);
          }
          const de = S ? S.anchor : D;
          e.placedSymbolArray.emplaceBack(de.x, de.y, de.z, D.x, D.y, K, this.glyphOffsetArray.length - K, Q, x, A, D.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], v, 0, !1, 0, I, 0);
        }
        _commitLayoutVertex(e, n, o, u, l, f, v) {
          e.emplaceBack(n, o, u, l, f, Math.round(v.x), Math.round(v.y));
        }
        _addCollisionDebugVertices(e, n, o, u, l, f, v) {
          const S = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), D = S.vertexLength, x = v.tileAnchorX, A = v.tileAnchorY;
          for (let M = 0; M < 4; M++)
            o.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(o.collisionVertexArrayExt, n, e.padding, v.zOffset), this._commitLayoutVertex(o.layoutVertexArray, u, l, f, x, A, new Et(e.x1, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, u, l, f, x, A, new Et(e.x2, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, u, l, f, x, A, new Et(e.x2, e.y2)), this._commitLayoutVertex(o.layoutVertexArray, u, l, f, x, A, new Et(e.x1, e.y2)), S.vertexLength += 4;
          const I = o.indexArray;
          I.emplaceBack(D, D + 1), I.emplaceBack(D + 1, D + 2), I.emplaceBack(D + 2, D + 3), I.emplaceBack(D + 3, D), S.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(e, n, o, u, l, f) {
          for (let v = u; v < l; v++) {
            const S = o.get(v), D = this.getSymbolInstanceTextSize(e, f, n, v);
            this._addCollisionDebugVertices(S, D, this.textCollisionBox, S.projectedAnchorX, S.projectedAnchorY, S.projectedAnchorZ, f);
          }
        }
        _addIconDebugCollisionBoxes(e, n, o, u, l, f) {
          for (let v = u; v < l; v++) {
            const S = o.get(v), D = this.getSymbolInstanceIconSize(e, n, f.placedIconSymbolIndex);
            this._addCollisionDebugVertices(S, D, this.iconCollisionBox, S.projectedAnchorX, S.projectedAnchorY, S.projectedAnchorZ, f);
          }
        }
        generateCollisionDebugBuffers(e, n, o) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new H_(mu, R0.members, Ka), this.iconCollisionBox = new H_(mu, R0.members, Ka);
          const u = Lu(this.iconSizeData, e), l = Lu(this.textSizeData, e, o);
          for (let f = 0; f < this.symbolInstances.length; f++) {
            const v = this.symbolInstances.get(f);
            this._addTextDebugCollisionBoxes(l, e, n, v.textBoxStartIndex, v.textBoxEndIndex, v), this._addTextDebugCollisionBoxes(l, e, n, v.verticalTextBoxStartIndex, v.verticalTextBoxEndIndex, v), this._addIconDebugCollisionBoxes(u, e, n, v.iconBoxStartIndex, v.iconBoxEndIndex, v), this._addIconDebugCollisionBoxes(u, e, n, v.verticalIconBoxStartIndex, v.verticalIconBoxEndIndex, v);
          }
        }
        getSymbolInstanceTextSize(e, n, o, u) {
          const l = this.text.placedSymbolArray.get(n.rightJustifiedTextSymbolIndex >= 0 ? n.rightJustifiedTextSymbolIndex : n.centerJustifiedTextSymbolIndex >= 0 ? n.centerJustifiedTextSymbolIndex : n.leftJustifiedTextSymbolIndex >= 0 ? n.leftJustifiedTextSymbolIndex : n.verticalPlacedTextSymbolIndex >= 0 ? n.verticalPlacedTextSymbolIndex : u), f = zp(this.textSizeData, e, l) / tr;
          return this.tilePixelRatio * f;
        }
        getSymbolInstanceIconSize(e, n, o) {
          const u = this.icon.placedSymbolArray.get(o), l = zp(this.iconSizeData, e, u);
          return this.tilePixelRatio * l;
        }
        _commitDebugCollisionVertexUpdate(e, n, o, u) {
          e.emplaceBack(n, -o, -o, u), e.emplaceBack(n, o, -o, u), e.emplaceBack(n, o, o, u), e.emplaceBack(n, -o, o, u);
        }
        _updateTextDebugCollisionBoxes(e, n, o, u, l, f, v) {
          for (let S = u; S < l; S++) {
            const D = o.get(S), x = this.getSymbolInstanceTextSize(e, f, n, S);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, x, D.padding, f.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(e, n, o, u, l, f, v) {
          for (let S = u; S < l; S++) {
            const D = o.get(S), x = this.getSymbolInstanceIconSize(e, n, f.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, x, D.padding, f.zOffset);
          }
        }
        updateCollisionDebugBuffers(e, n, o, u) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const l = Lu(this.iconSizeData, e, u), f = Lu(this.textSizeData, e, o);
          for (let v = 0; v < this.symbolInstances.length; v++) {
            const S = this.symbolInstances.get(v);
            this._updateTextDebugCollisionBoxes(f, e, n, S.textBoxStartIndex, S.textBoxEndIndex, S, o), this._updateTextDebugCollisionBoxes(f, e, n, S.verticalTextBoxStartIndex, S.verticalTextBoxEndIndex, S, o), this._updateIconDebugCollisionBoxes(l, e, n, S.iconBoxStartIndex, S.iconBoxEndIndex, S, u), this._updateIconDebugCollisionBoxes(l, e, n, S.verticalIconBoxStartIndex, S.verticalIconBoxEndIndex, S, u);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(e, n, o, u, l, f, v, S, D) {
          const x = {};
          if (n < o) {
            const { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(n);
            x.textBox = { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.textFeatureIndex = K;
          }
          if (u < l) {
            const { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(u);
            x.verticalTextBox = { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.verticalTextFeatureIndex = K;
          }
          if (f < v) {
            const { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(f);
            x.iconBox = { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.iconFeatureIndex = K;
          }
          if (S < D) {
            const { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(S);
            x.verticalIconBox = { x1: A, y1: I, x2: M, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.verticalIconFeatureIndex = K;
          }
          return x;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const o = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(e, n) {
          const o = e.placedSymbolArray.get(n), u = o.vertexStartIndex + 4 * o.numGlyphs;
          for (let l = o.vertexStartIndex; l < u; l += 4)
            e.indexArray.emplaceBack(l, l + 1, l + 2), e.indexArray.emplaceBack(l + 1, l + 2, l + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const n = Math.sin(e), o = Math.cos(e), u = [], l = [], f = [];
          for (let v = 0; v < this.symbolInstances.length; ++v) {
            f.push(v);
            const S = this.symbolInstances.get(v);
            u.push(0 | Math.round(n * S.tileAnchorX + o * S.tileAnchorY)), l.push(S.featureIndex);
          }
          return f.sort((v, S) => u[v] - u[S] || l[S] - l[v]), f;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty)
            return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let e = 0; e < this.symbolInstances.length; ++e)
              this.symbolInstanceIndexesSortedZOffset.push(e);
          }
          return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, n) => this.symbolInstances.get(n).zOffset - this.symbolInstances.get(e).zOffset);
        }
        addToSortKeyRanges(e, n) {
          const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          o && o.sortKey === n ? o.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const o = this.symbolInstances.get(n);
              this.featureSortOrder.push(o.featureIndex);
              const { rightJustifiedTextSymbolIndex: u, centerJustifiedTextSymbolIndex: l, leftJustifiedTextSymbolIndex: f, verticalPlacedTextSymbolIndex: v, placedIconSymbolIndex: S, verticalPlacedIconSymbolIndex: D } = o;
              u >= 0 && this.addIndicesForPlacedSymbol(this.text, u), l >= 0 && l !== u && this.addIndicesForPlacedSymbol(this.text, l), f >= 0 && f !== l && f !== u && this.addIndicesForPlacedSymbol(this.text, f), v >= 0 && this.addIndicesForPlacedSymbol(this.text, v), S >= 0 && this.addIndicesForPlacedSymbol(this.icon, S), D >= 0 && this.addIndicesForPlacedSymbol(this.icon, D);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let mx, _x, q_;
      Ft(Hp, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Hp.addDynamicAttributes = Zp;
      class gx {
        constructor(e) {
          this.type = e.property.overrides ? e.property.overrides.runtimeType : ha, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(e.formattedSection))
              return n.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Ft(gx, "FormatSectionOverride", { omit: ["defaultValue"] });
      const W_ = () => q_ || (q_ = { layout: mx || (mx = new Bn({ "symbol-placement": new yt($e.layout_symbol["symbol-placement"]), "symbol-spacing": new yt($e.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new yt($e.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Dt($e.layout_symbol["symbol-sort-key"]), "symbol-z-order": new yt($e.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new yt($e.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new yt($e.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new yt($e.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new yt($e.layout_symbol["icon-ignore-placement"]), "icon-optional": new yt($e.layout_symbol["icon-optional"]), "icon-rotation-alignment": new yt($e.layout_symbol["icon-rotation-alignment"]), "icon-size": new Dt($e.layout_symbol["icon-size"]), "icon-size-scale-range": new yt($e.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new Dt($e.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Dt($e.layout_symbol["icon-text-fit-padding"]), "icon-image": new Dt($e.layout_symbol["icon-image"]), "icon-rotate": new Dt($e.layout_symbol["icon-rotate"]), "icon-padding": new yt($e.layout_symbol["icon-padding"]), "icon-keep-upright": new yt($e.layout_symbol["icon-keep-upright"]), "icon-offset": new Dt($e.layout_symbol["icon-offset"]), "icon-anchor": new Dt($e.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new yt($e.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new yt($e.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new yt($e.layout_symbol["text-rotation-alignment"]), "text-field": new Dt($e.layout_symbol["text-field"]), "text-font": new Dt($e.layout_symbol["text-font"]), "text-size": new Dt($e.layout_symbol["text-size"]), "text-size-scale-range": new yt($e.layout_symbol["text-size-scale-range"]), "text-max-width": new Dt($e.layout_symbol["text-max-width"]), "text-line-height": new Dt($e.layout_symbol["text-line-height"]), "text-letter-spacing": new Dt($e.layout_symbol["text-letter-spacing"]), "text-justify": new Dt($e.layout_symbol["text-justify"]), "text-radial-offset": new Dt($e.layout_symbol["text-radial-offset"]), "text-variable-anchor": new yt($e.layout_symbol["text-variable-anchor"]), "text-anchor": new Dt($e.layout_symbol["text-anchor"]), "text-max-angle": new yt($e.layout_symbol["text-max-angle"]), "text-writing-mode": new yt($e.layout_symbol["text-writing-mode"]), "text-rotate": new Dt($e.layout_symbol["text-rotate"]), "text-padding": new yt($e.layout_symbol["text-padding"]), "text-keep-upright": new yt($e.layout_symbol["text-keep-upright"]), "text-transform": new Dt($e.layout_symbol["text-transform"]), "text-offset": new Dt($e.layout_symbol["text-offset"]), "text-allow-overlap": new yt($e.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new yt($e.layout_symbol["text-ignore-placement"]), "text-optional": new yt($e.layout_symbol["text-optional"]), visibility: new yt($e.layout_symbol.visibility) })), paint: _x || (_x = new Bn({ "icon-opacity": new Dt($e.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new Dt($e.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new Dt($e.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Dt($e.paint_symbol["text-emissive-strength"]), "icon-color": new Dt($e.paint_symbol["icon-color"]), "icon-halo-color": new Dt($e.paint_symbol["icon-halo-color"]), "icon-halo-width": new Dt($e.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Dt($e.paint_symbol["icon-halo-blur"]), "icon-translate": new yt($e.paint_symbol["icon-translate"]), "icon-translate-anchor": new yt($e.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Dt($e.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Dt($e.paint_symbol["text-opacity"]), "text-occlusion-opacity": new Dt($e.paint_symbol["text-occlusion-opacity"]), "text-color": new Dt($e.paint_symbol["text-color"], { runtimeType: ms, getOverride: (r) => r.textColor, hasOverride: (r) => !!r.textColor }), "text-halo-color": new Dt($e.paint_symbol["text-halo-color"]), "text-halo-width": new Dt($e.paint_symbol["text-halo-width"]), "text-halo-blur": new Dt($e.paint_symbol["text-halo-blur"]), "text-translate": new yt($e.paint_symbol["text-translate"]), "text-translate-anchor": new yt($e.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new yt($e.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new yt($e.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new yt($e.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new yt($e.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new Dt($e.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, q_);
      class qp extends wr {
        constructor(e, n, o, u) {
          super(e, W_(), n, o, u), this._colorAdjustmentMatrix = De.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint);
        }
        recalculate(e, n) {
          super.recalculate(e, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const o = this.layout.get("text-writing-mode");
          if (o) {
            const u = [];
            for (const l of o)
              u.indexOf(l) < 0 && u.push(l);
            this.layout._values["text-writing-mode"] = u;
          } else
            this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getColorAdjustmentMatrix(e, n, o, u) {
          return this._saturation === e && this._contrast === n && this._brightnessMin === o && this._brightnessMax === u || (this._colorAdjustmentMatrix = function(l, f, v, S) {
            l = le(l), f = re(f);
            const D = De.mat4.create(), x = l / 3, A = 1 - 2 * x, I = [A, x, x, 0, x, A, x, 0, x, x, A, 0, 0, 0, 0, 1], M = 0.5 - 0.5 * f, C = S - v;
            return De.mat4.multiply(D, [C, 0, 0, 0, 0, C, 0, 0, 0, 0, C, 0, v, v, v, 1], [f, 0, 0, 0, 0, f, 0, 0, 0, 0, f, 0, M, M, M, 1]), De.mat4.multiply(D, D, I), D;
          }(e, n, o, u), this._saturation = e, this._contrast = n, this._brightnessMin = o, this._brightnessMax = u), this._colorAdjustmentMatrix;
        }
        getValueAndResolveTokens(e, n, o, u) {
          const l = this.layout.get(e).evaluate(n, {}, o, u), f = this._unevaluatedLayout._values[e];
          return f.isDataDriven() || tu(f.value) || !l ? l : function(v, S) {
            return S.replace(/{([^{}]+)}/g, (D, x) => x in v ? String(v[x]) : "");
          }(n.properties, l);
        }
        createBucket(e) {
          return new Hp(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        _setPaintOverrides() {
          for (const e of W_().paint.overridableProperties) {
            if (!qp.hasPaintOverride(this.layout, e))
              continue;
            const n = this.paint.get(e), o = new gx(n), u = new cd(o, n.property.specification, this.scope, this.options);
            let l = null;
            l = n.value.kind === "constant" || n.value.kind === "source" ? new hd("source", u) : new sc("composite", u, n.value.zoomStops, n.value._interpolationType), this.paint._values[e] = new lc(n.property, l, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && qp.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, n) {
          const o = e.get("text-field"), u = W_().paint.properties[n];
          let l = !1;
          const f = (v) => {
            for (const S of v)
              if (u.overrides && u.overrides.hasOverride(S))
                return void (l = !0);
          };
          if (o.value.kind === "constant" && o.value.value instanceof Dn)
            f(o.value.value.sections);
          else if (o.value.kind === "source") {
            const v = (D) => {
              l || (D instanceof Lr && vn(D.value) === Js ? f(D.value.sections) : D instanceof Es ? f(D.sections) : D.eachChild(v));
            }, S = o.value;
            S._styleExpression && v(S._styleExpression.expression);
          }
          return l;
        }
        getProgramIds() {
          return ["symbol"];
        }
        getDefaultProgramParams(e, n, o) {
          return { config: new Cl(this, { zoom: n, lut: o }), overrideFog: !1 };
        }
      }
      let yx, xx, vx, bx;
      var $_ = qi([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      function X_(r) {
        switch (r) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.RGBA;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.DEPTH_COMPONENT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.DEPTH_STENCIL;
          case WebGL2RenderingContext.R8:
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.RED;
        }
      }
      function Y_(r) {
        switch (r) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.UNSIGNED_SHORT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.UNSIGNED_INT_24_8;
          case WebGL2RenderingContext.R8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.FLOAT;
        }
      }
      class K_ {
        constructor(e, n, o, u) {
          this.context = e, this.format = o, this.useMipmap = u && u.useMipmap, this.texture = e.gl.createTexture(), this.update(n, { premultiply: u && u.premultiply });
        }
        update(e, n) {
          const o = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width, u = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, { context: l } = this, { gl: f } = l, { x: v, y: S } = n && n.position ? n.position : { x: 0, y: 0 }, D = v + o, x = S + u;
          !this.size || this.size[0] === D && this.size[1] === x || (f.bindTexture(f.TEXTURE_2D, null), f.deleteTexture(this.texture), this.texture = f.createTexture(), this.size = null), f.bindTexture(f.TEXTURE_2D, this.texture), l.pixelStoreUnpackFlipY.set(!1), l.pixelStoreUnpack.set(1), l.pixelStoreUnpackPremultiplyAlpha.set(this.format === f.RGBA8 && (!n || n.premultiply !== !1));
          const A = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
          if (!this.size && D > 0 && x > 0) {
            const I = this.useMipmap ? Math.floor(Math.log2(Math.max(D, x))) + 1 : 1;
            f.texStorage2D(f.TEXTURE_2D, I, this.format, D, x), this.size = [D, x];
          }
          if (this.size)
            if (A)
              f.texSubImage2D(f.TEXTURE_2D, 0, v, S, X_(this.format), Y_(this.format), e);
            else {
              const I = e.data;
              I && f.texSubImage2D(f.TEXTURE_2D, 0, v, S, o, u, X_(this.format), Y_(this.format), I);
            }
          this.useMipmap && f.generateMipmap(f.TEXTURE_2D);
        }
        bind(e, n, o = !1) {
          const { context: u } = this, { gl: l } = u;
          l.bindTexture(l.TEXTURE_2D, this.texture), e !== this.minFilter && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, e), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, this.useMipmap && !o ? e === l.NEAREST ? l.NEAREST_MIPMAP_NEAREST : l.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), n !== this.wrapS && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, n), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, n), this.wrapS = n);
        }
        bindExtraParam(e, n, o, u) {
          const { context: l } = this, { gl: f } = l;
          f.bindTexture(f.TEXTURE_2D, this.texture), n !== this.magFilter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, n), this.magFilter = n), e !== this.minFilter && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, this.useMipmap ? e === f.NEAREST ? f.NEAREST_MIPMAP_NEAREST : f.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), o !== this.wrapS && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, o), this.wrapS = o), u !== this.wrapT && (f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, u), this.wrapT = u);
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      class Wp {
        constructor(e, n) {
          this.context = e, this.texture = n;
        }
        bind(e, n) {
          const { context: o } = this, { gl: u } = o;
          u.bindTexture(u.TEXTURE_2D, this.texture), e !== this.minFilter && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, e), this.minFilter = e), n !== this.wrapS && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, n), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, n), this.wrapS = n);
        }
      }
      function $p(r, e, n, o, u, l, f, v) {
        const S = [r, e, 1, n, o, 1, u, l, 1], D = [f, v, 1], x = De.mat3.adjoint([], S), [A, I, M] = De.vec3.transformMat3(D, D, x);
        return De.mat3.multiply(S, S, [A, 0, 0, 0, I, 0, 0, 0, M]);
      }
      function wx(r, e, n, o, u, l, f, v) {
        const S = function(D, x, A, I, M, C, k, V) {
          const U = $p(0, 0, 1, 0, 1, 1, 0, 1), q = $p(D, x, A, I, M, C, k, V), $ = De.mat3.adjoint([], U);
          return De.mat3.multiply(q, q, $);
        }(r, e, n, o, u, l, f, v);
        return [S[2] / S[8] / Tt, S[5] / S[8] / Tt];
      }
      function Xp(r) {
        return [r[0], Math.min(Math.max(r[1], -Un), Un)];
      }
      class Tx extends Zo {
        constructor(e, n, o, u) {
          super(), this.id = e, this.dispatcher = o, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(u), this.options = n, this._dirty = !1;
        }
        load(e, n) {
          if (this._loaded = n || !1, this.fire(new Pr("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
            return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading();
          this._imageRequest = Hn(this.map._requestManager.transformRequest(this.url, Uo.Image), (o, u) => {
            this._imageRequest = null, this._loaded = !0, o ? this.fire(new Cr(o)) : u && (this.image = u instanceof HTMLImageElement ? Ct.getImageData(u) : u, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e) {
          return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
        }
        setTexture(e) {
          if (!(e.handle instanceof WebGLTexture))
            throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new Wp(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new Pr("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove(e) {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Wp || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
        }
        setCoordinates(e) {
          if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length)
            return this;
          this.onNorthPole = !1, this.onSouthPole = !1;
          let n = e[0][1], o = e[0][1];
          for (const l of e)
            l[1] > o && (o = l[1]), l[1] < n && (n = l[1]);
          const u = (o + n) / 2;
          if (u > Un ? this.onNorthPole = !0 : u < -Un && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
            const l = e.map(h.fromLngLat);
            this.tileID = function(f) {
              let v = 1 / 0, S = 1 / 0, D = -1 / 0, x = -1 / 0;
              for (const k of f)
                v = Math.min(v, k.x), S = Math.min(S, k.y), D = Math.max(D, k.x), x = Math.max(x, k.y);
              const A = Math.max(D - v, x - S), I = Math.max(0, Math.floor(-Math.log(A) / Math.LN2)), M = Math.pow(2, I);
              let C = Math.floor((v + D) / 2 * M);
              return C > 1 && (C -= 1), new nt(I, C, Math.floor((S + x) / 2 * M));
            }(l), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new Pr("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0, this._unsupportedCoords = !1;
        }
        _prepareData(e) {
          for (const U in this.tiles) {
            const q = this.tiles[U];
            q.state !== "loaded" && (q.state = "loaded", q.texture = this.texture);
          }
          if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
            return;
          const n = Qd(new nt(0, 0, 0), this.map.transform.projection), o = [n.projection.project(this.coordinates[0][0], this.coordinates[0][1]), n.projection.project(this.coordinates[1][0], this.coordinates[1][1]), n.projection.project(this.coordinates[2][0], this.coordinates[2][1]), n.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
          if (!function(U) {
            const q = U[1].x - U[0].x, $ = U[1].y - U[0].y, H = U[2].x - U[1].x, K = U[2].y - U[1].y, Q = U[3].x - U[2].x, ie = U[3].y - U[2].y, fe = U[0].x - U[3].x, de = U[0].y - U[3].y, ue = q * K - H * $, Se = H * ie - Q * K, me = Q * de - fe * ie, Ee = fe * $ - q * de;
            return ue > 0 && Se > 0 && me > 0 && Ee > 0 || ue < 0 && Se < 0 && me < 0 && Ee < 0;
          }(o))
            return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
          const u = Qd(this.tileID, this.map.transform.projection), [l, f, v, S] = this.coordinates.map((U) => {
            const q = u.projection.project(U[0], U[1]);
            return cx(u, q)._round();
          });
          this.perspectiveTransform = wx(l.x, l.y, f.x, f.y, v.x, v.y, S.x, S.y);
          const D = this._boundsArray = new $a();
          D.emplaceBack(l.x, l.y, 0, 0), D.emplaceBack(f.x, f.y, Tt, 0), D.emplaceBack(S.x, S.y, 0, Tt), D.emplaceBack(v.x, v.y, Tt, Tt), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(D, $_.members), this.boundsSegments = Wn.simpleSegment(0, 0, 4, 2);
          const x = [], A = [Xp((I = this.coordinates)[0]), Xp(I[1]), Xp(I[2]), Xp(I[3])];
          var I;
          const [M, C, k, V] = function(U) {
            let q = U[0][0], $ = q, H = U[0][1], K = H;
            for (let Q = 1; Q < U.length; Q++)
              U[Q][0] < q ? q = U[Q][0] : U[Q][0] > $ && ($ = U[Q][0]), U[Q][1] < H ? H = U[Q][1] : U[Q][1] > K && (K = U[Q][1]);
            return [q, H, $ - q, K - H];
          }(A);
          {
            const U = new $a(), [q, $, H, K] = function(Ve) {
              let Ue = Ve[0].x, Fe = Ue, et = Ve[0].y, dt = et;
              for (let tt = 1; tt < Ve.length; tt++)
                Ve[tt].x < Ue ? Ue = Ve[tt].x : Ve[tt].x > Fe && (Fe = Ve[tt].x), Ve[tt].y < et ? et = Ve[tt].y : Ve[tt].y > dt && (dt = Ve[tt].y);
              return [Ue, et, Fe - Ue, dt - et];
            }(o), Q = (Ve) => [(Ve.x - q) / H, (Ve.y - $) / K], [ie, fe, de, ue] = o.map(Q), Se = function(Ve, Ue, Fe, et, dt, tt, Mt, wt) {
              const Pt = $p(0, 0, 1, 0, 1, 1, 0, 1), rt = $p(Ve, Ue, Fe, et, dt, tt, Mt, wt), Ut = De.mat3.adjoint([], rt);
              return De.mat3.multiply(Pt, Pt, Ut);
            }(ie[0], ie[1], fe[0], fe[1], de[0], de[1], ue[0], ue[1]);
            this.elevatedGlobePerspectiveTransform = wx(ie[0], ie[1], fe[0], fe[1], de[0], de[1], ue[0], ue[1]);
            const me = (Ve, Ue) => {
              x.push(Ve.lng);
              const Fe = Math.round((Ve.lng - M) / k * Tt), et = Math.round((Ve.lat - C) / V * Tt), dt = Q(Ue), tt = De.vec3.transformMat3([], [dt[0], dt[1], 1], Se), Mt = Math.round(tt[0] / tt[2] * Tt), wt = Math.round(tt[1] / tt[2] * Tt);
              U.emplaceBack(Fe, et, Mt, wt);
            }, Ee = o[3].x - o[0].x, ze = o[3].y - o[0].y, Ie = o[2].x - o[1].x, Re = o[2].y - o[1].y;
            for (let Ve = 0; Ve < 65; Ve++) {
              const Ue = Ve / 64, Fe = [o[0].x + Ue * Ee, o[0].y + Ue * ze], et = [o[1].x + Ue * Ie, o[1].y + Ue * Re], dt = et[0] - Fe[0], tt = et[1] - Fe[1];
              for (let Mt = 0; Mt < 65; Mt++) {
                const wt = Mt / 64, Pt = { x: Fe[0] + dt * wt, y: Fe[1] + tt * wt, z: 0 };
                me(n.projection.unproject(Pt.x, Pt.y), Pt);
              }
            }
            this.elevatedGlobeVertexBuffer = e.createVertexBuffer(U, $_.members);
          }
          {
            this.maxLongitudeTriangleSize = 0;
            let U = [], q = new qs();
            const $ = (H, K, Q) => {
              q.emplaceBack(H, K, Q);
              const ie = x[H], fe = x[K], de = x[Q], ue = Math.min(Math.min(ie, fe), de), Se = Math.max(Math.max(ie, fe), de) - ue;
              Se > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = Se), U.push(ue + Se / 2);
            };
            for (let H = 0; H < 64; H++)
              for (let K = 0; K < 64; K++) {
                const Q = 65 * H + K, ie = Q + 1, fe = Q + 65, de = fe + 1;
                $(Q, fe, ie), $(ie, fe, de);
              }
            [U, q] = function(H, K) {
              const Q = Array.from({ length: H.length }, (de, ue) => ue);
              Q.sort((de, ue) => H[de] - H[ue]);
              const ie = [], fe = new qs();
              for (let de = 0; de < Q.length; de++) {
                const ue = Q[de];
                ie.push(H[ue]);
                const Se = 3 * ue, me = Se + 1;
                fe.emplaceBack(K.uint16[Se], K.uint16[me], K.uint16[me + 1]);
              }
              return [ie, fe];
            }(U, q), this.elevatedGlobeTrianglesCenterLongitudes = U, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(q);
          }
          this.elevatedGlobeSegments = Wn.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, k / Tt, 0, V / Tt, 0, 0, C, M, 0]);
        }
        prepare() {
          const e = Object.keys(this.tiles).length !== 0;
          if (this.tileID && !e)
            return;
          const n = this.map.painter.context, o = n.gl;
          !this._dirty || this.texture instanceof Wp || (this.texture ? this.texture.update(this.image) : (this.texture = new K_(n, this.image, o.RGBA8), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(n);
        }
        loadTile(e, n) {
          this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, n(null)) : (e.state = "errored", n(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
        getSegmentsForLongitude(e) {
          const n = this.elevatedGlobeSegments;
          if (!this.elevatedGlobeTrianglesCenterLongitudes || !n)
            return null;
          const o = this.elevatedGlobeTrianglesCenterLongitudes;
          let u = (l = e + 180) + 360 * Math.round((o[0] - l) / 360);
          var l;
          const f = new Wn(), v = (A, I) => {
            f.segments.push({ vertexOffset: 0, primitiveOffset: A, vertexLength: n.segments[0].vertexLength, primitiveLength: I, sortKey: void 0, vaos: {} });
          }, S = 0.51 * this.maxLongitudeTriangleSize;
          if (Math.abs(o[0] - u) <= S) {
            const A = Ke(o, 0, o.length, u + S);
            return A === o.length || v(A, Vo(o, A + 1, o.length, u + 360 - S) - A), f;
          }
          u < o[0] && (u += 360);
          const D = Vo(o, 0, o.length, u - S);
          if (D === o.length)
            return v(0, o.length), f;
          v(0, D - 0);
          const x = Ke(o, D + 1, o.length, u + S);
          return x !== o.length && v(x, o.length - x), f;
        }
      }
      const JT = (Math.pow(256, 2) - 1) / 16907520;
      class Mx extends wr {
        constructor(e, n, o, u) {
          super(e, { layout: vx || (vx = new Bn({ visibility: new yt($e.layout_raster.visibility) })), paint: bx || (bx = new Bn({ "raster-opacity": new yt($e.paint_raster["raster-opacity"]), "raster-color": new Wa($e.paint_raster["raster-color"]), "raster-color-mix": new yt($e.paint_raster["raster-color-mix"]), "raster-color-range": new yt($e.paint_raster["raster-color-range"]), "raster-hue-rotate": new yt($e.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new yt($e.paint_raster["raster-brightness-min"]), "raster-brightness-max": new yt($e.paint_raster["raster-brightness-max"]), "raster-saturation": new yt($e.paint_raster["raster-saturation"]), "raster-contrast": new yt($e.paint_raster["raster-contrast"]), "raster-resampling": new yt($e.paint_raster["raster-resampling"]), "raster-fade-duration": new yt($e.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new yt($e.paint_raster["raster-emissive-strength"]), "raster-array-band": new yt($e.paint_raster["raster-array-band"]), "raster-elevation": new yt($e.paint_raster["raster-elevation"]), "raster-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, n, o, u), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        tileCoverLift() {
          return this.paint.get("raster-elevation");
        }
        isDraped(e) {
          return !(e && e._source instanceof Tx && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0;
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
        }
        updateColorRamp(e) {
          if (!this.hasColorMap() || !this._curRampRange)
            return;
          const n = this._transitionablePaint._values["raster-color"].value.expression, [o, u] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
          isNaN(o) && isNaN(u) || o === this._curRampRange[0] && u === this._curRampRange[1] || (this.colorRamp = Bd({ expression: n, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: o, end: u }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [o, u]);
        }
      }
      let Sx, Ex, Ax, Px, Cx;
      class Ix extends wr {
        constructor(e, n, o, u) {
          super(e, { layout: Sx || (Sx = new Bn({ visibility: new yt($e["layout_raster-particle"].visibility) })), paint: Ex || (Ex = new Bn({ "raster-particle-array-band": new yt($e["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new yt($e["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Wa($e["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new yt($e["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new yt($e["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new yt($e["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new yt($e["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new yt($e["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, n, o, u), this._updateColorRamp(), this.lastInvalidatedAt = Ct.now();
        }
        onRemove(e) {
          this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-particle-color"].value.value;
        }
        getProgramIds() {
          return ["rasterParticle"];
        }
        hasOffscreenPass() {
          return this.visibility !== "none";
        }
        isDraped(e) {
          return !1;
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState();
        }
        _updateColorRamp() {
          if (!this.hasColorMap())
            return;
          const e = this._transitionablePaint._values["raster-particle-color"].value.expression, n = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = Bd({ expression: e, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: n }], resolution: 256 }), this.colorRampTexture = null;
        }
        _invalidateAnimationState() {
          this.lastInvalidatedAt = Ct.now();
        }
        tileCoverLift() {
          return this.paint.get("raster-particle-elevation");
        }
      }
      class QT extends wr {
        constructor(e, n) {
          super(e, {}, n, null), this.implementation = e, e.slot && (this.slot = e.slot);
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        isDraped(e) {
          return this.implementation.renderToTile !== void 0;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
        }
        onAdd(e) {
          this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
        }
        onRemove(e) {
          this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
        }
      }
      function J_(r, e, n) {
        const o = [0, 0, 1], u = De.quat.identity([]);
        return De.quat.rotateY(u, u, n ? -vi(r) + Math.PI : vi(r)), De.quat.rotateX(u, u, -vi(e)), De.vec3.transformQuat(o, o, u), De.vec3.normalize(o, o);
      }
      function Lx(r, e) {
        const n = Yp(r.projection, r.zoom, r.width, r.height), o = function(l, f, v, S, D) {
          const x = new Ui(v.lng - 180 * wc, v.lat), A = new Ui(v.lng + 180 * wc, v.lat), I = l.project(x.lng, x.lat), M = l.project(A.lng, A.lat), C = -Math.atan2(M.y - I.y, M.x - I.x), k = h.fromLngLat(v);
          k.y = si(k.y, -1 + wc, 1 - wc);
          const V = k.toLngLat(), U = l.project(V.lng, V.lat), q = h.fromLngLat(V);
          q.x += wc;
          const $ = q.toLngLat(), H = l.project($.lng, $.lat), K = Dx(H.x - U.x, H.y - U.y, C), Q = h.fromLngLat(V);
          Q.y += wc;
          const ie = Q.toLngLat(), fe = l.project(ie.lng, ie.lat), de = Dx(fe.x - U.x, fe.y - U.y, C), ue = Math.abs(K.x) / Math.abs(de.y), Se = De.mat4.identity([]);
          De.mat4.rotateZ(Se, Se, -C * (1 - (D ? 0 : S)));
          const me = De.mat4.identity([]);
          return De.mat4.scale(me, me, [1, 1 - (1 - ue) * S, 1]), me[4] = -de.x / de.y * S, De.mat4.rotateZ(me, me, C), De.mat4.multiply(me, Se, me), me;
        }(r.projection, 0, r.center, n, e), u = zx(r);
        return De.mat4.scale(o, o, [u, u, 1]), o;
      }
      function zx(r) {
        const e = r.projection, n = Yp(r.projection, r.zoom, r.width, r.height), o = Q_(e, r.center), u = Q_(e, Ui.convert(e.center));
        return Math.pow(2, o * n + (1 - n) * u);
      }
      function Yp(r, e, n, o, u = 1 / 0) {
        const l = r.range;
        if (!l)
          return 0;
        const f = Math.min(u, Math.max(n, o)), v = Math.log(f / 1024) / Math.LN2;
        return fs(l[0] + v, l[1] + v, e);
      }
      const wc = 1 / 4e4;
      function Q_(r, e) {
        const n = si(e.lat, -Un, Un), o = new Ui(e.lng - 180 * wc, n), u = new Ui(e.lng + 180 * wc, n), l = r.project(o.lng, n), f = r.project(u.lng, n), v = h.fromLngLat(o), S = h.fromLngLat(u), D = f.x - l.x, x = f.y - l.y, A = S.x - v.x, I = S.y - v.y, M = Math.sqrt((A * A + I * I) / (D * D + x * x));
        return Math.log(M) / Math.LN2;
      }
      function Dx(r, e, n) {
        const o = Math.cos(n), u = Math.sin(n);
        return { x: r * o - e * u, y: r * u + e * o };
      }
      function kx(r, e, n) {
        De.mat4.identity(r), De.mat4.rotateZ(r, r, vi(e[2])), De.mat4.rotateX(r, r, vi(e[0])), De.mat4.rotateY(r, r, vi(e[1])), De.mat4.scale(r, r, n), De.mat4.multiply(r, r, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function Kp(r, e, n, o, u, l, f, v) {
        const S = [n[0] - e[0], n[1] - e[1], 0], D = [o[0] - e[0], o[1] - e[1], 0];
        if (De.vec3.length(S) < 1e-12 || De.vec3.length(D) < 1e-12)
          return De.quat.identity(r);
        const x = De.vec3.cross([], S, D);
        De.vec3.normalize(x, x), De.vec3.subtract(D, o, e), S[2] = (l - u) * v, D[2] = (f - u) * v;
        const A = S;
        return De.vec3.cross(A, S, D), De.vec3.normalize(A, A), De.quat.rotationTo(r, x, A);
      }
      function eg(r, e, n = !1) {
        const o = mr(e.zoom), u = function(l, f, v) {
          const S = f.worldSize, D = [l[12], l[13], l[14]], x = Os(D[1] / S), A = Fr(D[0] / S), I = De.mat4.identity([]), M = fr(1, x) * S, C = fr(1, 0) * S * c(x, f.zoom), k = 1 / eo(S);
          let V = C * k;
          if (v) {
            const H = Yp(f.projection, f.zoom, f.width, f.height, 1024);
            V = k * f.projection.pixelSpaceConversion(f.center.lat, S, H);
          }
          const U = el(x, A);
          De.vec3.add(U, U, De.vec3.scale([], De.vec3.normalize([], U), M * V * D[2]));
          const q = function(H) {
            const K = [H[0], H[1], H[2]];
            let Q = [0, 1, 0];
            const ie = De.vec3.cross([], Q, K);
            return De.vec3.cross(Q, K, ie), De.vec3.squaredLength(Q) === 0 && (Q = [0, 1, 0], De.vec3.cross(ie, K, Q)), De.vec3.normalize(ie, ie), De.vec3.normalize(Q, Q), De.vec3.normalize(K, K), [ie[0], ie[1], ie[2], 0, Q[0], Q[1], Q[2], 0, K[0], K[1], K[2], 0, H[0], H[1], H[2], 1];
          }(U);
          De.mat4.scale(I, I, [V, V, V * M]), De.mat4.translate(I, I, [-D[0], -D[1], -D[2]]);
          const $ = De.mat4.multiply([], f.globeMatrix, q);
          return De.mat4.multiply($, $, I), De.mat4.multiply($, $, l), $;
        }(r, e, n);
        if (o > 0) {
          const l = function(f, v) {
            const S = v.worldSize, D = fr(1, 0) * S * c(v.center.lat, v.zoom) / eo(S), x = fr(1, v.center.lat) * S, A = De.mat4.identity([]);
            return De.mat4.rotateY(A, A, vi(v.center.lng)), De.mat4.rotateX(A, A, vi(v.center.lat)), De.mat4.translate(A, A, [0, 0, dr]), De.mat4.scale(A, A, [D, D, D * x]), De.mat4.translate(A, A, [v.point.x - 0.5 * S, v.point.y - 0.5 * S, 0]), De.mat4.multiply(A, A, f), De.mat4.multiply(A, v.globeMatrix, A);
          }(r, e);
          return function(f, v, S) {
            const D = (C, k, V) => {
              const U = De.vec3.length(C), q = De.vec3.length(k), $ = As(C, k, V);
              return De.vec3.scale($, $, 1 / De.vec3.length($) * ei(U, q, V));
            }, x = D([f[0], f[1], f[2]], [v[0], v[1], v[2]], S), A = D([f[4], f[5], f[6]], [v[4], v[5], v[6]], S), I = D([f[8], f[9], f[10]], [v[8], v[9], v[10]], S), M = As([f[12], f[13], f[14]], [v[12], v[13], v[14]], S);
            return [x[0], x[1], x[2], 0, A[0], A[1], A[2], 0, I[0], I[1], I[2], 0, M[0], M[1], M[2], 1];
          }(u, l, o);
        }
        return u;
      }
      function Rx(r, e, n, o) {
        const u = Jt.projectAabbCorners(o, n);
        let l = Number.MAX_VALUE, f = -1;
        for (let D = 0; D < u.length; ++D) {
          const x = u[D];
          x[0] = (0.5 * x[0] + 0.5) * e.width, x[1] = (0.5 - 0.5 * x[1]) * e.height, x[2] < l && (f = D, l = x[2]);
        }
        const v = (D) => new Et(u[D][0], u[D][1]);
        let S;
        switch (f) {
          case 0:
          case 6:
            S = [v(1), v(5), v(4), v(7), v(3), v(2), v(1)];
            break;
          case 1:
          case 7:
            S = [v(0), v(4), v(5), v(6), v(2), v(3), v(0)];
            break;
          case 3:
          case 5:
            S = [v(1), v(0), v(4), v(7), v(6), v(2), v(1)];
            break;
          default:
            S = [v(1), v(5), v(6), v(7), v(3), v(0), v(1)];
        }
        if (se(r, S))
          return l;
      }
      const e2 = qi([{ name: "a_pos_3f", components: 3, type: "Float32" }]), t2 = qi([{ name: "a_color_3f", components: 3, type: "Float32" }]), i2 = qi([{ name: "a_color_4f", components: 4, type: "Float32" }]), n2 = qi([{ name: "a_uv_2f", components: 2, type: "Float32" }]), s2 = qi([{ name: "a_normal_3f", components: 3, type: "Float32" }]), r2 = qi([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), o2 = qi([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), Ox = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
      class Jp {
        constructor(e, n, o, u) {
          this.message = (e ? `${e}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function Fx(r, e) {
        const n = r.indexOf("://") === -1;
        try {
          return new URL(r, n && e ? "http://example.com" : void 0), !0;
        } catch {
          return !1;
        }
      }
      class Bx {
        constructor(e, n) {
          this.feature = e, this.instancedDataOffset = n, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class Nx {
        constructor() {
          this.instancedDataArray = new Ld(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class tg {
        constructor(e) {
          this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.projection = e.projection, this.index = e.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.tileToMeter = s(o);
          const l = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: f, id: v, index: S, sourceLayerIndex: D } of e) {
            const x = v ?? (f.properties && f.properties.hasOwnProperty("id") ? f.properties.id : void 0), A = Z(f, l);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), A, o))
              continue;
            const I = { id: x, sourceLayerIndex: D, index: S, geometry: l ? A.geometry : G(f, o, u), properties: f.properties, type: f.type, patterns: {} }, M = this.addFeature(I, I.geometry, A);
            M && n.featureIndex.insert(f, I.geometry, S, D, this.index, this.instancesPerModel[M].instancedDataArray.length, Tt / 32);
          }
          this.lookup = null;
        }
        update(e, n, o, u) {
          for (const l in this.instancesPerModel) {
            const f = this.instancesPerModel[l];
            for (const v in e)
              f.idToFeaturesIndex.hasOwnProperty(v) && (this.evaluate(f.features[f.idToFeaturesIndex[v]], e[v], f, !0), this.uploaded = !1);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties)
            return !1;
          let e = !1;
          for (const n in this.instancesPerModel) {
            const o = this.instancesPerModel[n];
            for (const u of o.features) {
              const l = this.layers[0], f = u.feature, v = this.canonical, S = l.paint.get("model-rotation").evaluate(f, {}, v), D = l.paint.get("model-scale").evaluate(f, {}, v), x = l.paint.get("model-translation").evaluate(f, {}, v);
              De.vec3.exactEquals(u.rotation, S) && De.vec3.exactEquals(u.scale, D) && De.vec3.exactEquals(u.translation, x) || (this.evaluate(u, u.featureStates, o, !0), e = !0);
            }
          }
          return e;
        }
        updateReplacement(e, n, o, u) {
          if (n.updateTime === this.replacementUpdateTime)
            return !1;
          this.replacementUpdateTime = n.updateTime;
          const l = n.getReplacementRegionsForTile(e.toUnwrapped(), !0);
          if (E_(this.activeReplacements, l))
            return !1;
          this.activeReplacements = l;
          let f = !1;
          for (const v in this.instancesPerModel) {
            const S = this.instancesPerModel[v], D = S.instancedDataArray;
            for (const x of S.features) {
              const A = x.instancedDataOffset, I = x.instancedDataCount;
              for (let M = 0; M < I; M++) {
                const C = 16 * (M + A);
                let k = D.float32[C + 0];
                const V = k > Tt;
                k = V ? k - Tt : k;
                const U = Math.floor(k), q = D.float32[C + 1];
                let $ = !1;
                for (const H of this.activeReplacements)
                  if (!Qy(H, o, Ox.Model, u) && !(H.min.x > U || U > H.max.x || H.min.y > q || q > H.max.y) && ($ = r0(s0(U, q, e.canonical, H.footprintTileId.canonical), H.footprint), $))
                    break;
                D.float32[C] = $ ? k + Tt : k, f = f || $ !== V;
              }
            }
          }
          return f;
        }
        isEmpty() {
          for (const e in this.instancesPerModel)
            if (this.instancesPerModel[e].instancedDataArray.length !== 0)
              return !1;
          return !0;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(e) {
          if (!this.uploaded)
            for (const n in this.instancesPerModel) {
              const o = this.instancesPerModel[n];
              o.instancedDataArray.length < 0 || o.instancedDataArray.length === 0 || (o.instancedDataBuffer ? o.instancedDataBuffer.updateData(o.instancedDataArray) : o.instancedDataBuffer = e.createVertexBuffer(o.instancedDataArray, r2.members, !0, void 0, this.instanceCount));
            }
          this.uploaded = !0;
        }
        destroy() {
          for (const n in this.instancesPerModel) {
            const o = this.instancesPerModel[n];
            o.instancedDataArray.length !== 0 && o.instancedDataBuffer && o.instancedDataBuffer.destroy();
          }
          const e = this.layers[0].modelManager;
          if (e && this.modelUris)
            for (const n of this.modelUris)
              e.removeModel(n, "");
        }
        addFeature(e, n, o) {
          const u = this.layers[0], l = u.layout.get("model-id").evaluate(o, {}, this.canonical);
          if (!l)
            return mi(`modelId is not evaluated for layer ${u.id} and it is not going to get rendered.`), l;
          Fx(l, !1) && (this.modelUris.includes(l) || this.modelUris.push(l)), this.instancesPerModel[l] || (this.instancesPerModel[l] = new Nx());
          const f = this.instancesPerModel[l], v = f.instancedDataArray, S = new Bx(o, v.length);
          for (const D of n)
            for (const x of D) {
              if (x.x < 0 || x.x >= Tt || x.y < 0 || x.y >= Tt)
                continue;
              const A = (this.lookupDim - 1) / Tt, I = this.lookupDim * (x.y * A | 0) + x.x * A | 0;
              if (this.lookup) {
                if (this.lookup[I] !== 0)
                  continue;
                this.lookup[I] = 1;
              }
              this.instanceCount++;
              const M = v.length;
              v.resize(M + 1), f.instancesEvaluatedElevation.push(0), v.float32[16 * M] = x.x, v.float32[16 * M + 1] = x.y;
            }
          return S.instancedDataCount = f.instancedDataArray.length - S.instancedDataOffset, S.instancedDataCount > 0 && (e.id && (f.idToFeaturesIndex[e.id] = f.features.length), f.features.push(S), this.evaluate(S, {}, f, !1)), l;
        }
        getModelUris() {
          return this.modelUris;
        }
        evaluate(e, n, o, u) {
          const l = this.layers[0], f = e.feature, v = this.canonical, S = e.rotation = l.paint.get("model-rotation").evaluate(f, n, v), D = e.scale = l.paint.get("model-scale").evaluate(f, n, v), x = e.translation = l.paint.get("model-translation").evaluate(f, n, v), A = l.paint.get("model-color").evaluate(f, n, v);
          A.a = l.paint.get("model-color-mix-intensity").evaluate(f, n, v);
          const I = [];
          this.maxVerticalOffset < x[2] && (this.maxVerticalOffset = x[2]), this.maxScale = Math.max(Math.max(this.maxScale, D[0]), Math.max(D[1], D[2])), kx(I, S, D);
          const M = Math.round(100 * A.a) + A.b / 1.05;
          for (let C = 0; C < e.instancedDataCount; ++C) {
            const k = e.instancedDataOffset + C, V = 16 * k, U = o.instancedDataArray.float32;
            let q = 0;
            u && (q = U[V + 6] - o.instancesEvaluatedElevation[k]);
            const $ = 0 | U[V + 1];
            U[V] = (0 | U[V]) + A.r / 1.05, U[V + 1] = $ + A.g / 1.05, U[V + 2] = M, U[V + 3] = 1 / (v.z > 10 ? this.tileToMeter : s(v, $)), U[V + 4] = x[0], U[V + 5] = x[1], U[V + 6] = x[2] + q, U[V + 7] = I[0], U[V + 8] = I[1], U[V + 9] = I[2], U[V + 10] = I[4], U[V + 11] = I[5], U[V + 12] = I[6], U[V + 13] = I[8], U[V + 14] = I[9], U[V + 15] = I[10], o.instancesEvaluatedElevation[k] = x[2];
          }
        }
      }
      let Vx, Ux;
      Ft(tg, "ModelBucket", { omit: ["layers"] }), Ft(Nx, "PerModelAttributes"), Ft(Bx, "ModelFeature");
      const bh = 64, Ou = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
      function jx(r, e, n, o, u, l, f, v, S, D = !1) {
        const x = n.zoom, A = n.project(o), I = c(o.lat, x), M = 1 / I;
        De.mat4.identity(r), De.mat4.translate(r, r, [A.x + f[0] * M, A.y + f[1] * M, f[2]]);
        let C = 1, k = 1;
        const V = n.worldSize;
        if (D) {
          if (n.projection.name === "mercator") {
            let H = 0;
            n.elevation && (H = n.elevation.getAtPointOrZero(new h(A.x / V, A.y / V), 0));
            const K = De.vec4.transformMat4([], [A.x, A.y, H, 1], n.projMatrix)[3] / n.cameraToCenterDistance;
            C = K, k = K * c(n.center.lat, x);
          } else if (n.projection.name === "globe") {
            const H = eg(r, n), K = De.mat4.multiply([], n.projMatrix, H), Q = [0, 0, 0, 1];
            De.vec4.transformMat4(Q, Q, K);
            const ie = Q[3] / n.cameraToCenterDistance, fe = mr(x), de = n.projection.pixelsPerMeter(o.lat, V) * c(o.lat, x), ue = n.projection.pixelsPerMeter(n.center.lat, V) * c(n.center.lat, x);
            C = ie / ei(de, p_(n.center.lat), fe), k = ie * I / de, C *= ue, k *= ue;
          }
        } else
          C = M;
        De.mat4.scale(r, r, [C, C, k]);
        const U = [...r], q = e.orientation, $ = [];
        if (kx($, [q[0] + u[0], q[1] + u[1], q[2] + u[2]], l), De.mat4.multiply(r, U, $), v && n.elevation) {
          let H = 0;
          const K = [];
          if (S && n.elevation) {
            H = function(fe, de, ue, Se, me) {
              const Ee = de.elevation;
              if (!Ee)
                return 0;
              const ze = Jt.projectAabbCorners(ue, Se), Ie = fr(1, me.lat) * de.worldSize, Re = function(Ut, St) {
                const Nt = [0, 0, 1], Qt = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                for (const pi of Qt) {
                  const gi = Ut[pi.corners[0]], Pi = Ut[pi.corners[1]], yi = Ut[pi.corners[2]], Ii = [Pi[0] - gi[0], Pi[1] - gi[1], St * (Pi[2] - gi[2])], fn = De.vec3.cross(Ii, Ii, [yi[0] - gi[0], yi[1] - gi[1], St * (yi[2] - gi[2])]);
                  De.vec3.normalize(fn, fn), pi.dotProductWithUp = De.vec3.dot(fn, Nt);
                }
                return Qt.sort((pi, gi) => pi.dotProductWithUp - gi.dotProductWithUp), Qt[0].corners;
              }(ze, Ie), Ve = ze[Re[0]], Ue = ze[Re[1]], Fe = ze[Re[2]], et = ze[Re[3]], dt = Ee.getAtPointOrZero(new h(Ve[0] / de.worldSize, Ve[1] / de.worldSize), 0), tt = Ee.getAtPointOrZero(new h(Ue[0] / de.worldSize, Ue[1] / de.worldSize), 0), Mt = Ee.getAtPointOrZero(new h(Fe[0] / de.worldSize, Fe[1] / de.worldSize), 0), wt = Ee.getAtPointOrZero(new h(et[0] / de.worldSize, et[1] / de.worldSize), 0), Pt = (dt + wt) / 2, rt = (tt + Mt) / 2;
              return Pt > rt ? tt < Mt ? Kp(fe, Ue, et, Ve, tt, wt, dt, Ie) : Kp(fe, Fe, Ve, et, Mt, dt, wt, Ie) : dt < wt ? Kp(fe, Ve, Ue, Fe, dt, tt, Mt, Ie) : Kp(fe, et, Fe, Ue, wt, Mt, tt, Ie), Math.max(Pt, rt);
            }(K, n, e.aabb, r, o);
            const Q = De.mat4.fromQuat([], K), ie = De.mat4.multiply([], Q, $);
            De.mat4.multiply(r, U, ie);
          } else
            H = n.elevation.getAtPointOrZero(new h(A.x / V, A.y / V), 0);
          H !== 0 && (r[14] += H);
        }
      }
      function rf(r, e, n = !1) {
        r.uploaded || (r.gfxTexture = new K_(e, r.image, n ? e.gl.R8 : e.gl.RGBA8, { useMipmap: r.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST }), r.uploaded = !0, r.image = null);
      }
      function a2(r, e, n) {
        r.indexBuffer = e.createIndexBuffer(r.indexArray, !1, !0), r.vertexBuffer = e.createVertexBuffer(r.vertexArray, e2.members, !1, !0), r.normalArray && (r.normalBuffer = e.createVertexBuffer(r.normalArray, s2.members, !1, !0)), r.texcoordArray && (r.texcoordBuffer = e.createVertexBuffer(r.texcoordArray, n2.members, !1, !0)), r.colorArray && (r.colorBuffer = e.createVertexBuffer(r.colorArray, (r.colorArray.bytesPerElement === 12 ? t2 : i2).members, !1, !0)), r.featureArray && (r.pbrBuffer = e.createVertexBuffer(r.featureArray, o2.members, !0)), r.segments = Wn.simpleSegment(0, 0, r.vertexArray.length, r.indexArray.length);
        const o = r.material;
        o.pbrMetallicRoughness.baseColorTexture && rf(o.pbrMetallicRoughness.baseColorTexture, e), o.pbrMetallicRoughness.metallicRoughnessTexture && rf(o.pbrMetallicRoughness.metallicRoughnessTexture, e), o.normalTexture && rf(o.normalTexture, e), o.occlusionTexture && rf(o.occlusionTexture, e, n), o.emissionTexture && rf(o.emissionTexture, e);
      }
      function ig(r, e, n) {
        if (r.meshes)
          for (const o of r.meshes)
            a2(o, e, n);
        if (r.children)
          for (const o of r.children)
            ig(o, e, n);
      }
      function Qp(r) {
        if (r.meshes)
          for (const e of r.meshes)
            e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
        if (r.children)
          for (const e of r.children)
            Qp(e);
      }
      function ng(r) {
        if (r.meshes)
          for (const n of r.meshes)
            n.vertexBuffer && (n.vertexBuffer.destroy(), n.indexBuffer.destroy(), n.normalBuffer && n.normalBuffer.destroy(), n.texcoordBuffer && n.texcoordBuffer.destroy(), n.colorBuffer && n.colorBuffer.destroy(), n.pbrBuffer && n.pbrBuffer.destroy(), n.segments.destroy(), n.material && ((e = n.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
        var e;
        if (r.children)
          for (const n of r.children)
            ng(n);
      }
      class Fu {
        constructor(e, n, o) {
          this._demTile = e, this._dem = this._demTile.dem, this._scale = n, this._offset = o;
        }
        static create(e, n, o) {
          const u = o || e.findDEMTileFor(n);
          if (!u || !u.dem)
            return;
          const l = u.dem, f = u.tileID, v = 1 << n.canonical.z - f.canonical.z;
          return new Fu(u, l.dim / Tt / v, [(n.canonical.x / v - f.canonical.x) * l.dim, (n.canonical.y / v - f.canonical.y) * l.dim]);
        }
        tileCoordToPixel(e, n) {
          const o = n * this._scale + this._offset[1], u = Math.floor(e * this._scale + this._offset[0]), l = Math.floor(o);
          return new Et(u, l);
        }
        getElevationAt(e, n, o, u) {
          const l = e * this._scale + this._offset[0], f = n * this._scale + this._offset[1], v = Math.floor(l), S = Math.floor(f), D = this._dem;
          return u = !!u, o ? ei(ei(D.get(v, S, u), D.get(v, S + 1, u), f - S), ei(D.get(v + 1, S, u), D.get(v + 1, S + 1, u), f - S), l - v) : D.get(v, S, u);
        }
        getElevationAtPixel(e, n, o) {
          return this._dem.get(e, n, !!o);
        }
        getMeterToDEM(e) {
          return (1 << this._demTile.tileID.canonical.z) * fr(1, e) * this._dem.stride;
        }
      }
      const sg = new Float32Array(262144), wh = new Uint8Array(262144);
      function Gx(r) {
        let e = 0;
        if (r.meshes)
          for (const n of r.meshes)
            e = Math.max(e, n.aabb.max[2]);
        if (r.children)
          for (const n of r.children)
            e = Math.max(e, Gx(n));
        return e;
      }
      function Zx(r, e, n) {
        if (r.meshes)
          for (const o of r.meshes) {
            if (o.aabb.min[0] === 1 / 0)
              continue;
            const u = Jt.applyTransform(o.aabb, r.matrix);
            n.insert(e, u.min[0], u.min[1], u.max[0], u.max[1]);
          }
        if (r.children)
          for (const o of r.children)
            Zx(o, e, n);
      }
      const Hx = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class qx {
        constructor(e) {
          this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: e.id, geometry: [], properties: { height: Gx(e) } }, this.aabb = this._getLocalBounds(), this.state = null;
        }
        _getLocalBounds() {
          if (!this.node.meshes)
            return new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
          if (!this.aabb) {
            let e = 0;
            const n = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            for (const o of this.node.meshes)
              this.node.lightMeshIndex !== e && (o.transformedAabb = Jt.applyTransformFast(o.aabb, this.node.matrix), n.encapsulate(o.transformedAabb)), e++;
            this.aabb = n;
          }
          return this.aabb;
        }
      }
      class em {
        constructor(e, n, o, u, l, f, v) {
          this.id = o, this.layers = e, this.layerIds = this.layers.map((S) => S.fqid), this.stateDependentLayerIds = this.layers.filter((S) => S.isStateDependent()).map((S) => S.id), this.modelTraits |= Ou.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, u && (this.modelTraits |= Ou.HasMapboxMeshFeatures), l && (this.modelTraits |= Ou.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = f, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
          for (const S of n)
            this.nodesInfo.push(new qx(S)), Zx(S, v.featureIndexArray.length, v.grid), v.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, v.bucketLayerIDs.length - 1, 0);
          this.states = {};
        }
        updateFootprints(e, n) {
          for (const o of this.getNodesInfo()) {
            const u = o.node;
            u.footprint && n.push({ footprint: u.footprint, id: e });
          }
        }
        update(e) {
          const n = Object.keys(e).length !== 0;
          if (n && !this.stateDependentLayers.length)
            return;
          const o = n ? this.stateDependentLayers : this.layers;
          if (!Ws(e, this.states))
            for (const u of o)
              this.evaluate(u, e);
          this.states = structuredClone(e);
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(e) {
          if (!this.needsUpload)
            return;
          const n = this.getNodesInfo();
          for (const o of n) {
            const u = o.node;
            this.uploaded ? this.updatePbrBuffer(u) : ig(u, e, !0);
          }
          for (const o of n)
            Qp(o.node);
          this.uploaded = !0, this.needsUpload = !1;
        }
        updatePbrBuffer(e) {
          let n = !1;
          if (!e.meshes)
            return n;
          for (const o of e.meshes)
            o.pbrBuffer && (o.pbrBuffer.updateData(o.featureArray), n = !0);
          return n;
        }
        needsReEvaluation(e, n, o) {
          const u = e.transform.projectionOptions, l = e.style.getBrightness(), f = this.brightness !== l;
          if (!this.uploaded || this.dirty || u.name !== this.projection.name || of(o.paint.get("model-color").value, f) || of(o.paint.get("model-color-mix-intensity").value, f) || of(o.paint.get("model-roughness").value, f) || of(o.paint.get("model-emissive-strength").value, f) || of(o.paint.get("model-height-based-emissive-strength-multiplier").value, f)) {
            this.projection = u, this.brightness = l;
            const v = this.getNodesInfo();
            for (const S of v)
              S.state = null;
            return !0;
          }
          return !1;
        }
        evaluateScale(e, n) {
          if (e.transform.zoom === this.zoom)
            return;
          this.zoom = e.transform.zoom;
          const o = this.getNodesInfo(), u = this.id.canonical;
          for (const l of o) {
            const f = l.feature;
            l.evaluatedScale = n.paint.get("model-scale").evaluate(f, {}, u);
          }
        }
        evaluate(e, n) {
          const o = this.getNodesInfo();
          for (const u of o) {
            if (!u.node.meshes)
              continue;
            const l = u.feature, f = n && n[l.id];
            if (Ws(f, u.state))
              continue;
            u.state = structuredClone(f);
            const v = u.node.meshes && u.node.meshes[0].featureData, S = u.evaluatedColor[2], D = u.evaluatedRMEA[2], x = this.id.canonical;
            if (u.hasTranslucentParts = !1, v) {
              for (let A = 0; A < Hx.length; A++) {
                const I = Hx[A];
                I.length && (l.properties.part = I);
                const M = e.paint.get("model-color").evaluate(l, f, x).toRenderColor(null), C = e.paint.get("model-color-mix-intensity").evaluate(l, f, x);
                u.evaluatedColor[A] = [M.r, M.g, M.b, C], u.evaluatedRMEA[A][0] = e.paint.get("model-roughness").evaluate(l, f, x), u.evaluatedRMEA[A][2] = e.paint.get("model-emissive-strength").evaluate(l, f, x), u.evaluatedRMEA[A][3] = M.a, u.emissionHeightBasedParams[A] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(l, f, x), !u.hasTranslucentParts && M.a < 1 && (u.hasTranslucentParts = !0);
              }
              delete l.properties.part, c2(u, S !== u.evaluatedColor[2] || D !== u.evaluatedRMEA[2], this.modelTraits);
            } else
              u.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(l, f, x);
            u.evaluatedScale = e.paint.get("model-scale").evaluate(l, f, x), this.updatePbrBuffer(u.node) || (this.needsUpload = !0);
          }
          this.dirty = !1;
        }
        elevationUpdate(e, n, o, u) {
          const l = e.findDEMTileFor(o);
          if (l && (l.tileID.canonical !== this.terrainTile || n !== this.terrainExaggeration)) {
            if (l.dem && l.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = l.tileID.overscaledZ;
              const f = Fu.create(e, o, l);
              if (!f)
                return;
              this.modelTraits & Ou.HasMapboxMeshFeatures && this.updateDEM(e, f, o, u);
              for (const v of this.getNodesInfo()) {
                const S = v.node;
                if (!S.footprint || !S.footprint.vertices || !S.footprint.vertices.length)
                  continue;
                const D = S.footprint.vertices;
                let x = f.getElevationAt(D[0].x, D[0].y, !0, !0);
                for (let A = 1; A < D.length; A++)
                  x = Math.min(x, f.getElevationAt(D[A].x, D[A].y, !0, !0));
                S.elevation = x;
              }
            }
            this.terrainTile = l.tileID.canonical, this.terrainExaggeration = n;
          }
        }
        updateDEM(e, n, o, u) {
          let l = n._dem._modifiedForSources[u];
          if (l === void 0 && (n._dem._modifiedForSources[u] = [], l = n._dem._modifiedForSources[u]), l.includes(o.canonical))
            return;
          const f = n._dem.dim;
          l.push(o.canonical);
          let v = !1;
          for (const S of this.getNodesInfo()) {
            const D = S.node;
            if (!D.footprint || !D.footprint.grid)
              continue;
            const x = D.footprint.grid, A = n.tileCoordToPixel(x.min.x, x.min.y), I = n.tileCoordToPixel(x.max.x, x.max.y), M = Math.min(Math.min(f - I.y, A.x), Math.min(A.y, f - I.x));
            if (M < 0)
              continue;
            const C = si(M, 2, 5);
            let k = Math.max(0, A.x - C), V = Math.max(0, A.y - C), U = Math.min(I.x + C, f - 1), q = Math.min(I.y + C, f - 1);
            for (let Q = V; Q <= q; ++Q)
              for (let ie = k; ie <= U; ++ie)
                wh[Q * f + ie] = 255;
            let $ = 0, H = 0;
            for (let Q = 0; Q < x.cellsY; ++Q)
              for (let ie = 0; ie < x.cellsX; ++ie) {
                if (!x.cells[Q * x.cellsX + ie])
                  continue;
                const fe = n.tileCoordToPixel(x.min.x + ie / x.xScale, x.min.y + Q / x.yScale), de = n.tileCoordToPixel(x.min.x + (ie + 1) / x.xScale, x.min.y + (Q + 1) / x.yScale);
                for (let ue = fe.y; ue <= Math.min(de.y + 1, f - 1); ++ue)
                  for (let Se = fe.x; Se <= Math.min(de.x + 1, f - 1); ++Se)
                    wh[ue * f + Se] === 255 && (wh[ue * f + Se] = 0, $ += n.getElevationAtPixel(Se, ue), H++);
              }
            const K = $ / H;
            k = Math.max(1, A.x - C), V = Math.max(1, A.y - C), U = Math.min(I.x + C, f - 2), q = Math.min(I.y + C, f - 2), v = !0;
            for (let Q = V; Q <= q; ++Q)
              for (let ie = k; ie <= U; ++ie)
                wh[Q * f + ie] === 0 && (sg[Q * f + ie] = n._dem.set(ie, Q, K));
            for (let Q = 1; Q < C; ++Q) {
              k = Math.max(1, A.x - Q), V = Math.max(1, A.y - Q), U = Math.min(I.x + Q, f - 2), q = Math.min(I.y + Q, f - 2);
              for (let ie = V; ie <= q; ++ie)
                for (let fe = k; fe <= U; ++fe) {
                  const de = ie * f + fe;
                  if (wh[de] === 255) {
                    let ue = 0, Se = 0, me = -1, Ee = -1;
                    for (let ze = -1; ze <= 1; ++ze)
                      for (let Ie = -1; Ie <= 1; ++Ie) {
                        const Re = (ie + ze) * f + fe + Ie;
                        if (wh[Re] >= Q)
                          continue;
                        const Ve = sg[Re], Ue = Math.abs(Ve);
                        Ue > Se && (ue = Ve, Se = Ue, me = Ie, Ee = ze);
                      }
                    if (Se > 0.1) {
                      const ze = 1 - (Q + 0.5 * Math.abs(me * Ee)) / C;
                      let Ie = n._dem.get(fe, ie) + ue * ze;
                      const Re = n._dem.get(fe + me, ie + Ee), Ve = n._dem.get(fe - me, ie - Ee, !0);
                      (Ie - Re) * (Ie - Ve) > 0 && (Ie = (Re + Ve) / 2), sg[de] = n._dem.set(fe, ie, Ie), wh[de] = Q;
                    }
                  }
                }
            }
          }
          v && (n._demTile.needsDEMTextureUpload = !0, n._dem._timestamp = Ct.now());
        }
        getNodesInfo() {
          return this.nodesInfo;
        }
        destroy() {
          const e = this.getNodesInfo();
          for (const n of e)
            Qp(n.node), ng(n.node);
        }
        isEmpty() {
          return !this.nodesInfo.length;
        }
        updateReplacement(e, n) {
          if (n.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = n.updateTime;
          const o = n.getReplacementRegionsForTile(e.toUnwrapped()), u = this.getNodesInfo();
          for (let l = 0; l < this.nodesInfo.length; l++) {
            const f = u[l].node;
            u[l].hiddenByReplacement = !!f.footprint && !o.find((v) => v.footprint === f.footprint);
          }
        }
        getHeightAtTileCoord(e, n) {
          const o = this.getNodesInfo(), u = [], l = [0, 0, 0], f = De.mat4.identity([]);
          for (let v = 0; v < this.nodesInfo.length; v++) {
            const S = o[v], D = S.node.meshes[0], x = D.transformedAabb;
            if (e < x.min[0] || n < x.min[1] || e > x.max[0] || n > x.max[1])
              continue;
            if (S.node.hidden === !0)
              return { height: 1 / 0, maxHeight: S.feature.properties.height, hidden: !1, verticalScale: S.evaluatedScale[2] };
            De.mat4.invert(f, S.node.matrix), l[0] = e, l[1] = n, De.vec3.transformMat4(l, l, f);
            const A = (l[0] - D.aabb.min[0]) / (D.aabb.max[0] - D.aabb.min[0]) * bh | 0, I = Math.min(63, (l[1] - D.aabb.min[1]) / (D.aabb.max[1] - D.aabb.min[1]) * bh | 0) * bh + Math.min(63, A), M = D.heightmap[I];
            if (!(M < 0 && S.node.footprint))
              return S.hiddenByReplacement ? void 0 : { height: M, maxHeight: S.feature.properties.height, hidden: !1, verticalScale: S.evaluatedScale[2] };
            if (S.node.footprint.grid.query(new Et(e, n), new Et(e, n), u), u.length > 0)
              return { height: void 0, maxHeight: S.feature.properties.height, hidden: S.hiddenByReplacement, verticalScale: S.evaluatedScale[2] };
          }
        }
      }
      function of(r, e) {
        return !r.isLightConstant && e;
      }
      function l2(r, e, n, o, u, l, f, v) {
        let S = (61440 & e | (61440 & e) >> 4) >> 8, D = (3840 & e | (3840 & e) >> 4) >> 4, x = 240 & e | (240 & e) >> 4;
        n[3] > 0 && (S = ei(S, 255 * n[0], n[3]), D = ei(D, 255 * n[1], n[3]), x = ei(x, 255 * n[2], n[3]));
        const A = S << 8 | D, I = x << 8 | Math.floor(255 * o[3]), M = function(Q) {
          const ie = si(Q, 0, 2);
          return Math.min(Math.round(0.5 * ie * 255), 255);
        }(o[2]) << 8 | 15 * o[0] << 4 | 15 * o[1], C = si(u[0], 0, 1), k = si(u[1], 0, 1), V = si(u[2], 0, 1), U = si(u[3], 0, 1);
        let q, $, H, K;
        if (C !== k && f !== l && k !== C) {
          const Q = f - l;
          $ = 1 / (Q * (k - C)), H = -(l + Q * C) / (Q * (k - C));
          const ie = si(u[4], -1, 1);
          K = Math.pow(10, ie), q = 255 * V << 8 | 255 * U;
        } else
          q = 65535, $ = 0, H = 1, K = 1;
        if (r.emplaceBack(A, I, M, q, $, H, K), v) {
          const Q = v.length;
          v.clear();
          for (let ie = 0; ie < Q; ie++)
            v.emplaceBack(A, I, M, q, $, H, K);
        }
      }
      function c2(r, e, n) {
        const o = r.node;
        let u = 0;
        const l = n & Ou.HasMeshoptCompression;
        for (const f of o.meshes) {
          if (o.lights && o.lightMeshIndex === u || !f.featureData)
            continue;
          f.featureArray = new lh(), f.featureArray.reserve(f.featureData.length);
          let v = e;
          for (const S of f.featureData) {
            const D = l ? 65535 & S : S >> 16 & 65535, x = l ? S >> 16 & 65535 : 65535 & S, A = (15 & x) < 8 ? 15 & x : 0, I = r.evaluatedRMEA[A], M = r.evaluatedColor[A], C = r.emissionHeightBasedParams[A];
            let k;
            if (v && A === 2 && o.lights && (k = new lh(), k.resize(10 * o.lights.length)), l2(f.featureArray, D, M, I, C, f.aabb.min[2], f.aabb.max[2], k), k && v) {
              v = !1;
              const V = o.meshes[o.lightMeshIndex];
              V.featureArray = k, V.featureArray._trim();
            }
          }
          f.featureArray._trim(), u++;
        }
      }
      function Wx(r, e, n, o) {
        const u = 1 << r.z;
        e.lat = Os((o / Tt + r.y) / u), e.lng = Fr((n / Tt + r.x) / u);
      }
      Ft(em, "Tiled3dModelBucket", { omit: ["layers"] }), Ft(qx, "Tiled3dModelFeature");
      const h2 = { circle: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Ge || (Ge = new Bn({ "circle-sort-key": new Dt($e.layout_circle["circle-sort-key"]), visibility: new yt($e.layout_circle.visibility) })), paint: lt || (lt = new Bn({ "circle-radius": new Dt($e.paint_circle["circle-radius"]), "circle-color": new Dt($e.paint_circle["circle-color"]), "circle-blur": new Dt($e.paint_circle["circle-blur"]), "circle-opacity": new Dt($e.paint_circle["circle-opacity"]), "circle-translate": new yt($e.paint_circle["circle-translate"]), "circle-translate-anchor": new yt($e.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new yt($e.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new yt($e.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Dt($e.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Dt($e.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Dt($e.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new yt($e.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        createBucket(r) {
          return new ee(r);
        }
        queryRadius(r) {
          const e = r;
          return Ne("circle-radius", this, e) + Ne("circle-stroke-width", this, e) + st(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l, f, v) {
          const S = xt(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), D = this.paint.get("circle-radius").evaluate(e, n) + this.paint.get("circle-stroke-width").evaluate(e, n);
          return Pu(r, o, l, f, v, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", S, D);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(r, e, n) {
          const o = Au(this);
          return { config: new Cl(this, { zoom: e, lut: n }), defines: o, overrideFog: !1 };
        }
      }, heatmap: class extends wr {
        createBucket(r) {
          return new Sy(r);
        }
        constructor(r, e, n, o) {
          super(r, { layout: Ey || (Ey = new Bn({ visibility: new yt($e.layout_heatmap.visibility) })), paint: Ay || (Ay = new Bn({ "heatmap-radius": new Dt($e.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Dt($e.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new yt($e.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Wa($e.paint_heatmap["heatmap-color"]), "heatmap-opacity": new yt($e.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(r) {
          r === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Bd({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(r) {
          return Ne("heatmap-radius", this, r);
        }
        queryIntersectsFeature(r, e, n, o, u, l, f, v) {
          const S = this.paint.get("heatmap-radius").evaluate(e, n);
          return Pu(r, o, l, f, v, !0, !0, new Et(0, 0), S);
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(r, e, n) {
          return r === "heatmap" ? { config: new Cl(this, { zoom: e, lut: n }), overrideFog: !1 } : {};
        }
      }, hillshade: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Py || (Py = new Bn({ visibility: new yt($e.layout_hillshade.visibility) })), paint: Cy || (Cy = new Bn({ "hillshade-illumination-direction": new yt($e.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new yt($e.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new yt($e.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new yt($e.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new yt($e.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new yt($e.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new yt($e.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        shouldRedrape() {
          return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport";
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(r, e, n) {
          return { overrideFog: !1 };
        }
      }, fill: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: By || (By = new Bn({ "fill-sort-key": new Dt($e.layout_fill["fill-sort-key"]), visibility: new yt($e.layout_fill.visibility), "fill-elevation-reference": new yt($e.layout_fill["fill-elevation-reference"]) })), paint: Ny || (Ny = new Bn({ "fill-antialias": new yt($e.paint_fill["fill-antialias"]), "fill-opacity": new Dt($e.paint_fill["fill-opacity"]), "fill-color": new Dt($e.paint_fill["fill-color"]), "fill-outline-color": new Dt($e.paint_fill["fill-outline-color"]), "fill-translate": new yt($e.paint_fill["fill-translate"]), "fill-translate-anchor": new yt($e.paint_fill["fill-translate-anchor"]), "fill-pattern": new Dt($e.paint_fill["fill-pattern"]), "fill-emissive-strength": new yt($e.paint_fill["fill-emissive-strength"]), "fill-z-offset": new Dt($e.paint_fill["fill-z-offset"]), "fill-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        getProgramIds() {
          const r = this.paint.get("fill-pattern"), e = r && r.constantOr(1), n = [e ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && n.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), n;
        }
        getDefaultProgramParams(r, e, n) {
          return { config: new Cl(this, { zoom: e, lut: n }), overrideFog: !1 };
        }
        recalculate(r, e) {
          super.recalculate(r, e);
          const n = this.paint._values["fill-outline-color"];
          n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(r) {
          return new v_(r);
        }
        queryRadius() {
          return st(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          return !r.queryGeometry.isAboveHorizon && he(ut(r.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), o);
        }
        isTileClipped() {
          return !0;
        }
        is3D() {
          return this.paint.get("fill-z-offset").constantOr(1) !== 0;
        }
      }, "fill-extrusion": class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: v0 || (v0 = new Bn({ visibility: new yt($e["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new yt($e["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: b0 || (b0 = new Bn({ "fill-extrusion-opacity": new yt($e["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Dt($e["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new yt($e["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new yt($e["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Dt($e["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Dt($e["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Dt($e["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new yt($e["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new yt($e["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new yt($e["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new yt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new yt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new yt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new yt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new yt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new yt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new yt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Dt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Dt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new yt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new yt($e["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new yt($e["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new yt($e["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new Dt($e["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new Dt($e["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new yt($e["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(r) {
          return new Ip(r);
        }
        queryRadius() {
          return st(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        hasShadowPass() {
          return this.paint.get("fill-extrusion-cast-shadows");
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return !0;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(r, e, n, o, u, l, f, v, S) {
          const D = xt(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), x = this.paint.get("fill-extrusion-height").evaluate(e, n), A = this.paint.get("fill-extrusion-base").evaluate(e, n), I = [0, 0], M = v && l.elevation, C = l.elevation ? l.elevation.exaggeration() : 1, k = r.tile.getBucket(this);
          if (M && k instanceof Ip) {
            const H = k.centroidVertexArray, K = S + 1;
            K < H.length && (I[0] = H.geta_centroid_pos0(K), I[1] = H.geta_centroid_pos1(K));
          }
          if (I[0] === 0 && I[1] === 1)
            return !1;
          l.projection.name === "globe" && (o = x0([o], [new Et(0, 0), new Et(Tt, Tt)], r.tileID.canonical).map((H) => H.polygon).flat());
          const V = M ? v : null, [U, q] = function(H, K, Q, ie, fe, de, ue, Se, me, Ee, ze) {
            return H.projection.name === "globe" ? function(Ie, Re, Ve, Ue, Fe, et, dt, tt, Mt, wt, Pt) {
              const rt = [], Ut = [], St = Ie.projection.upVectorScale(Pt, Ie.center.lat, Ie.worldSize).metersToTile, Nt = [0, 0, 0, 1], Qt = [0, 0, 0, 1], pi = (Pi, yi, Ii, fn) => {
                Pi[0] = yi, Pi[1] = Ii, Pi[2] = fn, Pi[3] = 1;
              }, gi = y0();
              Ve > 0 && (Ve += gi), Ue += gi;
              for (const Pi of Re) {
                const yi = [], Ii = [];
                for (const fn of Pi) {
                  const rn = fn.x + Fe.x, hi = fn.y + Fe.y, on = Ie.projection.projectTilePoint(rn, hi, Pt), Qi = Ie.projection.upVector(Pt, fn.x, fn.y);
                  let pn = Ve, as = Ue;
                  if (dt) {
                    const ls = T0(rn, hi, Ve, Ue, dt, tt, Mt, wt);
                    pn += ls.base, as += ls.top;
                  }
                  Ve !== 0 ? pi(Nt, on.x + Qi[0] * St * pn, on.y + Qi[1] * St * pn, on.z + Qi[2] * St * pn) : pi(Nt, on.x, on.y, on.z), pi(Qt, on.x + Qi[0] * St * as, on.y + Qi[1] * St * as, on.z + Qi[2] * St * as), De.vec3.transformMat4(Nt, Nt, et), De.vec3.transformMat4(Qt, Qt, et), yi.push(new vh(Nt[0], Nt[1], Nt[2])), Ii.push(new vh(Qt[0], Qt[1], Qt[2]));
                }
                rt.push(yi), Ut.push(Ii);
              }
              return [rt, Ut];
            }(H, K, Q, ie, fe, de, ue, Se, me, Ee, ze) : ue ? function(Ie, Re, Ve, Ue, Fe, et, dt, tt, Mt) {
              const wt = [], Pt = [], rt = [0, 0, 0, 1];
              for (const Ut of Ie) {
                const St = [], Nt = [];
                for (const Qt of Ut) {
                  const pi = Qt.x + Ue.x, gi = Qt.y + Ue.y, Pi = T0(pi, gi, Re, Ve, et, dt, tt, Mt);
                  rt[0] = pi, rt[1] = gi, rt[2] = Pi.base, rt[3] = 1, De.vec4.transformMat4(rt, rt, Fe), rt[3] = Math.max(rt[3], 1e-5);
                  const yi = new vh(rt[0] / rt[3], rt[1] / rt[3], rt[2] / rt[3]);
                  rt[0] = pi, rt[1] = gi, rt[2] = Pi.top, rt[3] = 1, De.vec4.transformMat4(rt, rt, Fe), rt[3] = Math.max(rt[3], 1e-5);
                  const Ii = new vh(rt[0] / rt[3], rt[1] / rt[3], rt[2] / rt[3]);
                  St.push(yi), Nt.push(Ii);
                }
                wt.push(St), Pt.push(Nt);
              }
              return [wt, Pt];
            }(K, Q, ie, fe, de, ue, Se, me, Ee) : function(Ie, Re, Ve, Ue, Fe) {
              const et = [], dt = [], tt = Fe[8] * Re, Mt = Fe[9] * Re, wt = Fe[10] * Re, Pt = Fe[11] * Re, rt = Fe[8] * Ve, Ut = Fe[9] * Ve, St = Fe[10] * Ve, Nt = Fe[11] * Ve;
              for (const Qt of Ie) {
                const pi = [], gi = [];
                for (const Pi of Qt) {
                  const yi = Pi.x + Ue.x, Ii = Pi.y + Ue.y, fn = Fe[0] * yi + Fe[4] * Ii + Fe[12], rn = Fe[1] * yi + Fe[5] * Ii + Fe[13], hi = Fe[2] * yi + Fe[6] * Ii + Fe[14], on = Fe[3] * yi + Fe[7] * Ii + Fe[15], Qi = fn + tt, pn = rn + Mt, as = hi + wt, ls = Math.max(on + Pt, 1e-5), Kn = fn + rt, Vr = rn + Ut, Sn = hi + St, Ln = Math.max(on + Nt, 1e-5);
                  pi.push(new vh(Qi / ls, pn / ls, as / ls)), gi.push(new vh(Kn / Ln, Vr / Ln, Sn / Ln));
                }
                et.push(pi), dt.push(gi);
              }
              return [et, dt];
            }(K, Q, ie, fe, de);
          }(l, o, A, x, D, f, V, I, C, l.center.lat, r.tileID.canonical), $ = r.queryGeometry;
          return function(H, K, Q) {
            let ie = 1 / 0;
            he(Q, K) && (ie = w0(Q, K[0]));
            for (let fe = 0; fe < K.length; fe++) {
              const de = K[fe], ue = H[fe];
              for (let Se = 0; Se < de.length - 1; Se++) {
                const me = de[Se], Ee = [me, de[Se + 1], ue[Se + 1], ue[Se], me];
                se(Q, Ee) && (ie = Math.min(ie, w0(Q, Ee)));
              }
            }
            return ie !== 1 / 0 && ie;
          }(U, q, $.isPointQuery() ? $.screenBounds : $.screenGeometry);
        }
      }, line: class extends wr {
        constructor(r, e, n, o) {
          const u = D0();
          super(r, u, e, n, o), u.layout && (this.layout = new cc(u.layout)), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(r) {
          if (r === "line-gradient") {
            const e = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Ti, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(r, e) {
          super.recalculate(r, e), this.paint._values["line-floorwidth"] = (() => {
            if (Wd)
              return Wd;
            const n = D0();
            return Wd = new fT(n.paint.properties["line-width"].specification), Wd.useIntegerZoom = !0, Wd;
          })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, r);
        }
        createBucket(r) {
          return new I_(r);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(r, e, n) {
          const o = L0(this);
          return { config: new Cl(this, { zoom: e, lut: n }), defines: o, overrideFog: !1 };
        }
        queryRadius(r) {
          const e = r, n = k0(Ne("line-width", this, e), Ne("line-gap-width", this, e)), o = Ne("line-offset", this, e);
          return n / 2 + Math.abs(o) + st(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          if (r.queryGeometry.isAboveHorizon)
            return !1;
          const f = ut(r.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), v = r.pixelToTileUnitsFactor / 2 * k0(this.paint.get("line-width").evaluate(e, n), this.paint.get("line-gap-width").evaluate(e, n)), S = this.paint.get("line-offset").evaluate(e, n);
          return S && (o = function(D, x) {
            const A = [], I = new Et(0, 0);
            for (let M = 0; M < D.length; M++) {
              const C = D[M], k = [];
              for (let V = 0; V < C.length; V++) {
                const U = C[V], q = C[V + 1], $ = V === 0 ? I : U.sub(C[V - 1])._unit()._perp(), H = V === C.length - 1 ? I : q.sub(U)._unit()._perp(), K = $._add(H)._unit();
                K._mult(1 / (K.x * H.x + K.y * H.y)), k.push(K._mult(x)._add(U));
              }
              A.push(k);
            }
            return A;
          }(o, S * r.pixelToTileUnitsFactor)), function(D, x, A) {
            for (let I = 0; I < x.length; I++) {
              const M = x[I];
              if (D.length >= 3) {
                for (let C = 0; C < M.length; C++)
                  if (Pe(D, M[C]))
                    return !0;
              }
              if (_e(D, M, A))
                return !0;
            }
            return !1;
          }(f, o, v);
        }
        isTileClipped() {
          return !0;
        }
        isDraped(r) {
          const e = this.layout.get("line-z-offset"), n = e.isConstant() && !e.constantOr(0), o = this.layout.get("line-elevation-reference");
          return !(o === "sea" || o === "ground") && (n || o !== "none");
        }
      }, symbol: qp, background: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: yx || (yx = new Bn({ visibility: new yt($e.layout_background.visibility) })), paint: xx || (xx = new Bn({ "background-pitch-alignment": new yt($e.paint_background["background-pitch-alignment"]), "background-color": new yt($e.paint_background["background-color"]), "background-pattern": new yt($e.paint_background["background-pattern"]), "background-opacity": new yt($e.paint_background["background-opacity"]), "background-emissive-strength": new yt($e.paint_background["background-emissive-strength"]), "background-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(r, e, n) {
          return { overrideFog: !1 };
        }
        is3D() {
          return this.paint.get("background-pitch-alignment") === "viewport";
        }
      }, raster: Mx, "raster-particle": Ix, sky: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Ax || (Ax = new Bn({ visibility: new yt($e.layout_sky.visibility) })), paint: Px || (Px = new Bn({ "sky-type": new yt($e.paint_sky["sky-type"]), "sky-atmosphere-sun": new yt($e.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new yt($e.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new yt($e.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new yt($e.paint_sky["sky-gradient-radius"]), "sky-gradient": new Wa($e.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new yt($e.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new yt($e.paint_sky["sky-atmosphere-color"]), "sky-opacity": new yt($e.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(r) {
          r === "sky-gradient" ? this._updateColorRamp() : r !== "sky-atmosphere-sun" && r !== "sky-atmosphere-halo-color" && r !== "sky-atmosphere-color" && r !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0);
        }
        _updateColorRamp() {
          this.colorRamp = Bd({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(r) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return !0;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e = r.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
          }
          return !1;
        }
        getCenter(r, e) {
          if (this.paint.get("sky-type") === "atmosphere") {
            const o = this.paint.get("sky-atmosphere-sun"), u = !o, l = r.style.light, f = l.properties.get("position");
            return u && l.properties.get("anchor") === "viewport" && mi("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), u ? J_(f.azimuthal, 90 - f.polar, e) : J_(o[0], 90 - o[1], e);
          }
          const n = this.paint.get("sky-gradient-center");
          return J_(n[0], 90 - n[1], e);
        }
        isSky() {
          return !0;
        }
        markSkyboxValid(r) {
          this._skyboxInvalidated = !1, this._lightPosition = r.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return !0;
        }
        getProgramIds() {
          const r = this.paint.get("sky-type");
          return r === "atmosphere" ? ["skyboxCapture", "skybox"] : r === "gradient" ? ["skyboxGradient"] : null;
        }
      }, slot: class extends wr {
        constructor(r, e, n, o) {
          super(r, { paint: Cx || (Cx = new Bn({})) }, e, null);
        }
      }, model: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Vx || (Vx = new Bn({ visibility: new yt($e.layout_model.visibility), "model-id": new Dt($e.layout_model["model-id"]) })), paint: Ux || (Ux = new Bn({ "model-opacity": new Dt($e.paint_model["model-opacity"]), "model-rotation": new Dt($e.paint_model["model-rotation"]), "model-scale": new Dt($e.paint_model["model-scale"]), "model-translation": new Dt($e.paint_model["model-translation"]), "model-color": new Dt($e.paint_model["model-color"]), "model-color-mix-intensity": new Dt($e.paint_model["model-color-mix-intensity"]), "model-type": new yt($e.paint_model["model-type"]), "model-cast-shadows": new yt($e.paint_model["model-cast-shadows"]), "model-receive-shadows": new yt($e.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new yt($e.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Dt($e.paint_model["model-emissive-strength"]), "model-roughness": new Dt($e.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Dt($e.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new yt($e.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new yt($e.paint_model["model-front-cutoff"]), "model-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(r) {
          return new tg(r);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D() {
          return !0;
        }
        hasShadowPass() {
          return !0;
        }
        canCastShadows() {
          return !0;
        }
        hasLightBeamPass() {
          return !0;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius(r) {
          return r instanceof em ? Tt - 1 : 0;
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          if (!this.modelManager)
            return !1;
          const f = this.modelManager, v = r.tile.getBucket(this);
          if (!(v && v instanceof tg))
            return !1;
          for (const S in v.instancesPerModel) {
            const D = v.instancesPerModel[S], x = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
            if (D.idToFeaturesIndex.hasOwnProperty(x)) {
              const A = D.features[D.idToFeaturesIndex[x]], I = f.getModel(S, this.scope);
              if (!I)
                return !1;
              let M = De.mat4.create();
              const C = new Ui(0, 0), k = v.canonical;
              let V = Number.MAX_VALUE;
              for (let U = 0; U < A.instancedDataCount; ++U) {
                const q = 16 * (A.instancedDataOffset + U), $ = D.instancedDataArray.float32, H = [$[q + 4], $[q + 5], $[q + 6]];
                Wx(k, C, $[q], 0 | $[q + 1]), jx(M, I, l, C, A.rotation, A.scale, H, !1, !1, !1), l.projection.name === "globe" && (M = eg(M, l));
                const K = De.mat4.multiply([], l.projMatrix, M), Q = r.queryGeometry, ie = Rx(Q.isPointQuery() ? Q.screenBounds : Q.screenGeometry, l, K, I.aabb);
                ie != null && (V = Math.min(ie, V));
              }
              return V !== Number.MAX_VALUE && V;
            }
          }
          return !1;
        }
        _handleOverridablePaintPropertyUpdate(r, e, n) {
          return !(!this.layout || e.isDataDriven() || n.isDataDriven() || r !== "model-color" && r !== "model-color-mix-intensity" && r !== "model-rotation" && r !== "model-scale" && r !== "model-translation" && r !== "model-emissive-strength");
        }
        _isPropertyZoomDependent(r) {
          const e = this._transitionablePaint._values[r];
          return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof sc;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
      }, clip: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Vy || (Vy = new Bn({ "clip-layer-types": new yt($e.layout_clip["clip-layer-types"]), "clip-layer-scope": new yt($e.layout_clip["clip-layer-scope"]) })), paint: Uy || (Uy = new Bn({})) }, e, n, o);
        }
        recalculate(r, e) {
          super.recalculate(r, e);
        }
        createBucket(r) {
          return new jy(r);
        }
        isTileClipped() {
          return !0;
        }
        is3D() {
          return !0;
        }
      } };
      class u2 {
        constructor(e) {
          this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class d2 {
        constructor() {
          this.tasks = {}, this.taskQueue = [], vo(["process"], this), this.invoker = new u2(this.process), this.nextId = 0;
        }
        add(e, n) {
          const o = this.nextId++, u = function({ type: l, isSymbolTile: f, zoom: v }) {
            return v = v || 0, l === "message" ? 0 : l !== "maybePrepare" || f ? l !== "parseTile" || f ? l === "parseTile" && f ? 300 - v : l === "maybePrepare" && f ? 400 - v : 500 : 200 - v : 100 - v;
          }(n);
          if (u === 0) {
            try {
              e();
            } finally {
            }
            return null;
          }
          return this.tasks[o] = { fn: e, metadata: n, priority: u, id: o }, this.taskQueue.push(o), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[o];
          } };
        }
        process() {
          try {
            if (this.taskQueue = this.taskQueue.filter((o) => !!this.tasks[o]), !this.taskQueue.length)
              return;
            const e = this.pick();
            if (e === null)
              return;
            const n = this.tasks[e];
            if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !n)
              return;
            n.fn();
          } finally {
          }
        }
        pick() {
          let e = null, n = 1 / 0;
          for (let u = 0; u < this.taskQueue.length; u++) {
            const l = this.tasks[this.taskQueue[u]];
            l.priority < n && (n = l.priority, e = u);
          }
          if (e === null)
            return null;
          const o = this.taskQueue[e];
          return this.taskQueue.splice(e, 1), o;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class $x {
        constructor(e, n, o) {
          this.target = e, this.parent = n, this.mapId = o, this.callbacks = {}, this.cancelCallbacks = {}, vo(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new d2();
        }
        send(e, n, o, u, l = !1, f) {
          const v = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          o && (o.metadata = f, this.callbacks[v] = o);
          const S = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: v, type: e, hasCallback: !!o, targetMapId: u, mustQueue: l, sourceMapId: this.mapId, data: lo(n, S) }, S), { cancel: () => {
            o && delete this.callbacks[v], this.target.postMessage({ id: v, type: "<cancel>", targetMapId: u, sourceMapId: this.mapId });
          } };
        }
        receive(e) {
          const n = e.data, o = n.id;
          if (o && (!n.targetMapId || this.mapId === n.targetMapId))
            if (n.type === "<cancel>") {
              const u = this.cancelCallbacks[o];
              delete this.cancelCallbacks[o], u && u.cancel();
            } else if (n.mustQueue || Jn()) {
              const u = this.callbacks[o], l = this.scheduler.add(() => this.processTask(o, n), u && u.metadata || { type: "message" });
              l && (this.cancelCallbacks[o] = l);
            } else
              this.processTask(o, n);
        }
        processTask(e, n) {
          if (delete this.cancelCallbacks[e], n.type === "<response>") {
            const o = this.callbacks[e];
            delete this.callbacks[e], o && (n.error ? o(Tl(n.error)) : o(null, Tl(n.data)));
          } else {
            const o = /* @__PURE__ */ new Set(), u = n.hasCallback ? (f, v) => {
              this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: f ? lo(f) : null, data: lo(v, o) }, o);
            } : () => {
            }, l = Tl(n.data);
            if (this.parent[n.type])
              this.parent[n.type](n.sourceMapId, l, u);
            else if (this.parent.getWorkerSource) {
              const f = n.type.split(".");
              this.parent.getWorkerSource(n.sourceMapId, f[0], l.source, l.scope)[f[1]](l, u);
            } else
              u(new Error(`Could not find function ${n.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
        }
      }
      var af = { workerUrl: "", workerClass: null, workerParams: void 0 };
      const rg = "mapboxgl_preloaded_worker_pool";
      class Th {
        constructor() {
          this.active = {};
        }
        acquire(e, n = Th.workerCount) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < n; )
              this.workers.push(af.workerClass != null ? new af.workerClass() : new self.Worker(af.workerUrl, af.workerParams));
          return this.active[e] = !0, this.workers.slice();
        }
        release(e) {
          delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach((n) => {
            n.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[rg];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      Th.workerCount = 2;
      class Bu {
        constructor(e, n, o = "Worker", u = Th.workerCount) {
          this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = yo();
          const l = this.workerPool.acquire(this.id, u);
          for (let f = 0; f < l.length; f++) {
            const v = new Bu.Actor(l[f], n, this.id);
            v.name = `${o} ${f}`, this.actors.push(v);
          }
          this.ready = !1, this.broadcast("checkIfReady", null, () => {
            this.ready = !0;
          });
        }
        broadcast(e, n, o) {
          Rn(this.actors, (u, l) => {
            u.send(e, n, l);
          }, o = o || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e) => {
            e.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      let lf, og;
      function tm() {
        return lf || (lf = new Th()), lf;
      }
      Bu.Actor = $x;
      const ag = new ki(0, 0, 0);
      var im = ((r) => (r[r.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED", r[r.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO", r[r.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD", r))(im || {}), nm = ((r) => (r[r.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED", r[r.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT", r[r.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND", r[r.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE", r))(nm || {}), cf = ((r) => (r[r.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED", r[r.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER", r[r.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP", r[r.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND", r[r.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL", r))(cf || {}), Xx = ((r) => (r[r.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED", r[r.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE", r[r.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL", r))(Xx || {}), Nu = ((r) => (r[r.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED", r[r.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE", r[r.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE", r[r.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD", r[r.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC", r[r.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE", r))(Nu || {}), Yx = ((r) => (r[r.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED", r[r.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE", r[r.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA", r))(Yx || {});
      function f2(r, e, n) {
        r === 1 && e.icons.push(function(o, u) {
          return function(l) {
            if (l.usvg_tree.height || (l.usvg_tree.height = l.usvg_tree.width), !l.metadata)
              return l;
            const { metadata: f } = l;
            if (f.content_area) {
              const { content_area: v } = f;
              v.top == null && (v.top = v.left), v.width == null && (v.width = l.usvg_tree.width), v.height == null && (v.height = v.width);
            }
            return f.stretch_x && f.stretch_x.length && Kx(f, "x"), f.stretch_y && f.stretch_y.length && Kx(f, "y"), l;
          }(o.readFields(p2, { name: void 0 }, u));
        }(n, n.readVarint() + n.pos));
      }
      function Kx(r, e) {
        const n = [], o = r[`stretch_${e}`];
        let u = null;
        for (let l = 0; l < o.length; l++)
          u === null ? u = n.length === 0 ? o[0] : n[n.length - 1][1] + o[l] : (n.push([u, u + o[l]]), u = null);
        r[`stretch_${e}_areas`] = n;
      }
      function p2(r, e, n) {
        r === 1 ? e.name = n.readString() : r === 2 ? e.metadata = function(o, u) {
          return o.readFields(m2, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, u);
        }(n, n.readVarint() + n.pos) : r === 3 && (e.usvg_tree = function(o, u) {
          return o.readFields(y2, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, u);
        }(n, n.readVarint() + n.pos), e.data = "usvg_tree");
      }
      function m2(r, e, n) {
        r === 1 ? e.stretch_x = n.readPackedVarint() : r === 2 ? e.stretch_y = n.readPackedVarint() : r === 3 ? e.content_area = function(o, u) {
          return o.readFields(_2, { left: 0 }, u);
        }(n, n.readVarint() + n.pos) : r === 4 && e.variables.push(function(o, u) {
          return o.readFields(g2, { name: void 0 }, u);
        }(n, n.readVarint() + n.pos));
      }
      function _2(r, e, n) {
        r === 1 ? e.left = n.readVarint() : r === 2 ? e.width = n.readVarint() : r === 3 ? e.top = n.readVarint() : r === 4 && (e.height = n.readVarint());
      }
      function g2(r, e, n) {
        r === 1 ? e.name = n.readString() : r === 2 && (e.rgb_color = om(n.readVarint()), e.value = "rgb_color");
      }
      function y2(r, e, n) {
        r === 1 ? e.width = e.height = n.readVarint() : r === 2 ? e.height = n.readVarint() : r === 3 ? e.children.push(sm(n, n.readVarint() + n.pos)) : r === 4 ? e.linear_gradients.push(function(o, u) {
          return o.readFields(S2, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, u);
        }(n, n.readVarint() + n.pos)) : r === 5 ? e.radial_gradients.push(function(o, u) {
          return o.readFields(A2, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, u);
        }(n, n.readVarint() + n.pos)) : r === 7 ? e.clip_paths.push(function(o, u) {
          return o.readFields(P2, { children: [] }, u);
        }(n, n.readVarint() + n.pos)) : r === 8 && e.masks.push(function(o, u) {
          const l = o.readFields(C2, { left: 0, width: 20, mask_type: 1, children: [] }, u);
          return l.height == null && (l.height = l.width), l.top == null && (l.top = l.left), l;
        }(n, n.readVarint() + n.pos));
      }
      function sm(r, e) {
        return r.readFields(x2, {}, e);
      }
      function x2(r, e, n) {
        r === 1 ? (e.group = function(o, u) {
          return o.readFields(v2, { opacity: 255, children: [] }, u);
        }(n, n.readVarint() + n.pos), e.node = "group") : r === 2 && (e.path = function(o, u) {
          return o.readFields(w2, { paint_order: 1, commands: [], step: 1, diffs: [], rule: 1 }, u);
        }(n, n.readVarint() + n.pos), e.node = "path");
      }
      function v2(r, e, n) {
        r === 1 ? e.transform = rm(n, n.readVarint() + n.pos) : r === 2 ? e.opacity = n.readVarint() : r === 5 ? e.clip_path_idx = n.readVarint() : r === 6 ? e.mask_idx = n.readVarint() : r === 7 && e.children.push(sm(n, n.readVarint() + n.pos));
      }
      function rm(r, e) {
        return r.readFields(b2, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e);
      }
      function b2(r, e, n) {
        r === 1 ? e.sx = n.readFloat() : r === 2 ? e.ky = n.readFloat() : r === 3 ? e.kx = n.readFloat() : r === 4 ? e.sy = n.readFloat() : r === 5 ? e.tx = n.readFloat() : r === 6 && (e.ty = n.readFloat());
      }
      function w2(r, e, n) {
        r === 1 ? e.fill = function(o, u) {
          return o.readFields(T2, { rgb_color: ag, paint: "rgb_color", opacity: 255 }, u);
        }(n, n.readVarint() + n.pos) : r === 2 ? e.stroke = function(o, u) {
          return o.readFields(M2, { rgb_color: ag, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, u);
        }(n, n.readVarint() + n.pos) : r === 3 ? e.paint_order = n.readVarint() : r === 5 ? n.readPackedVarint(e.commands) : r === 6 ? e.step = n.readFloat() : r === 7 ? n.readPackedSVarint(e.diffs) : r === 8 && (e.rule = n.readVarint());
      }
      function T2(r, e, n) {
        r === 1 ? (e.rgb_color = om(n.readVarint()), e.paint = "rgb_color") : r === 2 ? (e.linear_gradient_idx = n.readVarint(), e.paint = "linear_gradient_idx") : r === 3 ? (e.radial_gradient_idx = n.readVarint(), e.paint = "radial_gradient_idx") : r === 5 && (e.opacity = n.readVarint());
      }
      function om(r) {
        return new ki((r >> 16 & 255) / 255, (r >> 8 & 255) / 255, (255 & r) / 255, 1);
      }
      function M2(r, e, n) {
        r === 1 ? (e.rgb_color = om(n.readVarint()), e.paint = "rgb_color") : r === 2 ? (e.linear_gradient_idx = n.readVarint(), e.paint = "linear_gradient_idx") : r === 3 ? (e.radial_gradient_idx = n.readVarint(), e.paint = "radial_gradient_idx") : r === 5 ? n.readPackedFloat(e.dasharray) : r === 6 ? e.dashoffset = n.readFloat() : r === 7 ? e.miterlimit = n.readFloat() : r === 8 ? e.opacity = n.readVarint() : r === 9 ? e.width = n.readFloat() : r === 10 ? e.linecap = n.readVarint() : r === 11 && (e.linejoin = n.readVarint());
      }
      function S2(r, e, n) {
        r === 1 ? e.transform = rm(n, n.readVarint() + n.pos) : r === 2 ? e.spread_method = n.readVarint() : r === 3 ? e.stops.push(Jx(n, n.readVarint() + n.pos)) : r === 4 ? e.x1 = n.readFloat() : r === 5 ? e.y1 = n.readFloat() : r === 6 ? e.x2 = n.readFloat() : r === 7 && (e.y2 = n.readFloat());
      }
      function Jx(r, e) {
        return r.readFields(E2, { offset: 0, opacity: 255, rgb_color: ag }, e);
      }
      function E2(r, e, n) {
        r === 1 ? e.offset = n.readFloat() : r === 2 ? e.opacity = n.readVarint() : r === 3 && (e.rgb_color = om(n.readVarint()));
      }
      function A2(r, e, n) {
        r === 1 ? e.transform = rm(n, n.readVarint() + n.pos) : r === 2 ? e.spread_method = n.readVarint() : r === 3 ? e.stops.push(Jx(n, n.readVarint() + n.pos)) : r === 4 ? e.cx = n.readFloat() : r === 5 ? e.cy = n.readFloat() : r === 6 ? e.r = n.readFloat() : r === 7 ? e.fx = n.readFloat() : r === 8 ? e.fy = n.readFloat() : r === 9 && (e.fr = n.readFloat());
      }
      function P2(r, e, n) {
        r === 1 ? e.transform = rm(n, n.readVarint() + n.pos) : r === 2 ? e.clip_path_idx = n.readVarint() : r === 3 && e.children.push(sm(n, n.readVarint() + n.pos));
      }
      function C2(r, e, n) {
        r === 1 ? e.left = e.top = n.readFloat() : r === 2 ? e.width = e.height = n.readFloat() : r === 3 ? e.top = n.readFloat() : r === 4 ? e.height = n.readFloat() : r === 5 ? e.mask_type = n.readVarint() : r === 6 ? e.mask_idx = n.readVarint() : r === 7 && e.children.push(sm(n, n.readVarint() + n.pos));
      }
      class I2 {
        static calculate(e, n) {
          const o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
          if (Object.keys(e).length === 0)
            return o;
          n.forEach((l) => {
            u.set(l.name, l.rgb_color || new ki(0, 0, 0));
          });
          for (const [l, f] of Object.entries(e))
            u.has(l) ? o.set(u.get(l).toStringPremultipliedAlpha(), f) : console.warn(`Ignoring unknown image variable "${l}"`);
          return o;
        }
      }
      function Vu(r, e = 255, n) {
        const o = e / 255, u = r.toStringPremultipliedAlpha(), l = n.has(u) ? n.get(u).clone() : r.clone();
        return l.a = o, l.toString();
      }
      function lg(r, e) {
        if (!mt()) {
          const n = document.createElement("canvas");
          return n.width = r, n.height = e, n;
        }
        return new OffscreenCanvas(r, e);
      }
      function L2(r, e) {
        const n = I2.calculate(e.params, r.metadata ? r.metadata.variables : []), o = r.usvg_tree, u = o.width, l = o.height, f = e.transform ? e.transform : new DOMMatrix(), v = Math.max(1, Math.round(u * f.a)), S = Math.max(1, Math.round(l * f.d)), D = new DOMMatrix([v / u, 0, 0, S / l, 0, 0]), x = lg(v, S).getContext("2d");
        return cg(x, D, o, o, n), x.getImageData(0, 0, v, S);
      }
      function cg(r, e, n, o, u) {
        for (const l of o.children)
          Qx(r, e, n, l, u);
      }
      function Qx(r, e, n, o, u) {
        o.group ? (r.save(), function(l, f, v, S, D) {
          const x = S.mask_idx != null ? v.masks[S.mask_idx] : null, A = S.clip_path_idx != null ? v.clip_paths[S.clip_path_idx] : null;
          if (S.transform && (f = hf(S.transform).preMultiplySelf(f)), !function(C, k, V) {
            return C.opacity !== 255 || k || V;
          }(S, A != null, x != null))
            return void cg(l, f, v, S, D);
          const I = lg(l.canvas.width, l.canvas.height), M = I.getContext("2d");
          A && sv(M, f, v, A), cg(M, f, v, S, D), x && rv(M, f, v, x, D), l.globalAlpha = S.opacity / 255, l.drawImage(I, 0, 0);
        }(r, e, n, o.group, u), r.restore()) : o.path && (r.save(), function(l, f, v, S, D) {
          const x = ov(S);
          l.setTransform(f), S.paint_order === Xx.PAINT_ORDER_FILL_AND_STROKE ? (ev(l, v, S, x, D), tv(l, v, S, x, D)) : (tv(l, v, S, x, D), ev(l, v, S, x, D));
        }(r, e, n, o.path, u), r.restore());
      }
      function ev(r, e, n, o, u) {
        const l = n.fill;
        if (!l)
          return;
        const f = l.opacity / 255;
        switch (l.paint) {
          case "rgb_color":
            r.fillStyle = Vu(l.rgb_color, l.opacity, u);
            break;
          case "linear_gradient_idx":
            r.fillStyle = iv(r, e.linear_gradients[l.linear_gradient_idx], f, u);
            break;
          case "radial_gradient_idx":
            r.fillStyle = nv(r, e.radial_gradients[l.radial_gradient_idx], f, u);
        }
        let v;
        switch (n.rule) {
          case im.PATH_RULE_NON_ZERO:
            v = "nonzero";
            break;
          case im.PATH_RULE_EVEN_ODD:
            v = "evenodd";
        }
        r.fill(o, v);
      }
      function tv(r, e, n, o, u) {
        const l = n.stroke;
        if (!l)
          return;
        r.lineWidth = l.width, r.miterLimit = l.miterlimit, r.setLineDash(l.dasharray), r.lineDashOffset = l.dashoffset;
        const f = l.opacity / 255;
        switch (l.paint) {
          case "rgb_color":
            r.strokeStyle = Vu(l.rgb_color, l.opacity, u);
            break;
          case "linear_gradient_idx":
            r.strokeStyle = iv(r, e.linear_gradients[l.linear_gradient_idx], f, u);
            break;
          case "radial_gradient_idx":
            r.strokeStyle = nv(r, e.radial_gradients[l.radial_gradient_idx], f, u);
        }
        switch (l.linejoin) {
          case cf.LINE_JOIN_MITER_CLIP:
          case cf.LINE_JOIN_MITER:
            r.lineJoin = "miter";
            break;
          case cf.LINE_JOIN_ROUND:
            r.lineJoin = "round";
            break;
          case cf.LINE_JOIN_BEVEL:
            r.lineJoin = "bevel";
        }
        switch (l.linecap) {
          case nm.LINE_CAP_BUTT:
            r.lineCap = "butt";
            break;
          case nm.LINE_CAP_ROUND:
            r.lineCap = "round";
            break;
          case nm.LINE_CAP_SQUARE:
            r.lineCap = "square";
        }
        r.stroke(o);
      }
      function iv(r, e, n, o) {
        if (e.stops.length === 1) {
          const I = e.stops[0];
          return Vu(I.rgb_color, I.opacity * n, o);
        }
        const u = hf(e.transform), { x1: l, y1: f, x2: v, y2: S } = e, D = u.transformPoint(new DOMPoint(l, f)), x = u.transformPoint(new DOMPoint(v, S)), A = r.createLinearGradient(D.x, D.y, x.x, x.y);
        for (const I of e.stops)
          A.addColorStop(I.offset, Vu(I.rgb_color, I.opacity * n, o));
        return A;
      }
      function nv(r, e, n, o) {
        if (e.stops.length === 1) {
          const I = e.stops[0];
          return Vu(I.rgb_color, I.opacity * n, o);
        }
        const u = hf(e.transform), { fx: l, fy: f, cx: v, cy: S } = e, D = u.transformPoint(new DOMPoint(l, f)), x = u.transformPoint(new DOMPoint(v, S)), A = r.createRadialGradient(D.x, D.y, 0, x.x, x.y, e.r * ((u.a + u.d) / 2));
        for (const I of e.stops)
          A.addColorStop(I.offset, Vu(I.rgb_color, I.opacity * n, o));
        return A;
      }
      function sv(r, e, n, o) {
        const u = hf(o.transform).preMultiplySelf(e), l = o.clip_path_idx != null ? n.clip_paths[o.clip_path_idx] : null;
        l && sv(r, u, n, l);
        const f = new Path2D();
        let v;
        function S(D, x) {
          if (D.path) {
            const A = D.path;
            f.addPath(ov(A), x), A.rule === im.PATH_RULE_EVEN_ODD && (v = "evenodd");
          } else if (D.group) {
            const A = D.group.transform ? hf(D.group.transform).preMultiplySelf(x) : x;
            for (const I of D.group.children)
              S(I, A);
          }
        }
        for (const D of o.children)
          S(D, u);
        r.clip(f, v);
      }
      function rv(r, e, n, o, u) {
        if (o.children.length === 0)
          return;
        const l = o.mask_idx != null ? n.masks[o.mask_idx] : null;
        l && rv(r, e, n, l, u);
        const f = r.canvas.width, v = r.canvas.height, S = lg(f, v), D = S.getContext("2d"), x = o.width, A = o.height, I = o.left, M = o.top, C = new Path2D(), k = new Path2D();
        k.rect(I, M, x, A), C.addPath(k, e), D.clip(C);
        for (const q of o.children)
          Qx(D, e, n, q, u);
        const V = D.getImageData(0, 0, f, v), U = V.data;
        if (o.mask_type === Yx.MASK_TYPE_LUMINANCE)
          for (let q = 0; q < U.length; q += 4)
            U[q + 3] = U[q + 3] / 255 * (0.2126 * U[q] + 0.7152 * U[q + 1] + 0.0722 * U[q + 2]);
        D.putImageData(V, 0, 0), r.globalCompositeOperation = "destination-in", r.drawImage(S, 0, 0);
      }
      function hf(r) {
        return r ? new DOMMatrix([r.sx, r.ky, r.kx, r.sy, r.tx, r.ty]) : new DOMMatrix();
      }
      function ov(r) {
        const e = new Path2D(), n = r.step;
        let o = r.diffs[0] * n, u = r.diffs[1] * n;
        e.moveTo(o, u);
        for (let l = 0, f = 2; l < r.commands.length; l++)
          switch (r.commands[l]) {
            case Nu.PATH_COMMAND_MOVE:
              o += r.diffs[f++] * n, u += r.diffs[f++] * n, e.moveTo(o, u);
              break;
            case Nu.PATH_COMMAND_LINE:
              o += r.diffs[f++] * n, u += r.diffs[f++] * n, e.lineTo(o, u);
              break;
            case Nu.PATH_COMMAND_QUAD: {
              const v = o + r.diffs[f++] * n, S = u + r.diffs[f++] * n;
              o = v + r.diffs[f++] * n, u = S + r.diffs[f++] * n, e.quadraticCurveTo(v, S, o, u);
              break;
            }
            case Nu.PATH_COMMAND_CUBIC: {
              const v = o + r.diffs[f++] * n, S = u + r.diffs[f++] * n, D = v + r.diffs[f++] * n, x = S + r.diffs[f++] * n;
              o = D + r.diffs[f++] * n, u = x + r.diffs[f++] * n, e.bezierCurveTo(v, S, D, x, o, u);
              break;
            }
            case Nu.PATH_COMMAND_CLOSE:
              e.closePath();
          }
        return e;
      }
      class hg {
        constructor(e) {
          this.capacity = e, this.cache = /* @__PURE__ */ new Map();
        }
        get(e) {
          if (!this.cache.has(e))
            return;
          const n = this.cache.get(e);
          return this.cache.delete(e), this.cache.set(e, n), n;
        }
        put(e, n) {
          this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, n);
        }
        delete(e) {
          this.cache.delete(e);
        }
      }
      class ug {
        constructor() {
          this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
        }
        static _getImage(e) {
          return new _r(e, e.data);
        }
        getFromCache(e, n, o) {
          return this.cacheMap.has(o) || this.cacheMap.set(o, new hg(150)), this.cacheMap.get(o).get(Io(e.serialize(), n));
        }
        setInCache(e, n, o, u) {
          this.cacheDependenciesMap.has(u) || this.cacheDependenciesMap.set(u, /* @__PURE__ */ new Map()), this.cacheMap.has(u) || this.cacheMap.set(u, new hg(150));
          const l = this.cacheDependenciesMap.get(u);
          l.get(Io(e.id, o)) || l.set(Io(e.id, o), /* @__PURE__ */ new Set());
          const f = this.cacheMap.get(u), v = e.serialize();
          l.get(Io(e.id, o)).add(v), f.put(Io(e.serialize(), o), n);
        }
        removeImagesFromCacheByIds(e, n, o = "") {
          if (!this.cacheMap.has(o) || !this.cacheDependenciesMap.has(o))
            return;
          const u = this.cacheMap.get(o), l = this.cacheDependenciesMap.get(o);
          for (const f of e)
            if (l.has(Io(f, n))) {
              for (const v of l.get(Io(f, n)))
                u.delete(v);
              l.delete(Io(f, n));
            }
        }
        rasterize(e, n, o, u, l = L2) {
          const f = this.getFromCache(e, o, u);
          if (f)
            return f.clone();
          const v = l(n.icon, e.options), S = ug._getImage(v);
          return this.setInCache(e, S, o, u), S.clone();
        }
      }
      class av {
        constructor(e) {
          this.size = e, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(e, n) {
          const o = this.toIdx(e, n);
          return { min: this.minimums[o], max: this.maximums[o] };
        }
        isLeaf(e, n) {
          return this.leaves[this.toIdx(e, n)];
        }
        toIdx(e, n) {
          return n * this.size + e;
        }
      }
      function lv(r, e, n, o) {
        let u = 0, l = Number.MAX_VALUE;
        for (let f = 0; f < 3; f++)
          if (Math.abs(o[f]) < 1e-15) {
            if (n[f] < r[f] || n[f] > e[f])
              return null;
          } else {
            const v = 1 / o[f];
            let S = (r[f] - n[f]) * v, D = (e[f] - n[f]) * v;
            if (S > D) {
              const x = S;
              S = D, D = x;
            }
            if (S > u && (u = S), D < l && (l = D), u > l)
              return null;
          }
        return u;
      }
      function cv(r, e, n, o, u, l, f, v, S, D, x) {
        const A = o - r, I = u - e, M = l - n, C = f - r, k = v - e, V = S - n, U = x[1] * V - x[2] * k, q = x[2] * C - x[0] * V, $ = x[0] * k - x[1] * C, H = A * U + I * q + M * $;
        if (Math.abs(H) < 1e-15)
          return null;
        const K = 1 / H, Q = D[0] - r, ie = D[1] - e, fe = D[2] - n, de = (Q * U + ie * q + fe * $) * K;
        if (de < 0 || de > 1)
          return null;
        const ue = ie * M - fe * I, Se = fe * A - Q * M, me = Q * I - ie * A, Ee = (x[0] * ue + x[1] * Se + x[2] * me) * K;
        return Ee < 0 || de + Ee > 1 ? null : (C * ue + k * Se + V * me) * K;
      }
      function hv(r, e, n) {
        return (r - e) / (n - e);
      }
      function uv(r, e, n, o, u, l, f, v, S) {
        const D = 1 << n, x = l - o, A = f - u, I = (r + 1) / D * x + o, M = (e + 0) / D * A + u, C = (e + 1) / D * A + u;
        v[0] = (r + 0) / D * x + o, v[1] = M, S[0] = I, S[1] = C;
      }
      class dv {
        constructor(e) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const n = function(l) {
            const f = Math.ceil(Math.log2(l.dim / 8)), v = [];
            let S = Math.ceil(Math.pow(2, f));
            const D = 1 / S, x = (M, C, k, V, U) => {
              const q = V ? 1 : 0, $ = (M + 1) * k - q, H = C * k, K = (C + 1) * k - q;
              U[0] = M * k, U[1] = H, U[2] = $, U[3] = K;
            };
            let A = new av(S);
            const I = [];
            for (let M = 0; M < S * S; M++) {
              x(M % S, Math.floor(M / S), D, !1, I);
              const C = Tc(I[0], I[1], l), k = Tc(I[2], I[1], l), V = Tc(I[2], I[3], l), U = Tc(I[0], I[3], l);
              A.minimums.push(Math.min(C, k, V, U)), A.maximums.push(Math.max(C, k, V, U)), A.leaves.push(1);
            }
            for (v.push(A), S /= 2; S >= 1; S /= 2) {
              const M = v[v.length - 1];
              A = new av(S);
              for (let C = 0; C < S * S; C++) {
                x(C % S, Math.floor(C / S), 2, !0, I);
                const k = M.getElevation(I[0], I[1]), V = M.getElevation(I[2], I[1]), U = M.getElevation(I[2], I[3]), q = M.getElevation(I[0], I[3]), $ = M.isLeaf(I[0], I[1]), H = M.isLeaf(I[2], I[1]), K = M.isLeaf(I[2], I[3]), Q = M.isLeaf(I[0], I[3]), ie = Math.min(k.min, V.min, U.min, q.min), fe = Math.max(k.max, V.max, U.max, q.max), de = $ && H && K && Q;
                A.maximums.push(fe), A.minimums.push(ie), A.leaves.push(fe - ie <= 5 && de ? 1 : 0);
              }
              v.push(A);
            }
            return v;
          }(this.dem), o = n.length - 1, u = n[o];
          this._addNode(u.minimums[0], u.maximums[0], u.leaves[0]), this._construct(n, 0, 0, o, 0);
        }
        raycastRoot(e, n, o, u, l, f, v = 1) {
          return lv([e, n, -100], [o, u, this.maximums[0] * v], l, f);
        }
        raycast(e, n, o, u, l, f, v = 1) {
          if (!this.nodeCount)
            return null;
          const S = this.raycastRoot(e, n, o, u, l, f, v);
          if (S == null)
            return null;
          const D = [], x = [], A = [], I = [], M = [{ idx: 0, t: S, nodex: 0, nodey: 0, depth: 0 }];
          for (; M.length > 0; ) {
            const { idx: C, t: k, nodex: V, nodey: U, depth: q } = M.pop();
            if (this.leaves[C]) {
              uv(V, U, q, e, n, o, u, A, I);
              const H = 1 << q, K = (V + 0) / H, Q = (V + 1) / H, ie = (U + 0) / H, fe = (U + 1) / H, de = Tc(K, ie, this.dem) * v, ue = Tc(Q, ie, this.dem) * v, Se = Tc(Q, fe, this.dem) * v, me = Tc(K, fe, this.dem) * v, Ee = cv(A[0], A[1], de, I[0], A[1], ue, I[0], I[1], Se, l, f), ze = cv(I[0], I[1], Se, A[0], I[1], me, A[0], A[1], de, l, f), Ie = Math.min(Ee !== null ? Ee : Number.MAX_VALUE, ze !== null ? ze : Number.MAX_VALUE);
              if (Ie !== Number.MAX_VALUE)
                return Ie;
              {
                const Re = De.vec3.scaleAndAdd([], l, f, k);
                if (fv(de, ue, me, Se, hv(Re[0], A[0], I[0]), hv(Re[1], A[1], I[1])) >= Re[2])
                  return k;
              }
              continue;
            }
            let $ = 0;
            for (let H = 0; H < this._siblingOffset.length; H++) {
              uv((V << 1) + this._siblingOffset[H][0], (U << 1) + this._siblingOffset[H][1], q + 1, e, n, o, u, A, I), A[2] = -100, I[2] = this.maximums[this.childOffsets[C] + H] * v;
              const K = lv(A, I, l, f);
              if (K != null) {
                const Q = K;
                D[H] = Q;
                let ie = !1;
                for (let fe = 0; fe < $ && !ie; fe++)
                  Q >= D[x[fe]] && (x.splice(fe, 0, H), ie = !0);
                ie || (x[$] = H), $++;
              }
            }
            for (let H = 0; H < $; H++) {
              const K = x[H];
              M.push({ idx: this.childOffsets[C] + K, t: D[K], nodex: (V << 1) + this._siblingOffset[K][0], nodey: (U << 1) + this._siblingOffset[K][1], depth: q + 1 });
            }
          }
          return null;
        }
        _addNode(e, n, o) {
          return this.minimums.push(e), this.maximums.push(n), this.leaves.push(o), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(e, n, o, u, l) {
          if (e[u].isLeaf(n, o) === 1)
            return;
          this.childOffsets[l] || (this.childOffsets[l] = this.nodeCount);
          const f = u - 1, v = e[f];
          let S = 0, D = 0;
          for (let x = 0; x < this._siblingOffset.length; x++) {
            const A = 2 * n + this._siblingOffset[x][0], I = 2 * o + this._siblingOffset[x][1], M = v.getElevation(A, I), C = v.isLeaf(A, I), k = this._addNode(M.min, M.max, C);
            C && (S |= 1 << x), D || (D = k);
          }
          for (let x = 0; x < this._siblingOffset.length; x++)
            S & 1 << x || this._construct(e, 2 * n + this._siblingOffset[x][0], 2 * o + this._siblingOffset[x][1], f, D + x);
        }
      }
      function fv(r, e, n, o, u, l) {
        return ei(ei(r, n, l), ei(e, o, l), u);
      }
      function Tc(r, e, n) {
        const o = n.dim, u = si(r * o - 0.5, 0, o - 1), l = si(e * o - 0.5, 0, o - 1), f = Math.floor(u), v = Math.floor(l), S = Math.min(f + 1, o - 1), D = Math.min(v + 1, o - 1);
        return fv(n.get(f, v), n.get(S, v), n.get(f, D), n.get(S, D), u - f, l - v);
      }
      const z2 = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function D2(r, e, n) {
        return (256 * r * 256 + 256 * e + n) / 10 - 1e4;
      }
      function k2(r, e, n) {
        return 256 * r + e + n / 256 - 32768;
      }
      class am {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(e, n, o, u = !1) {
          if (this.uid = e, n.height !== n.width)
            throw new RangeError("DEM tiles must be square");
          if (o && o !== "mapbox" && o !== "terrarium")
            return void mi(`"${o}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = n.height;
          const l = this.dim = n.height - 2, f = new Uint32Array(n.data.buffer);
          if (this.pixels = new Uint8Array(n.data.buffer), this.floatView = new Float32Array(n.data.buffer), this.borderReady = u, this._modifiedForSources = {}, !u) {
            for (let S = 0; S < l; S++)
              f[this._idx(-1, S)] = f[this._idx(0, S)], f[this._idx(l, S)] = f[this._idx(l - 1, S)], f[this._idx(S, -1)] = f[this._idx(S, 0)], f[this._idx(S, l)] = f[this._idx(S, l - 1)];
            f[this._idx(-1, -1)] = f[this._idx(0, 0)], f[this._idx(l, -1)] = f[this._idx(l - 1, 0)], f[this._idx(-1, l)] = f[this._idx(0, l - 1)], f[this._idx(l, l)] = f[this._idx(l - 1, l - 1)];
          }
          const v = o === "terrarium" ? k2 : D2;
          for (let S = 0; S < f.length; ++S) {
            const D = 4 * S;
            this.floatView[S] = v(this.pixels[D], this.pixels[D + 1], this.pixels[D + 2]);
          }
          this._timestamp = Ct.now();
        }
        _buildQuadTree() {
          this._tree = new dv(this);
        }
        get(e, n, o = !1) {
          o && (e = si(e, -1, this.dim), n = si(n, -1, this.dim));
          const u = this._idx(e, n);
          return this.floatView[u];
        }
        set(e, n, o) {
          const u = this._idx(e, n), l = this.floatView[u];
          return this.floatView[u] = o, o - l;
        }
        static getUnpackVector(e) {
          return z2[e];
        }
        _idx(e, n) {
          if (e < -1 || e >= this.dim + 1 || n < -1 || n >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (e + 1);
        }
        static pack(e, n) {
          const o = [0, 0, 0, 0], u = am.getUnpackVector(n);
          let l = Math.floor((e + u[3]) / u[2]);
          return o[2] = l % 256, l = Math.floor(l / 256), o[1] = l % 256, l = Math.floor(l / 256), o[0] = l, o;
        }
        getPixels() {
          return new zy({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(e, n, o) {
          if (this.dim !== e.dim)
            throw new Error("dem dimension mismatch");
          let u = n * this.dim, l = n * this.dim + this.dim, f = o * this.dim, v = o * this.dim + this.dim;
          switch (n) {
            case -1:
              u = l - 1;
              break;
            case 1:
              l = u + 1;
          }
          switch (o) {
            case -1:
              f = v - 1;
              break;
            case 1:
              v = f + 1;
          }
          const S = -n * this.dim, D = -o * this.dim;
          for (let x = f; x < v; x++)
            for (let A = u; A < l; A++) {
              const I = 4 * this._idx(A, x), M = 4 * this._idx(A + S, x + D);
              this.pixels[I + 0] = e.pixels[M + 0], this.pixels[I + 1] = e.pixels[M + 1], this.pixels[I + 2] = e.pixels[M + 2], this.pixels[I + 3] = e.pixels[M + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      function R2(r, e, n) {
        r === 1 ? e.headerLength = n.readFixed32() : r === 2 ? e.x = n.readVarint() : r === 3 ? e.y = n.readVarint() : r === 4 ? e.z = n.readVarint() : r === 5 && e.layers.push(function(o, u) {
          return o.readFields(V2, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, u);
        }(n, n.readVarint() + n.pos));
      }
      function O2(r, e, n) {
        r === 1 ? (e.delta_filter = function(o, u) {
          return o.readFields(F2, { blockSize: 0 }, u);
        }(n, n.readVarint() + n.pos), e.filter = "delta_filter") : r === 2 ? (n.readVarint(), e.filter = "zigzag_filter") : r === 3 ? (n.readVarint(), e.filter = "bitshuffle_filter") : r === 4 && (n.readVarint(), e.filter = "byteshuffle_filter");
      }
      function F2(r, e, n) {
        r === 1 && (e.blockSize = n.readVarint());
      }
      function B2(r, e, n) {
        r === 1 ? (n.readVarint(), e.codec = "gzip_data") : r === 2 ? (n.readVarint(), e.codec = "jpeg_image") : r === 3 ? (n.readVarint(), e.codec = "webp_image") : r === 4 && (n.readVarint(), e.codec = "png_image");
      }
      function N2(r, e, n) {
        let o = 0, u = 0;
        r === 1 ? e.firstByte = n.readFixed64() : r === 2 ? e.lastByte = n.readFixed64() : r === 3 ? e.filters.push(function(l, f) {
          return l.readFields(O2, {}, f);
        }(n, n.readVarint() + n.pos)) : r === 4 ? e.codec = function(l, f) {
          return l.readFields(B2, {}, f);
        }(n, n.readVarint() + n.pos) : r === 5 ? u = n.readFloat() : r === 6 ? o = n.readFloat() : r === 7 ? e.bands.push(n.readString()) : r === 8 ? e.offset = n.readDouble() : r === 9 && (e.scale = n.readDouble()), e.offset === 0 && (e.offset = u), e.scale === 0 && (e.scale = o);
      }
      function V2(r, e, n) {
        r === 1 ? e.version = n.readVarint() : r === 2 ? e.name = n.readString() : r === 3 ? e.units = n.readString() : r === 4 ? e.tileSize = n.readVarint() : r === 5 ? e.buffer = n.readVarint() : r === 6 ? e.pixelFormat = n.readVarint() : r === 7 && e.dataIndex.push(function(o, u) {
          return o.readFields(N2, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, u);
        }(n, n.readVarint() + n.pos));
      }
      function U2(r, e, n) {
        if (r === 2)
          (function(o, u, l) {
            o.readFields(j2, l, u);
          })(n, n.readVarint() + n.pos, e);
        else if (r === 3)
          throw new Error("Not implemented");
      }
      function j2(r, e, n) {
        if (r === 1) {
          let o = 0;
          const u = n.readVarint() + n.pos;
          for (; n.pos < u; )
            e[o++] = n.readVarint();
        }
      }
      function G2(r, e) {
        if (e.length !== 4)
          throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
        let n = e[3];
        for (let o = 2; o >= 1; o--) {
          const u = o === 1 ? 1 : 0, l = o === 2 ? 1 : 0;
          for (let f = 0; f < e[0]; f++) {
            const v = e[1] * f;
            for (let S = u; S < e[1]; S++) {
              const D = e[2] * (S + v);
              for (let x = l; x < e[2]; x++) {
                const A = e[3] * (x + D);
                for (let I = 0; I < e[3]; I++) {
                  const M = A + I;
                  r[M] += r[M - n];
                }
              }
            }
          }
          n *= e[o];
        }
        return r;
      }
      function Z2(r) {
        for (let e = 0, n = r.length; e < n; e++)
          r[e] = r[e] >>> 1 ^ -(1 & r[e]);
        return r;
      }
      function H2(r, e) {
        switch (e) {
          case "uint32":
            return r;
          case "uint16":
            for (let n = 0; n < r.length; n += 2) {
              const o = r[n], u = r[n + 1];
              r[n] = (240 & o) >> 4 | (61440 & o) >> 8 | (240 & u) << 4 | 61440 & u, r[n + 1] = 15 & o | (3840 & o) >> 4 | (15 & u) << 8 | (3840 & u) << 4;
            }
            return r;
          case "uint8":
            for (let n = 0; n < r.length; n += 4) {
              const o = r[n], u = r[n + 1], l = r[n + 2], f = r[n + 3];
              r[n + 0] = (192 & o) >> 6 | (192 & u) >> 4 | (192 & l) >> 2 | 192 & f, r[n + 1] = (48 & o) >> 4 | (48 & u) >> 2 | 48 & l | (48 & f) << 2, r[n + 2] = (12 & o) >> 2 | 12 & u | (12 & l) << 2 | (12 & f) << 4, r[n + 3] = 3 & o | (3 & u) << 2 | (3 & l) << 4 | (3 & f) << 6;
            }
            return r;
          default:
            throw new Error(`Invalid pixel format, "${e}"`);
        }
      }
      Ft(am, "DEMData"), Ft(dv, "DemMinMaxQuadTree", { omit: ["dem"] });
      var Oo = Uint8Array, uf = Uint16Array, q2 = Int32Array, pv = new Oo([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), mv = new Oo([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), W2 = new Oo([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _v = function(r, e) {
        for (var n = new uf(31), o = 0; o < 31; ++o)
          n[o] = e += 1 << r[o - 1];
        var u = new q2(n[30]);
        for (o = 1; o < 30; ++o)
          for (var l = n[o]; l < n[o + 1]; ++l)
            u[l] = l - n[o] << 5 | o;
        return { b: n, r: u };
      }, gv = _v(pv, 2), yv = gv.b, $2 = gv.r;
      yv[28] = 258, $2[258] = 28;
      for (var X2 = _v(mv, 0).b, xv = new uf(32768), os = 0; os < 32768; ++os) {
        var Uu = (43690 & os) >> 1 | (21845 & os) << 1;
        xv[os] = ((65280 & (Uu = (61680 & (Uu = (52428 & Uu) >> 2 | (13107 & Uu) << 2)) >> 4 | (3855 & Uu) << 4)) >> 8 | (255 & Uu) << 8) >> 1;
      }
      var df = function(r, e, n) {
        for (var o = r.length, u = 0, l = new uf(e); u < o; ++u)
          r[u] && ++l[r[u] - 1];
        var f, v = new uf(e);
        for (u = 1; u < e; ++u)
          v[u] = v[u - 1] + l[u - 1] << 1;
        f = new uf(1 << e);
        var S = 15 - e;
        for (u = 0; u < o; ++u)
          if (r[u])
            for (var D = u << 4 | r[u], x = e - r[u], A = v[r[u] - 1]++ << x, I = A | (1 << x) - 1; A <= I; ++A)
              f[xv[A] >> S] = D;
        return f;
      }, ff = new Oo(288);
      for (os = 0; os < 144; ++os)
        ff[os] = 8;
      for (os = 144; os < 256; ++os)
        ff[os] = 9;
      for (os = 256; os < 280; ++os)
        ff[os] = 7;
      for (os = 280; os < 288; ++os)
        ff[os] = 8;
      var vv = new Oo(32);
      for (os = 0; os < 32; ++os)
        vv[os] = 5;
      var Y2 = df(ff, 9), K2 = df(vv, 5), dg = function(r) {
        for (var e = r[0], n = 1; n < r.length; ++n)
          r[n] > e && (e = r[n]);
        return e;
      }, Aa = function(r, e, n) {
        var o = e / 8 | 0;
        return (r[o] | r[o + 1] << 8) >> (7 & e) & n;
      }, fg = function(r, e) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (7 & e);
      }, J2 = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Pa = function(r, e, n) {
        var o = new Error(e || J2[r]);
        if (o.code = r, Error.captureStackTrace && Error.captureStackTrace(o, Pa), !n)
          throw o;
        return o;
      }, Q2 = new Oo(0), eM = typeof TextDecoder < "u" && new TextDecoder();
      try {
        eM.decode(Q2, { stream: !0 });
      } catch {
      }
      const tM = { gzip_data: "gzip" };
      class na extends Error {
        constructor(e) {
          super(e), this.name = "MRTError";
        }
      }
      const iM = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, bv = { uint32: 1, uint16: 2, uint8: 4 }, nM = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
      let pg;
      class mg {
        constructor(e = 5) {
          this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e;
        }
        getLayer(e) {
          const n = this.layers[e];
          if (!n)
            throw new na(`Layer '${e}' not found`);
          return n;
        }
        getHeaderLength(e) {
          const n = new Uint8Array(e), o = new DataView(e);
          if (n[0] !== 13)
            throw new na("File is not a valid MRT.");
          return o.getUint32(1, !0);
        }
        parseHeader(e) {
          const n = new Uint8Array(e), o = this.getHeaderLength(e);
          if (n.length < o)
            throw new na(`Expected header with length >= ${o} but got buffer of length ${n.length}`);
          const u = function(l, f) {
            return l.readFields(R2, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
          }(new pg(n.subarray(0, o)));
          if (!isNaN(this.x) && (this.x !== u.x || this.y !== u.y || this.z !== u.z))
            throw new na(`Invalid attempt to parse header ${u.z}/${u.x}/${u.y} for tile ${this.z}/${this.x}/${this.y}`);
          this.x = u.x, this.y = u.y, this.z = u.z;
          for (const l of u.layers)
            this.layers[l.name] = new sM(l, { cacheSize: this._cacheSize });
          return this;
        }
        createDecodingTask(e) {
          const n = [], o = this.getLayer(e.layerName);
          for (let u of e.blockIndices) {
            const l = o.dataIndex[u], f = l.firstByte - e.firstByte, v = l.lastByte - e.firstByte;
            if (o._blocksInProgress.has(u))
              continue;
            const S = { layerName: o.name, firstByte: f, lastByte: v, pixelFormat: o.pixelFormat, blockIndex: u, blockShape: [l.bands.length].concat(o.bandShape), buffer: o.buffer, codec: l.codec.codec, filters: l.filters.map((D) => D.filter) };
            o._blocksInProgress.add(u), n.push(S);
          }
          return new wv(n, () => {
            n.forEach((u) => o._blocksInProgress.delete(u.blockIndex));
          }, (u, l) => {
            if (n.forEach((f) => o._blocksInProgress.delete(f.blockIndex)), u)
              throw u;
            l.forEach((f) => {
              this.getLayer(f.layerName).processDecodedData(f);
            });
          });
        }
      }
      class sM {
        constructor({ version: e, name: n, units: o, tileSize: u, pixelFormat: l, buffer: f, dataIndex: v }, S) {
          if (this.version = e, this.version !== 1)
            throw new na(`Cannot parse raster layer encoded with MRT version ${e}`);
          this.name = n, this.units = o, this.tileSize = u, this.buffer = f, this.pixelFormat = iM[l], this.dataIndex = v, this.bandShape = [u + 2 * f, u + 2 * f, bv[this.pixelFormat]], this._decodedBlocks = new hg(S ? S.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
        }
        get dimension() {
          return bv[this.pixelFormat];
        }
        get cacheSize() {
          return this._decodedBlocks.capacity;
        }
        getBandList() {
          return this.dataIndex.map(({ bands: e }) => e).flat();
        }
        processDecodedData(e) {
          const n = e.blockIndex.toString();
          this._decodedBlocks.get(n) || this._decodedBlocks.put(n, e.data);
        }
        getBlockForBand(e) {
          let n = 0;
          switch (typeof e) {
            case "string":
              for (const [o, u] of this.dataIndex.entries()) {
                for (const [l, f] of u.bands.entries())
                  if (f === e)
                    return { bandIndex: n + l, blockIndex: o, blockBandIndex: l };
                n += u.bands.length;
              }
              break;
            case "number":
              for (const [o, u] of this.dataIndex.entries()) {
                if (e >= n && e < n + u.bands.length)
                  return { bandIndex: e, blockIndex: o, blockBandIndex: e - n };
                n += u.bands.length;
              }
              break;
            default:
              throw new na(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`);
          }
          throw new na(`Band not found: ${JSON.stringify(e)}`);
        }
        getDataRange(e) {
          let n = 1 / 0, o = -1 / 0;
          const u = [], l = /* @__PURE__ */ new Set();
          for (const f of e) {
            const { blockIndex: v } = this.getBlockForBand(f);
            if (v < 0)
              throw new na(`Invalid band: ${JSON.stringify(f)}`);
            const S = this.dataIndex[v];
            u.includes(v) || u.push(v), l.add(v), n = Math.min(n, S.firstByte), o = Math.max(o, S.lastByte);
          }
          if (l.size > this.cacheSize)
            throw new na(`Number of blocks to decode (${l.size}) exceeds cache size (${this.cacheSize}).`);
          return { layerName: this.name, firstByte: n, lastByte: o, blockIndices: u };
        }
        hasBand(e) {
          const { blockIndex: n } = this.getBlockForBand(e);
          return n >= 0;
        }
        hasDataForBand(e) {
          const { blockIndex: n } = this.getBlockForBand(e);
          return n >= 0 && !!this._decodedBlocks.get(n.toString());
        }
        getBandView(e) {
          const { blockIndex: n, blockBandIndex: o } = this.getBlockForBand(e), u = this._decodedBlocks.get(n.toString());
          if (!u)
            throw new na(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`);
          const l = this.dataIndex[n], f = this.bandShape.reduce((D, x) => D * x, 1), v = o * f, S = u.subarray(v, v + f);
          return { data: S, bytes: new Uint8Array(S.buffer).subarray(S.byteOffset, S.byteOffset + S.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: l.offset, scale: l.scale };
        }
      }
      mg.setPbf = function(r) {
        pg = r;
      };
      class wv {
        constructor(e, n, o) {
          this.tasks = e, this._onCancel = n, this._onComplete = o, this._finalized = !1;
        }
        cancel() {
          this._finalized || (this._onCancel(), this._finalized = !0);
        }
        complete(e, n) {
          this._finalized || (this._onComplete(e, n), this._finalized = !0);
        }
      }
      mg.performDecoding = function(r, e) {
        const n = new Uint8Array(r);
        return Promise.all(e.tasks.map((o) => {
          const { layerName: u, firstByte: l, lastByte: f, pixelFormat: v, blockShape: S, blockIndex: D, filters: x, codec: A } = o, I = n.subarray(l, f + 1), M = new Uint32Array(S[0] * S[1] * S[2]);
          let C;
          if (A !== "gzip_data")
            throw new na(`Unhandled codec: ${A}`);
          return C = function(k, V) {
            if (!globalThis.DecompressionStream && V === "gzip_data")
              return Promise.resolve(((H = function(ie) {
                ie[0] == 31 && ie[1] == 139 && ie[2] == 8 || Pa(6, "invalid gzip data");
                var fe = ie[3], de = 10;
                4 & fe && (de += 2 + (ie[10] | ie[11] << 8));
                for (var ue = (fe >> 3 & 1) + (fe >> 4 & 1); ue > 0; ue -= !ie[de++])
                  ;
                return de + (2 & fe);
              }($ = k)) + 8 > $.length && Pa(6, "invalid gzip data"), function(ie, fe, de, ue) {
                var Se = ie.length;
                if (!Se || fe.f && !fe.l)
                  return de || new Oo(0);
                var me = !de, Ee = me || fe.i != 2, ze = fe.i;
                me && (de = new Oo(3 * Se));
                var Ie, Re, Ve = function(Dl) {
                  var Ec = de.length;
                  if (Dl > Ec) {
                    var Ac = new Oo(Math.max(2 * Ec, Dl));
                    Ac.set(de), de = Ac;
                  }
                }, Ue = fe.f || 0, Fe = fe.p || 0, et = fe.b || 0, dt = fe.l, tt = fe.d, Mt = fe.m, wt = fe.n, Pt = 8 * Se;
                do {
                  if (!dt) {
                    Ue = Aa(ie, Fe, 1);
                    var rt = Aa(ie, Fe + 1, 3);
                    if (Fe += 3, !rt) {
                      var Ut = ie[(hi = 4 + ((Fe + 7) / 8 | 0)) - 4] | ie[hi - 3] << 8, St = hi + Ut;
                      if (St > Se) {
                        ze && Pa(0);
                        break;
                      }
                      Ee && Ve(et + Ut), de.set(ie.subarray(hi, St), et), fe.b = et += Ut, fe.p = Fe = 8 * St, fe.f = Ue;
                      continue;
                    }
                    if (rt == 1)
                      dt = Y2, tt = K2, Mt = 9, wt = 5;
                    else if (rt == 2) {
                      var Nt = Aa(ie, Fe, 31) + 257, Qt = Aa(ie, Fe + 10, 15) + 4, pi = Nt + Aa(ie, Fe + 5, 31) + 1;
                      Fe += 14;
                      for (var gi = new Oo(pi), Pi = new Oo(19), yi = 0; yi < Qt; ++yi)
                        Pi[W2[yi]] = Aa(ie, Fe + 3 * yi, 7);
                      Fe += 3 * Qt;
                      var Ii = dg(Pi), fn = (1 << Ii) - 1, rn = df(Pi, Ii);
                      for (yi = 0; yi < pi; ) {
                        var hi, on = rn[Aa(ie, Fe, fn)];
                        if (Fe += 15 & on, (hi = on >> 4) < 16)
                          gi[yi++] = hi;
                        else {
                          var Qi = 0, pn = 0;
                          for (hi == 16 ? (pn = 3 + Aa(ie, Fe, 3), Fe += 2, Qi = gi[yi - 1]) : hi == 17 ? (pn = 3 + Aa(ie, Fe, 7), Fe += 3) : hi == 18 && (pn = 11 + Aa(ie, Fe, 127), Fe += 7); pn--; )
                            gi[yi++] = Qi;
                        }
                      }
                      var as = gi.subarray(0, Nt), ls = gi.subarray(Nt);
                      Mt = dg(as), wt = dg(ls), dt = df(as, Mt), tt = df(ls, wt);
                    } else
                      Pa(1);
                    if (Fe > Pt) {
                      ze && Pa(0);
                      break;
                    }
                  }
                  Ee && Ve(et + 131072);
                  for (var Kn = (1 << Mt) - 1, Vr = (1 << wt) - 1, Sn = Fe; ; Sn = Fe) {
                    var Ln = (Qi = dt[fg(ie, Fe) & Kn]) >> 4;
                    if ((Fe += 15 & Qi) > Pt) {
                      ze && Pa(0);
                      break;
                    }
                    if (Qi || Pa(2), Ln < 256)
                      de[et++] = Ln;
                    else {
                      if (Ln == 256) {
                        Sn = Fe, dt = null;
                        break;
                      }
                      var Tr = Ln - 254;
                      Ln > 264 && (Tr = Aa(ie, Fe, (1 << (Ms = pv[yi = Ln - 257])) - 1) + yv[yi], Fe += Ms);
                      var cs = tt[fg(ie, Fe) & Vr], to = cs >> 4;
                      if (cs || Pa(3), Fe += 15 & cs, ls = X2[to], to > 3) {
                        var Ms = mv[to];
                        ls += fg(ie, Fe) & (1 << Ms) - 1, Fe += Ms;
                      }
                      if (Fe > Pt) {
                        ze && Pa(0);
                        break;
                      }
                      Ee && Ve(et + 131072);
                      var sl = et + Tr;
                      if (et < ls) {
                        var Mc = 0 - ls, Sc = Math.min(ls, sl);
                        for (Mc + et < 0 && Pa(3); et < Sc; ++et)
                          de[et] = (void 0)[Mc + et];
                      }
                      for (; et < sl; ++et)
                        de[et] = de[et - ls];
                    }
                  }
                  fe.l = dt, fe.p = Sn, fe.b = et, fe.f = Ue, dt && (Ue = 1, fe.m = Mt, fe.d = tt, fe.n = wt);
                } while (!Ue);
                return et != de.length && me ? (Ie = de, ((Re = et) == null || Re > Ie.length) && (Re = Ie.length), new Oo(Ie.subarray(0, Re))) : de.subarray(0, et);
              }($.subarray(H, -8), { i: 2 }, new Oo(((U = $)[(q = U.length) - 4] | U[q - 3] << 8 | U[q - 2] << 16 | U[q - 1] << 24) >>> 0))));
            var U, q, $, H;
            const K = tM[V];
            if (!K)
              throw new Error(`Unhandled codec: ${V}`);
            const Q = new globalThis.DecompressionStream(K);
            return new Response(new Blob([k]).stream().pipeThrough(Q)).arrayBuffer().then((ie) => new Uint8Array(ie));
          }(I, A).then((k) => (function(V, U) {
            V.readFields(U2, U);
          }(new pg(k), M), new nM[v](M.buffer))), C.then((k) => {
            for (let V = x.length - 1; V >= 0; V--)
              switch (x[V]) {
                case "delta_filter":
                  G2(k, S);
                  break;
                case "zigzag_filter":
                  Z2(k);
                  break;
                case "bitshuffle_filter":
                  H2(k, v);
                  break;
                default:
                  throw new na(`Unhandled filter "${x[V]}"`);
              }
            return { layerName: u, blockIndex: D, data: k };
          }).catch((k) => {
            throw k;
          });
        }));
      }, Ft(wv, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
      let pf, _g, Ca, ju, gg, Gu = null;
      function Tv() {
        return Jn() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : _g || ge.DRACO_URL;
      }
      function Mv() {
        if (Jn() && self.worker && self.worker.meshoptUrl)
          return self.worker.meshoptUrl;
        if (ju)
          return ju;
        const r = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
        if (typeof WebAssembly != "object")
          throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
        return ju = WebAssembly.validate(r) ? ge.MESHOPT_SIMD_URL : ge.MESHOPT_URL, ju;
      }
      const lm = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, rM = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, mf = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function Sv(r, e, n) {
        const o = n.json.bufferViews.length, u = n.buffers.length;
        e.bufferView = o, n.json.bufferViews[o] = { buffer: u, byteLength: r.byteLength }, n.buffers[u] = r;
      }
      const yg = "KHR_draco_mesh_compression";
      function oM(r, e) {
        const n = r.extensions && r.extensions[yg];
        if (!n)
          return;
        const o = new Ca.Decoder(), u = Cv(e, n.bufferView), l = new Ca.Mesh();
        if (!o.DecodeArrayToMesh(u, u.byteLength, l))
          throw new Error("Failed to decode Draco mesh");
        const f = e.json.accessors[r.indices], v = lm[f.componentType], S = f.count * v.BYTES_PER_ELEMENT, D = Ca._malloc(S);
        v === Uint16Array ? o.GetTrianglesUInt16Array(l, S, D) : o.GetTrianglesUInt32Array(l, S, D), Sv(Ca.memory.buffer.slice(D, D + S), f, e), Ca._free(D);
        for (const x of Object.keys(n.attributes)) {
          const A = o.GetAttributeByUniqueId(l, n.attributes[x]), I = e.json.accessors[r.attributes[x]], M = rM[I.componentType], C = I.count * mf[I.type] * lm[I.componentType].BYTES_PER_ELEMENT, k = Ca._malloc(C);
          o.GetAttributeDataArrayForAllPoints(l, A, Ca[M], C, k), Sv(Ca.memory.buffer.slice(k, k + C), I, e), Ca._free(k);
        }
        o.destroy(), l.destroy(), delete r.extensions[yg];
      }
      const cm = "EXT_meshopt_compression";
      function aM(r, e) {
        if (!r.extensions || !r.extensions[cm])
          return;
        const n = r.extensions[cm], o = new Uint8Array(e.buffers[n.buffer], n.byteOffset || 0, n.byteLength || 0), u = new Uint8Array(n.count * n.byteStride);
        gg.decodeGltfBuffer(u, n.count, n.byteStride, o, n.mode, n.filter), r.buffer = e.buffers.length, r.byteOffset = 0, e.buffers[r.buffer] = u.buffer, delete r.extensions[cm];
      }
      const Ev = 1179937895, Av = new TextDecoder("utf8");
      function Pv(r, e) {
        return new URL(r, e).href;
      }
      function lM(r, e, n, o) {
        return fetch(Pv(r.uri, o)).then((u) => u.arrayBuffer()).then((u) => {
          e.buffers[n] = u;
        });
      }
      function Cv(r, e) {
        const n = r.json.bufferViews[e];
        return new Uint8Array(r.buffers[n.buffer], n.byteOffset || 0, n.byteLength);
      }
      function cM(r, e, n, o) {
        if (r.uri) {
          const u = Pv(r.uri, o);
          return fetch(u).then((l) => l.blob()).then((l) => createImageBitmap(l)).then((l) => {
            e.images[n] = l;
          });
        }
        if (r.bufferView !== void 0) {
          const u = Cv(e, r.bufferView), l = new Blob([u], { type: r.mimeType });
          return createImageBitmap(l).then((f) => {
            e.images[n] = f;
          });
        }
      }
      function Iv(r, e = 0, n) {
        const o = { json: null, images: [], buffers: [] };
        if (new Uint32Array(r, e, 1)[0] === Ev) {
          const x = new Uint32Array(r, e);
          let A = 2;
          const I = (x[A++] >> 2) - 3, M = x[A++] >> 2;
          if (A++, o.json = JSON.parse(Av.decode(x.subarray(A, A + M))), A += M, A < I) {
            const C = x[A++];
            A++;
            const k = e + (A << 2);
            o.buffers[0] = r.slice(k, k + C);
          }
        } else
          o.json = JSON.parse(Av.decode(new Uint8Array(r, e)));
        const { buffers: u, images: l, meshes: f, extensionsUsed: v, bufferViews: S } = o.json;
        let D = Promise.resolve();
        if (u) {
          const x = [];
          for (let A = 0; A < u.length; A++) {
            const I = u[A];
            I.uri ? x.push(lM(I, o, A, n)) : o.buffers[A] || (o.buffers[A] = null);
          }
          D = Promise.all(x);
        }
        return D.then(() => {
          const x = [], A = v && v.includes(yg), I = v && v.includes(cm);
          if (A && x.push(function() {
            if (!Ca)
              return pf ?? (pf = function(M) {
                let C, k = null;
                function V() {
                  C = new Uint8Array(k.buffer);
                }
                function U() {
                  throw new Error("Unexpected Draco error.");
                }
                const q = { a: { a: U, d: function($, H, K) {
                  return C.copyWithin($, H, H + K);
                }, c: function($) {
                  const H = C.length, K = Math.max($ >>> 0, Math.ceil(1.2 * H)), Q = Math.ceil((K - H) / 65536);
                  try {
                    return k.grow(Q), V(), !0;
                  } catch {
                    return !1;
                  }
                }, b: U } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(M, q) : M.then(($) => $.arrayBuffer()).then(($) => WebAssembly.instantiate($, q))).then(($) => {
                  const { Rb: H, Qb: K, P: Q, T: ie, X: fe, Ja: de, La: ue, Qa: Se, Va: me, Wa: Ee, eb: ze, jb: Ie, f: Re, e: Ve, yb: Ue, zb: Fe, Ab: et, Bb: dt, Db: tt, Gb: Mt } = $.instance.exports;
                  k = Ve;
                  const wt = (() => {
                    let Pt = 0, rt = 0, Ut = 0, St = 0;
                    return (Nt) => {
                      Ut && (H(St), H(Pt), rt += Ut, Ut = Pt = 0), Pt || (rt += 128, Pt = K(rt));
                      const Qt = Nt.length + 7 & -8;
                      let pi = Pt;
                      Qt >= rt && (Ut = Qt, pi = St = K(Qt));
                      for (let gi = 0; gi < Nt.length; gi++)
                        C[pi + gi] = Nt[gi];
                      return pi;
                    };
                  })();
                  return V(), Re(), { memory: Ve, _free: H, _malloc: K, Mesh: class {
                    constructor() {
                      this.ptr = Q();
                    }
                    destroy() {
                      ie(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = de();
                    }
                    destroy() {
                      Ie(this.ptr);
                    }
                    DecodeArrayToMesh(Pt, rt, Ut) {
                      const St = wt(Pt), Nt = ue(this.ptr, St, rt, Ut.ptr);
                      return !!fe(Nt);
                    }
                    GetAttributeByUniqueId(Pt, rt) {
                      return { ptr: Se(this.ptr, Pt.ptr, rt) };
                    }
                    GetTrianglesUInt16Array(Pt, rt, Ut) {
                      me(this.ptr, Pt.ptr, rt, Ut);
                    }
                    GetTrianglesUInt32Array(Pt, rt, Ut) {
                      Ee(this.ptr, Pt.ptr, rt, Ut);
                    }
                    GetAttributeDataArrayForAllPoints(Pt, rt, Ut, St, Nt) {
                      ze(this.ptr, Pt.ptr, rt.ptr, Ut, St, Nt);
                    }
                  }, DT_INT8: Ue(), DT_UINT8: Fe(), DT_INT16: et(), DT_UINT16: dt(), DT_UINT32: tt(), DT_FLOAT32: Mt() };
                });
              }(fetch(Tv())), pf.then((M) => {
                Ca = M, pf = void 0;
              }));
          }()), I && x.push(function() {
            if (gg)
              return;
            const M = function(C) {
              let k;
              const V = WebAssembly.instantiateStreaming(C, {}).then(($) => {
                k = $.instance, k.exports.__wasm_call_ctors();
              }), U = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, q = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
              return { ready: V, supported: !0, decodeGltfBuffer($, H, K, Q, ie, fe) {
                (function(de, ue, Se, me, Ee, ze, Ie) {
                  const Re = de.exports.sbrk, Ve = me + 3 & -4, Ue = Re(Ve * Ee), Fe = Re(ze.length), et = new Uint8Array(de.exports.memory.buffer);
                  et.set(ze, Fe);
                  const dt = ue(Ue, me, Ee, Fe, ze.length);
                  if (dt === 0 && Ie && Ie(Ue, Ve, Ee), Se.set(et.subarray(Ue, Ue + me * Ee)), Re(Ue - Re(0)), dt !== 0)
                    throw new Error(`Malformed buffer data: ${dt}`);
                })(k, k.exports[q[ie]], $, H, K, Q, k.exports[U[fe]]);
              } };
            }(fetch(Mv()));
            return M.ready.then(() => {
              gg = M;
            });
          }()), l)
            for (let M = 0; M < l.length; M++)
              x.push(cM(l[M], o, M, n));
          return (x.length ? Promise.all(x) : Promise.resolve()).then(() => {
            if (A && f)
              for (const { primitives: M } of f)
                for (const C of M)
                  oM(C, o);
            if (I && f && S)
              for (const M of S)
                aM(M, o);
            return o;
          });
        });
      }
      function Mh(r, e) {
        const n = r.json.bufferViews[e.bufferView], o = lm[e.componentType];
        return new o(r.buffers[n.buffer], (e.byteOffset || 0) + (n.byteOffset || 0), e.count * (n.byteStride && n.byteStride !== mf[e.type] * o.BYTES_PER_ELEMENT ? n.byteStride / o.BYTES_PER_ELEMENT : mf[e.type]));
      }
      function xg(r, e, n, o) {
        const u = lm[e.componentType], l = function(x) {
          switch (x) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              return 1;
          }
        }(u), f = r.json.bufferViews[e.bufferView], v = f.byteStride ? f.byteStride / u.BYTES_PER_ELEMENT : mf[e.type], S = n.float32, D = S.length / n.capacity;
        for (let x = 0, A = 0; x < e.count * v; x += v, A += D)
          for (let I = 0; I < D; I++)
            S[A + I] = o[x + I] * l;
        n._trim();
      }
      function hM(r, e, n) {
        const o = r.indices, u = r.attributes, l = {};
        l.indexArray = new qs();
        const f = e.json.accessors[o], v = f.count / 3;
        l.indexArray.reserve(v);
        const S = Mh(e, f);
        for (let I = 0; I < v; I++)
          l.indexArray.emplaceBack(S[3 * I], S[3 * I + 1], S[3 * I + 2]);
        l.indexArray._trim(), l.vertexArray = new va();
        const D = e.json.accessors[u.POSITION];
        l.vertexArray.reserve(D.count);
        const x = Mh(e, D);
        for (let I = 0; I < D.count; I++)
          l.vertexArray.emplaceBack(x[3 * I], x[3 * I + 1], x[3 * I + 2]);
        if (l.vertexArray._trim(), l.aabb = new Jt(D.min, D.max), l.centroid = function(I, M) {
          const C = [0, 0, 0], k = I.length;
          if (k > 0) {
            for (let V = 0; V < k; V++) {
              const U = 3 * I[V];
              C[0] += M[U], C[1] += M[U + 1], C[2] += M[U + 2];
            }
            C[0] /= k, C[1] /= k, C[2] /= k;
          }
          return C;
        }(S, x), u.COLOR_0 !== void 0) {
          const I = e.json.accessors[u.COLOR_0], M = mf[I.type], C = Mh(e, I);
          l.colorArray = M === 3 ? new va() : new Xa(), l.colorArray.resize(I.count), xg(e, I, l.colorArray, C);
        }
        if (u.NORMAL !== void 0) {
          l.normalArray = new va();
          const I = e.json.accessors[u.NORMAL];
          l.normalArray.resize(I.count);
          const M = Mh(e, I);
          xg(e, I, l.normalArray, M);
        }
        if (u.TEXCOORD_0 !== void 0 && n.length > 0) {
          l.texcoordArray = new Al();
          const I = e.json.accessors[u.TEXCOORD_0];
          l.texcoordArray.resize(I.count);
          const M = Mh(e, I);
          xg(e, I, l.texcoordArray, M);
        }
        if (u._FEATURE_ID_RGBA4444 !== void 0) {
          const I = e.json.accessors[u._FEATURE_ID_RGBA4444];
          e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (l.featureData = Mh(e, I));
        }
        u._FEATURE_RGBA4444 !== void 0 && (l.featureData = new Uint32Array(Mh(e, e.json.accessors[u._FEATURE_RGBA4444]).buffer));
        const A = r.material;
        return l.material = function(I, M) {
          const { emissiveFactor: C = [0, 0, 0], alphaMode: k = "OPAQUE", alphaCutoff: V = 0.5, normalTexture: U, occlusionTexture: q, emissiveTexture: $, doubleSided: H } = I, { baseColorFactor: K = [1, 1, 1, 1], metallicFactor: Q = 1, roughnessFactor: ie = 1, baseColorTexture: fe, metallicRoughnessTexture: de } = I.pbrMetallicRoughness || {}, ue = q ? M[q.index] : void 0;
          if (q && q.extensions && q.extensions.KHR_texture_transform && ue) {
            const Se = q.extensions.KHR_texture_transform;
            ue.offsetScale = [Se.offset[0], Se.offset[1], Se.scale[0], Se.scale[1]];
          }
          return { pbrMetallicRoughness: { baseColorFactor: new ki(...K), metallicFactor: Q, roughnessFactor: ie, baseColorTexture: fe ? M[fe.index] : void 0, metallicRoughnessTexture: de ? M[de.index] : void 0 }, doubleSided: H, emissiveFactor: C, alphaMode: k, alphaCutoff: V, normalTexture: U ? M[U.index] : void 0, occlusionTexture: ue, emissionTexture: $ ? M[$.index] : void 0, defined: I.defined === void 0 };
        }(A !== void 0 ? e.json.materials[A] : { defined: !1 }, n), l;
      }
      function Lv(r, e, n) {
        const { matrix: o, rotation: u, translation: l, scale: f, mesh: v, extras: S, children: D } = r, x = {};
        if (x.matrix = o || De.mat4.fromRotationTranslationScale([], u || [0, 0, 0, 1], l || [0, 0, 0], f || [1, 1, 1]), v !== void 0) {
          x.meshes = n[v];
          const A = x.anchor = [0, 0];
          for (const I of x.meshes) {
            const { min: M, max: C } = I.aabb;
            A[0] += M[0] + C[0], A[1] += M[1] + C[1];
          }
          A[0] = Math.floor(A[0] / x.meshes.length / 2), A[1] = Math.floor(A[1] / x.meshes.length / 2);
        }
        if (S && (S.id && (x.id = S.id), S.lights && (x.lights = function(A) {
          if (!A.length)
            return [];
          const I = function(U) {
            const q = atob(U), $ = new Uint8Array(q.length);
            for (let H = 0; H < q.length; H++)
              $[H] = q.codePointAt(H);
            return $;
          }(A), M = [], C = I.length / 24, k = new Uint16Array(I.buffer), V = new Float32Array(I.buffer);
          for (let U = 0; U < C; U++) {
            const q = k[2 * U * 6] / 30, $ = k[2 * U * 6 + 1] / 30, H = k[2 * U * 6 + 10] / 100, K = V[6 * U + 1], Q = V[6 * U + 2], ie = V[6 * U + 3], fe = V[6 * U + 4], de = ie - K, ue = fe - Q, Se = Math.hypot(de, ue);
            M.push({ pos: [K + 0.5 * de, Q + 0.5 * ue, $], normal: [ue / Se, -de / Se, 0], width: Se, height: q, depth: H, points: [K, Q, ie, fe] });
          }
          return M;
        }(S.lights))), D) {
          const A = [];
          for (const I of D)
            A.push(Lv(e.json.nodes[I], e, n));
          x.children = A;
        }
        return x;
      }
      function uM(r) {
        if (r.vertices.length === 0 || r.indices.length === 0)
          return null;
        const e = new b_(r.vertices, r.indices, 8, 256), [n, o] = [e.min.clone(), e.max.clone()];
        return { vertices: r.vertices, indices: r.indices, grid: e, min: n, max: o };
      }
      function dM(r) {
        if (!r.extras || !r.extras.ground)
          return null;
        const e = r.extras.ground;
        if (!e || !Array.isArray(e) || e.length === 0)
          return null;
        const n = e[0];
        if (!n || !Array.isArray(n) || n.length === 0)
          return null;
        const o = [];
        for (const f of n) {
          if (!Array.isArray(f) || f.length !== 2)
            continue;
          const v = f[0], S = f[1];
          typeof v == "number" && typeof S == "number" && o.push(new Et(v, S));
        }
        if (o.length < 3)
          return null;
        o.length > 1 && o[o.length - 1].equals(o[0]) && o.pop();
        let u = 0;
        for (let f = 0; f < o.length; f++) {
          const v = o[f], S = o[(f + 1) % o.length], D = o[(f + 2) % o.length];
          u += (v.x - S.x) * (D.y - S.y) - (D.x - S.x) * (v.y - S.y);
        }
        u > 0 && o.reverse();
        const l = Nd(o.flatMap((f) => [f.x, f.y]), []);
        return l.length === 0 ? null : { vertices: o, indices: l };
      }
      function fM(r, e) {
        const n = [], o = [];
        let u = 0;
        const l = [];
        for (const f of r) {
          u = n.length;
          const v = f.vertexArray.float32, S = f.indexArray.uint16;
          for (let D = 0; D < f.vertexArray.length; D++)
            l[0] = v[3 * D + 0], l[1] = v[3 * D + 1], l[2] = v[3 * D + 2], De.vec3.transformMat4(l, l, e), n.push(new Et(l[0], l[1]));
          for (let D = 0; D < 3 * f.indexArray.length; D++)
            o.push(S[D] + u);
        }
        if (o.length % 3 != 0)
          return null;
        for (let f = 0; f < o.length; f += 3) {
          const v = n[o[f + 0]], S = n[o[f + 1]], D = n[o[f + 2]];
          (v.x - S.x) * (D.y - S.y) - (D.x - S.x) * (v.y - S.y) > 0 && ([o[f + 1], o[f + 2]] = [o[f + 2], o[f + 1]]);
        }
        return { vertices: n, indices: o };
      }
      function zv(r) {
        const e = function(S, D) {
          const x = [], A = WebGL2RenderingContext;
          if (S.json.textures)
            for (const I of S.json.textures) {
              const M = { magFilter: A.LINEAR, minFilter: A.NEAREST, wrapS: A.REPEAT, wrapT: A.REPEAT };
              I.sampler !== void 0 && Object.assign(M, S.json.samplers[I.sampler]), x.push({ image: D[I.source], sampler: M, uploaded: !1 });
            }
          return x;
        }(r, r.images), n = function(S, D) {
          const x = [];
          for (const A of S.json.meshes) {
            const I = [];
            for (const M of A.primitives)
              I.push(hM(M, S, D));
            x.push(I);
          }
          return x;
        }(r, e), { scenes: o, scene: u, nodes: l } = r.json, f = o ? o[u || 0].nodes : l, v = [];
        for (const S of f)
          v.push(Lv(l[S], r, n));
        return function(S, D, x) {
          const A = {}, I = /* @__PURE__ */ new Set();
          for (let M = 0; M < S.length; M++) {
            const C = x[D[M]];
            if (!C.extras)
              continue;
            const k = C.extras["mapbox:footprint:version"], V = C.extras["mapbox:footprint:id"];
            (k || V) && I.add(M), k === "1.0.0" && V && (A[V] = M);
          }
          for (let M = 0; M < S.length; M++) {
            if (I.has(M))
              continue;
            const C = S[M], k = x[D[M]];
            if (!k.extras)
              continue;
            let V = null;
            C.id in A && (V = fM(S[A[C.id]].meshes, C.matrix)), V || (V = dM(k)), V && (C.footprint = uM(V));
          }
          if (I.size > 0) {
            const M = Array.from(I.values()).sort((C, k) => C - k);
            for (let C = M.length - 1; C >= 0; C--)
              S.splice(M[C], 1);
          }
        }(v, f, r.json.nodes), v;
      }
      function pM(r) {
        r.heightmap = new Float32Array(4096), r.heightmap.fill(-1);
        const e = r.vertexArray.float32, n = r.aabb.min[0] - 1, o = r.aabb.min[1] - 1, u = bh / (r.aabb.max[0] - n + 2), l = bh / (r.aabb.max[1] - o + 2);
        for (let f = 0; f < e.length; f += 3) {
          const v = e[f + 2], S = (e[f + 0] - n) * u | 0, D = (e[f + 1] - o) * l | 0;
          v > r.heightmap[D * bh + S] && (r.heightmap[D * bh + S] = v);
        }
      }
      function mM(r, e) {
        const n = {};
        n.indexArray = new qs(), n.indexArray.reserve(4 * r.length), n.vertexArray = new va(), n.vertexArray.reserve(10 * r.length), n.colorArray = new Xa(), n.vertexArray.reserve(10 * r.length);
        let o = 0;
        for (const f of r) {
          const v = Math.min(10, Math.max(4, 1.3 * f.height)) * e, S = [-f.normal[1], f.normal[0], 0], D = Math.min(0.29, 0.1 * f.width / f.depth), x = f.width - 2 * f.depth * e * (D + 0.01), A = De.vec3.scaleAndAdd([], f.pos, S, x / 2), I = De.vec3.scaleAndAdd([], f.pos, S, -x / 2), M = [A[0], A[1], A[2] + f.height], C = [I[0], I[1], I[2] + f.height], k = De.vec3.scaleAndAdd([], f.normal, S, D);
          De.vec3.scale(k, k, v);
          const V = De.vec3.scaleAndAdd([], f.normal, S, -D);
          De.vec3.scale(V, V, v), De.vec3.add(k, A, k), De.vec3.add(V, I, V), A[2] += 0.1, I[2] += 0.1, n.vertexArray.emplaceBack(k[0], k[1], k[2]), n.vertexArray.emplaceBack(V[0], V[1], V[2]), n.vertexArray.emplaceBack(A[0], A[1], A[2]), n.vertexArray.emplaceBack(I[0], I[1], I[2]), n.vertexArray.emplaceBack(M[0], M[1], M[2]), n.vertexArray.emplaceBack(C[0], C[1], C[2]), n.vertexArray.emplaceBack(A[0], A[1], A[2]), n.vertexArray.emplaceBack(I[0], I[1], I[2]), n.vertexArray.emplaceBack(k[0], k[1], k[2]), n.vertexArray.emplaceBack(V[0], V[1], V[2]);
          const U = x / v / 2;
          n.colorArray.emplaceBack(-U - D, -1, U, 0.8), n.colorArray.emplaceBack(U + D, -1, U, 0.8), n.colorArray.emplaceBack(-U, 0, U, 1.3), n.colorArray.emplaceBack(U, 0, U, 1.3), n.colorArray.emplaceBack(U + D, -0.8, U, 0.7), n.colorArray.emplaceBack(U + D, -0.8, U, 0.7), n.colorArray.emplaceBack(0, 0, U, 1.3), n.colorArray.emplaceBack(0, 0, U, 1.3), n.colorArray.emplaceBack(U + D, -1.2, U, 0.8), n.colorArray.emplaceBack(U + D, -1.2, U, 0.8), n.indexArray.emplaceBack(6 + o, 4 + o, 8 + o), n.indexArray.emplaceBack(7 + o, 9 + o, 5 + o), n.indexArray.emplaceBack(0 + o, 1 + o, 2 + o), n.indexArray.emplaceBack(1 + o, 3 + o, 2 + o), o += 10;
        }
        const u = { defined: !0, emissiveFactor: [0, 0, 0] }, l = {};
        return l.baseColorFactor = ki.white, u.pbrMetallicRoughness = l, n.material = u, n.aabb = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n;
      }
      class Dv {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            this._stringToNumber[o] = n, this._numberToString[n] = o;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          return this._numberToString[e];
        }
      }
      const _M = ["id", "tile", "layer", "source", "sourceLayer", "state"];
      class Zu {
        constructor(e, n, o, u, l) {
          this.type = "Feature", this._vectorTileFeature = e, this._z = n, this._x = o, this._y = u, this.properties = e.properties, this.id = l;
        }
        clone() {
          const e = new Zu(this._vectorTileFeature, this._z, this._x, this._y, this.id);
          return this.state && (e.state = { ...this.state }), this.layer && (e.layer = { ...this.layer }), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          for (const n of _M)
            this[n] !== void 0 && (e[n] = this[n]);
          return e;
        }
      }
      class kv {
        constructor(e, n) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new rc(Tt, 16, 0), this.featureIndexArray = new dh(), this.promoteId = n, this.is3DTile = !1, this.serializedLayersCache = /* @__PURE__ */ new Map();
        }
        insert(e, n, o, u, l, f = 0, v = 0) {
          const S = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(o, u, l, f);
          const D = this.grid;
          for (let x = 0; x < n.length; x++) {
            const A = n[x], I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let M = 0; M < A.length; M++) {
              const C = A[M];
              I[0] = Math.min(I[0], C.x), I[1] = Math.min(I[1], C.y), I[2] = Math.max(I[2], C.x), I[3] = Math.max(I[3], C.y);
            }
            v !== 0 && (I[0] -= v, I[1] -= v, I[2] += v, I[3] += v), I[0] < Tt && I[1] < Tt && I[2] >= 0 && I[3] >= 0 && D.insert(S, I[0], I[1], I[2], I[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new Iu.VectorTile(new Dp(this.rawTileData)).layers, this.sourceLayerCoder = new Dv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const e in this.vtLayers)
              this.vtFeatures[e] = [];
          }
          return this.vtLayers;
        }
        query(e, n) {
          const { tilespaceGeometry: o, transform: u, tileTransform: l, pixelPosMatrix: f, availableImages: v } = n;
          this.loadVTLayers(), this.serializedLayersCache.clear();
          const S = o.bufferedTilespaceBounds, D = this.grid.query(S.min.x, S.min.y, S.max.x, S.max.y, (M, C, k, V) => Oe(o.bufferedTilespaceGeometry, M, C, k, V));
          D.sort(gM);
          let x = null;
          u.elevation && D.length > 0 && (x = Fu.create(u.elevation, this.tileID));
          const A = {};
          let I;
          for (let M = 0; M < D.length; M++) {
            const C = D[M];
            if (C === I)
              continue;
            I = C;
            const k = this.featureIndexArray.get(C);
            let V = null;
            this.is3DTile ? this.loadMatchingModelFeature(A, k, e, o, u) : this.loadMatchingFeature(A, k, e, v, (U, q, $, H = 0) => (V || (V = G(U, this.tileID.canonical, l)), q.queryIntersectsFeature(o, U, $, V, this.z, u, f, x, H)));
          }
          return A;
        }
        loadMatchingFeature(e, n, o, u, l) {
          const { featureIndex: f, bucketIndex: v, sourceLayerIndex: S, layoutVertexArrayOffset: D } = n, x = this.bucketLayerIDs[v], A = o.layers, I = Object.keys(A);
          if (I.length && !function(U, q) {
            for (let $ = 0; $ < U.length; $++)
              if (q.indexOf(U[$]) >= 0)
                return !0;
            return !1;
          }(I, x))
            return;
          const M = o.sourceCache, C = this.sourceLayerCoder.decode(S), k = this.vtLayers[C].feature(f), V = this.getId(k, C);
          for (let U = 0; U < x.length; U++) {
            const q = x[U];
            if (!A[q])
              continue;
            const { styleLayer: $, targets: H } = A[q];
            let K = {};
            V !== void 0 && (K = M.getFeatureState($.sourceLayer, V));
            const Q = !l || l(k, $, K, D);
            if (!Q)
              continue;
            const ie = new Zu(k, this.z, this.x, this.y, V);
            ie.tile = this.tileID.canonical, ie.state = K;
            let fe = this.serializedLayersCache.get(q);
            fe || (fe = $.serialize(), fe.id = q, this.serializedLayersCache.set(q, fe)), ie.source = fe.source, ie.sourceLayer = fe["source-layer"], ie.layer = Pn({}, fe), ie.layer.paint = Rv(fe.paint, $.paint, k, K, u), ie.layer.layout = Rv(fe.layout, $.layout, k, K, u);
            let de = !1;
            for (const ue of H) {
              this.updateFeatureProperties(ie, ue);
              const { filter: Se } = ue;
              if (Se) {
                if (k.properties = ie.properties, Se.needGeometry) {
                  const me = Z(k, !0);
                  if (!Se.filter(new Tn(this.tileID.overscaledZ), me, this.tileID.canonical))
                    continue;
                } else if (!Se.filter(new Tn(this.tileID.overscaledZ), k))
                  continue;
              }
              de = !0, ue.targetId && this.addFeatureVariant(ie, ue);
            }
            de && this.appendToResult(e, q, f, ie, Q);
          }
        }
        loadMatchingModelFeature(e, n, o, u, l) {
          const f = this.bucketLayerIDs[0][0], v = o.layers;
          if (!v[f])
            return;
          const { styleLayer: S, targets: D } = v[f];
          if (S.type !== "model")
            return;
          const x = u.tile, A = n.featureIndex, I = x.getBucket(S);
          if (!(I && I instanceof em))
            return;
          const M = function(fe, de, ue, Se) {
            const me = fe.getNodesInfo()[de];
            if (me.hiddenByReplacement || !me.node.meshes)
              return;
            let Ee = Number.MAX_VALUE;
            const ze = me.node, Ie = ue.tile, Re = Se.calculatePosMatrix(Ie.tileID.toUnwrapped(), Se.worldSize), Ve = me.evaluatedScale;
            let Ue = 0;
            Se.elevation && ze.elevation && (Ue = ze.elevation * Se.elevation.exaggeration()), De.mat4.translate(Re, Re, [(ze.anchor ? ze.anchor[0] : 0) * (Ve[0] - 1), (ze.anchor ? ze.anchor[1] : 0) * (Ve[1] - 1), Ue]), De.mat4.scale(Re, Re, Ve);
            const Fe = ue.queryGeometry, et = Fe.isPointQuery() ? Fe.screenBounds : Fe.screenGeometry, dt = function(Mt) {
              const wt = De.mat4.multiply([], Re, Mt.matrix);
              De.mat4.multiply(wt, Se.expandedFarZProjMatrix, wt);
              for (let Pt = 0; Pt < Mt.meshes.length; ++Pt) {
                const rt = Mt.meshes[Pt];
                if (Pt === Mt.lightMeshIndex)
                  continue;
                const Ut = Rx(et, Se, wt, rt.aabb);
                Ut != null && (Ee = Math.min(Ut, Ee));
              }
              if (Mt.children)
                for (const Pt of Mt.children)
                  dt(Pt);
            };
            if (dt(ze), Ee === Number.MAX_VALUE)
              return;
            const tt = new Ui(0, 0);
            return Wx(Ie.tileID.canonical, tt, me.node.anchor[0], me.node.anchor[1]), { intersectionZ: Ee, position: tt, feature: me.feature };
          }(I, A, u, l);
          if (!M)
            return;
          const { z: C, x: k, y: V } = x.tileID.canonical, { feature: U, intersectionZ: q, position: $ } = M;
          let H = {};
          U.id !== void 0 && (H = o.sourceCache.getFeatureState(S.sourceLayer, U.id));
          const K = new Zu({}, C, k, V, U.id);
          K.tile = this.tileID.canonical, K.state = H, K.properties = U.properties, K.geometry = { type: "Point", coordinates: [$.lng, $.lat] };
          let Q = this.serializedLayersCache.get(f);
          Q || (Q = S.serialize(), Q.id = f, this.serializedLayersCache.set(f, Q)), K.source = Q.source, K.sourceLayer = Q["source-layer"], K.layer = Pn({}, Q);
          let ie = !1;
          for (const fe of D) {
            this.updateFeatureProperties(K, fe);
            const { filter: de } = fe;
            if (de) {
              if (U.properties = K.properties, de.needGeometry) {
                if (!de.filter(new Tn(this.tileID.overscaledZ), U, this.tileID.canonical))
                  continue;
              } else if (!de.filter(new Tn(this.tileID.overscaledZ), U))
                continue;
            }
            ie = !0, fe.targetId && this.addFeatureVariant(K, fe);
          }
          ie && this.appendToResult(e, f, A, K, q);
        }
        updateFeatureProperties(e, n, o) {
          if (n.properties) {
            const u = {};
            for (const l in n.properties) {
              const f = n.properties[l].evaluate({ zoom: this.z }, e._vectorTileFeature, e.state, e.tile, o);
              f != null && (u[l] = f);
            }
            e.properties = u;
          }
        }
        addFeatureVariant(e, n, o) {
          const u = { target: n.target, namespace: n.namespace };
          n.properties && (u.properties = e.properties), e.variants = e.variants || {}, e.variants[n.targetId] = e.variants[n.targetId] || [], e.variants[n.targetId].push(u);
        }
        appendToResult(e, n, o, u, l) {
          let f = e[n];
          f === void 0 && (f = e[n] = []), f.push({ featureIndex: o, feature: u, intersectionZ: l });
        }
        lookupSymbolFeatures(e, n, o, u, l) {
          const f = {};
          this.loadVTLayers();
          for (const v of e)
            this.loadMatchingFeature(f, { bucketIndex: n, sourceLayerIndex: o, featureIndex: v, layoutVertexArrayOffset: 0 }, u, l);
          return f;
        }
        loadFeature(e) {
          const { featureIndex: n, sourceLayerIndex: o } = e;
          this.loadVTLayers();
          const u = this.sourceLayerCoder.decode(o), l = this.vtFeatures[u];
          if (l[n])
            return l[n];
          const f = this.vtLayers[u].feature(n);
          return l[n] = f, f;
        }
        hasLayer(e) {
          for (const n of this.bucketLayerIDs)
            for (const o of n)
              if (e === o)
                return !0;
          return !1;
        }
        getId(e, n) {
          let o = e.id;
          if (this.promoteId) {
            const u = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n];
            u != null && (o = e.properties[u]), typeof o == "boolean" && (o = Number(o));
          }
          return o;
        }
      }
      function Rv(r, e, n, o, u) {
        return Mr(r, (l, f) => {
          const v = e instanceof cc ? e.get(f) : null;
          return v && v.evaluate ? v.evaluate(n, o, u) : v;
        });
      }
      function gM(r, e) {
        return e - r;
      }
      Ft(kv, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const Ov = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class vg {
        static from(e) {
          if (!(e instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, o] = new Uint8Array(e, 0, 2);
          if (n !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const u = o >> 4;
          if (u !== 1)
            throw new Error(`Got v${u} data when expected v1.`);
          const l = Ov[15 & o];
          if (!l)
            throw new Error("Unrecognized array type.");
          const [f] = new Uint16Array(e, 2, 1), [v] = new Uint32Array(e, 4, 1);
          return new vg(v, f, l, e);
        }
        constructor(e, n = 64, o = Float64Array, u) {
          if (isNaN(e) || e < 0)
            throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const l = Ov.indexOf(this.ArrayType), f = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, v = e * this.IndexArrayType.BYTES_PER_ELEMENT, S = (8 - v % 8) % 8;
          if (l < 0)
            throw new Error(`Unexpected typed array class: ${o}.`);
          u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + v + S, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + f + v + S), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + v + S, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + l]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, n) {
          const o = this._pos >> 1;
          return this.ids[o] = o, this.coords[this._pos++] = e, this.coords[this._pos++] = n, o;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems)
            throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return bg(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, n, o, u) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: l, coords: f, nodeSize: v } = this, S = [0, l.length - 1, 0], D = [];
          for (; S.length; ) {
            const x = S.pop() || 0, A = S.pop() || 0, I = S.pop() || 0;
            if (A - I <= v) {
              for (let V = I; V <= A; V++) {
                const U = f[2 * V], q = f[2 * V + 1];
                U >= e && U <= o && q >= n && q <= u && D.push(l[V]);
              }
              continue;
            }
            const M = I + A >> 1, C = f[2 * M], k = f[2 * M + 1];
            C >= e && C <= o && k >= n && k <= u && D.push(l[M]), (x === 0 ? e <= C : n <= k) && (S.push(I), S.push(M - 1), S.push(1 - x)), (x === 0 ? o >= C : u >= k) && (S.push(M + 1), S.push(A), S.push(1 - x));
          }
          return D;
        }
        within(e, n, o) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: u, coords: l, nodeSize: f } = this, v = [0, u.length - 1, 0], S = [], D = o * o;
          for (; v.length; ) {
            const x = v.pop() || 0, A = v.pop() || 0, I = v.pop() || 0;
            if (A - I <= f) {
              for (let V = I; V <= A; V++)
                Bv(l[2 * V], l[2 * V + 1], e, n) <= D && S.push(u[V]);
              continue;
            }
            const M = I + A >> 1, C = l[2 * M], k = l[2 * M + 1];
            Bv(C, k, e, n) <= D && S.push(u[M]), (x === 0 ? e - o <= C : n - o <= k) && (v.push(I), v.push(M - 1), v.push(1 - x)), (x === 0 ? e + o >= C : n + o >= k) && (v.push(M + 1), v.push(A), v.push(1 - x));
          }
          return S;
        }
      }
      function bg(r, e, n, o, u, l) {
        if (u - o <= n)
          return;
        const f = o + u >> 1;
        Fv(r, e, f, o, u, l), bg(r, e, n, o, f - 1, 1 - l), bg(r, e, n, f + 1, u, 1 - l);
      }
      function Fv(r, e, n, o, u, l) {
        for (; u > o; ) {
          if (u - o > 600) {
            const D = u - o + 1, x = n - o + 1, A = Math.log(D), I = 0.5 * Math.exp(2 * A / 3), M = 0.5 * Math.sqrt(A * I * (D - I) / D) * (x - D / 2 < 0 ? -1 : 1);
            Fv(r, e, n, Math.max(o, Math.floor(n - x * I / D + M)), Math.min(u, Math.floor(n + (D - x) * I / D + M)), l);
          }
          const f = e[2 * n + l];
          let v = o, S = u;
          for (_f(r, e, o, n), e[2 * u + l] > f && _f(r, e, o, u); v < S; ) {
            for (_f(r, e, v, S), v++, S--; e[2 * v + l] < f; )
              v++;
            for (; e[2 * S + l] > f; )
              S--;
          }
          e[2 * o + l] === f ? _f(r, e, o, S) : (S++, _f(r, e, S, u)), S <= n && (o = S + 1), n <= S && (u = S - 1);
        }
      }
      function _f(r, e, n, o) {
        wg(r, n, o), wg(e, 2 * n, 2 * o), wg(e, 2 * n + 1, 2 * o + 1);
      }
      function wg(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      function Bv(r, e, n, o) {
        const u = r - n, l = e - o;
        return u * u + l * l;
      }
      i.$ = bd, i.A = ss, i.B = 2, i.C = J0, i.D = Bu, i.E = Zo, i.F = N_, i.G = class extends Jp {
      }, i.H = qo, i.I = ug, i.J = Bi, i.K = ip, i.L = ad, i.M = nc, i.N = qf, i.O = tu, i.P = Et, i.Q = cu, i.R = Uo, i.S = ud, i.T = K_, i.U = Qc, i.V = Jp, i.W = xl, i.X = oo, i.Y = ro, i.Z = or, i._ = Ra, i.a = function(r) {
        return ge.API_CDN_URL_REGEX.test(r);
      }, i.a$ = Zu, i.a0 = Qh, i.a1 = Jh, i.a2 = function(r) {
        const e = r.value;
        let n = [];
        if (!e)
          return n;
        const o = qo(e);
        return o !== "string" ? (n = n.concat([new Jp(r.key, e, `string expected, "${o}" found`)]), n) : (Fx(e, !0) || (n = n.concat([new Jp(r.key, e, `invalid url "${e}"`)])), n);
      }, i.a3 = $e, i.a4 = ih, i.a5 = Bn, i.a6 = yt, i.a7 = class {
        constructor(r) {
          this.specification = r;
        }
        possiblyEvaluate(r, e) {
          return Zi(r.expression.evaluate(e));
        }
        interpolate(r, e, n) {
          return { x: ei(r.x, e.x, n), y: ei(r.y, e.y, n), z: ei(r.z, e.z, n), azimuthal: ei(r.azimuthal, e.azimuthal, n), polar: ei(r.polar, e.polar, n) };
        }
      }, i.a8 = Tn, i.a9 = sc, i.aA = Ta, i.aB = class {
        constructor(r) {
          this.entries = {}, this.scheduler = r;
        }
        request(r, e, n, o) {
          const u = this.entries[r] = this.entries[r] || { callbacks: [] };
          if (u.result) {
            const [l, f] = u.result;
            return this.scheduler ? this.scheduler.add(() => {
              o(l, f);
            }, e) : o(l, f), () => {
            };
          }
          return u.callbacks.push(o), u.cancel || (u.cancel = n((l, f) => {
            u.result = [l, f];
            for (const v of u.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                v(l, f);
              }, e) : v(l, f);
            setTimeout(() => delete this.entries[r], 3e3);
          })), () => {
            u.result || (u.callbacks = u.callbacks.filter((l) => l !== o), u.callbacks.length || (u.cancel(), delete this.entries[r]));
          };
        }
      }, i.aC = Io, i.aD = function(r, e, n) {
        const o = JSON.stringify(r.request);
        return r.data && (this.deduped.entries[o] = { result: [null, r.data] }), this.deduped.request(o, { type: "parseTile", isSymbolTile: r.isSymbolTile, zoom: r.tileZoom }, (u) => {
          const l = no(r.request, (f, v, S, D) => {
            f ? u(f) : v && u(null, { vectorTile: n ? void 0 : new Iu.VectorTile(new Dp(v)), rawData: v, cacheControl: S, expires: D });
          });
          return () => {
            l.cancel(), u();
          };
        }, e);
      }, i.aE = function(r) {
        Xn++, Xn > ri && (r.getActor().send("enforceCacheSizeLimit", li), Xn = 0);
      }, i.aF = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
      }, i.aG = bt, i.aH = Mx, i.aI = Ix, i.aJ = Tx, i.aK = function(r, e) {
        const n = document.createElement("video");
        n.muted = !0, n.onloadstart = function() {
          e(null, n);
        };
        for (let o = 0; o < r.length; o++) {
          const u = document.createElement("source");
          Go(r[o]) || (n.crossOrigin = "Anonymous"), u.src = r[o], n.appendChild(u);
        }
        return { cancel: () => {
        } };
      }, i.aL = Wp, i.aM = function(r) {
        return fetch(r).then((e) => e.arrayBuffer()).then((e) => Iv(e, 0, r));
      }, i.aN = zv, i.aO = class {
        constructor(r, e, n, o) {
          this.id = r, this.position = e != null ? new Ui(e[0], e[1]) : new Ui(0, 0), this.orientation = n ?? [0, 0, 0], this.nodes = o, this.uploaded = !1, this.aabb = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(r, e) {
          if (De.mat4.multiply(r.matrix, e, r.matrix), r.meshes)
            for (const n of r.meshes) {
              const o = Jt.applyTransformFast(n.aabb, r.matrix);
              this.aabb.encapsulate(o);
            }
          if (r.children)
            for (const n of r.children)
              this._applyTransformations(n, r.matrix);
        }
        computeBoundsAndApplyParent() {
          const r = De.mat4.identity([]);
          for (const e of this.nodes)
            this._applyTransformations(e, r);
        }
        computeModelMatrix(r, e, n, o, u, l, f = !1) {
          jx(this.matrix, this, r.transform, this.position, e, n, o, u, l, f);
        }
        upload(r) {
          if (!this.uploaded) {
            for (const e of this.nodes)
              ig(e, r);
            for (const e of this.nodes)
              Qp(e);
            this.uploaded = !0;
          }
        }
        destroy() {
          for (const r of this.nodes)
            ng(r);
        }
      }, i.aP = vo, i.aQ = Qd, i.aR = Fr, i.aS = Os, i.aT = $a, i.aU = qs, i.aV = yo, i.aW = ap, i.aX = Hp, i.aY = function() {
        co.isLoading() || co.isLoaded() || au() !== "deferred" || ep();
      }, i.aZ = np, i.a_ = Z, i.aa = h, i.ab = De, i.ac = fs, i.ad = cc, i.ae = mr, i.af = ei, i.ag = Tt, i.ah = ul, i.ai = vi, i.aj = ki, i.ak = class {
        constructor(r) {
          this.specification = r;
        }
        possiblyEvaluate(r, e) {
          return function([n, o]) {
            const u = Zi([1, n, o]);
            return { x: u.x, y: u.y, z: u.z };
          }(r.expression.evaluate(e));
        }
        interpolate(r, e, n) {
          return { x: ei(r.x, e.x, n), y: ei(r.y, e.y, n), z: ei(r.z, e.z, n) };
        }
      }, i.al = function(r, e, n = 0, o = !0) {
        const u = new Et(n, n), l = r.sub(u), f = e.add(u), v = [l, new Et(f.x, l.y), f, new Et(l.x, f.y)];
        return o && v.push(l.clone()), v;
      }, i.am = function(r, e) {
        const n = [];
        for (let o = 0; o < r.length; o++) {
          const u = zn(o - 1, -1, r.length - 1), l = zn(o + 1, -1, r.length - 1), f = r[o], v = r[l], S = r[u].sub(f).unit(), D = v.sub(f).unit(), x = D.angleWithSep(S.x, S.y), A = S.add(D).unit().mult(-1 * e / Math.sin(x / 2));
          n.push(f.add(A));
        }
        return n;
      }, i.an = cx, i.ao = Oe, i.ap = function(r, e, n = 0) {
        return De.vec3.fromValues(((e.x - n) * r.scale - r.x) * Tt, (e.y * r.scale - r.y) * Tt, vp(e.z, e.y));
      }, i.aq = zi, i.ar = A0, i.as = function(r) {
        let e = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const l of r)
          e = Math.min(e, l.x), n = Math.min(n, l.y), o = Math.max(o, l.x), u = Math.max(u, l.y);
        return { min: new Et(e, n), max: new Et(o, u) };
      }, i.at = ta, i.au = Pe, i.av = y, i.aw = si, i.ax = dr, i.ay = function(r, e) {
        const n = {};
        for (let o = 0; o < e.length; o++) {
          const u = e[o];
          u in r && (n[u] = r[u]);
        }
        return n;
      }, i.az = tl, i.b = function(r) {
        return ge.API_FONTS_REGEX.test(r);
      }, i.b$ = Yp, i.b0 = Fn, i.b1 = I_, i.b2 = v_, i.b3 = G, i.b4 = Lo, i.b5 = xu, i.b6 = ai, i.b7 = Wn, i.b8 = Nd, i.b9 = $_, i.bA = r0, i.bB = j_, i.bC = rx, i.bD = B_, i.bE = vg, i.bF = zn, i.bG = zs, i.bH = fr, i.bI = function(r, e, n) {
        r[4 * e + 0] = n[0], r[4 * e + 1] = n[1], r[4 * e + 2] = n[2], r[4 * e + 3] = n[3];
      }, i.bJ = mh, i.bK = zo, i.bL = kd, i.bM = Nn, i.bN = dc, i.bO = Ui, i.bP = px, i.bQ = Lt, i.bR = _i, i.bS = zx, i.bT = nt, i.bU = jn, i.bV = function(r, e, n, o, u, l, f, v, S) {
        if (S.name === "globe")
          return jn(r, e, new nt(n, o, u), !1);
        const D = Qd({ z: n, x: o, y: u }, S);
        return new Jt([(l + D.x / D.scale) * e, e * (D.y / D.scale), f], [(l + D.x2 / D.scale) * e, e * (D.y2 / D.scale), v]);
      }, i.bW = function(r, e, n) {
        let o = 0;
        for (let u = 0; u < 2; ++u)
          r[u] > 0 && (o += (r[u] - 0) * (r[u] - 0)), e[u] < 0 && (o += (0 - e[u]) * (0 - e[u]));
        return o;
      }, i.bX = Un, i.bY = gp, i.bZ = function(r) {
        const e = De.mat4.identity(new Float64Array(16));
        De.mat4.multiply(e, r.pixelMatrix, r.globeMatrix);
        const n = [0, uo, 0], o = [0, fo, 0];
        return De.vec3.transformMat4(n, n, e), De.vec3.transformMat4(o, o, e), [n[0] > 0 && n[0] <= r.width && n[1] > 0 && n[1] <= r.height && !Nr(r, new Ui(r.center.lat, 90)), o[0] > 0 && o[0] <= r.width && o[1] > 0 && o[1] <= r.height && !Nr(r, new Ui(r.center.lat, -90))];
      }, i.b_ = function(r, e) {
        const { scale: n } = r.tileTransform, o = n * Tt / (r.tileSize * Math.pow(2, e.zoom - r.tileID.overscaledZ + r.tileID.canonical.z));
        return De.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [o, o]);
      }, i.ba = function(r, e) {
        const n = mr(e.zoom);
        if (n === 0)
          return ts(r);
        const o = dn(r), u = _n(o), l = ta(o.getWest()) * e.worldSize, f = ta(o.getEast()) * e.worldSize, v = Ta(o.getNorth()) * e.worldSize, S = Ta(o.getSouth()) * e.worldSize, D = [l, v, 0], x = [f, v, 0], A = [l, S, 0], I = [f, S, 0], M = De.mat4.invert([], e.globeMatrix);
        return De.vec3.transformMat4(D, D, M), De.vec3.transformMat4(x, x, M), De.vec3.transformMat4(A, A, M), De.vec3.transformMat4(I, I, M), u[0] = As(u[0], A, n), u[1] = As(u[1], I, n), u[2] = As(u[2], x, n), u[3] = As(u[3], D, n), Jt.fromPoints(u);
      }, i.bb = cn, i.bc = Ri, i.bd = As, i.be = oh, i.bf = Xt, i.bg = mg, i.bh = Dp, i.bi = no, i.bj = function(r) {
        const e = [];
        for (const n in r)
          e.push(r[n]);
        return e;
      }, i.bk = function(r, e) {
        const n = [];
        for (const o in r)
          o in e || n.push(o);
        return n;
      }, i.bl = Rn, i.bm = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], i.bn = Ws, i.bo = function(r, e) {
        const { x: n, y: o } = r.point, u = Ma(n, o, r.worldSize / r._pixelsPerMercatorPixel, 0, 0);
        return De.mat4.multiply(u, u, er(ts(e)));
      }, i.bp = Lu, i.bq = Ro, i.br = zp, i.bs = function(r, e, n, o, u) {
        const l = 5 * e + 2;
        r.float32[l + 0] = n, r.float32[l + 1] = o, r.float32[l + 2] = u;
      }, i.bt = Zp, i.bu = K0, i.bv = se, i.bw = tr, i.bx = Qy, i.by = Ox, i.bz = s0, i.c = Ce, i.c$ = (r, e, n, o, u, l, f, v) => {
        const S = r.transform, D = S.pitch < 15 ? P0(0.07, 0.7, si((14 - S.zoom) / 5, 0, 1)) : 0.07, x = n.paint.get("line-trim-color-use-theme").constantOr("default") === "none";
        return { u_matrix: I0(r, e, n, o), u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: S.calculatePixelsToTileUnitsMatrix(e), u_device_pixel_ratio: u, u_width_scale: l, u_floor_width_scale: f, u_image: 0, u_tile_units_to_pixels: C0(e, S), u_units_to_pixels: [1 / S.pixelsToGLUnits[0], 1 / S.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: v, u_trim_fade_range: n.paint.get("line-trim-fade-range"), u_trim_color: n.paint.get("line-trim-color").toRenderColor(x ? null : n.lut).toArray01(), u_emissive_strength: n.paint.get("line-emissive-strength"), u_zbias_factor: D, u_tile_to_meter: s(e.tileID.canonical, 0) };
      }, i.c0 = Lx, i.c1 = function(r) {
        const e = Lx(r, !0);
        return De.mat2.invert([], [e[0], e[1], e[4], e[5]]);
      }, i.c2 = wi, i.c3 = function(r) {
        const { x: e, y: n } = r.point, { lng: o, lat: u } = r._center;
        return Ma(e, n, r.worldSize, o, u);
      }, i.c4 = kn, i.c5 = zt, i.c6 = Su, i.c7 = function(r) {
        const e = Math.round((r + 45 + 360) % 360 / 90) % 4;
        return Xs[e];
      }, i.c8 = 45, i.c9 = gh, i.cA = class extends ba {
        constructor(r) {
          super(r), this.current = l_;
        }
        set(r, e, n) {
          if (this.fetchUniformLocation(r, e)) {
            for (let o = 0; o < 9; o++)
              if (n[o] !== this.current[o]) {
                this.current = n, this.gl.uniformMatrix3fv(this.location, !1, n);
                break;
              }
          }
        }
      }, i.cB = Hr, i.cC = function(r, e, n) {
        const o = mr(n.zoom), u = r.style.map._antialias, l = e.options.extStandardDerivativesForceOff || r.terrain && r.terrain.exaggeration() > 0;
        return o === 0 && !u && !l;
      }, i.cD = function(r) {
        const e = r.pixelsPerMeter, n = e / fr(1, r.center.lat), o = De.mat4.identity(new Float64Array(16));
        return De.mat4.translate(o, o, [r.point.x, r.point.y, 0]), De.mat4.scale(o, o, [n, n, e]), Float32Array.from(o);
      }, i.cE = dn, i.cF = function(r) {
        const e = Un - 5;
        r = si(r, -e, e) / e * 90;
        const n = Math.pow(Math.abs(Math.sin(vi(r))), 3);
        return Math.round(n * (Eu.length - 1));
      }, i.cG = function(r, e, n, o) {
        const u = e.getNorth(), l = e.getSouth(), f = e.getWest(), v = e.getEast(), S = 1 << r.z, D = v - f, x = u - l, A = D / Il, I = -x / Eu[n], M = [0, A, 0, I, 0, 0, u, f, 0];
        if (r.z > 0) {
          const C = 180 / o;
          De.mat3.multiply(M, M, [C / D + 1, 0, 0, 0, C / x + 1, 0, -0.5 * C / A, 0.5 * C / I, 1]);
        }
        return M[2] = S, M[5] = r.x, M[8] = r.y, M;
      }, i.cH = ts, i.cI = function(r, e, n) {
        const o = De.mat4.identity(new Float64Array(16)), u = (e / (1 << r) - 0.5) * Math.PI * 2;
        return De.mat4.rotateY(o, n.globeMatrix, u), Float32Array.from(o);
      }, i.cJ = class {
        isDataAvailableAtPoint(r) {
          const e = this._source();
          if (this.isUsingMockSource() || !e || r.y < 0 || r.y > 1)
            return !1;
          const n = e.getSource().maxzoom, o = 1 << n, u = Math.floor(r.x), l = Math.floor((r.x - u) * o), f = Math.floor(r.y * o), v = this.findDEMTileFor(new bt(n, u, n, l, f));
          return !(!v || !v.dem);
        }
        getAtPointOrZero(r, e = 0) {
          return this.getAtPoint(r, e) || 0;
        }
        getAtPoint(r, e, n = !0) {
          if (this.isUsingMockSource())
            return null;
          e == null && (e = null);
          const o = this._source();
          if (!o || r.y < 0 || r.y > 1)
            return e;
          const u = o.getSource().maxzoom, l = 1 << u, f = Math.floor(r.x), v = r.x - f, S = new bt(u, f, u, Math.floor(v * l), Math.floor(r.y * l)), D = this.findDEMTileFor(S);
          if (!D || !D.dem)
            return e;
          const x = D.dem, A = 1 << D.tileID.canonical.z, I = (v * A - D.tileID.canonical.x) * x.dim, M = (r.y * A - D.tileID.canonical.y) * x.dim, C = Math.floor(I), k = Math.floor(M);
          return (n ? this.exaggeration() : 1) * ei(ei(x.get(C, k), x.get(C, k + 1), M - k), ei(x.get(C + 1, k), x.get(C + 1, k + 1), M - k), I - C);
        }
        getAtTileOffset(r, e, n) {
          const o = 1 << r.canonical.z;
          return this.getAtPointOrZero(new h(r.wrap + (r.canonical.x + e / Tt) / o, (r.canonical.y + n / Tt) / o));
        }
        getAtTileOffsetFunc(r, e, n, o) {
          return (u) => {
            const l = this.getAtTileOffset(r, u.x, u.y), f = o.upVector(r.canonical, u.x, u.y), v = o.upVectorScale(r.canonical, e, n).metersToTile;
            return De.vec3.scale(f, f, l * v), f;
          };
        }
        getForTilePoints(r, e, n, o) {
          if (this.isUsingMockSource())
            return !1;
          const u = Fu.create(this, r, o);
          return !!u && (e.forEach((l) => {
            l[2] = this.exaggeration() * u.getElevationAt(l[0], l[1], n);
          }), !0);
        }
        getMinMaxForTile(r) {
          if (this.isUsingMockSource())
            return null;
          const e = this.findDEMTileFor(r);
          if (!e || !e.dem)
            return null;
          const n = e.dem.tree, o = e.tileID, u = 1 << r.canonical.z - o.canonical.z;
          let l = r.canonical.x / u - o.canonical.x, f = r.canonical.y / u - o.canonical.y, v = 0;
          for (let S = 0; S < r.canonical.z - o.canonical.z && !n.leaves[v]; S++) {
            l *= 2, f *= 2;
            const D = 2 * Math.floor(f) + Math.floor(l);
            v = n.childOffsets[v] + D, l %= 1, f %= 1;
          }
          return { min: this.exaggeration() * n.minimums[v], max: this.exaggeration() * n.maximums[v] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(r, e, n) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(r) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(r) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const r = this.visibleDemTiles;
          if (r.length === 0)
            return null;
          let e = !1, n = Number.MAX_VALUE, o = Number.MIN_VALUE;
          for (const u of r) {
            const l = this.getMinMaxForTile(u.tileID);
            l && (n = Math.min(n, l.min), o = Math.max(o, l.max), e = !0);
          }
          return e ? { min: n, max: o } : null;
        }
      }, i.cK = zy, i.cL = ji, i.cM = function(r, e) {
        return [Math.pow(r[0], 2.2) * e, Math.pow(r[1], 2.2) * e, Math.pow(r[2], 2.2) * e];
      }, i.cN = Br, i.cO = le, i.cP = re, i.cQ = 256, i.cR = function(r, e) {
        const n = [0, 0, 0], o = cn(ts(e.canonical));
        return De.vec3.transformMat4(n, n, o), De.vec3.transformMat4(n, n, r), n;
      }, i.cS = (r) => ({ u_camera_to_center_distance: new Nn(r), u_extrude_scale: new Od(r), u_device_pixel_ratio: new Nn(r), u_matrix: new mh(r), u_inv_rot_matrix: new mh(r), u_merc_center: new zo(r), u_tile_id: new kd(r), u_zoom_transition: new Nn(r), u_up_dir: new kd(r), u_emissive_strength: new Nn(r) }), i.cT = (r) => ({ u_matrix: new mh(r), u_pixels_to_tile_units: new Od(r), u_device_pixel_ratio: new Nn(r), u_width_scale: new Nn(r), u_floor_width_scale: new Nn(r), u_units_to_pixels: new zo(r), u_dash_image: new dc(r), u_gradient_image: new dc(r), u_image_height: new Nn(r), u_texsize: new zo(r), u_tile_units_to_pixels: new Nn(r), u_alpha_discard_threshold: new Nn(r), u_trim_offset: new zo(r), u_trim_fade_range: new zo(r), u_trim_color: new ph(r), u_emissive_strength: new Nn(r), u_zbias_factor: new Nn(r), u_tile_to_meter: new Nn(r) }), i.cU = (r) => ({ u_matrix: new mh(r), u_texsize: new zo(r), u_pixels_to_tile_units: new Od(r), u_device_pixel_ratio: new Nn(r), u_width_scale: new Nn(r), u_floor_width_scale: new Nn(r), u_image: new dc(r), u_units_to_pixels: new zo(r), u_tile_units_to_pixels: new Nn(r), u_alpha_discard_threshold: new Nn(r), u_trim_offset: new zo(r), u_trim_fade_range: new zo(r), u_trim_color: new ph(r), u_emissive_strength: new Nn(r), u_zbias_factor: new Nn(r), u_tile_to_meter: new Nn(r) }), i.cV = _u, i.cW = bT, i.cX = wT, i.cY = Au, i.cZ = (r, e, n, o, u, l) => {
        const f = r.transform, v = f.projection.name === "globe";
        let S;
        if (l.paint.get("circle-pitch-alignment") === "map")
          if (v) {
            const x = Br(f.zoom, e.canonical) * f._pixelsPerMercatorPixel;
            S = Float32Array.from([x, 0, 0, x]);
          } else
            S = f.calculatePixelsToTileUnitsMatrix(n);
        else
          S = new Float32Array([f.pixelsToGLUnits[0], 0, 0, f.pixelsToGLUnits[1]]);
        const D = { u_camera_to_center_distance: r.transform.getCameraToCenterDistance(f.projection), u_matrix: r.translatePosMatrix(e.projMatrix, n, l.paint.get("circle-translate"), l.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Ct.devicePixelRatio, u_extrude_scale: S, u_inv_rot_matrix: yh, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: l.paint.get("circle-emissive-strength") };
        if (v) {
          D.u_inv_rot_matrix = o, D.u_merc_center = u, D.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], D.u_zoom_transition = mr(f.zoom);
          const x = u[0] * Tt, A = u[1] * Tt;
          D.u_up_dir = f.projection.upVector(new nt(0, 0, 0), x, A);
        }
        return D;
      }, i.c_ = L0, i.ca = ph, i.cb = function(r, e, n) {
        const o = Math.sqrt(r * r + e * e + n * n), u = o > 0 ? Math.acos(n / o) * $s : 0;
        let l = r !== 0 || e !== 0 ? Math.atan2(-e, -r) * $s + 90 : 0;
        return l < 0 && (l += 360), [o, l, u];
      }, i.cc = s, i.cd = Jt, i.ce = Zi, i.cf = function(r) {
        return [Math.pow(r[0], 1 / 2.2), Math.pow(r[1], 1 / 2.2), Math.pow(r[2], 1 / 2.2)];
      }, i.cg = function(r, e) {
        return r.readFields(f2, { icons: [] }, e);
      }, i.ch = function(r) {
        return r({ pluginStatus: br, pluginURL: qa }), oc.on("pluginStateChange", r), r;
      }, i.ci = tm, i.cj = Du, i.ck = V_, i.cl = tn, i.cm = th, i.cn = Kt, i.co = $r, i.cp = Ys, i.cq = function(r) {
        const e = r.indexOf(Co);
        return e >= 0 ? r.slice(0, e) : r;
      }, i.cr = function(r) {
        return r.indexOf(Co) >= 0;
      }, i.cs = function(r) {
        const e = r.indexOf(Co);
        return e >= 0 ? r.slice(e + 1) : "";
      }, i.ct = function(r) {
        const e = [], n = r.id;
        return n === void 0 && e.push({ message: `layers.${n}: missing required property "id"` }), r.render === void 0 && e.push({ message: `layers.${n}: missing required method "render"` }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && e.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, i.cu = function(r, e, n, o) {
        return r.type === "custom" ? new QT(r, e) : new h2[r.type](r, e, n, o);
      }, i.cv = io, i.cw = class extends Zu {
        constructor(r, e) {
          super(r._vectorTileFeature, r._z, r._x, r._y, r.id), r.state && (this.state = { ...r.state }), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = r.source, this.sourceLayer = r.sourceLayer, this.layer = r.layer);
        }
        toJSON() {
          const r = super.toJSON();
          return r.target = this.target, r.namespace = this.namespace, r;
        }
      }, i.cx = oc, i.cy = xn, i.cz = _p, i.d = function(r) {
        return ge.API_TILEJSON_REGEX.test(r);
      }, i.d$ = Mr, i.d0 = (r, e, n, o, u, l, f, v, S) => {
        const D = r.transform, x = D.calculatePixelsToTileUnitsMatrix(e), A = n.paint.get("line-trim-color-use-theme").constantOr("default") === "none", I = D.pitch < 15 ? P0(0.07, 0.7, si((14 - D.zoom) / 5, 0, 1)) : 0.07;
        return { u_matrix: I0(r, e, n, o), u_pixels_to_tile_units: x, u_device_pixel_ratio: l, u_width_scale: f, u_floor_width_scale: v, u_units_to_pixels: [1 / D.pixelsToGLUnits[0], 1 / D.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: u, u_texsize: z0(n) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: C0(e, r.transform), u_alpha_discard_threshold: 0, u_trim_offset: S, u_trim_fade_range: n.paint.get("line-trim-fade-range"), u_trim_color: n.paint.get("line-trim-color").toRenderColor(A ? null : n.lut).toArray01(), u_emissive_strength: n.paint.get("line-emissive-strength"), u_zbias_factor: I, u_tile_to_meter: s(e.tileID.canonical, 0) };
      }, i.d1 = xo, i.d2 = Bd, i.d3 = y0, i.d4 = Bt, i.d5 = Ip, i.d6 = yc, i.d7 = 450, i.d8 = 7, i.d9 = JT, i.dA = Wr, i.dB = t, i.dC = el, i.dD = function([r, e, n]) {
        const o = Math.hypot(r, e, n), u = Math.atan2(r, n), l = 0.5 * Math.PI - Math.acos(-e / o);
        return new Ui(kn(u), kn(l));
      }, i.dE = Q_, i.dF = function(r) {
        const e = r.navigator ? r.navigator.userAgent : null;
        return !!function(n) {
          if (Ls == null) {
            const o = n.navigator ? n.navigator.userAgent : null;
            Ls = !!n.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
          }
          return Ls;
        }(r) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, i.dG = function(r, e) {
        li = r, ri = e;
      }, i.dH = Nr, i.dI = ko, i.dJ = function(r) {
        const e = [0, 0, 0], n = De.mat4.identity(new Float64Array(16));
        return De.mat4.multiply(n, r.pixelMatrix, r.globeMatrix), De.vec3.transformMat4(e, e, n), new Et(e[0], e[1]);
      }, i.dK = function(r, e, n = !1) {
        if (br === yd || br === ea || br === xd)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        qa = Ct.resolveURL(r), br = yd, vd = e, ou(), n || ep();
      }, i.dL = au, i.dM = function() {
        tm().acquire(rg);
      }, i.dN = function() {
        const r = lf;
        r && (r.isPreloaded() && r.numActive() === 1 ? (r.release(rg), lf = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, i.dO = Th, i.dP = function(r) {
        const e = $i();
        if (!e)
          return;
        const n = e.delete(di);
        r && n.catch(r).then(() => r());
      }, i.dQ = af, i.dR = Tv, i.dS = function(r) {
        _g = Ct.resolveURL(r), Gu || (Gu = new Bu(tm(), new Zo())), Gu.broadcast("setDracoUrl", _g);
      }, i.dT = Mv, i.dU = function(r) {
        ju = Ct.resolveURL(r), Gu || (Gu = new Bu(tm(), new Zo())), Gu.broadcast("setMeshoptUrl", ju);
      }, i.dV = Ft, i.dW = gc, i.dX = Ea, i.dY = Dv, i.dZ = kv, i.d_ = M0, i.da = qi, i.db = zd, i.dc = 256, i.dd = er, i.de = va, i.df = Rr, i.dg = yu, i.dh = function(r, e, n, o, u) {
        return si((r - e) / (n - e) * (u - o) + o, o, u);
      }, i.di = es, i.dj = c, i.dk = class {
        constructor(r, e, n, o) {
          this.context = r, this.format = o, this.size = n, this.texture = r.gl.createTexture();
          const [u, l, f] = this.size, { gl: v } = r;
          v.bindTexture(v.TEXTURE_3D, this.texture), r.pixelStoreUnpackFlipY.set(!1), r.pixelStoreUnpack.set(1), r.pixelStoreUnpackPremultiplyAlpha.set(!1), v.texImage3D(v.TEXTURE_3D, 0, this.format, u, l, f, 0, X_(this.format), Y_(this.format), e.data);
        }
        bind(r, e) {
          const { context: n } = this, { gl: o } = n;
          o.bindTexture(o.TEXTURE_3D, this.texture), r !== this.minFilter && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MAG_FILTER, r), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MIN_FILTER, r), this.minFilter = r), e !== this.wrapS && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_S, e), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_T, e), this.wrapS = e);
        }
        destroy() {
          const { gl: r } = this.context;
          r.deleteTexture(this.texture), this.texture = null;
        }
      }, i.dl = eg, i.dm = [1, 1, 1], i.dn = Fu, i.dp = Ou, i.dq = Ka, i.dr = Al, i.ds = _c, i.dt = Id, i.du = Cd, i.dv = class {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new Et(1 / 0, 1 / 0), max: new Et(-1 / 0, -1 / 0) };
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(r, e = !1) {
          const n = t0(new Et(0, 0), new Et(Tt, Tt), r), o = [];
          if (e && !S_(n, this._globalClipBounds))
            return o;
          for (const u of this._activeRegions) {
            if (u.hiddenByOverlap || !S_(n, u))
              continue;
            const l = $w(u.min, u.max, r);
            o.push({ min: l.min, max: l.max, sourceId: this._sourceIds[u.priority], footprint: u.footprint, footprintTileId: u.tileId, order: u.order, clipMask: u.clipMask, clipScope: u.clipScope });
          }
          return o;
        }
        setSources(r) {
          this._setSources(r.map((e) => ({ getSourceId: () => e.cache.id, getFootprints: () => {
            const n = [];
            for (const o of e.cache.getVisibleCoordinates()) {
              const u = e.cache.getTile(o).buckets[e.layer];
              u && u.updateFootprints(o.toUnwrapped(), n);
            }
            return n;
          }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope })));
        }
        _addSource(r) {
          const e = r.getFootprints();
          if (e.length === 0)
            return;
          const n = r.getOrder(), o = r.getClipMask(), u = r.getClipScope();
          for (const l of e) {
            if (!l.footprint)
              continue;
            const f = t0(l.footprint.min, l.footprint.max, l.id);
            this._activeRegions.push({ min: f.min, max: f.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: l.id, footprint: l.footprint, order: n, clipMask: o, clipScope: u });
          }
          this._sourceIds.push(r.getSourceId());
        }
        _computeReplacement() {
          this._activeRegions.sort((e, n) => e.priority - n.priority || Pp(e.min, n.min) || Pp(e.max, n.max) || e.order - n.order || e.clipMask - n.clipMask || function(o, u) {
            const l = (f, v) => f + v;
            return o.length - u.length || o.reduce(l, "").localeCompare(u.reduce(l, ""));
          }(e.clipScope, n.clipScope));
          let r = this._activeRegions.length !== this._prevRegions.length;
          if (!r) {
            let e = 0;
            for (; !r && e !== this._activeRegions.length; ) {
              const n = this._activeRegions[e], o = this._prevRegions[e];
              r = n.priority !== o.priority || !e0(n, o) || n.order !== o.order || n.clipMask !== o.clipMask || !Ws(n.clipScope, o.clipScope), ++e;
            }
          }
          if (r) {
            ++this._updateTime;
            for (const n of this._activeRegions)
              n.order !== Ap && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, n.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, n.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, n.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, n.max.y));
            const e = (n) => {
              const o = this._activeRegions;
              if (n >= o.length)
                return n;
              const u = o[n].priority;
              for (; n < o.length && o[n].priority === u; )
                ++n;
              return n;
            };
            if (this._sourceIds.length > 1) {
              let n = 0, o = e(n);
              for (; n !== o; ) {
                let u = n;
                const l = n;
                for (; u !== o; ) {
                  const f = this._activeRegions[u];
                  f.hiddenByOverlap = !1;
                  for (let v = 0; v < l; v++) {
                    const S = this._activeRegions[v];
                    if (!S.hiddenByOverlap && f.order === Ap && S_(f, S) && (f.hiddenByOverlap = n0(f.footprint, f.tileId, S.footprint, S.tileId), f.hiddenByOverlap))
                      break;
                  }
                  ++u;
                }
                n = o, o = e(n);
              }
            }
          }
        }
        _setSources(r) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let e = r.length - 1; e >= 0; e--)
            this._addSource(r[e]);
          this._computeReplacement();
        }
      }, i.dw = class {
        constructor(r) {
          this._createGrid(r), this._createPoles(r);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const r of this._poleSegments)
            r.destroy();
          for (const r of this._gridSegments)
            r.withSkirts.destroy(), r.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(r, e) {
          const n = new Lo(), o = new qs(), u = [], l = r + 1 + 2, f = e[0] + 1, v = e[0] + 1 + (1 + e.length), S = (D, x, A) => {
            let I = D === l - 1 ? D - 2 : D === 0 ? D : D - 1;
            return I += A ? 24575 : 0, [I, x];
          };
          for (let D = 0; D < l; ++D)
            n.emplaceBack(...S(D, 0, !0));
          for (let D = 0; D < f; ++D)
            for (let x = 0; x < l; ++x)
              n.emplaceBack(...S(x, D, (x === 0 || x === l - 1) && !0));
          for (let D = 0; D < e.length; ++D) {
            const x = e[D];
            for (let A = 0; A < l; ++A)
              n.emplaceBack(...S(A, x, !0));
          }
          for (let D = 0; D < e.length; ++D) {
            const x = o.length, A = e[D] + 1 + 2, I = new qs();
            for (let k = 0; k < A - 1; k++) {
              const V = k === A - 2, U = V ? l * (v - e.length + D - k) : l;
              for (let q = 0; q < l - 1; q++) {
                const $ = k * l + q;
                k === 0 || V || q === 0 || q === l - 2 ? (I.emplaceBack($ + 1, $, $ + U), I.emplaceBack($ + U, $ + U + 1, $ + 1)) : (o.emplaceBack($ + 1, $, $ + U), o.emplaceBack($ + U, $ + U + 1, $ + 1));
              }
            }
            const M = Wn.simpleSegment(0, x, n.length, o.length - x);
            for (let k = 0; k < I.uint16.length; k += 3)
              o.emplaceBack(I.uint16[k], I.uint16[k + 1], I.uint16[k + 2]);
            const C = Wn.simpleSegment(0, x, n.length, o.length - x);
            u.push({ withoutSkirts: M, withSkirts: C });
          }
          return { vertices: n, indices: o, segments: u };
        }
        _createGrid(r) {
          const e = this._fillGridMeshWithLods(Il, Eu);
          this._gridSegments = e.segments, this._gridBuffer = r.createVertexBuffer(e.vertices, ai.members), this._gridIndexBuffer = r.createIndexBuffer(e.indices, !0);
        }
        _createPoles(r) {
          const e = new qs();
          for (let f = 0; f <= Il; f++)
            e.emplaceBack(0, f + 1, f + 2);
          this._poleIndexBuffer = r.createIndexBuffer(e, !0);
          const n = new Rr(), o = new Rr(), u = new Rr(), l = new Rr();
          this._poleSegments = [];
          for (let f = 0, v = 0; f < Su; f++) {
            const S = 360 / (1 << f);
            n.emplaceBack(0, -dr, 0, 0.5, 0), o.emplaceBack(0, -dr, 0, 0.5, 1), u.emplaceBack(0, -dr, 0, 0.5, 0.5), l.emplaceBack(0, -dr, 0, 0.5, 0.5);
            for (let D = 0; D <= Il; D++) {
              let x = D / Il, A = 0;
              const I = ei(0, S, x), [M, C, k] = mc(ia, Ll, I, dr);
              n.emplaceBack(M, C, k, x, A), o.emplaceBack(M, C, k, x, 1 - A);
              const V = vi(I);
              x = 0.5 + 0.5 * Math.sin(V), A = 0.5 + 0.5 * Math.cos(V), u.emplaceBack(M, C, k, x, A), l.emplaceBack(M, C, k, x, 1 - A);
            }
            this._poleSegments.push(Wn.simpleSegment(v, 0, 66, 64)), v += 66;
          }
          this._poleNorthVertexBuffer = r.createVertexBuffer(n, $t, !1), this._poleSouthVertexBuffer = r.createVertexBuffer(o, $t, !1), this._texturedPoleNorthVertexBuffer = r.createVertexBuffer(u, $t, !1), this._texturedPoleSouthVertexBuffer = r.createVertexBuffer(l, $t, !1);
        }
        getGridBuffers(r, e) {
          return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[r].withSkirts : this._gridSegments[r].withoutSkirts];
        }
        getPoleBuffers(r, e) {
          return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[r]];
        }
      }, i.dx = Ap, i.dy = qr, i.dz = function() {
        return !!document.fullscreenElement || !!document.webkitFullscreenElement;
      }, i.e = ge, i.e0 = rr, i.e1 = Q0, i.e2 = function(r, e, n, o, u, l, f, v, S, D, x = 1, A, I) {
        r.createArrays(), r.tilePixelRatio = Tt / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        const M = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, k = {};
        k.scaleFactor = x, k.textSizeScaleRange = M.get("text-size-scale-range"), k.iconSizeScaleRange = M.get("icon-size-scale-range");
        const [V, U] = k.textSizeScaleRange, [q, $] = k.iconSizeScaleRange;
        if (k.textScaleFactor = si(k.scaleFactor, V, U), k.iconScaleFactor = si(k.scaleFactor, q, $), r.textSizeData.kind === "composite") {
          const { minZoom: ie, maxZoom: fe } = r.textSizeData;
          k.compositeTextSizes = [C["text-size"].possiblyEvaluate(new Tn(ie), v), C["text-size"].possiblyEvaluate(new Tn(fe), v)];
        }
        if (r.iconSizeData.kind === "composite") {
          const { minZoom: ie, maxZoom: fe } = r.iconSizeData;
          k.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new Tn(ie), v), C["icon-size"].possiblyEvaluate(new Tn(fe), v)];
        }
        k.layoutTextSize = C["text-size"].possiblyEvaluate(new Tn(S + 1), v), k.layoutIconSize = C["icon-size"].possiblyEvaluate(new Tn(S + 1), v), k.textMaxSize = C["text-size"].possiblyEvaluate(new Tn(18), v);
        const H = M.get("text-rotation-alignment") === "map" && M.get("symbol-placement") !== "point", K = M.get("text-size");
        let Q = !1;
        for (const ie of r.features)
          if (ie.icon && ie.icon.nameSecondary) {
            Q = !0;
            break;
          }
        for (const ie of r.features) {
          const fe = M.get("text-font").evaluate(ie, {}, v).join(","), de = K.evaluate(ie, {}, v) * k.textScaleFactor, ue = k.layoutTextSize.evaluate(ie, {}, v) * k.textScaleFactor, Se = (k.layoutIconSize.evaluate(ie, {}, v), { horizontal: {}, vertical: void 0 }), me = ie.text;
          let Ee, ze = [0, 0];
          if (me) {
            const Ue = me.toString(), Fe = M.get("text-letter-spacing").evaluate(ie, {}, v) * tr, et = M.get("text-line-height").evaluate(ie, {}, v) * tr, dt = Kf(Ue) ? Fe : 0, tt = M.get("text-anchor").evaluate(ie, {}, v), Mt = M.get("text-variable-anchor");
            if (!Mt) {
              const St = M.get("text-radial-offset").evaluate(ie, {}, v);
              ze = St ? rx(tt, [St * tr, U_]) : M.get("text-offset").evaluate(ie, {}, v).map((Nt) => Nt * tr);
            }
            let wt = H ? "center" : M.get("text-justify").evaluate(ie, {}, v);
            const Pt = M.get("symbol-placement") === "point", rt = Pt ? M.get("text-max-width").evaluate(ie, {}, v) * tr : 1 / 0, Ut = (St) => {
              r.allowVerticalPlacement && md(Ue) && (Se.vertical = F_(me, e, n, u, fe, rt, et, tt, St, dt, ze, Ro.vertical, !0, ue, de));
            };
            if (!H && Mt) {
              const St = wt === "auto" ? Mt.map((Qt) => j_(Qt)) : [wt];
              let Nt = !1;
              for (let Qt = 0; Qt < St.length; Qt++) {
                const pi = St[Qt];
                if (!Se.horizontal[pi])
                  if (Nt)
                    Se.horizontal[pi] = Se.horizontal[0];
                  else {
                    const gi = F_(me, e, n, u, fe, rt, et, "center", pi, dt, ze, Ro.horizontal, !1, ue, de);
                    gi && (Se.horizontal[pi] = gi, Nt = gi.positionedLines.length === 1);
                  }
              }
              Ut("left");
            } else {
              if (wt === "auto" && (wt = j_(tt)), Pt || M.get("text-writing-mode").indexOf("horizontal") >= 0 || !md(Ue)) {
                const St = F_(me, e, n, u, fe, rt, et, tt, wt, dt, ze, Ro.horizontal, !1, ue, de);
                St && (Se.horizontal[wt] = St);
              }
              Ut(Pt ? "left" : wt);
            }
          }
          let Ie = !1, Re = !1;
          if (ie.icon && ie.icon.namePrimary) {
            const Ue = Lp(r.iconSizeData, C["icon-size"], v, r.zoom, ie) * k.iconScaleFactor * A, Fe = ie.icon.getPrimary().scaleSelf(Ue).serialize(), et = o[Fe];
            et && (Ee = zT(u[Fe], ie.icon.nameSecondary ? u[ie.icon.getSecondary().scaleSelf(Ue).serialize()] : void 0, M.get("icon-offset").evaluate(ie, {}, v), M.get("icon-anchor").evaluate(ie, {}, v)), Ie = et.sdf, Re = et.usvg, r.sdfIcons === void 0 ? r.sdfIcons = et.sdf : r.sdfIcons !== et.sdf && mi("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (et.pixelRatio !== r.pixelRatio || M.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          const Ve = ax(Se.horizontal) || Se.vertical;
          r.iconsInText || (r.iconsInText = !!Ve && Ve.iconsInText), (Ve || Ee) && NT(r, ie, Se, Ee, o, k, ue, 0, ze, Ie, Re, f, v, D, I, Q);
        }
        l && r.generateCollisionDebugBuffers(S, r.collisionBoxArray, k.textScaleFactor);
      }, i.e3 = Iu, i.e4 = am, i.e5 = Zr, i.e6 = Xy, i.e7 = B0, i.e8 = O, i.e9 = function(r) {
        let e = 0;
        if (new Uint32Array(r, 0, 1)[0] !== Ev) {
          const n = new Uint32Array(r, 0, 7), [, , o, u, l, f] = n;
          e = n.byteLength + u + l + f + l, (o !== r.byteLength || e >= r.byteLength) && mi("Invalid b3dm header information.");
        }
        return Iv(r, e);
      }, i.ea = function(r, e) {
        const n = zv(r);
        for (const o of n) {
          for (const u of o.meshes)
            pM(u);
          o.lights && (o.lightMeshIndex = o.meshes.length, o.meshes.push(mM(o.lights, e)));
        }
        return n;
      }, i.eb = em, i.ec = $x, i.ed = co, i.ee = function(r) {
        Hi(), Ni != null && Ni.then((e) => {
          e.keys().then((n) => {
            for (let o = 0; o < n.length - r; o++)
              e.delete(n[o]);
          });
        });
      }, i.f = function(r) {
        return r.indexOf("mapbox:") === 0;
      }, i.g = function(r, e) {
        return xn(Pn(r, { method: "GET" }), e);
      }, i.h = Le, i.i = function(r) {
        return ge.API_STYLE_REGEX.test(r) && !Ce(r);
      }, i.j = function(r) {
        return decodeURIComponent(atob(r).split("").map((e) => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""));
      }, i.k = function(r) {
        return btoa(encodeURIComponent(r).replace(/%([0-9A-F]{2})/g, (e, n) => String.fromCharCode(+("0x" + n))));
      }, i.l = Pn, i.m = Gs, i.n = function(r, e) {
        return xn(Pn(r, { type: "json" }), e);
      }, i.o = Hn, i.p = function(r, e) {
        return xn(Pn(r, { method: "POST" }), e);
      }, i.q = Ct, i.r = _r, i.s = function(r) {
        try {
          const e = self[r];
          return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }, i.t = mt, i.u = function() {
        return function r(e) {
          return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }, i.v = function(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }, i.w = mi, i.x = function() {
        return og || (og = new Th()), og;
      }, i.y = Cr, i.z = Pr;
    }), b(["./shared"], function(i) {
      function O(Ke) {
        const re = Ke ? Ke.url.toString() : void 0;
        return re ? performance.getEntriesByName(re) : [];
      }
      function j(Ke) {
        if (typeof Ke == "number" || typeof Ke == "boolean" || typeof Ke == "string" || Ke == null)
          return JSON.stringify(Ke);
        if (Array.isArray(Ke)) {
          let le = "[";
          for (const ge of Ke)
            le += `${j(ge)},`;
          return `${le}]`;
        }
        let re = "{";
        for (const le of Object.keys(Ke).sort())
          re += `${le}:${j(Ke[le])},`;
        return `${re}}`;
      }
      function Y(Ke) {
        let re = "";
        for (const le of i.bm)
          re += `/${j(Ke[le])}`;
        return re;
      }
      class J {
        constructor(re) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, re && this.replace(re);
        }
        replace(re, le) {
          this._layerConfigs = {}, this._layers = {}, this.update(re, [], le);
        }
        update(re, le, ge) {
          this._options = ge;
          for (const Ce of re)
            this._layerConfigs[Ce.id] = Ce, (this._layers[Ce.id] = i.cu(Ce, this.scope, null, this._options)).compileFilter(ge), this.keyCache[Ce.id] && delete this.keyCache[Ce.id];
          for (const Ce of le)
            delete this.keyCache[Ce], delete this._layerConfigs[Ce], delete this._layers[Ce];
          this.familiesBySource = {};
          const Le = function(Ce, Be) {
            const qe = {};
            for (let Ye = 0; Ye < Ce.length; Ye++) {
              const Qe = Ce[Ye];
              let it = Be && Be[Qe.id];
              !it && (it = Y(Qe), Qe.type === "line" && Qe.paint) && function Ct(It) {
                return typeof It == "string" && It === "line-progress" || (Array.isArray(It) ? It.some(Ct) : !(!It || typeof It != "object") && Object.values(It).some(Ct));
              }(Qe.paint["line-width"]) && (it += `/${j(Qe.paint["line-width"])}`), Be && (Be[Qe.id] = it);
              let mt = qe[it];
              mt || (mt = qe[it] = []), mt.push(Qe);
            }
            const Ae = [];
            for (const Ye in qe)
              Ae.push(qe[Ye]);
            return Ae;
          }(i.bj(this._layerConfigs), this.keyCache);
          for (const Ce of Le) {
            const Be = Ce.map((mt) => this._layers[mt.id]), qe = Be[0];
            if (qe.visibility === "none")
              continue;
            const Ae = qe.source || "";
            let Ye = this.familiesBySource[Ae];
            Ye || (Ye = this.familiesBySource[Ae] = {});
            const Qe = qe.sourceLayer || "_geojsonTileLayer";
            let it = Ye[Qe];
            it || (it = Ye[Qe] = []), it.push(Be);
          }
        }
      }
      const ae = 1 * i.dX;
      class ce {
        constructor(re) {
          const le = {}, ge = [];
          for (const qe in re) {
            const Ae = re[qe], Ye = le[qe] = {};
            for (const Qe in Ae.glyphs) {
              const it = Ae.glyphs[+Qe];
              if (!it || it.bitmap.width === 0 || it.bitmap.height === 0)
                continue;
              const mt = it.metrics.localGlyph ? ae : 1, Ct = { x: 0, y: 0, w: it.bitmap.width + 2 * mt, h: it.bitmap.height + 2 * mt };
              ge.push(Ct), Ye[Qe] = Ct;
            }
          }
          const { w: Le, h: Ce } = i.C(ge), Be = new i.dW({ width: Le || 1, height: Ce || 1 });
          for (const qe in re) {
            const Ae = re[qe];
            for (const Ye in Ae.glyphs) {
              const Qe = Ae.glyphs[+Ye];
              if (!Qe || Qe.bitmap.width === 0 || Qe.bitmap.height === 0)
                continue;
              const it = le[qe][Ye], mt = Qe.metrics.localGlyph ? ae : 1;
              i.dW.copy(Qe.bitmap, Be, { x: 0, y: 0 }, { x: it.x + mt, y: it.y + mt }, Qe.bitmap);
            }
          }
          this.image = Be, this.positions = le;
        }
      }
      i.dV(ce, "GlyphAtlas");
      class Te {
        constructor(re) {
          this.tileID = new i.aG(re.tileID.overscaledZ, re.tileID.wrap, re.tileID.canonical.z, re.tileID.canonical.x, re.tileID.canonical.y), this.tileZoom = re.tileZoom, this.uid = re.uid, this.zoom = re.zoom, this.lut = re.lut, this.canonical = re.tileID.canonical, this.pixelRatio = re.pixelRatio, this.tileSize = re.tileSize, this.source = re.source, this.scope = re.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = re.showCollisionBoxes, this.collectResourceTiming = !!re.request && re.request.collectResourceTiming, this.promoteId = re.promoteId, this.isSymbolTile = re.isSymbolTile, this.tileTransform = i.aQ(re.tileID.canonical, re.projection), this.projection = re.projection, this.worldview = re.worldview, this.localizableLayerIds = re.localizableLayerIds, this.brightness = re.brightness, this.extraShadowCaster = !!re.extraShadowCaster, this.tessellationStep = re.tessellationStep, this.scaleFactor = re.scaleFactor;
        }
        parse(re, le, ge, Le, Ce) {
          this.status = "parsing", this.data = re, this.collisionBoxArray = new i.aW();
          const Be = new i.dY(Object.keys(re.layers).sort()), qe = new i.dZ(this.tileID, this.promoteId);
          qe.bucketLayerIDs = [];
          const Ae = {}, Ye = new i.d_(256, 256), Qe = { featureIndex: qe, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: Ye, availableImages: ge, brightness: this.brightness, scaleFactor: this.scaleFactor }, it = le.familiesBySource[this.source];
          for (const ri in it) {
            const Ki = re.layers[ri];
            if (!Ki)
              continue;
            let Ni = !1, Ei = !1, $i = !1;
            for (const Gs of it[ri])
              Gs[0].type === "symbol" ? Ni = !0 : Ei = !0, Gs[0].is3D() && Gs[0].type !== "model" && ($i = !0);
            if (this.extraShadowCaster && !$i || this.isSymbolTile === !0 && !Ni || this.isSymbolTile === !1 && !Ei)
              continue;
            Ki.version === 1 && i.w(`Vector tile source "${this.source}" layer "${ri}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const Hi = Be.encode(ri), Xn = [];
            for (let Gs = 0, ps = 0; Gs < Ki.length; Gs++) {
              const vs = Ki.feature(Gs), ra = qe.getId(vs, ri);
              if (this.localizableLayerIds && this.localizableLayerIds.has(ri)) {
                const Er = vs.properties ? vs.properties.worldview : null;
                if (this.worldview && typeof Er == "string")
                  if (Er === "all")
                    vs.properties.$localized = !0;
                  else {
                    if (!Er.split(",").includes(this.worldview))
                      continue;
                    vs.properties.$localized = !0, vs.properties.worldview = this.worldview;
                  }
              }
              Xn.push({ feature: vs, id: ra, index: ps, sourceLayerIndex: Hi }), ps++;
            }
            for (const Gs of it[ri]) {
              const ps = Gs[0];
              (!this.extraShadowCaster || ps.is3D() && ps.type !== "model") && (this.isSymbolTile !== void 0 && ps.type === "symbol" !== this.isSymbolTile || ps.minzoom && this.zoom < Math.floor(ps.minzoom) || ps.maxzoom && this.zoom >= ps.maxzoom || ps.visibility !== "none" && (be(Gs, this.zoom, Qe.brightness, ge), (Ae[ps.id] = ps.createBucket({ index: qe.bucketLayerIDs.length, layers: Gs, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Hi, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(Xn, Qe, this.tileID.canonical, this.tileTransform), qe.bucketLayerIDs.push(Gs.map((vs) => i.aC(vs.id, vs.scope)))));
            }
          }
          let mt, Ct, It, Kt;
          Ye.trim();
          const di = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, li = () => {
            if (mt)
              return this.status = "done", Ce(mt);
            if (this.extraShadowCaster)
              this.status = "done", Ce(null, { buckets: i.bj(Ae).filter((ri) => !ri.isEmpty()), featureIndex: qe, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: Qe.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (Ct && It && Kt) {
              const ri = new ce(Ct), Ki = new i.e1(It, Kt, this.lut);
              for (const Ni in Ae) {
                const Ei = Ae[Ni];
                Ei instanceof i.aX ? (be(Ei.layers, this.zoom, Qe.brightness, ge), i.e2(Ei, Ct, ri.positions, It, Ki.iconPositions, this.showCollisionBoxes, ge, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : Ei.hasPattern && (Ei instanceof i.b1 || Ei instanceof i.b2 || Ei instanceof i.d5) && (be(Ei.layers, this.zoom, Qe.brightness, ge), Ei.addFeatures(Qe, this.tileID.canonical, Ki.patternPositions, ge, this.tileTransform, this.brightness));
              }
              this.status = "done", Ce(null, { buckets: i.bj(Ae).filter((Ni) => !Ni.isEmpty()), featureIndex: qe, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ri.image, lineAtlas: Ye, imageAtlas: Ki, brightness: Qe.brightness });
            }
          };
          if (!this.extraShadowCaster) {
            const ri = i.d$(Qe.glyphDependencies, (Ei) => Object.keys(Ei).map(Number));
            Object.keys(ri).length ? Le.send("getGlyphs", { uid: this.uid, stacks: ri, scope: this.scope }, (Ei, $i) => {
              mt || (mt = Ei, Ct = $i, li());
            }, void 0, !1, di) : Ct = {};
            const Ki = Object.keys(Qe.iconDependencies);
            Ki.length ? Le.send("getImages", { icons: Ki, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (Ei, $i) => {
              if (mt)
                return;
              mt = Ei;
              const Hi = {};
              Object.values($i).some((Xn) => Xn.usvg) ? this.rasterize(Le, Hi, $i, Qe.iconDependencies, () => {
                It = Hi, li();
              }) : (this.fillImageMap(Hi, Qe.iconDependencies, $i), It = Hi, li());
            }, void 0, !1, di) : It = {};
            const Ni = Object.keys(Qe.patternDependencies);
            Ni.length ? Le.send("getImages", { icons: Ni, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (Ei, $i) => {
              if (!mt) {
                mt = Ei;
                const Hi = {};
                Object.values($i).some((Xn) => Xn.usvg) ? this.rasterize(Le, Hi, $i, Qe.patternDependencies, () => {
                  Kt = Hi, li();
                }) : (this.fillImageMap(Hi, Qe.patternDependencies, $i), Kt = Hi, li());
              }
            }, void 0, !1, di) : Kt = {};
          }
          li();
        }
        fillImageMap(re, le, ge) {
          for (const Le in ge) {
            const Ce = le[Le] || [];
            for (const Be of Ce)
              ge[Be.id].usvg || (re[Be.serialize()] = ge[Be.id]);
          }
        }
        getImageTaskQueue(re, le, ge) {
          const Le = {};
          for (const Ce in le) {
            const Be = ge[Ce] || [];
            for (const qe of Be) {
              const Ae = qe.serialize();
              le[qe.id].usvg ? Le[Ae] || (Le[Ae] = qe) : re[Ae] = le[qe.id];
            }
          }
          return Le;
        }
        rasterize(re, le, ge, Le, Ce) {
          const Be = this.getImageTaskQueue(le, ge, Le);
          this.rasterizeTask = re.send("rasterizeImages", { scope: this.scope, imageTasks: Be }, (qe, Ae) => {
            if (!qe)
              for (const Ye in Ae) {
                const { id: Qe } = i.e0.deserializeFromString(Ye);
                le[Ye] = Object.assign({}, ge[Qe], { data: Ae[Ye] });
              }
            Ce();
          });
        }
        cancelRasterize() {
          this.rasterizeTask && this.rasterizeTask.cancel();
        }
      }
      function be(Ke, re, le, ge) {
        const Le = new i.a8(re, { brightness: le });
        for (const Ce of Ke)
          Ce.recalculate(Le, ge);
      }
      class Ze extends i.E {
        constructor(re, le, ge, Le, Ce, Be) {
          super(), this.actor = re, this.layerIndex = le, this.availableImages = ge, this.loadVectorData = Ce || i.aD, this.loading = {}, this.loaded = {}, this.deduped = new i.aB(re.scheduler), this.isSpriteLoaded = Le, this.scheduler = re.scheduler, this.brightness = Be;
        }
        loadTile(re, le) {
          const ge = re.uid, Le = re && re.request, Ce = Le && Le.collectResourceTiming, Be = this.loading[ge] = new Te(re);
          Be.abort = this.loadVectorData(re, (qe, Ae) => {
            const Ye = !this.loading[ge];
            if (delete this.loading[ge], Be.cancelRasterize(), Ye || qe || !Ae)
              return Be.status = "done", Ye || (this.loaded[ge] = Be), le(qe);
            const Qe = Ae.rawData, it = {};
            Ae.expires && (it.expires = Ae.expires), Ae.cacheControl && (it.cacheControl = Ae.cacheControl), Be.vectorTile = Ae.vectorTile || new i.e3.VectorTile(new i.bh(Qe));
            const mt = () => {
              Be.parse(Be.vectorTile, this.layerIndex, this.availableImages, this.actor, (Ct, It) => {
                if (Ct || !It)
                  return le(Ct);
                const Kt = {};
                if (Ce) {
                  const di = O(Le);
                  di.length > 0 && (Kt.resourceTiming = JSON.parse(JSON.stringify(di)));
                }
                le(null, i.l({ rawTileData: Qe.slice(0) }, It, it, Kt));
              });
            };
            this.isSpriteLoaded ? mt() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(mt, { type: "parseTile", isSymbolTile: re.isSymbolTile, zoom: re.tileZoom }) : mt();
            }), this.loaded = this.loaded || {}, this.loaded[ge] = Be;
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          if (ge && ge[Le]) {
            const Ce = ge[Le];
            Ce.scaleFactor = re.scaleFactor, Ce.showCollisionBoxes = re.showCollisionBoxes, Ce.projection = re.projection, Ce.brightness = re.brightness, Ce.tileTransform = i.aQ(re.tileID.canonical, re.projection), Ce.extraShadowCaster = re.extraShadowCaster, Ce.lut = re.lut;
            const Be = (qe, Ae) => {
              const Ye = Ce.reloadCallback;
              Ye && (delete Ce.reloadCallback, Ce.parse(Ce.vectorTile, this.layerIndex, this.availableImages, this.actor, Ye)), le(qe, Ae);
            };
            Ce.status === "parsing" ? Ce.reloadCallback = Be : Ce.status === "done" && (Ce.vectorTile ? Ce.parse(Ce.vectorTile, this.layerIndex, this.availableImages, this.actor, Be) : Be());
          } else
            le(null, void 0);
        }
        abortTile(re, le) {
          const ge = re.uid, Le = this.loading[ge];
          Le && (Le.abort && Le.abort(), delete this.loading[ge]), le();
        }
        removeTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          ge && ge[Le] && delete ge[Le], le();
        }
      }
      class je {
        loadTile(re, le) {
          const { uid: ge, encoding: Le, rawImageData: Ce, padding: Be } = re, qe = ImageBitmap && Ce instanceof ImageBitmap ? this.getImageData(Ce, Be) : Ce;
          le(null, new i.e4(ge, qe, Le, Be < 1));
        }
        getImageData(re, le) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(re.width, re.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = re.width, this.offscreenCanvas.height = re.height, this.offscreenCanvasContext.drawImage(re, 0, 0, re.width, re.height);
          const ge = this.offscreenCanvasContext.getImageData(-le, -le, re.width + 2 * le, re.height + 2 * le);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), ge;
        }
      }
      i.bg.setPbf(i.bh);
      class ot {
        decodeRasterArray({ task: re, buffer: le }, ge) {
          i.bg.performDecoding(le, re).then((Le) => {
            ge(null, Le);
          }, (Le) => {
            ge(Le);
          });
        }
      }
      const vt = i.e3.VectorTileFeature.prototype.toGeoJSON;
      class ht {
        constructor(re) {
          this._feature = re, this.extent = i.ag, this.type = re.type, this.properties = re.tags, "id" in re && !isNaN(re.id) && (this.id = parseInt(re.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const re = [];
            for (const le of this._feature.geometry)
              re.push([new i.P(le[0], le[1])]);
            return re;
          }
          {
            const re = [];
            for (const le of this._feature.geometry) {
              const ge = [];
              for (const Le of le)
                ge.push(new i.P(Le[0], Le[1]));
              re.push(ge);
            }
            return re;
          }
        }
        toGeoJSON(re, le, ge) {
          return vt.call(this, re, le, ge);
        }
      }
      class gt {
        constructor(re) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = i.ag, this.length = re.length, this._features = re;
        }
        feature(re) {
          return new ht(this._features[re]);
        }
      }
      const Vt = 64 / 4096, pt = 128;
      class Gt {
        constructor() {
          this.features = /* @__PURE__ */ new Map();
        }
        clear() {
          this.features.clear();
        }
        load(re = [], le) {
          for (const ge of re) {
            const Le = ge.id;
            if (Le == null)
              continue;
            let Ce = this.features.get(Le);
            Ce && this.updateCache(Ce, le), ge.geometry ? (Ce = kt(ge), this.updateCache(Ce, le), this.features.set(Le, Ce)) : this.features.delete(Le), this.updateCache(Ce, le);
          }
        }
        updateCache(re, le) {
          for (const { canonical: ge, uid: Le } of Object.values(le)) {
            const { z: Ce, x: Be, y: qe } = ge;
            ui(re, Math.pow(2, Ce), Be, qe) && delete le[Le];
          }
        }
        getTile(re, le, ge) {
          const Le = Math.pow(2, re), Ce = [];
          for (const Be of this.features.values())
            ui(Be, Le, le, ge) && Ce.push(hn(Be, Le, le, ge));
          return { features: Ce };
        }
        getFeatures() {
          return [...this.features.values()];
        }
      }
      function ui({ minX: Ke, minY: re, maxX: le, maxY: ge }, Le, Ce, Be) {
        return Ke < (Ce + 1 + Vt) / Le && re < (Be + 1 + Vt) / Le && le > (Ce - Vt) / Le && ge > (Be - Vt) / Le;
      }
      function kt(Ke) {
        const { id: re, geometry: le, properties: ge } = Ke;
        if (!le)
          return;
        if (le.type === "GeometryCollection")
          throw new Error("GeometryCollection not supported in dynamic mode.");
        const { type: Le, coordinates: Ce } = le, Be = { id: re, type: 1, geometry: [], tags: ge, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, qe = Be.geometry;
        if (Le === "Point")
          At(Ce, qe, Be);
        else if (Le === "MultiPoint")
          for (const Ae of Ce)
            At(Ae, qe, Be);
        else if (Le === "LineString")
          Be.type = 2, Mi(Ce, qe, Be);
        else if (Le === "MultiLineString")
          Be.type = 2, An(Ce, qe, Be);
        else if (Le === "Polygon")
          Be.type = 3, An(Ce, qe, Be, !0);
        else {
          if (Le !== "MultiPolygon")
            throw new Error("Input data is not a valid GeoJSON object.");
          Be.type = 3;
          for (const Ae of Ce)
            An(Ae, qe, Be, !0);
        }
        return Be;
      }
      function At([Ke, re], le, ge) {
        const Le = i.at(Ke);
        let Ce = i.aA(re);
        Ce = Ce < 0 ? 0 : Ce > 1 ? 1 : Ce, le.push(Le, Ce), ge.minX = Math.min(ge.minX, Le), ge.minY = Math.min(ge.minY, Ce), ge.maxX = Math.max(ge.maxX, Le), ge.maxY = Math.max(ge.maxY, Ce);
      }
      function Mi(Ke, re, le, ge = !1, Le = !1) {
        const Ce = [];
        for (const Be of Ke)
          At(Be, Ce, le);
        re.push(Ce), ge && function(Be, qe) {
          let Ae = 0;
          for (let Ye = 0, Qe = Be.length, it = Qe - 2; Ye < Qe; it = Ye, Ye += 2)
            Ae += (Be[Ye] - Be[it]) * (Be[Ye + 1] + Be[it + 1]);
          if (Ae > 0 === qe)
            for (let Ye = 0, Qe = Be.length; Ye < Qe / 2; Ye += 2) {
              const it = Be[Ye], mt = Be[Ye + 1];
              Be[Ye] = Be[Qe - 2 - Ye], Be[Ye + 1] = Be[Qe - 1 - Ye], Be[Qe - 2 - Ye] = it, Be[Qe - 1 - Ye] = mt;
            }
        }(Ce, Le);
      }
      function An(Ke, re, le, ge = !1) {
        for (let Le = 0; Le < Ke.length; Le++)
          Mi(Ke[Le], re, le, ge, Le === 0);
      }
      function hn(Ke, re, le, ge) {
        const { id: Le, type: Ce, geometry: Be, tags: qe } = Ke, Ae = [];
        if (Ce === 1)
          (function(Ye, Qe, it, mt, Ct) {
            for (let It = 0; It < Ye.length; It += 2) {
              const Kt = Math.round(i.ag * (Ye[It + 0] * Qe - it)), di = Math.round(i.ag * (Ye[It + 1] * Qe - mt));
              Ct.push([Kt, di]);
            }
          })(Be, re, le, ge, Ae);
        else
          for (const Ye of Be)
            Ht(Ye, re, le, ge, Ae);
        return { id: Le, type: Ce, geometry: Ae, tags: qe };
      }
      function Ht(Ke, re, le, ge, Le) {
        const Ce = -pt, Be = i.ag + pt;
        let qe;
        for (let Ae = 0; Ae < Ke.length - 2; Ae += 2) {
          let Ye = Math.round(i.ag * (Ke[Ae + 0] * re - le)), Qe = Math.round(i.ag * (Ke[Ae + 1] * re - ge)), it = Math.round(i.ag * (Ke[Ae + 2] * re - le)), mt = Math.round(i.ag * (Ke[Ae + 3] * re - ge));
          const Ct = it - Ye, It = mt - Qe;
          Ye < Ce && it < Ce || (Ye < Ce ? (Qe += Math.round(It * ((Ce - Ye) / Ct)), Ye = Ce) : it < Ce && (mt = Qe + Math.round(It * ((Ce - Ye) / Ct)), it = Ce), Qe < Ce && mt < Ce || (Qe < Ce ? (Ye += Math.round(Ct * ((Ce - Qe) / It)), Qe = Ce) : mt < Ce && (it = Ye + Math.round(Ct * ((Ce - Qe) / It)), mt = Ce), Ye >= Be && it >= Be || (Ye >= Be ? (Qe += Math.round(It * ((Be - Ye) / Ct)), Ye = Be) : it >= Be && (mt = Qe + Math.round(It * ((Be - Ye) / Ct)), it = Be), Qe >= Be && mt >= Be || (Qe >= Be ? (Ye += Math.round(Ct * ((Be - Qe) / It)), Qe = Be) : mt >= Be && (it = Ye + Math.round(Ct * ((Be - Qe) / It)), mt = Be), qe && Ye === qe[qe.length - 1][0] && Qe === qe[qe.length - 1][1] || (qe = [[Ye, Qe]], Le.push(qe)), qe.push([it, mt])))));
        }
      }
      var Si, Ji, fi, jt = { exports: {} }, ni = function() {
        if (fi)
          return jt.exports;
        fi = 1;
        var Ke = i.e7(), re = function() {
          if (Ji)
            return Si;
          Ji = 1;
          var Qe = i.e5(), it = i.e6().VectorTileFeature;
          function mt(It, Kt) {
            this.options = Kt || {}, this.features = It, this.length = It.length;
          }
          function Ct(It, Kt) {
            this.id = typeof It.id == "number" ? It.id : void 0, this.type = It.type, this.rawGeometry = It.type === 1 ? [It.geometry] : It.geometry, this.properties = It.tags, this.extent = Kt || 4096;
          }
          return Si = mt, mt.prototype.feature = function(It) {
            return new Ct(this.features[It], this.options.extent);
          }, Ct.prototype.loadGeometry = function() {
            var It = this.rawGeometry;
            this.geometry = [];
            for (var Kt = 0; Kt < It.length; Kt++) {
              for (var di = It[Kt], li = [], ri = 0; ri < di.length; ri++)
                li.push(new Qe(di[ri][0], di[ri][1]));
              this.geometry.push(li);
            }
            return this.geometry;
          }, Ct.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var It = this.geometry, Kt = 1 / 0, di = -1 / 0, li = 1 / 0, ri = -1 / 0, Ki = 0; Ki < It.length; Ki++)
              for (var Ni = It[Ki], Ei = 0; Ei < Ni.length; Ei++) {
                var $i = Ni[Ei];
                Kt = Math.min(Kt, $i.x), di = Math.max(di, $i.x), li = Math.min(li, $i.y), ri = Math.max(ri, $i.y);
              }
            return [Kt, li, di, ri];
          }, Ct.prototype.toGeoJSON = it.prototype.toGeoJSON, Si;
        }();
        function le(Qe) {
          var it = new Ke();
          return function(mt, Ct) {
            for (var It in mt.layers)
              Ct.writeMessage(3, ge, mt.layers[It]);
          }(Qe, it), it.finish();
        }
        function ge(Qe, it) {
          var mt;
          it.writeVarintField(15, Qe.version || 1), it.writeStringField(1, Qe.name || ""), it.writeVarintField(5, Qe.extent || 4096);
          var Ct = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (mt = 0; mt < Qe.length; mt++)
            Ct.feature = Qe.feature(mt), it.writeMessage(2, Le, Ct);
          var It = Ct.keys;
          for (mt = 0; mt < It.length; mt++)
            it.writeStringField(3, It[mt]);
          var Kt = Ct.values;
          for (mt = 0; mt < Kt.length; mt++)
            it.writeMessage(4, Ye, Kt[mt]);
        }
        function Le(Qe, it) {
          var mt = Qe.feature;
          mt.id !== void 0 && it.writeVarintField(1, mt.id), it.writeMessage(2, Ce, Qe), it.writeVarintField(3, mt.type), it.writeMessage(4, Ae, mt);
        }
        function Ce(Qe, it) {
          var mt = Qe.feature, Ct = Qe.keys, It = Qe.values, Kt = Qe.keycache, di = Qe.valuecache;
          for (var li in mt.properties) {
            var ri = mt.properties[li], Ki = Kt[li];
            if (ri !== null) {
              Ki === void 0 && (Ct.push(li), Kt[li] = Ki = Ct.length - 1), it.writeVarint(Ki);
              var Ni = typeof ri;
              Ni !== "string" && Ni !== "boolean" && Ni !== "number" && (ri = JSON.stringify(ri));
              var Ei = Ni + ":" + ri, $i = di[Ei];
              $i === void 0 && (It.push(ri), di[Ei] = $i = It.length - 1), it.writeVarint($i);
            }
          }
        }
        function Be(Qe, it) {
          return (it << 3) + (7 & Qe);
        }
        function qe(Qe) {
          return Qe << 1 ^ Qe >> 31;
        }
        function Ae(Qe, it) {
          for (var mt = Qe.loadGeometry(), Ct = Qe.type, It = 0, Kt = 0, di = mt.length, li = 0; li < di; li++) {
            var ri = mt[li], Ki = 1;
            Ct === 1 && (Ki = ri.length), it.writeVarint(Be(1, Ki));
            for (var Ni = Ct === 3 ? ri.length - 1 : ri.length, Ei = 0; Ei < Ni; Ei++) {
              Ei === 1 && Ct !== 1 && it.writeVarint(Be(2, Ni - 1));
              var $i = ri[Ei].x - It, Hi = ri[Ei].y - Kt;
              it.writeVarint(qe($i)), it.writeVarint(qe(Hi)), It += $i, Kt += Hi;
            }
            Ct === 3 && it.writeVarint(Be(7, 1));
          }
        }
        function Ye(Qe, it) {
          var mt = typeof Qe;
          mt === "string" ? it.writeStringField(1, Qe) : mt === "boolean" ? it.writeBooleanField(7, Qe) : mt === "number" && (Qe % 1 != 0 ? it.writeDoubleField(3, Qe) : Qe < 0 ? it.writeSVarintField(6, Qe) : it.writeVarintField(5, Qe));
        }
        return jt.exports = le, jt.exports.fromVectorTileJs = le, jt.exports.fromGeojsonVt = function(Qe, it) {
          it = it || {};
          var mt = {};
          for (var Ct in Qe)
            mt[Ct] = new re(Qe[Ct].features, it), mt[Ct].name = Ct, mt[Ct].version = it.version, mt[Ct].extent = it.extent;
          return le({ layers: mt });
        }, jt.exports.GeoJSONWrapper = re, jt.exports;
      }(), Gi = i.e8(ni);
      const an = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Ke) => Ke }, qt = Math.fround || (ln = new Float32Array(1), (Ke) => (ln[0] = +Ke, ln[0]));
      var ln;
      const Di = 3, xi = 5, Cs = 6;
      class xs {
        constructor(re) {
          this.options = Object.assign(Object.create(an), re), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(re) {
          const { log: le, minZoom: ge, maxZoom: Le } = this.options;
          le && console.time("total time");
          const Ce = `prepare ${re.length} points`;
          le && console.time(Ce), this.points = re;
          const Be = [];
          for (let Ae = 0; Ae < re.length; Ae++) {
            const Ye = re[Ae];
            if (!Ye.geometry)
              continue;
            const [Qe, it] = Ye.geometry.coordinates, mt = qt(Vs(Qe)), Ct = qt(Us(it));
            Be.push(mt, Ct, 1 / 0, Ae, -1, 1), this.options.reduce && Be.push(0);
          }
          let qe = this.trees[Le + 1] = this._createTree(Be);
          le && console.timeEnd(Ce);
          for (let Ae = Le; Ae >= ge; Ae--) {
            const Ye = +Date.now();
            qe = this.trees[Ae] = this._createTree(this._cluster(qe, Ae)), le && console.log("z%d: %d clusters in %dms", Ae, qe.numItems, +Date.now() - Ye);
          }
          return le && console.timeEnd("total time"), this;
        }
        getClusters(re, le) {
          let ge = ((re[0] + 180) % 360 + 360) % 360 - 180;
          const Le = Math.max(-90, Math.min(90, re[1]));
          let Ce = re[2] === 180 ? 180 : ((re[2] + 180) % 360 + 360) % 360 - 180;
          const Be = Math.max(-90, Math.min(90, re[3]));
          if (re[2] - re[0] >= 360)
            ge = -180, Ce = 180;
          else if (ge > Ce) {
            const it = this.getClusters([ge, Le, 180, Be], le), mt = this.getClusters([-180, Le, Ce, Be], le);
            return it.concat(mt);
          }
          const qe = this.trees[this._limitZoom(le)], Ae = qe.range(Vs(ge), Us(Be), Vs(Ce), Us(Le)), Ye = qe.data, Qe = [];
          for (const it of Ae) {
            const mt = this.stride * it;
            Qe.push(Ye[mt + xi] > 1 ? Is(Ye, mt, this.clusterProps) : this.points[Ye[mt + Di]]);
          }
          return Qe;
        }
        getChildren(re) {
          const le = this._getOriginId(re), ge = this._getOriginZoom(re), Le = "No cluster with the specified id.", Ce = this.trees[ge];
          if (!Ce)
            throw new Error(Le);
          const Be = Ce.data;
          if (le * this.stride >= Be.length)
            throw new Error(Le);
          const qe = this.options.radius / (this.options.extent * Math.pow(2, ge - 1)), Ae = Ce.within(Be[le * this.stride], Be[le * this.stride + 1], qe), Ye = [];
          for (const Qe of Ae) {
            const it = Qe * this.stride;
            Be[it + 4] === re && Ye.push(Be[it + xi] > 1 ? Is(Be, it, this.clusterProps) : this.points[Be[it + Di]]);
          }
          if (Ye.length === 0)
            throw new Error(Le);
          return Ye;
        }
        getLeaves(re, le, ge) {
          const Le = [];
          return this._appendLeaves(Le, re, le = le || 10, ge = ge || 0, 0), Le;
        }
        getTile(re, le, ge) {
          const Le = this.trees[this._limitZoom(re)], Ce = Math.pow(2, re), { extent: Be, radius: qe } = this.options, Ae = qe / Be, Ye = (ge - Ae) / Ce, Qe = (ge + 1 + Ae) / Ce, it = { features: [] };
          return this._addTileFeatures(Le.range((le - Ae) / Ce, Ye, (le + 1 + Ae) / Ce, Qe), Le.data, le, ge, Ce, it), le === 0 && this._addTileFeatures(Le.range(1 - Ae / Ce, Ye, 1, Qe), Le.data, Ce, ge, Ce, it), le === Ce - 1 && this._addTileFeatures(Le.range(0, Ye, Ae / Ce, Qe), Le.data, -1, ge, Ce, it), it.features.length ? it : null;
        }
        getClusterExpansionZoom(re) {
          let le = this._getOriginZoom(re) - 1;
          for (; le <= this.options.maxZoom; ) {
            const ge = this.getChildren(re);
            if (le++, ge.length !== 1)
              break;
            re = ge[0].properties.cluster_id;
          }
          return le;
        }
        _appendLeaves(re, le, ge, Le, Ce) {
          const Be = this.getChildren(le);
          for (const qe of Be) {
            const Ae = qe.properties;
            if (Ae && Ae.cluster ? Ce + Ae.point_count <= Le ? Ce += Ae.point_count : Ce = this._appendLeaves(re, Ae.cluster_id, ge, Le, Ce) : Ce < Le ? Ce++ : re.push(qe), re.length === ge)
              break;
          }
          return Ce;
        }
        _createTree(re) {
          const le = new i.bE(re.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let ge = 0; ge < re.length; ge += this.stride)
            le.add(re[ge], re[ge + 1]);
          return le.finish(), le.data = re, le;
        }
        _addTileFeatures(re, le, ge, Le, Ce, Be) {
          for (const qe of re) {
            const Ae = qe * this.stride, Ye = le[Ae + xi] > 1;
            let Qe, it, mt;
            if (Ye)
              Qe = De(le, Ae, this.clusterProps), it = le[Ae], mt = le[Ae + 1];
            else {
              const Kt = this.points[le[Ae + Di]];
              Qe = Kt.properties;
              const [di, li] = Kt.geometry.coordinates;
              it = Vs(di), mt = Us(li);
            }
            const Ct = { type: 1, geometry: [[Math.round(this.options.extent * (it * Ce - ge)), Math.round(this.options.extent * (mt * Ce - Le))]], tags: Qe };
            let It;
            It = Ye || this.options.generateId ? le[Ae + Di] : this.points[le[Ae + Di]].id, It !== void 0 && (Ct.id = It), Be.features.push(Ct);
          }
        }
        _limitZoom(re) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+re), this.options.maxZoom + 1));
        }
        _cluster(re, le) {
          const { radius: ge, extent: Le, reduce: Ce, minPoints: Be } = this.options, qe = ge / (Le * Math.pow(2, le)), Ae = re.data, Ye = [], Qe = this.stride;
          for (let it = 0; it < Ae.length; it += Qe) {
            if (Ae[it + 2] <= le)
              continue;
            Ae[it + 2] = le;
            const mt = Ae[it], Ct = Ae[it + 1], It = re.within(Ae[it], Ae[it + 1], qe), Kt = Ae[it + xi];
            let di = Kt;
            for (const li of It) {
              const ri = li * Qe;
              Ae[ri + 2] > le && (di += Ae[ri + xi]);
            }
            if (di > Kt && di >= Be) {
              let li, ri = mt * Kt, Ki = Ct * Kt, Ni = -1;
              const Ei = (it / Qe << 5) + (le + 1) + this.points.length;
              for (const $i of It) {
                const Hi = $i * Qe;
                if (Ae[Hi + 2] <= le)
                  continue;
                Ae[Hi + 2] = le;
                const Xn = Ae[Hi + xi];
                ri += Ae[Hi] * Xn, Ki += Ae[Hi + 1] * Xn, Ae[Hi + 4] = Ei, Ce && (li || (li = this._map(Ae, it, !0), Ni = this.clusterProps.length, this.clusterProps.push(li)), Ce(li, this._map(Ae, Hi)));
              }
              Ae[it + 4] = Ei, Ye.push(ri / di, Ki / di, 1 / 0, Ei, -1, di), Ce && Ye.push(Ni);
            } else {
              for (let li = 0; li < Qe; li++)
                Ye.push(Ae[it + li]);
              if (di > 1)
                for (const li of It) {
                  const ri = li * Qe;
                  if (!(Ae[ri + 2] <= le)) {
                    Ae[ri + 2] = le;
                    for (let Ki = 0; Ki < Qe; Ki++)
                      Ye.push(Ae[ri + Ki]);
                  }
                }
            }
          }
          return Ye;
        }
        _getOriginId(re) {
          return re - this.points.length >> 5;
        }
        _getOriginZoom(re) {
          return (re - this.points.length) % 32;
        }
        _map(re, le, ge) {
          if (re[le + xi] > 1) {
            const Be = this.clusterProps[re[le + Cs]];
            return ge ? Object.assign({}, Be) : Be;
          }
          const Le = this.points[re[le + Di]].properties, Ce = this.options.map(Le);
          return ge && Ce === Le ? Object.assign({}, Ce) : Ce;
        }
      }
      function Is(Ke, re, le) {
        return { type: "Feature", id: Ke[re + Di], properties: De(Ke, re, le), geometry: { type: "Point", coordinates: [(ge = Ke[re], 360 * (ge - 0.5)), Zr(Ke[re + 1])] } };
        var ge;
      }
      function De(Ke, re, le) {
        const ge = Ke[re + xi], Le = ge >= 1e4 ? `${Math.round(ge / 1e3)}k` : ge >= 1e3 ? Math.round(ge / 100) / 10 + "k" : ge, Ce = Ke[re + Cs], Be = Ce === -1 ? {} : Object.assign({}, le[Ce]);
        return Object.assign(Be, { cluster: !0, cluster_id: Ke[re + Di], point_count: ge, point_count_abbreviated: Le });
      }
      function Vs(Ke) {
        return Ke / 360 + 0.5;
      }
      function Us(Ke) {
        const re = Math.sin(Ke * Math.PI / 180), le = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
        return le < 0 ? 0 : le > 1 ? 1 : le;
      }
      function Zr(Ke) {
        const re = (180 - 360 * Ke) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(re)) / Math.PI - 90;
      }
      function Et(Ke, re, le, ge) {
        let Le = ge;
        const Ce = re + (le - re >> 1);
        let Be, qe = le - re;
        const Ae = Ke[re], Ye = Ke[re + 1], Qe = Ke[le], it = Ke[le + 1];
        for (let mt = re + 3; mt < le; mt += 3) {
          const Ct = Ws(Ke[mt], Ke[mt + 1], Ae, Ye, Qe, it);
          if (Ct > Le)
            Be = mt, Le = Ct;
          else if (Ct === Le) {
            const It = Math.abs(mt - Ce);
            It < qe && (Be = mt, qe = It);
          }
        }
        Le > ge && (Be - re > 3 && Et(Ke, re, Be, ge), Ke[Be + 2] = Le, le - Be > 3 && Et(Ke, Be, le, ge));
      }
      function Ws(Ke, re, le, ge, Le, Ce) {
        let Be = Le - le, qe = Ce - ge;
        if (Be !== 0 || qe !== 0) {
          const Ae = ((Ke - le) * Be + (re - ge) * qe) / (Be * Be + qe * qe);
          Ae > 1 ? (le = Le, ge = Ce) : Ae > 0 && (le += Be * Ae, ge += qe * Ae);
        }
        return Be = Ke - le, qe = re - ge, Be * Be + qe * qe;
      }
      function $n(Ke, re, le, ge) {
        const Le = { id: Ke ?? null, type: re, geometry: le, tags: ge, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (re === "Point" || re === "MultiPoint" || re === "LineString")
          $s(Le, le);
        else if (re === "Polygon")
          $s(Le, le[0]);
        else if (re === "MultiLineString")
          for (const Ce of le)
            $s(Le, Ce);
        else if (re === "MultiPolygon")
          for (const Ce of le)
            $s(Le, Ce[0]);
        return Le;
      }
      function $s(Ke, re) {
        for (let le = 0; le < re.length; le += 3)
          Ke.minX = Math.min(Ke.minX, re[le]), Ke.minY = Math.min(Ke.minY, re[le + 1]), Ke.maxX = Math.max(Ke.maxX, re[le]), Ke.maxY = Math.max(Ke.maxY, re[le + 1]);
      }
      function vi(Ke, re, le, ge) {
        if (!re.geometry)
          return;
        const Le = re.geometry.coordinates;
        if (Le && Le.length === 0)
          return;
        const Ce = re.geometry.type, Be = Math.pow(le.tolerance / ((1 << le.maxZoom) * le.extent), 2);
        let qe = [], Ae = re.id;
        if (le.promoteId ? Ae = re.properties[le.promoteId] : le.generateId && (Ae = ge || 0), Ce === "Point")
          kn(Le, qe);
        else if (Ce === "MultiPoint")
          for (const Ye of Le)
            kn(Ye, qe);
        else if (Ce === "LineString")
          Xs(Le, qe, Be, !1);
        else if (Ce === "MultiLineString") {
          if (le.lineMetrics) {
            for (const Ye of Le)
              qe = [], Xs(Ye, qe, Be, !1), Ke.push($n(Ae, "LineString", qe, re.properties));
            return;
          }
          Hr(Le, qe, Be, !1);
        } else if (Ce === "Polygon")
          Hr(Le, qe, Be, !0);
        else {
          if (Ce !== "MultiPolygon") {
            if (Ce === "GeometryCollection") {
              for (const Ye of re.geometry.geometries)
                vi(Ke, { id: Ae, geometry: Ye, properties: re.properties }, le, ge);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const Ye of Le) {
            const Qe = [];
            Hr(Ye, Qe, Be, !0), qe.push(Qe);
          }
        }
        Ke.push($n(Ae, Ce, qe, re.properties));
      }
      function kn(Ke, re) {
        re.push(qr(Ke[0]), Wr(Ke[1]), 0);
      }
      function Xs(Ke, re, le, ge) {
        let Le, Ce, Be = 0;
        for (let Ae = 0; Ae < Ke.length; Ae++) {
          const Ye = qr(Ke[Ae][0]), Qe = Wr(Ke[Ae][1]);
          re.push(Ye, Qe, 0), Ae > 0 && (Be += ge ? (Le * Qe - Ye * Ce) / 2 : Math.sqrt(Math.pow(Ye - Le, 2) + Math.pow(Qe - Ce, 2))), Le = Ye, Ce = Qe;
        }
        const qe = re.length - 3;
        re[2] = 1, Et(re, 0, qe, le), re[qe + 2] = 1, re.size = Math.abs(Be), re.start = 0, re.end = re.size;
      }
      function Hr(Ke, re, le, ge) {
        for (let Le = 0; Le < Ke.length; Le++) {
          const Ce = [];
          Xs(Ke[Le], Ce, le, ge), re.push(Ce);
        }
      }
      function qr(Ke) {
        return Ke / 360 + 0.5;
      }
      function Wr(Ke) {
        const re = Math.sin(Ke * Math.PI / 180), le = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
        return le < 0 ? 0 : le > 1 ? 1 : le;
      }
      function si(Ke, re, le, ge, Le, Ce, Be, qe) {
        if (ge /= re, Ce >= (le /= re) && Be < ge)
          return Ke;
        if (Be < le || Ce >= ge)
          return null;
        const Ae = [];
        for (const Ye of Ke) {
          const Qe = Ye.geometry;
          let it = Ye.type;
          const mt = Le === 0 ? Ye.minX : Ye.minY, Ct = Le === 0 ? Ye.maxX : Ye.maxY;
          if (mt >= le && Ct < ge) {
            Ae.push(Ye);
            continue;
          }
          if (Ct < le || mt >= ge)
            continue;
          let It = [];
          if (it === "Point" || it === "MultiPoint")
            fs(Qe, It, le, ge, Le);
          else if (it === "LineString")
            zn(Qe, It, le, ge, Le, !1, qe.lineMetrics);
          else if (it === "MultiLineString")
            Pn(Qe, It, le, ge, Le, !1);
          else if (it === "Polygon")
            Pn(Qe, It, le, ge, Le, !0);
          else if (it === "MultiPolygon")
            for (const Kt of Qe) {
              const di = [];
              Pn(Kt, di, le, ge, Le, !0), di.length && It.push(di);
            }
          if (It.length) {
            if (qe.lineMetrics && it === "LineString") {
              for (const Kt of It)
                Ae.push($n(Ye.id, it, Kt, Ye.tags));
              continue;
            }
            it !== "LineString" && it !== "MultiLineString" || (It.length === 1 ? (it = "LineString", It = It[0]) : it = "MultiLineString"), it !== "Point" && it !== "MultiPoint" || (it = It.length === 3 ? "Point" : "MultiPoint"), Ae.push($n(Ye.id, it, It, Ye.tags));
          }
        }
        return Ae.length ? Ae : null;
      }
      function fs(Ke, re, le, ge, Le) {
        for (let Ce = 0; Ce < Ke.length; Ce += 3) {
          const Be = Ke[Ce + Le];
          Be >= le && Be <= ge && js(re, Ke[Ce], Ke[Ce + 1], Ke[Ce + 2]);
        }
      }
      function zn(Ke, re, le, ge, Le, Ce, Be) {
        let qe = Rn(Ke);
        const Ae = Le === 0 ? yo : xo;
        let Ye, Qe, it = Ke.start;
        for (let di = 0; di < Ke.length - 3; di += 3) {
          const li = Ke[di], ri = Ke[di + 1], Ki = Ke[di + 2], Ni = Ke[di + 3], Ei = Ke[di + 4], $i = Le === 0 ? li : ri, Hi = Le === 0 ? Ni : Ei;
          let Xn = !1;
          Be && (Ye = Math.sqrt(Math.pow(li - Ni, 2) + Math.pow(ri - Ei, 2))), $i < le ? Hi > le && (Qe = Ae(qe, li, ri, Ni, Ei, le), Be && (qe.start = it + Ye * Qe)) : $i > ge ? Hi < ge && (Qe = Ae(qe, li, ri, Ni, Ei, ge), Be && (qe.start = it + Ye * Qe)) : js(qe, li, ri, Ki), Hi < le && $i >= le && (Qe = Ae(qe, li, ri, Ni, Ei, le), Xn = !0), Hi > ge && $i <= ge && (Qe = Ae(qe, li, ri, Ni, Ei, ge), Xn = !0), !Ce && Xn && (Be && (qe.end = it + Ye * Qe), re.push(qe), qe = Rn(Ke)), Be && (it += Ye);
        }
        let mt = Ke.length - 3;
        const Ct = Ke[mt], It = Ke[mt + 1], Kt = Le === 0 ? Ct : It;
        Kt >= le && Kt <= ge && js(qe, Ct, It, Ke[mt + 2]), mt = qe.length - 3, Ce && mt >= 3 && (qe[mt] !== qe[0] || qe[mt + 1] !== qe[1]) && js(qe, qe[0], qe[1], qe[2]), qe.length && re.push(qe);
      }
      function Rn(Ke) {
        const re = [];
        return re.size = Ke.size, re.start = Ke.start, re.end = Ke.end, re;
      }
      function Pn(Ke, re, le, ge, Le, Ce) {
        for (const Be of Ke)
          zn(Be, re, le, ge, Le, Ce, !1);
      }
      function js(Ke, re, le, ge) {
        Ke.push(re, le, ge);
      }
      function yo(Ke, re, le, ge, Le, Ce) {
        const Be = (Ce - re) / (ge - re);
        return js(Ke, Ce, le + (Le - le) * Be, 1), Be;
      }
      function xo(Ke, re, le, ge, Le, Ce) {
        const Be = (Ce - le) / (Le - le);
        return js(Ke, re + (ge - re) * Be, Ce, 1), Be;
      }
      function vo(Ke, re) {
        const le = [];
        for (let ge = 0; ge < Ke.length; ge++) {
          const Le = Ke[ge], Ce = Le.type;
          let Be;
          if (Ce === "Point" || Ce === "MultiPoint" || Ce === "LineString")
            Be = yr(Le.geometry, re);
          else if (Ce === "MultiLineString" || Ce === "Polygon") {
            Be = [];
            for (const qe of Le.geometry)
              Be.push(yr(qe, re));
          } else if (Ce === "MultiPolygon") {
            Be = [];
            for (const qe of Le.geometry) {
              const Ae = [];
              for (const Ye of qe)
                Ae.push(yr(Ye, re));
              Be.push(Ae);
            }
          }
          le.push($n(Le.id, Ce, Be, Le.tags));
        }
        return le;
      }
      function yr(Ke, re) {
        const le = [];
        le.size = Ke.size, Ke.start !== void 0 && (le.start = Ke.start, le.end = Ke.end);
        for (let ge = 0; ge < Ke.length; ge += 3)
          le.push(Ke[ge] + re, Ke[ge + 1], Ke[ge + 2]);
        return le;
      }
      function Mr(Ke, re) {
        if (Ke.transformed)
          return Ke;
        const le = 1 << Ke.z, ge = Ke.x, Le = Ke.y;
        for (const Ce of Ke.features) {
          const Be = Ce.geometry, qe = Ce.type;
          if (Ce.geometry = [], qe === 1)
            for (let Ae = 0; Ae < Be.length; Ae += 2)
              Ce.geometry.push(io(Be[Ae], Be[Ae + 1], re, le, ge, Le));
          else
            for (let Ae = 0; Ae < Be.length; Ae++) {
              const Ye = [];
              for (let Qe = 0; Qe < Be[Ae].length; Qe += 2)
                Ye.push(io(Be[Ae][Qe], Be[Ae][Qe + 1], re, le, ge, Le));
              Ce.geometry.push(Ye);
            }
        }
        return Ke.transformed = !0, Ke;
      }
      function io(Ke, re, le, ge, Le, Ce) {
        return [Math.round(le * (Ke * ge - Le)), Math.round(le * (re * ge - Ce))];
      }
      function Ys(Ke, re, le, ge, Le) {
        const Ce = re === Le.maxZoom ? 0 : Le.tolerance / ((1 << re) * Le.extent), Be = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Ke.length, source: null, x: le, y: ge, z: re, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const qe of Ke)
          Sr(Be, qe, Ce, Le);
        return Be;
      }
      function Sr(Ke, re, le, ge) {
        const Le = re.geometry, Ce = re.type, Be = [];
        if (Ke.minX = Math.min(Ke.minX, re.minX), Ke.minY = Math.min(Ke.minY, re.minY), Ke.maxX = Math.max(Ke.maxX, re.maxX), Ke.maxY = Math.max(Ke.maxY, re.maxY), Ce === "Point" || Ce === "MultiPoint")
          for (let qe = 0; qe < Le.length; qe += 3)
            Be.push(Le[qe], Le[qe + 1]), Ke.numPoints++, Ke.numSimplified++;
        else if (Ce === "LineString")
          mi(Be, Le, Ke, le, !1, !1);
        else if (Ce === "MultiLineString" || Ce === "Polygon")
          for (let qe = 0; qe < Le.length; qe++)
            mi(Be, Le[qe], Ke, le, Ce === "Polygon", qe === 0);
        else if (Ce === "MultiPolygon")
          for (let qe = 0; qe < Le.length; qe++) {
            const Ae = Le[qe];
            for (let Ye = 0; Ye < Ae.length; Ye++)
              mi(Be, Ae[Ye], Ke, le, !0, Ye === 0);
          }
        if (Be.length) {
          let qe = re.tags || null;
          if (Ce === "LineString" && ge.lineMetrics) {
            qe = {};
            for (const Ye in re.tags)
              qe[Ye] = re.tags[Ye];
            qe.mapbox_clip_start = Le.start / Le.size, qe.mapbox_clip_end = Le.end / Le.size;
          }
          const Ae = { geometry: Be, type: Ce === "Polygon" || Ce === "MultiPolygon" ? 3 : Ce === "LineString" || Ce === "MultiLineString" ? 2 : 1, tags: qe };
          re.id !== null && (Ae.id = re.id), Ke.features.push(Ae);
        }
      }
      function mi(Ke, re, le, ge, Le, Ce) {
        const Be = ge * ge;
        if (ge > 0 && re.size < (Le ? Be : ge))
          return void (le.numPoints += re.length / 3);
        const qe = [];
        for (let Ae = 0; Ae < re.length; Ae += 3)
          (ge === 0 || re[Ae + 2] > Be) && (le.numSimplified++, qe.push(re[Ae], re[Ae + 1])), le.numPoints++;
        Le && function(Ae, Ye) {
          let Qe = 0;
          for (let it = 0, mt = Ae.length, Ct = mt - 2; it < mt; Ct = it, it += 2)
            Qe += (Ae[it] - Ae[Ct]) * (Ae[it + 1] + Ae[Ct + 1]);
          if (Qe > 0 === Ye)
            for (let it = 0, mt = Ae.length; it < mt / 2; it += 2) {
              const Ct = Ae[it], It = Ae[it + 1];
              Ae[it] = Ae[mt - 2 - it], Ae[it + 1] = Ae[mt - 1 - it], Ae[mt - 2 - it] = Ct, Ae[mt - 1 - it] = It;
            }
        }(qe, Ce), Ke.push(qe);
      }
      const On = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class Vn {
        constructor(re, le) {
          const ge = (le = this.options = function(Ce, Be) {
            for (const qe in Be)
              Ce[qe] = Be[qe];
            return Ce;
          }(Object.create(On), le)).debug;
          if (ge && console.time("preprocess data"), le.maxZoom < 0 || le.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (le.promoteId && le.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let Le = function(Ce, Be) {
            const qe = [];
            if (Ce.type === "FeatureCollection")
              for (let Ae = 0; Ae < Ce.features.length; Ae++)
                vi(qe, Ce.features[Ae], Be, Ae);
            else
              vi(qe, Ce.type === "Feature" ? Ce : { geometry: Ce }, Be);
            return qe;
          }(re, le);
          this.tiles = {}, this.tileCoords = [], ge && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", le.indexMaxZoom, le.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Le = function(Ce, Be) {
            const qe = Be.buffer / Be.extent;
            let Ae = Ce;
            const Ye = si(Ce, 1, -1 - qe, qe, 0, -1, 2, Be), Qe = si(Ce, 1, 1 - qe, 2 + qe, 0, -1, 2, Be);
            return (Ye || Qe) && (Ae = si(Ce, 1, -qe, 1 + qe, 0, -1, 2, Be) || [], Ye && (Ae = vo(Ye, 1).concat(Ae)), Qe && (Ae = Ae.concat(vo(Qe, -1)))), Ae;
          }(Le, le), Le.length && this.splitTile(Le, 0, 0, 0), ge && (Le.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(re, le, ge, Le, Ce, Be, qe) {
          const Ae = [re, le, ge, Le], Ye = this.options, Qe = Ye.debug;
          for (; Ae.length; ) {
            Le = Ae.pop(), ge = Ae.pop(), le = Ae.pop(), re = Ae.pop();
            const it = 1 << le, mt = Zi(le, ge, Le);
            let Ct = this.tiles[mt];
            if (!Ct && (Qe > 1 && console.time("creation"), Ct = this.tiles[mt] = Ys(re, le, ge, Le, Ye), this.tileCoords.push({ z: le, x: ge, y: Le }), Qe)) {
              Qe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", le, ge, Le, Ct.numFeatures, Ct.numPoints, Ct.numSimplified), console.timeEnd("creation"));
              const Xn = `z${le}`;
              this.stats[Xn] = (this.stats[Xn] || 0) + 1, this.total++;
            }
            if (Ct.source = re, Ce == null) {
              if (le === Ye.indexMaxZoom || Ct.numPoints <= Ye.indexMaxPoints)
                continue;
            } else {
              if (le === Ye.maxZoom || le === Ce)
                continue;
              if (Ce != null) {
                const Xn = Ce - le;
                if (ge !== Be >> Xn || Le !== qe >> Xn)
                  continue;
              }
            }
            if (Ct.source = null, re.length === 0)
              continue;
            Qe > 1 && console.time("clipping");
            const It = 0.5 * Ye.buffer / Ye.extent, Kt = 0.5 - It, di = 0.5 + It, li = 1 + It;
            let ri = null, Ki = null, Ni = null, Ei = null, $i = si(re, it, ge - It, ge + di, 0, Ct.minX, Ct.maxX, Ye), Hi = si(re, it, ge + Kt, ge + li, 0, Ct.minX, Ct.maxX, Ye);
            re = null, $i && (ri = si($i, it, Le - It, Le + di, 1, Ct.minY, Ct.maxY, Ye), Ki = si($i, it, Le + Kt, Le + li, 1, Ct.minY, Ct.maxY, Ye), $i = null), Hi && (Ni = si(Hi, it, Le - It, Le + di, 1, Ct.minY, Ct.maxY, Ye), Ei = si(Hi, it, Le + Kt, Le + li, 1, Ct.minY, Ct.maxY, Ye), Hi = null), Qe > 1 && console.timeEnd("clipping"), Ae.push(ri || [], le + 1, 2 * ge, 2 * Le), Ae.push(Ki || [], le + 1, 2 * ge, 2 * Le + 1), Ae.push(Ni || [], le + 1, 2 * ge + 1, 2 * Le), Ae.push(Ei || [], le + 1, 2 * ge + 1, 2 * Le + 1);
          }
        }
        getTile(re, le, ge) {
          re = +re, le = +le, ge = +ge;
          const Le = this.options, { extent: Ce, debug: Be } = Le;
          if (re < 0 || re > 24)
            return null;
          const qe = 1 << re, Ae = Zi(re, le = le + qe & qe - 1, ge);
          if (this.tiles[Ae])
            return Mr(this.tiles[Ae], Ce);
          Be > 1 && console.log("drilling down to z%d-%d-%d", re, le, ge);
          let Ye, Qe = re, it = le, mt = ge;
          for (; !Ye && Qe > 0; )
            Qe--, it >>= 1, mt >>= 1, Ye = this.tiles[Zi(Qe, it, mt)];
          return Ye && Ye.source ? (Be > 1 && (console.log("found parent tile z%d-%d-%d", Qe, it, mt), console.time("drilling down")), this.splitTile(Ye.source, Qe, it, mt, re, le, ge), Be > 1 && console.timeEnd("drilling down"), this.tiles[Ae] ? Mr(this.tiles[Ae], Ce) : null) : null;
        }
      }
      function Zi(Ke, re, le) {
        return 32 * ((1 << Ke) * le + re) + Ke;
      }
      function Jn(Ke, re) {
        const le = Ke.tileID.canonical;
        if (!this._geoJSONIndex)
          return void re(null, null);
        const ge = this._geoJSONIndex.getTile(le.z, le.x, le.y);
        if (!ge)
          return void re(null, null);
        const Le = new gt(ge.features);
        let Ce = Gi(Le);
        Ce.byteOffset === 0 && Ce.byteLength === Ce.buffer.byteLength || (Ce = new Uint8Array(Ce)), re(null, { vectorTile: Le, rawData: Ce.buffer });
      }
      class Fn extends Ze {
        constructor(re, le, ge, Le, Ce, Be) {
          super(re, le, ge, Le, Jn, Be), Ce && (this.loadGeoJSON = Ce), this._dynamicIndex = new Gt();
        }
        loadData(re, le) {
          const ge = re && re.request, Le = ge && ge.collectResourceTiming;
          this.loadGeoJSON(re, (Ce, Be) => {
            if (Ce || !Be)
              return le(Ce);
            if (typeof Be != "object")
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            {
              try {
                if (re.filter) {
                  const Ae = i.U(re.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (Ae.result === "error")
                    throw new Error(Ae.value.map((Ye) => `${Ye.key}: ${Ye.message}`).join(", "));
                  Be.features = Be.features.filter((Ye) => Ae.value.evaluate({ zoom: 0 }, Ye));
                }
                re.dynamic ? (Be.type === "Feature" && (Be = { type: "FeatureCollection", features: [Be] }), re.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Be.features, this.loaded), re.cluster && (Be.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = re.cluster ? new xs(function({ superclusterOptions: Ae, clusterProperties: Ye }) {
                  if (!Ye || !Ae)
                    return Ae;
                  const Qe = {}, it = {}, mt = { accumulated: null, zoom: 0 }, Ct = { properties: null }, It = Object.keys(Ye);
                  for (const Kt of It) {
                    const [di, li] = Ye[Kt], ri = i.U(li), Ki = i.U(typeof di == "string" ? [di, ["accumulated"], ["get", Kt]] : di);
                    Qe[Kt] = ri.value, it[Kt] = Ki.value;
                  }
                  return Ae.map = (Kt) => {
                    Ct.properties = Kt;
                    const di = {};
                    for (const li of It)
                      di[li] = Qe[li].evaluate(mt, Ct);
                    return di;
                  }, Ae.reduce = (Kt, di) => {
                    Ct.properties = di;
                    for (const li of It)
                      mt.accumulated = Kt[li], Kt[li] = it[li].evaluate(mt, Ct);
                  }, Ae;
                }(re)).load(Be.features) : re.dynamic ? this._dynamicIndex : function(Ae, Ye) {
                  return new Vn(Ae, Ye);
                }(Be, re.geojsonVtOptions);
              } catch (Ae) {
                return le(Ae);
              }
              const qe = {};
              if (Le) {
                const Ae = O(ge);
                Ae && (qe.resourceTiming = {}, qe.resourceTiming[re.source] = JSON.parse(JSON.stringify(Ae)));
              }
              le(null, qe);
            }
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded;
          return ge && ge[re.uid] ? re.partial ? le(null, void 0) : super.reloadTile(re, le) : this.loadTile(re, le);
        }
        loadGeoJSON(re, le) {
          if (re.request)
            i.n(re.request, le);
          else {
            if (typeof re.data != "string")
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            try {
              return le(null, JSON.parse(re.data));
            } catch {
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(re, le) {
          try {
            le(null, this._geoJSONIndex.getClusterExpansionZoom(re.clusterId));
          } catch (ge) {
            le(ge);
          }
        }
        getClusterChildren(re, le) {
          try {
            le(null, this._geoJSONIndex.getChildren(re.clusterId));
          } catch (ge) {
            le(ge);
          }
        }
        getClusterLeaves(re, le) {
          try {
            le(null, this._geoJSONIndex.getLeaves(re.clusterId, re.limit, re.offset));
          } catch (ge) {
            le(ge);
          }
        }
      }
      class Ls {
        constructor(re, le) {
          this.tileID = new i.aG(re.tileID.overscaledZ, re.tileID.wrap, re.tileID.canonical.z, re.tileID.canonical.x, re.tileID.canonical.y), this.tileZoom = re.tileZoom, this.uid = re.uid, this.zoom = re.zoom, this.canonical = re.tileID.canonical, this.pixelRatio = re.pixelRatio, this.tileSize = re.tileSize, this.source = re.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = re.projection, this.brightness = le;
        }
        parse(re, le, ge, Le) {
          this.status = "parsing";
          const Ce = new i.aG(ge.tileID.overscaledZ, ge.tileID.wrap, ge.tileID.canonical.z, ge.tileID.canonical.x, ge.tileID.canonical.y), Be = [], qe = le.familiesBySource[ge.source], Ae = new i.dZ(Ce, ge.promoteId);
          return Ae.bucketLayerIDs = [], Ae.is3DTile = !0, i.e9(re).then((Ye) => {
            if (!Ye)
              return Le(new Error("Could not parse tile"));
            const Qe = i.ea(Ye, 1 / i.cc(ge.tileID.canonical)), it = Ye.json.extensionsUsed && Ye.json.extensionsUsed.includes("MAPBOX_mesh_features") || Ye.json.asset.extras && Ye.json.asset.extras.MAPBOX_mesh_features, mt = Ye.json.extensionsUsed && Ye.json.extensionsUsed.includes("EXT_meshopt_compression"), Ct = new i.a8(this.zoom, { brightness: this.brightness });
            for (const It in qe)
              for (const Kt of qe[It]) {
                const di = Kt[0];
                Ae.bucketLayerIDs.push(Kt.map((ri) => i.aC(ri.id, ri.scope))), di.recalculate(Ct, []);
                const li = new i.eb(Kt, Qe, Ce, it, mt, this.brightness, Ae);
                it || (li.needsUpload = !0), Be.push(li), li.evaluate(di);
              }
            this.status = "done", Le(null, { buckets: Be, featureIndex: Ae, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
          }).catch((Ye) => Le(new Error(Ye.message)));
        }
      }
      class zs {
        constructor(re, le, ge, Le, Ce, Be) {
          this.actor = re, this.layerIndex = le, this.availableImages = ge, this.brightness = Be, this.loading = {}, this.loaded = {};
        }
        loadTile(re, le) {
          const ge = re.uid, Le = this.loading[ge] = new Ls(re, this.brightness);
          i.bi(re.request, (Ce, Be) => {
            const qe = !this.loading[ge];
            return delete this.loading[ge], qe || Ce ? (Le.status = "done", qe || (this.loaded[ge] = Le), le(Ce)) : Be && Be.byteLength !== 0 ? void Le.parse(Be, this.layerIndex, re, (Ae, Ye) => {
              Le.status = "done", this.loaded = this.loaded || {}, this.loaded[ge] = Le, Ae || !Ye ? le(Ae) : le(null, Ye);
            }) : (Le.status = "done", this.loaded[ge] = Le, le());
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          if (ge && ge[Le]) {
            const Ce = ge[Le];
            Ce.projection = re.projection, Ce.brightness = re.brightness;
            const Be = (qe, Ae) => {
              Ce.reloadCallback && (delete Ce.reloadCallback, this.loadTile(re, le)), le(qe, Ae);
            };
            Ce.status === "parsing" ? Ce.reloadCallback = Be : Ce.status === "done" && this.loadTile(re, le);
          }
        }
        abortTile(re, le) {
          const ge = re.uid;
          this.loading[ge] && delete this.loading[ge], le();
        }
        removeTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          ge && ge[Le] && delete ge[Le], le();
        }
      }
      class Vo {
        constructor(re) {
          this.self = re, this.actor = new i.ec(re, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new i.I(), this.projections = {}, this.defaultProjection = i.bP({ name: "mercator" }), this.workerSourceTypes = { vector: Ze, geojson: Fn, "batched-model": zs }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (le, ge) => {
            if (this.workerSourceTypes[le])
              throw new Error(`Worker source with name "${le}" already registered.`);
            this.workerSourceTypes[le] = ge;
          }, this.self.registerRTLTextPlugin = (le) => {
            if (i.ed.isParsed())
              throw new Error("RTL text plugin already registered.");
            i.ed.applyArabicShaping = le.applyArabicShaping, i.ed.processBidirectionalText = le.processBidirectionalText, i.ed.processStyledBidirectionalText = le.processStyledBidirectionalText;
          };
        }
        clearCaches(re, le, ge) {
          delete this.layerIndexes[re], delete this.availableImages[re], delete this.workerSources[re], delete this.demWorkerSources[re], delete this.rasterArrayWorkerSource, ge();
        }
        checkIfReady(re, le, ge) {
          ge();
        }
        setReferrer(re, le) {
          this.referrer = le;
        }
        spriteLoaded(re, { scope: le, isLoaded: ge }) {
          if (this.isSpriteLoaded[re] || (this.isSpriteLoaded[re] = {}), this.isSpriteLoaded[re][le] = ge, this.workerSources[re] && this.workerSources[re][le])
            for (const Le in this.workerSources[re][le]) {
              const Ce = this.workerSources[re][le][Le];
              for (const Be in Ce) {
                const qe = Ce[Be];
                qe instanceof Ze && (qe.isSpriteLoaded = ge, qe.fire(new i.z("isSpriteLoaded")));
              }
            }
        }
        setImages(re, { scope: le, images: ge }, Le) {
          if (this.availableImages[re] || (this.availableImages[re] = {}), this.availableImages[re][le] = ge, this.workerSources[re] && this.workerSources[re][le]) {
            for (const Ce in this.workerSources[re][le]) {
              const Be = this.workerSources[re][le][Ce];
              for (const qe in Be)
                Be[qe].availableImages = ge;
            }
            Le();
          } else
            Le();
        }
        setProjection(re, le) {
          this.projections[re] = i.bP(le);
        }
        setBrightness(re, le, ge) {
          this.brightness = le, ge();
        }
        setLayers(re, le, ge) {
          this.getLayerIndex(re, le.scope).replace(le.layers, le.options), ge();
        }
        updateLayers(re, le, ge) {
          this.getLayerIndex(re, le.scope).update(le.layers, le.removedIds, le.options), ge();
        }
        loadTile(re, le, ge) {
          le.projection = this.projections[re] || this.defaultProjection, this.getWorkerSource(re, le.type, le.source, le.scope).loadTile(le, ge);
        }
        loadDEMTile(re, le, ge) {
          this.getDEMWorkerSource(re, le.source, le.scope).loadTile(le, ge);
        }
        decodeRasterArray(re, le, ge) {
          this.getRasterArrayWorkerSource().decodeRasterArray(le, ge);
        }
        reloadTile(re, le, ge) {
          le.projection = this.projections[re] || this.defaultProjection, this.getWorkerSource(re, le.type, le.source, le.scope).reloadTile(le, ge);
        }
        abortTile(re, le, ge) {
          this.getWorkerSource(re, le.type, le.source, le.scope).abortTile(le, ge);
        }
        removeTile(re, le, ge) {
          this.getWorkerSource(re, le.type, le.source, le.scope).removeTile(le, ge);
        }
        removeSource(re, le, ge) {
          if (!(this.workerSources[re] && this.workerSources[re][le.scope] && this.workerSources[re][le.scope][le.type] && this.workerSources[re][le.scope][le.type][le.source]))
            return;
          const Le = this.workerSources[re][le.scope][le.type][le.source];
          delete this.workerSources[re][le.scope][le.type][le.source], Le.removeSource !== void 0 ? Le.removeSource(le, ge) : ge();
        }
        loadWorkerSource(re, le, ge) {
          try {
            this.self.importScripts(le.url), ge();
          } catch (Le) {
            ge(Le.toString());
          }
        }
        syncRTLPluginState(re, le, ge) {
          try {
            i.ed.setState(le);
            const Le = i.ed.getPluginURL();
            if (i.ed.isLoaded() && !i.ed.isParsed() && Le != null) {
              this.self.importScripts(Le);
              const Ce = i.ed.isParsed();
              ge(Ce ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${Le}`), Ce);
            }
          } catch (Le) {
            ge(Le.toString());
          }
        }
        setDracoUrl(re, le) {
          this.dracoUrl = le;
        }
        getAvailableImages(re, le) {
          this.availableImages[re] || (this.availableImages[re] = {});
          let ge = this.availableImages[re][le];
          return ge || (ge = []), ge;
        }
        getLayerIndex(re, le) {
          this.layerIndexes[re] || (this.layerIndexes[re] = {});
          let ge = this.layerIndexes[re][le];
          return ge || (ge = this.layerIndexes[re][le] = new J(), ge.scope = le), ge;
        }
        getWorkerSource(re, le, ge, Le) {
          return this.workerSources[re] || (this.workerSources[re] = {}), this.workerSources[re][Le] || (this.workerSources[re][Le] = {}), this.workerSources[re][Le][le] || (this.workerSources[re][Le][le] = {}), this.isSpriteLoaded[re] || (this.isSpriteLoaded[re] = {}), this.workerSources[re][Le][le][ge] || (this.workerSources[re][Le][le][ge] = new this.workerSourceTypes[le]({ send: (Ce, Be, qe, Ae, Ye, Qe) => {
            this.actor.send(Ce, Be, qe, re, Ye, Qe);
          }, scheduler: this.actor.scheduler }, this.getLayerIndex(re, Le), this.getAvailableImages(re, Le), this.isSpriteLoaded[re][Le], void 0, this.brightness)), this.workerSources[re][Le][le][ge];
        }
        rasterizeImages(re, le, ge) {
          const { imageTasks: Le, scope: Ce } = le, Be = {};
          for (const qe in Le) {
            const { image: Ae, imageIdWithOptions: Ye } = Le[qe];
            Be[qe] = this.imageRasterizer.rasterize(Ye, Ae, Ce, re);
          }
          ge(void 0, Be);
        }
        removeRasterizedImages(re, le, ge) {
          const { imageIds: Le, scope: Ce } = le;
          this.imageRasterizer.removeImagesFromCacheByIds(Le, Ce, re), ge();
        }
        getDEMWorkerSource(re, le, ge) {
          return this.demWorkerSources[re] || (this.demWorkerSources[re] = {}), this.demWorkerSources[re][ge] || (this.demWorkerSources[re][ge] = {}), this.demWorkerSources[re][ge][le] || (this.demWorkerSources[re][ge][le] = new je()), this.demWorkerSources[re][ge][le];
        }
        getRasterArrayWorkerSource() {
          return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new ot()), this.rasterArrayWorkerSource;
        }
        enforceCacheSizeLimit(re, le) {
          i.ee(le);
        }
        getWorkerPerformanceMetrics(re, le, ge) {
          ge(void 0, void 0);
        }
      }
      return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new Vo(self)), Vo;
    }), b(["./shared"], function(i) {
      var O = "3.9.4";
      const j = { create: "create", load: "load", fullLoad: "fullLoad" }, Y = { mark(c) {
        performance.mark(c);
      }, measure(c, t, s) {
        performance.measure(c, t, s);
      } };
      function J(c) {
        const t = c.name.split("?")[0];
        return i.a(t) && t.includes("mapbox-gl.js") ? "javascript" : i.a(t) && t.includes("mapbox-gl.css") ? "css" : i.b(t) ? "fontRange" : i.c(t) ? "sprite" : i.i(t) ? "style" : i.d(t) ? "tilejson" : "other";
      }
      var ae, ce = {}, Te = function() {
        if (ae)
          return ce;
        function c(h) {
          return !t(h);
        }
        function t(h) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var y, T, z = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(z);
            try {
              T = new Worker(R), y = !0;
            } catch {
              y = !1;
            }
            return T && T.terminate(), URL.revokeObjectURL(R), y;
          }() ? function() {
            var y = document.createElement("canvas");
            y.width = y.height = 1;
            var T = y.getContext("2d");
            if (!T)
              return !1;
            var z = T.getImageData(0, 0, 1, 1);
            return z && z.width === y.width;
          }() ? (s[_ = h && h.failIfMajorPerformanceCaveat] === void 0 && (s[_] = function(y) {
            var T, z = function(R) {
              var F = document.createElement("canvas"), N = Object.create(c.webGLContextAttributes);
              return N.failIfMajorPerformanceCaveat = R, F.getContext("webgl2", N);
            }(y);
            if (!z)
              return !1;
            try {
              T = z.createShader(z.VERTEX_SHADER);
            } catch {
              return !1;
            }
            return !(!T || z.isContextLost()) && (z.shaderSource(T, "void main() {}"), z.compileShader(T), z.getShaderParameter(T, z.COMPILE_STATUS) === !0);
          }(_)), s[_] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
          var _;
        }
        ae = 1, ce.supported = c, ce.notSupportedReason = t;
        var s = {};
        return c.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }, ce;
      }();
      function be(c, t, s) {
        const h = document.createElement(c);
        return t != null && (h.className = t), s && s.appendChild(h), h;
      }
      function Ze(c, t, s) {
        const h = document.createElementNS("http://www.w3.org/2000/svg", c);
        for (const _ of Object.keys(t))
          h.setAttributeNS(null, _, String(t[_]));
        return s && s.appendChild(h), h;
      }
      const je = typeof document < "u" ? document.documentElement && document.documentElement.style : null, ot = je && je.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
      let vt;
      function ht() {
        je && ot && (vt = je[ot], je[ot] = "none");
      }
      function gt() {
        je && ot && (je[ot] = vt);
      }
      function Vt(c) {
        c.preventDefault(), c.stopPropagation(), window.removeEventListener("click", Vt, !0);
      }
      function pt() {
        window.addEventListener("click", Vt, !0), window.setTimeout(() => {
          window.removeEventListener("click", Vt, !0);
        }, 0);
      }
      function Gt(c, t) {
        const s = c.getBoundingClientRect();
        return At(c, s, t);
      }
      function ui(c, t) {
        const s = c.getBoundingClientRect(), h = [];
        for (let _ = 0; _ < t.length; _++)
          h.push(At(c, s, t[_]));
        return h;
      }
      function kt(c) {
        return window.InstallTrigger !== void 0 && c.button === 2 && c.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : c.button;
      }
      function At(c, t, s) {
        const h = c.offsetWidth === t.width ? 1 : c.offsetWidth / t.width;
        return new i.P((s.clientX - t.left) * h, (s.clientY - t.top) * h);
      }
      const Mi = "01", An = "NO_ACCESS_TOKEN";
      class hn {
        constructor(t, s, h) {
          this._transformRequestFn = t, this._customAccessToken = s, this._silenceAuthErrors = !!h, this._createSkuToken();
        }
        _createSkuToken() {
          const t = function() {
            let s = "";
            for (let h = 0; h < 10; h++)
              s += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", Mi, s].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t, s) {
          return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t };
        }
        normalizeStyleURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Si(t);
          return h.params.push(`sdk=js-${O}`), h.path = `/styles/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeGlyphsURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Si(t);
          return h.path = `/fonts/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeModelURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Si(t);
          return h.path = `/models/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeSourceURL(t, s, h, _) {
          if (!i.f(t))
            return t;
          const y = Si(t);
          return y.path = `/v4/${y.authority}.json`, y.params.push("secure"), h && y.params.push(`language=${h}`), _ && y.params.push(`worldview=${_}`), this._makeAPIURL(y, this._customAccessToken || s);
        }
        normalizeIconsetURL(t, s) {
          const h = Si(t);
          return i.f(t) ? (h.path = `/styles/v1${h.path}/iconset.pbf`, this._makeAPIURL(h, this._customAccessToken || s)) : Ji(h);
        }
        normalizeSpriteURL(t, s, h, _) {
          const y = Si(t);
          return i.f(t) ? (y.path = `/styles/v1${y.path}/sprite${s}${h}`, this._makeAPIURL(y, this._customAccessToken || _)) : (y.path += `${s}${h}`, Ji(y));
        }
        normalizeTileURL(t, s, h) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t && !i.f(t))
            return t;
          const _ = Si(t);
          _.path = _.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${s || h && _.authority !== "raster" && h === 512 ? "@2x" : ""}${i.m.supported ? ".webp" : "$1"}`), _.authority === "raster" ? _.path = `/${i.e.RASTER_URL_PREFIX}${_.path}` : _.authority === "rasterarrays" ? _.path = `/${i.e.RASTERARRAYS_URL_PREFIX}${_.path}` : _.authority === "3dtiles" ? _.path = `/${i.e.TILES3D_URL_PREFIX}${_.path}` : (_.path = _.path.replace(/^.+\/v4\//, "/"), _.path = `/${i.e.TILE_URL_VERSION}${_.path}`);
          const y = this._customAccessToken || function(T) {
            for (const z of T) {
              const R = z.match(/^access_token=(.*)$/);
              if (R)
                return R[1];
            }
            return null;
          }(_.params) || i.e.ACCESS_TOKEN;
          return i.e.REQUIRE_ACCESS_TOKEN && y && this._skuToken && _.params.push(`sku=${this._skuToken}`), this._makeAPIURL(_, y);
        }
        canonicalizeTileURL(t, s) {
          const h = Si(t);
          if (!h.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !h.path.match(/\.[\w]+$/))
            return t;
          let _ = "mapbox://";
          h.path.match(/^\/raster\/v1\//) ? _ += `raster/${h.path.replace(`/${i.e.RASTER_URL_PREFIX}/`, "")}` : h.path.match(/^\/rasterarrays\/v1\//) ? _ += `rasterarrays/${h.path.replace(`/${i.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : _ += `tiles/${h.path.replace(`/${i.e.TILE_URL_VERSION}/`, "")}`;
          let y = h.params;
          return s && (y = y.filter((T) => !T.match(/^access_token=/))), y.length && (_ += `?${y.join("&")}`), _;
        }
        canonicalizeTileset(t, s) {
          const h = !!s && i.f(s), _ = [];
          for (const y of t.tiles || [])
            i.h(y) ? _.push(this.canonicalizeTileURL(y, h)) : _.push(y);
          return _;
        }
        _makeAPIURL(t, s) {
          const h = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", _ = Si(i.e.API_URL);
          if (t.protocol = _.protocol, t.authority = _.authority, t.protocol === "http") {
            const y = t.params.indexOf("secure");
            y >= 0 && t.params.splice(y, 1);
          }
          if (_.path !== "/" && (t.path = `${_.path}${t.path}`), !i.e.REQUIRE_ACCESS_TOKEN)
            return Ji(t);
          if (s = s || i.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!s)
              throw new Error(`An API access token is required to use Mapbox GL. ${h}`);
            if (s[0] === "s")
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${h}`);
          }
          return t.params = t.params.filter((y) => y.indexOf("access_token") === -1), t.params.push(`access_token=${s || ""}`), Ji(t);
        }
      }
      const Ht = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Si(c) {
        const t = c.match(Ht);
        if (!t)
          throw new Error("Unable to parse URL object");
        return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] };
      }
      function Ji(c) {
        const t = c.params.length ? `?${c.params.join("&")}` : "";
        return `${c.protocol}://${c.authority}${c.path}${t}`;
      }
      const fi = "mapbox.eventData";
      function jt(c) {
        if (!c)
          return null;
        const t = c.split(".");
        if (!t || t.length !== 3)
          return null;
        try {
          return JSON.parse(i.j(t[1]));
        } catch {
          return null;
        }
      }
      class ni {
        constructor(t) {
          this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t) {
          const s = jt(i.e.ACCESS_TOKEN);
          let h = "";
          return h = s && s.u ? i.k(s.u) : i.e.ACCESS_TOKEN || "", t ? `${fi}.${t}:${h}` : `${fi}:${h}`;
        }
        fetchEventData() {
          const t = i.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid");
          if (t)
            try {
              const _ = localStorage.getItem(s);
              _ && (this.eventData = JSON.parse(_));
              const y = localStorage.getItem(h);
              y && (this.anonId = y);
            } catch {
              i.w("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t = i.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid"), _ = this.anonId;
          if (t && _)
            try {
              localStorage.setItem(h, _), Object.keys(this.eventData).length >= 1 && localStorage.setItem(s, JSON.stringify(this.eventData));
            } catch {
              i.w("Unable to write to LocalStorage");
            }
        }
        processRequests(t) {
        }
        postEvent(t, s, h, _) {
          if (!i.e.EVENTS_URL)
            return;
          const y = Si(i.e.EVENTS_URL);
          y.params.push(`access_token=${_ || i.e.ACCESS_TOKEN || ""}`);
          const T = { event: this.type, created: new Date(t).toISOString() }, z = s ? i.l(T, s) : T, R = { url: Ji(y), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([z]) };
          this.pendingRequest = i.p(R, (F) => {
            this.pendingRequest = null, h(F), this.saveEventData(), this.processRequests(_);
          });
        }
        queueRequest(t, s) {
          this.queue.push(t), this.processRequests(s);
        }
      }
      const Gi = new class extends ni {
        constructor(c) {
          super("appUserTurnstile"), this._customAccessToken = c;
        }
        postTurnstileEvent(c, t) {
          i.e.EVENTS_URL && i.e.ACCESS_TOKEN && Array.isArray(c) && c.some((s) => i.f(s) || i.h(s)) && this.queueRequest(Date.now(), t);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const t = jt(i.e.ACCESS_TOKEN), s = t ? t.u : i.e.ACCESS_TOKEN;
          let h = s !== this.eventData.tokenU;
          i.v(this.anonId) || (this.anonId = i.u(), h = !0);
          const _ = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const y = new Date(this.eventData.lastSuccess), T = new Date(_), z = (_ - this.eventData.lastSuccess) / 864e5;
            h = h || z >= 1 || z < -1 || y.getDate() !== T.getDate();
          } else
            h = !0;
          h ? this.postEvent(_, { sdkIdentifier: "mapbox-gl-js", sdkVersion: O, skuId: Mi, "enabled.telemetry": !1, userId: this.anonId }, (y) => {
            y || (this.eventData.lastSuccess = _, this.eventData.tokenU = s);
          }, c) : this.processRequests();
        }
      }(), an = Gi.postTurnstileEvent.bind(Gi), qt = new class extends ni {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(c, t, s, h) {
          this.skuToken = t, this.errorCb = h, i.e.EVENTS_URL && (s || i.e.ACCESS_TOKEN ? this.queueRequest({ id: c, timestamp: Date.now() }, s) : this.errorCb(new Error(An)));
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: t, timestamp: s } = this.queue.shift();
          t && this.success[t] || (this.anonId || this.fetchEventData(), i.v(this.anonId) || (this.anonId = i.u()), this.postEvent(s, { sdkIdentifier: "mapbox-gl-js", sdkVersion: O, skuId: Mi, skuToken: this.skuToken, userId: this.anonId }, (h) => {
            h ? this.errorCb(h) : t && (this.success[t] = !0);
          }, c));
        }
        remove() {
          this.errorCb = null;
        }
      }(), ln = qt.postMapLoadEvent.bind(qt), Di = new class extends ni {
        constructor() {
          super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
        }
        getMapInstanceId(c) {
          let t = this.mapInstanceIdMap.get(c);
          return t || (t = i.u(), this.mapInstanceIdMap.set(c, t)), t;
        }
        getEventId(c) {
          const t = this.eventIdPerMapInstanceMap.get(c) || 0;
          return this.eventIdPerMapInstanceMap.set(c, t + 1), t;
        }
        postStyleLoadEvent(c, t) {
          const { map: s, style: h, importedStyles: _ } = t;
          if (!i.e.EVENTS_URL || !c && !i.e.ACCESS_TOKEN)
            return;
          const y = this.getMapInstanceId(s), T = { mapInstanceId: y, eventId: this.getEventId(y), style: h };
          _.length && (T.importedStyles = _), this.queueRequest({ timestamp: Date.now(), payload: T }, c);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { timestamp: t, payload: s } = this.queue.shift();
          this.postEvent(t, s, () => {
          }, c);
        }
      }(), xi = Di.postStyleLoadEvent.bind(Di), Cs = new class extends ni {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(c, t) {
          i.e.EVENTS_URL && (c || i.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, c);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { timestamp: t, performanceData: s } = this.queue.shift(), h = function(_) {
            const y = performance.getEntriesByType("resource"), T = performance.getEntriesByType("mark"), z = function(W) {
              const te = {};
              if (W) {
                for (const ee in W)
                  if (ee !== "other")
                    for (const se of W[ee]) {
                      const oe = `${ee}ResolveRangeMin`, he = `${ee}ResolveRangeMax`, _e = `${ee}RequestCount`, pe = `${ee}RequestCachedCount`;
                      te[oe] = Math.min(te[oe] || 1 / 0, se.startTime), te[he] = Math.max(te[he] || -1 / 0, se.responseEnd);
                      const Me = (xe) => {
                        te[xe] === void 0 && (te[xe] = 0), ++te[xe];
                      };
                      se.transferSize !== void 0 && se.transferSize === 0 && Me(pe), Me(_e);
                    }
              }
              return te;
            }(function(W, te) {
              const ee = {};
              if (W)
                for (const se of W) {
                  const oe = te(se);
                  ee[oe] === void 0 && (ee[oe] = []), ee[oe].push(se);
                }
              return ee;
            }(y, J)), R = window.devicePixelRatio, F = navigator.connection || navigator.mozConnection || navigator.webkitConnection, N = F ? F.effectiveType : void 0, G = { counters: [], metadata: [], attributes: [] }, Z = (W, te, ee) => {
              ee != null && W.push({ name: te, value: ee.toString() });
            };
            for (const W in z)
              Z(G.counters, W, z[W]);
            if (_.interactionRange[0] !== 1 / 0 && _.interactionRange[1] !== -1 / 0 && (Z(G.counters, "interactionRangeMin", _.interactionRange[0]), Z(G.counters, "interactionRangeMax", _.interactionRange[1])), T)
              for (const W of Object.keys(j)) {
                const te = j[W], ee = T.find((se) => se.name === te);
                ee && Z(G.counters, te, ee.startTime);
              }
            return Z(G.counters, "visibilityHidden", _.visibilityHidden), Z(G.attributes, "style", function(W) {
              if (W)
                for (const te of W) {
                  const ee = te.name.split("?")[0];
                  if (i.i(ee)) {
                    const se = ee.split("/").slice(-2);
                    if (se.length === 2)
                      return `mapbox://styles/${se[0]}/${se[1]}`;
                  }
                }
            }(y)), Z(G.attributes, "terrainEnabled", _.terrainEnabled ? "true" : "false"), Z(G.attributes, "fogEnabled", _.fogEnabled ? "true" : "false"), Z(G.attributes, "projection", _.projection), Z(G.attributes, "zoom", _.zoom), Z(G.metadata, "devicePixelRatio", R), Z(G.metadata, "connectionEffectiveType", N), Z(G.metadata, "navigatorUserAgent", navigator.userAgent), Z(G.metadata, "screenWidth", window.screen.width), Z(G.metadata, "screenHeight", window.screen.height), Z(G.metadata, "windowWidth", window.innerWidth), Z(G.metadata, "windowHeight", window.innerHeight), Z(G.metadata, "mapWidth", _.width / R), Z(G.metadata, "mapHeight", _.height / R), Z(G.metadata, "webglRenderer", _.renderer), Z(G.metadata, "webglVendor", _.vendor), Z(G.metadata, "sdkVersion", O), Z(G.metadata, "sdkIdentifier", "mapbox-gl-js"), G;
          }(s);
          for (const _ of h.metadata)
            ;
          for (const _ of h.counters)
            ;
          for (const _ of h.attributes)
            ;
          this.postEvent(t, h, () => {
          }, c);
        }
      }(), xs = Cs.postPerformanceEvent.bind(Cs), Is = new class extends ni {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(c, t, s, h) {
          if (!i.e.API_URL || !i.e.SESSION_PATH)
            return;
          const _ = Si(i.e.API_URL + i.e.SESSION_PATH);
          _.params.push(`sku=${t || ""}`), _.params.push(`access_token=${h || i.e.ACCESS_TOKEN || ""}`);
          const y = { url: Ji(_), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = i.g(y, (T) => {
            this.pendingRequest = null, s(T), this.saveEventData(), this.processRequests(h);
          });
        }
        getSessionAPI(c, t, s, h) {
          this.skuToken = t, this.errorCb = h, i.e.SESSION_PATH && i.e.API_URL && (s || i.e.ACCESS_TOKEN ? this.queueRequest({ id: c, timestamp: Date.now() }, s) : this.errorCb(new Error(An)));
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: t, timestamp: s } = this.queue.shift();
          t && this.success[t] || this.getSession(s, this.skuToken, (h) => {
            h ? this.errorCb(h) : t && (this.success[t] = !0);
          }, c);
        }
        remove() {
          this.errorCb = null;
        }
      }(), De = Is.getSessionAPI.bind(Is), Vs = /* @__PURE__ */ new Set();
      function Us(c, t) {
        t ? Vs.add(c) : Vs.delete(c);
      }
      class Zr {
        constructor() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = !0;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(t, s) {
          this._updatedSourceCaches[t] = s, this.setDirty();
        }
        discardSourceCacheUpdate(t) {
          delete this._updatedSourceCaches[t];
        }
        updateLayer(t) {
          const s = t.scope;
          this._updatedLayers[s] = this._updatedLayers[s] || /* @__PURE__ */ new Set(), this._updatedLayers[s].add(t.id), this.setDirty();
        }
        removeLayer(t) {
          const s = t.scope;
          this._removedLayers[s] = this._removedLayers[s] || {}, this._updatedLayers[s] = this._updatedLayers[s] || /* @__PURE__ */ new Set(), this._removedLayers[s][t.id] = t, this._updatedLayers[s].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty();
        }
        getRemovedLayer(t) {
          return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null;
        }
        discardLayerRemoval(t) {
          this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id];
        }
        getLayerUpdatesByScope() {
          const t = {};
          for (const s in this._updatedLayers)
            t[s] = t[s] || {}, t[s].updatedIds = Array.from(this._updatedLayers[s].values());
          for (const s in this._removedLayers)
            t[s] = t[s] || {}, t[s].removedIds = Object.keys(this._removedLayers[s]);
          return t;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(t) {
          this._updatedPaintProps.add(t.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(t) {
          this._updatedImages.add(t), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      function Et(c) {
        const { userImage: t } = c;
        return !!(t && t.render && t.render()) && (c.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class Ws extends i.E {
        constructor(t) {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t, t !== "raster" && i.t() && (this.imageRasterizerDispatcher = new i.D(i.x(), this, "Image Rasterizer Worker", 1));
        }
        get imageRasterizer() {
          return this._imageRasterizer || (this._imageRasterizer = new i.I()), this._imageRasterizer;
        }
        createScope(t) {
          this.images[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = {}, this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = {}, this.atlasImage[t] = new i.r({ width: 1, height: 1 });
        }
        isLoaded() {
          for (const t in this.loaded)
            if (!this.loaded[t])
              return !1;
          return !0;
        }
        setLoaded(t, s) {
          if (this.loaded[s] !== t && (this.loaded[s] = t, t)) {
            for (const { ids: h, callback: _ } of this.requestors)
              this._notify(h, s, _);
            this.requestors = [];
          }
        }
        hasImage(t, s) {
          return !!this.getImage(t, s);
        }
        getImage(t, s) {
          return this.images[s][t];
        }
        addImage(t, s, h) {
          this._validate(t, h) && (this.images[s][t] = h);
        }
        _validate(t, s) {
          let h = !0;
          return this._validateStretch(s.stretchX, s.data && s.data.width) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchX" value`))), h = !1), this._validateStretch(s.stretchY, s.data && s.data.height) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchY" value`))), h = !1), this._validateContent(s.content, s) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "content" value`))), h = !1), h;
        }
        _validateStretch(t, s) {
          if (!t)
            return !0;
          let h = 0;
          for (const _ of t) {
            if (_[0] < h || _[1] < _[0] || s < _[1])
              return !1;
            h = _[1];
          }
          return !0;
        }
        _validateContent(t, s) {
          return t ? t.length !== 4 || !s.usvg && (t[0] < 0 || s.data.width < t[0] || t[1] < 0 || s.data.height < t[1] || t[2] < 0 || s.data.width < t[2] || t[3] < 0 || s.data.height < t[3]) ? !1 : !(t[2] < t[0] || t[3] < t[1]) : !0;
        }
        updateImage(t, s, h) {
          h.version = this.images[s][t].version + 1, this.images[s][t] = h, this.updatedImages[s][t] = !0, this.removeFromImageRasterizerCache(t, s);
        }
        removeFromImageRasterizerCache(t, s) {
          this.spriteFormat !== "raster" && (i.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t], scope: s }) : this.imageRasterizer.removeImagesFromCacheByIds([t], s));
        }
        removeImage(t, s) {
          const h = this.images[s][t];
          delete this.images[s][t], delete this.patterns[s][t], this.removeFromImageRasterizerCache(t, s), h.userImage && h.userImage.onRemove && h.userImage.onRemove();
        }
        listImages(t) {
          return Object.keys(this.images[t]);
        }
        getImages(t, s, h) {
          let _ = !0;
          const y = !!this.loaded[s];
          if (!y)
            for (const T of t)
              this.images[s][T] || (_ = !1);
          y || _ ? this._notify(t, s, h) : this.requestors.push({ ids: t, scope: s, callback: h });
        }
        rasterizeImages({ scope: t, imageTasks: s }, h) {
          const _ = {};
          for (const y in s) {
            const T = s[y], z = this.getImage(T.id, t);
            z && (_[y] = { image: z, imageIdWithOptions: T });
          }
          i.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", { imageTasks: _, scope: t }, h) : this.rasterizeImagesInMainThread({ imageTasks: _, scope: t }, h);
        }
        rasterizeImagesInMainThread(t, s) {
          const { imageTasks: h, scope: _ } = t, y = {};
          for (const T in h) {
            const { image: z, imageIdWithOptions: R } = h[T];
            y[T] = this.imageRasterizer.rasterize(R, z, _, "");
          }
          s(void 0, y);
        }
        getUpdatedImages(t) {
          return this.updatedImages[t];
        }
        _notify(t, s, h) {
          const _ = {};
          for (const y of t) {
            this.images[s][y] || this.fire(new i.z("styleimagemissing", { id: y }));
            const T = this.images[s][y];
            T ? _[y] = { data: T.usvg ? null : T.data.clone(), pixelRatio: T.pixelRatio, sdf: T.sdf, usvg: T.usvg, version: T.version, stretchX: T.stretchX, stretchY: T.stretchY, content: T.content, hasRenderCallback: !!(T.userImage && T.userImage.render) } : i.w(`Image "${y}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          h(null, _);
        }
        getPixelSize(t) {
          const { width: s, height: h } = this.atlasImage[t];
          return { width: s, height: h };
        }
        getPattern(t, s, h) {
          const _ = this.patterns[s][t], y = this.getImage(t, s);
          if (!y)
            return null;
          if (_ && _.position.version === y.version)
            return _.position;
          if (_)
            _.position.version = y.version;
          else {
            y.usvg && !y.data && (y.data = this.imageRasterizer.rasterize(i.A.from(t).getPrimary(), y, s, ""));
            const T = { w: y.data.width + 2 * i.B, h: y.data.height + 2 * i.B, x: 0, y: 0 }, z = new i.F(T, y, i.B);
            this.patterns[s][t] = { bin: T, position: z };
          }
          return this._updatePatternAtlas(s, h), this.patterns[s][t].position;
        }
        bind(t, s) {
          const h = t.gl;
          let _ = this.atlasTexture[s];
          _ ? this.dirty && (_.update(this.atlasImage[s]), this.dirty = !1) : (_ = new i.T(t, this.atlasImage[s], h.RGBA8), this.atlasTexture[s] = _), _.bind(h.LINEAR, h.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t, s) {
          const h = [];
          for (const z in this.patterns[t])
            h.push(this.patterns[t][z].bin);
          const { w: _, h: y } = i.C(h), T = this.atlasImage[t];
          T.resize({ width: _ || 1, height: y || 1 });
          for (const z in this.patterns[t]) {
            const { bin: R, position: F } = this.patterns[t][z];
            let N = F.padding;
            const G = R.x + N, Z = R.y + N, W = this.images[t][z].data, te = W.width, ee = W.height;
            N = N > 1 ? N - 1 : N, i.r.copy(W, T, { x: 0, y: 0 }, { x: G, y: Z }, { width: te, height: ee }, s), i.r.copy(W, T, { x: 0, y: ee - N }, { x: G, y: Z - N }, { width: te, height: N }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: G, y: Z + ee }, { width: te, height: N }, s), i.r.copy(W, T, { x: te - N, y: 0 }, { x: G - N, y: Z }, { width: N, height: ee }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: G + te, y: Z }, { width: N, height: ee }, s), i.r.copy(W, T, { x: te - N, y: ee - N }, { x: G - N, y: Z - N }, { width: N, height: N }, s), i.r.copy(W, T, { x: 0, y: ee - N }, { x: G + te, y: Z - N }, { width: N, height: N }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: G + te, y: Z + ee }, { width: N, height: N }, s), i.r.copy(W, T, { x: te - N, y: 0 }, { x: G - N, y: Z + ee }, { width: N, height: N }, s);
          }
          this.dirty = !0;
        }
        beginFrame() {
          for (const t in this.images)
            this.callbackDispatchedThisFrame[t] = {};
        }
        dispatchRenderCallbacks(t, s) {
          for (const h of t) {
            if (this.callbackDispatchedThisFrame[s][h])
              continue;
            this.callbackDispatchedThisFrame[s][h] = !0;
            const _ = this.images[s][h];
            Et(_) && this.updateImage(h, s, _);
          }
        }
      }
      function $n(c) {
        const t = c.key, s = c.value, h = c.valueSpec || {}, _ = c.objectElementValidators || {}, y = c.style, T = c.styleSpec;
        let z = [];
        const R = i.H(s);
        if (R !== "object")
          return [new i.V(t, s, `object expected, ${R} found`)];
        for (const F in s) {
          const N = F.split(".")[0];
          let G;
          _[N] ? G = _[N] : h[N] ? G = mi : _["*"] ? G = _["*"] : h["*"] && (G = mi), G ? z = z.concat(G({ key: (t && `${t}.`) + F, value: s[F], valueSpec: h[N] || h["*"], style: y, styleSpec: T, object: s, objectKey: F }, s)) : z.push(new i.G(t, s[F], `unknown property "${F}"`));
        }
        for (const F in h)
          _[F] || h[F].required && h[F].default === void 0 && s[F] === void 0 && z.push(new i.V(t, s, `missing required property "${F}"`));
        return z;
      }
      function $s(c) {
        const t = c.value, s = c.valueSpec, h = c.style, _ = c.styleSpec, y = c.key, T = c.arrayElementValidator || mi;
        if (i.H(t) !== "array")
          return [new i.V(y, t, `array expected, ${i.H(t)} found`)];
        if (s.length && t.length !== s.length)
          return [new i.V(y, t, `array length ${s.length} expected, length ${t.length} found`)];
        if (s["min-length"] && t.length < s["min-length"])
          return [new i.V(y, t, `array length at least ${s["min-length"]} expected, length ${t.length} found`)];
        let z = { type: s.value, values: s.values, minimum: s.minimum, maximum: s.maximum, function: void 0 };
        _.$version < 7 && (z.function = s.function), i.H(s.value) === "object" && (z = s.value);
        let R = [];
        for (let F = 0; F < t.length; F++)
          R = R.concat(T({ array: t, arrayIndex: F, value: t[F], valueSpec: z, style: h, styleSpec: _, key: `${y}[${F}]` }, !0));
        return R;
      }
      function vi(c) {
        const t = c.key, s = c.value, h = c.valueSpec;
        let _ = i.H(s);
        if (_ === "number" && s != s && (_ = "NaN"), _ !== "number")
          return [new i.V(t, s, `number expected, ${_} found`)];
        if ("minimum" in h) {
          let y = h.minimum;
          if (i.H(h.minimum) === "array" && (y = h.minimum[c.arrayIndex]), s < y)
            return [new i.V(t, s, `${s} is less than the minimum value ${y}`)];
        }
        if ("maximum" in h) {
          let y = h.maximum;
          if (i.H(h.maximum) === "array" && (y = h.maximum[c.arrayIndex]), s > y)
            return [new i.V(t, s, `${s} is greater than the maximum value ${y}`)];
        }
        return [];
      }
      function kn(c) {
        const t = c.valueSpec, s = i.K(c.value.type);
        let h, _, y, T = {};
        const z = s !== "categorical" && c.value.property === void 0, R = !z, F = i.H(c.value.stops) === "array" && i.H(c.value.stops[0]) === "array" && i.H(c.value.stops[0][0]) === "object", N = $n({ key: c.key, value: c.value, valueSpec: c.styleSpec.function, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { stops: function(W) {
          if (s === "identity")
            return [new i.V(W.key, W.value, 'identity function may not have a "stops" property')];
          let te = [];
          const ee = W.value;
          return te = te.concat($s({ key: W.key, value: ee, valueSpec: W.valueSpec, style: W.style, styleSpec: W.styleSpec, arrayElementValidator: G })), i.H(ee) === "array" && ee.length === 0 && te.push(new i.V(W.key, ee, "array must have at least one stop")), te;
        }, default: function(W) {
          return mi({ key: W.key, value: W.value, valueSpec: t, style: W.style, styleSpec: W.styleSpec });
        } } });
        return s === "identity" && z && N.push(new i.V(c.key, c.value, 'missing required property "property"')), s === "identity" || c.value.stops || N.push(new i.V(c.key, c.value, 'missing required property "stops"')), s === "exponential" && c.valueSpec.expression && !i.L(c.valueSpec) && N.push(new i.V(c.key, c.value, "exponential functions not supported")), c.styleSpec.$version >= 8 && (R && !i.M(c.valueSpec) ? N.push(new i.V(c.key, c.value, "property functions not supported")) : z && !i.N(c.valueSpec) && N.push(new i.V(c.key, c.value, "zoom functions not supported"))), s !== "categorical" && !F || c.value.property !== void 0 || N.push(new i.V(c.key, c.value, '"property" property is required')), N;
        function G(W) {
          let te = [];
          const ee = W.value, se = W.key;
          if (i.H(ee) !== "array")
            return [new i.V(se, ee, `array expected, ${i.H(ee)} found`)];
          if (ee.length !== 2)
            return [new i.V(se, ee, `array length 2 expected, length ${ee.length} found`)];
          if (F) {
            if (i.H(ee[0]) !== "object")
              return [new i.V(se, ee, `object expected, ${i.H(ee[0])} found`)];
            if (ee[0].zoom === void 0)
              return [new i.V(se, ee, "object stop key must have zoom")];
            if (ee[0].value === void 0)
              return [new i.V(se, ee, "object stop key must have value")];
            const oe = i.K(ee[0].zoom);
            if (typeof oe != "number")
              return [new i.V(se, ee[0].zoom, "stop zoom values must be numbers")];
            if (y && y > oe)
              return [new i.V(se, ee[0].zoom, "stop zoom values must appear in ascending order")];
            oe !== y && (y = oe, _ = void 0, T = {}), te = te.concat($n({ key: `${se}[0]`, value: ee[0], valueSpec: { zoom: {} }, style: W.style, styleSpec: W.styleSpec, objectElementValidators: { zoom: vi, value: Z } }));
          } else
            te = te.concat(Z({ key: `${se}[0]`, value: ee[0], valueSpec: {}, style: W.style, styleSpec: W.styleSpec }, ee));
          return i.O(i.Q(ee[1])) ? te.concat([new i.V(`${se}[1]`, ee[1], "expressions are not allowed in function stops.")]) : te.concat(mi({ key: `${se}[1]`, value: ee[1], valueSpec: t, style: W.style, styleSpec: W.styleSpec }));
        }
        function Z(W, te) {
          const ee = i.H(W.value), se = i.K(W.value), oe = W.value !== null ? W.value : te;
          if (h) {
            if (ee !== h)
              return [new i.V(W.key, oe, `${ee} stop domain type must match previous stop domain type ${h}`)];
          } else
            h = ee;
          if (ee !== "number" && ee !== "string" && ee !== "boolean" && typeof se != "number" && typeof se != "string" && typeof se != "boolean")
            return [new i.V(W.key, oe, "stop domain value must be a number, string, or boolean")];
          if (ee !== "number" && s !== "categorical") {
            let he = `number expected, ${ee} found`;
            return i.M(t) && s === void 0 && (he += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new i.V(W.key, oe, he)];
          }
          return s !== "categorical" || ee !== "number" || typeof se == "number" && isFinite(se) && Math.floor(se) === se ? s !== "categorical" && ee === "number" && typeof se == "number" && typeof _ == "number" && _ !== void 0 && se < _ ? [new i.V(W.key, oe, "stop domain values must appear in ascending order")] : (_ = se, s === "categorical" && se in T ? [new i.V(W.key, oe, "stop domain values must be unique")] : (T[se] = !0, [])) : [new i.V(W.key, oe, `integer expected, found ${String(se)}`)];
        }
      }
      function Xs(c) {
        const t = (c.expressionContext === "property" ? i.S : i.U)(i.Q(c.value), c.valueSpec);
        if (t.result === "error")
          return t.value.map((h) => new i.V(`${c.key}${h.key}`, c.value, h.message));
        const s = t.value.expression || t.value._styleExpression.expression;
        if (c.expressionContext === "property" && c.propertyKey === "text-font" && !s.outputDefined())
          return [new i.V(c.key, c.value, `Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (c.expressionContext === "property" && c.propertyType === "layout" && !i.W(s))
          return [new i.V(c.key, c.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (c.expressionContext === "filter")
          return Hr(s, c);
        if (c.expressionContext && c.expressionContext.indexOf("cluster") === 0) {
          if (!i.X(s, ["zoom", "feature-state"]))
            return [new i.V(c.key, c.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (c.expressionContext === "cluster-initial" && !i.Y(s))
            return [new i.V(c.key, c.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Hr(c, t) {
        const s = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (t.valueSpec && t.valueSpec.expression)
          for (const _ of t.valueSpec.expression.parameters)
            s.delete(_);
        if (s.size === 0)
          return [];
        const h = [];
        return c instanceof i.Z && s.has(c.name) ? [new i.V(t.key, t.value, `["${c.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (c.eachChild((_) => {
          h.push(...Hr(_, t));
        }), h);
      }
      function qr(c) {
        const t = c.key, s = c.value, h = c.valueSpec, _ = [];
        return Array.isArray(h.values) ? h.values.indexOf(i.K(s)) === -1 && _.push(new i.V(t, s, `expected one of [${h.values.join(", ")}], ${JSON.stringify(s)} found`)) : Object.keys(h.values).indexOf(i.K(s)) === -1 && _.push(new i.V(t, s, `expected one of [${Object.keys(h.values).join(", ")}], ${JSON.stringify(s)} found`)), _;
      }
      function Wr(c) {
        return i.$(i.Q(c.value)) ? Xs(i.J({}, c, { expressionContext: "filter", valueSpec: c.styleSpec[`filter_${c.layerType || "fill"}`] })) : si(c);
      }
      function si(c) {
        const t = c.value, s = c.key;
        if (i.H(t) !== "array")
          return [new i.V(s, t, `array expected, ${i.H(t)} found`)];
        const h = c.styleSpec;
        let _, y = [];
        if (t.length < 1)
          return [new i.V(s, t, "filter array must have at least 1 element")];
        switch (y = y.concat(qr({ key: `${s}[0]`, value: t[0], valueSpec: h.filter_operator, style: c.style, styleSpec: c.styleSpec })), i.K(t[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 && i.K(t[1]) === "$type" && y.push(new i.V(s, t, `"$type" cannot be use with operator "${t[0]}"`));
          case "==":
          case "!=":
            t.length !== 3 && y.push(new i.V(s, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t.length >= 2 && (_ = i.H(t[1]), _ !== "string" && y.push(new i.V(`${s}[1]`, t[1], `string expected, ${_} found`)));
            for (let T = 2; T < t.length; T++)
              _ = i.H(t[T]), i.K(t[1]) === "$type" ? y = y.concat(qr({ key: `${s}[${T}]`, value: t[T], valueSpec: h.geometry_type, style: c.style, styleSpec: c.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && y.push(new i.V(`${s}[${T}]`, t[T], `string, number, or boolean expected, ${_} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let T = 1; T < t.length; T++)
              y = y.concat(si({ key: `${s}[${T}]`, value: t[T], style: c.style, styleSpec: c.styleSpec }));
            break;
          case "has":
          case "!has":
            _ = i.H(t[1]), t.length !== 2 ? y.push(new i.V(s, t, `filter array for "${t[0]}" operator must have 2 elements`)) : _ !== "string" && y.push(new i.V(`${s}[1]`, t[1], `string expected, ${_} found`));
        }
        return y;
      }
      function fs(c, t) {
        const s = c.key, h = c.style, _ = c.layer, y = c.styleSpec, T = c.value, z = c.objectKey, R = y[`${t}_${c.layerType}`];
        if (!R)
          return [];
        const F = z.match(/^(.*)-use-theme$/);
        if (t === "paint" && F && R[F[1]])
          return mi({ key: s, value: T, valueSpec: { type: "string" }, style: h, styleSpec: y });
        const N = z.match(/^(.*)-transition$/);
        if (t === "paint" && N && R[N[1]] && R[N[1]].transition)
          return mi({ key: s, value: T, valueSpec: y.transition, style: h, styleSpec: y });
        const G = c.valueSpec || R[z];
        if (!G)
          return [new i.G(s, T, `unknown property "${z}"`)];
        let Z;
        if (i.H(T) === "string" && i.M(G) && !G.tokens && (Z = /^{([^}]+)}$/.exec(T))) {
          const te = `\`{ "type": "identity", "property": ${Z ? JSON.stringify(Z[1]) : '"_"'} }\``;
          return [new i.V(s, T, `"${z}" does not support interpolation syntax
Use an identity property function instead: ${te}.`)];
        }
        const W = [];
        if (c.layerType === "symbol")
          z !== "text-field" || !h || h.glyphs || h.imports || W.push(new i.V(s, T, 'use of "text-field" requires a style "glyphs" property')), z === "text-font" && i.a0(i.Q(T)) && i.K(T.type) === "identity" && W.push(new i.V(s, T, '"text-font" does not support identity functions'));
        else if (c.layerType === "model" && t === "paint" && _ && _.layout && _.layout.hasOwnProperty("model-id") && i.M(G) && (i.a1(G) || i.N(G))) {
          const te = i.S(i.Q(T), G), ee = te.value.expression || te.value._styleExpression.expression;
          ee && !i.X(ee, ["measure-light"]) && (z === "model-emissive-strength" && i.Y(ee) && i.W(ee) || W.push(new i.V(s, T, `${z} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return W.concat(mi({ key: c.key, value: T, valueSpec: G, style: h, styleSpec: y, expressionContext: "property", propertyType: t, propertyKey: z }));
      }
      function zn(c) {
        return fs(c, "paint");
      }
      function Rn(c) {
        return fs(c, "layout");
      }
      function Pn(c) {
        let t = [];
        const s = c.value, h = c.key, _ = c.style, y = c.styleSpec;
        s.type || s.ref || t.push(new i.V(h, s, 'either "type" or "ref" is required'));
        let T = i.K(s.type);
        const z = i.K(s.ref);
        if (s.id) {
          const R = i.K(s.id);
          for (let F = 0; F < c.arrayIndex; F++) {
            const N = _.layers[F];
            i.K(N.id) === R && t.push(new i.V(h, s.id, `duplicate layer id "${s.id}", previously used at line ${N.id.__line__}`));
          }
        }
        if ("ref" in s) {
          let R;
          ["type", "source", "source-layer", "filter", "layout"].forEach((F) => {
            F in s && t.push(new i.V(h, s[F], `"${F}" is prohibited for ref layers`));
          }), _.layers.forEach((F) => {
            i.K(F.id) === z && (R = F);
          }), R ? R.ref ? t.push(new i.V(h, s.ref, "ref cannot reference another ref layer")) : T = i.K(R.type) : typeof z == "string" && t.push(new i.V(h, s.ref, `ref layer "${z}" not found`));
        } else if (T !== "background" && T !== "sky" && T !== "slot")
          if (s.source) {
            const R = _.sources && _.sources[s.source], F = R && i.K(R.type);
            R ? F === "vector" && T === "raster" ? t.push(new i.V(h, s.source, `layer "${s.id}" requires a raster source`)) : F === "raster" && T !== "raster" ? t.push(new i.V(h, s.source, `layer "${s.id}" requires a vector source`)) : F !== "vector" || s["source-layer"] ? F === "raster-dem" && T !== "hillshade" ? t.push(new i.V(h, s.source, "raster-dem source can only be used with layer type 'hillshade'.")) : F !== "raster-array" || ["raster", "raster-particle"].includes(T) ? T !== "line" || !s.paint || !s.paint["line-gradient"] && !s.paint["line-trim-offset"] || F === "geojson" && R.lineMetrics ? T === "raster-particle" && F !== "raster-array" && t.push(new i.V(h, s.source, `layer "${s.id}" requires a 'raster-array' source.`)) : t.push(new i.V(h, s, `layer "${s.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new i.V(h, s.source, "raster-array source can only be used with layer type 'raster'.")) : t.push(new i.V(h, s, `layer "${s.id}" must specify a "source-layer"`)) : t.push(new i.V(h, s.source, `source "${s.source}" not found`));
          } else
            t.push(new i.V(h, s, 'missing required property "source"'));
        return t = t.concat($n({ key: h, value: s, valueSpec: y.layer, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { "*": () => [], type: () => mi({ key: `${h}.type`, value: s.type, valueSpec: y.layer.type, style: c.style, styleSpec: c.styleSpec, object: s, objectKey: "type" }), filter: (R) => Wr(i.J({ layerType: T }, R)), layout: (R) => $n({ layer: s, key: R.key, value: R.value, valueSpec: {}, style: R.style, styleSpec: R.styleSpec, objectElementValidators: { "*": (F) => Rn(i.J({ layerType: T }, F)) } }), paint: (R) => $n({ layer: s, key: R.key, value: R.value, valueSpec: {}, style: R.style, styleSpec: R.styleSpec, objectElementValidators: { "*": (F) => zn(i.J({ layerType: T, layer: s }, F)) } }) } })), t;
      }
      function js(c) {
        const t = c.value, s = c.key, h = i.H(t);
        return h !== "string" ? [new i.V(s, t, `string expected, ${h} found`)] : [];
      }
      const yo = { promoteId: function({ key: c, value: t }) {
        if (i.H(t) === "string")
          return js({ key: c, value: t });
        {
          const s = [];
          for (const h in t)
            s.push(...js({ key: `${c}.${h}`, value: t[h] }));
          return s;
        }
      } };
      function xo(c) {
        const t = c.value, s = c.key, h = c.styleSpec, _ = c.style;
        if (!t.type)
          return [new i.V(s, t, '"type" is required')];
        const y = i.K(t.type);
        let T = [];
        switch (["vector", "raster", "raster-dem", "raster-array"].includes(y) && (t.url || t.tiles || T.push(new i.G(s, t, 'Either "url" or "tiles" is required.'))), y) {
          case "vector":
          case "raster":
          case "raster-dem":
          case "raster-array":
            return T = T.concat($n({ key: s, value: t, valueSpec: h[`source_${y.replace("-", "_")}`], style: c.style, styleSpec: h, objectElementValidators: yo })), T;
          case "geojson":
            if (T = $n({ key: s, value: t, valueSpec: h.source_geojson, style: _, styleSpec: h, objectElementValidators: yo }), t.cluster)
              for (const z in t.clusterProperties) {
                const [R, F] = t.clusterProperties[z], N = typeof R == "string" ? [R, ["accumulated"], ["get", z]] : R;
                T.push(...Xs({ key: `${s}.${z}.map`, value: F, expressionContext: "cluster-map" })), T.push(...Xs({ key: `${s}.${z}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
            return T;
          case "video":
            return $n({ key: s, value: t, valueSpec: h.source_video, style: _, styleSpec: h });
          case "image":
            return $n({ key: s, value: t, valueSpec: h.source_image, style: _, styleSpec: h });
          case "canvas":
            return [new i.V(s, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return qr({ key: `${s}.type`, value: t.type, valueSpec: { values: vo(h) }, style: _, styleSpec: h });
        }
      }
      function vo(c) {
        return c.source.reduce((t, s) => {
          const h = c[s];
          return h.type.type === "enum" && (t = t.concat(Object.keys(h.type.values))), t;
        }, []);
      }
      function yr(c) {
        const t = c.value, s = c.styleSpec, h = s.light, _ = c.style;
        let y = [];
        const T = i.H(t);
        if (t === void 0)
          return y;
        if (T !== "object")
          return y = y.concat([new i.V("light", t, `object expected, ${T} found`)]), y;
        for (const z in t) {
          const R = z.match(/^(.*)-transition$/), F = z.match(/^(.*)-use-theme$/);
          y = y.concat(F && h[F[1]] ? mi({ key: z, value: t[z], valueSpec: { type: "string" }, style: _, styleSpec: s }) : R && h[R[1]] && h[R[1]].transition ? mi({ key: z, value: t[z], valueSpec: s.transition, style: _, styleSpec: s }) : h[z] ? mi({ key: z, value: t[z], valueSpec: h[z], style: _, styleSpec: s }) : [new i.V(z, t[z], `unknown property "${z}"`)]);
        }
        return y;
      }
      function Mr(c) {
        const t = c.value;
        let s = [];
        if (!t)
          return s;
        const h = i.H(t);
        if (h !== "object")
          return s = s.concat([new i.V("light-3d", t, `object expected, ${h} found`)]), s;
        const _ = c.styleSpec, y = _["light-3d"], T = c.key, z = c.style, R = c.style.lights;
        for (const G of ["type", "id"])
          if (!(G in t))
            return s = s.concat([new i.V("light-3d", t, `missing property ${G} on light`)]), s;
        if (t.type && R)
          for (let G = 0; G < c.arrayIndex; G++) {
            const Z = i.K(t.type), W = R[G];
            i.K(W.type) === Z && s.push(new i.V(T, t.id, `duplicate light type "${t.type}", previously defined at line ${W.id.__line__}`));
          }
        const F = `properties_light_${t.type}`;
        if (!(F in _))
          return s = s.concat([new i.V("light-3d", t, `Invalid light type ${t.type}`)]), s;
        const N = _[F];
        for (const G in t)
          if (G === "properties") {
            const Z = t[G], W = i.H(Z);
            if (W !== "object")
              return s = s.concat([new i.V("properties", Z, `object expected, ${W} found`)]), s;
            for (const te in Z)
              s = s.concat(N[te] ? mi({ key: te, value: Z[te], valueSpec: N[te], style: z, styleSpec: _ }) : [new i.G(c.key, Z[te], `unknown property "${te}"`)]);
          } else {
            const Z = G.match(/^(.*)-transition$/), W = G.match(/^(.*)-use-theme$/);
            s = s.concat(W && y[W[1]] ? mi({ key: G, value: t[G], valueSpec: { type: "string" }, style: z, styleSpec: _ }) : Z && y[Z[1]] && y[Z[1]].transition ? mi({ key: G, value: t[G], valueSpec: _.transition, style: z, styleSpec: _ }) : y[G] ? mi({ key: G, value: t[G], valueSpec: y[G], style: z, styleSpec: _ }) : [new i.G(G, t[G], `unknown property "${G}"`)]);
          }
        return s;
      }
      function io(c) {
        const t = c.value, s = c.key, h = c.style, _ = c.styleSpec, y = _.terrain;
        let T = [];
        const z = i.H(t);
        if (t === void 0 || z === "null")
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("terrain", t, `object expected, ${z} found`)]), T;
        for (const R in t) {
          const F = R.match(/^(.*)-transition$/), N = R.match(/^(.*)-use-theme$/);
          T = T.concat(N && y[N[1]] ? mi({ key: R, value: t[R], valueSpec: { type: "string" }, style: h, styleSpec: _ }) : F && y[F[1]] && y[F[1]].transition ? mi({ key: R, value: t[R], valueSpec: _.transition, style: h, styleSpec: _ }) : y[R] ? mi({ key: R, value: t[R], valueSpec: y[R], style: h, styleSpec: _ }) : [new i.G(R, t[R], `unknown property "${R}"`)]);
        }
        if (t.source) {
          const R = h.sources && h.sources[t.source], F = R && i.K(R.type);
          R ? F !== "raster-dem" && T.push(new i.V(s, t.source, `terrain cannot be used with a source of type ${String(F)}, it only be used with a "raster-dem" source type`)) : T.push(new i.V(s, t.source, `source "${t.source}" not found`));
        } else
          T.push(new i.V(s, t, 'terrain is missing required property "source"'));
        return T;
      }
      function Ys(c) {
        const t = c.value, s = c.style, h = c.styleSpec, _ = h.fog;
        let y = [];
        const T = i.H(t);
        if (t === void 0)
          return y;
        if (T !== "object")
          return y = y.concat([new i.V("fog", t, `object expected, ${T} found`)]), y;
        for (const z in t) {
          const R = z.match(/^(.*)-transition$/), F = z.match(/^(.*)-use-theme$/);
          y = y.concat(F && _[F[1]] ? mi({ key: z, value: t[z], valueSpec: { type: "string" }, style: s, styleSpec: h }) : R && _[R[1]] && _[R[1]].transition ? mi({ key: z, value: t[z], valueSpec: h.transition, style: s, styleSpec: h }) : _[z] ? mi({ key: z, value: t[z], valueSpec: _[z], style: s, styleSpec: h }) : [new i.G(z, t[z], `unknown property "${z}"`)]);
        }
        return y;
      }
      const Sr = { "*": () => [], array: $s, boolean: function(c) {
        const t = c.value, s = c.key, h = i.H(t);
        return h !== "boolean" ? [new i.V(s, t, `boolean expected, ${h} found`)] : [];
      }, number: vi, color: function(c) {
        const t = c.key, s = c.value, h = i.H(s);
        return h !== "string" ? [new i.V(t, s, `color expected, ${h} found`)] : i._.parseCSSColor(s) === null ? [new i.V(t, s, `color expected, "${s}" found`)] : [];
      }, enum: qr, filter: Wr, function: kn, layer: Pn, object: $n, source: xo, model: i.a2, light: yr, "light-3d": Mr, terrain: io, fog: Ys, string: js, formatted: function(c) {
        return js(c).length === 0 ? [] : Xs(c);
      }, resolvedImage: function(c) {
        return js(c).length === 0 ? [] : Xs(c);
      }, projection: function(c) {
        const t = c.value, s = c.styleSpec, h = s.projection, _ = c.style;
        let y = [];
        const T = i.H(t);
        if (T === "object")
          for (const z in t)
            y = y.concat(mi({ key: z, value: t[z], valueSpec: h[z], style: _, styleSpec: s }));
        else
          T !== "string" && (y = y.concat([new i.V("projection", t, `object or string expected, ${T} found`)]));
        return y;
      }, import: function(c) {
        const { value: t, styleSpec: s } = c, { data: h, ..._ } = t;
        Object.defineProperty(_, "__line__", { value: t.__line__, enumerable: !1 });
        let y = $n(i.J({}, c, { value: _, valueSpec: s.import }));
        return i.K(_.id) === "" && y.push(new i.V(`${c.key}.id`, _, "import id can't be an empty string")), h && (y = y.concat(Vn(h, s, { key: `${c.key}.data` }))), y;
      } };
      function mi(c, t = !1) {
        const s = c.value, h = c.valueSpec, _ = c.styleSpec;
        if (h.expression && i.a0(i.K(s)))
          return kn(c);
        if (h.expression && i.O(i.Q(s)))
          return Xs(c);
        if (h.type && Sr[h.type]) {
          const y = Sr[h.type](c);
          return t === !0 && y.length > 0 && i.H(c.value) === "array" ? Xs(c) : y;
        }
        return $n(i.J({}, c, { valueSpec: h.type ? _[h.type] : h }));
      }
      function On(c) {
        const t = c.value, s = c.key, h = js(c);
        return h.length || (t.indexOf("{fontstack}") === -1 && h.push(new i.V(s, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && h.push(new i.V(s, t, '"glyphs" url must include a "{range}" token'))), h;
      }
      function Vn(c, t = i.a3, s = {}) {
        return mi({ key: s.key || "", value: c, valueSpec: t.$root, styleSpec: t, style: c, objectElementValidators: { glyphs: On, "*": () => [] } });
      }
      function Zi(c, t = i.a3) {
        return qe(Vn(c, t));
      }
      const Jn = (c) => qe(xo(c)), Fn = (c) => qe(yr(c)), Ls = (c) => qe(Mr(c)), zs = (c) => qe(io(c)), Vo = (c) => qe(Ys(c)), Ke = (c) => qe(function(t) {
        const s = t.value, h = t.style, _ = t.styleSpec, y = _.snow;
        let T = [];
        const z = i.H(s);
        if (s === void 0)
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("snow", s, `object expected, ${z} found`)]), T;
        for (const R in s) {
          const F = R.match(/^(.*)-transition$/);
          T = T.concat(F && y[F[1]] && y[F[1]].transition ? mi({ key: R, value: s[R], valueSpec: _.transition, style: h, styleSpec: _ }) : y[R] ? mi({ key: R, value: s[R], valueSpec: y[R], style: h, styleSpec: _ }) : [new i.G(R, s[R], `unknown property "${R}"`)]);
        }
        return T;
      }(c)), re = (c) => qe(function(t) {
        const s = t.value, h = t.style, _ = t.styleSpec, y = _.rain;
        let T = [];
        const z = i.H(s);
        if (s === void 0)
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("rain", s, `object expected, ${z} found`)]), T;
        for (const R in s) {
          const F = R.match(/^(.*)-transition$/);
          T = T.concat(F && y[F[1]] && y[F[1]].transition ? mi({ key: R, value: s[R], valueSpec: _.transition, style: h, styleSpec: _ }) : y[R] ? mi({ key: R, value: s[R], valueSpec: y[R], style: h, styleSpec: _ }) : [new i.G(R, s[R], `unknown property "${R}"`)]);
        }
        return T;
      }(c)), le = (c) => qe(Pn(c)), ge = (c) => qe(Wr(c)), Le = (c) => qe(zn(c)), Ce = (c) => qe(Rn(c)), Be = (c) => qe(i.a2(c));
      function qe(c) {
        return c.slice().sort((t, s) => t.line && s.line ? t.line - s.line : 0);
      }
      function Ae(c, t) {
        let s = !1;
        if (t && t.length)
          for (const h of t)
            h instanceof i.G ? i.w(h.message) : (c.fire(new i.y(new Error(h.message))), s = !0);
        return s;
      }
      let Ye;
      class Qe extends i.E {
        constructor(t, s = "flat") {
          super(), this._transitionable = new i.a4(Ye || (Ye = new i.a5({ anchor: new i.a6(i.a3.light.anchor), position: new i.a7(i.a3.light.position), color: new i.a6(i.a3.light.color), intensity: new i.a6(i.a3.light.intensity) }))), this.setLight(t, s), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, s, h = {}) {
          this._validate(Fn, t, h) || (this._transitionable.setTransitionOrValue(t), this.id = s);
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, h) {
          return (!h || h.validate !== !1) && Ae(this, t.call(Zi, i.l({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }
      let it = class extends i.E {
        constructor(c, t, s, h) {
          super(), this.scope = s, this._transitionable = new i.a4(new i.a5({ source: new i.a6(i.a3.terrain.source), exaggeration: new i.a6(i.a3.terrain.exaggeration) }), s, h), this._transitionable.setTransitionOrValue(c, h), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t) {
          this._transitionable.setTransitionOrValue(c, t);
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        getExaggeration(c) {
          return this._transitioning.possiblyEvaluate(new i.a8(c)).get("exaggeration");
        }
        getAttenuationRange() {
          if (!this.isZoomDependent())
            return null;
          const c = this._transitionable._values.exaggeration;
          if (!c)
            return null;
          const t = c.value.expression;
          if (!t)
            return null;
          let s = -1, h = -1, _ = 1;
          for (const y of t.zoomStops)
            _ = t.evaluate(new i.a8(y)), _ > 0.01 ? (s = y, h = -1) : h = y;
          return _ < 0.01 && s > 0 && h > s ? [s, h] : null;
        }
        isZoomDependent() {
          const c = this._transitionable._values.exaggeration;
          return c != null && c.value != null && c.value.expression != null && c.value.expression instanceof i.a9;
        }
      };
      const mt = 45, Ct = 65, It = 0.05;
      function Kt(c, t, s, h) {
        const _ = i.ac(mt, Ct, s), [y, T] = di(c, h);
        let z = 1 - Math.min(1, Math.exp((t - y) / (T - y) * -6));
        return z *= z * z, z = Math.min(1, 1.00747 * z), z * _ * c.alpha;
      }
      function di(c, t) {
        const s = 0.5 / Math.tan(0.5 * t);
        return [c.range[0] + s, c.range[1] + s];
      }
      function li(c, t, s, h, _) {
        const y = i.ab.vec3.transformMat4([], [t, s, h], _.mercatorFogMatrix);
        return Kt(c, i.ab.vec3.length(y), _.pitch, _._fov);
      }
      function ri(c, t, s, h, _, y, T) {
        const z = [[s, h, 0], [_, h, 0], [_, y, 0], [s, y, 0]];
        let R = Number.MAX_VALUE, F = -Number.MAX_VALUE;
        for (const N of z) {
          const G = i.ab.vec3.transformMat4([], N, t), Z = i.ab.vec3.length(G);
          R = Math.min(R, Z), F = Math.max(F, Z);
        }
        return [Kt(c, R, T.pitch, T._fov), Kt(c, F, T.pitch, T._fov)];
      }
      class Ki extends i.E {
        constructor(t, s, h, _) {
          super();
          const y = new i.a5({ range: new i.a6(i.a3.fog.range), color: new i.a6(i.a3.fog.color), "color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new i.a6(i.a3.fog["high-color"]), "high-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new i.a6(i.a3.fog["space-color"]), "space-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new i.a6(i.a3.fog["horizon-blend"]), "star-intensity": new i.a6(i.a3.fog["star-intensity"]), "vertical-range": new i.a6(i.a3.fog["vertical-range"]) });
          this._transitionable = new i.a4(y, h, new Map(_)), this.set(t, _), this._transitioning = this._transitionable.untransitioned(), this._transform = s, this.properties = new i.ad(y), this.scope = h;
        }
        get state() {
          const t = this._transform, s = t.projection.name === "globe", h = i.ae(t.zoom), _ = this.properties.get("range"), y = [0.5, 3];
          return { range: s ? [i.af(y[0], _[0], h), i.af(y[1], _[1], h)] : _, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t, s, h = {}) {
          if (this._validate(Vo, t, h))
            return;
          const _ = i.l({}, t);
          for (const y of Object.keys(i.a3.fog))
            _[y] === void 0 && (_[y] = i.a3.fog[y].default);
          this._options = _, this._transitionable.setTransitionOrValue(this._options, s);
        }
        getOpacity(t) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const s = this.properties && this.properties.get("color") || 1;
          return (this._transform.projection.name === "globe" ? 1 : i.ac(mt, Ct, t)) * s.a;
        }
        getOpacityAtLatLng(t, s) {
          return this._transform.projection.supportsFog ? function(h, _, y) {
            const T = i.aa.fromLngLat(_), z = y.elevation ? y.elevation.getAtPointOrZero(T) : 0;
            return li(h, T.x, T.y, z, y);
          }(this.state, t, s) : 0;
        }
        getOpacityForTile(t) {
          if (!this._transform.projection.supportsFog)
            return [1, 1];
          const s = this._transform.calculateFogTileMatrix(t.toUnwrapped());
          return ri(this.state, s, 0, 0, i.ag, i.ag, this._transform);
        }
        getOpacityForBounds(t, s, h, _, y) {
          return this._transform.projection.supportsFog ? ri(this.state, t, s, h, _, y, this._transform) : [1, 1];
        }
        getFovAdjustedRange(t) {
          return this._transform.projection.supportsFog ? di(this.state, t) : [0, 1];
        }
        isVisibleOnFrustum(t) {
          if (!this._transform.projection.supportsFog)
            return !1;
          const s = [4, 5, 6, 7];
          for (const h of s) {
            const _ = t.points[h];
            let y;
            if (_[2] >= 0)
              y = _;
            else {
              const T = t.points[h - 4];
              y = i.ah(T, _, T[2] / (T[2] - _[2]));
            }
            if (li(this.state, y[0], y[1], 0, this._transform) >= It)
              return !0;
          }
          return !1;
        }
        updateConfig(t) {
          this._transitionable.setTransitionOrValue(this._options, new Map(t));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, h) {
          return (!h || h.validate !== !1) && Ae(this, t.call(Zi, i.l({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }
      let Ni, Ei, $i, Hi, Xn = class extends i.E {
        constructor(c, t, s, h) {
          super();
          const _ = Ni || (Ni = new i.a5({ density: new i.a6(i.a3.snow.density), intensity: new i.a6(i.a3.snow.intensity), color: new i.a6(i.a3.snow.color), opacity: new i.a6(i.a3.snow.opacity), vignette: new i.a6(i.a3.snow.vignette), "vignette-color": new i.a6(i.a3.snow["vignette-color"]), "center-thinning": new i.a6(i.a3.snow["center-thinning"]), direction: new i.a6(i.a3.snow.direction), "flake-size": new i.a6(i.a3.snow["flake-size"]) }));
          this._transitionable = new i.a4(_, s, new Map(h)), this.set(c, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(_), this.scope = s;
        }
        get state() {
          const c = this.properties.get("opacity"), t = this.properties.get("color"), s = this.properties.get("direction"), h = i.ai(s[0]), _ = -Math.max(i.ai(s[1]), 0.01), y = [Math.cos(h) * Math.cos(_), Math.sin(h) * Math.cos(_), Math.sin(_)], T = this.properties.get("vignette"), z = this.properties.get("vignette-color");
          return z.a = T, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * c), direction: y, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: z };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t, s = {}) {
          if (this._validate(Ke, c, s))
            return;
          const h = i.l({}, c);
          for (const _ of Object.keys(i.a3.snow))
            h[_] === void 0 && (h[_] = i.a3.snow[_].default);
          this._options = h, this._transitionable.setTransitionOrValue(this._options, t);
        }
        updateConfig(c) {
          this._transitionable.setTransitionOrValue(this._options, new Map(c));
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        _validate(c, t, s) {
          return (!s || s.validate !== !1) && Ae(this, c.call(Zi, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }, Gs = class extends i.E {
        constructor(c, t, s, h) {
          super();
          const _ = Ei || (Ei = new i.a5({ density: new i.a6(i.a3.rain.density), intensity: new i.a6(i.a3.rain.intensity), color: new i.a6(i.a3.rain.color), opacity: new i.a6(i.a3.rain.opacity), vignette: new i.a6(i.a3.rain.vignette), "vignette-color": new i.a6(i.a3.rain["vignette-color"]), "center-thinning": new i.a6(i.a3.rain["center-thinning"]), direction: new i.a6(i.a3.rain.direction), "droplet-size": new i.a6(i.a3.rain["droplet-size"]), "distortion-strength": new i.a6(i.a3.rain["distortion-strength"]) }));
          this._transitionable = new i.a4(_, s, new Map(h)), this.set(c, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(_), this.scope = s;
        }
        get state() {
          const c = this.properties.get("opacity"), t = this.properties.get("color"), s = this.properties.get("direction"), h = i.ai(s[0]), _ = -Math.max(i.ai(s[1]), 0.01), y = [Math.cos(h) * Math.cos(_), Math.sin(h) * Math.cos(_), Math.sin(_)], T = this.properties.get("vignette-color");
          return T.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * c), direction: y, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: T };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t, s = {}) {
          if (this._validate(re, c, s))
            return;
          const h = i.l({}, c);
          for (const _ of Object.keys(i.a3.rain))
            h[_] === void 0 && (h[_] = i.a3.rain[_].default);
          this._options = h, this._transitionable.setTransitionOrValue(this._options, t);
        }
        updateConfig(c) {
          this._transitionable.setTransitionOrValue(this._options, new Map(c));
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        _validate(c, t, s) {
          return (!s || s.validate !== !1) && Ae(this, c.call(Zi, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      };
      class ps extends i.E {
        constructor(t, s, h, _) {
          super(), this.scope = h, this._options = t, this.properties = new i.ad(s), this._transitionable = new i.a4(s, h, new Map(_)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(t) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(t));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(t, s) {
          this._options = t, this._transitionable.setTransitionOrValue(t.properties, s);
        }
        shadowsEnabled() {
          return !!this.properties && this.properties.get("cast-shadows") === !0;
        }
      }
      class vs {
        constructor(t, s, h, _) {
          this.screenBounds = t, this.cameraPoint = s, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = h, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, _);
        }
        static createFromScreenPoints(t, s) {
          let h, _;
          if (t instanceof i.P || typeof t[0] == "number") {
            const y = i.P.convert(t);
            h = [y], _ = s.isPointAboveHorizon(y);
          } else {
            const y = i.P.convert(t[0]), T = i.P.convert(t[1]);
            h = [y, T], _ = i.al(y, T).every((z) => s.isPointAboveHorizon(z));
          }
          return new vs(h, s.getCameraPoint(), _, s);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(t) {
          return i.al(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t);
        }
        bufferedCameraGeometry(t) {
          const s = this.screenBounds[0], h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], _ = i.al(s, h, 0, !1);
          return this.cameraPoint.y > h.y && (this.cameraPoint.x > s.x && this.cameraPoint.x < h.x ? _.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= h.x ? _[2] = this.cameraPoint : this.cameraPoint.x <= s.x && (_[3] = this.cameraPoint)), i.am(_, t);
        }
        bufferedCameraGeometryGlobe(t) {
          const s = this.screenBounds[0], h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], _ = i.al(s, h, t), y = this.cameraPoint.clone();
          switch (3 * ((y.y > s.y) + (y.y > h.y)) + ((y.x > s.x) + (y.x > h.x))) {
            case 0:
              _[0] = y, _[4] = y.clone();
              break;
            case 1:
              _.splice(1, 0, y);
              break;
            case 2:
              _[1] = y;
              break;
            case 3:
              _.splice(4, 0, y);
              break;
            case 5:
              _.splice(2, 0, y);
              break;
            case 6:
              _[3] = y;
              break;
            case 7:
              _.splice(3, 0, y);
              break;
            case 8:
              _[2] = y;
          }
          return _;
        }
        containsTile(t, s, h, _ = 0) {
          const y = t.queryPadding / s._pixelsPerMercatorPixel + 1, T = h ? this._bufferedCameraMercator(y, s) : this._bufferedScreenMercator(y, s);
          let z = t.tileID.wrap + (T.unwrapped ? _ : 0);
          const R = T.polygon.map((se) => i.an(t.tileTransform, se, z));
          if (!i.ao(R, 0, 0, i.ag, i.ag))
            return;
          z = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? _ : 0);
          const F = this.screenGeometryMercator.polygon.map((se) => i.ap(t.tileTransform, se, z)), N = F.map((se) => new i.P(se[0], se[1])), G = s.getFreeCameraOptions().position || new i.aa(0, 0, 0), Z = i.ap(t.tileTransform, G, z), W = F.map((se) => {
            const oe = i.ab.vec3.sub(se, se, Z);
            return i.ab.vec3.normalize(oe, oe), new i.aq(Z, oe);
          }), te = i.ar(t, 1, s.zoom) * s._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: N, tilespaceRays: W, bufferedTilespaceGeometry: R, bufferedTilespaceBounds: (ee = i.as(R), ee.min.x = i.aw(ee.min.x, 0, i.ag), ee.min.y = i.aw(ee.min.y, 0, i.ag), ee.max.x = i.aw(ee.max.x, 0, i.ag), ee.max.y = i.aw(ee.max.y, 0, i.ag), ee), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: te };
          var ee;
        }
        _bufferedScreenMercator(t, s) {
          const h = oa(t);
          if (this._screenRaycastCache[h])
            return this._screenRaycastCache[h];
          {
            let _;
            return _ = s.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(t), s) : { polygon: this.bufferedScreenGeometry(t).map((y) => s.pointCoordinate3D(y)), unwrapped: !0 }, this._screenRaycastCache[h] = _, _;
          }
        }
        _bufferedCameraMercator(t, s) {
          const h = oa(t);
          if (this._cameraRaycastCache[h])
            return this._cameraRaycastCache[h];
          {
            let _;
            return _ = s.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), s) : { polygon: this.bufferedCameraGeometry(t).map((y) => s.pointCoordinate3D(y)), unwrapped: !0 }, this._cameraRaycastCache[h] = _, _;
          }
        }
        _projectAndResample(t, s) {
          const h = function(y, T) {
            const z = i.ab.mat4.multiply([], T.pixelMatrix, T.globeMatrix), R = [0, -i.ax, 0, 1], F = [0, i.ax, 0, 1], N = [0, 0, 0, 1];
            i.ab.vec4.transformMat4(R, R, z), i.ab.vec4.transformMat4(F, F, z), i.ab.vec4.transformMat4(N, N, z);
            const G = new i.P(R[0] / R[3], R[1] / R[3]), Z = new i.P(F[0] / F[3], F[1] / F[3]), W = i.au(y, G) && R[3] < N[3], te = i.au(y, Z) && F[3] < N[3];
            if (!W && !te)
              return null;
            const ee = function(we, ve, Pe) {
              for (let Oe = 1; Oe < we.length; Oe++) {
                const Xe = Er(ve.pointCoordinate3D(we[Oe - 1]).x), He = Er(ve.pointCoordinate3D(we[Oe]).x);
                if (Pe < 0) {
                  if (Xe < He)
                    return { idx: Oe, t: -Xe / (He - 1 - Xe) };
                } else if (He < Xe)
                  return { idx: Oe, t: (1 - Xe) / (He + 1 - Xe) };
              }
              return null;
            }(y, T, W ? -1 : 1);
            if (!ee)
              return null;
            const { idx: se, t: oe } = ee;
            let he = se > 1 ? ra(y.slice(0, se), T) : [], _e = se < y.length ? ra(y.slice(se), T) : [];
            he = he.map((we) => new i.P(Er(we.x), we.y)), _e = _e.map((we) => new i.P(Er(we.x), we.y));
            const pe = [...he];
            pe.length === 0 && pe.push(_e[_e.length - 1]);
            const Me = i.af(pe[pe.length - 1].y, (_e.length === 0 ? he[0] : _e[0]).y, oe);
            let xe;
            return xe = W ? [new i.P(0, Me), new i.P(0, 0), new i.P(1, 0), new i.P(1, Me)] : [new i.P(1, Me), new i.P(1, 1), new i.P(0, 1), new i.P(0, Me)], pe.push(...xe), _e.length === 0 ? pe.push(he[0]) : pe.push(..._e), { polygon: pe.map((we) => new i.aa(we.x, we.y)), unwrapped: !1 };
          }(t, s);
          if (h)
            return h;
          const _ = function(y, T) {
            let z = !1, R = -1 / 0, F = 0;
            for (let G = 0; G < y.length - 1; G++)
              y[G].x > R && (R = y[G].x, F = G);
            for (let G = 0; G < y.length - 1; G++) {
              const Z = (F + G) % (y.length - 1), W = y[Z], te = y[Z + 1];
              Math.abs(W.x - te.x) > 0.5 && (W.x < te.x ? (W.x += 1, Z === 0 && (y[y.length - 1].x += 1)) : (te.x += 1, Z + 1 === y.length - 1 && (y[0].x += 1)), z = !0);
            }
            const N = i.at(T.center.lng);
            return z && N < Math.abs(N - 1) && y.forEach((G) => {
              G.x -= 1;
            }), { polygon: y, unwrapped: z };
          }(ra(t, s).map((y) => new i.P(Er(y.x), y.y)), s);
          return { polygon: _.polygon.map((y) => new i.aa(y.x, y.y)), unwrapped: _.unwrapped };
        }
      }
      function ra(c, t) {
        return i.av(c, (s) => {
          const h = t.pointCoordinate3D(s);
          s.x = h.x, s.y = h.y;
        }, 1 / 256);
      }
      function Er(c) {
        return c < 0 ? 1 + c % 1 : c % 1;
      }
      function oa(c) {
        return 100 * c | 0;
      }
      function cl(c, t, s, h, _) {
        const y = function(z, R) {
          if (z)
            return _(z);
          if (R) {
            if (c.url && R.tiles && c.tiles && delete c.tiles, R.variants) {
              if (!Array.isArray(R.variants))
                return _(new Error("variants must be an array"));
              for (const N of R.variants) {
                if (N == null || typeof N != "object" || N.constructor !== Object)
                  return _(new Error("variant must be an object"));
                if (!Array.isArray(N.capabilities))
                  return _(new Error("capabilities must be an array"));
                if (N.capabilities.length === 1 && N.capabilities[0] === "meshopt") {
                  R = i.l(R, N);
                  break;
                }
              }
            }
            const F = i.ay(i.l({}, R, c), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
            F.tiles = t.canonicalizeTileset(F, c.url), _(null, F);
          }
        }, T = function(z, R, F) {
          if (!z)
            return null;
          if (!R && !F)
            return z;
          F = F || z.worldview_default;
          const N = Object.values(z.language || {});
          if (N.length === 0)
            return null;
          const G = Object.values(z.worldview || {});
          if (G.length === 0)
            return null;
          const Z = N.every((te) => te === R), W = G.every((te) => te === F);
          return Z && W ? z : R in (z.language_options || {}) || F in (z.worldview_options || {}) ? null : z.language_options && z.worldview_options ? z : null;
        }(c.data, s, h);
        return T ? i.q.frame(() => y(null, T)) : c.url ? i.n(t.transformRequest(t.normalizeSourceURL(c.url, null, s, h), i.R.Source), y) : i.q.frame(() => {
          const { data: z, ...R } = c;
          y(null, R);
        });
      }
      class Uo {
        constructor(t, s, h) {
          this.bounds = i.az.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = h || 24;
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const s = Math.pow(2, t.z), h = Math.floor(i.at(this.bounds.getWest()) * s), _ = Math.floor(i.aA(this.bounds.getNorth()) * s), y = Math.ceil(i.at(this.bounds.getEast()) * s), T = Math.ceil(i.aA(this.bounds.getSouth()) * s);
          return t.x >= h && t.x < y && t.y >= _ && t.y < T;
        }
      }
      class jo extends i.E {
        constructor(t, s, h, _) {
          if (super(), this.id = t, this.dispatcher = h, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, i.l(this, i.ay(s, ["url", "scheme", "tileSize", "promoteId"])), this._options = i.l({ type: "vector" }, s), this._collectResourceTiming = !!s.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(_), this._tileWorkers = {}, this._deduped = new i.aB();
        }
        load(t) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
          const s = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, h = this.map.getWorldview();
          this._tileJSONRequest = cl(this._options, this.map._requestManager, s, h, (_, y) => {
            if (this._tileJSONRequest = null, this._loaded = !0, _)
              s && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${s}`), h && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${h}`), this.fire(new i.y(_));
            else if (y) {
              if (i.l(this, y), this.hasWorldviews = !!y.worldview_options, y.worldview_default && (this.worldviewDefault = y.worldview_default), y.vector_layers) {
                this.vectorLayers = y.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                for (const T of y.vector_layers)
                  this.vectorLayerIds.push(T.id), y.worldview && y.worldview[T.source] && this.localizableLayerIds.add(T.id);
              }
              y.bounds && (this.tileBounds = new Uo(y.bounds, this.minzoom, this.maxzoom)), an(y.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
            }
            t && t(_);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = i.aC(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return this._options.tiles = t, this.reload(), this;
        }
        setUrl(t) {
          return this.url = t, this._options.url = t, this.reload(), this;
        }
        onRemove(t) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return i.l({}, this._options);
        }
        loadTile(t, s) {
          const h = t.tileID.canonical.url(this.tiles, this.scheme), _ = this.map._requestManager.normalizeTileURL(h), y = this.map._requestManager.transformRequest(_, i.R.Tile), T = this.map.style ? this.map.style.getLut(this.scope) : null, z = T ? { image: T.image.clone() } : null, R = { request: y, data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, lut: z, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
          if (this.hasWorldviews && i.f(h) && (R.worldview = this.map.getWorldview() || this.worldviewDefault, R.localizableLayerIds = this.localizableLayerIds), R.request.collectResourceTiming = this._collectResourceTiming, t.actor && t.state !== "expired")
            t.state === "loading" ? t.reloadCallback = s : t.request = t.actor.send("reloadTile", R, F.bind(this));
          else if (t.actor = this._tileWorkers[_] = this._tileWorkers[_] || this.dispatcher.getActor(), this.dispatcher.ready)
            t.request = t.actor.send("loadTile", R, F.bind(this), void 0, !0);
          else {
            const N = i.aD.call({ deduped: this._deduped }, R, (G, Z) => {
              G || !Z ? F.call(this, G) : (R.data = { cacheControl: Z.cacheControl, expires: Z.expires, rawData: Z.rawData.slice(0) }, t.actor && t.actor.send("loadTile", R, F.bind(this), void 0, !0));
            }, !0);
            t.request = { cancel: N };
          }
          function F(N, G) {
            return delete t.request, t.aborted ? s(null) : N && N.status !== 404 ? s(N) : (G && G.resourceTiming && (t.resourceTiming = G.resourceTiming), this.map._refreshExpiredTiles && G && t.setExpiryData(G), t.loadVectorData(G, this.map.painter), i.aE(this.dispatcher), s(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
          }
        }
        abortTile(t) {
          t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(t, s) {
          t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope }), t.destroy();
        }
        hasTransition() {
          return !1;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class tn extends i.E {
        constructor(t, s, h, _) {
          super(), this.id = t, this.dispatcher = h, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = i.l({ type: "raster" }, s), i.l(this, i.ay(s, ["url", "scheme", "tileSize"]));
        }
        load(t) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._tileJSONRequest = cl(this._options, this.map._requestManager, null, null, (s, h) => {
            this._tileJSONRequest = null, this._loaded = !0, s ? this.fire(new i.y(s)) : h && (i.l(this, h), h.raster_layers && (this.rasterLayers = h.raster_layers, this.rasterLayerIds = this.rasterLayers.map((_) => _.id)), h.bounds && (this.tileBounds = new Uo(h.bounds, this.minzoom, this.maxzoom)), an(h.tiles), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), t && t(s);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = i.aC(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return this._options.tiles = t, this.reload(), this;
        }
        setUrl(t) {
          return this.url = t, this._options.url = t, this.reload(), this;
        }
        onRemove(t) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return i.l({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t, s) {
          const h = i.q.devicePixelRatio >= 2, _ = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), h, this.tileSize);
          t.request = i.o(this.map._requestManager.transformRequest(_, i.R.Tile), (y, T, z, R) => (delete t.request, t.aborted ? (t.state = "unloaded", s(null)) : y ? (t.state = "errored", s(y)) : T ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: z, expires: R }), t.setTexture(T, this.map.painter), t.state = "loaded", i.aE(this.dispatcher), void s(null)) : s(null)));
        }
        abortTile(t, s) {
          t.request && (t.request.cancel(), delete t.request), s && s();
        }
        unloadTile(t, s) {
          t.texture && t.texture instanceof i.T ? (t.destroy(!0), t.texture && t.texture instanceof i.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), s && s();
        }
        hasTransition() {
          return !1;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class xn extends tn {
        constructor(t, s, h, _) {
          super(t, s, h, _), this.type = "raster-array", this.maxzoom = 22, this._options = i.l({ type: "raster-array" }, s);
        }
        triggerRepaint(t) {
          const s = this.map.painter._terrain, h = this.map.style.getSourceCache(this.id);
          s && s.enabled && h && s._clearRenderCacheForTile(h.id, t.tileID), this.map.triggerRepaint();
        }
        loadTile(t, s) {
          const h = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), _ = this.map._requestManager.transformRequest(h, i.R.Tile);
          t.requestParams = _, t.actor || (t.actor = this.dispatcher.getActor()), t.request = t.fetchHeader(void 0, (y, T, z, R) => {
            if (delete t.request, t.aborted)
              return t.state = "unloaded", s(null);
            if (y)
              return y.code === 20 ? void 0 : (t.state = "errored", s(y));
            this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: z, expires: R }), t.state = "empty", s(null);
          });
        }
        unloadTile(t, s) {
          const h = t.texture;
          h && h instanceof i.T ? (t.destroy(!0), this.map.painter.saveTileTexture(h)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = "unloaded";
        }
        prepareTile(t, s, h) {
          t._isHeaderLoaded && (t.state !== "empty" && (t.state = "reloading"), t.fetchBand(s, h, (_, y) => {
            if (_)
              return t.state = "errored", this.fire(new i.y(_)), void this.triggerRepaint(t);
            y && (t.setTexture(y, this.map.painter), t.state = "loaded", this.triggerRepaint(t));
          }));
        }
        getInitialBand(t) {
          if (!this.rasterLayers)
            return 0;
          const s = this.rasterLayers.find(({ id: y }) => y === t), h = s && s.fields, _ = h && h.bands && h.bands;
          return _ ? _[0] : 0;
        }
        getTextureDescriptor(t, s, h) {
          if (!t)
            return;
          const _ = s.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
          if (!_)
            return;
          let y = null;
          s instanceof i.aH ? y = s.paint.get("raster-array-band") : s instanceof i.aI && (y = s.paint.get("raster-particle-array-band"));
          const T = y || this.getInitialBand(_);
          if (T != null)
            if (t.textureDescriptor) {
              if (!t.updateNeeded(_, T) || h)
                return Object.assign({}, t.textureDescriptor, { texture: t.texture });
            } else
              this.prepareTile(t, _, T);
        }
      }
      const no = { vector: jo, raster: tn, "raster-dem": class extends tn {
        constructor(c, t, s, h) {
          super(c, t, s, h), this.type = "raster-dem", this.maxzoom = 22, this._options = i.l({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox";
        }
        loadTile(c, t) {
          const s = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
          function h(_, y) {
            _ && (c.state = "errored", t(_)), y && (c.dem = y, c.dem.onDeserialize(), c.needsHillshadePrepare = !0, c.needsDEMTextureUpload = !0, c.state = "loaded", t(null));
          }
          c.request = i.o(this.map._requestManager.transformRequest(s, i.R.Tile), (function(_, y, T, z) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", t(null);
            else if (_)
              c.state = "errored", t(_);
            else if (y) {
              this.map._refreshExpiredTiles && c.setExpiryData({ cacheControl: T, expires: z });
              const R = ImageBitmap && y instanceof ImageBitmap && i.t(), F = 1 - (y.width - i.aF(y.width)) / 2;
              F < 1 || c.neighboringTiles || (c.neighboringTiles = this._getNeighboringTiles(c.tileID));
              const N = R ? y : i.q.getImageData(y, F), G = { uid: c.uid, coord: c.tileID, source: this.id, scope: this.scope, rawImageData: N, encoding: this.encoding, padding: F };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", G, h.bind(this), void 0, !0));
            }
          }).bind(this));
        }
        _getNeighboringTiles(c) {
          const t = c.canonical, s = Math.pow(2, t.z), h = (t.x - 1 + s) % s, _ = t.x === 0 ? c.wrap - 1 : c.wrap, y = (t.x + 1 + s) % s, T = t.x + 1 === s ? c.wrap + 1 : c.wrap, z = {};
          return z[new i.aG(c.overscaledZ, _, t.z, h, t.y).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, y, t.y).key] = { backfilled: !1 }, t.y > 0 && (z[new i.aG(c.overscaledZ, _, t.z, h, t.y - 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, c.wrap, t.z, t.x, t.y - 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, y, t.y - 1).key] = { backfilled: !1 }), t.y + 1 < s && (z[new i.aG(c.overscaledZ, _, t.z, h, t.y + 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, c.wrap, t.z, t.x, t.y + 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, y, t.y + 1).key] = { backfilled: !1 }), z;
        }
      }, "raster-array": xn, geojson: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = s.getActor(), this.setEventedParent(h), this._data = t.data, this._options = i.l({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.minzoom !== void 0 && (this.minzoom = t.minzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
          const _ = i.ag / this.tileSize;
          this.workerOptions = i.l({ source: this.id, scope: this.scope, cluster: t.cluster || !1, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * _, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * _, extent: i.ag, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || !1, generateId: t.generateId || !1 }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: i.ag, radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * _, log: !1, generateId: t.generateId || !1 }, clusterProperties: t.clusterProperties, filter: t.filter, dynamic: t.dynamic }, t.workerOptions);
        }
        onAdd(c) {
          this.map = c, this.setData(this._data);
        }
        setData(c) {
          return this._data = c, this._updateWorkerData(), this;
        }
        updateData(c) {
          if (!this._options.dynamic)
            return this.fire(new i.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          if (typeof c != "string" && (c.type === "Feature" && (c = { type: "FeatureCollection", features: [c] }), c.type !== "FeatureCollection"))
            return this.fire(new i.y(new Error("Data to update should be a feature or a feature collection.")));
          if (this._coalesce && typeof c != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
            const t = /* @__PURE__ */ new Map();
            for (const s of this._data.features)
              t.set(s.id, s);
            for (const s of c.features)
              t.set(s.id, s);
            this._data.features = [...t.values()];
          } else
            this._data = c;
          return this._updateWorkerData(!0), this;
        }
        getClusterExpansionZoom(c, t) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id, scope: this.scope }, t), this;
        }
        getClusterChildren(c, t) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id, scope: this.scope }, t), this;
        }
        getClusterLeaves(c, t, s, h) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: c, limit: t, offset: s }, h), this;
        }
        _updateWorkerData(c = !1) {
          if (this._pendingLoad)
            return void (this._coalesce = !0);
          this.fire(new i.z("dataloading", { dataType: "source" })), this._loaded = !1;
          const t = i.l({ append: c }, this.workerOptions);
          t.scope = this.scope;
          const s = this._data;
          typeof s == "string" ? (t.request = this.map._requestManager.transformRequest(i.q.resolveURL(s), i.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(s), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (h, _) => {
            if (this._loaded = !0, this._pendingLoad = null, h)
              this.fire(new i.y(h));
            else {
              const y = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && _ && _.resourceTiming && _.resourceTiming[this.id] && (y.resourceTiming = _.resourceTiming[this.id]), c && (this._partialReload = !0), this.fire(new i.z("data", y)), this._partialReload = !1, this._metadataFired = !0;
            }
            this._coalesce && (this._updateWorkerData(c), this._coalesce = !1);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(c, t) {
          const s = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor;
          const h = this.map.style ? this.map.style.getLut(this.scope) : null, _ = h ? { image: h.image.clone() } : null, y = this._partialReload, T = { type: this.type, uid: c.uid, tileID: c.tileID, tileZoom: c.tileZoom, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: _, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, scaleFactor: this.map.getScaleFactor(), partial: y };
          c.request = this.actor.send(s, T, (z, R) => y && !R ? (c.state = "loaded", t(null)) : (delete c.request, c.destroy(), c.aborted ? t(null) : z ? t(z) : (c.loadVectorData(R, this.map.painter, s === "reloadTile"), t(null))), void 0, s === "loadTile");
        }
        abortTile(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }
        unloadTile(c, t) {
          this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id, scope: this.scope }), c.destroy();
        }
        onRemove(c) {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return i.l({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }, video: class extends i.aJ {
        constructor(c, t, s, h) {
          super(c, t, s, h), this.roundZoom = !0, this.type = "video", this.options = t;
        }
        load() {
          this._loaded = !1;
          const c = this.options;
          this.urls = [];
          for (const t of c.urls)
            this.urls.push(this.map._requestManager.transformRequest(t, i.R.Source).url);
          i.aK(this.urls, (t, s) => {
            this._loaded = !0, t ? this.fire(new i.y(t)) : s && (this.video = s, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(c) {
          if (this.video) {
            const t = this.video.seekable;
            c < t.start(0) || c > t.end(0) ? this.fire(new i.y(new i.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = c;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const c = this.map.painter.context, t = c.gl;
          this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new i.T(c, this.video, t.RGBA8), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(c);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: i.aJ, model: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "model", this.models = [], this._loaded = !1, this._options = t;
        }
        load() {
          const c = [];
          for (const t in this._options.models) {
            const s = this._options.models[t], h = i.aM(this.map._requestManager.transformRequest(s.uri, i.R.Model).url).then((_) => {
              if (!_)
                return;
              const y = i.aN(_), T = new i.aO(t, s.position, s.orientation, y);
              T.computeBoundsAndApplyParent(), this.models.push(T);
            }).catch((_) => {
              this.fire(new i.y(new Error(`Could not load model ${t} from ${s.uri}: ${_.message}`)));
            });
            c.push(h);
          }
          return Promise.allSettled(c).then(() => {
            this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((t) => {
            this.fire(new i.y(new Error(`Could not load models: ${t.message}`)));
          });
        }
        onAdd(c) {
          this.map = c, this.load();
        }
        hasTransition() {
          return !1;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(c, t) {
        }
        serialize() {
          return { type: "model" };
        }
      }, "batched-model": class extends i.E {
        constructor(c, t, s, h) {
          super(), this.type = "batched-model", this.id = c, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = s, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(h);
        }
        onAdd(c) {
          this.map = c, this.load();
        }
        load(c) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
          const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, s = this.map.getWorldview();
          this._tileJSONRequest = cl(this._options, this.map._requestManager, t, s, (h, _) => {
            this._tileJSONRequest = null, this._loaded = !0, h ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), s && s.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${s}`), this.fire(new i.y(h))) : _ && (i.l(this, _), _.bounds && (this.tileBounds = new Uo(_.bounds, this.minzoom, this.maxzoom)), an(_.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), c && c(h);
          });
        }
        hasTransition() {
          return !1;
        }
        hasTile(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(c, t) {
          const s = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), h = { request: this.map._requestManager.transformRequest(s, i.R.Tile), data: void 0, uid: c.uid, tileID: c.tileID, tileZoom: c.tileZoom, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: c.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, lut: null, maxZoom: null, promoteId: null, pixelRatio: null, scaleFactor: null };
          if (c.actor && c.state !== "expired")
            if (c.state === "loading")
              c.reloadCallback = t;
            else {
              if (c.buckets) {
                const y = Object.values(c.buckets);
                for (const T of y)
                  T.dirty = !0;
                return void (c.state = "loaded");
              }
              c.request = c.actor.send("reloadTile", h, _.bind(this));
            }
          else
            c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", h, _.bind(this), void 0, !0);
          function _(y, T) {
            return c.aborted ? t(null) : y && y.status !== 404 ? t(y) : (this.map._refreshExpiredTiles && T && c.setExpiryData(T), c.loadModelData(T, this.map.painter), c.state = "loaded", void t(null));
          }
        }
        serialize() {
          return i.l({}, this._options);
        }
      }, canvas: class extends i.aJ {
        constructor(c, t, s, h) {
          super(c, t, s, h), t.coordinates ? Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some((_) => !Array.isArray(_) || _.length !== 2 || _.some((y) => typeof y != "number")) || this.fire(new i.y(new i.V(`sources.${c}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new i.y(new i.V(`sources.${c}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new i.y(new i.V(`sources.${c}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == "string" || t.canvas instanceof HTMLCanvasElement || this.fire(new i.y(new i.V(`sources.${c}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new i.y(new i.V(`sources.${c}`, null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate === void 0 || t.animate;
        }
        load() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new i.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove(c) {
          this.pause();
        }
        prepare() {
          let c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
            return;
          const t = this.map.painter.context;
          this.texture ? !c && !this._playing || this.texture instanceof i.aL || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new i.T(t, this.canvas, t.gl.RGBA8, { premultiply: !0 }), this._prepareData(t);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const c of [this.canvas.width, this.canvas.height])
            if (isNaN(c) || c <= 0)
              return !0;
          return !1;
        }
      }, custom: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "custom", this._dataType = "raster", this._dispatcher = s, this._implementation = t, this.setEventedParent(h), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new i.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new i.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Uo(this._implementation.bounds, this.minzoom, this.maxzoom)), t.update = this._update.bind(this), t.clearTiles = this._clearTiles.bind(this), t.coveringTiles = this._coveringTiles.bind(this), i.l(this, i.ay(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return i.ay(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(c) {
          this.map = c, this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(c), this.load();
        }
        onRemove(c) {
          this._implementation.onRemove && this._implementation.onRemove(c);
        }
        hasTile(c) {
          if (this._implementation.hasTile) {
            const { x: t, y: s, z: h } = c.canonical;
            return this._implementation.hasTile({ x: t, y: s, z: h });
          }
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }
        loadTile(c, t) {
          const { x: s, y: h, z: _ } = c.tileID.canonical, y = new AbortController();
          c.request = Promise.resolve(this._implementation.loadTile({ x: s, y: h, z: _ }, { signal: y.signal })).then((function(T) {
            return delete c.request, c.aborted ? (c.state = "unloaded", t(null)) : T === void 0 ? (c.state = "errored", t(null)) : T === null ? (this.loadTileData(c, { width: this.tileSize, height: this.tileSize, data: null }), c.state = "loaded", t(null)) : function(z) {
              return z instanceof ImageData || z instanceof HTMLCanvasElement || z instanceof ImageBitmap || z instanceof HTMLImageElement;
            }(T) ? (this.loadTileData(c, T), c.state = "loaded", void t(null)) : (c.state = "errored", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }).bind(this)).catch((T) => {
            T.code !== 20 && (c.state = "errored", t(T));
          }), c.request.cancel = () => y.abort();
        }
        loadTileData(c, t) {
          c.setTexture(t, this.map.painter);
        }
        unloadTile(c, t) {
          if (c.texture && c.texture instanceof i.T ? (c.destroy(!0), c.texture && c.texture instanceof i.T && this.map.painter.saveTileTexture(c.texture)) : c.destroy(), this._implementation.unloadTile) {
            const { x: s, y: h, z: _ } = c.tileID.canonical;
            this._implementation.unloadTile({ x: s, y: h, z: _ });
          }
          t && t();
        }
        abortTile(c, t) {
          c.request && c.request.cancel && (c.request.cancel(), delete c.request), t && t();
        }
        hasTransition() {
          return !1;
        }
        _coveringTiles() {
          return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((c) => ({ x: c.canonical.x, y: c.canonical.y, z: c.canonical.z }));
        }
        _clearTiles() {
          const c = i.aC(this.id, this.scope);
          this.map.style.clearSource(c);
        }
        _update() {
          this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, Go = function(c, t, s, h) {
        const _ = new no[t.type](c, t, s, h);
        if (_.id !== c)
          throw new Error(`Expected Source id to be ${c} instead of ${_.id}`);
        return i.aP(["load", "abort", "unload", "serialize", "prepare"], _), _;
      };
      function aa(c, t, s, h, _ = !1) {
        const y = t.sourceCache.transform, T = t.sourceCache.tilesIn(c, t.has3DLayers, _);
        T.sort(Hn);
        const z = [];
        for (const R of T) {
          const F = R.tile.queryRenderedFeatures(t, R, s, h, y, _);
          Object.keys(F).length && z.push({ wrappedTileID: R.tile.tileID.wrapped().key, queryResults: F });
        }
        return z.length === 0 ? {} : function(R) {
          const F = {}, N = {};
          for (const G of R) {
            const Z = G.queryResults, W = G.wrappedTileID, te = N[W] = N[W] || {};
            for (const ee in Z) {
              const se = Z[ee], oe = te[ee] = te[ee] || {}, he = F[ee] = F[ee] || [];
              for (const _e of se)
                oe[_e.featureIndex] || (oe[_e.featureIndex] = !0, he.push(_e));
            }
          }
          return F;
        }(z);
      }
      function Da(c, t, s, h, _) {
        const y = {}, T = h.queryRenderedSymbols(c), z = [];
        for (const R of Object.keys(T).map(Number))
          z.push(_[R]);
        z.sort(Hn);
        for (const R of z) {
          const F = R.featureIndex.lookupSymbolFeatures(T[R.bucketInstanceId], R.bucketIndex, R.sourceLayerIndex, t, s);
          for (const N in F) {
            const G = y[N] = y[N] || [], Z = F[N];
            Z.sort((W, te) => {
              const ee = R.featureSortOrder;
              if (ee) {
                const se = ee.indexOf(W.featureIndex);
                return ee.indexOf(te.featureIndex) - se;
              }
              return te.featureIndex - W.featureIndex;
            });
            for (const W of Z)
              G.push(W);
          }
        }
        return y;
      }
      function Vi(c, t) {
        const s = c.getRenderableIds().map((y) => c.getTileByID(y)), h = [], _ = {};
        for (let y = 0; y < s.length; y++) {
          const T = s[y], z = T.tileID.canonical.key;
          _[z] || (_[z] = !0, T.querySourceFeatures(h, t));
        }
        return h;
      }
      function Hn(c, t) {
        const s = c.tileID, h = t.tileID;
        return s.overscaledZ - h.overscaledZ || s.canonical.y - h.canonical.y || s.wrap - h.wrap || s.canonical.x - h.canonical.x;
      }
      function hl(c, t) {
        const s = {};
        if (!t)
          return s;
        for (const h of c) {
          const _ = h.layerIds.map((y) => t.getLayer(y)).filter(Boolean);
          if (_.length !== 0) {
            h.layers = _, h.stateDependentLayerIds && (h.stateDependentLayers = h.stateDependentLayerIds.map((y) => _.filter((T) => T.id === y)[0]));
            for (const y of _)
              s[y.fqid] = h;
          }
        }
        return s;
      }
      const Zs = 32, Qn = 33, Ar = new Uint16Array(8184);
      for (let c = 0; c < 2046; c++) {
        let t = c + 2, s = 0, h = 0, _ = 0, y = 0, T = 0, z = 0;
        for (1 & t ? _ = y = T = Zs : s = h = z = Zs; (t >>= 1) > 1; ) {
          const F = s + _ >> 1, N = h + y >> 1;
          1 & t ? (_ = s, y = h, s = T, h = z) : (s = _, h = y, _ = T, y = z), T = F, z = N;
        }
        const R = 4 * c;
        Ar[R + 0] = s, Ar[R + 1] = h, Ar[R + 2] = _, Ar[R + 3] = y;
      }
      const nr = new Uint16Array(2178), Ks = new Uint8Array(1089), Yn = new Uint16Array(1089);
      function $r(c) {
        return c === 0 ? -0.03125 : c === 32 ? 0.03125 : 0;
      }
      const Pr = (() => ({ type: 2, extent: i.ag, loadGeometry: () => [[new i.P(0, 0), new i.P(i.ag + 1, 0), new i.P(i.ag + 1, i.ag + 1), new i.P(0, i.ag + 1), new i.P(0, 0)]] }))();
      class Cr {
        constructor(t, s, h, _, y) {
          this.tileID = t, this.uid = i.aV(), this.uses = 0, this.tileSize = s, this.tileZoom = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = y, _ && _.style && (this._lastUpdatedBrightness = _.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", _ && _.transform && (this.projection = _.transform.projection);
        }
        registerFadeDuration(t) {
          const s = t + this.timeAdded;
          s < i.q.now() || this.fadeEndTime && s < this.fadeEndTime || (this.fadeEndTime = s);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = i.aQ(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t, s, h) {
          if (this.unloadVectorData(), this.state = "loaded", t) {
            t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = hl(t.buckets, s.style), this.hasSymbolBuckets = !1;
            for (const _ in this.buckets) {
              const y = this.buckets[_];
              if (y instanceof i.aX) {
                if (this.hasSymbolBuckets = !0, !h)
                  break;
                y.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets)
              for (const _ in this.buckets) {
                const y = this.buckets[_];
                if (y instanceof i.aX && y.hasRTLText) {
                  this.hasRTLText = !0, i.aY();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const _ in this.buckets) {
              const y = this.buckets[_], T = s.style.getOwnLayer(_);
              if (!T)
                continue;
              const z = T.queryRadius(y);
              this.queryPadding = Math.max(this.queryPadding, z);
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;
          } else
            this.collisionBoxArray = new i.aW();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t in this.buckets)
              this.buckets[t].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        loadModelData(t, s, h) {
          t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming), this.buckets = { ...this.buckets, ...hl(t.buckets, s.style) }, t.featureIndex && (this.latestFeatureIndex = t.featureIndex));
        }
        getBucket(t) {
          return this.buckets[t.fqid];
        }
        upload(t) {
          for (const _ in this.buckets) {
            const y = this.buckets[_];
            y.uploadPending() && y.upload(t);
          }
          const s = t.gl, h = this.imageAtlas;
          if (h && !h.uploaded) {
            const _ = !!Object.keys(h.patternPositions).length;
            this.imageAtlasTexture = new i.T(t, h.image, s.RGBA8, { useMipmap: _ }), this.imageAtlas.uploaded = !0;
          }
          this.glyphAtlasImage && (this.glyphAtlasTexture = new i.T(t, this.glyphAtlasImage, s.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new i.T(t, this.lineAtlas.image, s.R8), this.lineAtlas.uploaded = !0);
        }
        prepare(t, s, h) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, h), !s || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
            return;
          const _ = s.style.getBrightness();
          (this._lastUpdatedBrightness || _) && (this._lastUpdatedBrightness && _ && Math.abs(this._lastUpdatedBrightness - _) < 1e-3 || (this.updateBuckets(s, this._lastUpdatedBrightness !== _), this._lastUpdatedBrightness = _));
        }
        queryRenderedFeatures(t, s, h, _, y, T) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile)
            return {};
          const z = function(R, F) {
            const N = i.ab.mat4.fromScaling([], [0.5 * R.width, 0.5 * -R.height, 1]);
            return i.ab.mat4.translate(N, N, [1, -1, 0]), i.ab.mat4.multiply(N, N, R.calculateProjMatrix(F.toUnwrapped())), Float32Array.from(N);
          }(y, this.tileID);
          return this.latestFeatureIndex.query(t, { tilespaceGeometry: s, pixelPosMatrix: z, transform: _, availableImages: h, tileTransform: this.tileTransform });
        }
        querySourceFeatures(t, s) {
          const h = this.latestFeatureIndex;
          if (!h || !h.rawTileData)
            return;
          const _ = h.loadVTLayers(), y = s ? s.sourceLayer : "", T = _._geojsonTileLayer || _[y];
          if (!T)
            return;
          const z = i.aZ(s && s.filter), { z: R, x: F, y: N } = this.tileID.canonical, G = { z: R, x: F, y: N };
          for (let Z = 0; Z < T.length; Z++) {
            const W = T.feature(Z);
            if (z.needGeometry) {
              const se = i.a_(W, !0);
              if (!z.filter(new i.a8(this.tileID.overscaledZ), se, this.tileID.canonical))
                continue;
            } else if (!z.filter(new i.a8(this.tileID.overscaledZ), W))
              continue;
            const te = h.getId(W, y), ee = new i.a$(W, R, F, N, te);
            ee.tile = G, t.push(ee);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const s = this.expirationTime;
          if (t.cacheControl) {
            const h = i.b0(t.cacheControl);
            h["max-age"] && (this.expirationTime = Date.now() + 1e3 * h["max-age"]);
          } else
            t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const h = Date.now();
            let _ = !1;
            if (this.expirationTime > h)
              _ = !1;
            else if (s)
              if (this.expirationTime < s)
                _ = !0;
              else {
                const y = this.expirationTime - s;
                y ? this.expirationTime = h + Math.max(y, 3e4) : _ = !0;
              }
            else
              _ = !0;
            _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        refreshFeatureState(t) {
          this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t);
        }
        updateBuckets(t, s) {
          if (!this.latestFeatureIndex || !t.style)
            return;
          const h = this.latestFeatureIndex.loadVTLayers(), _ = t.style.listImages(), y = t.style.getBrightness();
          for (const T in this.buckets) {
            if (!t.style.hasLayer(T))
              continue;
            const z = this.buckets[T], R = z.layers[0], F = R.sourceLayer || "_geojsonTileLayer", N = h[F], G = t.style.getLayerSourceCache(R);
            let Z = {};
            G && (Z = G._state.getState(F, void 0));
            const W = this.imageAtlas && this.imageAtlas.patternPositions || {}, te = Object.keys(Z).length > 0 && !s;
            te && !z.stateDependentLayers.length && !s || z.update(Z, N, _, W, te ? z.stateDependentLayers : z.layers, s, y), (z instanceof i.b1 || z instanceof i.b2) && t._terrain && t._terrain.enabled && G && z.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(G.id, this.tileID);
            const ee = t && t.style && t.style.getOwnLayer(T);
            ee && (this.queryPadding = Math.max(this.queryPadding, ee.queryRadius(z)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < i.q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = i.q.now() + t;
        }
        setTexture(t, s) {
          const h = s.context, _ = h.gl;
          this.texture = this.texture || s.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t) : (this.texture = new i.T(h, t, _.RGBA8, { useMipmap: !0 }), this.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE));
        }
        setDependencies(t, s) {
          const h = {};
          for (const _ of s)
            h[_] = !0;
          this.dependencies[t] = h;
        }
        hasDependency(t, s) {
          for (const h of t) {
            const _ = this.dependencies[h];
            if (_) {
              for (const y of s)
                if (_[y])
                  return !0;
            }
          }
          return !1;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t, s) {
          if (!s || s.name === "mercator" || this._tileDebugBuffer)
            return;
          const h = i.b3(Pr, this.tileID.canonical, this.tileTransform)[0], _ = new i.b4(), y = new i.b5();
          for (let T = 0; T < h.length; T++) {
            const { x: z, y: R } = h[T];
            _.emplaceBack(z, R), y.emplaceBack(T);
          }
          y.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(y), this._tileDebugBuffer = t.createVertexBuffer(_, i.b6.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, _.length, y.length);
        }
        _makeTileBoundsBuffers(t, s) {
          if (this._tileBoundsBuffer || !s || s.name === "mercator")
            return;
          const h = i.b3(Pr, this.tileID.canonical, this.tileTransform)[0];
          let _, y;
          if (this.isRaster) {
            const T = function(z, R) {
              const F = i.aQ(z, R), N = Math.pow(2, z.z);
              for (let se = 0; se < Qn; se++)
                for (let oe = 0; oe < Qn; oe++) {
                  const he = i.aR((z.x + (oe + $r(oe)) / Zs) / N), _e = i.aS((z.y + (se + $r(se)) / Zs) / N), pe = R.project(he, _e), Me = se * Qn + oe;
                  nr[2 * Me + 0] = Math.round((pe.x * F.scale - F.x) * i.ag), nr[2 * Me + 1] = Math.round((pe.y * F.scale - F.y) * i.ag);
                }
              Ks.fill(0), Yn.fill(0);
              for (let se = 2045; se >= 0; se--) {
                const oe = 4 * se, he = Ar[oe + 0], _e = Ar[oe + 1], pe = Ar[oe + 2], Me = Ar[oe + 3], xe = he + pe >> 1, we = _e + Me >> 1, ve = xe + we - _e, Pe = we + he - xe, Oe = _e * Qn + he, Xe = Me * Qn + pe, He = we * Qn + xe, ke = Math.hypot((nr[2 * Oe + 0] + nr[2 * Xe + 0]) / 2 - nr[2 * He + 0], (nr[2 * Oe + 1] + nr[2 * Xe + 1]) / 2 - nr[2 * He + 1]) >= 16;
                Ks[He] = Ks[He] || (ke ? 1 : 0), se < 1022 && (Ks[He] = Ks[He] || Ks[(_e + Pe >> 1) * Qn + (he + ve >> 1)] || Ks[(Me + Pe >> 1) * Qn + (pe + ve >> 1)]);
              }
              const G = new i.aT(), Z = new i.aU();
              let W = 0;
              function te(se, oe) {
                const he = oe * Qn + se;
                return Yn[he] === 0 && (G.emplaceBack(nr[2 * he + 0], nr[2 * he + 1], se * i.ag / Zs, oe * i.ag / Zs), Yn[he] = ++W), Yn[he] - 1;
              }
              function ee(se, oe, he, _e, pe, Me) {
                const xe = se + he >> 1, we = oe + _e >> 1;
                if (Math.abs(se - pe) + Math.abs(oe - Me) > 1 && Ks[we * Qn + xe])
                  ee(pe, Me, se, oe, xe, we), ee(he, _e, pe, Me, xe, we);
                else {
                  const ve = te(se, oe), Pe = te(he, _e), Oe = te(pe, Me);
                  Z.emplaceBack(ve, Pe, Oe);
                }
              }
              return ee(0, 0, Zs, Zs, Zs, 0), ee(Zs, Zs, 0, 0, 0, Zs), { vertices: G, indices: Z };
            }(this.tileID.canonical, s);
            _ = T.vertices, y = T.indices;
          } else {
            _ = new i.aT(), y = new i.aU();
            for (const { x: z, y: R } of h)
              _.emplaceBack(z, R, 0, 0);
            const T = i.b8(_.int16, void 0, 4);
            for (let z = 0; z < T.length; z += 3)
              y.emplaceBack(T[z], T[z + 1], T[z + 2]);
          }
          this._tileBoundsBuffer = t.createVertexBuffer(_, i.b9.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(y), this._tileBoundsSegments = i.b7.simpleSegment(0, 0, _.length, y.length);
        }
        _makeGlobeTileDebugBuffers(t, s) {
          const h = s.projection;
          if (!h || h.name !== "globe" || s.freezeTileCoverage)
            return;
          const _ = this.tileID.canonical, y = i.ba(_, s), T = i.bb(y), z = i.ae(s.zoom);
          let R;
          z > 0 && (R = i.ab.mat4.invert(new Float64Array(16), s.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, _, s, T, R, z), this._makeGlobeTileDebugTextBuffer(t, _, s, T, R, z);
        }
        _globePoint(t, s, h, _, y, T, z) {
          let R = i.bc(t, s, h);
          if (T) {
            const F = 1 << h.z, N = i.at(_.center.lng), G = i.aA(_.center.lat), Z = (h.x + 0.5) / F - N;
            let W = 0;
            Z > 0.5 ? W = -1 : Z < -0.5 && (W = 1);
            let te = (t / i.ag + h.x) / F + W, ee = (s / i.ag + h.y) / F;
            te = (te - N) * _._pixelsPerMercatorPixel + N, ee = (ee - G) * _._pixelsPerMercatorPixel + G;
            const se = [te * _.worldSize, ee * _.worldSize, 0];
            i.ab.vec3.transformMat4(se, se, T), R = i.bd(R, se, z);
          }
          return i.ab.vec3.transformMat4(R, R, y);
        }
        _makeGlobeTileDebugBorderBuffer(t, s, h, _, y, T) {
          const z = new i.b4(), R = new i.b5(), F = new i.be(), N = (Z, W, te, ee, se) => {
            const oe = (te - Z) / (se - 1), he = (ee - W) / (se - 1), _e = z.length;
            for (let pe = 0; pe < se; pe++) {
              const Me = Z + pe * oe, xe = W + pe * he;
              z.emplaceBack(Me, xe);
              const we = this._globePoint(Me, xe, s, h, _, y, T);
              F.emplaceBack(we[0], we[1], we[2]), R.emplaceBack(_e + pe);
            }
          }, G = i.ag;
          N(0, 0, G, 0, 16), N(G, 0, G, G, 16), N(G, G, 0, G, 16), N(0, G, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(R), this._tileDebugBuffer = t.createVertexBuffer(z, i.b6.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(F, i.bf.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, z.length, R.length);
        }
        _makeGlobeTileDebugTextBuffer(t, s, h, _, y, T) {
          const z = i.ag / 4, R = new i.b4(), F = new i.aU(), N = new i.be(), G = 25;
          F.reserve(32), R.reserve(G), N.reserve(G);
          const Z = (W, te) => G * W + te;
          for (let W = 0; W < G; W++) {
            const te = W * z;
            for (let ee = 0; ee < G; ee++) {
              const se = ee * z;
              R.emplaceBack(se, te);
              const oe = this._globePoint(se, te, s, h, _, y, T);
              N.emplaceBack(oe[0], oe[1], oe[2]);
            }
          }
          for (let W = 0; W < 4; W++)
            for (let te = 0; te < 4; te++) {
              const ee = Z(W, te), se = Z(W, te + 1), oe = Z(W + 1, te), he = Z(W + 1, te + 1);
              F.emplaceBack(ee, se, oe), F.emplaceBack(oe, se, he);
            }
          this._tileDebugTextIndexBuffer = t.createIndexBuffer(F), this._tileDebugTextBuffer = t.createVertexBuffer(R, i.b6.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(N, i.bf.members), this._tileDebugTextSegments = i.b7.simpleSegment(0, 0, G, 32);
        }
        destroy(t = !1) {
          for (const s in this.buckets)
            this.buckets[s].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof i.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      i.bg.setPbf(i.bh);
      class ka extends Cr {
        constructor(t, s, h, _, y) {
          super(t, s, h, _, y), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
        }
        setTexture(t, s) {
          const h = s.context, _ = h.gl;
          this.texture = this.texture || s.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t, { premultiply: !1 }) : this.texture = new i.T(h, t, _.RGBA8, { premultiply: !1 });
        }
        flushQueues() {
          for (; this._workQueue.length; )
            this._workQueue.pop()();
          for (; this._fetchQueue.length; )
            this._fetchQueue.pop()();
        }
        fetchHeader(t = 16384, s) {
          const h = this._mrt = new i.bg(30), _ = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t - 1) } });
          return this.entireBuffer = null, this.request = i.bi(_, (y, T, z, R) => {
            if (y)
              s(y);
            else
              try {
                const F = h.getHeaderLength(T);
                if (F > t)
                  return void (this.request = this.fetchHeader(F, s));
                h.parseHeader(T), this._isHeaderLoaded = !0;
                let N = 0;
                for (const G of Object.values(h.layers))
                  N = Math.max(N, G.dataIndex[G.dataIndex.length - 1].last_byte);
                T.byteLength >= N && (this.entireBuffer = T), s(null, this.entireBuffer || T, z, R);
              } catch (F) {
                s(F);
              }
          }), this.request;
        }
        fetchBand(t, s, h) {
          const _ = this._mrt;
          if (!this._isHeaderLoaded || !_)
            return void h(new Error("Tile header is not ready"));
          const y = this.actor;
          if (!y)
            return void h(new Error("Can't fetch tile band without an actor"));
          let T;
          const z = (G, Z) => {
            T.complete(G, Z), G ? h(G) : (this.updateTextureDescriptor(t, s), h(null, this.textureDescriptor && this.textureDescriptor.img));
          }, R = (G, Z) => {
            if (G)
              return h(G);
            const W = y.send("decodeRasterArray", { buffer: Z, task: T }, z, void 0, !0);
            this._workQueue.push(() => {
              W && W.cancel(), T.cancel();
            });
          }, F = _.getLayer(t);
          if (!F)
            return void h(new Error(`Unknown sourceLayer "${t}"`));
          if (F.hasDataForBand(s))
            return this.updateTextureDescriptor(t, s), void h(null, this.textureDescriptor ? this.textureDescriptor.img : null);
          const N = F.getDataRange([s]);
          if (T = _.createDecodingTask(N), !T || T.tasks.length)
            if (this.flushQueues(), this.entireBuffer)
              R(null, this.entireBuffer.slice(N.firstByte, N.lastByte + 1));
            else {
              const G = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${N.firstByte}-${N.lastByte}` } }), Z = i.bi(G, R);
              this._fetchQueue.push(() => {
                Z.cancel(), T.cancel();
              });
            }
          else
            h(null);
        }
        updateNeeded(t, s) {
          return (!this.textureDescriptor || this.textureDescriptor.band !== s || this.textureDescriptor.layer !== t) && this.state !== "errored";
        }
        updateTextureDescriptor(t, s) {
          if (!this._mrt)
            return;
          const h = this._mrt.getLayer(t);
          if (!h || !h.hasBand(s) || !h.hasDataForBand(s))
            return;
          const { bytes: _, tileSize: y, buffer: T, offset: z, scale: R } = h.getBandView(s), F = y + 2 * T, N = { data: _, width: F, height: F }, G = this.texture;
          G && G instanceof i.T && G.update(N, { premultiply: !1 }), this.textureDescriptor = { layer: t, band: s, img: N, buffer: T, offset: z, tileSize: y, format: h.pixelFormat, mix: [R, 256 * R, 65536 * R, 16777216 * R] };
        }
      }
      class la {
        constructor(t, s) {
          this.max = t, this.onRemove = s, this.reset();
        }
        reset() {
          for (const t in this.data)
            for (const s of this.data[t])
              s.timeout && clearTimeout(s.timeout), this.onRemove(s.value);
          return this.data = {}, this.order = [], this;
        }
        add(t, s, h) {
          const _ = t.wrapped().key;
          this.data[_] === void 0 && (this.data[_] = []);
          const y = { value: s, timeout: void 0 };
          if (h !== void 0 && (y.timeout = setTimeout(() => {
            this.remove(t, y);
          }, h)), this.data[_].push(y), this.order.push(_), this.order.length > this.max) {
            const T = this._getAndRemoveByKey(this.order[0]);
            T && this.onRemove(T);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const s = this.data[t].shift();
          return s.timeout && clearTimeout(s.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), s.value;
        }
        getByKey(t) {
          const s = this.data[t];
          return s ? s[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, s) {
          if (!this.has(t))
            return this;
          const h = t.wrapped().key, _ = s === void 0 ? 0 : this.data[h].indexOf(s), y = this.data[h][_];
          return this.data[h].splice(_, 1), y.timeout && clearTimeout(y.timeout), this.data[h].length === 0 && delete this.data[h], this.onRemove(y.value), this.order.splice(this.order.indexOf(h), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const s = this._getAndRemoveByKey(this.order[0]);
            s && this.onRemove(s);
          }
          return this;
        }
        filter(t) {
          const s = [];
          for (const h in this.data)
            for (const _ of this.data[h])
              t(_.value) || s.push(_);
          for (const h of s)
            this.remove(h.value.tileID, h);
        }
      }
      class Zo {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t, s, h) {
          const _ = String(s);
          if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][_] = this.stateChanges[t][_] || {}, i.l(this.stateChanges[t][_], h), this.deletedStates[t] === null) {
            this.deletedStates[t] = {};
            for (const y in this.state[t])
              y !== _ && (this.deletedStates[t][y] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][_] === null) {
            this.deletedStates[t][_] = {};
            for (const y in this.state[t][_])
              h[y] || (this.deletedStates[t][_][y] = null);
          } else
            for (const y in h)
              this.deletedStates[t] && this.deletedStates[t][_] && this.deletedStates[t][_][y] === null && delete this.deletedStates[t][_][y];
        }
        removeFeatureState(t, s, h) {
          if (this.deletedStates[t] === null)
            return;
          const _ = String(s);
          if (this.deletedStates[t] = this.deletedStates[t] || {}, h && s !== void 0)
            this.deletedStates[t][_] !== null && (this.deletedStates[t][_] = this.deletedStates[t][_] || {}, this.deletedStates[t][_][h] = null);
          else if (s !== void 0)
            if (this.stateChanges[t] && this.stateChanges[t][_])
              for (h in this.deletedStates[t][_] = {}, this.stateChanges[t][_])
                this.deletedStates[t][_][h] = null;
            else
              this.deletedStates[t][_] = null;
          else
            this.deletedStates[t] = null;
        }
        getState(t, s) {
          const h = this.state[t] || {}, _ = this.stateChanges[t] || {}, y = this.deletedStates[t];
          if (y === null)
            return {};
          if (s !== void 0) {
            const z = String(s), R = i.l({}, h[z], _[z]);
            if (y) {
              const F = y[s];
              if (F === null)
                return {};
              for (const N in F)
                delete R[N];
            }
            return R;
          }
          const T = i.l({}, h, _);
          if (y)
            for (const z in y)
              delete T[z];
          return T;
        }
        initializeTileState(t, s) {
          t.refreshFeatureState(s);
        }
        coalesceChanges(t, s) {
          const h = {};
          for (const _ in this.stateChanges) {
            this.state[_] = this.state[_] || {};
            const y = {};
            for (const T in this.stateChanges[_])
              this.state[_][T] || (this.state[_][T] = {}), i.l(this.state[_][T], this.stateChanges[_][T]), y[T] = this.state[_][T];
            h[_] = y;
          }
          for (const _ in this.deletedStates) {
            this.state[_] = this.state[_] || {};
            const y = {};
            if (this.deletedStates[_] === null)
              for (const T in this.state[_])
                y[T] = {}, this.state[_][T] = {};
            else
              for (const T in this.deletedStates[_]) {
                if (this.deletedStates[_][T] === null)
                  this.state[_][T] = {};
                else if (this.state[_][T])
                  for (const z of Object.keys(this.deletedStates[_][T]))
                    delete this.state[_][T][z];
                y[T] = this.state[_][T];
              }
            h[_] = h[_] || {}, i.l(h[_], y);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(h).length !== 0)
            for (const _ in t)
              t[_].refreshFeatureState(s);
        }
      }
      class sr extends i.E {
        constructor(t, s, h) {
          super(), this.id = t, this._onlySymbols = h, s.on("data", (_) => {
            _.dataType === "source" && _.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && _.dataType === "source" && _.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
          }), s.on("error", () => {
            this._sourceErrored = !0;
          }), this._source = s, this._tiles = {}, this._cache = new la(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = s.minTileCacheSize, this._maxTileCacheSize = s.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Zo(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster";
        }
        onAdd(t) {
          this.map = t, this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (const t in this._tiles) {
            const s = this._tiles[t];
            if (s.state !== "loaded" && s.state !== "errored")
              return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused)
            return;
          const t = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t, s) {
          return t.isSymbolTile = this._onlySymbols, t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key], this._source.loadTile(t, s);
        }
        _unloadTile(t) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t);
        }
        _abortTile(t) {
          if (this._source.abortTile)
            return this._source.abortTile(t);
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const s in this._tiles) {
            const h = this._tiles[s];
            h.upload(t), h.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return i.bj(this._tiles).map((t) => t.tileID).sort(ca).map((t) => t.key);
        }
        getRenderableIds(t, s) {
          const h = [];
          for (const _ in this._tiles)
            this._isIdRenderable(+_, t, s) && h.push(this._tiles[_]);
          return t ? h.sort((_, y) => {
            const T = _.tileID, z = y.tileID, R = new i.P(T.canonical.x, T.canonical.y)._rotate(this.transform.angle), F = new i.P(z.canonical.x, z.canonical.y)._rotate(this.transform.angle);
            return T.overscaledZ - z.overscaledZ || F.y - R.y || F.x - R.x;
          }).map((_) => _.tileID.key) : h.map((_) => _.tileID).sort(ca).map((_) => _.key);
        }
        hasRenderableParent(t) {
          const s = this.findLoadedParent(t, 0);
          return !!s && this._isIdRenderable(s.tileID.key);
        }
        _isIdRenderable(t, s, h) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (s || !this._tiles[t].holdingForFade()) && (h || !this._shadowCasterTiles[t]);
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles)
              this._tiles[t].state !== "errored" && this._reloadTile(+t, "reloading");
          }
        }
        _reloadTile(t, s) {
          const h = this._tiles[t];
          h && (h.state !== "loading" && (h.state = s), this._loadTile(h, this._tileLoaded.bind(this, h, t, s)));
        }
        _tileLoaded(t, s, h, _) {
          if (_)
            if (t.state = "errored", _.status !== 404)
              this._source.fire(new i.y(_, { tile: t }));
            else {
              if (this._source.fire(new i.z("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t })), !(t.tileID.key in this._loadedParentTiles))
                return;
              if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                const y = this.map.painter.terrain;
                this.update(this.transform, y.getScaledDemTileSize(), !0), y.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            }
          else
            t.timeAdded = i.q.now(), h === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this._source.type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new i.z("data", { dataType: "source", tile: t, coord: t.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t) {
          const s = this.getRenderableIds();
          for (let _ = 0; _ < s.length; _++) {
            const y = s[_];
            if (t.neighboringTiles && t.neighboringTiles[y]) {
              const T = this.getTileByID(y);
              h(t, T), h(T, t);
            }
          }
          function h(_, y) {
            if (!_.dem || _.dem.borderReady)
              return;
            _.needsHillshadePrepare = !0, _.needsDEMTextureUpload = !0;
            let T = y.tileID.canonical.x - _.tileID.canonical.x;
            const z = y.tileID.canonical.y - _.tileID.canonical.y, R = Math.pow(2, _.tileID.canonical.z), F = y.tileID.key;
            T === 0 && z === 0 || Math.abs(z) > 1 || (Math.abs(T) > 1 && (Math.abs(T + R) === 1 ? T += R : Math.abs(T - R) === 1 && (T -= R)), y.dem && _.dem && (_.dem.backfillBorder(y.dem, T, z), _.neighboringTiles && _.neighboringTiles[F] && (_.neighboringTiles[F].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, s, h, _) {
          for (const y in this._tiles) {
            let T = this._tiles[y];
            if (_[y] || !T.hasData() || T.tileID.overscaledZ <= s || T.tileID.overscaledZ > h)
              continue;
            let z = T.tileID;
            for (; T && T.tileID.overscaledZ > s + 1; ) {
              const F = T.tileID.scaledTo(T.tileID.overscaledZ - 1);
              T = this._tiles[F.key], T && T.hasData() && (z = F);
            }
            let R = z;
            for (; R.overscaledZ > s; )
              if (R = R.scaledTo(R.overscaledZ - 1), t[R.key]) {
                _[z.key] = z;
                break;
              }
          }
        }
        findLoadedParent(t, s) {
          if (t.key in this._loadedParentTiles) {
            const h = this._loadedParentTiles[t.key];
            return h && h.tileID.overscaledZ >= s ? h : null;
          }
          for (let h = t.overscaledZ - 1; h >= s; h--) {
            const _ = t.scaledTo(h), y = this._getLoadedTile(_);
            if (y)
              return y;
          }
        }
        _getLoadedTile(t) {
          const s = this._tiles[t.key];
          return s && s.hasData() ? s : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
        }
        updateCacheSize(t, s) {
          s = s || this._source.tileSize;
          const h = Math.ceil(t.width / s) + 1, _ = Math.ceil(t.height / s) + 1, y = Math.floor(h * _ * 5), T = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, y) : y, z = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, T) : T;
          this._cache.setMaxSize(z);
        }
        handleWrapJump(t) {
          const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (this._prevLng = t, s) {
            const h = {};
            for (const _ in this._tiles) {
              const y = this._tiles[_];
              y.tileID = y.tileID.unwrapTo(y.tileID.wrap + s), h[y.tileID.key] = y;
            }
            this._tiles = h;
            for (const _ in this._timers)
              clearTimeout(this._timers[_]), delete this._timers[_];
            for (const _ in this._tiles)
              this._setTileReloadTimer(+_, this._tiles[_]);
          }
        }
        update(t, s, h, _) {
          if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !h)
            return;
          this.updateCacheSize(t, s), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
          const y = this._source.type === "batched-model";
          let T, z = this._source.maxzoom;
          const R = this.map && this.map.painter ? this.map.painter._terrain : null;
          if (R && R.sourceCache === this && R.attenuationRange()) {
            const G = R.attenuationRange()[0], Z = Math.floor(G) - Math.log2(R.getDemUpscale());
            z > Z && (z = Z);
          }
          if (this.used || this.usedForTerrain) {
            if (this._source.tileID)
              T = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((G) => new i.aG(G.canonical.z, G.wrap, G.canonical.z, G.canonical.x, G.canonical.y));
            else if (this.tileCoverLift !== 0) {
              const G = t.clone();
              G.tileCoverLift = this.tileCoverLift, T = G.coveringTiles({ tileSize: s || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: z, roundZoom: this._source.roundZoom && !h, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: y }), this._source.minzoom <= 1 && t.projection.name === "globe" && (T.push(new i.aG(1, 0, 1, 0, 0)), T.push(new i.aG(1, 0, 1, 1, 0)), T.push(new i.aG(1, 0, 1, 0, 1)), T.push(new i.aG(1, 0, 1, 1, 1)));
            } else if (T = t.coveringTiles({ tileSize: s || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: z, roundZoom: this._source.roundZoom && !h, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: y }), this._source.hasTile) {
              const G = this._source.hasTile.bind(this._source);
              T = T.filter((Z) => G(Z));
            }
          } else
            T = [];
          if (T.length > 0 && this.castsShadows && _ && this.transform.projection.name !== "globe" && !this.usedForTerrain && !Ra(this._source.type)) {
            const G = t.coveringZoomLevel({ tileSize: s || this._source.tileSize, roundZoom: this._source.roundZoom && !h }), Z = Math.min(G, this._source.maxzoom);
            if (y) {
              const W = t.extendTileCover(T, Z);
              for (const te of W)
                T.push(te);
            } else {
              const W = t.extendTileCover(T, Z, _);
              for (const te of W)
                this._shadowCasterTiles[te.key] = !0, T.push(te);
            }
          }
          const F = this._updateRetainedTiles(T);
          if (Ra(this._source.type) && T.length !== 0) {
            const G = {}, Z = {}, W = Object.keys(F);
            for (const ee of W) {
              const se = F[ee], oe = this._tiles[ee];
              if (!oe || oe.fadeEndTime && oe.fadeEndTime <= i.q.now())
                continue;
              const he = this.findLoadedParent(se, Math.max(se.overscaledZ - sr.maxOverzooming, this._source.minzoom));
              he && (this._addTile(he.tileID), G[he.tileID.key] = he.tileID), Z[ee] = se;
            }
            const te = T[T.length - 1].overscaledZ;
            for (const ee in this._tiles) {
              const se = this._tiles[ee];
              if (F[ee] || !se.hasData())
                continue;
              let oe = se.tileID;
              for (; oe.overscaledZ > te; ) {
                oe = oe.scaledTo(oe.overscaledZ - 1);
                const he = this._tiles[oe.key];
                if (he && he.hasData() && Z[oe.key]) {
                  F[ee] = se.tileID;
                  break;
                }
              }
            }
            for (const ee in G)
              F[ee] || (this._coveredTiles[ee] = !0, F[ee] = G[ee]);
          }
          for (const G in F)
            this._tiles[G].clearFadeHold();
          const N = i.bk(this._tiles, F);
          for (const G of N) {
            const Z = this._tiles[G];
            Z.hasSymbolBuckets && !Z.holdingForFade() ? Z.setHoldDuration(this.map._fadeDuration) : Z.hasSymbolBuckets && !Z.symbolFadeFinished() || this._removeTile(+G);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles)
            this._tiles[t].holdingForFade() && this._removeTile(+t);
        }
        _updateRetainedTiles(t) {
          const s = {};
          if (t.length === 0)
            return s;
          const h = {}, _ = t.reduce((F, N) => Math.min(F, N.overscaledZ), 1 / 0), y = t[0].overscaledZ, T = Math.max(y - sr.maxOverzooming, this._source.minzoom), z = Math.max(y + sr.maxUnderzooming, this._source.minzoom), R = {};
          for (const F of t) {
            const N = this._addTile(F);
            s[F.key] = F, N.hasData() || _ < this._source.maxzoom && (R[F.key] = F);
          }
          this._retainLoadedChildren(R, _, z, s);
          for (const F of t) {
            let N = this._tiles[F.key];
            if (N.hasData())
              continue;
            if (F.canonical.z >= this._source.maxzoom) {
              const Z = F.children(this._source.maxzoom)[0], W = this.getTile(Z);
              if (W && W.hasData()) {
                s[Z.key] = Z;
                continue;
              }
            } else {
              const Z = F.children(this._source.maxzoom);
              if (s[Z[0].key] && s[Z[1].key] && s[Z[2].key] && s[Z[3].key])
                continue;
            }
            let G = N.wasRequested();
            for (let Z = F.overscaledZ - 1; Z >= T; --Z) {
              const W = F.scaledTo(Z);
              if (h[W.key] || (h[W.key] = !0, N = this.getTile(W), !N && G && (N = this._addTile(W)), N && (s[W.key] = W, G = N.wasRequested(), N.hasData())))
                break;
            }
          }
          return s;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const s = [];
            let h, _ = this._tiles[t].tileID;
            for (; _.overscaledZ > 0; ) {
              if (_.key in this._loadedParentTiles) {
                h = this._loadedParentTiles[_.key];
                break;
              }
              s.push(_.key);
              const y = _.scaledTo(_.overscaledZ - 1);
              if (h = this._getLoadedTile(y), h)
                break;
              _ = y;
            }
            for (const y of s)
              this._loadedParentTiles[y] = h;
          }
        }
        _addTile(t) {
          let s = this._tiles[t.key];
          if (s)
            return s.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"), s;
          s = this._cache.getAndRemove(t), s && (this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, s)));
          const h = !!s;
          if (!h) {
            const _ = this.map ? this.map.painter : null, y = this._source.tileSize * t.overscaleFactor();
            s = this._source.type === "raster-array" ? new ka(t, y, this.transform.tileZoom, _, this._isRaster) : new Cr(t, y, this.transform.tileZoom, _, this._isRaster), this._loadTile(s, this._tileLoaded.bind(this, s, t.key, s.state));
          }
          return s ? (s.uses++, this._tiles[t.key] = s, h || this._source.fire(new i.z("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s) : null;
        }
        _setTileReloadTimer(t, s) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const h = s.getExpiryTimeout();
          h && (this._timers[t] = setTimeout(() => {
            this._reloadTile(t, "expired"), delete this._timers[t];
          }, h));
        }
        _removeTile(t) {
          const s = this._tiles[t];
          s && (s.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), s.uses > 0 || (s.hasData() && s.state !== "reloading" || s.state === "empty" ? this._cache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))));
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const t in this._tiles)
            this._removeTile(+t);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t, s, h) {
          const _ = [], y = this.transform;
          if (!y)
            return _;
          const T = y.projection.name === "globe", z = i.at(y.center.lng);
          for (const R in this._tiles) {
            const F = this._tiles[R];
            if (h && F.clearQueryDebugViz(), F.holdingForFade())
              continue;
            let N;
            if (T) {
              const G = F.tileID.canonical;
              if (G.z === 0) {
                const Z = [Math.abs(i.aw(z, ...ki(G, -1)) - z), Math.abs(i.aw(z, ...ki(G, 1)) - z)];
                N = [0, 2 * Z.indexOf(Math.min(...Z)) - 1];
              } else {
                const Z = [Math.abs(i.aw(z, ...ki(G, -1)) - z), Math.abs(i.aw(z, ...ki(G, 0)) - z), Math.abs(i.aw(z, ...ki(G, 1)) - z)];
                N = [Z.indexOf(Math.min(...Z)) - 1];
              }
            } else
              N = [0];
            for (const G of N) {
              const Z = t.containsTile(F, y, s, G);
              Z && _.push(Z);
            }
          }
          return _;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(!1, !0);
        }
        getVisibleCoordinates(t) {
          return this._getRenderableCoordinates(t);
        }
        _getRenderableCoordinates(t, s) {
          const h = this.getRenderableIds(t, s).map((y) => this._tiles[y].tileID), _ = this.transform.projection.name === "globe";
          for (const y of h)
            y.projMatrix = this.transform.calculateProjMatrix(y.toUnwrapped()), y.expandedProjMatrix = _ ? this.transform.calculateProjMatrix(y.toUnwrapped(), !1, !0) : y.projMatrix;
          return h;
        }
        sortCoordinatesByDistance(t) {
          const s = t.slice(), h = this.transform._camera.position, _ = this.transform._camera.forward(), y = {};
          for (const T of s) {
            const z = 1 / (1 << T.canonical.z);
            y[T.key] = ((T.canonical.x + 0.5) * z + T.wrap - h[0]) * _[0] + ((T.canonical.y + 0.5) * z - h[1]) * _[1] - h[2] * _[2];
          }
          return s.sort((T, z) => y[T.key] - y[z.key]), s;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return !0;
          if (Ra(this._source.type))
            for (const t in this._tiles) {
              const s = this._tiles[t];
              if (s.fadeEndTime !== void 0 && s.fadeEndTime >= i.q.now())
                return !0;
            }
          return !1;
        }
        setFeatureState(t, s, h) {
          this._state.updateState(t = t || "_geojsonTileLayer", s, h);
        }
        removeFeatureState(t, s, h) {
          this._state.removeFeatureState(t = t || "_geojsonTileLayer", s, h);
        }
        getFeatureState(t, s) {
          return this._state.getState(t = t || "_geojsonTileLayer", s);
        }
        setDependencies(t, s, h) {
          const _ = this._tiles[t];
          _ && _.setDependencies(s, h);
        }
        reloadTilesForDependencies(t, s) {
          for (const h in this._tiles)
            this._tiles[h].hasDependency(t, s) && this._reloadTile(+h, "reloading");
          this._cache.filter((h) => !h.hasDependency(t, s));
        }
        _preloadTiles(t, s) {
          if (!this._sourceLoaded) {
            const R = () => {
              this._sourceLoaded && (this._source.off("data", R), this._preloadTiles(t, s));
            };
            return void this._source.on("data", R);
          }
          const h = /* @__PURE__ */ new Map(), _ = Array.isArray(t) ? t : [t], y = this.map.painter.terrain, T = this.usedForTerrain && y ? y.getScaledDemTileSize() : this._source.tileSize;
          for (const R of _) {
            const F = R.coveringTiles({ tileSize: T, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const N of F)
              h.set(N.key, N);
            this.usedForTerrain && R.updateElevation(!1);
          }
          const z = Array.from(h.values());
          i.bl(z, (R, F) => {
            const N = new Cr(R, this._source.tileSize * R.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(N, (G) => {
              this._source.type === "raster-dem" && N.dem && this._backfillDEM(N), F(G, N);
            });
          }, s);
        }
      }
      function ca(c, t) {
        const s = Math.abs(2 * c.wrap) - +(c.wrap < 0), h = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return c.overscaledZ - t.overscaledZ || h - s || t.canonical.y - c.canonical.y || t.canonical.x - c.canonical.x;
      }
      function Ra(c) {
        return c === "raster" || c === "image" || c === "video" || c === "custom";
      }
      function ki(c, t) {
        const s = 1 << c.z;
        return [c.x / s + t, (c.x + 1) / s + t];
      }
      sr.maxOverzooming = 10, sr.maxUnderzooming = 3;
      class Gl {
        constructor(t) {
          this.style = t, this.layersGotHidden = !1, this.layers = [];
        }
        processLayersChanged() {
          this.layers = [];
          const t = !1, s = !1;
          for (const h in this.style._mergedLayers) {
            const _ = this.style._mergedLayers[h];
            if (_.type === "fill-extrusion")
              this.layers.push({ layer: _, visible: t, visibilityChanged: s });
            else if (_.type === "model") {
              const y = this.style.getLayerSource(_);
              y && y.type === "batched-model" && this.layers.push({ layer: _, visible: t, visibilityChanged: s });
            }
          }
        }
        onNewFrame(t) {
          this.layersGotHidden = !1;
          for (const s of this.layers) {
            const h = s.layer;
            let _ = !1;
            h.type === "fill-extrusion" ? _ = !h.isHidden(t) && h.paint.get("fill-extrusion-opacity") > 0 : h.type === "model" && (_ = !h.isHidden(t) && h.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !_ && s.visible, s.visible = _;
          }
        }
        updateZOffset(t, s) {
          this.currentBuildingBuckets = [];
          for (const _ of this.layers) {
            const y = _.layer, T = this.style.getLayerSourceCache(y);
            let z = 1;
            y.type === "fill-extrusion" && (z = _.visible ? y.paint.get("fill-extrusion-vertical-scale") : 0);
            let R = T ? T.getTile(s) : null;
            if (!R && T && s.canonical.z > T.getSource().minzoom) {
              let F = s.scaledTo(Math.min(T.getSource().maxzoom, s.overscaledZ - 1));
              for (; F.overscaledZ >= T.getSource().minzoom && (R = T.getTile(F), !R && F.overscaledZ !== 0); )
                F = F.scaledTo(F.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: R ? R.getBucket(y) : null, tileID: R ? R.tileID : s, verticalScale: z });
          }
          t.hasAnyZOffset = !1;
          let h = !1;
          for (let _ = 0; _ < t.symbolInstances.length; _++) {
            const y = t.symbolInstances.get(_), T = y.zOffset, z = this._getHeightAtTileOffset(s, y.tileAnchorX, y.tileAnchorY);
            y.zOffset = z !== Number.NEGATIVE_INFINITY ? z : T, h || T === y.zOffset || (h = !0), t.hasAnyZOffset || y.zOffset === 0 || (t.hasAnyZOffset = !0);
          }
          h && (t.zOffsetBuffersNeedUpload = !0, t.zOffsetSortDirty = !0);
        }
        _mapCoordToOverlappingTile(t, s, h, _) {
          let y = s, T = h;
          if (t.canonical.z !== _.canonical.z) {
            const z = _.canonical, R = 1 / (1 << t.canonical.z - z.z);
            y = (s + t.canonical.x * i.ag) * R - z.x * i.ag | 0, T = (h + t.canonical.y * i.ag) * R - z.y * i.ag | 0;
          }
          return { tileX: y, tileY: T };
        }
        _getHeightAtTileOffset(t, s, h) {
          let _, y;
          for (let T = 0; T < this.layers.length; ++T) {
            if (this.layers[T].layer.type !== "fill-extrusion")
              continue;
            const { bucket: z, tileID: R, verticalScale: F } = this.currentBuildingBuckets[T];
            if (!z)
              continue;
            const { tileX: N, tileY: G } = this._mapCoordToOverlappingTile(t, s, h, R), Z = z.getHeightAtTileCoord(N, G);
            Z && Z.height !== void 0 && (Z.hidden ? _ = Z.height : y = Math.max(Z.height * F, y || 0));
          }
          if (y !== void 0)
            return y;
          for (let T = 0; T < this.layers.length; ++T) {
            const z = this.layers[T];
            if (z.layer.type !== "model" || !z.visible)
              continue;
            const { bucket: R, tileID: F } = this.currentBuildingBuckets[T];
            if (!R)
              continue;
            const { tileX: N, tileY: G } = this._mapCoordToOverlappingTile(t, s, h, F), Z = R.getHeightAtTileCoord(N, G);
            if (Z && !Z.hidden)
              return Z.height === void 0 && _ !== void 0 ? Math.min(Z.maxHeight, _) * Z.verticalScale : Z.height ? Z.height * Z.verticalScale : Number.NEGATIVE_INFINITY;
          }
          return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
        }
      }
      function ei(c, t) {
        const s = {};
        for (const h in c)
          h !== "ref" && (s[h] = c[h]);
        return i.bm.forEach((h) => {
          h in t && (s[h] = t[h]);
        }), s;
      }
      function ul(c) {
        c = c.slice();
        const t = /* @__PURE__ */ Object.create(null);
        for (let s = 0; s < c.length; s++)
          t[c[s].id] = c[s];
        for (let s = 0; s < c.length; s++)
          "ref" in c[s] && (c[s] = ei(c[s], t[c[s].ref]));
        return c;
      }
      const Oi = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
      function Bi(c, t, s) {
        s.push({ command: Oi.addSource, args: [c, t[c]] });
      }
      function ns(c, t, s) {
        t.push({ command: Oi.removeSource, args: [c] }), s[c] = !0;
      }
      function Cn(c, t, s, h) {
        ns(c, s, h), Bi(c, t, s);
      }
      function ha(c, t, s) {
        let h;
        for (h in c[s])
          if (c[s].hasOwnProperty(h) && h !== "data" && !i.bn(c[s][h], t[s][h]))
            return !1;
        for (h in t[s])
          if (t[s].hasOwnProperty(h) && h !== "data" && !i.bn(c[s][h], t[s][h]))
            return !1;
        return !0;
      }
      function Ot(c, t, s, h, _, y) {
        let T;
        for (T in t = t || {}, c = c || {})
          c.hasOwnProperty(T) && (i.bn(c[T], t[T]) || s.push({ command: y, args: [h, T, t[T], _] }));
        for (T in t)
          t.hasOwnProperty(T) && !c.hasOwnProperty(T) && (i.bn(c[T], t[T]) || s.push({ command: y, args: [h, T, t[T], _] }));
      }
      function Fi(c) {
        return c.id;
      }
      function Li(c, t) {
        return c[t.id] = t, c;
      }
      class ms {
        constructor(t, s) {
          this.reset(t, s);
        }
        reset(t, s) {
          this.points = t || [], this._distances = [0];
          for (let h = 1; h < this.points.length; h++)
            this._distances[h] = this._distances[h - 1] + this.points[h].dist(this.points[h - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t) {
          if (this.points.length === 1)
            return this.points[0];
          t = i.aw(t, 0, 1);
          let s = 1, h = this._distances[s];
          const _ = t * this.paddedLength + this.padding;
          for (; h < _ && s < this._distances.length; )
            h = this._distances[++s];
          const y = s - 1, T = this._distances[y], z = h - T, R = z > 0 ? (_ - T) / z : 0;
          return this.points[y].mult(1 - R).add(this.points[s].mult(R));
        }
      }
      class bo {
        constructor(t, s, h) {
          const _ = this.boxCells = [], y = this.circleCells = [];
          this.xCellCount = Math.ceil(t / h), this.yCellCount = Math.ceil(s / h);
          for (let T = 0; T < this.xCellCount * this.yCellCount; T++)
            _.push([]), y.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, s, h, _, y) {
          this._forEachCell(s, h, _, y, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(h), this.bboxes.push(_), this.bboxes.push(y);
        }
        insertCircle(t, s, h, _) {
          this._forEachCell(s - _, h - _, s + _, h + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(h), this.circles.push(_);
        }
        _insertBoxCell(t, s, h, _, y, T) {
          this.boxCells[y].push(T);
        }
        _insertCircleCell(t, s, h, _, y, T) {
          this.circleCells[y].push(T);
        }
        _query(t, s, h, _, y, T) {
          if (h < 0 || t > this.width || _ < 0 || s > this.height)
            return !y && [];
          const z = [];
          if (t <= 0 && s <= 0 && this.width <= h && this.height <= _) {
            if (y)
              return !0;
            for (let R = 0; R < this.boxKeys.length; R++)
              z.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
            for (let R = 0; R < this.circleKeys.length; R++) {
              const F = this.circles[3 * R], N = this.circles[3 * R + 1], G = this.circles[3 * R + 2];
              z.push({ key: this.circleKeys[R], x1: F - G, y1: N - G, x2: F + G, y2: N + G });
            }
            return T ? z.filter(T) : z;
          }
          return this._forEachCell(t, s, h, _, this._queryCell, z, { hitTest: y, seenUids: { box: {}, circle: {} } }, T), y ? z.length > 0 : z;
        }
        _queryCircle(t, s, h, _, y) {
          const T = t - h, z = t + h, R = s - h, F = s + h;
          if (z < 0 || T > this.width || F < 0 || R > this.height)
            return !_ && [];
          const N = [];
          return this._forEachCell(T, R, z, F, this._queryCellCircle, N, { hitTest: _, circle: { x: t, y: s, radius: h }, seenUids: { box: {}, circle: {} } }, y), _ ? N.length > 0 : N;
        }
        query(t, s, h, _, y) {
          return this._query(t, s, h, _, !1, y);
        }
        hitTest(t, s, h, _, y) {
          return this._query(t, s, h, _, !0, y);
        }
        hitTestCircle(t, s, h, _) {
          return this._queryCircle(t, s, h, !0, _);
        }
        _queryCell(t, s, h, _, y, T, z, R) {
          const F = z.seenUids, N = this.boxCells[y];
          if (N !== null) {
            const Z = this.bboxes;
            for (const W of N)
              if (!F.box[W]) {
                F.box[W] = !0;
                const te = 4 * W;
                if (t <= Z[te + 2] && s <= Z[te + 3] && h >= Z[te + 0] && _ >= Z[te + 1] && (!R || R(this.boxKeys[W]))) {
                  if (z.hitTest)
                    return T.push(!0), !0;
                  T.push({ key: this.boxKeys[W], x1: Z[te], y1: Z[te + 1], x2: Z[te + 2], y2: Z[te + 3] });
                }
              }
          }
          const G = this.circleCells[y];
          if (G !== null) {
            const Z = this.circles;
            for (const W of G)
              if (!F.circle[W]) {
                F.circle[W] = !0;
                const te = 3 * W;
                if (this._circleAndRectCollide(Z[te], Z[te + 1], Z[te + 2], t, s, h, _) && (!R || R(this.circleKeys[W]))) {
                  if (z.hitTest)
                    return T.push(!0), !0;
                  {
                    const ee = Z[te], se = Z[te + 1], oe = Z[te + 2];
                    T.push({ key: this.circleKeys[W], x1: ee - oe, y1: se - oe, x2: ee + oe, y2: se + oe });
                  }
                }
              }
          }
        }
        _queryCellCircle(t, s, h, _, y, T, z, R) {
          const F = z.circle, N = z.seenUids, G = this.boxCells[y];
          if (G !== null) {
            const W = this.bboxes;
            for (const te of G)
              if (!N.box[te]) {
                N.box[te] = !0;
                const ee = 4 * te;
                if (this._circleAndRectCollide(F.x, F.y, F.radius, W[ee + 0], W[ee + 1], W[ee + 2], W[ee + 3]) && (!R || R(this.boxKeys[te])))
                  return T.push(!0), !0;
              }
          }
          const Z = this.circleCells[y];
          if (Z !== null) {
            const W = this.circles;
            for (const te of Z)
              if (!N.circle[te]) {
                N.circle[te] = !0;
                const ee = 3 * te;
                if (this._circlesCollide(W[ee], W[ee + 1], W[ee + 2], F.x, F.y, F.radius) && (!R || R(this.circleKeys[te])))
                  return T.push(!0), !0;
              }
          }
        }
        _forEachCell(t, s, h, _, y, T, z, R) {
          const F = this._convertToXCellCoord(t), N = this._convertToYCellCoord(s), G = this._convertToXCellCoord(h), Z = this._convertToYCellCoord(_);
          for (let W = F; W <= G; W++)
            for (let te = N; te <= Z; te++)
              if (y.call(this, t, s, h, _, this.xCellCount * te + W, T, z, R))
                return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, s, h, _, y, T) {
          const z = _ - t, R = y - s, F = h + T;
          return F * F > z * z + R * R;
        }
        _circleAndRectCollide(t, s, h, _, y, T, z) {
          const R = (T - _) / 2, F = Math.abs(t - (_ + R));
          if (F > R + h)
            return !1;
          const N = (z - y) / 2, G = Math.abs(s - (y + N));
          if (G > N + h)
            return !1;
          if (F <= R || G <= N)
            return !0;
          const Z = F - R, W = G - N;
          return Z * Z + W * W <= h * h;
        }
      }
      const Ai = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, _s = Math.tan(85 * Math.PI / 180);
      function Js(c, t, s, h, _, y, T) {
        const z = i.ab.mat4.create();
        if (s)
          if (y.name === "globe") {
            const R = i.bo(_, t);
            i.ab.mat4.multiply(z, z, R);
          } else {
            const R = i.ab.mat2.invert([], T);
            z[0] = R[0], z[1] = R[1], z[4] = R[2], z[5] = R[3], h || i.ab.mat4.rotateZ(z, z, _.angle);
          }
        else
          i.ab.mat4.multiply(z, _.labelPlaneMatrix, c);
        return z;
      }
      function Ho(c, t, s, h, _, y, T) {
        const z = Js(c, t, s, h, _, y, T);
        return y.name === "globe" && s || (z[2] = z[6] = z[10] = z[14] = 0), z;
      }
      function Ss(c, t, s, h, _, y, T) {
        if (s) {
          if (y.name === "globe") {
            const z = Js(c, t, s, h, _, y, T);
            return i.ab.mat4.invert(z, z), i.ab.mat4.multiply(z, c, z), z;
          }
          {
            const z = i.ab.mat4.clone(c), R = i.ab.mat4.identity([]);
            return R[0] = T[0], R[1] = T[1], R[4] = T[2], R[5] = T[3], i.ab.mat4.multiply(z, z, R), h || i.ab.mat4.rotateZ(z, z, -_.angle), z;
          }
        }
        return _.glCoordMatrix;
      }
      function un(c, t, s, h) {
        const _ = [c, t, s, 1];
        s ? i.ab.vec4.transformMat4(_, _, h) : wo(_, _, h);
        const y = _[3];
        return _[0] /= y, _[1] /= y, _[2] /= y, _;
      }
      function Bc(c, t) {
        return Math.min(0.5 + c / t * 0.5, 1.5);
      }
      function ua(c, t) {
        const s = c[0] / c[3], h = c[1] / c[3];
        return s >= -t[0] && s <= t[0] && h >= -t[1] && h <= t[1];
      }
      function Zl(c, t, s, h, _, y, T, z, R, F) {
        const N = s.transform, G = h ? c.textSizeData : c.iconSizeData, Z = i.bp(G, s.transform.zoom), W = N.projection.name === "globe", te = [256 / s.width * 2 + 1, 256 / s.height * 2 + 1], ee = h ? c.text.dynamicLayoutVertexArray : c.icon.dynamicLayoutVertexArray;
        ee.clear();
        let se = null;
        W && (se = h ? c.text.globeExtVertexArray : c.icon.globeExtVertexArray);
        const oe = c.lineVertexArray, he = h ? c.text.placedSymbolArray : c.icon.placedSymbolArray, _e = s.transform.width / s.transform.height;
        let pe, Me = !1;
        for (let xe = 0; xe < he.length; xe++) {
          const we = he.get(xe), { numGlyphs: ve, writingMode: Pe } = we;
          if (Pe !== i.bq.vertical || Me || pe === i.bq.horizontal || (Me = !0), pe = Pe, (we.hidden || Pe === i.bq.vertical) && !Me) {
            fa(ve, ee);
            continue;
          }
          Me = !1;
          const Oe = new i.P(we.tileAnchorX, we.tileAnchorY);
          let { x: Xe, y: He, z: ke } = N.projection.projectTilePoint(Oe.x, Oe.y, F.canonical);
          if (R) {
            const [nt, Lt, bt] = R(Oe);
            Xe += nt, He += Lt, ke += bt;
          }
          const Ne = [Xe, He, ke, 1];
          if (i.ab.vec4.transformMat4(Ne, Ne, t), !ua(Ne, te)) {
            fa(ve, ee);
            continue;
          }
          const st = Ne[3], ut = Bc(s.transform.getCameraToCenterDistance(N.projection), st), xt = i.br(G, Z, we), Ge = T ? xt / ut : xt * ut, lt = un(Xe, He, ke, _);
          if (lt[3] <= 0) {
            fa(ve, ee);
            continue;
          }
          let Je = {};
          const _t = T ? null : R, ct = dl(we, Ge, !1, z, t, _, y, c.glyphOffsetArray, oe, ee, se, lt, Oe, Je, _e, _t, N.projection, F, T);
          Me = ct.useVertical, _t && ct.needsFlipping && (Je = {}), (ct.notEnoughRoom || Me || ct.needsFlipping && dl(we, Ge, !0, z, t, _, y, c.glyphOffsetArray, oe, ee, se, lt, Oe, Je, _e, _t, N.projection, F, T).notEnoughRoom) && fa(ve, ee);
        }
        h ? (c.text.dynamicLayoutVertexBuffer.updateData(ee), se && c.text.globeExtVertexBuffer && c.text.globeExtVertexBuffer.updateData(se)) : (c.icon.dynamicLayoutVertexBuffer.updateData(ee), se && c.icon.globeExtVertexBuffer && c.icon.globeExtVertexBuffer.updateData(se));
      }
      function da(c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee) {
        const { lineStartIndex: se, glyphStartIndex: oe, segment: he } = z, _e = oe + z.numGlyphs, pe = se + z.lineLength, Me = t.getoffsetX(oe), xe = t.getoffsetX(_e - 1), we = ss(c * Me, s, h, _, y, T, he, se, pe, R, F, N, G, Z, !0, W, te, ee);
        if (!we)
          return null;
        const ve = ss(c * xe, s, h, _, y, T, he, se, pe, R, F, N, G, Z, !0, W, te, ee);
        return ve ? { first: we, last: ve } : null;
      }
      function nn(c, t, s, h) {
        return c === i.bq.horizontal && Math.abs(h) > Math.abs(s) ? { useVertical: !0 } : c === i.bq.vertical ? h > 0 ? { needsFlipping: !0 } : null : t !== Ai.unknown && function(_, y) {
          return _ === 0 || Math.abs(y / _) > _s;
        }(s, h) ? t === Ai.flipRequired ? { needsFlipping: !0 } : null : s < 0 ? { needsFlipping: !0 } : null;
      }
      function dl(c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe, he) {
        const _e = t / 24, pe = c.lineOffsetX * _e, Me = c.lineOffsetY * _e, { lineStartIndex: xe, glyphStartIndex: we, numGlyphs: ve, segment: Pe, writingMode: Oe, flipState: Xe } = c, He = xe + c.lineLength, ke = (Ne) => {
          if (N) {
            const [Ge, lt, Je] = Ne.up, _t = F.length;
            i.bs(N, _t + 0, Ge, lt, Je), i.bs(N, _t + 1, Ge, lt, Je), i.bs(N, _t + 2, Ge, lt, Je), i.bs(N, _t + 3, Ge, lt, Je);
          }
          const [st, ut, xt] = Ne.point;
          i.bt(F, st, ut, xt, Ne.angle);
        };
        if (ve > 1) {
          const Ne = da(_e, z, pe, Me, s, G, Z, c, R, y, W, ee, !1, se, oe, he);
          if (!Ne)
            return { notEnoughRoom: !0 };
          if (h && !s) {
            let [st, ut, xt] = Ne.first.point, [Ge, lt, Je] = Ne.last.point;
            [st, ut] = un(st, ut, xt, T), [Ge, lt] = un(Ge, lt, Je, T);
            const _t = nn(Oe, Xe, (Ge - st) * te, lt - ut);
            if (c.flipState = _t && _t.needsFlipping ? Ai.flipRequired : Ai.flipNotRequired, _t)
              return _t;
          }
          ke(Ne.first);
          for (let st = we + 1; st < we + ve - 1; st++) {
            const ut = ss(_e * z.getoffsetX(st), pe, Me, s, G, Z, Pe, xe, He, R, y, W, ee, !1, !1, se, oe, he);
            if (!ut)
              return F.length -= 4 * (st - we), { notEnoughRoom: !0 };
            ke(ut);
          }
          ke(Ne.last);
        } else {
          if (h && !s) {
            const st = un(Z.x, Z.y, 0, _), ut = xe + Pe + 1, xt = new i.P(R.getx(ut), R.gety(ut)), Ge = un(xt.x, xt.y, 0, _), lt = Ge[3] > 0 ? Ge : rr(Z, xt, st, 1, _, void 0, se, oe.canonical), Je = nn(Oe, Xe, (lt[0] - st[0]) * te, lt[1] - st[1]);
            if (c.flipState = Je && Je.needsFlipping ? Ai.flipRequired : Ai.flipNotRequired, Je)
              return Je;
          }
          const Ne = ss(_e * z.getoffsetX(we), pe, Me, s, G, Z, Pe, xe, He, R, y, W, ee, !1, !1, se, oe, he);
          if (!Ne)
            return { notEnoughRoom: !0 };
          ke(Ne);
        }
        return {};
      }
      function Dn(c, t, s, h, _) {
        const { x: y, y: T, z } = h.projectTilePoint(c.x, c.y, t);
        if (!_)
          return un(y, T, z, s);
        const [R, F, N] = _(c);
        return un(y + R, T + F, z + N, s);
      }
      function rr(c, t, s, h, _, y, T, z) {
        const R = Dn(c.sub(t)._unit()._add(c), z, _, T, y);
        return i.ab.vec3.sub(R, s, R), i.ab.vec3.normalize(R, R), i.ab.vec3.scaleAndAdd(R, s, R, h);
      }
      function ss(c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe) {
        const he = h ? c - t : c + t;
        let _e = he > 0 ? 1 : -1, pe = 0;
        h && (_e *= -1, pe = Math.PI), _e < 0 && (pe += Math.PI);
        let Me = z + T + (_e > 0 ? 0 : 1) | 0, xe = _, we = _, ve = 0, Pe = 0;
        const Oe = Math.abs(he), Xe = [], He = [];
        let ke = y, Ne = ke;
        const st = () => rr(Ne, ke, we, Oe - ve + 1, N, Z, ee, se.canonical);
        for (; ve + Pe <= Oe; ) {
          if (Me += _e, Me < z || Me >= R)
            return null;
          if (we = xe, Ne = ke, Xe.push(we), W && He.push(Ne), ke = new i.P(F.getx(Me), F.gety(Me)), xe = G[Me], !xe) {
            const Lt = Dn(ke, se.canonical, N, ee, Z);
            xe = Lt[3] > 0 ? G[Me] = Lt : st();
          }
          ve += Pe, Pe = i.ab.vec3.distance(we, xe);
        }
        te && Z && (G[Me] && (xe = st(), Pe = i.ab.vec3.distance(we, xe)), G[Me] = xe);
        const ut = (Oe - ve) / Pe, xt = ke.sub(Ne)._mult(ut)._add(Ne), Ge = i.ab.vec3.sub([], xe, we), lt = i.ab.vec3.scaleAndAdd([], we, Ge, ut);
        let Je = [0, 0, 1], _t = Ge[0], ct = Ge[1];
        if (oe && (Je = ee.upVector(se.canonical, xt.x, xt.y), Je[0] !== 0 || Je[1] !== 0 || Je[2] !== 1)) {
          const Lt = [Je[2], 0, -Je[0]], bt = i.ab.vec3.cross([], Je, Lt);
          i.ab.vec3.normalize(Lt, Lt), i.ab.vec3.normalize(bt, bt), _t = i.ab.vec3.dot(Ge, Lt), ct = i.ab.vec3.dot(Ge, bt);
        }
        if (s) {
          const Lt = i.ab.vec3.cross([], Je, Ge);
          i.ab.vec3.normalize(Lt, Lt), i.ab.vec3.scaleAndAdd(lt, lt, Lt, s * _e);
        }
        const nt = pe + Math.atan2(ct, _t);
        return Xe.push(lt), W && He.push(xt), { point: lt, angle: nt, path: Xe, tilePath: He, up: Je };
      }
      function fa(c, t) {
        const s = t.length, h = s + 4 * c;
        t.resize(h), t.float32.fill(-1 / 0, 4 * s, 4 * h);
      }
      function wo(c, t, s) {
        const h = t[0], _ = t[1];
        return c[0] = s[0] * h + s[4] * _ + s[12], c[1] = s[1] * h + s[5] * _ + s[13], c[3] = s[3] * h + s[7] * _ + s[15], c;
      }
      const vn = 100;
      class Ir {
        constructor(t, s, h = new bo(t.width + 200, t.height + 200, 25), _ = new bo(t.width + 200, t.height + 200, 25)) {
          this.transform = t, this.grid = h, this.ignoredGrid = _, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + vn, this.screenBottomBoundary = t.height + vn, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.fogState = s;
        }
        placeCollisionBox(t, s, h, _, y, T, z, R) {
          let F = h.projectedAnchorX, N = h.projectedAnchorY, G = h.projectedAnchorZ;
          const Z = h.elevation, W = h.tileID, te = t.getProjection();
          if (Z && W) {
            const [xe, we, ve] = te.upVector(W.canonical, h.tileAnchorX, h.tileAnchorY), Pe = te.upVectorScale(W.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            F += xe * Z * Pe, N += we * Z * Pe, G += ve * Z * Pe;
          }
          const ee = this.projectAndGetPerspectiveRatio(z, F, N, G, h.tileID, te.name === "globe" || !!Z || this.transform.pitch > 0, te), se = T * ee.perspectiveRatio, oe = (h.x1 * s + _.x - h.padding) * se + ee.point.x, he = (h.y1 * s + _.y - h.padding) * se + ee.point.y, _e = (h.x2 * s + _.x + h.padding) * se + ee.point.x, pe = (h.y2 * s + _.y + h.padding) * se + ee.point.y, Me = ee.perspectiveRatio <= 0.55 || ee.occluded;
          return !this.isInsideGrid(oe, he, _e, pe) || !y && this.grid.hitTest(oe, he, _e, pe, R) || Me ? { box: [], offscreen: !1, occluded: ee.occluded } : { box: [oe, he, _e, pe], offscreen: this.isOffscreen(oe, he, _e, pe), occluded: !1 };
        }
        placeCollisionCircles(t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee) {
          const se = [], oe = this.transform.elevation, he = t.getProjection(), _e = oe ? oe.getAtTileOffsetFunc(ee, this.transform.center.lat, this.transform.worldSize, he) : null, pe = new i.P(h.tileAnchorX, h.tileAnchorY);
          let { x: Me, y: xe, z: we } = he.projectTilePoint(pe.x, pe.y, ee.canonical);
          if (_e) {
            const [xt, Ge, lt] = _e(pe);
            Me += xt, xe += Ge, we += lt;
          }
          const ve = he.name === "globe", Pe = this.projectAndGetPerspectiveRatio(z, Me, xe, we, ee, ve || !!oe || this.transform.pitch > 0, he), { perspectiveRatio: Oe } = Pe, Xe = (G ? T / Oe : T * Oe) / i.bw, He = un(Me, xe, we, R), ke = Pe.signedDistanceFromCamera > 0 ? da(Xe, y, h.lineOffsetX * Xe, h.lineOffsetY * Xe, !1, He, pe, h, _, R, {}, oe && !G ? _e : null, G && !!oe, he, ee, G) : null;
          let Ne = !1, st = !1, ut = !0;
          if (ke && !Pe.occluded) {
            const xt = 0.5 * W * Oe + te, Ge = new i.P(-100, -100), lt = new i.P(this.screenRightBoundary, this.screenBottomBoundary), Je = new ms(), { first: _t, last: ct } = ke, nt = _t.path.length;
            let Lt = [];
            for (let Bt = nt - 1; Bt >= 1; Bt--)
              Lt.push(_t.path[Bt]);
            for (let Bt = 1; Bt < ct.path.length; Bt++)
              Lt.push(ct.path[Bt]);
            const bt = 2.5 * xt;
            F && (Lt = Lt.map(([Bt, oi, $t], Xt) => (_e && !ve && ($t = _e(Xt < nt - 1 ? _t.tilePath[nt - 1 - Xt] : ct.tilePath[Xt - nt + 2])[2]), un(Bt, oi, $t, F))), Lt.some((Bt) => Bt[3] <= 0) && (Lt = []));
            let zt = [];
            if (Lt.length > 0) {
              let Bt = 1 / 0, oi = -1 / 0, $t = 1 / 0, Xt = -1 / 0;
              for (const ai of Lt)
                Bt = Math.min(Bt, ai[0]), $t = Math.min($t, ai[1]), oi = Math.max(oi, ai[0]), Xt = Math.max(Xt, ai[1]);
              oi >= Ge.x && Bt <= lt.x && Xt >= Ge.y && $t <= lt.y && (zt = [Lt.map((ai) => new i.P(ai[0], ai[1]))], (Bt < Ge.x || oi > lt.x || $t < Ge.y || Xt > lt.y) && (zt = i.bu(zt, Ge.x, Ge.y, lt.x, lt.y)));
            }
            for (const Bt of zt) {
              Je.reset(Bt, 0.25 * xt);
              let oi = 0;
              oi = Je.length <= 0.5 * xt ? 1 : Math.ceil(Je.paddedLength / bt) + 1;
              for (let $t = 0; $t < oi; $t++) {
                const Xt = $t / Math.max(oi - 1, 1), ai = Je.lerp(Xt), zi = ai.x + vn, wi = ai.y + vn;
                se.push(zi, wi, xt, 0);
                const mn = zi - xt, Mn = wi - xt, Xi = zi + xt, sn = wi + xt;
                if (ut = ut && this.isOffscreen(mn, Mn, Xi, sn), st = st || this.isInsideGrid(mn, Mn, Xi, sn), !s && this.grid.hitTestCircle(zi, wi, xt, Z) && (Ne = !0, !N))
                  return { circles: [], offscreen: !1, collisionDetected: Ne, occluded: !1 };
              }
            }
          }
          return { circles: !N && Ne || !st ? [] : se, offscreen: ut, collisionDetected: Ne, occluded: Pe.occluded };
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const s = [];
          let h = 1 / 0, _ = 1 / 0, y = -1 / 0, T = -1 / 0;
          for (const N of t) {
            const G = new i.P(N.x + vn, N.y + vn);
            h = Math.min(h, G.x), _ = Math.min(_, G.y), y = Math.max(y, G.x), T = Math.max(T, G.y), s.push(G);
          }
          const z = this.grid.query(h, _, y, T).concat(this.ignoredGrid.query(h, _, y, T)), R = {}, F = {};
          for (const N of z) {
            const G = N.key;
            if (R[G.bucketInstanceId] === void 0 && (R[G.bucketInstanceId] = {}), R[G.bucketInstanceId][G.featureIndex])
              continue;
            const Z = [new i.P(N.x1, N.y1), new i.P(N.x2, N.y1), new i.P(N.x2, N.y2), new i.P(N.x1, N.y2)];
            i.bv(s, Z) && (R[G.bucketInstanceId][G.featureIndex] = !0, F[G.bucketInstanceId] === void 0 && (F[G.bucketInstanceId] = []), F[G.bucketInstanceId].push(G.featureIndex));
          }
          return F;
        }
        insertCollisionBox(t, s, h, _, y) {
          (s ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: h, featureIndex: _, collisionGroupID: y }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, s, h, _, y) {
          const T = s ? this.ignoredGrid : this.grid, z = { bucketInstanceId: h, featureIndex: _, collisionGroupID: y };
          for (let R = 0; R < t.length; R += 4)
            T.insertCircle(z, t[R], t[R + 1], t[R + 2]);
        }
        projectAndGetPerspectiveRatio(t, s, h, _, y, T, z) {
          const R = [s, h, _, 1];
          let F = !1;
          _ || this.transform.pitch > 0 ? (i.ab.vec4.transformMat4(R, R, t), this.fogState && y && z.name !== "globe" && (F = function(Z, W, te, ee, se, oe) {
            const he = oe.calculateFogTileMatrix(se), _e = [W, te, ee];
            return i.ab.vec3.transformMat4(_e, _e, he), Kt(Z, i.ab.vec3.length(_e), oe.pitch, oe._fov);
          }(this.fogState, s, h, _, y.toUnwrapped(), this.transform) > 0.9)) : wo(R, R, t);
          const N = R[3];
          return { point: new i.P((R[0] / N + 1) / 2 * this.transform.width + vn, (-R[1] / N + 1) / 2 * this.transform.height + vn), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(z) / N * 0.5, 1.5), signedDistanceFromCamera: N, occluded: T && R[2] > N || F };
        }
        isOffscreen(t, s, h, _) {
          return h < vn || t >= this.screenRightBoundary || _ < vn || s > this.screenBottomBoundary;
        }
        isInsideGrid(t, s, h, _) {
          return h >= 0 && t < this.gridRightBoundary && _ >= 0 && s < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = i.ab.mat4.identity([]);
          return i.ab.mat4.translate(t, t, [-100, -100, 0]), t;
        }
      }
      function Lr(c, t, s) {
        const h = t.createTileMatrix(c, c.worldSize, s.toUnwrapped());
        return i.ab.mat4.multiply(new Float32Array(16), c.projMatrix, h);
      }
      function qn(c, t, s) {
        if (t.projection.name === s.projection.name)
          return c.projMatrix;
        const h = s.clone();
        return h.setProjection(t.projection), Lr(h, t.getProjection(), c);
      }
      function pa(c, t, s) {
        return t.name === s.projection.name ? c.projMatrix : Lr(s, t, c);
      }
      class zr {
        constructor(t, s, h, _) {
          this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : _ && h ? 1 : 0, this.placed = h;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Es {
        constructor(t, s, h, _, y, T = !1) {
          this.text = new zr(t ? t.text : null, s, h, y), this.icon = new zr(t ? t.icon : null, s, _, y), this.clipped = T;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Oa {
        constructor(t, s, h, _ = !1) {
          this.text = t, this.icon = s, this.skipFade = h, this.clipped = _;
        }
      }
      class qo {
        constructor() {
          this.invProjMatrix = i.ab.mat4.create(), this.viewportMatrix = i.ab.mat4.create(), this.circles = [];
        }
      }
      class Wo {
        constructor(t, s, h, _, y) {
          this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = h, this.bucketIndex = _, this.tileID = y;
        }
      }
      class so {
        constructor(t) {
          this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const s = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: s, predicate: (h) => h.collisionGroupID === s };
          }
          return this.collisionGroups[t];
        }
      }
      function Nc(c, t, s, h, _) {
        const { horizontalAlign: y, verticalAlign: T } = i.bD(c), z = -(y - 0.5) * t, R = -(T - 0.5) * s, F = i.bC(c, h);
        return new i.P(z + F[0] * _, R + F[1] * _);
      }
      function Fa(c, t, s, h, _) {
        const y = new i.P(c, t);
        return s && y._rotate(h ? _ : -_), y;
      }
      class or {
        constructor(t, s, h, _, y, T) {
          this.transform = t.clone(), this.projection = t.projection.name, this.collisionIndex = new Ir(this.transform, y), this.buildingIndex = T, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new so(h), this.collisionCircleArrays = {}, this.prevPlacement = _, _ && (_.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t, s, h, _, y = 1) {
          const T = h.getBucket(s), z = h.latestFeatureIndex;
          if (!T || !z || s.fqid !== T.layerIds[0])
            return;
          const R = T.layers[0].layout, F = T.layers[0].paint, N = h.collisionBoxArray, G = Math.pow(2, this.transform.zoom - h.tileID.overscaledZ), Z = h.tileSize / i.ag, W = h.tileID.toUnwrapped();
          this.transform.setProjection(T.projection);
          const te = (ee = h.tileID, se = T.getProjection(), oe = this.transform, se.name === this.projection ? oe.calculateProjMatrix(ee.toUnwrapped()) : Lr(oe, se, ee));
          var ee, se, oe;
          const he = R.get("text-pitch-alignment") === "map", _e = R.get("text-rotation-alignment") === "map";
          s.compileFilter(s.options);
          const pe = s.dynamicFilter(), Me = s.dynamicFilterNeedsFeature(), xe = this.transform.calculatePixelsToTileUnitsMatrix(h), we = Ho(te, h.tileID.canonical, he, _e, this.transform, T.getProjection(), xe);
          let ve = null;
          if (he) {
            const xt = Ss(te, h.tileID.canonical, he, _e, this.transform, T.getProjection(), xe);
            ve = i.ab.mat4.multiply([], this.transform.labelPlaneMatrix, xt);
          }
          let Pe = null;
          pe && h.latestFeatureIndex && (Pe = { unwrappedTileID: W, dynamicFilter: pe, dynamicFilterNeedsFeature: Me }), this.retainedQueryData[T.bucketInstanceId] = new Wo(T.bucketInstanceId, z, T.sourceLayerIndex, T.index, h.tileID);
          const [Oe, Xe] = T.layers[0].layout.get("text-size-scale-range"), He = i.aw(y, Oe, Xe), [ke, Ne] = R.get("icon-size-scale-range"), st = i.aw(y, ke, Ne), ut = { bucket: T, layout: R, paint: F, posMatrix: te, textLabelPlaneMatrix: we, labelToScreenMatrix: ve, clippingData: Pe, scale: G, textPixelRatio: Z, holdingForFade: h.holdingForFade(), collisionBoxArray: N, partiallyEvaluatedTextSize: i.bp(T.textSizeData, this.transform.zoom, He), partiallyEvaluatedIconSize: i.bp(T.iconSizeData, this.transform.zoom, st), collisionGroup: this.collisionGroups.get(T.sourceID), latestFeatureIndex: h.latestFeatureIndex };
          if (_)
            for (const xt of T.sortKeyRanges) {
              const { sortKey: Ge, symbolInstanceStart: lt, symbolInstanceEnd: Je } = xt;
              t.push({ sortKey: Ge, symbolInstanceStart: lt, symbolInstanceEnd: Je, parameters: ut });
            }
          else
            t.push({ symbolInstanceStart: 0, symbolInstanceEnd: T.symbolInstances.length, parameters: ut });
        }
        attemptAnchorPlacement(t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe, he) {
          const { textOffset0: _e, textOffset1: pe, crossTileID: Me } = Z, xe = [_e, pe], we = Nc(t, h, _, xe, y), ve = this.collisionIndex.placeCollisionBox(te, y, s, Fa(we.x, we.y, T, z, this.transform.angle), G, R, F, N.predicate);
          if (se) {
            const Pe = te.getSymbolInstanceIconSize(he, this.transform.zoom, Z.placedIconSymbolIndex);
            if (this.collisionIndex.placeCollisionBox(te, Pe, se, Fa(we.x, we.y, T, z, this.transform.angle), G, R, F, N.predicate).box.length === 0)
              return;
          }
          if (ve.box.length > 0) {
            let Pe;
            return this.prevPlacement && this.prevPlacement.variableOffsets[Me] && this.prevPlacement.placements[Me] && this.prevPlacement.placements[Me].text && (Pe = this.prevPlacement.variableOffsets[Me].anchor), this.variableOffsets[Me] = { textOffset: xe, width: h, height: _, anchor: t, textScale: y, prevAnchor: Pe }, this.markUsedJustification(te, t, Z, ee), te.allowVerticalPlacement && (this.markUsedOrientation(te, ee, Z), this.placedOrientations[Me] = ee), { shift: we, placedGlyphBoxes: ve };
          }
        }
        placeLayerBucketPart(t, s, h, _, y = 1) {
          const { bucket: T, layout: z, paint: R, posMatrix: F, textLabelPlaneMatrix: N, labelToScreenMatrix: G, clippingData: Z, textPixelRatio: W, holdingForFade: te, collisionBoxArray: ee, partiallyEvaluatedTextSize: se, partiallyEvaluatedIconSize: oe, collisionGroup: he, latestFeatureIndex: _e } = t.parameters, pe = z.get("text-optional"), Me = z.get("icon-optional"), xe = z.get("text-allow-overlap"), we = z.get("icon-allow-overlap"), ve = z.get("text-rotation-alignment") === "map", Pe = z.get("text-pitch-alignment") === "map", Oe = z.get("symbol-z-elevate"), Xe = R.get("symbol-z-offset"), He = z.get("symbol-elevation-reference") === "sea", [ke, Ne] = z.get("text-size-scale-range"), [st, ut] = z.get("icon-size-scale-range"), xt = i.aw(y, ke, Ne), Ge = i.aw(y, st, ut);
          this.transform.setProjection(T.projection);
          let lt = xe && (we || !T.hasIconData() || Me), Je = we && (xe || !T.hasTextData() || pe);
          const _t = !Xe.isConstant();
          !T.collisionArrays && ee && T.deserializeCollisionBoxes(ee), h && _ && T.updateCollisionDebugBuffers(this.transform.zoom, ee, xt, Ge);
          const ct = (nt, Lt, bt) => {
            const { crossTileID: zt, numVerticalGlyphVertices: Bt } = nt;
            let oi = null;
            if (Z && Z.dynamicFilterNeedsFeature || _t) {
              const dn = this.retainedQueryData[T.bucketInstanceId];
              oi = _e.loadFeature({ featureIndex: nt.featureIndex, bucketIndex: dn.bucketIndex, sourceLayerIndex: dn.sourceLayerIndex, layoutVertexArrayOffset: 0 });
            }
            if (Z && !(0, Z.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, oi, this.retainedQueryData[T.bucketInstanceId].tileID.canonical, new i.P(nt.tileAnchorX, nt.tileAnchorY), this.transform.calculateDistanceTileData(Z.unwrappedTileID)))
              return this.placements[zt] = new Oa(!1, !1, !1, !0), void s.add(zt);
            const $t = Xe.evaluate(oi, {});
            if (s.has(zt))
              return;
            if (te)
              return void (this.placements[zt] = new Oa(!1, !1, !1));
            let Xt = !1, ai = !1, zi = !0, wi = !1, mn = !1, Mn = null, Xi = { box: null, offscreen: null, occluded: null }, sn = { box: null, offscreen: null, occluded: null }, _i = null, Jt = null, ji = null, Yi = 0, In = 0, Fs = 0;
            bt.textFeatureIndex ? Yi = bt.textFeatureIndex : nt.useRuntimeCollisionCircles && (Yi = nt.featureIndex), bt.verticalTextFeatureIndex && (In = bt.verticalTextFeatureIndex);
            const pr = (dn) => {
              dn.tileID = this.retainedQueryData[T.bucketInstanceId].tileID;
              const _n = this.transform.elevation;
              dn.elevation = He ? $t : $t + (_n ? _n.getAtTileOffset(dn.tileID, dn.tileAnchorX, dn.tileAnchorY) : 0), dn.elevation += nt.zOffset;
            }, ts = bt.textBox;
            if (ts) {
              pr(ts);
              const dn = (Ri) => {
                let Gn = i.bq.horizontal;
                if (T.allowVerticalPlacement && !Ri && this.prevPlacement) {
                  const Bs = this.prevPlacement.placedOrientations[zt];
                  Bs && (this.placedOrientations[zt] = Bs, Gn = Bs, this.markUsedOrientation(T, Gn, nt));
                }
                return Gn;
              }, _n = (Ri, Gn) => {
                if (T.allowVerticalPlacement && Bt > 0 && bt.verticalTextBox) {
                  for (const Bs of T.writingModes)
                    if (Bs === i.bq.vertical ? (Xi = Gn(), sn = Xi) : Xi = Ri(), Xi && Xi.box && Xi.box.length)
                      break;
                } else
                  Xi = Ri();
              };
              if (z.get("text-variable-anchor")) {
                let Ri = z.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[zt]) {
                  const cn = this.prevPlacement.variableOffsets[zt];
                  Ri.indexOf(cn.anchor) > 0 && (Ri = Ri.filter((er) => er !== cn.anchor), Ri.unshift(cn.anchor));
                }
                const Gn = (cn, er, eo) => {
                  const Br = T.getSymbolInstanceTextSize(se, nt, this.transform.zoom, Lt), Ma = (cn.x2 - cn.x1) * Br + 2 * cn.padding, mr = (cn.y2 - cn.y1) * Br + 2 * cn.padding, ko = nt.hasIconTextFit && !we ? er : null;
                  ko && pr(ko);
                  let Nr = { box: [], offscreen: !1, occluded: !1 };
                  const il = xe ? 2 * Ri.length : Ri.length;
                  for (let ia = 0; ia < il; ++ia) {
                    const Ll = this.attemptAnchorPlacement(Ri[ia % Ri.length], cn, Ma, mr, Br, ve, Pe, W, F, he, ia >= Ri.length, nt, Lt, T, eo, ko, se, oe);
                    if (Ll && (Nr = Ll.placedGlyphBoxes, Nr && Nr.box && Nr.box.length)) {
                      Xt = !0, Mn = Ll.shift;
                      break;
                    }
                  }
                  return Nr;
                };
                _n(() => Gn(ts, bt.iconBox, i.bq.horizontal), () => {
                  const cn = bt.verticalTextBox;
                  return cn && pr(cn), T.allowVerticalPlacement && !(Xi && Xi.box && Xi.box.length) && Bt > 0 && cn ? Gn(cn, bt.verticalIconBox, i.bq.vertical) : { box: null, offscreen: null, occluded: null };
                }), Xi && (Xt = Xi.box, zi = Xi.offscreen, wi = Xi.occluded);
                const Bs = dn(!(!Xi || !Xi.box));
                if (!Xt && this.prevPlacement) {
                  const cn = this.prevPlacement.variableOffsets[zt];
                  cn && (this.variableOffsets[zt] = cn, this.markUsedJustification(T, cn.anchor, nt, Bs));
                }
              } else {
                const Ri = (Gn, Bs) => {
                  const cn = T.getSymbolInstanceTextSize(se, nt, this.transform.zoom, Lt, y), er = this.collisionIndex.placeCollisionBox(T, cn, Gn, new i.P(0, 0), xe, W, F, he.predicate);
                  return er && er.box && er.box.length && (this.markUsedOrientation(T, Bs, nt), this.placedOrientations[zt] = Bs), er;
                };
                _n(() => Ri(ts, i.bq.horizontal), () => {
                  const Gn = bt.verticalTextBox;
                  return T.allowVerticalPlacement && Bt > 0 && Gn ? (pr(Gn), Ri(Gn, i.bq.vertical)) : { box: null, offscreen: null, occluded: null };
                }), dn(!!(Xi && Xi.box && Xi.box.length));
              }
            }
            if (_i = Xi, Xt = _i && _i.box && _i.box.length > 0, zi = _i && _i.offscreen, wi = _i && _i.occluded, nt.useRuntimeCollisionCircles) {
              const dn = T.text.placedSymbolArray.get(nt.centerJustifiedTextSymbolIndex >= 0 ? nt.centerJustifiedTextSymbolIndex : nt.verticalPlacedTextSymbolIndex), _n = i.br(T.textSizeData, se, dn), Ri = z.get("text-padding");
              Jt = this.collisionIndex.placeCollisionCircles(T, xe, dn, T.lineVertexArray, T.glyphOffsetArray, _n, F, N, G, h, Pe, he.predicate, nt.collisionCircleDiameter * _n / i.bw, Ri, this.retainedQueryData[T.bucketInstanceId].tileID), Xt = xe || Jt.circles.length > 0 && !Jt.collisionDetected, zi = zi && Jt.offscreen, wi = Jt.occluded;
            }
            if (bt.iconFeatureIndex && (Fs = bt.iconFeatureIndex), bt.iconBox) {
              const dn = (_n) => {
                pr(_n);
                const Ri = nt.hasIconTextFit && Mn ? Fa(Mn.x, Mn.y, ve, Pe, this.transform.angle) : new i.P(0, 0), Gn = T.getSymbolInstanceIconSize(oe, this.transform.zoom, nt.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(T, Gn, _n, Ri, we, W, F, he.predicate);
              };
              sn && sn.box && sn.box.length && bt.verticalIconBox ? (ji = dn(bt.verticalIconBox), ai = ji.box.length > 0) : (ji = dn(bt.iconBox), ai = ji.box.length > 0), zi = zi && ji.offscreen, mn = ji.occluded;
            }
            const As = pe || nt.numHorizontalGlyphVertices === 0 && Bt === 0, Qs = Me || nt.numIconVertices === 0;
            if (As || Qs ? Qs ? As || (ai = ai && Xt) : Xt = ai && Xt : ai = Xt = ai && Xt, Xt && _i && _i.box && this.collisionIndex.insertCollisionBox(_i.box, z.get("text-ignore-placement"), T.bucketInstanceId, sn && sn.box && In ? In : Yi, he.ID), ai && ji && this.collisionIndex.insertCollisionBox(ji.box, z.get("icon-ignore-placement"), T.bucketInstanceId, Fs, he.ID), Jt && (Xt && this.collisionIndex.insertCollisionCircles(Jt.circles, z.get("text-ignore-placement"), T.bucketInstanceId, Yi, he.ID), h)) {
              const dn = T.bucketInstanceId;
              let _n = this.collisionCircleArrays[dn];
              _n === void 0 && (_n = this.collisionCircleArrays[dn] = new qo());
              for (let Ri = 0; Ri < Jt.circles.length; Ri += 4)
                _n.circles.push(Jt.circles[Ri + 0]), _n.circles.push(Jt.circles[Ri + 1]), _n.circles.push(Jt.circles[Ri + 2]), _n.circles.push(Jt.collisionDetected ? 1 : 0);
            }
            const jn = T.projection.name !== "globe";
            lt = lt && (jn || !wi), Je = Je && (jn || !mn), this.placements[zt] = new Oa(Xt || lt, ai || Je, zi || T.justReloaded), s.add(zt);
          };
          if (Oe && this.buildingIndex && (this.buildingIndex.updateZOffset(T, this.retainedQueryData[T.bucketInstanceId].tileID), T.updateZOffset()), T.sortFeaturesByY) {
            const nt = T.getSortedSymbolIndexes(this.transform.angle);
            for (let Lt = nt.length - 1; Lt >= 0; --Lt) {
              const bt = nt[Lt];
              ct(T.symbolInstances.get(bt), bt, T.collisionArrays[bt]);
            }
            T.hasAnyZOffset && i.w(`${T.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (T.hasAnyZOffset) {
            const nt = T.getSortedIndexesByZOffset();
            for (let Lt = 0; Lt < nt.length; ++Lt) {
              const bt = nt[Lt];
              ct(T.symbolInstances.get(bt), bt, T.collisionArrays[bt]);
            }
          } else
            for (let nt = t.symbolInstanceStart; nt < t.symbolInstanceEnd; nt++)
              ct(T.symbolInstances.get(nt), nt, T.collisionArrays[nt]);
          if (h && T.bucketInstanceId in this.collisionCircleArrays) {
            const nt = this.collisionCircleArrays[T.bucketInstanceId];
            i.ab.mat4.invert(nt.invProjMatrix, F), nt.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          T.justReloaded = !1;
        }
        markUsedJustification(t, s, h, _) {
          const { leftJustifiedTextSymbolIndex: y, centerJustifiedTextSymbolIndex: T, rightJustifiedTextSymbolIndex: z, verticalPlacedTextSymbolIndex: R, crossTileID: F } = h, N = i.bB(s), G = _ === i.bq.vertical ? R : N === "left" ? y : N === "center" ? T : N === "right" ? z : -1;
          y >= 0 && (t.text.placedSymbolArray.get(y).crossTileID = G >= 0 && y !== G ? 0 : F), T >= 0 && (t.text.placedSymbolArray.get(T).crossTileID = G >= 0 && T !== G ? 0 : F), z >= 0 && (t.text.placedSymbolArray.get(z).crossTileID = G >= 0 && z !== G ? 0 : F), R >= 0 && (t.text.placedSymbolArray.get(R).crossTileID = G >= 0 && R !== G ? 0 : F);
        }
        markUsedOrientation(t, s, h) {
          const _ = s === i.bq.horizontal || s === i.bq.horizontalOnly ? s : 0, y = s === i.bq.vertical ? s : 0, { leftJustifiedTextSymbolIndex: T, centerJustifiedTextSymbolIndex: z, rightJustifiedTextSymbolIndex: R, verticalPlacedTextSymbolIndex: F } = h, N = t.text.placedSymbolArray;
          T >= 0 && (N.get(T).placedOrientation = _), z >= 0 && (N.get(z).placedOrientation = _), R >= 0 && (N.get(R).placedOrientation = _), F >= 0 && (N.get(F).placedOrientation = y);
        }
        commit(t) {
          this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const s = this.prevPlacement;
          let h = !1;
          this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
          const _ = s ? s.symbolFadeChange(t) : 1, y = s ? s.opacities : {}, T = s ? s.variableOffsets : {}, z = s ? s.placedOrientations : {};
          for (const R in this.placements) {
            const F = this.placements[R], N = y[R];
            N ? (this.opacities[R] = new Es(N, _, F.text, F.icon, null, F.clipped), h = h || F.text !== N.text.placed || F.icon !== N.icon.placed) : (this.opacities[R] = new Es(null, _, F.text, F.icon, F.skipFade, F.clipped), h = h || F.text || F.icon);
          }
          for (const R in y) {
            const F = y[R];
            if (!this.opacities[R]) {
              const N = new Es(F, _, !1, !1);
              N.isHidden() || (this.opacities[R] = N, h = h || F.text.placed || F.icon.placed);
            }
          }
          for (const R in T)
            this.variableOffsets[R] || !this.opacities[R] || this.opacities[R].isHidden() || (this.variableOffsets[R] = T[R]);
          for (const R in z)
            this.placedOrientations[R] || !this.opacities[R] || this.opacities[R].isHidden() || (this.placedOrientations[R] = z[R]);
          h ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, s, h, _) {
          const y = /* @__PURE__ */ new Set();
          for (const T of s) {
            const z = T.getBucket(t);
            z && T.latestFeatureIndex && t.fqid === z.layerIds[0] && (this.updateBucketOpacities(z, y, T, T.collisionBoxArray, h, _, T.tileID, t.scope), z.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(z, T.tileID), z.updateZOffset()));
          }
        }
        updateBucketOpacities(t, s, h, _, y, T, z, R) {
          t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const F = t.layers[0].layout, N = t.layers[0].paint, G = !!t.layers[0].dynamicFilter(), Z = new Es(null, 0, !1, !1, !0), W = F.get("text-allow-overlap"), te = F.get("icon-allow-overlap"), ee = F.get("text-variable-anchor"), se = F.get("text-rotation-alignment") === "map", oe = F.get("text-pitch-alignment") === "map", he = N.get("symbol-z-offset"), _e = F.get("symbol-elevation-reference") === "sea", pe = !he.isConstant(), Me = new Es(null, 0, W && (te || !t.hasIconData() || F.get("icon-optional")), te && (W || !t.hasTextData() || F.get("text-optional")), !0);
          !t.collisionArrays && _ && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(_);
          const xe = (ve, Pe, Oe) => {
            for (let Xe = 0; Xe < Pe / 4; Xe++)
              ve.opacityVertexArray.emplaceBack(Oe);
          };
          let we = 0;
          T && t.updateReplacement(z, T);
          for (let ve = 0; ve < t.symbolInstances.length; ve++) {
            const Pe = t.symbolInstances.get(ve), { numHorizontalGlyphVertices: Oe, numVerticalGlyphVertices: Xe, crossTileID: He, numIconVertices: ke, tileAnchorX: Ne, tileAnchorY: st } = Pe;
            let ut = null;
            const xt = this.retainedQueryData[t.bucketInstanceId];
            pe && Pe && xt && (ut = h.latestFeatureIndex.loadFeature({ featureIndex: Pe.featureIndex, bucketIndex: xt.bucketIndex, sourceLayerIndex: xt.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
            const Ge = he.evaluate(ut, {}), lt = s.has(He);
            let Je = this.opacities[He];
            lt ? Je = Z : Je || (Je = Me, this.opacities[He] = Je), s.add(He);
            const _t = Oe > 0 || Xe > 0, ct = ke > 0, nt = this.placedOrientations[He], Lt = nt === i.bq.vertical, bt = nt === i.bq.horizontal || nt === i.bq.horizontalOnly;
            !_t && !ct || Je.isHidden() || we++;
            let zt = !1;
            if ((_t || ct) && T)
              for (const Bt of t.activeReplacements) {
                if (i.bx(Bt, y, i.by.Symbol, R) || Bt.min.x > Ne || Ne > Bt.max.x || Bt.min.y > st || st > Bt.max.y)
                  continue;
                const oi = i.bz(Ne, st, z.canonical, Bt.footprintTileId.canonical);
                if (zt = i.bA(oi, Bt.footprint), zt)
                  break;
              }
            if (_t) {
              const Bt = zt ? Ds : _l(Je.text);
              xe(t.text, Oe, Lt ? Ds : Bt), xe(t.text, Xe, bt ? Ds : Bt);
              const oi = Je.text.isHidden(), { leftJustifiedTextSymbolIndex: $t, centerJustifiedTextSymbolIndex: Xt, rightJustifiedTextSymbolIndex: ai, verticalPlacedTextSymbolIndex: zi } = Pe, wi = t.text.placedSymbolArray, mn = oi || Lt ? 1 : 0;
              $t >= 0 && (wi.get($t).hidden = mn), Xt >= 0 && (wi.get(Xt).hidden = mn), ai >= 0 && (wi.get(ai).hidden = mn), zi >= 0 && (wi.get(zi).hidden = oi || bt ? 1 : 0);
              const Mn = this.variableOffsets[He];
              Mn && this.markUsedJustification(t, Mn.anchor, Pe, nt);
              const Xi = this.placedOrientations[He];
              Xi && (this.markUsedJustification(t, "left", Pe, Xi), this.markUsedOrientation(t, Xi, Pe));
            }
            if (ct) {
              const Bt = zt ? Ds : _l(Je.icon), { placedIconSymbolIndex: oi, verticalPlacedIconSymbolIndex: $t } = Pe, Xt = t.icon.placedSymbolArray, ai = Je.icon.isHidden() ? 1 : 0;
              oi >= 0 && (xe(t.icon, ke, Lt ? Ds : Bt), Xt.get(oi).hidden = ai), $t >= 0 && (xe(t.icon, Pe.numVerticalIconVertices, bt ? Ds : Bt), Xt.get($t).hidden = ai);
            }
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const Bt = t.collisionArrays[ve];
              if (Bt) {
                let oi = new i.P(0, 0), $t = !0;
                if (Bt.textBox || Bt.verticalTextBox) {
                  if (ee) {
                    const ai = this.variableOffsets[He];
                    ai ? (oi = Nc(ai.anchor, ai.width, ai.height, ai.textOffset, ai.textScale), se && oi._rotate(oe ? this.transform.angle : -this.transform.angle)) : $t = !1;
                  }
                  G && ($t = !Je.clipped), Bt.textBox && fl(t.textCollisionBox.collisionVertexArray, Je.text.placed, !$t || Lt, Ge, _e, oi.x, oi.y), Bt.verticalTextBox && fl(t.textCollisionBox.collisionVertexArray, Je.text.placed, !$t || bt, Ge, _e, oi.x, oi.y);
                }
                const Xt = $t && !!(!bt && Bt.verticalIconBox);
                Bt.iconBox && fl(t.iconCollisionBox.collisionVertexArray, Je.icon.placed, Xt, Ge, _e, Pe.hasIconTextFit ? oi.x : 0, Pe.hasIconTextFit ? oi.y : 0), Bt.verticalIconBox && fl(t.iconCollisionBox.collisionVertexArray, Je.icon.placed, !Xt, Ge, _e, Pe.hasIconTextFit ? oi.x : 0, Pe.hasIconTextFit ? oi.y : 0);
              }
            }
          }
          if (t.fullyClipped = we === 0, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
            const ve = this.collisionCircleArrays[t.bucketInstanceId];
            t.placementInvProjMatrix = ve.invProjMatrix, t.placementViewportMatrix = ve.viewportMatrix, t.collisionCircleArray = ve.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, s) {
          const h = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
          return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * h > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function fl(c, t, s, h, _, y, T) {
        c.emplaceBack(t ? 1 : 0, s ? 1 : 0, y || 0, T || 0, h, _ ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, y || 0, T || 0, h, _ ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, y || 0, T || 0, h, _ ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, y || 0, T || 0, h, _ ? 1 : 0);
      }
      const pl = Math.pow(2, 25), Nh = Math.pow(2, 24), ml = Math.pow(2, 17), Vc = Math.pow(2, 16), Qu = Math.pow(2, 9), Ba = Math.pow(2, 8), Na = Math.pow(2, 1);
      function _l(c) {
        if (c.opacity === 0 && !c.placed)
          return 0;
        if (c.opacity === 1 && c.placed)
          return 4294967295;
        const t = c.placed ? 1 : 0, s = Math.floor(127 * c.opacity);
        return s * pl + t * Nh + s * ml + t * Vc + s * Qu + t * Ba + s * Na + t;
      }
      const Ds = 0;
      class Vh {
        constructor(t) {
          this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && t.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(t, s, h, _, y, T) {
          const z = this._bucketParts;
          for (; this._currentTileIndex < t.length; )
            if (s.getBucketParts(z, _, t[this._currentTileIndex], this._sortAcrossTiles, T), this._currentTileIndex++, y())
              return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, z.sort((R, F) => R.sortKey - F.sortKey)); this._currentPartIndex < z.length; ) {
            const R = z[this._currentPartIndex];
            if (s.placeLayerBucketPart(R, this._seenCrossTileIDs, h, R.symbolInstanceStart === 0, T), this._currentPartIndex++, y())
              return !0;
          }
          return !1;
        }
      }
      class $o {
        constructor(t, s, h, _, y, T, z, R, F) {
          this.placement = new or(t, y, T, z, R, F), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = _, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, s, h, _, y) {
          const T = i.q.now(), z = () => {
            const R = i.q.now() - T;
            return !this._forceFullPlacement && R > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const R = s[t[this._currentPlacementIndex]], F = this.placement.collisionIndex.transform.zoom;
            if (R.type === "symbol" && (!R.minzoom || R.minzoom <= F) && (!R.maxzoom || R.maxzoom > F)) {
              const N = R, G = N.layout.get("symbol-z-elevate"), Z = N.layout.get("symbol-sort-key").constantOr(1) !== void 0, W = N.layout.get("symbol-z-order"), te = W === "viewport-y" || W === "auto" && !(W !== "viewport-y" && Z), ee = N.layout.get("text-allow-overlap") || N.layout.get("icon-allow-overlap") || N.layout.get("text-ignore-placement") || N.layout.get("icon-ignore-placement"), se = te && ee, oe = this._inProgressLayer = this._inProgressLayer || new Vh(N), he = i.aC(R.source, R.scope);
              if (oe.continuePlacement(G || se ? _[he] : h[he], this.placement, this._showCollisionBoxes, R, z, y))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const rs = 512 / i.ag / 2;
      class Uh {
        constructor(t, s, h) {
          this.tileID = t, this.bucketInstanceId = h, this.index = new i.bE(s.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const _ = t.canonical.x * i.ag, y = t.canonical.y * i.ag;
          for (let T = 0; T < s.length; T++) {
            const { key: z, crossTileID: R, tileAnchorX: F, tileAnchorY: N } = s.get(T), G = Math.floor((_ + F) * rs), Z = Math.floor((y + N) * rs);
            this.index.add(G, Z), this.keys.push(z), this.crossTileIDs.push(R);
          }
          this.index.finish();
        }
        findMatches(t, s, h) {
          const _ = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z), y = rs / Math.pow(2, s.canonical.z - this.tileID.canonical.z), T = s.canonical.x * i.ag, z = s.canonical.y * i.ag;
          for (let R = 0; R < t.length; R++) {
            const F = t.get(R);
            if (F.crossTileID)
              continue;
            const { key: N, tileAnchorX: G, tileAnchorY: Z } = F, W = Math.floor((T + G) * y), te = Math.floor((z + Z) * y), ee = this.index.range(W - _, te - _, W + _, te + _);
            for (const se of ee) {
              const oe = this.crossTileIDs[se];
              if (this.keys[se] === N && !h.has(oe)) {
                h.add(oe), F.crossTileID = oe;
                break;
              }
            }
          }
        }
      }
      class jh {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class ed {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t) {
          const s = Math.round((t - this.lng) / 360);
          if (s !== 0)
            for (const h in this.indexes) {
              const _ = this.indexes[h], y = {};
              for (const T in _) {
                const z = _[T];
                z.tileID = z.tileID.unwrapTo(z.tileID.wrap + s), y[z.tileID.key] = z;
              }
              this.indexes[h] = y;
            }
          this.lng = t;
        }
        addBucket(t, s, h) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId)
              return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let y = 0; y < s.symbolInstances.length; y++)
            s.symbolInstances.get(y).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = /* @__PURE__ */ new Set());
          const _ = this.usedCrossTileIDs[t.overscaledZ];
          for (const y in this.indexes) {
            const T = this.indexes[y];
            if (Number(y) > t.overscaledZ)
              for (const z in T) {
                const R = T[z];
                R.tileID.isChildOf(t) && R.findMatches(s.symbolInstances, t, _);
              }
            else {
              const z = T[t.scaledTo(Number(y)).key];
              z && z.findMatches(s.symbolInstances, t, _);
            }
          }
          for (let y = 0; y < s.symbolInstances.length; y++) {
            const T = s.symbolInstances.get(y);
            T.crossTileID || (T.crossTileID = h.generate(), _.add(T.crossTileID));
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Uh(t, s.symbolInstances, s.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(t, s) {
          for (const h of s.crossTileIDs)
            this.usedCrossTileIDs[t].delete(h);
        }
        removeStaleBuckets(t) {
          let s = !1;
          for (const h in this.indexes) {
            const _ = this.indexes[h];
            for (const y in _)
              t[_[y].bucketInstanceId] || (this.removeBucketCrossTileIDs(h, _[y]), delete _[y], s = !0);
          }
          return s;
        }
      }
      class Hl {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new jh(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t, s, h, _) {
          let y = this.layerIndexes[t.fqid];
          y === void 0 && (y = this.layerIndexes[t.fqid] = new ed());
          let T = !1;
          const z = {};
          _.name !== "globe" && y.handleWrapJump(h);
          for (const R of s) {
            const F = R.getBucket(t);
            F && t.fqid === F.layerIds[0] && (F.bucketInstanceId || (F.bucketInstanceId = ++this.maxBucketInstanceId), y.addBucket(R.tileID, F, this.crossTileIDs) && (T = !0), z[F.bucketInstanceId] = !0);
          }
          return y.removeStaleBuckets(z) && (T = !0), T;
        }
        pruneUnusedLayers(t) {
          const s = {};
          t.forEach((h) => {
            s[h] = !0;
          });
          for (const h in this.layerIndexes)
            s[h] || delete this.layerIndexes[h];
        }
      }
      const Xo = 771;
      class bi {
        constructor(t, s, h, _) {
          this.blendFunction = t, this.blendColor = s, this.mask = h, this.blendEquation = _;
        }
      }
      bi.Replace = [1, 0, 1, 0], bi.disabled = new bi(bi.Replace, i.aj.transparent, [!1, !1, !1, !1]), bi.unblended = new bi(bi.Replace, i.aj.transparent, [!0, !0, !0, !0]), bi.alphaBlended = new bi([1, Xo, 1, Xo], i.aj.transparent, [!0, !0, !0, !0]), bi.alphaBlendedNonPremultiplied = new bi([770, Xo, 770, Xo], i.aj.transparent, [!0, !0, !0, !0]), bi.multiply = new bi([774, 0, 774, 0], i.aj.transparent, [!0, !0, !0, !0]);
      class Wt {
        constructor(t, s, h) {
          this.func = t, this.mask = s, this.range = h;
        }
      }
      Wt.ReadOnly = !1, Wt.ReadWrite = !0, Wt.disabled = new Wt(519, Wt.ReadOnly, [0, 1]);
      const gl = 7680;
      class ci {
        constructor(t, s, h, _, y, T) {
          this.test = t, this.ref = s, this.mask = h, this.fail = _, this.depthFail = y, this.pass = T;
        }
      }
      ci.disabled = new ci({ func: 519, mask: 0 }, 0, 0, gl, gl, gl);
      const ar = 1029, lr = 2305;
      class ti {
        constructor(t, s, h) {
          this.enable = t, this.mode = s, this.frontFace = h;
        }
      }
      function Xr(c, t) {
        const s = i.bG(c, 3);
        i.ab.mat4.fromQuat(c, t), i.bI(c, 3, s);
      }
      function ql(c, t) {
        const s = i.ab.quat.identity([]);
        return i.ab.quat.rotateZ(s, s, -t), i.ab.quat.rotateX(s, s, -c), s;
      }
      function Yr(c, t) {
        const s = [c[0], c[1], 0], h = [t[0], t[1], 0];
        if (i.ab.vec3.length(s) >= 1e-15) {
          const T = i.ab.vec3.normalize([], s);
          i.ab.vec3.scale(h, T, i.ab.vec3.dot(h, T)), t[0] = h[0], t[1] = h[1];
        }
        const _ = i.ab.vec3.cross([], t, c);
        if (i.ab.vec3.len(_) < 1e-15)
          return null;
        const y = Math.atan2(-_[1], _[0]);
        return ql(Math.atan2(Math.sqrt(c[0] * c[0] + c[1] * c[1]), -c[2]), y);
      }
      ti.disabled = new ti(!1, ar, lr), ti.backCCW = new ti(!0, ar, lr), ti.backCW = new ti(!0, ar, 2304), ti.frontCW = new ti(!0, 1028, 2304), ti.frontCCW = new ti(!0, 1028, lr);
      class Va {
        constructor(t, s) {
          this.position = t, this.orientation = s;
        }
        get position() {
          return this._position;
        }
        set position(t) {
          if (t) {
            const s = t instanceof i.aa ? t : new i.aa(t[0], t[1], t[2]);
            this._renderWorldCopies && (s.x = i.bF(s.x, 0, 1)), this._position = s;
          } else
            this._position = null;
        }
        lookAtPoint(t, s) {
          if (this.orientation = null, !this.position)
            return;
          const h = this.position, _ = this._elevation ? this._elevation.getAtPointOrZero(i.aa.fromLngLat(t)) : 0, y = i.aa.fromLngLat(t, _), T = [y.x - h.x, y.y - h.y, y.z - h.z];
          s || (s = [0, 0, 1]), s[2] = Math.abs(s[2]), this.orientation = Yr(T, s);
        }
        setPitchBearing(t, s) {
          this.orientation = ql(i.ai(t), i.ai(-s));
        }
      }
      class To {
        constructor(t, s) {
          this._transform = i.ab.mat4.identity([]), this.orientation = s, this.position = t;
        }
        get mercatorPosition() {
          const t = this.position;
          return new i.aa(t[0], t[1], t[2]);
        }
        get position() {
          const t = i.bG(this._transform, 3);
          return [t[0], t[1], t[2]];
        }
        set position(t) {
          var s;
          t && i.bI(this._transform, 3, [(s = t)[0], s[1], s[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t) {
          this._orientation = t || i.ab.quat.identity([]), t && Xr(this._transform, this._orientation);
        }
        getPitchBearing() {
          const t = this.forward(), s = this.right();
          return { bearing: Math.atan2(-s[1], s[0]), pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]) };
        }
        setPitchBearing(t, s) {
          this._orientation = ql(t, s), Xr(this._transform, this._orientation);
        }
        forward() {
          const t = i.bG(this._transform, 2);
          return [-t[0], -t[1], -t[2]];
        }
        up() {
          const t = i.bG(this._transform, 1);
          return [-t[0], -t[1], -t[2]];
        }
        right() {
          const t = i.bG(this._transform, 0);
          return [t[0], t[1], t[2]];
        }
        getCameraToWorld(t, s) {
          const h = new Float64Array(16);
          return i.ab.mat4.invert(h, this.getWorldToCamera(t, s)), h;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t, s, h) {
          const _ = this.position;
          i.ab.vec3.scale(_, _, -t);
          const y = new Float64Array(16);
          return i.ab.mat4.fromScaling(y, [h, h, h]), i.ab.mat4.translate(y, y, _), y[10] *= s, y;
        }
        getWorldToCamera(t, s) {
          const h = new Float64Array(16), _ = new Float64Array(4), y = this.position;
          return i.ab.quat.conjugate(_, this._orientation), i.ab.vec3.scale(y, y, -t), i.ab.mat4.fromQuat(h, _), i.ab.mat4.translate(h, h, y), h[1] *= -1, h[5] *= -1, h[9] *= -1, h[13] *= -1, h[8] *= s, h[9] *= s, h[10] *= s, h[11] *= s, h;
        }
        getCameraToClipPerspective(t, s, h, _) {
          const y = new Float64Array(16);
          return i.ab.mat4.perspective(y, t, s, h, _), y;
        }
        getCameraToClipOrthographic(t, s, h, _, y, T) {
          const z = new Float64Array(16);
          return i.ab.mat4.ortho(z, t, s, h, _, y, T), z;
        }
        getDistanceToElevation(t, s = !1) {
          const h = t === 0 ? 0 : i.bH(t, s ? i.aS(this.position[1]) : this.position[1]), _ = this.forward();
          return (h - this.position[2]) / _[2];
        }
        clone() {
          return new To([...this.position], [...this.orientation]);
        }
      }
      const bs = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
      class ks {
        constructor(t = 0, s = 0, h = 0, _ = 0) {
          if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(h) || h < 0 || isNaN(_) || _ < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t, this.bottom = s, this.left = h, this.right = _;
        }
        interpolate(t, s, h) {
          return s.top != null && t.top != null && (this.top = i.af(t.top, s.top, h)), s.bottom != null && t.bottom != null && (this.bottom = i.af(t.bottom, s.bottom, h)), s.left != null && t.left != null && (this.left = i.af(t.left, s.left, h)), s.right != null && t.right != null && (this.right = i.af(t.right, s.right, h)), this;
        }
        getCenter(t, s) {
          const h = i.aw((this.left + t - this.right) / 2, 0, t), _ = i.aw((this.top + s - this.bottom) / 2, 0, s);
          return new i.P(h, _);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new ks(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const Wl = (c, t, s) => (1 - s) * c + s * t, Tt = (c) => c * c * c * c * c;
      class ma {
        constructor(t, s, h, _, y, T, z) {
          this.tileSize = 512, this._renderWorldCopies = y === void 0 || y, this._minZoom = t || 0, this._maxZoom = s || 22, this._minPitch = h ?? 0, this._maxPitch = _ ?? 60, this.setProjection(T), this.setMaxBounds(z), this.width = 0, this.height = 0, this._center = new i.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ks(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new To(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = !1;
        }
        clone() {
          const t = new ma(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return t._elevation = this._elevation, t._centerAltitude = this._centerAltitude, t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, t.tileSize = this.tileSize, t.mercatorFromTransition = this.mercatorFromTransition, t.width = this.width, t.height = this.height, t.cameraElevationReference = this.cameraElevationReference, t._center = this._center, t._setZoom(this.zoom), t._seaLevelZoom = this._seaLevelZoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._nearZ = this._nearZ, t._farZ = this._farZ, t._averageElevation = this._averageElevation, t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._camera = this._camera.clone(), t._calcMatrices(), t.freezeTileCoverage = this.freezeTileCoverage, t.frustumCorners = this.frustumCorners, t;
        }
        get isOrthographic() {
          return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          this._elevation !== t && (this._elevation = t, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return this.projection.name !== "globe" && !this.isOrthographic;
        }
        updateElevation(t, s = !1) {
          const h = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || h) && this._updateCameraOnTerrain(), (t || h) && this._constrainCamera(s), this._calcMatrices();
        }
        getProjection() {
          return i.ay(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(t) {
          this.projectionOptions = t || { name: "mercator" };
          const s = this.projection ? this.getProjection() : void 0;
          this.projection = i.bP(this.projectionOptions);
          const h = this.getProjection(), _ = !i.bn(s, h);
          return _ && this._calcMatrices(), this.mercatorFromTransition = !1, _;
        }
        setOrthographicProjectionAtLowPitch(t) {
          return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t, this._calcMatrices(), !0);
        }
        setMercatorFromTransition() {
          const t = this.projection.name;
          this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = i.bP({ name: "mercator" });
          const s = t !== this.projection.name;
          return s && this._calcMatrices(), s;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
        }
        set renderWorldCopies(t) {
          t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get cameraWorldSize() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return i.bH(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new i.P(this.width, this.height);
        }
        get bearing() {
          return i.bF(this.rotation, -180, 180);
        }
        set bearing(t) {
          this.rotation = t;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t) {
          const s = -t * Math.PI / 180;
          this.angle !== s && (this._unmodified = !1, this.angle = s, this._calcMatrices(), this.rotationMatrix = i.ab.mat2.create(), i.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t) {
          const s = i.aw(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== s && (this._unmodified = !1, this._pitch = s, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const t = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / t);
        }
        set fov(t) {
          t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = i.ai(t), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(t) {
          this._averageElevation = t, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const s = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== s && (this._unmodified = !1, this._setZoom(s), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(t) {
          this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom;
        }
        get tileCoverLift() {
          return this._tileCoverLift;
        }
        set tileCoverLift(t) {
          this._tileCoverLift !== t && (this._tileCoverLift = t);
        }
        _updateCameraOnTerrain() {
          const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, s = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!s || !this._centerAltitude))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const h = this._elevation;
          s || this._centerAltitude && this._centerAltitudeValidForExaggeration && h.exaggeration() && this._centerAltitudeValidForExaggeration !== h.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * h.exaggeration(), this._centerAltitudeValidForExaggeration = h.exaggeration()) : (this._centerAltitude = t || 0, this._centerAltitudeValidForExaggeration = h.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t = this._elevation, s = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], h = this.horizonLineFromTop();
          let _ = 0, y = 0;
          for (let T = 0; T < s.length; T++) {
            const z = new i.P(s[T][0] * this.width, h + s[T][1] * (this.height - h)), R = t.pointCoordinate(z);
            if (!R)
              continue;
            const F = 1 / Math.hypot(R[0] - this._camera.position[0], R[1] - this._camera.position[1]);
            _ += R[3] * F, y += F;
          }
          return y === 0 ? NaN : _ / y;
        }
        get center() {
          return this._center;
        }
        set center(t) {
          t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation)
            return;
          const t = this._seaLevelZoom, s = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), h = this.pixelsPerMeter / this.worldSize * s, _ = this._mercatorZfromZoom(t), y = this._mercatorZfromZoom(this._maxZoom), T = Math.max(_ - h, y);
          this._setZoom(this._zoomFromMercatorZ(T));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t) {
          const s = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
          let h;
          h = t.z < this._camera.position[2] ? [s.x, s.y, s.z] : [t.x, t.y, t.z];
          const _ = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, h));
          return i.aw(this._zoomFromMercatorZ(_), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t) {
          if (!this.height || !t.position && !t.orientation)
            return;
          this._updateCameraState();
          let s = !1;
          if (t.orientation && !i.ab.quat.exactEquals(t.orientation, this._camera.orientation) && (s = this._setCameraOrientation(t.orientation)), t.position) {
            const h = [t.position.x, t.position.y, t.position.z];
            i.ab.vec3.exactEquals(h, this._camera.position) || (this._setCameraPosition(h), s = !0);
          }
          s && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t = this._camera.position, s = new Va();
          return s.position = new i.aa(t[0], t[1], t[2]), s.orientation = this._camera.orientation, s._elevation = this.elevation, s._renderWorldCopies = this.renderWorldCopies, s;
        }
        _setCameraOrientation(t) {
          if (!i.ab.quat.length(t))
            return !1;
          i.ab.quat.normalize(t, t);
          const s = i.ab.vec3.transformQuat([], [0, 0, -1], t), h = i.ab.vec3.transformQuat([], [0, -1, 0], t);
          if (h[2] < 0)
            return !1;
          const _ = Yr(s, h);
          return !!_ && (this._camera.orientation = _, !0);
        }
        _setCameraPosition(t) {
          const s = this.zoomScale(this.minZoom) * this.tileSize, h = this.zoomScale(this.maxZoom) * this.tileSize, _ = this.cameraToCenterDistance;
          t[2] = i.aw(t[2], _ / h, _ / s), this._camera.position = t;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, s, h) {
          this._unmodified = !1, this._edgeInsets.interpolate(t, s, h), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const s = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, s);
        }
        getVisibleUnwrappedCoordinates(t) {
          const s = [new i.bQ(0, t)];
          if (this.renderWorldCopies) {
            const h = this.pointCoordinate(new i.P(0, 0)), _ = this.pointCoordinate(new i.P(this.width, 0)), y = this.pointCoordinate(new i.P(this.width, this.height)), T = this.pointCoordinate(new i.P(0, this.height)), z = Math.floor(Math.min(h.x, _.x, y.x, T.x)), R = Math.floor(Math.max(h.x, _.x, y.x, T.x)), F = 1;
            for (let N = z - F; N <= R + F; N++)
              N !== 0 && s.push(new i.bQ(N, t));
          }
          return s;
        }
        isLODDisabled(t) {
          return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCover(t, s, h) {
          let _ = [];
          const y = h !== void 0, T = !y;
          if (T && this.zoom < s || y && h[0] === 0 && h[1] === 0)
            return _;
          const z = /* @__PURE__ */ new Set(), R = (N, G, Z, W, te) => {
            const ee = i.c5(G, N, Z, W, te);
            z.has(ee) || (_.push(new i.aG(N, G, Z, W, te)), z.add(ee));
          };
          for (let N = 0; N < t.length; N++) {
            const G = t[N];
            if (T && G.canonical.z !== s)
              continue;
            const Z = G.canonical, W = G.overscaledZ, te = G.wrap, ee = 1 << Z.z, se = Z.x + 1 < ee, oe = Z.x > 0, he = Z.y + 1 < ee, _e = Z.y > 0, pe = G.wrap - (oe ? 0 : 1), Me = G.wrap + (se ? 0 : 1), xe = oe ? Z.x - 1 : ee - 1, we = se ? Z.x + 1 : 0;
            if (y)
              h[0] < 0 ? (R(W, Me, Z.z, we, Z.y), h[1] < 0 && he && (R(W, te, Z.z, Z.x, Z.y + 1), R(W, Me, Z.z, we, Z.y + 1)), h[1] > 0 && _e && (R(W, te, Z.z, Z.x, Z.y - 1), R(W, Me, Z.z, we, Z.y - 1))) : h[0] > 0 ? (R(W, pe, Z.z, xe, Z.y), h[1] < 0 && he && (R(W, te, Z.z, Z.x, Z.y + 1), R(W, pe, Z.z, xe, Z.y + 1)), h[1] > 0 && _e && (R(W, te, Z.z, Z.x, Z.y - 1), R(W, pe, Z.z, xe, Z.y - 1))) : h[1] < 0 && he ? R(W, te, Z.z, Z.x, Z.y + 1) : _e && R(W, te, Z.z, Z.x, Z.y - 1);
            else {
              const ve = G.visibleQuadrants;
              1 & ve && (R(W, pe, Z.z, xe, Z.y), _e && (R(W, te, Z.z, Z.x, Z.y - 1), R(W, pe, Z.z, xe, Z.y - 1))), 2 & ve && (R(W, Me, Z.z, we, Z.y), _e && (R(W, te, Z.z, Z.x, Z.y - 1), R(W, Me, Z.z, we, Z.y - 1))), 4 & ve && (R(W, pe, Z.z, xe, Z.y), he && (R(W, te, Z.z, Z.x, Z.y + 1), R(W, pe, Z.z, xe, Z.y + 1))), 8 & ve && (R(W, Me, Z.z, we, Z.y), he && (R(W, te, Z.z, Z.x, Z.y + 1), R(W, Me, Z.z, we, Z.y + 1)));
            }
          }
          const F = [];
          for (const N of _)
            _.some((G) => N.isChildOf(G)) || F.push(N);
          if (_ = F.filter((N) => !t.some((G) => !!(N.overscaledZ < s && G.isChildOf(N)) || N.equals(G) || N.isChildOf(G))), T) {
            const N = 1 << s, G = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), Z = [N * G.x, N * G.y], W = 4, te = W * W;
            _ = _.filter((ee) => {
              const se = ee.canonical.x + 0.5 - Z[0], oe = ee.canonical.y + 0.5 - Z[1];
              return se * se + oe * oe < te;
            });
          }
          return _;
        }
        coveringTiles(t) {
          let s = this.coveringZoomLevel(t);
          const h = s, _ = this.elevation && this.elevation.exaggeration(), y = _ && !t.isTerrainDEM, T = this.projection.name === "mercator";
          if (t.minzoom !== void 0 && s < t.minzoom)
            return [];
          t.maxzoom !== void 0 && s > t.maxzoom && (s = t.maxzoom);
          const z = this.locationCoordinate(this.center), R = this.center.lat, F = 1 << s, N = [F * z.x, F * z.y, 0], G = this.projection.name === "globe", Z = !G, W = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, s, Z), te = G ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), ee = F * i.bH(1, this.center.lat), se = this._camera.position[2] / i.bH(1, this.center.lat), oe = [F * te.x, F * te.y, se * (Z ? 1 : ee)], he = G || _, _e = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : 0.502), pe = this.isLODDisabled(!0) ? s : 0;
          let Me;
          if (this._elevation && t.isTerrainDEM)
            Me = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const Ge = this._elevation.getMinMaxForVisibleTiles();
            Me = Ge ? Ge.max : this._centerAltitude;
          } else
            Me = this._centerAltitude;
          const xe = t.isTerrainDEM ? -Me : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, we = this.projection.isReprojectedInTileSpace ? i.bS(this) : 1, ve = (Ge) => {
            const Je = new i.aa(Ge.x + 25e-6, Ge.y, Ge.z), _t = new i.aa(Ge.x, Ge.y + 25e-6, Ge.z), ct = Ge.toLngLat(), nt = Je.toLngLat(), Lt = _t.toLngLat(), bt = this.locationCoordinate(ct), zt = this.locationCoordinate(nt), Bt = this.locationCoordinate(Lt), oi = Math.hypot(zt.x - bt.x, zt.y - bt.y), $t = Math.hypot(Bt.x - bt.x, Bt.y - bt.y);
            return Math.sqrt(oi * $t) * we / 25e-6;
          }, Pe = (Ge) => {
            const lt = Me, Je = xe;
            return { aabb: i.bV(this, F, 0, 0, 0, Ge, Je, lt, this.projection), zoom: 0, x: 0, y: 0, minZ: Je, maxZ: lt, wrap: Ge, fullyVisible: !1 };
          }, Oe = [];
          let Xe = [];
          const He = s, ke = t.reparseOverscaled ? h : s, Ne = (se - this._centerAltitude) * ee, st = (Ge) => {
            if (!this._elevation || !Ge.tileID || !T)
              return;
            const lt = this._elevation.getMinMaxForTile(Ge.tileID), Je = Ge.aabb;
            lt ? (Je.min[2] = lt.min, Je.max[2] = lt.max, Je.center[2] = (Je.min[2] + Je.max[2]) / 2) : (Ge.shouldSplit = xt(Ge), Ge.shouldSplit || (Je.min[2] = Je.max[2] = Je.center[2] = this._centerAltitude));
          }, ut = (Ge, lt) => {
            if (0.707 * lt < Ge)
              return 1;
            const Je = lt / Ge;
            return Je / (1.4144271570014144 + (Math.pow(1.1, Je - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
          }, xt = (Ge) => {
            if (Ge.zoom < pe)
              return !0;
            if (Ge.zoom === He)
              return !1;
            if (Ge.shouldSplit != null)
              return Ge.shouldSplit;
            const lt = Ge.aabb.distanceX(oe), Je = Ge.aabb.distanceY(oe);
            let _t = Ne, ct = 1;
            if (G) {
              _t = Ge.aabb.distanceZ(oe);
              const $t = Math.pow(2, Ge.zoom), Xt = i.aS((Ge.y + 1) / $t), ai = i.aS(Ge.y / $t), zi = Math.min(Math.max(R, Xt), ai), wi = i.c9(zi) / i.c9(R);
              if (ct = zi === R ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, wi / this._mercatorScaleRatio), this.zoom <= i.c6 && Ge.zoom === He - 1 && wi >= 0.9)
                return !0;
            } else if (y && (_t = Ge.aabb.distanceZ(oe) * ee), this.projection.isReprojectedInTileSpace && h <= 5) {
              const $t = Math.pow(2, Ge.zoom), Xt = ve(new i.aa((Ge.x + 0.5) / $t, (Ge.y + 0.5) / $t));
              ct = Xt > 0.85 ? 1 : Xt;
            }
            if (!T) {
              const $t = Math.sqrt(lt * lt + Je * Je + _t * _t);
              let Xt = (1 << He - Ge.zoom) * _e * ct;
              return Xt *= ut(Math.max(_t, Ne), $t), $t < Xt;
            }
            let nt = Number.MAX_VALUE, Lt = 0;
            const bt = Ge.aabb.getCorners(), zt = [];
            for (const $t of bt) {
              i.ab.vec3.sub(zt, $t, oe), G || (y ? zt[2] *= ee : zt[2] = Ne);
              const Xt = i.ab.vec3.dot(zt, this._camera.forward());
              Xt < nt && (nt = Xt, Lt = Math.abs(zt[2]));
            }
            let Bt = (1 << He - Ge.zoom) * _e * ct;
            if (Bt *= ut(Math.max(Lt, Ne), nt), nt < Bt)
              return !0;
            const oi = Ge.aabb.closestPoint(N);
            return oi[0] === N[0] && oi[1] === N[1];
          };
          if (this.renderWorldCopies)
            for (let Ge = 1; Ge <= 3; Ge++)
              Oe.push(Pe(-Ge)), Oe.push(Pe(Ge));
          for (Oe.push(Pe(0)); Oe.length > 0; ) {
            const Ge = Oe.pop(), lt = Ge.x, Je = Ge.y;
            let _t = Ge.fullyVisible;
            const ct = () => this.projection.name === "globe" && (Ge.y === 0 || Ge.y === (1 << Ge.zoom) - 1);
            if (!_t) {
              let nt = he ? Ge.aabb.intersects(W) : Ge.aabb.intersectsFlat(W);
              if (nt === 0 && ct()) {
                const Lt = new i.bT(Ge.zoom, lt, Je);
                nt = i.bU(this, F, Lt, !0).intersects(W);
              }
              if (nt === 0)
                continue;
              _t = nt === 2;
            }
            if (Ge.zoom !== He && xt(Ge))
              for (let nt = 0; nt < 4; nt++) {
                const Lt = (lt << 1) + nt % 2, bt = (Je << 1) + (nt >> 1), zt = { aabb: T ? Ge.aabb.quadrant(nt) : i.bV(this, F, Ge.zoom + 1, Lt, bt, Ge.wrap, Ge.minZ, Ge.maxZ, this.projection), zoom: Ge.zoom + 1, x: Lt, y: bt, wrap: Ge.wrap, fullyVisible: _t, tileID: void 0, shouldSplit: void 0, minZ: Ge.minZ, maxZ: Ge.maxZ };
                y && !G && (zt.tileID = new i.aG(Ge.zoom + 1 === He ? ke : Ge.zoom + 1, Ge.wrap, Ge.zoom + 1, Lt, bt), st(zt)), Oe.push(zt);
              }
            else {
              const nt = Ge.zoom === He ? ke : Ge.zoom;
              if (t.minzoom && t.minzoom > nt)
                continue;
              let Lt = 0;
              if (!_t) {
                let oi = he ? Ge.aabb.intersectsPrecise(W) : Ge.aabb.intersectsPreciseFlat(W);
                if (oi === 0 && ct()) {
                  const $t = new i.bT(Ge.zoom, lt, Je);
                  oi = i.bU(this, F, $t, !0).intersectsPrecise(W);
                }
                if (oi === 0)
                  continue;
                if (t.calculateQuadrantVisibility)
                  if (W.containsPoint(Ge.aabb.center))
                    Lt = 15;
                  else
                    for (let $t = 0; $t < 4; $t++)
                      Ge.aabb.quadrant($t).intersects(W) !== 0 && (Lt |= 1 << $t);
              }
              const bt = N[0] - (0.5 + lt + (Ge.wrap << Ge.zoom)) * (1 << s - Ge.zoom), zt = N[1] - 0.5 - Je, Bt = Ge.tileID ? Ge.tileID : new i.aG(nt, Ge.wrap, Ge.zoom, lt, Je);
              t.calculateQuadrantVisibility && (Bt.visibleQuadrants = Lt), Xe.push({ tileID: Bt, distanceSq: bt * bt + zt * zt });
            }
          }
          if (this.fogCullDistSq) {
            const Ge = this.fogCullDistSq, lt = this.horizonLineFromTop();
            Xe = Xe.filter((Je) => {
              const _t = [0, 0, 0, 1], ct = [i.ag, i.ag, 0, 1], nt = this.calculateFogTileMatrix(Je.tileID.toUnwrapped());
              i.ab.vec4.transformMat4(_t, _t, nt), i.ab.vec4.transformMat4(ct, ct, nt);
              const Lt = i.ab.vec4.min([], _t, ct), bt = i.ab.vec4.max([], _t, ct), zt = i.bW(Lt, bt);
              if (zt === 0)
                return !0;
              let Bt = !1;
              const oi = this._elevation;
              if (oi && zt > Ge && lt !== 0) {
                const $t = this.calculateProjMatrix(Je.tileID.toUnwrapped());
                let Xt;
                t.isTerrainDEM || (Xt = oi.getMinMaxForTile(Je.tileID)), Xt || (Xt = { min: xe, max: Me });
                const ai = i.c7(this.rotation), zi = [ai[0] * i.ag, ai[1] * i.ag, Xt.max];
                i.ab.vec3.transformMat4(zi, zi, $t), Bt = (1 - zi[1]) * this.height * 0.5 < lt;
              }
              return zt < Ge || Bt;
            });
          }
          return Xe.sort((Ge, lt) => Ge.distanceSq - lt.distanceSq).map((Ge) => Ge.tileID);
        }
        resize(t, s) {
          this.width = t, this.height = s, this.pixelsToGLUnits = [2 / t, -2 / s], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const s = i.aw(t.lat, -i.bX, i.bX), h = this.projection.project(t.lng, s);
          return new i.P(h.x * this.worldSize, h.y * this.worldSize);
        }
        unproject(t) {
          return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / i.bH(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t, s) {
          let h, _;
          const y = this.centerPoint;
          if (this.projection.name === "globe") {
            const z = this.worldSize;
            h = (s.x - y.x) / z, _ = (s.y - y.y) / z;
          } else {
            const z = this.pointCoordinate(s), R = this.pointCoordinate(y);
            h = z.x - R.x, _ = z.y - R.y;
          }
          const T = this.locationCoordinate(t);
          this.setLocation(new i.aa(T.x - h, T.y - _));
        }
        setLocation(t) {
          this.center = this.coordinateLocation(t), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(t) {
          return this.projection.locationPoint(this, t);
        }
        locationPoint3D(t) {
          return this.projection.locationPoint(this, t, !0);
        }
        pointLocation(t) {
          return this.coordinateLocation(this.pointCoordinate(t));
        }
        pointLocation3D(t) {
          return this.coordinateLocation(this.pointCoordinate3D(t));
        }
        locationCoordinate(t, s) {
          const h = s ? i.bH(s, t.lat) : void 0, _ = this.projection.project(t.lng, t.lat);
          return new i.aa(_.x, _.y, h);
        }
        coordinateLocation(t) {
          return this.projection.unproject(t.x, t.y);
        }
        pointRayIntersection(t, s) {
          const h = s ?? this._centerAltitude, _ = [t.x, t.y, 0, 1], y = [t.x, t.y, 1, 1];
          i.ab.vec4.transformMat4(_, _, this.pixelMatrixInverse), i.ab.vec4.transformMat4(y, y, this.pixelMatrixInverse);
          const T = y[3];
          i.ab.vec4.scale(_, _, 1 / _[3]), i.ab.vec4.scale(y, y, 1 / T);
          const z = _[2], R = y[2];
          return { p0: _, p1: y, t: z === R ? 0 : (h - z) / (R - z) };
        }
        screenPointToMercatorRay(t) {
          const s = [t.x, t.y, 0, 1], h = [t.x, t.y, 1, 1];
          return i.ab.vec4.transformMat4(s, s, this.pixelMatrixInverse), i.ab.vec4.transformMat4(h, h, this.pixelMatrixInverse), i.ab.vec4.scale(s, s, 1 / s[3]), i.ab.vec4.scale(h, h, 1 / h[3]), s[2] = i.bH(s[2], this._center.lat) * this.worldSize, h[2] = i.bH(h[2], this._center.lat) * this.worldSize, i.ab.vec4.scale(s, s, 1 / this.worldSize), i.ab.vec4.scale(h, h, 1 / this.worldSize), new i.aq([s[0], s[1], s[2]], i.ab.vec3.normalize([], i.ab.vec3.sub([], h, s)));
        }
        rayIntersectionCoordinate(t) {
          const { p0: s, p1: h, t: _ } = t, y = i.bH(s[2], this._center.lat), T = i.bH(h[2], this._center.lat);
          return new i.aa(i.af(s[0], h[0], _) / this.worldSize, i.af(s[1], h[1], _) / this.worldSize, i.af(y, T, _));
        }
        pointCoordinate(t, s = this._centerAltitude) {
          return this.projection.pointCoordinate(this, t.x, t.y, s);
        }
        pointCoordinate3D(t) {
          if (!this.elevation)
            return this.pointCoordinate(t);
          let s = this.projection.pointCoordinate3D(this, t.x, t.y);
          if (s)
            return new i.aa(s[0], s[1], s[2]);
          let h = 0, _ = this.horizonLineFromTop();
          if (t.y > _)
            return this.pointCoordinate(t);
          const y = 0.02 * _, T = t.clone();
          for (let z = 0; z < 10 && _ - h > y; z++) {
            T.y = i.af(h, _, 0.66);
            const R = this.projection.pointCoordinate3D(this, T.x, T.y);
            R ? (_ = T.y, s = R) : h = T.y;
          }
          return s ? new i.aa(s[0], s[1], s[2]) : this.pointCoordinate(t);
        }
        isPointAboveHorizon(t) {
          return this.projection.isPointAboveHorizon(this, t);
        }
        isPointOnSurface(t) {
          if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width)
            return !1;
          if (this.elevation || this.zoom >= i.bY)
            return !this.isPointAboveHorizon(t);
          const s = this.pointCoordinate(t);
          return s.y >= 0 && s.y <= 1;
        }
        _coordinatePoint(t, s) {
          const h = s && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, _ = [t.x * this.worldSize, t.y * this.worldSize, h + t.toAltitude(), 1];
          return i.ab.vec4.transformMat4(_, _, this.pixelMatrix), _[3] > 0 ? new i.P(_[0] / _[3], _[1] / _[3]) : new i.P(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t, left: s } = this._edgeInsets, h = this.height - this._edgeInsets.bottom, _ = this.width - this._edgeInsets.right, y = this.pointLocation3D(new i.P(s, t)), T = this.pointLocation3D(new i.P(_, t)), z = this.pointLocation3D(new i.P(_, h)), R = this.pointLocation3D(new i.P(s, h));
          let F = Math.min(y.lng, T.lng, z.lng, R.lng), N = Math.max(y.lng, T.lng, z.lng, R.lng), G = Math.min(y.lat, T.lat, z.lat, R.lat), Z = Math.max(y.lat, T.lat, z.lat, R.lat);
          const W = Math.pow(2, -this.zoom) / 16 * 270, te = this.projection.name === "globe" ? 1 : 4, ee = (se, oe, he, _e, pe) => {
            const Me = (se + he) / 2, xe = (oe + _e) / 2, we = new i.P(Me, xe), { lng: ve, lat: Pe } = this.pointLocation3D(we), Oe = Math.max(0, F - ve, G - Pe, ve - N, Pe - Z);
            F = Math.min(F, ve), N = Math.max(N, ve), G = Math.min(G, Pe), Z = Math.max(Z, Pe), (pe < te || Oe > W) && (ee(se, oe, Me, xe, pe + 1), ee(Me, xe, he, _e, pe + 1));
          };
          if (ee(s, t, _, t, 1), ee(_, t, _, h, 1), ee(_, h, s, h, 1), ee(s, h, s, t, 1), this.projection.name === "globe") {
            const [se, oe] = i.bZ(this);
            se ? (Z = 90, N = 180, F = -180) : oe && (G = -90, N = 180, F = -180);
          }
          return new i.az(new i.bO(F, G), new i.bO(N, Z));
        }
        _getBoundsRectangular(t, s) {
          const { top: h, left: _ } = this._edgeInsets, y = this.height - this._edgeInsets.bottom, T = this.width - this._edgeInsets.right, z = new i.P(_, h), R = new i.P(T, h), F = new i.P(T, y), N = new i.P(_, y);
          let G = this.pointCoordinate(z, t), Z = this.pointCoordinate(R, t);
          const W = this.pointCoordinate(F, s), te = this.pointCoordinate(N, s), ee = (se, oe) => (oe.y - se.y) / (oe.x - se.x);
          return G.y > 1 && Z.y >= 0 ? G = new i.aa((1 - te.y) / ee(te, G) + te.x, 1) : G.y < 0 && Z.y <= 1 && (G = new i.aa(-te.y / ee(te, G) + te.x, 0)), Z.y > 1 && G.y >= 0 ? Z = new i.aa((1 - W.y) / ee(W, Z) + W.x, 1) : Z.y < 0 && G.y <= 1 && (Z = new i.aa(-W.y / ee(W, Z) + W.x, 0)), new i.az().extend(this.coordinateLocation(G)).extend(this.coordinateLocation(Z)).extend(this.coordinateLocation(te)).extend(this.coordinateLocation(W));
        }
        _getBoundsRectangularTerrain() {
          const t = this.elevation;
          if (!t.visibleDemTiles.length || t.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const s = t.visibleDemTiles.reduce((h, _) => {
            if (_.dem) {
              const y = _.dem.tree;
              h.min = Math.min(h.min, y.minimums[0]), h.max = Math.max(h.max, y.maximums[0]);
            }
            return h;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(s.min * t.exaggeration(), s.max * t.exaggeration());
        }
        getBounds() {
          return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(t = !0) {
          const s = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, h = this.height / 2 - s * (1 - this._horizonShift);
          return t ? Math.max(0, h) : h;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t) {
          this.maxBounds = t, this.minLat = -i.bX, this.maxLat = i.bX, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = i.at(this.minLng) * this.tileSize, this.worldMaxX = i.at(this.maxLng) * this.tileSize, this.worldMinY = i.aA(this.maxLat) * this.tileSize, this.worldMaxY = i.aA(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(t, s) {
          return this.projection.createTileMatrix(this, s, t);
        }
        calculateDistanceTileData(t) {
          const s = t.key, h = this._distanceTileDataCache;
          if (h[s])
            return h[s];
          const _ = t.canonical, y = 1 / this.height, T = this.cameraWorldSize, z = T / this.zoomScale(_.z), R = (_.x + Math.pow(2, _.z) * t.wrap) * z, F = _.y * z, N = this.point;
          N.x *= T / this.worldSize, N.y *= T / this.worldSize;
          const G = this.angle, Z = Math.sin(-G), W = -Math.cos(-G);
          return h[s] = { bearing: [Z, W], center: [(N.x - R) * y, (N.y - F) * y], scale: z / i.ag * y }, h[s];
        }
        calculateFogTileMatrix(t) {
          const s = t.key, h = this._fogTileMatrixCache;
          if (h[s])
            return h[s];
          const _ = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
          return i.ab.mat4.multiply(_, this.worldToFogMatrix, _), h[s] = new Float32Array(_), h[s];
        }
        calculateProjMatrix(t, s = !1, h = !1) {
          const _ = t.key;
          let y;
          if (y = h ? this._expandedProjMatrixCache : s ? this._alignedProjMatrixCache : this._projMatrixCache, y[_])
            return y[_];
          const T = this.calculatePosMatrix(t, this.worldSize);
          let z;
          return z = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : h ? this.expandedFarZProjMatrix : s ? this.alignedProjMatrix : this.projMatrix, i.ab.mat4.multiply(T, z, T), y[_] = new Float32Array(T), y[_];
        }
        calculatePixelsToTileUnitsMatrix(t) {
          const s = t.tileID.key, h = this._pixelsToTileUnitsCache;
          if (h[s])
            return h[s];
          const _ = i.b_(t, this);
          return h[s] = _, h[s];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if (this.projection.name === "globe") {
            const t = 1 / this.worldSize, s = i.ab.mat4.fromScaling([], [t, t, t]);
            return i.ab.mat4.multiply(s, s, this.globeMatrix), s;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === "globe")
            return;
          const t = this._elevation;
          this._updateCameraState();
          const s = i.bH(1, this._center.lat) * this.worldSize, h = this._computeCameraPosition(s), _ = this._camera.forward(), y = i.bH(1, this._center.lat);
          h[2] /= y, _[2] /= y, i.ab.vec3.normalize(_, _);
          const T = t.raycast(h, _, t.exaggeration());
          if (T) {
            const z = i.ab.vec3.scaleAndAdd([], h, _, T), R = new i.aa(z[0], z[1], i.bH(z[2], i.aS(z[1]))), F = (R.z + i.ab.vec3.length([R.x - h[0], R.y - h[1], R.z - h[2] * y])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(F), this._centerAltitude = R.toAltitude(), this._center = this.coordinateLocation(R), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t = !1) {
          if (!this._elevation)
            return;
          const s = this._elevation, h = i.bH(1, this._center.lat) * this.worldSize, _ = this._computeCameraPosition(h), y = s.getAtPointOrZero(new i.aa(..._)), T = this.pixelsPerMeter / this.worldSize * y, z = this._minimumHeightOverTerrain(), R = _[2] - T;
          if (R <= z)
            if (R < 0 || t) {
              const F = this.locationCoordinate(this._center, this._centerAltitude), N = [_[0], _[1], F.z - _[2]], G = i.ab.vec3.length(N);
              N[2] -= (z - R) / this._pixelsPerMercatorPixel;
              const Z = i.ab.vec3.length(N);
              if (Z === 0)
                return;
              i.ab.vec3.scale(N, N, G / Z * this._pixelsPerMercatorPixel), this._camera.position = [_[0], _[1], F.z * this._pixelsPerMercatorPixel - N[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = !0;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = !0;
          const t = this.projection.name === "globe" || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t) {
            const Z = this.center;
            return Z.lat = i.aw(Z.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (Z.lng = i.aw(Z.lng, this.minLng, this.maxLng)), this.center = Z, void (this._constraining = !1);
          }
          const s = this._unmodified, { x: h, y: _ } = this.point;
          let y = 0, T = h, z = _;
          const R = this.width / 2, F = this.height / 2, N = this.worldMinY * this.scale, G = this.worldMaxY * this.scale;
          if (_ - F < N && (z = N + F), _ + F > G && (z = G - F), G - N < this.height && (y = Math.max(y, this.height / (G - N)), z = (G + N) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const Z = this.worldMinX * this.scale, W = this.worldMaxX * this.scale, te = this.worldSize / 2 - (Z + W) / 2;
            T = (h + te + this.worldSize) % this.worldSize - te, T - R < Z && (T = Z + R), T + R > W && (T = W - R), W - Z < this.width && (y = Math.max(y, this.width / (W - Z)), T = (W + Z) / 2);
          }
          T === h && z === _ || (this.center = this.unproject(new i.P(T, z))), y && (this.zoom += this.scaleZoom(y)), this._constrainCamera(), this._unmodified = s, this._constraining = !1;
        }
        _minZoomForBounds() {
          let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t = this.centerOffset, s = this.projection.name === "globe", h = this.pixelsPerMeter;
          this.projection.name === "globe" && (this._mercatorScaleRatio = i.bH(1, this.center.lat) / i.bH(1, i.c8));
          const _ = i.b$(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, _), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const y = this.projection.zAxisUnit === "meters" ? h : 1, T = this._camera.getWorldToCamera(this.worldSize, y);
          let z;
          const R = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (R[8] = 2 * -t.x / this.width, R[9] = 2 * t.y / this.height, this.isOrthographic) {
            let Pe = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), Oe = Pe * this.aspect, Xe = -Oe, He = -Pe;
            Oe -= t.x, Xe -= t.x, Pe += t.y, He += t.y, z = this._camera.getCameraToClipOrthographic(Xe, Oe, He, Pe, this._nearZ, this._farZ), ((ke, Ne, st, ut) => {
              for (let xt = 0; xt < 16; xt++)
                ke[xt] = Wl(Ne[xt], st[xt], ut);
            })(z, z, R, Tt(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else
            z = R;
          const F = i.ab.mat4.mul([], R, T);
          let N = i.ab.mat4.mul([], z, T);
          if (this.projection.isReprojectedInTileSpace) {
            const Pe = this.locationCoordinate(this.center), Oe = i.ab.mat4.identity([]);
            i.ab.mat4.translate(Oe, Oe, [Pe.x * this.worldSize, Pe.y * this.worldSize, 0]), i.ab.mat4.multiply(Oe, Oe, i.c0(this)), i.ab.mat4.translate(Oe, Oe, [-Pe.x * this.worldSize, -Pe.y * this.worldSize, 0]), i.ab.mat4.multiply(N, N, Oe), i.ab.mat4.multiply(F, F, Oe), this.inverseAdjustmentMatrix = i.c1(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = i.ab.mat4.scale([], N, [this.worldSize, this.worldSize, this.worldSize / y, 1]), this.projMatrix = N, this.invProjMatrix = i.ab.mat4.invert(new Float64Array(16), this.projMatrix), s) {
            const Pe = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            Pe[8] = 2 * -t.x / this.width, Pe[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = i.ab.mat4.mul([], Pe, T);
          } else
            this.expandedFarZProjMatrix = this.projMatrix;
          const G = i.ab.mat4.invert([], z);
          this.frustumCorners = i.c2.fromInvProjectionMatrix(G, this.horizonLineFromTop(), this.height), this.cameraFrustum = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !s);
          const Z = new Float32Array(16);
          i.ab.mat4.identity(Z), i.ab.mat4.scale(Z, Z, [1, -1, 1]), i.ab.mat4.rotateX(Z, Z, this._pitch), i.ab.mat4.rotateZ(Z, Z, this.angle);
          const W = i.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = i.ab.mat4.clone(W);
          const te = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          W[8] = 2 * -t.x / this.width, W[9] = 2 * (t.y + te) / this.height, this.skyboxMatrix = i.ab.mat4.multiply(Z, W, Z);
          const ee = this.point, se = ee.x, oe = ee.y, he = this.width % 2 / 2, _e = this.height % 2 / 2, pe = Math.cos(this.angle), Me = Math.sin(this.angle), xe = se - Math.round(se) + pe * he + Me * _e, we = oe - Math.round(oe) + pe * _e + Me * he, ve = new Float64Array(N);
          if (i.ab.mat4.translate(ve, ve, [xe > 0.5 ? xe - 1 : xe, we > 0.5 ? we - 1 : we, 0]), this.alignedProjMatrix = ve, N = i.ab.mat4.create(), i.ab.mat4.scale(N, N, [this.width / 2, -this.height / 2, 1]), i.ab.mat4.translate(N, N, [1, -1, 0]), this.labelPlaneMatrix = N, N = i.ab.mat4.create(), i.ab.mat4.scale(N, N, [1, -1, 1]), i.ab.mat4.translate(N, N, [-1, -1, 0]), i.ab.mat4.scale(N, N, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = N, this.pixelMatrix = i.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, F), this._calcFogMatrices(), this._distanceTileDataCache = {}, N = i.ab.mat4.invert(new Float64Array(16), this.pixelMatrix), !N)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = N, this.projection.name === "globe" || this.mercatorFromTransition) {
            this.globeMatrix = i.c3(this);
            const Pe = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = i.ab.vec3.transformMat4(Pe, Pe, T), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = N;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t = this.cameraWorldSizeForFog, s = this.cameraPixelsPerMeter, h = this._camera.position, _ = 1 / this.height / this._pixelsPerMercatorPixel, y = [t, t, s];
          i.ab.vec3.scale(y, y, _), i.ab.vec3.scale(h, h, -1), i.ab.vec3.multiply(h, h, y);
          const T = i.ab.mat4.create();
          i.ab.mat4.translate(T, T, h), i.ab.mat4.scale(T, T, y), this.mercatorFogMatrix = T, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, s, _);
        }
        _computeCameraPosition(t) {
          const s = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter, h = this._camera.forward(), _ = this.point, y = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * s - t / this.worldSize * this._centerAltitude;
          return [_.x / this.worldSize - h[0] * y, _.y / this.worldSize - h[1] * y, t / this.worldSize * this._centerAltitude - h[2] * y];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t) {
          const s = this._maxCameraBoundsDistance() * Math.cos(this._pitch), h = this._camera.position[2], _ = t[2];
          let y = 1;
          this.projection.wrap && (this.center = this.center.wrap()), _ > 0 && (y = Math.min((s - h) / _, 1)), this._camera.position = i.ab.vec3.scaleAndAdd([], this._camera.position, t, y), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t = this._camera.position, s = this._camera.forward(), { pitch: h, bearing: _ } = this._camera.getPitchBearing(), y = i.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, T = this._mercatorZfromZoom(this._maxZoom) * Math.cos(i.ai(this._maxPitch)), z = Math.max((t[2] - y) / Math.cos(h), T), R = this._zoomFromMercatorZ(z);
          i.ab.vec3.scaleAndAdd(t, t, s, z), this._pitch = i.aw(h, i.ai(this.minPitch), i.ai(this.maxPitch)), this.angle = i.bF(_, -Math.PI, Math.PI), this._setZoom(i.aw(R, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new i.aa(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(t) {
          return Math.pow(2, t) * this.tileSize;
        }
        _mercatorZfromZoom(t) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
        }
        _minimumHeightOverTerrain() {
          const t = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
          return this._mercatorZfromZoom(t);
        }
        _zoomFromMercatorZ(t) {
          return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t) {
          let s = 0, h = i.bY, _ = 0, y = 1 / 0;
          for (; h - s > 1e-6 && h > s; ) {
            const T = s + 0.5 * (h - s), z = this.tileSize * Math.pow(2, T), R = this.getCameraToCenterDistance(this.projection, T, z), F = this.scaleZoom(R / (t * this.tileSize)), N = Math.abs(T - F);
            N < y && (y = N, _ = T), T < F ? s = T : h = T;
          }
          return _;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (i.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t, s) {
          const h = Math.min(t.x, s.x), _ = Math.max(t.x, s.x), y = Math.min(t.y, s.y), T = Math.max(t.y, s.y);
          if (y < this.horizonLineFromTop(!1))
            return !0;
          if (this.projection.name !== "mercator")
            return !1;
          const z = [new i.P(h, y), new i.P(_, T), new i.P(h, T), new i.P(_, y)], R = this.renderWorldCopies ? -3 : 0, F = this.renderWorldCopies ? 4 : 1;
          for (const N of z) {
            const G = this.pointRayIntersection(N);
            if (G.t < 0)
              return !0;
            const Z = this.rayIntersectionCoordinate(G);
            if (Z.x < R || Z.y < 0 || Z.x > F || Z.y > 1)
              return !0;
          }
          return !1;
        }
        isHorizonVisible() {
          return this.pitch + i.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new i.P(0, 0), new i.P(this.width, this.height));
        }
        zoomDeltaToMovement(t, s) {
          const h = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, t)), _ = this._zoomFromMercatorZ(h) + s;
          return h - this._mercatorZfromZoom(_);
        }
        getCameraPoint() {
          if (this.projection.name === "globe") {
            const t = function([s, h, _], y) {
              const T = [s, h, _, 1];
              i.ab.vec4.transformMat4(T, T, y);
              const z = T[3] = Math.max(T[3], 1e-6);
              return T[0] /= z, T[1] /= z, T[2] /= z, T;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new i.P(t[0], t[1]);
          }
          {
            const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new i.P(0, t));
          }
        }
        getCameraToCenterDistance(t, s = this.zoom, h = this.worldSize) {
          const _ = i.b$(t, s, this.width, this.height, 1024), y = t.pixelSpaceConversion(this.center.lat, h, _);
          let T = 0.5 / Math.tan(0.5 * this._fov) * this.height * y;
          return this.isOrthographic && (T = Wl(1, T, Tt(this.pitch >= 15 ? 1 : this.pitch / 15))), T;
        }
        getWorldToCameraMatrix() {
          const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
          return this.projection.name === "globe" && i.ab.mat4.multiply(t, t, this.globeMatrix), t;
        }
        getFrustum(t) {
          return i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === "meters");
        }
      }
      const Mo = (c, t) => {
        if (t > 0 && c.terrain && i.w("Cutoff is currently disabled on terrain"), t <= 0 || c.terrain)
          return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
        const s = c.transform, h = Math.max(Math.abs(s._zoom - (c.minCutoffZoom - 1)), 1), _ = s.isLODDisabled(!1) ? i.ac(60, 45, s.pitch) : i.ac(30, 15, s.pitch), y = s._farZ - s._nearZ, T = t * s.height, z = ((1 - (R = _)) * s.cameraToCenterDistance + R * (s._farZ + T)) * h;
        var R;
        return { shouldRenderCutoff: _ < 1, uniformValues: { u_cutoff_params: [s._nearZ, s._farZ, (z - s._nearZ) / y, (z - T - s._nearZ) / y] } };
      }, gs = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
      class Gh {
        constructor(t, s) {
          this.aabb = t, this.lastCascade = s;
        }
      }
      class Dr {
        add(t, s) {
          const h = this.receivers[t.key];
          h !== void 0 ? (h.aabb.min[0] = Math.min(h.aabb.min[0], s.min[0]), h.aabb.min[1] = Math.min(h.aabb.min[1], s.min[1]), h.aabb.min[2] = Math.min(h.aabb.min[2], s.min[2]), h.aabb.max[0] = Math.max(h.aabb.max[0], s.max[0]), h.aabb.max[1] = Math.max(h.aabb.max[1], s.max[1]), h.aabb.max[2] = Math.max(h.aabb.max[2], s.max[2])) : this.receivers[t.key] = new Gh(s, null);
        }
        clear() {
          this.receivers = {};
        }
        get(t) {
          return this.receivers[t.key];
        }
        computeRequiredCascades(t, s, h) {
          const _ = i.cd.fromPoints(t.points);
          let y = 0;
          for (const T in this.receivers) {
            const z = this.receivers[T];
            if (!z || !_.intersectsAabb(z.aabb))
              continue;
            z.aabb.min = _.closestPoint(z.aabb.min), z.aabb.max = _.closestPoint(z.aabb.max);
            const R = z.aabb.getCorners();
            for (let F = 0; F < h.length; F++) {
              let N = !0;
              for (const G of R) {
                const Z = [G[0] * s, G[1] * s, G[2]];
                if (i.ab.vec3.transformMat4(Z, Z, h[F].matrix), Z[0] < -1 || Z[0] > 1 || Z[1] < -1 || Z[1] > 1) {
                  N = !1;
                  break;
                }
              }
              if (z.lastCascade = F, y = Math.max(y, F), N)
                break;
            }
          }
          return y + 1;
        }
      }
      class So {
        constructor(t) {
          this.painter = t, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new Dr(), this._depthMode = new Wt(t.context.gl.LEQUAL, Wt.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = !1, this.useNormalOffset = !1, t.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
            this.painter.style.map.triggerRepaint();
          }), t.tp.registerParameter(gs, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), t.tp.registerParameter(gs, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), t.tp.registerParameter(gs, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: !0, label: "numCascadesToRender" });
        }
        destroy() {
          for (const t of this._cascades)
            t.texture.destroy(), t.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t, s) {
          const h = this.painter;
          if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !s || !s.properties)
            return;
          const _ = s.properties.get("shadow-intensity");
          if (!s.shadowsEnabled() || _ <= 0 || (this._shadowLayerCount = h.style.order.reduce((te, ee) => {
            const se = h.style._mergedLayers[ee];
            return te + (se.hasShadowPass() && !se.isHidden(t.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled))
            return;
          const y = h.context, T = gs.shadowMapResolution, z = gs.shadowMapResolution;
          if (this._cascades.length === 0 || gs.shadowMapResolution !== this._cascades[0].texture.size[0]) {
            this._cascades = [];
            for (let te = 0; te < gs.cascadeCount; ++te) {
              const ee = h._shadowMapDebug, se = y.gl, oe = y.createFramebuffer(T, z, ee, "texture"), he = new i.T(y, { width: T, height: z, data: null }, se.DEPTH_COMPONENT16);
              if (oe.depthAttachment.set(he.texture), ee) {
                const _e = new i.T(y, { width: T, height: z, data: null }, se.RGBA8);
                oe.colorAttachment.set(_e.texture);
              }
              this._cascades.push({ framebuffer: oe, texture: he, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new i.bR(), scale: 0 });
            }
          }
          this.shadowDirection = Yo(s);
          let R = 0;
          if (t.elevation) {
            const te = t.elevation, ee = [1e4, -1e4];
            te.visibleDemTiles.filter((se) => se.dem).forEach((se) => {
              const oe = se.dem.tree;
              ee[0] = Math.min(ee[0], oe.minimums[0]), ee[1] = Math.max(ee[1], oe.maximums[0]);
            }), ee[0] !== 1e4 && (R = (ee[1] - ee[0]) * te.exaggeration());
          }
          const F = 1.5 * t.cameraToCenterDistance, N = 3 * F, G = new Float64Array(16);
          for (let te = 0; te < this._cascades.length; ++te) {
            const ee = this._cascades[te];
            let se = t.height / 50, oe = 1;
            gs.cascadeCount === 1 ? oe = N : te === 0 ? oe = F : (se = F, oe = N);
            const [he, _e] = Eo(t, this.shadowDirection, se, oe, gs.shadowMapResolution, R);
            ee.scale = t.scale, ee.matrix = he, ee.boundingSphereRadius = _e, i.ab.mat4.invert(G, ee.matrix), ee.frustum = i.bR.fromInvProjectionMatrix(G, 1, 0, !0), ee.far = oe;
          }
          const Z = this._cascades.length - 1;
          this._uniformValues.u_fade_range = [0.75 * this._cascades[Z].far, this._cascades[Z].far], this._uniformValues.u_shadow_intensity = _, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / gs.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = gs.shadowMapResolution, this._uniformValues.u_shadowmap_0 = bs.ShadowMap0, this._uniformValues.u_shadowmap_1 = bs.ShadowMap0 + 1, this._groundShadowTiles = h.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 });
          const W = h.transform.elevation;
          for (const te of this._groundShadowTiles) {
            let ee = { min: 0, max: 0 };
            if (W) {
              const se = W.getMinMaxForTile(te);
              se && (ee = se);
            }
            this.addShadowReceiver(te.toUnwrapped(), ee.min, ee.max);
          }
        }
        get enabled() {
          return this._enabled && !this._forceDisable;
        }
        set enabled(t) {
          this._enabled = t;
        }
        drawShadowPass(t, s) {
          if (!this.enabled)
            return;
          const h = this.painter, _ = h.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(h.transform.getFrustum(0), h.transform.worldSize, this._cascades), _.viewport.set([0, 0, gs.shadowMapResolution, gs.shadowMapResolution]);
          for (let y = 0; y < this._numCascadesToRender; ++y) {
            h.currentShadowCascade = y, _.bindFramebuffer.set(this._cascades[y].framebuffer.framebuffer), _.clear({ color: i.aj.white, depth: 1 });
            for (const T of t.order) {
              const z = t._mergedLayers[T];
              if (!z.hasShadowPass() || z.isHidden(h.transform.zoom))
                continue;
              const R = t.getLayerSourceCache(z), F = R ? s[R.id] : void 0;
              (z.type === "model" || F && F.length) && h.renderLayer(h, R, z, F);
            }
          }
          h.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this.enabled)
            return;
          const t = this.painter, s = t.style, h = t.context, _ = s.directionalLight, y = s.ambientLight;
          if (!_ || !y)
            return;
          const T = [], z = Mo(t, t.longestCutoffRange);
          z.shouldRenderCutoff && T.push("RENDER_CUTOFF"), T.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && T.push("NORMAL_OFFSET");
          const R = cr(s, _, y), F = new Wt(h.gl.LEQUAL, Wt.ReadOnly, t.depthRangeFor3D);
          for (const N of this._groundShadowTiles) {
            const G = N.toUnwrapped(), Z = t.isTileAffectedByFog(N), W = t.getOrCreateProgram("groundShadow", { defines: T, overrideFog: Z });
            this.setupShadows(G, W), t.uploadCommonUniforms(h, W, G, null, z);
            const te = { u_matrix: t.transform.calculateProjMatrix(G), u_ground_shadow_factor: R };
            W.draw(t, h.gl.TRIANGLES, F, ci.disabled, bi.multiply, ti.disabled, te, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? bi.unblended : bi.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t) {
          const s = this.painter.transform, h = s.calculatePosMatrix(t, s.worldSize);
          return i.ab.mat4.multiply(h, this._cascades[this.painter.currentShadowCascade].matrix, h), Float32Array.from(h);
        }
        calculateShadowPassMatrixFromMatrix(t) {
          return i.ab.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);
        }
        setupShadows(t, s, h, _ = 0) {
          if (!this.enabled)
            return;
          const y = this.painter.transform, T = this.painter.context, z = T.gl, R = this._uniformValues, F = new Float64Array(16), N = y.calculatePosMatrix(t, y.worldSize);
          for (let G = 0; G < this._cascades.length; G++)
            i.ab.mat4.multiply(F, this._cascades[G].matrix, N), R[G === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(F), T.activeTexture.set(z.TEXTURE0 + bs.ShadowMap0 + G), this._cascades[G].texture.bind(z.NEAREST, z.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!h, this.useNormalOffset) {
            const G = i.cc(t.canonical), Z = 2 / y.tileSize * i.ag / gs.shadowMapResolution, W = Z * this._cascades[0].boundingSphereRadius, te = Z * this._cascades[this._cascades.length - 1].boundingSphereRadius, ee = (h === "vector-tile" ? 1 : 3) / Math.pow(2, _ - t.canonical.z - (1 - y.zoom + Math.floor(y.zoom)));
            R.u_shadow_normal_offset = [G, W * ee, te * ee], R.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            R.u_shadow_bias = [36e-5, 12e-4, 0.012];
          s.setShadowUniformValues(T, R);
        }
        setupShadowsFromMatrix(t, s, h = !1) {
          if (!this.enabled)
            return;
          const _ = this.painter.context, y = _.gl, T = this._uniformValues, z = new Float64Array(16);
          for (let R = 0; R < gs.cascadeCount; R++)
            i.ab.mat4.multiply(z, this._cascades[R].matrix, t), T[R === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(z), _.activeTexture.set(y.TEXTURE0 + bs.ShadowMap0 + R), this._cascades[R].texture.bind(y.NEAREST, y.CLAMP_TO_EDGE);
          if (this.useNormalOffset = h, h) {
            const R = gs.normalOffset;
            T.u_shadow_normal_offset = [1, R, R], T.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            T.u_shadow_bias = [36e-5, 12e-4, 0.012];
          s.setShadowUniformValues(_, T);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t, s, h, _) {
          if (_[2] >= 0)
            return {};
          const y = function(R, F, N) {
            const G = N / (1 << R.canonical.z);
            return new i.cd([R.canonical.x * G + R.wrap * N, R.canonical.y * G + R.wrap * N, 0], [(R.canonical.x + 1) * G + R.wrap * N, (R.canonical.y + 1) * G + R.wrap * N, F]);
          }(t, s, h).getCorners(), T = s / -_[2];
          _[0] < 0 ? (i.ab.vec3.add(y[0], y[0], [_[0] * T, 0, 0]), i.ab.vec3.add(y[3], y[3], [_[0] * T, 0, 0])) : _[0] > 0 && (i.ab.vec3.add(y[1], y[1], [_[0] * T, 0, 0]), i.ab.vec3.add(y[2], y[2], [_[0] * T, 0, 0])), _[1] < 0 ? (i.ab.vec3.add(y[0], y[0], [0, _[1] * T, 0]), i.ab.vec3.add(y[1], y[1], [0, _[1] * T, 0])) : _[1] > 0 && (i.ab.vec3.add(y[2], y[2], [0, _[1] * T, 0]), i.ab.vec3.add(y[3], y[3], [0, _[1] * T, 0]));
          const z = {};
          return z.vertices = y, z.planes = [Kr(y[1], y[0], y[4]), Kr(y[2], y[1], y[5]), Kr(y[3], y[2], y[6]), Kr(y[0], y[3], y[7])], z;
        }
        addShadowReceiver(t, s, h) {
          this._receivers.add(t, i.cd.fromTileIdAndHeight(t, s, h));
        }
        getMaxCascadeForTile(t) {
          const s = this._receivers.get(t);
          return s && s.lastCascade ? s.lastCascade : 0;
        }
      }
      function Kr(c, t, s) {
        const h = i.ab.vec3.sub([], s, t), _ = i.ab.vec3.sub([], c, t), y = i.ab.vec3.cross([], h, _), T = i.ab.vec3.length(y);
        return T === 0 ? [0, 0, 1, 0] : (i.ab.vec3.scale(y, y, 1 / T), [y[0], y[1], y[2], -i.ab.vec3.dot(y, t)]);
      }
      function Yo(c) {
        const t = c.properties.get("direction"), s = i.cb(t.x, t.y, t.z);
        s[2] = i.aw(s[2], 0, 75);
        const h = i.ce([s[0], s[1], s[2]]);
        return i.ab.vec3.fromValues(h.x, h.y, h.z);
      }
      function cr(c, t, s) {
        const h = t.properties.get("color-use-theme") === "none", _ = t.properties.get("color"), y = t.properties.get("intensity"), T = t.properties.get("direction"), z = [T.x, T.y, T.z], R = s.properties.get("color-use-theme") === "none", F = s.properties.get("color"), N = s.properties.get("intensity"), G = Math.max(i.ab.vec3.dot([0, 0, 1], z), 0), Z = [0, 0, 0];
        i.ab.vec3.scale(Z, F.toRenderColor(R ? null : c.getLut(t.scope)).toArray01Linear().slice(0, 3), N);
        const W = [0, 0, 0];
        return i.ab.vec3.scale(W, _.toRenderColor(h ? null : c.getLut(s.scope)).toArray01Linear().slice(0, 3), G * y), i.cf([Z[0] > 0 ? Z[0] / (Z[0] + W[0]) : 0, Z[1] > 0 ? Z[1] / (Z[1] + W[1]) : 0, Z[2] > 0 ? Z[2] / (Z[2] + W[2]) : 0]);
      }
      function Eo(c, t, s, h, _, y) {
        const T = c.zoom, z = c.scale, R = c.worldSize, F = 1 / R, N = c.aspect, G = Math.sqrt(1 + N * N) * Math.tan(0.5 * c.fovX), Z = G * G, W = h - s, te = h + s;
        let ee, se;
        Z > W / te ? (ee = h, se = h * G) : (ee = 0.5 * te * (1 + Z), se = 0.5 * Math.sqrt(W * W + 2 * (h * h + s * s) * Z + te * te * Z * Z));
        const oe = c.projection.pixelsPerMeter(c.center.lat, R), he = c._camera.getCameraToWorldMercator(), _e = [0, 0, -ee * F];
        i.ab.vec3.transformMat4(_e, _e, he);
        let pe = se * F;
        const Me = c._edgeInsets;
        if (!(Me.left === 0 && Me.top === 0 && Me.right === 0 && Me.bottom === 0 || Me.left === Me.right && Me.top === Me.bottom)) {
          const _t = c._camera.getWorldToCamera(c.worldSize, c.projection.zAxisUnit === "meters" ? oe : 1), ct = c._camera.getCameraToClipPerspective(c._fov, c.width / c.height, s, h);
          ct[8] = 2 * -c.centerOffset.x / c.width, ct[9] = 2 * c.centerOffset.y / c.height;
          const nt = new Float64Array(16);
          i.ab.mat4.mul(nt, ct, _t);
          const Lt = new Float64Array(16);
          i.ab.mat4.invert(Lt, nt);
          const bt = i.bR.fromInvProjectionMatrix(Lt, R, T, !0);
          for (const zt of bt.points) {
            const Bt = ((xe = zt)[0] /= z, xe[1] /= z, xe[2] = i.bH(xe[2], c._center.lat), xe);
            pe = Math.max(pe, i.ab.vec3.len(i.ab.vec3.subtract([], _e, Bt)));
          }
        }
        var xe;
        pe *= _ / (_ - 1);
        const we = Math.acos(t[2]), ve = Math.atan2(-t[0], -t[1]), Pe = new To();
        Pe.position = _e, Pe.setPitchBearing(we, ve);
        const Oe = Pe.getWorldToCamera(R, oe), Xe = pe * R, He = Math.min(c._mercatorZfromZoom(17) * R * -2, -2 * Xe), ke = Pe.getCameraToClipOrthographic(-Xe, Xe, -Xe, Xe, He, (Xe + y * oe) / t[2]), Ne = new Float64Array(16);
        i.ab.mat4.multiply(Ne, ke, Oe);
        const st = i.ab.vec3.fromValues(Math.floor(1e6 * _e[0]) / 1e6 * R, Math.floor(1e6 * _e[1]) / 1e6 * R, 0), ut = 0.5 * _, xt = [0, 0, 0];
        i.ab.vec3.transformMat4(xt, st, Ne), i.ab.vec3.scale(xt, xt, ut);
        const Ge = [Math.floor(xt[0]), Math.floor(xt[1]), Math.floor(xt[2])], lt = [0, 0, 0];
        i.ab.vec3.sub(lt, xt, Ge), i.ab.vec3.scale(lt, lt, -1 / ut);
        const Je = new Float64Array(16);
        return i.ab.mat4.identity(Je), i.ab.mat4.translate(Je, Je, lt), i.ab.mat4.multiply(Ne, Je, Ne), [Ne, Xe];
      }
      class Zh extends i.E {
        constructor(t) {
          super(), this.requestManager = t, this.models = { "": {} }, this.numModelsLoading = {};
        }
        loadModel(t, s) {
          return i.aM(this.requestManager.transformRequest(s, i.R.Model).url).then((h) => {
            if (!h)
              return;
            const _ = i.aN(h), y = new i.aO(t, void 0, void 0, _);
            return y.computeBoundsAndApplyParent(), y;
          }).catch((h) => {
            if (h && h.status === 404)
              return null;
            this.fire(new i.y(new Error(`Could not load model ${t} from ${s}: ${h.message}`)));
          });
        }
        load(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = Object.keys(t);
          this.numModelsLoading[s] = (this.numModelsLoading[s] || 0) + h.length;
          const _ = [];
          for (const y of h)
            _.push(this.loadModel(y, t[y]));
          Promise.allSettled(_).then((y) => {
            for (let T = 0; T < y.length; T++) {
              const { status: z, value: R } = y[T];
              z === "fulfilled" && R && (this.models[s][h[T]] = { model: R, numReferences: 1 });
            }
            this.numModelsLoading[s] -= h.length, this.fire(new i.z("data", { dataType: "style" }));
          }).catch((y) => {
            this.fire(new i.y(new Error(`Could not load models: ${y.message}`)));
          });
        }
        isLoaded() {
          for (const t in this.numModelsLoading)
            if (this.numModelsLoading[t] > 0)
              return !1;
          return !0;
        }
        hasModel(t, s) {
          return !!this.getModel(t, s);
        }
        getModel(t, s) {
          return this.models[s] || (this.models[s] = {}), this.models[s][t] ? this.models[s][t].model : void 0;
        }
        addModel(t, s, h) {
          this.models[h] || (this.models[h] = {}), this.hasModel(t, h) && this.models[h][t].numReferences++, this.load({ [t]: this.requestManager.normalizeModelURL(s) }, h);
        }
        addModels(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = {};
          for (const _ in t)
            this.models[s][_] = {}, h[_] = this.requestManager.normalizeModelURL(t[_]);
          this.load(h, s);
        }
        addModelsFromBucket(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = {};
          for (const _ of t)
            this.hasModel(_, s) ? this.models[s][_].numReferences++ : h[_] = this.requestManager.normalizeModelURL(_);
          this.load(h, s);
        }
        removeModel(t, s) {
          if (this.models[s] && this.models[s][t] && (this.models[s][t].numReferences--, this.models[s][t].numReferences === 0)) {
            const h = this.models[s][t].model;
            delete this.models[s][t], h.destroy();
          }
        }
        listModels(t) {
          return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t]);
        }
        upload(t, s) {
          this.models[s] || (this.models[s] = {});
          for (const h in this.models[s])
            this.models[s][h].model && this.models[s][h].model.upload(t.context);
        }
      }
      const Uc = new i.a5({ data: new i.a6(i.a3.colorTheme.data) }), Ua = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", !1] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
      function $l(c) {
        return c = c || {}, Object.assign(c, Ua);
      }
      class yl extends i.E {
        constructor(t) {
          super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, i.aP(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
        }
        destroy() {
          this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
        }
        _onLoad() {
          this._map.style.forEachFragmentStyle((t) => {
            t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new i.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId, this._scope = t.scope));
          }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (t) => (t.feature && t.feature.properties.floorplan && this.selectFloorplan(t.feature.properties.floorplan), !0) }), this._checkFloorplanVisible(!0);
        }
        _onMove() {
          this._checkFloorplanVisible(!1);
        }
        _checkFloorplanVisible(t) {
          if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13)
            return;
          this._indoorData && !function(T, z) {
            const [R, F] = T, { center: N, radius: G } = z, [Z, W] = N, te = Math.abs(R - Z);
            return Math.sqrt((te > 180 ? 360 - te : te) ** 2 + (F - W) ** 2) <= G;
          }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new i.z("floorplangone")));
          const s = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, h = new i.P(this._map.transform.width / 2, this._map.transform.height / 2), _ = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], y = this._map.queryRenderedFeatures(t ? _ : h, s);
          y.length > 0 && (this._selectedFloorplan && y[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = y[0], this._floorplanSelected(!1)));
        }
        _floorplanSelected(t) {
          this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(y) {
            const [[T, z], [R, F]] = y, N = (R - T + 360) % 360, G = N > 180 ? 360 - N : N;
            return { center: [(T + G / 2 + 360) % 360, (z + F) / 2], radius: Math.sqrt(G ** 2 + (F - z) ** 2) / 2 };
          }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
          const s = this._floorplanStates[this._indoorData.id].selectedBuilding, h = this._floorplanStates[this._indoorData.id].selectedLevel;
          let _;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel)
            for (const y of this._indoorData.levels)
              y.id === this._selectedLevel.id && (_ = y.id);
          if (this.fire(new i.z("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: _ })), s) {
            const y = this._indoorData.buildings.find((T) => T.id === s);
            this._buildingSelected(y, !1);
          } else
            this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
          if (h) {
            const y = this._indoorData.levels.find((T) => T.id === h);
            this._updateLevels(y, t);
          } else
            t && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
        }
        _buildingSelected(t, s) {
          s && t && t.extent && this._map.fitBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;
          const h = this._indoorData.levels.filter((_) => t.levels.includes(_.id));
          this.fire(new i.z("buildingselected", { buildingId: t.id, levels: h }));
        }
        _levelSelected(t) {
          if (t === "overview")
            this._updateLevels(void 0, !0);
          else {
            const s = this._indoorData.levels.find((h) => h.id === t);
            this._updateLevels(s, !0);
          }
          this.fire(new i.z("levelselected", { levelId: t === "overview" ? void 0 : t }));
        }
        _updateLevels(t, s) {
          if (!t)
            return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (s && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
          function h(F) {
            const N = F.indexOf("/floor/");
            if (N === -1)
              return F;
            const G = N + 7, Z = F.indexOf("/", G);
            return Z === -1 ? F.slice(G) : F.slice(G, Z);
          }
          this._selectedLevel = t, this._floorplanStates[this._indoorData.id].selectedLevel = t ? t.id : void 0;
          const _ = [], y = {}, T = {}, z = {}, R = {};
          for (const F of this._indoorData.levels)
            if (_.push(F.id), y[F.id] = F.height, T[F.id] = F.base, t) {
              if (this.mergeFloors) {
                const N = h(t.id), G = h(F.id);
                z[F.id] = G === N ? "true" : "false";
              } else
                z[F.id] = F.id === t.id ? "true" : "false";
              R[F.id] = F.base < t.base ? "true" : "false";
            } else
              R[F.id] = !0;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", _]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", y]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", T]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", z]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", R]), t && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!t.isUnderground), s && t.extent)) {
            const F = this._map.cameraForBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), N = this._map.getZoom(), G = F.zoom ? Math.abs(N - F.zoom) : 0;
            this._map.fitBounds(t.extent, G >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: N });
          }
        }
        selectFloorplan(t) {
          const s = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, h = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], _ = this._map.queryRenderedFeatures(h, s);
          if (_.length > 0) {
            for (const y of _)
              if (JSON.parse(y.properties["indoor-data"]).floorplanIDs.includes(t)) {
                this._selectedFloorplan = y, this._floorplanSelected(!0);
                break;
              }
          }
        }
        selectBuilding(t) {
          const s = this._indoorData.buildings.find((h) => h.id === t);
          this._buildingSelected(s, !0);
        }
        selectLevel(t) {
          this._levelSelected(t);
        }
      }
      function _a(c) {
        if (!c.metadata || !c.metadata.content_area)
          return;
        const t = i.q.devicePixelRatio, { left: s, top: h, width: _, height: y } = c.metadata.content_area, T = s * t, z = h * t;
        return [T, z, T + _ * t, z + y * t];
      }
      function ga(c) {
        if (c)
          return c.map(([t, s]) => [t * i.q.devicePixelRatio, s * i.q.devicePixelRatio]);
      }
      const Ao = (c, t) => Ae(c, t && t.filter((s) => s.identifier !== "source.canvas")), Hh = i.ay(Oi, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), td = i.ay(Oi, ["setCenter", "setZoom", "setBearing", "setPitch"]), ja = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), jc = { version: 8, layers: [], sources: {} }, Gc = { duration: 300, delay: 0 };
      class hr extends i.E {
        constructor(t, s = {}) {
          super(), this.map = t, this.scope = s.scope || "", this.globalId = null, this.fragments = [], this.importDepth = s.importDepth || 0, this.importsCache = s.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = s.resolvedImports || /* @__PURE__ */ new Set(), this.transition = i.l({}, Gc), this._buildingIndex = new Gl(this), this.crossTileSymbolIndex = new Hl(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = s.styleChanges || new Zr(), this.dispatcher = s.dispatcher ? s.dispatcher : new i.D(i.ci(), this), s.imageManager ? this.imageManager = s.imageManager : (this.imageManager = new Ws(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = s.glyphManager ? s.glyphManager : new i.cj(t._requestManager, s.localFontFamily ? i.ck.all : s.localIdeographFontFamily ? i.ck.ideographs : i.ck.none, s.localFontFamily || s.localIdeographFontFamily), s.modelManager ? this.modelManager = s.modelManager : (this.modelManager = new Zh(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = s.configOptions ? s.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = s.configDependentLayers ? s.configDependentLayers : /* @__PURE__ */ new Set(), this._config = s.config, this._styleColorTheme = { lut: null, lutLoading: !1, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: s.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = s.initialConfig, this.dispatcher.broadcast("setReferrer", i.cl());
          const h = this;
          this._rtlTextPluginCallback = hr.registerForPluginStateChange((_) => {
            h.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: _.pluginStatus, pluginURL: _.pluginURL }, (y, T) => {
              if (i.cm(y), T && T.every((z) => z))
                for (const z in h._sourceCaches) {
                  const R = h._sourceCaches[z], F = R.getSource().type;
                  F !== "vector" && F !== "geojson" || R.reload();
                }
            });
          }), this.on("data", (_) => {
            if (_.dataType !== "source" || _.sourceDataType !== "metadata")
              return;
            const y = this.getOwnSource(_.sourceId);
            if (y && y.vectorLayerIds)
              for (const T in this._layers) {
                const z = this._layers[T];
                z.source === y.id && this._validateLayer(z);
              }
          });
        }
        load(t) {
          return t ? (typeof t == "string" ? this.loadURL(t) : this.loadJSON(t), this) : this;
        }
        _getGlobalId(t) {
          if (!t)
            return null;
          if (typeof t == "string") {
            if (i.f(t))
              return t;
            const s = i.cn(t);
            if (!s.startsWith("http"))
              try {
                return new URL(s, location.href).toString();
              } catch {
                return s;
              }
            return s;
          }
          return `json://${i.co(JSON.stringify(t))}`;
        }
        _diffStyle(t, s, h) {
          this.globalId = this._getGlobalId(t);
          const _ = (y, T) => {
            try {
              T(null, this.setState(y, h));
            } catch (z) {
              T(z, !1);
            }
          };
          if (typeof t == "string") {
            const y = this.map._requestManager.normalizeStyleURL(t), T = this.map._requestManager.transformRequest(y, i.R.Style);
            i.n(T, (z, R) => {
              z ? this.fire(new i.y(z)) : R && _(R, s);
            });
          } else
            typeof t == "object" && _(t, s);
        }
        loadURL(t, s = {}) {
          this.fire(new i.z("dataloading", { dataType: "style" }));
          const h = typeof s.validate == "boolean" ? s.validate : !i.f(t);
          this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, s.accessToken), this.resolvedImports.add(t);
          const _ = this.importsCache.get(t);
          if (_)
            return this._load(_, h);
          const y = this.map._requestManager.transformRequest(t, i.R.Style);
          this._request = i.n(y, (T, z) => {
            if (this._request = null, T)
              this.fire(new i.y(T));
            else if (z)
              return this.importsCache.set(t, z), this._load(z, h);
          });
        }
        loadJSON(t, s = {}) {
          this.fire(new i.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t), this._request = i.q.frame(() => {
            this._request = null, this._load(t, s.validate !== !1);
          });
        }
        loadEmpty() {
          this.fire(new i.z("dataloading", { dataType: "style" })), this._load(jc, !1);
        }
        _loadImports(t, s, h) {
          if (this.importDepth >= 4)
            return i.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const _ = [];
          for (const y of t) {
            const T = this._createFragmentStyle(y), z = new Promise((N) => {
              T.once("style.import.load", N), T.once("error", N);
            }).then(() => this.mergeAll());
            if (_.push(z), this.resolvedImports.has(y.url)) {
              T.loadEmpty();
              continue;
            }
            const R = y.data || this.importsCache.get(y.url);
            R ? (T.loadJSON(R, { validate: s }), this._isInternalStyle(R) && (T.globalId = null)) : y.url ? T.loadURL(y.url, { validate: s }) : T.loadEmpty();
            const F = { style: T, id: y.id, config: y.config };
            if (h) {
              const N = this.fragments.findIndex(({ id: G }) => G === h);
              this.fragments = this.fragments.slice(0, N).concat(F).concat(this.fragments.slice(N));
            } else
              this.fragments.push(F);
          }
          return Promise.allSettled(_);
        }
        getImportGlobalIds(t = this, s = /* @__PURE__ */ new Set()) {
          for (const h of t.fragments)
            h.style.globalId && s.add(h.style.globalId), this.getImportGlobalIds(h.style, s);
          return [...s.values()];
        }
        _createFragmentStyle(t) {
          const s = this.scope ? i.aC(t.id, this.scope) : t.id;
          let h;
          const _ = this._initialConfig && this._initialConfig[s];
          (t.config || _) && (h = i.l({}, t.config, _));
          const y = new hr(this.map, { scope: s, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: h, configOptions: this.options, colorThemeOverride: t["color-theme"], configDependentLayers: this._configDependentLayers });
          return y.setEventedParent(this.map, { style: y }), y;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
        }
        _isInternalStyle(t) {
          return this.isRootStyle() && (t.fragment || !!t.schema && t.fragment !== !1);
        }
        _load(t, s) {
          const h = t.indoor ? $l(t.schema) : t.schema;
          if (this._isInternalStyle(t)) {
            const T = i.l({}, jc, { imports: [{ id: "basemap", data: t, url: "" }] });
            return void this._load(T, s);
          }
          if (this.updateConfig(this._config, h), s && Ao(this, Zi(t)))
            return;
          this._loaded = !0, this.stylesheet = i.cp(t);
          const _ = () => {
            for (const F in t.sources)
              this.addSource(F, t.sources[F], { validate: !1, isInitialLoad: !0 });
            t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 })), this.glyphManager.setURL(t.glyphs, this.scope);
            const T = ul(this.stylesheet.layers);
            if (this._order = T.map((F) => F.id), this.stylesheet.light && i.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
              if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                const F = this.stylesheet.lights[0];
                this.light = new Qe(F.properties, F.id);
              } else
                this.setLights(this.stylesheet.lights);
            this.light || (this.light = new Qe(this.stylesheet.light)), this._layers = {};
            for (const F of T) {
              const N = i.cu(F, this.scope, this._styleColorTheme.lut, this.options);
              N.configDependencies.size !== 0 && this._configDependentLayers.add(N.fqid), N.setEventedParent(this, { layer: { id: N.id } }), this._layers[N.id] = N;
              const G = this.getOwnLayerSourceCache(N), Z = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              G && N.canCastShadows() && Z && (G.castsShadows = !0);
            }
            this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
            const z = this.stylesheet.terrain;
            z && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(z, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new i.z("data", { dataType: "style" }));
            const R = this.isRootStyle();
            t.imports ? this._loadImports(t.imports, s).then(() => {
              this._reloadImports(), this.fire(new i.z(R ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new i.z(R ? "style.load" : "style.import.load")));
          };
          this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
          const y = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (y) {
            const T = this._evaluateColorThemeData(y);
            this._loadColorTheme(T).then(() => {
              _();
            }).catch((z) => {
              i.w(`Couldn't load color theme from the stylesheet: ${z}`), _();
            });
          } else
            this._styleColorTheme.lut = null, _();
        }
        isRootStyle() {
          return this.importDepth === 0;
        }
        mergeAll() {
          let t, s, h, _, y, T, z, R, F, N;
          const G = {};
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((Z) => {
            if (Z.stylesheet) {
              if (Z.light != null && (t = Z.light), Z.stylesheet.lights)
                for (const W of Z.stylesheet.lights)
                  W.type === "ambient" && Z.ambientLight != null && (s = Z.ambientLight), W.type === "directional" && Z.directionalLight != null && (h = Z.directionalLight);
              _ = this._prioritizeTerrain(_, Z.terrain, Z.stylesheet.terrain), Z.stylesheet.fog && Z.fog != null && (y = Z.fog), Z.stylesheet.snow && Z.snow != null && (T = Z.snow), Z.stylesheet.rain && Z.rain != null && (z = Z.rain), Z.stylesheet.camera != null && (N = Z.stylesheet.camera), Z.stylesheet.projection != null && (R = Z.stylesheet.projection), Z.stylesheet.transition != null && (F = Z.stylesheet.transition), G[Z.scope] = Z._styleColorTheme;
            }
          }), this.light = t, this.ambientLight = s, this.directionalLight = h, this.fog = y, this.snow = T, this.rain = z, this._styleColorThemeForScope = G, _ === null ? delete this.terrain : this.terrain = _, this.camera = N || { "camera-projection": "perspective" }, this.projection = R || { name: "mercator" }, this.transition = i.l({}, Gc, F), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(t) {
          const s = (h) => {
            for (const _ of h.fragments)
              s(_.style);
            t(h);
          };
          s(this);
        }
        _prioritizeTerrain(t, s, h) {
          const _ = t && t.drapeRenderMode === 0;
          return h === null ? s && s.drapeRenderMode === 0 ? s : _ ? t : null : s != null && (!t || _ || s && s.drapeRenderMode === 1) ? s : t;
        }
        mergeTerrain() {
          let t;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((s) => {
            t = this._prioritizeTerrain(t, s.terrain, s.stylesheet.terrain);
          }), t === null ? delete this.terrain : this.terrain = t;
        }
        mergeProjection() {
          let t;
          this.forEachFragmentStyle((s) => {
            s.stylesheet.projection != null && (t = s.stylesheet.projection);
          }), this.projection = t || { name: "mercator" };
        }
        mergeSources() {
          const t = {}, s = {}, h = {};
          this.forEachFragmentStyle((_) => {
            for (const y in _._sourceCaches) {
              const T = i.aC(y, _.scope);
              t[T] = _._sourceCaches[y];
            }
            for (const y in _._otherSourceCaches) {
              const T = i.aC(y, _.scope);
              s[T] = _._otherSourceCaches[y];
            }
            for (const y in _._symbolSourceCaches) {
              const T = i.aC(y, _.scope);
              h[T] = _._symbolSourceCaches[y];
            }
          }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = s, this._mergedSymbolSourceCaches = h;
        }
        mergeLayers() {
          const t = {}, s = [], h = {};
          this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((y) => {
            for (const T of y._order) {
              const z = y._layers[T];
              if (z.type === "slot") {
                const R = i.cq(T);
                if (t[R])
                  continue;
                t[R] = [];
              }
              z.slot && t[z.slot] ? t[z.slot].push(z) : s.push(z);
            }
          }), this._mergedOrder = [];
          const _ = (y = []) => {
            for (const T of y)
              if (T.type === "slot") {
                const z = i.cq(T.id);
                t[z] && _(t[z]), this._mergedSlots.push(z);
              } else {
                const z = i.aC(T.id, T.scope);
                this._mergedOrder.push(z), h[z] = T, T.is3D() && (this._has3DLayers = !0), T.type === "circle" && (this._hasCircleLayers = !0), T.type === "symbol" && (this._hasSymbolLayers = !0), T.type === "clip" && (this._clipLayerPresent = !0);
              }
          };
          _(s), this._mergedOrder.sort((y, T) => {
            const z = h[y], R = h[T];
            return z.hasInitialOcclusionOpacityProperties ? R.is3D() ? 1 : 0 : z.is3D() && R.hasInitialOcclusionOpacityProperties ? -1 : 0;
          }), this._mergedLayers = h, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t) {
          return this.stylesheet.camera = i.l({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;
        }
        _evaluateColorThemeData(t) {
          return t.data ? function(s, h, _) {
            const y = i.l({}, h);
            for (const z of Object.keys(i.a3.colorTheme))
              y[z] === void 0 && (y[z] = i.a3.colorTheme[z].default);
            const T = new i.a4(Uc, s, new Map(_));
            return T.setTransitionOrValue(y, _), T.untransitioned().possiblyEvaluate(new i.a8(0));
          }(this.scope, t, this.options).get("data") : null;
        }
        _loadColorTheme(t) {
          this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
          const s = this._styleColorTheme.lutLoadingCorrelationID;
          return new Promise((h, _) => {
            const y = "data:image/png;base64,";
            if (!t || t.length === 0)
              return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void h();
            let T = t;
            T.startsWith(y) || (T = y + T);
            const z = "mapbox-reserved-lut", R = new Image();
            R.src = T, R.onerror = () => {
              this._styleColorTheme.lutLoading = !1, _(new Error("Failed to load image data"));
            }, R.onload = () => {
              if (this._styleColorTheme.lutLoadingCorrelationID !== s)
                return void h();
              this._styleColorTheme.lutLoading = !1;
              const { width: F, height: N, data: G } = i.q.getImageData(R);
              if (N > 32)
                return void _(new Error("The height of the image must be less than or equal to 32 pixels."));
              if (F !== N * N)
                return void _(new Error("The width of the image must be equal to the height squared."));
              this.getImage(z) && this.removeImage(z), this.addImage(z, { data: new i.r({ width: F, height: N }, G), pixelRatio: 1, sdf: !1, usvg: !1, version: 0 });
              const Z = this.imageManager.getImage(z, this.scope);
              Z ? (this._styleColorTheme.lut = { image: Z.data, data: t }, h()) : _(new Error("Missing LUT image."));
            };
          });
        }
        getLut(t) {
          const s = this._styleColorThemeForScope[t];
          return s ? s.lut : null;
        }
        setProjection(t) {
          t ? this.stylesheet.projection = t : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t) {
          this._spriteRequest = function(s, h, _) {
            let y, T, z;
            const R = i.q.devicePixelRatio > 1 ? "@2x" : "";
            let F = i.n(h.transformRequest(h.normalizeSpriteURL(s, R, ".json"), i.R.SpriteJSON), (Z, W) => {
              F = null, z || (z = Z, y = W, G());
            }), N = i.o(h.transformRequest(h.normalizeSpriteURL(s, R, ".png"), i.R.SpriteImage), (Z, W) => {
              N = null, z || (z = Z, T = W, G());
            });
            function G() {
              if (z)
                _(z);
              else if (y && T) {
                const Z = i.q.getImageData(T), W = {};
                for (const te in y) {
                  const { width: ee, height: se, x: oe, y: he, sdf: _e, pixelRatio: pe, stretchX: Me, stretchY: xe, content: we } = y[te], ve = new i.r({ width: ee, height: se });
                  i.r.copy(Z, ve, { x: oe, y: he }, { x: 0, y: 0 }, { width: ee, height: se }, null), W[te] = { data: ve, pixelRatio: pe, sdf: _e, stretchX: Me, stretchY: xe, content: we, usvg: !1 };
                }
                _(null, W);
              }
            }
            return { cancel() {
              F && (F.cancel(), F = null), N && (N.cancel(), N = null);
            } };
          }(t, this.map._requestManager, (s, h) => {
            if (this._spriteRequest = null, s)
              this.fire(new i.y(s));
            else if (h)
              for (const _ in h)
                this.imageManager.addImage(_, this.scope, h[_]);
            this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
          });
        }
        _loadIconset(t) {
          if (!i.f(t) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster")
            return void this._loadSprite(t);
          const s = this.map._spriteFormat === "auto";
          var h, _;
          this._spriteRequest = (_ = (y, T) => {
            if (this._spriteRequest = null, y)
              s ? this._loadSprite(t) : this.fire(new i.y(y));
            else if (T)
              for (const z in T)
                this.imageManager.addImage(z, this.scope, T[z]);
            this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
          }, i.bi((h = this.map._requestManager).transformRequest(h.normalizeIconsetURL(t), i.R.Iconset), (y, T) => {
            if (y)
              return void _(y);
            const z = {}, R = i.cg(new i.bh(T));
            for (const F of R.icons) {
              const N = { version: 1, pixelRatio: i.q.devicePixelRatio, content: _a(F), stretchX: F.metadata ? ga(F.metadata.stretch_x_areas) : void 0, stretchY: F.metadata ? ga(F.metadata.stretch_y_areas) : void 0, sdf: !1, usvg: !0, icon: F };
              z[F.name] = N;
            }
            _(null, z);
          }));
        }
        _validateLayer(t) {
          const s = this.getOwnSource(t.source);
          if (!s)
            return;
          const h = t.sourceLayer;
          h && (s.type === "geojson" || s.vectorLayerIds && s.vectorLayerIds.indexOf(h) === -1) && this.fire(new i.y(new Error(`Source layer "${h}" does not exist on source "${s.id}" as specified by style layer "${t.id}"`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length)
            return !1;
          for (const t in this._sourceCaches)
            if (!this._sourceCaches[t].loaded())
              return !1;
          if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading)
            return !1;
          for (const { style: t } of this.fragments)
            if (!t.loaded())
              return !1;
          return !0;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((t, s) => {
              const h = this.fragments[s];
              return h && h.style && (t.data = h.style.serialize()), t;
            });
        }
        _serializeSources() {
          const t = {};
          for (const s in this._sourceCaches) {
            const h = this._sourceCaches[s].getSource();
            t[h.id] || (t[h.id] = h.serialize());
          }
          return t;
        }
        _serializeLayers(t) {
          const s = [];
          for (const h of t) {
            const _ = this._layers[h];
            _ && _.type !== "custom" && s.push(_.serialize());
          }
          return s;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasSnowTransition() {
          return !!this.snow && this.snow.hasTransition();
        }
        hasRainTransition() {
          return !!this.rain && this.rain.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition())
            return !0;
          for (const t in this._sourceCaches)
            if (this._sourceCaches[t].hasTransition())
              return !0;
          for (const t in this._layers)
            if (this._layers[t].hasTransition())
              return !0;
          return !1;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        _getOrder(t) {
          return t ? this.order : this._mergedOrder;
        }
        isLayerDraped(t) {
          return !!this.terrain && t.isDraped(this.getLayerSourceCache(t));
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        _checkLayer(t) {
          const s = this.getOwnLayer(t);
          if (s)
            return s;
          this.fire(new i.y(new Error(`The layer '${t}' does not exist in the map's style.`)));
        }
        _checkSource(t) {
          const s = this.getOwnSource(t);
          if (s)
            return s;
          this.fire(new i.y(new Error(`The source '${t}' does not exist in the map's style.`)));
        }
        precompilePrograms(t, s) {
          const h = this.map.painter;
          if (h)
            for (let _ = t.minzoom || 0; _ < (t.maxzoom || 25.5); _++) {
              const y = t.getProgramIds();
              if (y)
                for (const T of y) {
                  const z = t.getDefaultProgramParams(T, s.zoom, this._styleColorTheme.lut);
                  z && (h.style = this, this.fog && (h._fogVisible = !0, z.overrideFog = !0, h.getOrCreateProgram(T, z)), h._fogVisible = !1, z.overrideFog = !1, h.getOrCreateProgram(T, z), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (z.overrideRtt = !0, h.getOrCreateProgram(T, z)));
                }
            }
        }
        update(t) {
          if (!this._loaded)
            return;
          this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
          const s = this.calculateLightsBrightness();
          t.brightness = s || 0, s !== this._brightness && (this._brightness = s, this.dispatcher.broadcast("setBrightness", s));
          const h = this._changes.isDirty();
          let _ = !1;
          if (this._changes.isDirty()) {
            const T = this._changes.getLayerUpdatesByScope();
            for (const z in T) {
              const { updatedIds: R, removedIds: F } = T[z];
              (R || F) && (this._updateWorkerLayers(z, R, F), _ = !0);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();
          }
          const y = {};
          for (const T in this._mergedSourceCaches) {
            const z = this._mergedSourceCaches[T];
            y[T] = z.used, z.used = !1, z.tileCoverLift = 0;
          }
          for (const T of this._mergedOrder) {
            const z = this._mergedLayers[T];
            if (z.recalculate(t, this._availableImages), !z.isHidden(t.zoom)) {
              const R = this.getLayerSourceCache(z);
              R && (R.used = !0, R.tileCoverLift = Math.max(R.tileCoverLift, z.tileCoverLift()));
            }
            !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
              this.precompilePrograms(z, t);
            }) : this.precompilePrograms(z, t));
          }
          this._shouldPrecompile && (this._precompileDone = !0), this.terrain && _ && this.mergeLayers();
          for (const T in y) {
            const z = this._mergedSourceCaches[T];
            y[T] !== z.used && z.getSource().fire(new i.z("data", { sourceDataType: "visibility", dataType: "source", sourceId: z.getSource().id }));
          }
          this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), h && this.fire(new i.z("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t = this._changes.getUpdatedImages();
          if (t.length) {
            for (const s in this._sourceCaches)
              this._sourceCaches[s].reloadTilesForDependencies(["icons", "patterns"], t);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(t, s, h) {
          const _ = this.getFragmentStyle(t);
          _ && this.dispatcher.broadcast("updateLayers", { layers: s ? _._serializeLayers(s) : [], scope: t, removedIds: h || [], options: _.options });
        }
        setState(t, s) {
          if (this._checkLoaded(), Ao(this, Zi(t)))
            return !1;
          (t = i.cp(t)).layers = ul(t.layers);
          const h = function(T, z) {
            if (!T)
              return [{ command: Oi.setStyle, args: [z] }];
            let R = [];
            try {
              if (!i.bn(T.version, z.version))
                return [{ command: Oi.setStyle, args: [z] }];
              if (i.bn(T.center, z.center) || R.push({ command: Oi.setCenter, args: [z.center] }), i.bn(T.zoom, z.zoom) || R.push({ command: Oi.setZoom, args: [z.zoom] }), i.bn(T.bearing, z.bearing) || R.push({ command: Oi.setBearing, args: [z.bearing] }), i.bn(T.pitch, z.pitch) || R.push({ command: Oi.setPitch, args: [z.pitch] }), i.bn(T.sprite, z.sprite) || R.push({ command: Oi.setSprite, args: [z.sprite] }), i.bn(T.glyphs, z.glyphs) || R.push({ command: Oi.setGlyphs, args: [z.glyphs] }), i.bn(T.imports, z.imports) || function(W = [], te = [], ee) {
                te = te || [];
                const se = (W = W || []).map(Fi), oe = te.map(Fi), he = W.reduce(Li, {}), _e = te.reduce(Li, {}), pe = se.slice();
                let Me, xe, we, ve;
                for (Me = 0, xe = 0; Me < se.length; Me++)
                  we = se[Me], _e.hasOwnProperty(we) ? xe++ : (ee.push({ command: Oi.removeImport, args: [we] }), pe.splice(pe.indexOf(we, xe), 1));
                for (Me = 0, xe = 0; Me < oe.length; Me++)
                  we = oe[oe.length - 1 - Me], pe[pe.length - 1 - Me] !== we && (he.hasOwnProperty(we) ? (ee.push({ command: Oi.removeImport, args: [we] }), pe.splice(pe.lastIndexOf(we, pe.length - xe), 1)) : xe++, ve = pe[pe.length - Me], ee.push({ command: Oi.addImport, args: [_e[we], ve] }), pe.splice(pe.length - Me, 0, we));
                for (const Pe of te) {
                  const Oe = he[Pe.id];
                  Oe && !i.bn(Oe, Pe) && ee.push({ command: Oi.updateImport, args: [Pe.id, Pe] });
                }
              }(T.imports, z.imports, R), i.bn(T.transition, z.transition) || R.push({ command: Oi.setTransition, args: [z.transition] }), i.bn(T.light, z.light) || R.push({ command: Oi.setLight, args: [z.light] }), i.bn(T.fog, z.fog) || R.push({ command: Oi.setFog, args: [z.fog] }), i.bn(T.snow, z.snow) || R.push({ command: Oi.setSnow, args: [z.snow] }), i.bn(T.rain, z.rain) || R.push({ command: Oi.setRain, args: [z.rain] }), i.bn(T.projection, z.projection) || R.push({ command: Oi.setProjection, args: [z.projection] }), i.bn(T.lights, z.lights) || R.push({ command: Oi.setLights, args: [z.lights] }), i.bn(T.camera, z.camera) || R.push({ command: Oi.setCamera, args: [z.camera] }), !i.bn(T["color-theme"], z["color-theme"]))
                return [{ command: Oi.setStyle, args: [z] }];
              const F = {}, N = [];
              (function(W, te, ee, se) {
                let oe;
                for (oe in te = te || {}, W = W || {})
                  W.hasOwnProperty(oe) && (te.hasOwnProperty(oe) || ns(oe, ee, se));
                for (oe in te) {
                  if (!te.hasOwnProperty(oe))
                    continue;
                  const he = te[oe];
                  W.hasOwnProperty(oe) ? i.bn(W[oe], he) || (W[oe].type === "geojson" && he.type === "geojson" && ha(W, te, oe) ? ee.push({ command: Oi.setGeoJSONSourceData, args: [oe, he.data] }) : Cn(oe, te, ee, se)) : Bi(oe, te, ee);
                }
              })(T.sources, z.sources, N, F);
              const G = [];
              T.layers && T.layers.forEach((W) => {
                W.source && F[W.source] ? R.push({ command: Oi.removeLayer, args: [W.id] }) : G.push(W);
              });
              let Z = T.terrain;
              Z && F[Z.source] && (R.push({ command: Oi.setTerrain, args: [void 0] }), Z = void 0), R = R.concat(N), i.bn(Z, z.terrain) || R.push({ command: Oi.setTerrain, args: [z.terrain] }), function(W, te, ee) {
                te = te || [];
                const se = (W = W || []).map(Fi), oe = te.map(Fi), he = W.reduce(Li, {}), _e = te.reduce(Li, {}), pe = se.slice(), Me = /* @__PURE__ */ Object.create(null);
                let xe, we, ve, Pe, Oe, Xe, He;
                for (xe = 0, we = 0; xe < se.length; xe++)
                  ve = se[xe], _e.hasOwnProperty(ve) ? we++ : (ee.push({ command: Oi.removeLayer, args: [ve] }), pe.splice(pe.indexOf(ve, we), 1));
                for (xe = 0, we = 0; xe < oe.length; xe++)
                  ve = oe[oe.length - 1 - xe], pe[pe.length - 1 - xe] !== ve && (he.hasOwnProperty(ve) ? (ee.push({ command: Oi.removeLayer, args: [ve] }), pe.splice(pe.lastIndexOf(ve, pe.length - we), 1)) : we++, Xe = pe[pe.length - xe], ee.push({ command: Oi.addLayer, args: [_e[ve], Xe] }), pe.splice(pe.length - xe, 0, ve), Me[ve] = !0);
                for (xe = 0; xe < oe.length; xe++)
                  if (ve = oe[xe], Pe = he[ve], Oe = _e[ve], !Me[ve] && !i.bn(Pe, Oe))
                    if (i.bn(Pe.source, Oe.source) && i.bn(Pe["source-layer"], Oe["source-layer"]) && i.bn(Pe.type, Oe.type)) {
                      for (He in Ot(Pe.layout, Oe.layout, ee, ve, null, Oi.setLayoutProperty), Ot(Pe.paint, Oe.paint, ee, ve, null, Oi.setPaintProperty), i.bn(Pe.slot, Oe.slot) || ee.push({ command: Oi.setSlot, args: [ve, Oe.slot] }), i.bn(Pe.filter, Oe.filter) || ee.push({ command: Oi.setFilter, args: [ve, Oe.filter] }), i.bn(Pe.minzoom, Oe.minzoom) && i.bn(Pe.maxzoom, Oe.maxzoom) || ee.push({ command: Oi.setLayerZoomRange, args: [ve, Oe.minzoom, Oe.maxzoom] }), Pe)
                        Pe.hasOwnProperty(He) && He !== "layout" && He !== "paint" && He !== "filter" && He !== "metadata" && He !== "minzoom" && He !== "maxzoom" && He !== "slot" && (He.indexOf("paint.") === 0 ? Ot(Pe[He], Oe[He], ee, ve, He.slice(6), Oi.setPaintProperty) : i.bn(Pe[He], Oe[He]) || ee.push({ command: Oi.setLayerProperty, args: [ve, He, Oe[He]] }));
                      for (He in Oe)
                        Oe.hasOwnProperty(He) && !Pe.hasOwnProperty(He) && He !== "layout" && He !== "paint" && He !== "filter" && He !== "metadata" && He !== "minzoom" && He !== "maxzoom" && He !== "slot" && (He.indexOf("paint.") === 0 ? Ot(Pe[He], Oe[He], ee, ve, He.slice(6), Oi.setPaintProperty) : i.bn(Pe[He], Oe[He]) || ee.push({ command: Oi.setLayerProperty, args: [ve, He, Oe[He]] }));
                    } else
                      ee.push({ command: Oi.removeLayer, args: [ve] }), Xe = pe[pe.lastIndexOf(ve) + 1], ee.push({ command: Oi.addLayer, args: [Oe, Xe] });
              }(G, z.layers, R);
            } catch (F) {
              console.warn("Unable to compute style diff:", F), R = [{ command: Oi.setStyle, args: [z] }];
            }
            return R;
          }(this.serialize(), t).filter((T) => !(T.command in td));
          if (h.length === 0)
            return !1;
          const _ = h.filter((T) => !(T.command in Hh));
          if (_.length > 0)
            throw new Error(`Unimplemented: ${_.map((T) => T.command).join(", ")}.`);
          const y = [];
          return h.forEach((T) => {
            y.push(this[T.command].apply(this, T.args));
          }), s && Promise.all(y).then(s), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), !0;
        }
        addImage(t, s) {
          return this.getImage(t) ? this.fire(new i.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, this.scope, s), this._afterImageUpdated(t), this);
        }
        updateImage(t, s, h = !1) {
          this.imageManager.updateImage(t, this.scope, s), h && this._afterImageUpdated(t);
        }
        getImage(t) {
          return this.imageManager.getImage(t, this.scope);
        }
        removeImage(t) {
          return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new i.y(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t) {
          this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new i.z("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(t, s, h = {}) {
          return this._checkLoaded(), this._validate(Be, `models.${t}`, s, null, h) || (this.modelManager.addModel(t, s, this.scope), this._changes.setDirty()), this;
        }
        hasModel(t) {
          return this.modelManager.hasModel(t, this.scope);
        }
        removeModel(t) {
          return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new i.y(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t, s, h = {}) {
          if (this._checkLoaded(), this.getOwnSource(t) !== void 0)
            throw new Error(`There is already a source with ID "${t}".`);
          if (!s.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(Jn, `sources.${t}`, s, null, h))
            return;
          this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
          const _ = Go(t, s, this.dispatcher, this);
          _.scope = this.scope, _.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(_.id), source: _.serialize(), sourceId: _.id }));
          const y = (T) => {
            const z = (T ? "symbol:" : "other:") + _.id, R = i.aC(z, this.scope), F = this._sourceCaches[z] = new sr(R, _, T);
            (T ? this._symbolSourceCaches : this._otherSourceCaches)[_.id] = F, F.onAdd(this.map);
          };
          y(!1), s.type !== "vector" && s.type !== "geojson" || y(!0), _.onAdd && _.onAdd(this.map), h.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t) {
          this._checkLoaded();
          const s = this.getOwnSource(t);
          if (!s)
            throw new Error("There is no source with this ID");
          for (const _ in this._layers)
            if (this._layers[_].source === t)
              return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while layer "${_}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t)
            return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
          const h = this.getOwnSourceCaches(t);
          for (const _ of h) {
            const y = i.cq(_.id);
            delete this._sourceCaches[y], this._changes.discardSourceCacheUpdate(_.id), _.fire(new i.z("data", { sourceDataType: "metadata", dataType: "source", sourceId: _.getSource().id })), _.setEventedParent(null), _.clearTiles();
          }
          return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), s.setEventedParent(null), s.onRemove && s.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(t, s) {
          this._checkLoaded(), this.getOwnSource(t).setData(s), this._changes.setDirty();
        }
        getOwnSource(t) {
          const s = this.getOwnSourceCache(t);
          return s && s.getSource();
        }
        getOwnSources() {
          const t = [];
          for (const s in this._otherSourceCaches) {
            const h = this.getOwnSourceCache(s);
            h && t.push(h.getSource());
          }
          return t;
        }
        areTilesLoaded() {
          const t = this._mergedSourceCaches;
          for (const s in t) {
            const h = t[s]._tiles;
            for (const _ in h) {
              const y = h[_];
              if (y.state !== "loaded" && y.state !== "errored")
                return !1;
            }
          }
          return !0;
        }
        setLights(t) {
          if (this._checkLoaded(), !t)
            return delete this.ambientLight, void delete this.directionalLight;
          const s = this._getTransitionParameters();
          for (const _ of t) {
            if (this._validate(Ls, "lights", _))
              return;
            switch (_.type) {
              case "ambient":
                if (this.ambientLight) {
                  const y = this.ambientLight;
                  y.set(_), y.updateTransitions(s);
                } else
                  this.ambientLight = new ps(_, $i || ($i = new i.a5({ color: new i.a6(i.a3.properties_light_ambient.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_ambient.intensity) })), this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const y = this.directionalLight;
                  y.set(_), y.updateTransitions(s);
                } else
                  this.directionalLight = new ps(_, Hi || (Hi = new i.a5({ direction: new i.ak(i.a3.properties_light_directional.direction), color: new i.a6(i.a3.properties_light_directional.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_directional.intensity), "cast-shadows": new i.a6(i.a3.properties_light_directional["cast-shadows"]), "shadow-quality": new i.a6(i.a3.properties_light_directional["shadow-quality"]), "shadow-intensity": new i.a6(i.a3.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
            }
          }
          const h = new i.a8(this.z || 0, s);
          this.ambientLight && this.ambientLight.recalculate(h), this.directionalLight && this.directionalLight.recalculate(h), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const t = this.directionalLight, s = this.ambientLight;
          if (!t || !s)
            return;
          const h = (Z) => 0.2126 * (Z[0] <= 0.03928 ? Z[0] / 12.92 : Math.pow((Z[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (Z[1] <= 0.03928 ? Z[1] / 12.92 : Math.pow((Z[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (Z[2] <= 0.03928 ? Z[2] / 12.92 : Math.pow((Z[2] + 0.055) / 1.055, 2.4)), _ = t.properties.get("color").toRenderColor(null).toArray01(), y = t.properties.get("intensity"), T = t.properties.get("direction"), z = 1 - i.cb(T.x, T.y, T.z)[2] / 90, R = h(_) * y * z, F = s.properties.get("color").toRenderColor(null).toArray01(), N = s.properties.get("intensity"), G = h(F) * N;
          return Number(((R + G) / 2).toFixed(6));
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights())
            return null;
          const t = [];
          return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t) {
          if (!t)
            return this;
          if (i.cr(t)) {
            const s = i.cs(t), h = this.fragments.find(({ id: y }) => y === s);
            if (!h)
              throw new Error(`Style import '${t}' not found`);
            const _ = i.cq(t);
            return h.style.getFragmentStyle(_);
          }
          {
            const s = this.fragments.find(({ id: h }) => h === t);
            if (!s)
              throw new Error(`Style import '${t}' not found`);
            return s.style;
          }
        }
        setFeaturesetSelectors(t) {
          if (!t)
            return;
          const s = {}, h = (_, y = "") => `${_}::${y}`;
          this.featuresetSelectors = {};
          for (const _ in t) {
            const y = this.featuresetSelectors[_] = [];
            for (const T of t[_].selectors) {
              if (T.featureNamespace) {
                const R = this.getOwnLayer(T.layer);
                if (!R) {
                  i.w(`Layer is undefined for selector: ${T.layer}`);
                  continue;
                }
                const F = h(R.source, R.sourceLayer);
                if (F in s && s[F] !== T.featureNamespace) {
                  i.w(`"featureNamespace ${T.featureNamespace} of featureset ${_}'s selector is not associated to the same source, skip this selector`);
                  continue;
                }
                s[F] = T.featureNamespace;
              }
              let z;
              if (T.properties)
                for (const R in T.properties) {
                  const F = i.U(T.properties[R]);
                  F.result === "success" && (z = z || {}, z[R] = F.value);
                }
              y.push({ layerId: T.layer, namespace: T.featureNamespace, properties: z });
            }
          }
        }
        getFeaturesetDescriptors(t) {
          const s = this.getFragmentStyle(t);
          if (!s || !s.stylesheet.featuresets)
            return [];
          const h = [];
          for (const _ in s.stylesheet.featuresets)
            h.push({ featuresetId: _, importId: s.scope ? s.scope : void 0 });
          return h;
        }
        getFeaturesetLayers(t, s) {
          const h = this.getFragmentStyle(s), _ = h.stylesheet.featuresets;
          if (!_ || !_[t])
            return this.fire(new i.y(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];
          const y = [];
          for (const T of _[t].selectors) {
            const z = h.getOwnLayer(T.layer);
            z && y.push(z);
          }
          return y;
        }
        getConfigProperty(t, s) {
          const h = this.getFragmentStyle(t);
          if (!h)
            return null;
          const _ = i.aC(s, h.scope), y = h.options.get(_), T = y ? y.value || y.default : null;
          return T ? T.serialize() : null;
        }
        setConfigProperty(t, s, h) {
          const _ = this.getFragmentStyle(t);
          if (!_)
            return;
          const y = _.stylesheet.indoor ? $l(_.stylesheet.schema) : _.stylesheet.schema;
          if (!y || !y[s])
            return;
          const T = i.U(h);
          if (T.result !== "success")
            return void Ao(this, T.value);
          const z = T.value.expression, R = i.aC(s, _.scope), F = _.options.get(R);
          if (!F)
            return;
          let N;
          const { minValue: G, maxValue: Z, stepValue: W, type: te, values: ee } = y[s], se = i.U(y[s].default);
          se.result === "success" && (N = se.value.expression), N ? (this.options.set(R, { ...F, value: z, default: N, minValue: G, maxValue: Z, stepValue: W, type: te, values: ee }), this.updateConfigDependencies(s)) : this.fire(new i.y(new Error(`No schema defined for the config option "${s}" in the "${t}" fragment.`)));
        }
        getConfig(t) {
          const s = this.getFragmentStyle(t);
          if (!s)
            return null;
          const h = s.stylesheet.schema;
          if (!h)
            return null;
          const _ = {};
          for (const y in h) {
            const T = i.aC(y, s.scope), z = s.options.get(T), R = z ? z.value || z.default : null;
            _[y] = R ? R.serialize() : null;
          }
          return _;
        }
        setConfig(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h.updateConfig(s, h.stylesheet.schema), this.updateConfigDependencies());
        }
        getSchema(t) {
          const s = this.getFragmentStyle(t);
          return s ? s.stylesheet.schema : null;
        }
        setSchema(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h.stylesheet.schema = s, h.updateConfig(h._config, s), this.updateConfigDependencies());
        }
        updateConfig(t, s) {
          if (this._config = t, t || s)
            if (s)
              for (const h in s) {
                let _, y;
                const T = i.U(s[h].default);
                if (T.result === "success" && (_ = T.value.expression), t && t[h] !== void 0) {
                  const Z = i.U(t[h]);
                  Z.result === "success" && (y = Z.value.expression);
                }
                const { minValue: z, maxValue: R, stepValue: F, type: N, values: G } = s[h];
                if (_) {
                  const Z = i.aC(h, this.scope);
                  this.options.set(Z, { default: _, value: y, minValue: z, maxValue: R, stepValue: F, type: N, values: G });
                } else
                  this.fire(new i.y(new Error(`No schema defined for config option "${h}".`)));
              }
            else
              this.fire(new i.y(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies(t) {
          for (const s of this._configDependentLayers) {
            const h = this.getLayer(s);
            if (h) {
              if (t && !h.configDependencies.has(t))
                continue;
              h.possiblyEvaluateVisibility(), this._updateLayer(h);
            }
          }
          this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((s) => {
            const h = s._styleColorTheme.colorThemeOverride ? s._styleColorTheme.colorThemeOverride : s._styleColorTheme.colorTheme;
            if (h) {
              const _ = s._evaluateColorThemeData(h);
              (!s._styleColorTheme.lut && _ !== "" || s._styleColorTheme.lut && _ !== s._styleColorTheme.lut.data) && s.setColorTheme(h);
            }
          }), this._changes.setDirty();
        }
        addLayer(t, s, h = {}) {
          this._checkLoaded();
          const _ = t.id;
          if (this._layers[_])
            return void this.fire(new i.y(new Error(`Layer with id "${_}" already exists on this map`)));
          let y;
          if (t.type === "custom") {
            if (Ao(this, i.ct(t)))
              return;
            y = i.cu(t, this.scope, this._styleColorTheme.lut, this.options);
          } else {
            if (typeof t.source == "object" && (this.addSource(_, t.source), t = i.cp(t), t = i.l(t, { source: _ })), this._validate(le, `layers.${_}`, t, { arrayIndex: -1 }, h))
              return;
            y = i.cu(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(y), y.setEventedParent(this, { layer: { id: _ } });
          }
          y.configDependencies.size !== 0 && this._configDependentLayers.add(y.fqid);
          let T = this._order.length;
          if (s) {
            const N = this._order.indexOf(s);
            if (N === -1)
              return void this.fire(new i.y(new Error(`Layer with id "${s}" does not exist on this map.`)));
            y.slot === this._layers[s].slot ? T = N : i.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(T, 0, _), this._layerOrderChanged = !0, this._layers[_] = y;
          const z = this.getOwnLayerSourceCache(y), R = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          z && y.canCastShadows() && R && (z.castsShadows = !0);
          const F = this._changes.getRemovedLayer(y);
          if (F && y.source && z && y.type !== "custom") {
            this._changes.discardLayerRemoval(y);
            const N = i.aC(y.source, y.scope);
            F.type !== y.type ? this._changes.updateSourceCache(N, "clear") : (this._changes.updateSourceCache(N, "reload"), z.pause());
          }
          this._updateLayer(y), y.onAdd && y.onAdd(this.map), y.scope = this.scope, this.mergeLayers();
        }
        moveLayer(t, s) {
          this._checkLoaded();
          const h = this._checkLayer(t);
          if (!h || t === s)
            return;
          const _ = this._order.indexOf(t);
          this._order.splice(_, 1);
          let y = this._order.length;
          if (s) {
            const T = this._order.indexOf(s);
            if (T === -1)
              return void this.fire(new i.y(new Error(`Layer with id "${s}" does not exist on this map.`)));
            h.slot === this._layers[s].slot ? y = T : i.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(y, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
        }
        removeLayer(t) {
          this._checkLoaded();
          const s = this._checkLayer(t);
          if (!s)
            return;
          s.setEventedParent(null);
          const h = this._order.indexOf(t);
          this._order.splice(h, 1), delete this._layers[t], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(s.fqid), this._changes.removeLayer(s);
          const _ = this.getOwnLayerSourceCache(s);
          if (_ && _.castsShadows) {
            let y = !1;
            for (const T in this._layers)
              if (this._layers[T].source === s.source && this._layers[T].canCastShadows()) {
                y = !0;
                break;
              }
            _.castsShadows = y;
          }
          s.onRemove && s.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(t) {
          return this._layers[t];
        }
        hasLayer(t) {
          return t in this._mergedLayers;
        }
        hasLayerType(t) {
          for (const s in this._layers)
            if (this._layers[s].type === t)
              return !0;
          return !1;
        }
        setLayerZoomRange(t, s, h) {
          this._checkLoaded();
          const _ = this._checkLayer(t);
          _ && (_.minzoom === s && _.maxzoom === h || (s != null && (_.minzoom = s), h != null && (_.maxzoom = h), this._updateLayer(_)));
        }
        getSlots() {
          return this._checkLoaded(), this._mergedSlots;
        }
        setSlot(t, s) {
          this._checkLoaded();
          const h = this._checkLayer(t);
          h && h.slot !== s && (h.slot = s, this._updateLayer(h));
        }
        setFilter(t, s, h = {}) {
          this._checkLoaded();
          const _ = this._checkLayer(t);
          if (_ && !i.bn(_.filter, s))
            return s == null ? (_.filter = void 0, void this._updateLayer(_)) : void (this._validate(ge, `layers.${_.id}.filter`, s, { layerType: _.type }, h) || (_.filter = i.cp(s), this._updateLayer(_)));
        }
        getFilter(t) {
          const s = this._checkLayer(t);
          if (s)
            return i.cp(s.filter);
        }
        setLayoutProperty(t, s, h, _ = {}) {
          this._checkLoaded();
          const y = this._checkLayer(t);
          if (y && !i.bn(y.getLayoutProperty(s), h)) {
            if (h != null && (!_ || _.validate !== !1) && Ao(y, Ce.call(Zi, { key: `layers.${t}.layout.${s}`, layerType: y.type, objectKey: s, value: h, styleSpec: i.a3, style: { glyphs: !0, sprite: !0 } })))
              return;
            y.setLayoutProperty(s, h), y.configDependencies.size !== 0 && this._configDependentLayers.add(y.fqid), this._updateLayer(y);
          }
        }
        getLayoutProperty(t, s) {
          const h = this._checkLayer(t);
          if (h)
            return h.getLayoutProperty(s);
        }
        setPaintProperty(t, s, h, _ = {}) {
          this._checkLoaded();
          const y = this._checkLayer(t);
          if (!y || i.bn(y.getPaintProperty(s), h) || h != null && (!_ || _.validate !== !1) && Ao(y, Le.call(Zi, { key: `layers.${t}.paint.${s}`, layerType: y.type, objectKey: s, value: h, styleSpec: i.a3 })))
            return;
          const T = y.setPaintProperty(s, h);
          y.configDependencies.size !== 0 && this._configDependentLayers.add(y.fqid), T && this._updateLayer(y), this._changes.updatePaintProperties(y);
        }
        getPaintProperty(t, s) {
          const h = this._checkLayer(t);
          if (h)
            return h.getPaintProperty(s);
        }
        setFeatureState(t, s) {
          if (this._checkLoaded(), "target" in t) {
            if ("featuresetId" in t.target) {
              const { featuresetId: R, importId: F } = t.target, N = this.getFragmentStyle(F), G = N.getFeaturesetLayers(R);
              for (const { source: Z, sourceLayer: W } of G)
                N.setFeatureState({ id: t.id, source: Z, sourceLayer: W }, s);
            } else if ("layerId" in t.target) {
              const { layerId: R } = t.target, F = this.getLayer(R);
              this.setFeatureState({ id: t.id, source: F.source, sourceLayer: F.sourceLayer }, s);
            }
            return;
          }
          const h = t.source, _ = t.sourceLayer, y = this._checkSource(h);
          if (!y)
            return;
          const T = y.type;
          if (T === "geojson" && _)
            return void this.fire(new i.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if (T === "vector" && !_)
            return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided.")));
          const z = this.getOwnSourceCaches(h);
          for (const R of z)
            R.setFeatureState(_, t.id, s);
        }
        removeFeatureState(t, s) {
          if (this._checkLoaded(), "target" in t) {
            if ("featuresetId" in t.target) {
              const { featuresetId: R, importId: F } = t.target, N = this.getFragmentStyle(F), G = N.getFeaturesetLayers(R);
              for (const { source: Z, sourceLayer: W } of G)
                N.removeFeatureState({ id: t.id, source: Z, sourceLayer: W }, s);
            } else if ("layerId" in t.target) {
              const { layerId: R } = t.target, F = this.getLayer(R);
              this.removeFeatureState({ id: t.id, source: F.source, sourceLayer: F.sourceLayer }, s);
            }
            return;
          }
          const h = t.source, _ = this._checkSource(h);
          if (!_)
            return;
          const y = _.type, T = y === "vector" ? t.sourceLayer : void 0;
          if (y === "vector" && !T)
            return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (s && typeof t.id != "string" && typeof t.id != "number")
            return void this.fire(new i.y(new Error("A feature id is required to remove its specific state property.")));
          const z = this.getOwnSourceCaches(h);
          for (const R of z)
            R.removeFeatureState(T, t.id, s);
        }
        getFeatureState(t) {
          if (this._checkLoaded(), "target" in t) {
            let y;
            if ("featuresetId" in t.target) {
              const { featuresetId: T, importId: z } = t.target, R = this.getFragmentStyle(z), F = R.getFeaturesetLayers(T);
              for (const { source: N, sourceLayer: G } of F) {
                const Z = R.getFeatureState({ id: t.id, source: N, sourceLayer: G });
                if (Z && !y)
                  y = Z;
                else if (!i.bn(y, Z))
                  return void this.fire(new i.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
              }
            } else if ("layerId" in t.target) {
              const { layerId: T } = t.target, z = this.getLayer(T);
              y = this.getFeatureState({ id: t.id, source: z.source, sourceLayer: z.sourceLayer });
            }
            return y;
          }
          const s = t.source, h = t.sourceLayer, _ = this._checkSource(s);
          if (_) {
            if (_.type !== "vector" || h)
              return t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(s)[0].getFeatureState(h, t.id);
            this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(t) {
          return this.stylesheet.transition = i.l({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return i.l({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t = this.getTerrain(), s = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
          return i.cv({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: s, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (h) => h !== void 0);
        }
        _updateFilteredLayers(t) {
          for (const s of Object.values(this._mergedLayers))
            t(s) && this._updateLayer(s);
        }
        _updateLayer(t) {
          this._changes.updateLayer(t);
          const s = this.getLayerSourceCache(t), h = i.aC(t.source, t.scope), _ = this._changes.getUpdatedSourceCaches();
          t.source && !_[h] && s && s.getSource().type !== "raster" && (this._changes.updateSourceCache(h, "reload"), s.pause()), t.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(t) {
          const s = (z) => this._mergedLayers[z].is3D(), h = this.order, _ = {}, y = [];
          for (let z = h.length - 1; z >= 0; z--) {
            const R = h[z];
            if (s(R)) {
              _[R] = z;
              for (const F of t) {
                const N = F[R];
                if (N)
                  for (const G of N)
                    y.push(G);
              }
            }
          }
          y.sort((z, R) => R.intersectionZ - z.intersectionZ);
          const T = [];
          for (let z = h.length - 1; z >= 0; z--) {
            const R = h[z];
            if (s(R))
              for (let F = y.length - 1; F >= 0; F--) {
                const N = y[F].feature;
                if (N.layer && _[N.layer.id] < z)
                  break;
                T.push(N), y.pop();
              }
            else
              for (const F of t) {
                const N = F[R];
                if (N)
                  for (const G of N)
                    T.push(G.feature);
              }
          }
          return T;
        }
        queryRenderedFeatures(t, s, h) {
          let _;
          s && !Array.isArray(s) && s.filter && (this._validate(ge, "queryRenderedFeatures.filter", s.filter, null, s), _ = i.aZ(s.filter));
          const y = {}, T = (N) => {
            if (ja.has(N.type))
              return;
            const G = this.getOwnLayerSourceCache(N), Z = y[G.id] = y[G.id] || { sourceCache: G, layers: {}, has3DLayers: !1 };
            N.is3D() && (Z.has3DLayers = !0), Z.layers[N.fqid] = Z.layers[N.fqid] || { styleLayer: N, targets: [] }, Z.layers[N.fqid].targets.push({ filter: _ });
          };
          if (s && s.layers) {
            if (!Array.isArray(s.layers))
              return this.fire(new i.y(new Error("parameters.layers must be an Array."))), [];
            for (const N of s.layers) {
              const G = this._layers[N];
              if (!G)
                return this.fire(new i.y(new Error(`The layer '${N}' does not exist in the map's style and cannot be queried for features.`))), [];
              T(G);
            }
          } else
            for (const N in this._layers)
              T(this._layers[N]);
          const z = this._queryRenderedFeatures(t, y, h), R = this._flattenAndSortRenderedFeatures(z), F = [];
          for (const N of R)
            i.cs(N.layer.id) === this.scope && F.push(N);
          return F;
        }
        queryRenderedFeatureset(t, s, h) {
          let _;
          s && !Array.isArray(s) && s.filter && (this._validate(ge, "queryRenderedFeatures.filter", s.filter, null, s), _ = i.aZ(s.filter));
          const y = "mock", T = [];
          if (s && s.target)
            T.push({ ...s, targetId: y, filter: _ });
          else {
            const F = this.getFeaturesetDescriptors();
            for (const N of F)
              T.push({ targetId: y, filter: _, target: N });
            for (const { style: N } of this.fragments) {
              const G = N.getFeaturesetDescriptors();
              for (const Z of G)
                T.push({ targetId: y, filter: _, target: Z });
            }
          }
          const z = this.queryRenderedTargets(t, T, h), R = [];
          for (const F of z)
            for (const N of F.variants[y])
              R.push(new i.cw(F, N));
          return R;
        }
        queryRenderedTargets(t, s, h) {
          const _ = {}, y = (z, R, F, N) => {
            const G = _[R.id] = _[R.id] || { sourceCache: R, layers: {}, has3DLayers: !1 };
            G.layers[z.fqid] = G.layers[z.fqid] || { styleLayer: z, targets: [] }, z.is3D() && (G.has3DLayers = !0), G.layers[z.fqid].targets.push(N ? { ...F, namespace: N.namespace, properties: N.properties } : F);
          };
          for (const z of s)
            if ("featuresetId" in z.target) {
              const { featuresetId: R, importId: F } = z.target, N = this.getFragmentStyle(F), G = N.featuresetSelectors[R];
              if (!G) {
                this.fire(new i.y(new Error(`The featureset '${R}' does not exist in the map's style and cannot be queried for features.`)));
                continue;
              }
              for (const Z of G) {
                const W = N.getOwnLayer(Z.layerId);
                W && !ja.has(W.type) && y(W, N.getOwnLayerSourceCache(W), z, Z);
              }
            } else if ("layerId" in z.target) {
              const { layerId: R } = z.target, F = this.getLayer(R);
              if (!F || ja.has(F.type))
                continue;
              y(F, this.getLayerSourceCache(F), z);
            }
          const T = this._queryRenderedFeatures(t, _, h);
          return this._flattenAndSortRenderedFeatures(T);
        }
        _queryRenderedFeatures(t, s, h) {
          const _ = [], y = !!this.map._showQueryGeometry, T = vs.createFromScreenPoints(t, h);
          for (const z in s) {
            const R = aa(T, s[z], this._availableImages, h, y);
            Object.keys(R).length && _.push(R);
          }
          if (this.placement)
            for (const z in s) {
              if (!s[z].sourceCache._onlySymbols)
                continue;
              const R = Da(T.screenGeometry, s[z], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
              Object.keys(R).length && _.push(R);
            }
          return _;
        }
        querySourceFeatures(t, s) {
          const h = s && s.filter;
          h && this._validate(ge, "querySourceFeatures.filter", h, null, s);
          let _ = [];
          const y = this.getOwnSourceCaches(t);
          for (const T of y)
            _ = _.concat(Vi(T, s));
          return _;
        }
        addSourceType(t, s, h) {
          return hr.getSourceType(t) ? h(new Error(`A source type called "${t}" already exists.`)) : (hr.setSourceType(t, s), s.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: s.workerSourceURL }, h) : h(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(t, s, h = {}) {
          this._checkLoaded();
          const _ = this.light.getLight();
          let y = !1;
          for (const z in t)
            if (!i.bn(t[z], _[z])) {
              y = !0;
              break;
            }
          if (!y)
            return;
          const T = this._getTransitionParameters();
          this.light.setLight(t, s, h), this.light.updateTransitions(T);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        checkCanvasFingerprintNoise() {
          this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = i.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && i.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
        }
        setTerrain(t, s = 1) {
          if (this._checkLoaded(), !t)
            return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), s === 0 && delete this.terrain, t === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
          this.checkCanvasFingerprintNoise();
          let h = t;
          const _ = t.source == null;
          if (s === 1) {
            if (this.disableElevatedTerrain)
              return;
            if (typeof h.source == "object") {
              const z = "terrain-dem-src";
              this.addSource(z, h.source), h = i.cp(h), h = i.l(h, { source: z });
            }
            const y = i.l({}, h), T = {};
            if (this.terrain && _) {
              y.source = this.terrain.get().source;
              const z = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              z && (T.style = z.serialize());
            }
            if (this._validate(zs, "terrain", y, T))
              return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !_ || this.terrain && s !== this.terrain.drapeRenderMode) {
            if (!h)
              return;
            this._createTerrain(h, s), this.fire(new i.z("data", { dataType: "style" }));
          } else {
            const y = this.terrain, T = y.get();
            for (const z of Object.keys(i.a3.terrain))
              !h.hasOwnProperty(z) && i.a3.terrain[z].default && (h[z] = i.a3.terrain[z].default);
            for (const z in t)
              if (!i.bn(t[z], T[z])) {
                y.set(t, this.options), this.stylesheet.terrain = t;
                const R = this._getTransitionParameters({ duration: 0 });
                y.updateTransitions(R), this.fire(new i.z("data", { dataType: "style" }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
        }
        _createFog(t) {
          const s = this.fog = new Ki(t, this.map.transform, this.scope, this.options);
          this.stylesheet.fog = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _createSnow(t) {
          const s = this.snow = new Xn(t, this.map.transform, this.scope, this.options);
          this.stylesheet.snow = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _createRain(t) {
          const s = this.rain = new Gs(t, this.map.transform, this.scope, this.options);
          this.stylesheet.rain = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 && this.map._requestDomTask(() => {
            for (const t of this.map._markers)
              t._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t) {
          if (this._checkLoaded(), !t)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
          if (this.fog) {
            const s = this.fog;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.fog = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createFog(t);
          this._markersNeedUpdate = !0;
        }
        getSnow() {
          return this.snow ? this.snow.get() : null;
        }
        setSnow(t) {
          if (this._checkLoaded(), !t)
            return delete this.snow, void delete this.stylesheet.snow;
          if (this.snow) {
            const s = this.snow;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.snow = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createSnow(t);
          this._markersNeedUpdate = !0;
        }
        getRain() {
          return this.rain ? this.rain.get() : null;
        }
        setRain(t) {
          if (this._checkLoaded(), !t)
            return delete this.rain, void delete this.stylesheet.rain;
          if (this.rain) {
            const s = this.rain;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.rain = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createRain(t);
          this._markersNeedUpdate = !0;
        }
        _reloadColorTheme() {
          const t = () => {
            for (const _ in this._layers)
              this._layers[_].lut = this._styleColorTheme.lut;
            for (const _ in this._sourceCaches)
              this._sourceCaches[_].clearTiles();
          }, s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (!s)
            return this._styleColorTheme.lut = null, void t();
          const h = this._evaluateColorThemeData(s);
          this._loadColorTheme(h).then(() => {
            this.fire(new i.z("colorthemeset")), t();
          }).catch((_) => {
            i.w(`Couldn't set color theme: ${_}`);
          });
        }
        setColorTheme(t) {
          this._checkLoaded(), this._styleColorTheme.colorThemeOverride && i.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();
        }
        setImportColorTheme(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h._styleColorTheme.colorThemeOverride = s, h._reloadColorTheme());
        }
        _getTransitionParameters(t) {
          return { now: i.q.now(), transition: i.l(this.transition, t) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain)
            return;
          const t = [], s = [];
          for (const h of this._mergedOrder)
            this.isLayerDraped(this._mergedLayers[h]) ? t.push(h) : s.push(h);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...s);
        }
        _createTerrain(t, s) {
          const h = this.terrain = new it(t, s, this.scope, this.options);
          s === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const _ = this._getTransitionParameters({ duration: 0 });
          h.updateTransitions(_);
        }
        _force3DLayerUpdate() {
          for (const t in this._layers) {
            const s = this._layers[t];
            s.type === "fill-extrusion" && this._updateLayer(s);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const t in this._layers) {
            const s = this._layers[t];
            s.type === "symbol" && this._updateLayer(s);
          }
        }
        _validate(t, s, h, _, y = {}) {
          if (y && y.validate === !1)
            return !1;
          const T = i.l({}, this.serialize());
          return Ao(this, t.call(Zi, i.l({ key: s, style: T, value: h, styleSpec: i.a3 }, _)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), i.cx.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const t in this._mergedLayers)
            this._mergedLayers[t].setEventedParent(null);
          for (const t in this._mergedSourceCaches)
            this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(t) {
          const s = this.getSourceCaches(t);
          for (const h of s)
            h.clearTiles();
        }
        clearSources() {
          for (const t in this._mergedSourceCaches)
            this._mergedSourceCaches[t].clearTiles();
        }
        reloadSource(t) {
          const s = this.getSourceCaches(t);
          for (const h of s)
            h.resume(), h.reload();
        }
        reloadSources() {
          for (const t of this.getSources())
            t.reload && t.reload();
        }
        updateSources(t) {
          let s;
          this.directionalLight && (s = Yo(this.directionalLight));
          for (const h in this._mergedSourceCaches)
            this._mergedSourceCaches[h].update(t, void 0, void 0, s);
        }
        _generateCollisionBoxes() {
          for (const t in this._sourceCaches) {
            const s = this._sourceCaches[t];
            s.resume(), s.reload();
          }
        }
        _updatePlacement(t, s, h, _, y, T, z = !1) {
          let R = !1, F = !1;
          const N = {}, G = {};
          for (const Z of this._mergedOrder) {
            const W = this._mergedLayers[Z];
            if (W.type !== "symbol")
              continue;
            const te = i.aC(W.source, W.scope);
            let ee = N[te];
            if (!ee) {
              const oe = this.getLayerSourceCache(W);
              if (!oe)
                continue;
              const he = oe.getRenderableIds(!0).map((_e) => oe.getTileByID(_e));
              G[te] = he.slice(), ee = N[te] = he.sort((_e, pe) => pe.tileID.overscaledZ - _e.tileID.overscaledZ || (_e.tileID.isLessThan(pe.tileID) ? -1 : 1));
            }
            const se = this.crossTileSymbolIndex.addLayer(W, ee, s.center.lng, s.projection);
            R = R || se;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), z = z || this._layerOrderChanged || _ === 0, this._layerOrderChanged && this.fire(new i.z("neworder")), (z || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(i.q.now(), s.zoom)) && (this.pauseablePlacement = new $o(s, this._mergedOrder, z, h, _, y, this.placement, this.fog && s.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, N, G, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(i.q.now()), F = !0), R && this.pauseablePlacement.placement.setStale()), F || R) {
            this._buildingIndex.onNewFrame(s.zoom);
            for (let Z = 0; Z < this._mergedOrder.length; Z++) {
              const W = this._mergedLayers[this._mergedOrder[Z]];
              if (W.type !== "symbol")
                continue;
              const te = this.isLayerClipped(W);
              this.placement.updateLayerOpacities(W, N[i.aC(W.source, W.scope)], Z, te ? T : null);
            }
          }
          return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(i.q.now()) };
        }
        _releaseSymbolFadeTiles() {
          for (const t in this._sourceCaches)
            this._sourceCaches[t].releaseSymbolFadeTiles();
        }
        addImport(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports = this.stylesheet.imports || [];
          if (h.findIndex(({ id: y }) => y === t.id) !== -1)
            return void this.fire(new i.y(new Error(`Import with id '${t.id}' already exists in the map's style.`)));
          if (!s)
            return h.push(t), this._loadImports([t], !0);
          const _ = h.findIndex(({ id: y }) => y === s);
          return _ === -1 && this.fire(new i.y(new Error(`Import with id "${s}" does not exist on this map.`))), this.stylesheet.imports = h.slice(0, _).concat(t).concat(h.slice(_)), this._loadImports([t], !0, s);
        }
        updateImport(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports || [], _ = this.getImportIndex(t);
          return _ === -1 ? this : typeof s == "string" ? (this.setImportUrl(t, s), this) : (s.url && s.url !== h[_].url && this.setImportUrl(t, s.url), i.bn(s.config, h[_].config) || this.setImportConfig(t, s.config), i.bn(s.data, h[_].data) || this.setImportData(t, s.data), this);
        }
        moveImport(t, s) {
          this._checkLoaded();
          let h = this.stylesheet.imports || [];
          const _ = this.getImportIndex(t);
          if (_ === -1)
            return this;
          const y = this.getImportIndex(s);
          if (y === -1)
            return this;
          const T = h[_], z = this.fragments[_];
          return h = h.filter(({ id: R }) => R !== t), this.fragments = this.fragments.filter(({ id: R }) => R !== t), this.stylesheet.imports = h.slice(0, y).concat(T).concat(h.slice(y)), this.fragments = this.fragments.slice(0, y).concat(z).concat(this.fragments.slice(y)), this.mergeLayers(), this;
        }
        setImportUrl(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports || [], _ = this.getImportIndex(t);
          if (_ === -1)
            return this;
          h[_].url = s;
          const y = this.fragments[_];
          return y.style = this._createFragmentStyle(h[_]), y.style.on("style.import.load", () => this.mergeAll()), y.style.loadURL(s), this;
        }
        setImportData(t, s) {
          this._checkLoaded();
          const h = this.getImportIndex(t), _ = this.stylesheet.imports || [];
          return h === -1 ? this : s ? (this.fragments[h].style.setState(s), this._reloadImports(), this) : (delete _[h].data, this.setImportUrl(t, _[h].url));
        }
        setImportConfig(t, s) {
          this._checkLoaded();
          const h = this.getImportIndex(t), _ = this.stylesheet.imports || [];
          if (h === -1)
            return this;
          s ? _[h].config = s : delete _[h].config;
          const y = this.fragments[h], T = y.style.stylesheet && y.style.stylesheet.schema;
          return y.config = s, y.style.updateConfig(s, T), this.updateConfigDependencies(), this;
        }
        removeImport(t) {
          this._checkLoaded();
          const s = this.stylesheet.imports || [], h = this.getImportIndex(t);
          h !== -1 && (s.splice(h, 1), this.fragments[h].style._remove(), this.fragments.splice(h, 1), this._reloadImports());
        }
        getImportIndex(t) {
          const s = (this.stylesheet.imports || []).findIndex((h) => h.id === t);
          return s === -1 && this.fire(new i.y(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), s;
        }
        getLayer(t) {
          return this._mergedLayers[t];
        }
        getSources() {
          const t = [];
          for (const s in this._mergedOtherSourceCaches) {
            const h = this._mergedOtherSourceCaches[s];
            h && t.push(h.getSource());
          }
          return t;
        }
        getSource(t, s) {
          const h = this.getSourceCache(t, s);
          return h && h.getSource();
        }
        getLayerSource(t) {
          const s = this.getLayerSourceCache(t);
          return s && s.getSource();
        }
        getSourceCache(t, s) {
          const h = i.aC(t, s);
          return this._mergedOtherSourceCaches[h];
        }
        getLayerSourceCache(t) {
          const s = i.aC(t.source, t.scope);
          return t.type === "symbol" ? this._mergedSymbolSourceCaches[s] : this._mergedOtherSourceCaches[s];
        }
        getSourceCaches(t) {
          if (t == null)
            return Object.values(this._mergedSourceCaches);
          const s = [];
          return this._mergedOtherSourceCaches[t] && s.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && s.push(this._mergedSymbolSourceCaches[t]), s;
        }
        updateSourceCaches() {
          const t = this._changes.getUpdatedSourceCaches();
          for (const s in t) {
            const h = t[s];
            h === "reload" ? this.reloadSource(s) : h === "clear" && this.clearSource(s);
          }
        }
        updateLayers(t) {
          const s = this._changes.getUpdatedPaintProperties();
          for (const h of s) {
            const _ = this.getLayer(h);
            _ && _.updateTransitions(t);
          }
        }
        getImages(t, s, h) {
          this.imageManager.getImages(s.icons, s.scope, h), this._updateTilesForChangedImages();
          const _ = (y) => {
            y && y.setDependencies(s.tileID.key, s.type, s.icons);
          };
          _(this._otherSourceCaches[s.source]), _(this._symbolSourceCaches[s.source]);
        }
        rasterizeImages(t, s, h) {
          this.imageManager.rasterizeImages(s, h);
        }
        getGlyphs(t, s, h) {
          this.glyphManager.getGlyphs(s.stacks, s.scope, h);
        }
        getResource(t, s, h) {
          return i.cy(s, h);
        }
        getOwnSourceCache(t) {
          return this._otherSourceCaches[t];
        }
        getOwnLayerSourceCache(t) {
          return t.type === "symbol" ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source];
        }
        getOwnSourceCaches(t) {
          const s = [];
          return this._otherSourceCaches[t] && s.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && s.push(this._symbolSourceCaches[t]), s;
        }
        _isSourceCacheLoaded(t) {
          const s = this.getOwnSourceCaches(t);
          return s.length === 0 ? (this.fire(new i.y(new Error(`There is no source with ID '${t}'`))), !1) : s.every((h) => h.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        isLayerClipped(t, s) {
          if (!this._clipLayerPresent && t.type !== "fill-extrusion")
            return !1;
          const h = t.type === "fill-extrusion" && t.sourceLayer === "building";
          if (t.is3D()) {
            if (h || s && s.type === "batched-model" || t.type === "model")
              return !0;
          } else if (t.type === "symbol")
            return !0;
          return !1;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.fragments.forEach((t) => {
            t.style._remove();
          }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      hr.getSourceType = function(c) {
        return no[c];
      }, hr.setSourceType = function(c, t) {
        no[c] = t;
      }, hr.registerForPluginStateChange = i.ch;
      var Zc = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, Hc = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`, xr = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`, Ko = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Xl = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, Jr = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, Yl = `highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}
#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {
#ifdef FOG_DITHERING
vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);
#else
return color;
#endif
}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, Kl = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, ya = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`, ro = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, xl = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef TEXTURE_GATHER
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
      const kr = [];
      ao(Zc, kr), ao(xr, kr), ao(Hc, kr);
      const oo = { "_prelude_fog.vertex.glsl": Jr, "_prelude_terrain.vertex.glsl": Xl, "_prelude_shadow.vertex.glsl": ro, "_prelude_fog.fragment.glsl": Yl, "_prelude_shadow.fragment.glsl": xl, "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`, "_prelude_raster_array.glsl": Kl, "_prelude_raster_particle.glsl": ya }, Jo = {};
      Ti("", Xl), Ti(Yl, Jr), Ti(xl, ro), Ti(Kl, ""), Ti(ya, "");
      const Jl = Ti(Hc, xr), Qr = Zc;
      var vl = { background: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), circle: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: Ti("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ti(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: Ti(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ti("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: Ti("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: Ti("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), fill: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`), fillOutline: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionDepth: Ti(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`), fillExtrusionPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), groundShadow: Ti(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`), fillExtrusionGroundEffect: Ti(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), hillshadePrepare: Ti(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec2 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec4 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
halfwidth=(u_width_scale*a_z_offset_width.y)/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);
#else
v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), linePattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec4 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec2 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec4 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec4 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
float a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), raster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`), rasterParticle: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), rasterParticleDraw: Ti("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`), rasterParticleTexture: Ti("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Ti(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Ti(`#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#else
z+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#endif
}`), terrainRaster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`), terrainDepth: Ti("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`), skybox: Ti(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Ko), skyboxGradient: Ti(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Ko), skyboxCapture: Ti(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: Ti(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;
#ifndef NATIVE
c=dither(c,gl_FragCoord.xy+u_temporal_offset);
#endif
glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`), model: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`), modelDepth: Ti(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`), stars: Ti(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`), snowParticle: Ti("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`), rainParticle: Ti("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`), vignette: Ti("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Ti("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`) };
      function ao(c, t) {
        const s = c.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
        for (let h of s)
          if (h = h.trim(), h[0] === "#" && h.includes("if") && !h.includes("endif")) {
            h = h.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const _ = h.split(" ");
            for (const y of _)
              t.includes(y) || t.push(y);
          }
      }
      function Ti(c, t) {
        const s = /#include\s+"([^"]+)"/g, h = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let _ = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        _ && (_ = _.map((F) => {
          const N = F.split(" ");
          return N[N.length - 1];
        }), _ = [...new Set(_)]);
        const y = {}, T = [], z = [];
        if (c = c.replace(s, (F, N) => (z.push(N), "")), (t = t.replace(s, (F, N) => (T.push(N), ""))).includes("flat out"))
          return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
        let R = [...kr];
        ao(c, R), ao(t, R);
        for (const F of [...T, ...z])
          oo[F] || console.error(`Undefined include: ${F}`), Jo[F] || (Jo[F] = [], ao(oo[F], Jo[F])), R = [...R, ...Jo[F]];
        return { fragmentSource: c = c.replace(h, (F, N, G, Z, W) => (y[W] = !0, N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
in ${G} ${Z} ${W};
#else
uniform ${G} ${Z} u_${W};
#endif
` : N === "initialize" ? `
#ifdef HAS_UNIFORM_u_${W}
    ${G} ${Z} ${W} = u_${W};
#endif
` : N === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    in ${G} ${Z} ${W};
#endif
` : N === "initialize-attribute" ? "" : void 0)), vertexSource: t = t.replace(h, (F, N, G, Z, W) => {
          const te = Z === "float" ? "vec2" : Z, ee = W.match(/color/) ? "color" : te;
          return N === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
in ${G} ${Z} a_${W};
#endif
` : y[W] ? N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
uniform lowp float u_${W}_t;
in ${G} ${te} a_${W};
out ${G} ${Z} ${W};
#else
uniform ${G} ${Z} u_${W};
#endif
` : N === "initialize" ? ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${W}
    ${W} = a_${W};
#else
    ${G} ${Z} ${W} = u_${W};
#endif
` : `
#ifndef HAS_UNIFORM_u_${W}
    ${W} = unpack_mix_${ee}(a_${W}, u_${W}_t);
#else
    ${G} ${Z} ${W} = u_${W};
#endif
` : N === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    in ${G} ${Z} a_${W};
    out ${G} ${Z} ${W};
#endif
` : N === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    ${W} = a_${W};
#endif
` : void 0 : N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
uniform lowp float u_${W}_t;
in ${G} ${te} a_${W};
#else
uniform ${G} ${Z} u_${W};
#endif
` : N === "define-instanced" ? ee === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${W}0;
in vec4 a_${W}1;
in vec4 a_${W}2;
in vec4 a_${W}3;
#else
uniform ${G} ${Z} u_${W};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${G} ${te} a_${W};
#else
uniform ${G} ${Z} u_${W};
#endif
` : N === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    ${G} ${Z} ${W} = a_${W};
#endif
` : ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${W}
    ${G} ${Z} ${W} = a_${W};
#else
    ${G} ${Z} ${W} = u_${W};
#endif
` : `
#ifndef HAS_UNIFORM_u_${W}
    ${G} ${Z} ${W} = unpack_mix_${ee}(a_${W}, u_${W}_t);
#else
    ${G} ${Z} ${W} = u_${W};
#endif
`;
        }), staticAttributes: _, usedDefines: R, vertexIncludes: T, fragmentIncludes: z };
      }
      class qh {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(t, s, h, _, y, T, z, R) {
          this.context = t;
          let F = this.boundPaintVertexBuffers.length !== _.length;
          for (let G = 0; !F && G < _.length; G++)
            this.boundPaintVertexBuffers[G] !== _[G] && (F = !0);
          let N = this.boundDynamicVertexBuffers.length !== z.length;
          for (let G = 0; !N && G < z.length; G++)
            this.boundDynamicVertexBuffers[G] !== z[G] && (N = !0);
          if (!this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== h || F || N || this.boundIndexBuffer !== y || this.boundVertexOffset !== T)
            this.freshBind(s, h, _, y, T, z, R);
          else {
            t.bindVertexArrayOES.set(this.vao);
            for (const G of z)
              G && (G.bind(), R && G.instanceCount && G.setVertexAttribDivisor(t.gl, s, R));
            y && y.dynamicDraw && y.bind();
          }
        }
        freshBind(t, s, h, _, y, T, z) {
          const R = t.numAttributes, F = this.context, N = F.gl;
          this.vao && this.destroy(), this.vao = F.gl.createVertexArray(), F.bindVertexArrayOES.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = h, this.boundIndexBuffer = _, this.boundVertexOffset = y, this.boundDynamicVertexBuffers = T, s.enableAttributes(N, t), s.bind(), s.setVertexAttribPointers(N, t, y);
          for (const G of h)
            G.enableAttributes(N, t), G.bind(), G.setVertexAttribPointers(N, t, y);
          for (const G of T)
            G && (G.enableAttributes(N, t), G.bind(), G.setVertexAttribPointers(N, t, y), z && G.instanceCount && G.setVertexAttribDivisor(N, t, z));
          _ && _.bind(), F.currentNumAttributes = R;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function bl(c, t) {
        const s = Math.pow(2, t.canonical.z), h = t.canonical.y;
        return [new i.aa(0, h / s).toLngLat().lat, new i.aa(0, (h + 1) / s).toLngLat().lat];
      }
      function Ga(c, t, s, h, _, y, T) {
        const z = c.context, R = z.gl, F = s.hillshadeFBO;
        if (!F)
          return;
        c.prepareDrawTile();
        const N = c.isTileAffectedByFog(t), G = c.getOrCreateProgram("hillshade", { overrideFog: N });
        z.activeTexture.set(R.TEXTURE0), R.bindTexture(R.TEXTURE_2D, F.colorAttachment.get());
        const Z = ((se, oe, he, _e) => {
          const pe = he.paint.get("hillshade-shadow-color"), Me = he.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none", xe = he.paint.get("hillshade-highlight-color"), we = he.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none", ve = he.paint.get("hillshade-accent-color"), Pe = he.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none", Oe = he.paint.get("hillshade-emissive-strength");
          let Xe = i.ai(he.paint.get("hillshade-illumination-direction"));
          if (he.paint.get("hillshade-illumination-anchor") === "viewport")
            Xe -= se.transform.angle;
          else if (se.style && se.style.enable3dLights() && se.style.directionalLight) {
            const ke = se.style.directionalLight.properties.get("direction"), Ne = i.cb(ke.x, ke.y, ke.z);
            Xe = i.ai(Ne[1]);
          }
          const He = !se.options.moving;
          return { u_matrix: _e || se.transform.calculateProjMatrix(oe.tileID.toUnwrapped(), He), u_image: 0, u_latrange: bl(0, oe.tileID), u_light: [he.paint.get("hillshade-exaggeration"), Xe], u_shadow: pe.toRenderColor(Me ? null : he.lut), u_highlight: xe.toRenderColor(we ? null : he.lut), u_emissive_strength: Oe, u_accent: ve.toRenderColor(Pe ? null : he.lut) };
        })(c, s, h, c.terrain ? t.projMatrix : null);
        c.uploadCommonUniforms(z, G, t.toUnwrapped());
        const { tileBoundsBuffer: W, tileBoundsIndexBuffer: te, tileBoundsSegments: ee } = c.getTileBoundsBuffers(s);
        G.draw(c, R.TRIANGLES, _, y, T, ti.disabled, Z, h.id, W, te, ee);
      }
      function Qo(c, t, s) {
        if (!t.needsDEMTextureUpload)
          return;
        const h = c.context, _ = h.gl;
        h.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || c.getTileTexture(s.stride);
        const y = s.getPixels();
        t.demTexture ? t.demTexture.update(y, { premultiply: !1 }) : t.demTexture = new i.T(h, y, _.R32F, { premultiply: !1 }), t.needsDEMTextureUpload = !1;
      }
      function qc(c, t, s) {
        const h = c.context, _ = h.gl;
        if (!t.dem)
          return;
        const y = t.dem;
        if (h.activeTexture.set(_.TEXTURE1), Qo(c, t, y), !t.demTexture)
          return;
        t.demTexture.bind(_.NEAREST, _.CLAMP_TO_EDGE);
        const T = y.dim;
        h.activeTexture.set(_.TEXTURE0);
        let z = t.hillshadeFBO;
        if (!z) {
          const Z = new i.T(h, { width: T, height: T, data: null }, _.RGBA8);
          Z.bind(_.LINEAR, _.CLAMP_TO_EDGE), z = t.hillshadeFBO = h.createFramebuffer(T, T, !0, "renderbuffer"), z.colorAttachment.set(Z.texture);
        }
        h.bindFramebuffer.set(z.framebuffer), h.viewport.set([0, 0, T, T]);
        const { tileBoundsBuffer: R, tileBoundsIndexBuffer: F, tileBoundsSegments: N } = c.getMercatorTileBoundsBuffers(), G = [];
        c.linearFloatFilteringSupported() && G.push("TERRAIN_DEM_FLOAT_FORMAT"), c.getOrCreateProgram("hillshadePrepare", { defines: G }).draw(c, _.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.disabled, ((Z, W) => {
          const te = W.stride, ee = i.ab.mat4.create();
          return i.ab.mat4.ortho(ee, 0, i.ag, -i.ag, 0, 0, 1), i.ab.mat4.translate(ee, ee, [0, -i.ag, 0]), { u_matrix: ee, u_image: 1, u_dimension: [te, te], u_zoom: Z.overscaledZ };
        })(t.tileID, y), s.id, R, F, N), t.needsHillshadePrepare = !1;
      }
      class gn {
        constructor(t) {
          this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(t) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Wh extends gn {
        getDefault() {
          return i.aj.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class $h extends gn {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
        }
      }
      class Ql extends gn {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
        }
      }
      class ec extends gn {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class tc extends gn {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Wc extends gn {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
        }
      }
      class $c extends gn {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const s = this.current;
          (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
        }
      }
      class Xc extends gn {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
        }
      }
      class id extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1;
        }
      }
      class p extends gn {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class P extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1;
        }
      }
      class B extends gn {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
        }
      }
      class X extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1;
        }
      }
      class ne extends gn {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO, t.ONE, t.ZERO];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class ye extends gn {
        getDefault() {
          return i.aj.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class We extends gn {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), this.current = t, this.dirty = !1);
        }
      }
      class at extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1;
        }
      }
      class ft extends gn {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
        }
      }
      class Rt extends gn {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
        }
      }
      let ii = class extends gn {
        getDefault() {
          return null;
        }
        set(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }
      };
      class Ci extends gn {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
        }
      }
      class Wi extends gn {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Hs extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ws extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Rs extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1;
        }
      }
      class ur extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Za extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          const s = this.gl;
          s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class nd extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), this.current = t, this.dirty = !1);
        }
      }
      class sd extends gn {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
        }
      }
      class rd extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class Xh extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class wl extends gn {
        constructor(t, s) {
          super(t), this.context = t, this.parent = s;
        }
        getDefault() {
          return null;
        }
      }
      class ic extends wl {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class es extends wl {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferRenderbuffer(s.FRAMEBUFFER, this.attachment(), s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Po extends wl {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferTexture2D(s.FRAMEBUFFER, this.attachment(), s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class Yh extends es {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      const Kh = (c, t, s) => ({ u_matrix: c, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: s }), Yc = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee) => ({ u_proj_matrix: Float32Array.from(c), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(h), u_merc_matrix: s, u_zoom_transition: _, u_merc_center: y, u_image0: 0, u_frustum_tl: T, u_frustum_tr: z, u_frustum_br: R, u_frustum_bl: F, u_globe_pos: N, u_globe_radius: G, u_viewport: Z, u_grid_matrix: ee ? Float32Array.from(ee) : new Float32Array(9), u_skirt_height: W, u_far_z_cutoff: te });
      function Ha(c, t) {
        return c != null && t != null && !(!c.hasData() || !t.hasData()) && c.demTexture != null && t.demTexture != null && c.tileID.key !== t.tileID.key;
      }
      const vr = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(c, t, s, h, _) {
          if (c in this.operations) {
            const y = this.operations[c];
            y.to.tileID.key !== s.tileID.key && (y.queued = s);
          } else
            this.operations[c] = { startTime: h, phase: 0, duration: _, from: t, to: s, queued: null };
        }
        getMorphValuesForProxy(c) {
          if (!(c in this.operations))
            return null;
          const t = this.operations[c];
          return { from: t.from, to: t.to, phase: t.phase };
        }
        update(c) {
          for (const t in this.operations) {
            const s = this.operations[t];
            for (s.phase = (c - s.startTime) / s.duration; s.phase >= 1 || !this._validOp(s); )
              if (!this._nextOp(s, c)) {
                delete this.operations[t];
                break;
              }
          }
        }
        _nextOp(c, t) {
          return !!c.queued && (c.from = c.to, c.to = c.queued, c.queued = null, c.phase = 0, c.startTime = t, !0);
        }
        _validOp(c) {
          return c.from.hasData() && c.to.hasData();
        }
      }(), Kc = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function xa(c, t, s) {
        if (t === 0)
          return 0;
        const h = t < 1 && s === 514 ? 0.25 / t : 1;
        return 6 * Math.pow(1.5, 22 - c) * Math.max(t, 1) * h;
      }
      function od(c, t) {
        const s = 1 << c.z;
        return !t && (c.x === 0 || c.x === s - 1) || c.y === 0 || c.y === s - 1;
      }
      const nc = (c) => ({ u_matrix: c });
      function Jh(c, t, s, h, _) {
        if (_ > 0) {
          const y = i.q.now(), T = (y - c.timeAdded) / _, z = t ? (y - t.timeAdded) / _ : -1, R = s.getSource(), F = h.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), N = !t || Math.abs(t.tileID.overscaledZ - F) > Math.abs(c.tileID.overscaledZ - F), G = N && c.refreshedUponExpiration ? 1 : i.aw(N ? T : 1 - z, 0, 1);
          return c.refreshedUponExpiration && T >= 1 && (c.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - G } : { opacity: G, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class qf extends sr {
        constructor(t) {
          const s = { type: "raster-dem", maxzoom: t.transform.maxZoom }, h = new i.D(i.ci(), null), _ = Go("mock-dem", s, h, t.style);
          super("mock-dem", _, !1), _.setEventedParent(this), this._sourceLoaded = !0;
        }
        _loadTile(t, s) {
          t.state = "loaded", s(null);
        }
      }
      class ad extends sr {
        constructor(t) {
          const s = Go("proxy", { type: "geojson", maxzoom: t.transform.maxZoom }, new i.D(i.ci(), null), t.style);
          super("proxy", s, !1), s.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t, s, h) {
          if (t.freezeTileCoverage)
            return;
          this.transform = t;
          const _ = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((y, T) => {
            if (y[T.key] = "", !this._tiles[T.key]) {
              const z = new Cr(T, this._source.tileSize * T.overscaleFactor(), t.tileZoom);
              z.state = "loaded", this._tiles[T.key] = z;
            }
            return y;
          }, {});
          for (const y in this._tiles)
            y in _ || (this.freeFBO(y), this._tiles[y].unloadVectorData(), delete this._tiles[y]);
        }
        freeFBO(t) {
          const s = this.proxyCachedFBO[t];
          if (s !== void 0) {
            const h = Object.values(s);
            this.renderCachePool.push(...h), delete this.proxyCachedFBO[t];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((t) => t.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Qh extends i.aG {
        constructor(t, s, h) {
          super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), this.proxyTileKey = s, this.projMatrix = h;
        }
      }
      class Wf extends i.cJ {
        constructor(t, s) {
          super(), this._debugParams = { sortTilesHiZFirst: !0, disableRenderCache: !1 }, t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
            this._style.map.triggerRepaint();
          }), t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
            this._style.map.triggerRepaint();
          }), t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
            this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
          }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [h, _, y] = function(R) {
            const F = new i.b4(), N = new i.aU(), G = 131;
            F.reserve(17161), N.reserve(33800);
            const Z = i.ag / 128, W = i.ag + Z / 2, te = W + Z;
            for (let se = -Z; se < te; se += Z)
              for (let oe = -Z; oe < te; oe += Z) {
                const he = oe < 0 || oe > W || se < 0 || se > W ? 24575 : 0, _e = i.aw(Math.round(oe), 0, i.ag), pe = i.aw(Math.round(se), 0, i.ag);
                F.emplaceBack(_e + he, pe);
              }
            const ee = (se, oe) => {
              const he = oe * G + se;
              N.emplaceBack(he + 1, he, he + G), N.emplaceBack(he + G, he + G + 1, he + 1);
            };
            for (let se = 1; se < 129; se++)
              for (let oe = 1; oe < 129; oe++)
                ee(oe, se);
            return [0, 129].forEach((se) => {
              for (let oe = 0; oe < 130; oe++)
                ee(oe, se), ee(se, oe);
            }), [F, N, 32768];
          }(), T = t.context;
          this.gridBuffer = T.createVertexBuffer(h, i.b6.members), this.gridIndexBuffer = T.createIndexBuffer(_), this.gridSegments = i.b7.simpleSegment(0, 0, h.length, _.length), this.gridNoSkirtSegments = i.b7.simpleSegment(0, 0, h.length, y), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new ad(s.map), this.orthoMatrix = i.ab.mat4.create(), i.ab.mat4.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, i.ag, 0, i.ag, 0, 1);
          const z = T.gl;
          this._overlapStencilMode = new ci({ func: z.GEQUAL, mask: 255 }, 0, 255, z.KEEP, z.KEEP, z.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = s, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new qf(s.map), this._pendingGroundEffectLayers = [];
        }
        set style(t) {
          t.on("data", this._onStyleDataEvent.bind(this)), this._style = t, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t, s, h) {
          if (t && t.terrain) {
            this._style !== t && (this.style = t, this._evaluationZoom = void 0);
            const _ = t.terrain.properties, y = t.terrain.drapeRenderMode === 0, T = t.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = i.q.now();
            const z = t.terrain && t.terrain.scope, R = _.get("source"), F = y ? this._mockSourceCache : t.getSourceCache(R, z);
            if (!F)
              return void i.w(`Couldn't find terrain source "${R}".`);
            if (this.sourceCache = F, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = T ? this.calculateExaggeration(s) : _.get("exaggeration"), !s.projection.requiresDraping && T && this._exaggeration === 0)
              return void this._disable();
            this.enabled = !0;
            const N = () => {
              this.sourceCache.used && i.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const G = this.getScaledDemTileSize();
              this.sourceCache.update(s, G, !0), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, N(), this._initializing = !0), N(), s.updateElevation(!0, h), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(s), this._emptyDEMTextureDirty = !0, this._previousZoom = s.zoom;
          } else
            this._disable();
        }
        calculateExaggeration(t) {
          if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1]))
            return this._style.terrain.getExaggeration(t.zoom);
          const s = this._previousCameraAltitude, h = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
          this._previousCameraAltitude = h;
          const _ = s != null ? h - s : Number.MAX_VALUE;
          if (Math.abs(_) < 2)
            return this._exaggeration;
          const y = t.zoom, T = this._style.terrain;
          if (!this._previousUpdateTimestamp)
            return T.getExaggeration(y);
          let z = y - this._previousZoom;
          const R = this._previousUpdateTimestamp;
          let F = y;
          this._evaluationZoom != null && (F = this._evaluationZoom, Math.abs(y - F) > 0.5 && (z = 0.5 * (y - F + z)), z * _ < 0 && (F += z)), this._evaluationZoom = F;
          const N = T.getExaggeration(F), G = N === T.getExaggeration(Math.max(0, F - 0.1));
          if (G && Math.abs(N - this._exaggeration) < 0.01)
            return N;
          let Z = Math.min(0.1, 375e-5 * (this._updateTimestamp - R));
          return (G || N < 0.1 || Math.abs(z) < 1e-4) && (Z = Math.min(0.2, 4 * Z)), i.af(this._exaggeration, N, Z);
        }
        resetTileLookupCache(t) {
          this._findCoveringTileCache[t] = {};
        }
        attenuationRange() {
          return this._attenuationRange;
        }
        getDemUpscale() {
          return this.proxySourceCache.getSource().tileSize / 128;
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(t) {
          t.coord && t.dataType === "source" ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const t in this._style._mergedSourceCaches)
              this._style._mergedSourceCaches[t].usedForTerrain = !1;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((t) => t.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this.enabled ? this._exaggeration : 0;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const t = 2 * this.proxySourceCache.getSource().tileSize;
          return [t, t];
        }
        set useVertexMorphing(t) {
          this._useVertexMorphing = t;
        }
        updateTileBinding(t) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const s = this.proxySourceCache, h = this.painter.transform;
          this._initializing && (this._initializing = h._centerAltitude === 0 && this.getAtPointOrZero(i.aa.fromLngLat(h.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
          const _ = this.proxyCoords = s.getIds().map((R) => {
            const F = s.getTileByID(R).tileID;
            return F.projMatrix = h.calculateProjMatrix(F.toUnwrapped()), F;
          });
          (function(R, F) {
            const N = F.transform.pointCoordinate(F.transform.getCameraPoint()), G = new i.P(N.x, N.y);
            R.sort((Z, W) => {
              if (W.overscaledZ - Z.overscaledZ)
                return W.overscaledZ - Z.overscaledZ;
              const te = new i.P(Z.canonical.x + (1 << Z.canonical.z) * Z.wrap, Z.canonical.y), ee = new i.P(W.canonical.x + (1 << W.canonical.z) * W.wrap, W.canonical.y), se = G.mult(1 << Z.canonical.z);
              return se.x -= 0.5, se.y -= 0.5, se.distSqr(te) - se.distSqr(ee);
            });
          })(_, this.painter);
          const y = this.proxyToSource || {};
          this.proxyToSource = {}, _.forEach((R) => {
            this.proxyToSource[R.key] = {};
          }), this.terrainTileForTile = {};
          const T = this._style._mergedSourceCaches;
          for (const R in T) {
            const F = T[R];
            if (!F.used || (F !== this.sourceCache && this.resetTileLookupCache(F.id), this._setupProxiedCoordsForOrtho(F, t[R], y), F.usedForTerrain))
              continue;
            const N = t[R];
            F.getSource().reparseOverscaled && this._assignTerrainTiles(N);
          }
          this.proxiedCoords[s.id] = _.map((R) => new Qh(R, R.key, this.orthoMatrix)), this._assignTerrainTiles(_), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(y), this.renderingToTexture = !1;
          const z = {};
          this._visibleDemTiles = [];
          for (const R of this.proxyCoords) {
            const F = this.terrainTileForTile[R.key];
            if (!F)
              continue;
            const N = F.tileID.key;
            N in z || (this._visibleDemTiles.push(F), z[N] = N);
          }
        }
        _assignTerrainTiles(t) {
          this._initializing || t.forEach((s) => {
            if (this.terrainTileForTile[s.key])
              return;
            const h = this._findTileCoveringTileID(s, this.sourceCache);
            h && (this.terrainTileForTile[s.key] = h);
          });
        }
        _prepareDEMTextures() {
          const t = this.painter.context, s = t.gl;
          for (const h in this.terrainTileForTile) {
            const _ = this.terrainTileForTile[h], y = _.dem;
            !y || _.demTexture && !_.needsDEMTextureUpload || (t.activeTexture.set(s.TEXTURE1), Qo(this.painter, _, y));
          }
        }
        _prepareDemTileUniforms(t, s, h, _) {
          if (!s || s.demTexture == null)
            return !1;
          const y = t.tileID.canonical, T = Math.pow(2, s.tileID.canonical.z - y.z), z = _ || "";
          return h[`u_dem_tl${z}`] = [y.x * T % 1, y.y * T % 1], h[`u_dem_scale${z}`] = T, !0;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        _getLoadedAreaMinimum() {
          if (!this.enabled)
            return 0;
          let t = 0;
          const s = this._visibleDemTiles.reduce((h, _) => {
            if (!_.dem)
              return h;
            const y = _.dem.tree.minimums[0];
            return y > 0 && t++, h + y;
          }, 0);
          return t ? s / t : 0;
        }
        _updateEmptyDEMTexture() {
          const t = this.painter.context, s = t.gl;
          t.activeTexture.set(s.TEXTURE2);
          const h = this._getLoadedAreaMinimum(), _ = new i.cK({ width: 1, height: 1 }, new Float32Array([h]));
          this._emptyDEMTextureDirty = !1;
          let y = this._emptyDEMTexture;
          return y ? y.update(_, { premultiply: !1 }) : y = this._emptyDEMTexture = new i.T(t, _, s.R32F, { premultiply: !1 }), y;
        }
        setupElevationDraw(t, s, h) {
          const _ = this.painter.context, y = _.gl, T = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
          T.u_exaggeration = this.exaggeration();
          let z = null, R = null, F = 1;
          if (h && h.morphing && this._useVertexMorphing) {
            const W = h.morphing.srcDemTile, te = h.morphing.dstDemTile;
            F = h.morphing.phase, W && te && (this._prepareDemTileUniforms(t, W, T, "_prev") && (R = W), this._prepareDemTileUniforms(t, te, T) && (z = te));
          }
          const N = (W) => W && W.demTexture && this.painter.linearFloatFilteringSupported() ? y.LINEAR : y.NEAREST;
          let G = null;
          var Z;
          if (this.enabled ? R && z ? (G = z.demTexture, _.activeTexture.set(y.TEXTURE4), R.demTexture.bind(N(R), y.CLAMP_TO_EDGE), T.u_dem_lerp = F) : (z = this.terrainTileForTile[t.tileID.key], G = this._prepareDemTileUniforms(t, z, T) ? z.demTexture : this.emptyDEMTexture) : G = this.emptyDEMTexture, _.activeTexture.set(y.TEXTURE2), G && (T.u_dem_size = (Z = G).size[0] === 1 ? 1 : Z.size[0] - 2, G.bind(N(z), y.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(h && h.useDepthForOcclusion, s, T), h && h.useMeterToDem && z) {
            const W = (1 << z.tileID.canonical.z) * i.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            T.u_meter_to_dem = W;
          }
          if (h && h.labelPlaneMatrixInv && (T.u_label_plane_matrix_inv = h.labelPlaneMatrixInv), s.setTerrainUniformValues(_, T), this.painter.transform.projection.name === "globe") {
            const W = this.globeUniformValues(this.painter.transform, t.tileID.canonical, h && h.useDenormalizedUpVectorScale);
            s.setGlobeUniformValues(_, W);
          }
        }
        globeUniformValues(t, s, h) {
          const _ = t.projection;
          return { u_tile_tl_up: _.upVector(s, 0, 0), u_tile_tr_up: _.upVector(s, i.ag, 0), u_tile_br_up: _.upVector(s, i.ag, i.ag), u_tile_bl_up: _.upVector(s, 0, i.ag), u_tile_up_scale: h ? i.cL(1) : _.upVectorScale(s, t.center.lat, t.worldSize).metersToTile };
        }
        renderToBackBuffer(t) {
          const s = this.painter, h = this.painter.context;
          t.length !== 0 && (h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), s.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(_, y, T, z, R) {
            if (_.transform.projection.name === "globe")
              (function(F, N, G, Z, W) {
                const te = F.context, ee = te.gl;
                let se, oe;
                const he = F.transform, _e = i.cC(F, te, he), pe = (ke, Ne) => {
                  if (oe === Ne)
                    return;
                  const st = [Kc[Ne], "PROJECTION_GLOBE_VIEW"];
                  _e && st.push("CUSTOM_ANTIALIASING");
                  const ut = F.isTileAffectedByFog(ke);
                  se = F.getOrCreateProgram("globeRaster", { defines: st, overrideFog: ut }), oe = Ne;
                }, Me = F.colorModeForRenderPass(), xe = new Wt(ee.LEQUAL, Wt.ReadWrite, F.depthRangeFor3D);
                vr.update(W);
                const we = i.cD(he), ve = [i.at(he.center.lng), i.aA(he.center.lat)], Pe = F.globeSharedBuffers, Oe = [he.width * i.q.devicePixelRatio, he.height * i.q.devicePixelRatio], Xe = Float32Array.from(he.globeMatrix), He = { useDenormalizedUpVectorScale: !0 };
                {
                  const ke = F.transform, Ne = xa(ke.zoom, N.exaggeration(), N.sourceCache._source.tileSize);
                  oe = -1;
                  const st = ee.TRIANGLES;
                  for (const ut of Z) {
                    const xt = G.getTile(ut), Ge = ci.disabled, lt = N.prevTerrainTileForTile[ut.key], Je = N.terrainTileForTile[ut.key];
                    Ha(lt, Je) && vr.newMorphing(ut.key, lt, Je, W, 250), te.activeTexture.set(ee.TEXTURE0), xt.texture && xt.texture.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
                    const _t = vr.getMorphValuesForProxy(ut.key), ct = _t ? 1 : 0;
                    _t && i.J(He, { morphing: { srcDemTile: _t.from, dstDemTile: _t.to, phase: i.cB(_t.phase) } });
                    const nt = i.cE(ut.canonical), Lt = i.cF(nt.getCenter().lat), bt = i.cG(ut.canonical, nt, Lt, ke.worldSize / ke._pixelsPerMercatorPixel), zt = i.bb(i.cH(ut.canonical)), Bt = Yc(ke.expandedFarZProjMatrix, Xe, we, zt, i.ae(ke.zoom), ve, ke.frustumCorners.TL, ke.frustumCorners.TR, ke.frustumCorners.BR, ke.frustumCorners.BL, ke.globeCenterInViewSpace, ke.globeRadius, Oe, Ne, ke._farZ, bt);
                    if (pe(ut, ct), se && (N.setupElevationDraw(xt, se, He), F.uploadCommonUniforms(te, se, ut.toUnwrapped()), Pe)) {
                      const [oi, $t, Xt] = Pe.getGridBuffers(Lt, Ne !== 0);
                      se.draw(F, st, xe, Ge, Me, ti.backCCW, Bt, "globe_raster", oi, $t, Xt);
                    }
                  }
                }
                if (Pe && (F.renderDefaultNorthPole || F.renderDefaultSouthPole)) {
                  const ke = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _e && ke.push("CUSTOM_ANTIALIASING"), se = F.getOrCreateProgram("globeRaster", { defines: ke });
                  for (const Ne of Z) {
                    const { x: st, y: ut, z: xt } = Ne.canonical, Ge = ut === 0, lt = ut === (1 << xt) - 1, [Je, _t, ct, nt] = Pe.getPoleBuffers(xt, !1);
                    if (nt && (Ge || lt)) {
                      const Lt = G.getTile(Ne);
                      te.activeTexture.set(ee.TEXTURE0), Lt.texture && Lt.texture.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
                      let bt = i.cI(xt, st, he);
                      const zt = i.bb(i.cH(Ne.canonical)), Bt = (oi, $t) => oi.draw(F, ee.TRIANGLES, xe, ci.disabled, Me, ti.disabled, Yc(he.expandedFarZProjMatrix, bt, bt, zt, 0, ve, he.frustumCorners.TL, he.frustumCorners.TR, he.frustumCorners.BR, he.frustumCorners.BL, he.globeCenterInViewSpace, he.globeRadius, Oe, 0, he._farZ), "globe_pole_raster", $t, ct, nt);
                      N.setupElevationDraw(Lt, se, He), F.uploadCommonUniforms(te, se, Ne.toUnwrapped()), Ge && F.renderDefaultNorthPole && Bt(se, Je), lt && F.renderDefaultSouthPole && (bt = i.ab.mat4.scale(i.ab.mat4.create(), bt, [1, -1, 1]), Bt(se, _t));
                    }
                  }
                }
              })(_, y, T, z, R);
            else {
              const F = _.context, N = F.gl;
              let G, Z;
              const W = _.shadowRenderer, te = Mo(_, _.longestCutoffRange), ee = (Me) => {
                if (Z === Me)
                  return;
                const xe = [];
                xe.push(Kc[Me]), te.shouldRenderCutoff && xe.push("RENDER_CUTOFF"), W && (xe.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), W.useNormalOffset && xe.push("NORMAL_OFFSET")), G = _.getOrCreateProgram("terrainRaster", { defines: xe }), Z = Me;
              }, se = _.colorModeForRenderPass(), oe = new Wt(N.LEQUAL, Wt.ReadWrite, _.depthRangeFor3D);
              vr.update(R);
              const he = _.transform, _e = xa(he.zoom, y.exaggeration(), y.sourceCache._source.tileSize);
              let pe = [0, 0, 0];
              if (W) {
                const Me = _.style.directionalLight, xe = _.style.ambientLight;
                Me && xe && (pe = cr(_.style, Me, xe));
              }
              {
                Z = -1;
                const Me = N.TRIANGLES, [xe, we] = [y.gridIndexBuffer, y.gridSegments];
                for (const ve of z) {
                  const Pe = T.getTile(ve), Oe = ci.disabled, Xe = y.prevTerrainTileForTile[ve.key], He = y.terrainTileForTile[ve.key];
                  Ha(Xe, He) && vr.newMorphing(ve.key, Xe, He, R, 250), F.activeTexture.set(N.TEXTURE0), Pe.texture && Pe.texture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
                  const ke = vr.getMorphValuesForProxy(ve.key), Ne = ke ? 1 : 0;
                  let st;
                  ke && (st = { morphing: { srcDemTile: ke.from, dstDemTile: ke.to, phase: i.cB(ke.phase) } });
                  const ut = Kh(ve.projMatrix, od(ve.canonical, he.renderWorldCopies) ? _e / 10 : _e, pe);
                  if (ee(Ne), !G)
                    continue;
                  y.setupElevationDraw(Pe, G, st);
                  const xt = ve.toUnwrapped();
                  W && W.setupShadows(xt, G), _.uploadCommonUniforms(F, G, xt, null, te), G.draw(_, Me, oe, Oe, se, ti.backCCW, ut, "terrain_raster", y.gridBuffer, xe, we);
                }
              }
            }
          }(s, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, s.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
        }
        renderBatch(t) {
          if (this._drapedRenderBatches.length === 0)
            return t + 1;
          this.renderingToTexture = !0;
          const s = this.painter, h = this.painter.context, _ = this.proxySourceCache, y = this.proxiedCoords[_.id], T = this._drapedRenderBatches.shift(), z = s.style.order, R = [];
          let F = 0;
          for (const N of y) {
            const G = _.getTileByID(N.proxyTileKey), Z = _.proxyCachedFBO[N.key] ? _.proxyCachedFBO[N.key][t] : void 0, W = Z !== void 0 ? _.renderCache[Z] : this.pool[F++], te = Z !== void 0;
            if (G.texture = W.tex, te && !W.dirty) {
              R.push(G.tileID);
              continue;
            }
            let ee;
            h.bindFramebuffer.set(W.fb.framebuffer), this.renderedToTile = !1, W.dirty && (h.clear({ color: i.aj.transparent, stencil: 0 }), W.dirty = !1);
            for (let se = T.start; se <= T.end; ++se) {
              const oe = s.style._mergedLayers[z[se]];
              if (oe.isHidden(s.transform.zoom))
                continue;
              const he = s.style.getLayerSourceCache(oe), _e = he ? this.proxyToSource[N.key][he.id] : [N];
              if (!_e)
                continue;
              const pe = _e;
              h.viewport.set([0, 0, W.fb.width, W.fb.height]), ee !== (he ? he.id : null) && (this._setupStencil(W, _e, oe, he), ee = he ? he.id : null), s.renderLayer(s, he, oe, pe);
            }
            if (this._drapedRenderBatches.length === 0)
              for (const se of this._pendingGroundEffectLayers) {
                const oe = s.style._mergedLayers[z[se]];
                if (oe.isHidden(s.transform.zoom))
                  continue;
                const he = s.style.getLayerSourceCache(oe), _e = he ? this.proxyToSource[N.key][he.id] : [N];
                if (!_e)
                  continue;
                const pe = _e;
                h.viewport.set([0, 0, W.fb.width, W.fb.height]), ee !== (he ? he.id : null) && (this._setupStencil(W, _e, oe, he), ee = he ? he.id : null), s.renderLayer(s, he, oe, pe);
              }
            this.renderedToTile ? (W.dirty = !0, R.push(G.tileID)) : te || --F, F === 5 && (F = 0, this.renderToBackBuffer(R));
          }
          return this.renderToBackBuffer(R), this.renderingToTexture = !1, h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), T.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(t) {
          const s = t.order.length;
          let h = -1, _ = s;
          for (let y = 0; y < s; ++y)
            this._style.isLayerDraped(t._mergedLayers[t.order[y]]) ? h = Math.max(h, y) : _ = Math.min(_, y);
          return _ > h;
        }
        getMinElevationBelowMSL() {
          let t = 0;
          return this._visibleDemTiles.filter((s) => s.dem).forEach((s) => {
            t = Math.min(t, s.dem.tree.minimums[0]);
          }), t === 0 ? t : (t - 30) * this._exaggeration;
        }
        raycast(t, s, h) {
          if (!this._visibleDemTiles)
            return null;
          const _ = this._visibleDemTiles.filter((y) => y.dem).map((y) => {
            const T = y.tileID, z = 1 << T.overscaledZ, { x: R, y: F } = T.canonical, N = R / z, G = (R + 1) / z, Z = F / z, W = (F + 1) / z;
            return { minx: N, miny: Z, maxx: G, maxy: W, t: y.dem.tree.raycastRoot(N, Z, G, W, t, s, h), tile: y };
          });
          _.sort((y, T) => (y.t !== null ? y.t : Number.MAX_VALUE) - (T.t !== null ? T.t : Number.MAX_VALUE));
          for (const y of _) {
            if (y.t == null)
              return null;
            const T = y.tile.dem.tree.raycast(y.minx, y.miny, y.maxx, y.maxy, t, s, h);
            if (T != null)
              return T;
          }
          return null;
        }
        _createFBO() {
          const t = this.painter.context, s = t.gl, h = this.drapeBufferSize;
          t.activeTexture.set(s.TEXTURE0);
          const _ = new i.T(t, { width: h[0], height: h[1], data: null }, s.RGBA8);
          _.bind(s.LINEAR, s.CLAMP_TO_EDGE);
          const y = t.createFramebuffer(h[0], h[1], !0, null);
          return y.colorAttachment.set(_.texture), y.depthAttachment = new Yh(t, y.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, h[0], h[1]), this._stencilRef = 0, y.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : y.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: y, tex: _, dirty: !1 };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._debugParams.disableRenderCache || this._style.hasLightTransitions())
            return !0;
          for (const t in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[t].hasTransition())
              return !0;
          return this._style.order.some((t) => {
            const s = this._style._mergedLayers[t], h = s.isHidden(this.painter.transform.zoom);
            return s.type === "hillshade" || s.type === "custom" ? !h && s.shouldRedrape() : !h && s.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t = !1;
          for (const h of this._style.getSources())
            if (h instanceof jo) {
              t = !0;
              break;
            }
          if (!t)
            return;
          const s = {};
          for (let h = 0; h < this._style.order.length; ++h) {
            const _ = this._style._mergedLayers[this._style.order[h]], y = this._style.getLayerSourceCache(_);
            if (y && !s[y.id] && !_.isHidden(this.painter.transform.zoom) && _.type === "line" && _.widthExpression() instanceof i.a9) {
              s[y.id] = !0;
              for (const T of this.proxyCoords) {
                const z = this.proxyToSource[T.key][y.id];
                if (z)
                  for (const R of z)
                    this._clearRenderCacheForTile(y.id, R);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let t = !1;
          for (const h in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[h]._source instanceof tn) {
              t = !0;
              break;
            }
          if (!t)
            return;
          const s = {};
          for (let h = 0; h < this._style.order.length; ++h) {
            const _ = this._style._mergedLayers[this._style.order[h]], y = this._style.getLayerSourceCache(_);
            if (!y || s[y.id] || _.isHidden(this.painter.transform.zoom) || _.type !== "raster")
              continue;
            const T = _.paint.get("raster-fade-duration");
            for (const z of this.proxyCoords) {
              const R = this.proxyToSource[z.key][y.id];
              if (R)
                for (const F of R) {
                  const N = Jh(y.getTile(F), y.findLoadedParent(F, 0), y, this.painter.transform, T);
                  (N.opacity !== 1 || N.mix !== 0) && this._clearRenderCacheForTile(y.id, F);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          this._style.updateDrapeFirstLayers();
          const t = this._style.order, s = t.length;
          if (s === 0)
            return;
          const h = [];
          this._pendingGroundEffectLayers = [];
          let _, y = 0, T = this._style._mergedLayers[t[y]];
          for (; !this._style.isLayerDraped(T) && T.isHidden(this.painter.transform.zoom) && ++y < s; )
            T = this._style._mergedLayers[t[y]];
          for (; y < s; ++y) {
            const z = this._style._mergedLayers[t[y]];
            z.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(z) ? _ === void 0 && (_ = y) : (z.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(y), _ !== void 0 && (h.push({ start: _, end: y - 1 }), _ = void 0)));
          }
          if (_ !== void 0 && h.push({ start: _, end: y - 1 }), h.length !== 0) {
            const z = h[h.length - 1];
            this._pendingGroundEffectLayers.every((R) => R > z.end) || i.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = h;
        }
        _setupRenderCache(t) {
          const s = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = !1, s.renderCache.length > s.renderCachePool.length) {
              const T = Object.values(s.proxyCachedFBO);
              s.proxyCachedFBO = {};
              for (let z = 0; z < T.length; ++z) {
                const R = Object.values(T[z]);
                s.renderCachePool.push(...R);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const h = this.proxyCoords, _ = this._tilesDirty;
          for (let T = h.length - 1; T >= 0; T--) {
            const z = h[T];
            if (s.getTileByID(z.key), s.proxyCachedFBO[z.key] !== void 0) {
              const R = t[z.key], F = this.proxyToSource[z.key];
              let N = 0;
              for (const G in F) {
                const Z = F[G], W = R[G];
                if (!W || W.length !== Z.length || Z.some((te, ee) => te !== W[ee] || _[G] && _[G].hasOwnProperty(te.key))) {
                  N = -1;
                  break;
                }
                ++N;
              }
              for (const G in s.proxyCachedFBO[z.key])
                s.renderCache[s.proxyCachedFBO[z.key][G]].dirty = N < 0 || N !== Object.values(R).length;
            }
          }
          const y = [...this._drapedRenderBatches];
          y.sort((T, z) => z.end - z.start - (T.end - T.start));
          for (const T of y)
            for (const z of h) {
              if (s.proxyCachedFBO[z.key])
                continue;
              let R = s.renderCachePool.pop();
              R === void 0 && s.renderCache.length < 50 && (R = s.renderCache.length, s.renderCache.push(this._createFBO())), R !== void 0 && (s.proxyCachedFBO[z.key] = {}, s.proxyCachedFBO[z.key][T.start] = R, s.renderCache[R].dirty = !0);
            }
          this._tilesDirty = {};
        }
        _setupStencil(t, s, h, _) {
          if (!_ || !this._sourceTilesOverlap[_.id])
            return void (this._overlapStencilType && (this._overlapStencilType = !1));
          const y = this.painter.context, T = y.gl;
          if (s.length <= 1)
            return void (this._overlapStencilType = !1);
          let z;
          if (h.isTileClipped())
            z = s.length, this._overlapStencilMode.test = { func: T.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(s[0].overscaledZ > s[s.length - 1].overscaledZ))
              return void (this._overlapStencilType = !1);
            z = 1, this._overlapStencilMode.test = { func: T.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + z > 255 && (y.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += z, this._overlapStencilMode.ref = this._stencilRef, h.isTileClipped() && this._renderTileClippingMasks(s, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
        }
        stencilModeForRTTOverlap(t) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : ci.disabled;
        }
        _renderTileClippingMasks(t, s) {
          const h = this.painter, _ = this.painter.context, y = _.gl;
          h._tileClippingMaskIDs = {}, _.setColorMode(bi.disabled), _.setDepthMode(Wt.disabled);
          const T = h.getOrCreateProgram("clippingMask");
          for (const z of t) {
            const R = h._tileClippingMaskIDs[z.key] = --s;
            T.draw(h, y.TRIANGLES, Wt.disabled, new ci({ func: y.ALWAYS, mask: 0 }, R, 255, y.KEEP, y.KEEP, y.REPLACE), bi.disabled, ti.disabled, nc(z.projMatrix), "$clipping", h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments);
          }
        }
        pointCoordinate(t) {
          const s = this.painter.transform;
          if (t.x < 0 || t.x > s.width || t.y < 0 || t.y > s.height)
            return null;
          const h = [t.x, t.y, 1, 1];
          i.ab.vec4.transformMat4(h, h, s.pixelMatrixInverse), i.ab.vec4.scale(h, h, 1 / h[3]), h[0] /= s.worldSize, h[1] /= s.worldSize;
          const _ = s._camera.position, y = i.bH(1, s.center.lat), T = [_[0], _[1], _[2] / y, 0], z = i.ab.vec3.subtract([], h.slice(0, 3), T);
          i.ab.vec3.normalize(z, z);
          const R = this.raycast(T, z, this._exaggeration);
          return R !== null && R ? (i.ab.vec3.scaleAndAdd(T, T, z, R), T[3] = T[2], T[2] *= y, T) : null;
        }
        _setupProxiedCoordsForOrtho(t, s, h) {
          if (t.getSource() instanceof i.aJ)
            return this._setupProxiedCoordsForImageSource(t, s, h);
          this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
          const _ = this.proxiedCoords[t.id] = [], y = this.proxyCoords;
          for (let R = 0; R < y.length; R++) {
            const F = y[R], N = this._findTileCoveringTileID(F, t);
            if (N) {
              const G = this._createProxiedId(F, N, h[F.key] && h[F.key][t.id]);
              _.push(G), this.proxyToSource[F.key][t.id] = [G];
            }
          }
          let T = !1;
          const z = /* @__PURE__ */ new Set();
          for (let R = 0; R < s.length; R++) {
            const F = t.getTile(s[R]);
            if (!F || !F.hasData())
              continue;
            const N = this._findTileCoveringTileID(F.tileID, this.proxySourceCache);
            if (N && N.tileID.canonical.z !== F.tileID.canonical.z) {
              const G = this.proxyToSource[N.tileID.key][t.id], Z = this._createProxiedId(N.tileID, F, h[N.tileID.key] && h[N.tileID.key][t.id]);
              G ? G.splice(G.length - 1, 0, Z) : this.proxyToSource[N.tileID.key][t.id] = [Z];
              const W = this.proxyToSource[N.tileID.key][t.id];
              z.has(W) || z.add(W), _.push(Z), T = !0;
            }
          }
          if (this._sourceTilesOverlap[t.id] = T, T && this._debugParams.sortTilesHiZFirst)
            for (const R of z)
              R.sort((F, N) => N.overscaledZ - F.overscaledZ);
        }
        _setupProxiedCoordsForImageSource(t, s, h) {
          if (!t.getSource().loaded())
            return;
          const _ = this.proxiedCoords[t.id] = [], y = this.proxyCoords, T = t.getSource(), z = T.tileID;
          if (!z)
            return;
          const R = new i.P(z.x, z.y)._div(1 << z.z), F = T.coordinates.map(i.aa.fromLngLat).reduce((G, Z) => (G.min.x = Math.min(G.min.x, Z.x - R.x), G.min.y = Math.min(G.min.y, Z.y - R.y), G.max.x = Math.max(G.max.x, Z.x - R.x), G.max.y = Math.max(G.max.y, Z.y - R.y), G), { min: new i.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new i.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), N = (G, Z) => {
            const W = G.wrap + G.canonical.x / (1 << G.canonical.z), te = G.canonical.y / (1 << G.canonical.z), ee = i.ag / (1 << G.canonical.z), se = Z.wrap + Z.canonical.x / (1 << Z.canonical.z), oe = Z.canonical.y / (1 << Z.canonical.z);
            return W + ee < se + F.min.x || W > se + F.max.x || te + ee < oe + F.min.y || te > oe + F.max.y;
          };
          for (let G = 0; G < y.length; G++) {
            const Z = y[G];
            for (let W = 0; W < s.length; W++) {
              const te = t.getTile(s[W]);
              if (!te || !te.hasData() || N(Z, te.tileID))
                continue;
              const ee = this._createProxiedId(Z, te, h[Z.key] && h[Z.key][t.id]), se = this.proxyToSource[Z.key][t.id];
              se ? se.push(ee) : this.proxyToSource[Z.key][t.id] = [ee], _.push(ee);
            }
          }
        }
        _createProxiedId(t, s, h) {
          let _ = this.orthoMatrix;
          if (h) {
            const y = h.find((T) => T.key === s.tileID.key);
            if (y)
              return y;
          }
          if (s.tileID.key !== t.key) {
            const y = t.canonical.z - s.tileID.canonical.z;
            let T, z, R;
            _ = i.ab.mat4.create();
            const F = s.tileID.wrap - t.wrap << t.overscaledZ;
            y > 0 ? (T = i.ag >> y, z = T * ((s.tileID.canonical.x << y) - t.canonical.x + F), R = T * ((s.tileID.canonical.y << y) - t.canonical.y)) : (T = i.ag << -y, z = i.ag * (s.tileID.canonical.x - (t.canonical.x + F << -y)), R = i.ag * (s.tileID.canonical.y - (t.canonical.y << -y))), i.ab.mat4.ortho(_, 0, T, 0, T, 0, 1), i.ab.mat4.translate(_, _, [z, R, 0]);
          }
          return new Qh(s.tileID, t.key, _);
        }
        _findTileCoveringTileID(t, s) {
          let h = s.getTile(t);
          if (h && h.hasData())
            return h;
          const _ = this._findCoveringTileCache[s.id], y = _[t.key];
          if (h = y ? s.getTileByID(y) : null, h && h.hasData() || y === null)
            return h;
          let T = h ? h.tileID : t, z = T.overscaledZ;
          const R = s.getSource().minzoom, F = [];
          if (!y) {
            const G = s.getSource().maxzoom;
            if (t.canonical.z >= G) {
              const Z = t.canonical.z - G;
              s.getSource().reparseOverscaled ? (z = Math.max(t.canonical.z + 2, s.transform.tileZoom), T = new i.aG(z, t.wrap, G, t.canonical.x >> Z, t.canonical.y >> Z)) : Z !== 0 && (z = G, T = new i.aG(z, t.wrap, G, t.canonical.x >> Z, t.canonical.y >> Z));
            }
            T.key !== t.key && (F.push(T.key), h = s.getTile(T));
          }
          const N = (G) => {
            F.forEach((Z) => {
              _[Z] = G;
            }), F.length = 0;
          };
          for (z -= 1; z >= R && (!h || !h.hasData()); z--) {
            h && N(h.tileID.key);
            const G = T.calculateScaledKey(z);
            if (h = s.getTileByID(G), h && h.hasData())
              break;
            const Z = _[G];
            if (Z === null)
              break;
            Z === void 0 ? F.push(G) : h = s.getTileByID(Z);
          }
          return N(h ? h.tileID.key : null), h && h.hasData() ? h : null;
        }
        findDEMTileFor(t) {
          return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = !0;
        }
        _clearRenderCacheForTile(t, s) {
          let h = this._tilesDirty[t];
          h || (h = this._tilesDirty[t] = {}), h[s.key] = !0;
        }
      }
      function $f(c, t, s) {
        const h = function(z, R, F) {
          const N = i.ab.vec3.dot(R, z), G = i.ab.vec3.dot(F, [0.2126, 0.7152, 0.0722]), Z = (te, ee, se) => (1 - se) * te + se * ee, W = Z(1 - 0.3 * Math.min(G, 1), 1, Math.min(N + 1, 1));
          return Z(0.92, 1, Math.asin(i.aw(R[2], -1, 1)) / Math.PI + 0.5) * W;
        }(c, [0, 0, 1], t), _ = [0, 0, 0];
        i.ab.vec3.scale(_, s.slice(0, 3), h);
        const y = [0, 0, 0];
        i.ab.vec3.scale(y, t.slice(0, 3), c[2]);
        const T = [0, 0, 0];
        return i.ab.vec3.add(T, _, y), i.cf(T);
      }
      const Jc = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Jm = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
      class Xf {
        static cacheKey(t, s, h, _) {
          let y = `${s}${_ ? _.cacheKey : ""}`;
          for (const T of h)
            t.usedDefines.includes(T) && (y += `/${T}`);
          return y;
        }
        constructor(t, s, h, _, y, T) {
          const z = t.gl;
          this.program = z.createProgram(), this.configuration = _, this.name = s, this.fixedDefines = [...T];
          const R = _ ? _.getBinderAttributes() : [], F = (h.staticAttributes || []).concat(R);
          let N = _ ? _.defines() : [];
          N = N.concat(T.map((se) => `#define ${se}`));
          const G = `#version 300 es
`;
          let Z = G + N.concat("precision mediump float;", Qr, Jl.fragmentSource).join(`
`);
          for (const se of h.fragmentIncludes)
            Z += `
${oo[se]}`;
          Z += `
${h.fragmentSource}`;
          let W = G + N.concat("precision highp float;", Qr, Jl.vertexSource).join(`
`);
          for (const se of h.vertexIncludes)
            W += `
${oo[se]}`;
          this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && h.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (W += `
uniform int u_instanceID;
`), W += `
${h.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (W = W.replaceAll("gl_InstanceID", "u_instanceID"));
          const te = z.createShader(z.FRAGMENT_SHADER);
          if (z.isContextLost())
            return void (this.failedToCreate = !0);
          z.shaderSource(te, Z), z.compileShader(te), z.attachShader(this.program, te);
          const ee = z.createShader(z.VERTEX_SHADER);
          if (z.isContextLost())
            this.failedToCreate = !0;
          else {
            z.shaderSource(ee, W), z.compileShader(ee), z.attachShader(this.program, ee), this.attributes = {}, this.numAttributes = F.length;
            for (let se = 0; se < this.numAttributes; se++)
              if (F[se]) {
                const oe = F[se].startsWith("a_") ? F[se] : `a_${F[se]}`;
                z.bindAttribLocation(this.program, se, oe), this.attributes[oe] = se;
              }
            z.linkProgram(this.program), z.deleteShader(ee), z.deleteShader(te), this.fixedUniforms = y(t), this.binderUniforms = _ ? _.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((se) => ({ u_instanceID: new i.bN(se) }))(t)), (T.includes("TERRAIN") || s.indexOf("symbol") !== -1 || s.indexOf("circle") !== -1) && (this.terrainUniforms = ((se) => ({ u_dem: new i.bN(se), u_dem_prev: new i.bN(se), u_dem_tl: new i.bK(se), u_dem_scale: new i.bM(se), u_dem_tl_prev: new i.bK(se), u_dem_scale_prev: new i.bM(se), u_dem_size: new i.bM(se), u_dem_lerp: new i.bM(se), u_exaggeration: new i.bM(se), u_depth: new i.bN(se), u_depth_size_inv: new i.bK(se), u_depth_range_unpack: new i.bK(se), u_occluder_half_size: new i.bM(se), u_occlusion_depth_offset: new i.bM(se), u_meter_to_dem: new i.bM(se), u_label_plane_matrix_inv: new i.bJ(se) }))(t)), T.includes("GLOBE") && (this.globeUniforms = ((se) => ({ u_tile_tl_up: new i.bL(se), u_tile_tr_up: new i.bL(se), u_tile_br_up: new i.bL(se), u_tile_bl_up: new i.bL(se), u_tile_up_scale: new i.bM(se) }))(t)), T.includes("FOG") && (this.fogUniforms = ((se) => ({ u_fog_matrix: new i.bJ(se), u_fog_range: new i.bK(se), u_fog_color: new i.ca(se), u_fog_horizon_blend: new i.bM(se), u_fog_vertical_limit: new i.bK(se), u_fog_temporal_offset: new i.bM(se), u_frustum_tl: new i.bL(se), u_frustum_tr: new i.bL(se), u_frustum_br: new i.bL(se), u_frustum_bl: new i.bL(se), u_globe_pos: new i.bL(se), u_globe_radius: new i.bM(se), u_globe_transition: new i.bM(se), u_is_globe: new i.bN(se), u_viewport: new i.bK(se) }))(t)), T.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((se) => ({ u_cutoff_params: new i.ca(se) }))(t)), T.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((se) => ({ u_lighting_ambient_color: new i.bL(se), u_lighting_directional_dir: new i.bL(se), u_lighting_directional_color: new i.bL(se), u_ground_radiance: new i.bL(se) }))(t)), T.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((se) => ({ u_light_matrix_0: new i.bJ(se), u_light_matrix_1: new i.bJ(se), u_fade_range: new i.bK(se), u_shadow_normal_offset: new i.bL(se), u_shadow_intensity: new i.bM(se), u_shadow_texel_size: new i.bM(se), u_shadow_map_resolution: new i.bM(se), u_shadow_direction: new i.bL(se), u_shadow_bias: new i.bL(se), u_shadowmap_0: new i.bN(se), u_shadowmap_1: new i.bN(se) }))(t));
          }
        }
        setTerrainUniformValues(t, s) {
          if (!this.terrainUniforms)
            return;
          const h = this.terrainUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const _ in s)
              h[_] && h[_].set(this.program, _, s[_]);
          }
        }
        setGlobeUniformValues(t, s) {
          if (!this.globeUniforms)
            return;
          const h = this.globeUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const _ in s)
              h[_] && h[_].set(this.program, _, s[_]);
          }
        }
        setFogUniformValues(t, s) {
          if (!this.fogUniforms)
            return;
          const h = this.fogUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const _ in s)
              h[_].set(this.program, _, s[_]);
          }
        }
        setCutoffUniformValues(t, s) {
          if (!this.cutoffUniforms)
            return;
          const h = this.cutoffUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const _ in s)
              h[_].set(this.program, _, s[_]);
          }
        }
        setLightsUniformValues(t, s) {
          if (!this.lightsUniforms)
            return;
          const h = this.lightsUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const _ in s)
              h[_].set(this.program, _, s[_]);
          }
        }
        setShadowUniformValues(t, s) {
          if (this.failedToCreate || !this.shadowUniforms)
            return;
          const h = this.shadowUniforms;
          t.program.set(this.program);
          for (const _ in s)
            h[_].set(this.program, _, s[_]);
        }
        _drawDebugWireframe(t, s, h, _, y, T, z, R, F, N) {
          const G = t.options.wireframe;
          if (G.terrain === !1 && G.layers2D === !1 && G.layers3D === !1)
            return;
          const Z = t.context;
          if (!(() => !(!G.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!G.layers2D || t._terrain && t._terrain.renderingToTexture || !Jc.includes(this.name)) || !(!G.layers3D || !Jm.includes(this.name)))())
            return;
          const W = Z.gl, te = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, y, Z);
          if (!te)
            return;
          const ee = [...this.fixedDefines];
          ee.push("DEBUG_WIREFRAME");
          const se = t.getOrCreateProgram(this.name, { config: this.configuration, defines: ee });
          Z.program.set(se.program);
          const oe = (pe, Me, xe) => {
            if (Me[pe] && xe[pe])
              for (const we in Me[pe])
                xe[pe][we] && xe[pe][we].set(xe.program, we, Me[pe][we].current);
          };
          F && F.setUniforms(se.program, Z, se.binderUniforms, z, { zoom: R }), oe("fixedUniforms", this, se), oe("terrainUniforms", this, se), oe("globeUniforms", this, se), oe("fogUniforms", this, se), oe("lightsUniforms", this, se), oe("shadowUniforms", this, se), te.bind(), Z.setColorMode(new bi([W.ONE, W.ONE_MINUS_SRC_ALPHA, W.ZERO, W.ONE], i.aj.transparent, [!0, !0, !0, !1])), Z.setDepthMode(new Wt(s.func === W.LESS ? W.LEQUAL : s.func, Wt.ReadOnly, s.range)), Z.setStencilMode(ci.disabled);
          const he = 3 * T.primitiveLength * 2, _e = 3 * T.primitiveOffset * 2 * 2;
          if (this.forceManualRenderingForInstanceIDShaders) {
            const pe = N || 1;
            for (let Me = 0; Me < pe; ++Me)
              se.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", Me), W.drawElements(W.LINES, he, W.UNSIGNED_SHORT, _e);
          } else
            N && N > 1 ? W.drawElementsInstanced(W.LINES, he, W.UNSIGNED_SHORT, _e, N) : W.drawElements(W.LINES, he, W.UNSIGNED_SHORT, _e);
          y.bind(), Z.program.set(this.program), Z.setDepthMode(s), Z.setStencilMode(h), Z.setColorMode(_);
        }
        checkUniforms(t, s, h) {
          if (this.fixedDefines.includes(s)) {
            for (const _ of Object.keys(h))
              if (!h[_].initialized)
                throw new Error(`Program '${this.name}', from draw '${t}': uniform ${_} not set but required by ${s} being defined`);
          }
        }
        draw(t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se) {
          const oe = t.context, he = oe.gl;
          if (this.failedToCreate)
            return;
          oe.program.set(this.program), oe.setDepthMode(h), oe.setStencilMode(_), oe.setColorMode(y), oe.setCullFace(T);
          for (const Me of Object.keys(this.fixedUniforms))
            this.fixedUniforms[Me].set(this.program, Me, z[Me]);
          te && te.setUniforms(this.program, oe, this.binderUniforms, Z, { zoom: W });
          const _e = { [he.POINTS]: 1, [he.LINES]: 2, [he.TRIANGLES]: 3, [he.LINE_STRIP]: 1 }[s];
          this.checkUniforms(R, "RENDER_SHADOWS", this.shadowUniforms);
          const pe = se && se > 0 ? 1 : void 0;
          for (const Me of G.get()) {
            const xe = Me.vaos || (Me.vaos = {});
            if ((xe[R] || (xe[R] = new qh())).bind(oe, this, F, te ? te.getPaintVertexBuffers() : [], N, Me.vertexOffset, ee || [], pe), this.forceManualRenderingForInstanceIDShaders) {
              const we = se || 1;
              for (let ve = 0; ve < we; ++ve)
                this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ve), N ? he.drawElements(s, Me.primitiveLength * _e, he.UNSIGNED_SHORT, Me.primitiveOffset * _e * 2) : he.drawArrays(s, Me.vertexOffset, Me.vertexLength);
            } else
              se && se > 1 ? he.drawElementsInstanced(s, Me.primitiveLength * _e, he.UNSIGNED_SHORT, Me.primitiveOffset * _e * 2, se) : N ? he.drawElements(s, Me.primitiveLength * _e, he.UNSIGNED_SHORT, Me.primitiveOffset * _e * 2) : he.drawArrays(s, Me.vertexOffset, Me.vertexLength);
            s === he.TRIANGLES && N && this._drawDebugWireframe(t, h, _, y, N, Me, Z, W, te, se);
          }
        }
      }
      function ld(c, t) {
        const s = Math.pow(2, t.tileID.overscaledZ), h = t.tileSize * Math.pow(2, c.transform.tileZoom) / s, _ = h * (t.tileID.canonical.x + t.tileID.wrap * s), y = h * t.tileID.canonical.y;
        return { u_image: 0, u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / i.ar(t, 1, c.transform.tileZoom), u_pixel_coord_upper: [_ >> 16, y >> 16], u_pixel_coord_lower: [65535 & _, 65535 & y] };
      }
      const eu = { terrain: 0, flat: 1 }, cd = i.ab.mat4.create(), tu = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe) => {
        const he = t.style.light, _e = he.properties.get("position"), pe = [_e.x, _e.y, _e.z], Me = i.ab.mat3.create();
        he.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(Me, -t.transform.angle), i.ab.vec3.transformMat3(pe, pe, Me));
        const xe = he.properties.get("color"), we = t.transform, ve = { u_matrix: c, u_lightpos: pe, u_lightintensity: he.properties.get("intensity"), u_lightcolor: [xe.r, xe.g, xe.b], u_vertical_gradient: +s, u_opacity: h, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: cd, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: eu[F], u_base_type: eu[N], u_ao: _, u_edge_radius: y, u_width_scale: T, u_flood_light_color: te, u_vertical_scale: ee, u_flood_light_intensity: se, u_ground_shadow_factor: oe };
        return we.projection.name === "globe" && (ve.u_tile_id = [z.canonical.x, z.canonical.y, 1 << z.canonical.z], ve.u_zoom_transition = G, ve.u_inv_rot_matrix = W, ve.u_merc_center = Z, ve.u_up_dir = we.projection.upVector(new i.bT(0, 0, 0), Z[0] * i.ag, Z[1] * i.ag), ve.u_height_lift = R), ve;
      }, Qc = (c, t, s, h, _, y) => ({ u_matrix: c, u_edge_radius: t, u_width_scale: s, u_vertical_scale: h, u_height_type: eu[_], u_base_type: eu[y] }), hd = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se) => {
        const oe = tu(c, t, s, h, _, y, T, z, F, N, G, Z, W, te, ee, se, 1, [0, 0, 0]), he = { u_height_factor: -Math.pow(2, z.overscaledZ) / R.tileSize / 8 };
        return i.l(oe, ld(t, R), he);
      }, sc = (c, t) => ({ u_matrix: c, u_emissive_strength: t }), ud = (c, t, s, h) => i.l(sc(c, t), ld(s, h)), iu = (c, t, s) => ({ u_matrix: c, u_world: s, u_emissive_strength: t }), nu = (c, t, s, h, _) => i.l(ud(c, t, s, h), { u_world: _ }), dd = (c, t, s, h) => {
        const _ = i.ag / s.tileSize;
        return { u_matrix: c, u_camera_to_center_distance: t.getCameraToCenterDistance(h), u_extrude_scale: [t.pixelsToGLUnits[0] / _, t.pixelsToGLUnits[1] / _] };
      }, fd = (c, t, s = 1) => ({ u_matrix: c, u_color: t.toRenderColor(null), u_overlay: 0, u_overlay_scale: s }), Qm = i.ab.mat4.create(), rc = (c, t, s, h, _, y, T) => {
        const z = c.transform, R = z.projection.name === "globe", F = R ? i.cN(z.zoom, t.canonical) * z._pixelsPerMercatorPixel : i.ar(s, 1, y), N = { u_matrix: t.projMatrix, u_extrude_scale: F, u_intensity: T, u_inv_rot_matrix: Qm, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (R) {
          N.u_inv_rot_matrix = h, N.u_merc_center = _, N.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z], N.u_zoom_transition = i.ae(z.zoom);
          const G = _[0] * i.ag, Z = _[1] * i.ag;
          N.u_up_dir = z.projection.upVector(new i.bT(0, 0, 0), G, Z);
        }
        return N;
      };
      function eh(c, [t, s, h, _], [y, T]) {
        if (y === T)
          return [0, 0, 0, 0];
        const z = 255 * (c - 1) / (c * (T - y));
        return [t * z, s * z, h * z, _ * z];
      }
      function Ft(c, t, [s, h]) {
        return s === h ? 0 : 0.5 / c + (t - s) * (c - 1) / (c * (h - s));
      }
      const pd = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe, he, _e, pe) => ({ u_matrix: c, u_normalize_matrix: t, u_globe_matrix: s, u_merc_matrix: h, u_grid_matrix: _, u_tl_parent: y, u_scale_parent: F, u_fade_t: N.mix, u_opacity: N.opacity * G.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: G.paint.get("raster-brightness-min"), u_brightness_high: G.paint.get("raster-brightness-max"), u_saturation_factor: i.cO(G.paint.get("raster-saturation")), u_contrast_factor: i.cP(G.paint.get("raster-contrast")), u_spin_weights: Yf(G.paint.get("raster-hue-rotate")), u_perspective_transform: Z, u_raster_elevation: W, u_zoom_transition: T, u_merc_center: z, u_cutoff_params: R, u_colorization_mix: eh(i.cQ, ee, oe), u_colorization_offset: Ft(i.cQ, se, oe), u_color_ramp: te, u_texture_offset: [_e / (he + 2 * _e), he / (he + 2 * _e)], u_texture_res: [he + 2 * _e, he + 2 * _e], u_emissive_strength: pe });
      function Yf(c) {
        c *= Math.PI / 180;
        const t = Math.sin(c), s = Math.cos(c);
        return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3];
      }
      const lo = 0.05, Tl = (c, t, s, h, _, y, T, z, R, F, N, G) => ({ u_matrix: c, u_normalize_matrix: t, u_globe_matrix: s, u_merc_matrix: h, u_grid_matrix: _, u_tl_parent: y, u_scale_parent: F, u_fade_t: N.mix, u_opacity: N.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: G, u_zoom_transition: T, u_merc_center: z, u_cutoff_params: R }), Zt = (c, t, s, h, _, y, T, z, R, F) => ({ u_particle_texture: c, u_particle_texture_side_len: t, u_tile_offset: s, u_velocity: h, u_color_ramp: y, u_velocity_res: _, u_max_speed: T, u_uv_offset: z, u_data_scale: [255 * R[0], 255 * R[1]], u_data_offset: F, u_particle_pos_scale: 1.1, u_particle_pos_offset: [lo, lo] }), md = (c, t, s, h, _, y, T, z, R, F) => ({ u_particle_texture: c, u_particle_texture_side_len: t, u_velocity: s, u_velocity_res: h, u_max_speed: _, u_speed_factor: y, u_reset_rate: T, u_rand_seed: Math.random(), u_uv_offset: z, u_data_scale: [255 * R[0], 255 * R[1]], u_data_offset: F, u_particle_pos_scale: 1.1, u_particle_pos_offset: [lo, lo] }), Kf = i.ab.mat4.create(), Jf = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe, he, _e, pe, Me) => {
        const xe = _.transform, we = { u_is_size_zoom_constant: +(c === "constant" || c === "source"), u_is_size_feature_constant: +(c === "constant" || c === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: xe.getCameraToCenterDistance(he), u_rotate_symbol: +s, u_aspect_ratio: xe.width / xe.height, u_fade_change: _.options.fadeDuration ? _.symbolFadeChange : 1, u_matrix: y, u_label_plane_matrix: T, u_coord_matrix: z, u_is_text: +F, u_elevation_from_sea: R ? 1 : 0, u_pitch_with_map: +h, u_texsize: N, u_texsize_icon: G, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Kf, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: Kf, u_up_vector: [0, -1, 0], u_color_adj_mat: _e, u_icon_transition: pe || 0, u_gamma_scale: h ? _.transform.getCameraToCenterDistance(he) * Math.cos(_.terrain ? 0 : _.transform._pitch) : 1, u_device_pixel_ratio: i.q.devicePixelRatio, u_is_halo: +Z, u_scale_factor: Me || 1 };
        return he.name === "globe" && (we.u_tile_id = [W.canonical.x, W.canonical.y, 1 << W.canonical.z], we.u_zoom_transition = te, we.u_inv_rot_matrix = se, we.u_merc_center = ee, we.u_camera_forward = xe._camera.forward(), we.u_ecef_origin = i.cR(xe.globeMatrix, W.toUnwrapped()), we.u_tile_matrix = Float32Array.from(xe.globeMatrix), we.u_up_vector = oe), we;
      }, su = (c, t, s, h) => ({ u_matrix: c, u_emissive_strength: t, u_opacity: s, u_color: h }), _d = (c, t, s, h, _, y, T, z, R) => i.l(function(F, N, G, Z, W, te) {
        const { width: ee, height: se } = Z.imageManager.getPixelSize(N), oe = Math.pow(2, te.tileID.overscaledZ), he = te.tileSize * Math.pow(2, Z.transform.tileZoom) / oe, _e = he * (te.tileID.canonical.x + te.tileID.wrap * oe), pe = he * te.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: G.tl, u_pattern_br: G.br, u_texsize: [ee, se], u_pattern_size: G.displaySize, u_pattern_units_to_pixels: W ? [Z.transform.width, -1 * Z.transform.height] : [1 / i.ar(te, 1, Z.transform.tileZoom), 1 / i.ar(te, 1, Z.transform.tileZoom)], u_pixel_coord_upper: [_e >> 16, pe >> 16], u_pixel_coord_lower: [65535 & _e, 65535 & pe] };
      }(0, y, T, h, z, R), { u_matrix: c, u_emissive_strength: t, u_opacity: s }), ru = new Float32Array(i.ab.mat4.identity([])), gd = (c, t, s, h, _, y, T, z, R, F, N, G, Z, W = [0, 0, 0], te) => {
        const ee = _.style.light, se = ee.properties.get("position"), oe = [-se.x, -se.y, se.z], he = i.ab.mat3.create();
        ee.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(he, -_.transform.angle), i.ab.vec3.transformMat3(oe, oe, he));
        const _e = N.alphaMode === "MASK", pe = ee.properties.get("color").toRenderColor(null), Me = Z.paint.get("model-ambient-occlusion-intensity"), xe = Z.paint.get("model-color").constantOr(i.aj.white).toRenderColor(null), we = Z.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: c, u_lighting_matrix: t, u_normal_matrix: s, u_node_matrix: h || ru, u_lightpos: oe, u_lightintensity: ee.properties.get("intensity"), u_lightcolor: [pe.r, pe.g, pe.b], u_camera_pos: W, u_opacity: y, u_baseTextureIsAlpha: 0, u_alphaMask: +_e, u_alphaCutoff: N.alphaCutoff, u_baseColorFactor: [T.r, T.g, T.b, T.a], u_emissiveFactor: [z[0], z[1], z[2], 1], u_metallicFactor: R, u_roughnessFactor: F, u_baseColorTexture: bs.BaseColor, u_metallicRoughnessTexture: bs.MetallicRoughness, u_normalTexture: bs.Normal, u_occlusionTexture: bs.Occlusion, u_emissionTexture: bs.Emission, u_lutTexture: bs.LUT, u_color_mix: [xe.r, xe.g, xe.b, we], u_aoIntensity: Me, u_emissive_strength: G, u_occlusionTextureTransform: te || [0, 0, 0, 0] };
      }, Qf = (c, t = ru, s = ru) => ({ u_matrix: c, u_instance: t, u_node_matrix: s }), yd = { fillExtrusion: (c) => ({ u_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_vertical_gradient: new i.bM(c), u_opacity: new i.bM(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_ao: new i.bK(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_up_dir: new i.bL(c), u_height_lift: new i.bM(c), u_flood_light_color: new i.bL(c), u_vertical_scale: new i.bM(c), u_flood_light_intensity: new i.bM(c), u_ground_shadow_factor: new i.bL(c) }), fillExtrusionDepth: (c) => ({ u_matrix: new i.bJ(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_vertical_scale: new i.bM(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c) }), fillExtrusionPattern: (c) => ({ u_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_vertical_gradient: new i.bM(c), u_height_factor: new i.bM(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_ao: new i.bK(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_up_dir: new i.bL(c), u_height_lift: new i.bM(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c), u_opacity: new i.bM(c) }), fillExtrusionGroundEffect: (c) => ({ u_matrix: new i.bJ(c), u_opacity: new i.bM(c), u_ao_pass: new i.bM(c), u_meter_to_tile: new i.bM(c), u_ao: new i.bK(c), u_flood_light_intensity: new i.bM(c), u_flood_light_color: new i.bL(c), u_attenuation: new i.bM(c), u_edge_radius: new i.bM(c), u_fb: new i.bN(c), u_fb_size: new i.bM(c), u_dynamic_offset: new i.bM(c) }), fill: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c) }), fillPattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c) }), fillOutline: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_world: new i.bK(c) }), fillOutlinePattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_world: new i.bK(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c) }), circle: i.cS, collisionBox: (c) => ({ u_matrix: new i.bJ(c), u_camera_to_center_distance: new i.bM(c), u_extrude_scale: new i.bK(c) }), collisionCircle: (c) => ({ u_matrix: new i.bJ(c), u_inv_matrix: new i.bJ(c), u_camera_to_center_distance: new i.bM(c), u_viewport_size: new i.bK(c) }), debug: (c) => ({ u_color: new i.cz(c), u_matrix: new i.bJ(c), u_overlay: new i.bN(c), u_overlay_scale: new i.bM(c) }), clippingMask: (c) => ({ u_matrix: new i.bJ(c) }), heatmap: (c) => ({ u_extrude_scale: new i.bM(c), u_intensity: new i.bM(c), u_matrix: new i.bJ(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_up_dir: new i.bL(c) }), heatmapTexture: (c) => ({ u_image: new i.bN(c), u_color_ramp: new i.bN(c), u_opacity: new i.bM(c) }), hillshade: (c) => ({ u_matrix: new i.bJ(c), u_image: new i.bN(c), u_latrange: new i.bK(c), u_light: new i.bK(c), u_shadow: new i.cz(c), u_highlight: new i.cz(c), u_emissive_strength: new i.bM(c), u_accent: new i.cz(c) }), hillshadePrepare: (c) => ({ u_matrix: new i.bJ(c), u_image: new i.bN(c), u_dimension: new i.bK(c), u_zoom: new i.bM(c) }), line: i.cT, linePattern: i.cU, raster: (c) => ({ u_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_grid_matrix: new i.cA(c), u_tl_parent: new i.bK(c), u_scale_parent: new i.bM(c), u_fade_t: new i.bM(c), u_opacity: new i.bM(c), u_image0: new i.bN(c), u_image1: new i.bN(c), u_brightness_low: new i.bM(c), u_brightness_high: new i.bM(c), u_saturation_factor: new i.bM(c), u_contrast_factor: new i.bM(c), u_spin_weights: new i.bL(c), u_perspective_transform: new i.bK(c), u_raster_elevation: new i.bM(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_cutoff_params: new i.ca(c), u_colorization_mix: new i.ca(c), u_colorization_offset: new i.bM(c), u_color_ramp: new i.bN(c), u_texture_offset: new i.bK(c), u_texture_res: new i.bK(c), u_emissive_strength: new i.bM(c) }), rasterParticle: (c) => ({ u_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_grid_matrix: new i.cA(c), u_tl_parent: new i.bK(c), u_scale_parent: new i.bM(c), u_fade_t: new i.bM(c), u_opacity: new i.bM(c), u_image0: new i.bN(c), u_image1: new i.bN(c), u_raster_elevation: new i.bM(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_cutoff_params: new i.ca(c) }), rasterParticleTexture: (c) => ({ u_texture: new i.bN(c), u_opacity: new i.bM(c) }), rasterParticleDraw: (c) => ({ u_particle_texture: new i.bN(c), u_particle_texture_side_len: new i.bM(c), u_tile_offset: new i.bK(c), u_velocity: new i.bN(c), u_color_ramp: new i.bN(c), u_velocity_res: new i.bK(c), u_max_speed: new i.bM(c), u_uv_offset: new i.bK(c), u_data_scale: new i.bK(c), u_data_offset: new i.bM(c), u_particle_pos_scale: new i.bM(c), u_particle_pos_offset: new i.bK(c) }), rasterParticleUpdate: (c) => ({ u_particle_texture: new i.bN(c), u_particle_texture_side_len: new i.bM(c), u_velocity: new i.bN(c), u_velocity_res: new i.bK(c), u_max_speed: new i.bM(c), u_speed_factor: new i.bM(c), u_reset_rate: new i.bM(c), u_rand_seed: new i.bM(c), u_uv_offset: new i.bK(c), u_data_scale: new i.bK(c), u_data_offset: new i.bM(c), u_particle_pos_scale: new i.bM(c), u_particle_pos_offset: new i.bK(c) }), symbol: (c) => ({ u_is_size_zoom_constant: new i.bN(c), u_is_size_feature_constant: new i.bN(c), u_size_t: new i.bM(c), u_size: new i.bM(c), u_camera_to_center_distance: new i.bM(c), u_rotate_symbol: new i.bN(c), u_aspect_ratio: new i.bM(c), u_fade_change: new i.bM(c), u_matrix: new i.bJ(c), u_label_plane_matrix: new i.bJ(c), u_coord_matrix: new i.bJ(c), u_is_text: new i.bN(c), u_elevation_from_sea: new i.bN(c), u_pitch_with_map: new i.bN(c), u_texsize: new i.bK(c), u_texsize_icon: new i.bK(c), u_texture: new i.bN(c), u_texture_icon: new i.bN(c), u_gamma_scale: new i.bM(c), u_device_pixel_ratio: new i.bM(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_camera_forward: new i.bL(c), u_tile_matrix: new i.bJ(c), u_up_vector: new i.bL(c), u_ecef_origin: new i.bL(c), u_is_halo: new i.bN(c), u_icon_transition: new i.bM(c), u_color_adj_mat: new i.bJ(c), u_scale_factor: new i.bM(c) }), background: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_opacity: new i.bM(c), u_color: new i.cz(c) }), backgroundPattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_opacity: new i.bM(c), u_image: new i.bN(c), u_pattern_tl: new i.bK(c), u_pattern_br: new i.bK(c), u_texsize: new i.bK(c), u_pattern_size: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_pattern_units_to_pixels: new i.bK(c) }), terrainRaster: (c) => ({ u_matrix: new i.bJ(c), u_image0: new i.bN(c), u_skirt_height: new i.bM(c), u_ground_shadow_factor: new i.bL(c) }), skybox: (c) => ({ u_matrix: new i.bJ(c), u_sun_direction: new i.bL(c), u_cubemap: new i.bN(c), u_opacity: new i.bM(c), u_temporal_offset: new i.bM(c) }), skyboxGradient: (c) => ({ u_matrix: new i.bJ(c), u_color_ramp: new i.bN(c), u_center_direction: new i.bL(c), u_radius: new i.bM(c), u_opacity: new i.bM(c), u_temporal_offset: new i.bM(c) }), skyboxCapture: (c) => ({ u_matrix_3f: new i.cA(c), u_sun_direction: new i.bL(c), u_sun_intensity: new i.bM(c), u_color_tint_r: new i.ca(c), u_color_tint_m: new i.ca(c), u_luminance: new i.bM(c) }), globeRaster: (c) => ({ u_proj_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_image0: new i.bN(c), u_grid_matrix: new i.cA(c), u_skirt_height: new i.bM(c), u_far_z_cutoff: new i.bM(c), u_frustum_tl: new i.bL(c), u_frustum_tr: new i.bL(c), u_frustum_br: new i.bL(c), u_frustum_bl: new i.bL(c), u_globe_pos: new i.bL(c), u_globe_radius: new i.bM(c), u_viewport: new i.bK(c) }), globeAtmosphere: (c) => ({ u_frustum_tl: new i.bL(c), u_frustum_tr: new i.bL(c), u_frustum_br: new i.bL(c), u_frustum_bl: new i.bL(c), u_horizon: new i.bM(c), u_transition: new i.bM(c), u_fadeout_range: new i.bM(c), u_color: new i.ca(c), u_high_color: new i.ca(c), u_space_color: new i.ca(c), u_temporal_offset: new i.bM(c), u_horizon_angle: new i.bM(c) }), model: (c) => ({ u_matrix: new i.bJ(c), u_lighting_matrix: new i.bJ(c), u_normal_matrix: new i.bJ(c), u_node_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_camera_pos: new i.bL(c), u_opacity: new i.bM(c), u_baseColorFactor: new i.ca(c), u_emissiveFactor: new i.ca(c), u_metallicFactor: new i.bM(c), u_roughnessFactor: new i.bM(c), u_baseTextureIsAlpha: new i.bN(c), u_alphaMask: new i.bN(c), u_alphaCutoff: new i.bM(c), u_baseColorTexture: new i.bN(c), u_metallicRoughnessTexture: new i.bN(c), u_normalTexture: new i.bN(c), u_occlusionTexture: new i.bN(c), u_emissionTexture: new i.bN(c), u_lutTexture: new i.bN(c), u_color_mix: new i.ca(c), u_aoIntensity: new i.bM(c), u_emissive_strength: new i.bM(c), u_occlusionTextureTransform: new i.ca(c) }), modelDepth: (c) => ({ u_matrix: new i.bJ(c), u_instance: new i.bJ(c), u_node_matrix: new i.bJ(c) }), groundShadow: (c) => ({ u_matrix: new i.bJ(c), u_ground_shadow_factor: new i.bL(c) }), stars: (c) => ({ u_matrix: new i.bJ(c), u_up: new i.bL(c), u_right: new i.bL(c), u_intensity_multiplier: new i.bM(c) }), snowParticle: (c) => ({ u_modelview: new i.bJ(c), u_projection: new i.bJ(c), u_time: new i.bM(c), u_cam_pos: new i.bL(c), u_velocityConeAperture: new i.bM(c), u_velocity: new i.bM(c), u_horizontalOscillationRadius: new i.bM(c), u_horizontalOscillationRate: new i.bM(c), u_boxSize: new i.bM(c), u_billboardSize: new i.bM(c), u_simpleShapeParameters: new i.bK(c), u_screenSize: new i.bK(c), u_thinningCenterPos: new i.bK(c), u_thinningShape: new i.bL(c), u_thinningAffectedRatio: new i.bM(c), u_thinningParticleOffset: new i.bM(c), u_particleColor: new i.ca(c), u_direction: new i.bL(c) }), rainParticle: (c) => ({ u_modelview: new i.bJ(c), u_projection: new i.bJ(c), u_time: new i.bM(c), u_cam_pos: new i.bL(c), u_texScreen: new i.bN(c), u_velocityConeAperture: new i.bM(c), u_velocity: new i.bM(c), u_boxSize: new i.bM(c), u_rainDropletSize: new i.bK(c), u_distortionStrength: new i.bM(c), u_rainDirection: new i.bL(c), u_color: new i.ca(c), u_screenSize: new i.bK(c), u_thinningCenterPos: new i.bK(c), u_thinningShape: new i.bL(c), u_thinningAffectedRatio: new i.bM(c), u_thinningParticleOffset: new i.bM(c), u_shapeDirectionalPower: new i.bM(c), u_shapeNormalPower: new i.bM(c), u_mode: new i.bM(c) }), vignette: (c) => ({ u_vignetteShape: new i.bL(c), u_vignetteColor: new i.ca(c) }), occlusion: (c) => ({ u_matrix: new i.bJ(c), u_anchorPos: new i.bL(c), u_screenSizePx: new i.bK(c), u_occluderSizePx: new i.bK(c), u_color: new i.ca(c) }) };
      class ea {
        constructor(t, s, h, _) {
          this.id = ea.uniqueIdxCounter, ea.uniqueIdxCounter++, this.context = t;
          const y = t.gl;
          this.buffer = y.createBuffer(), this.dynamicDraw = !!h, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), y.bufferData(y.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? y.DYNAMIC_DRAW : y.STATIC_DRAW), this.dynamicDraw || _ || s.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          this.id = ea.uniqueIdxCounter, ea.uniqueIdxCounter++;
          const s = this.context.gl;
          this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      ea.uniqueIdxCounter = 0;
      const xd = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class vd {
        constructor(t, s, h, _, y, T) {
          this.length = s.length, this.attributes = h, this.itemSize = s.bytesPerElement, this.dynamicDraw = _, this.instanceCount = T, this.context = t;
          const z = t.gl;
          this.buffer = z.createBuffer(), t.bindVertexBuffer.set(this.buffer), z.bufferData(z.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? z.DYNAMIC_DRAW : z.STATIC_DRAW), this.dynamicDraw || y || s.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          const s = this.context.gl;
          this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, s) {
          for (let h = 0; h < this.attributes.length; h++) {
            const _ = s.attributes[this.attributes[h].name];
            _ !== void 0 && t.enableVertexAttribArray(_);
          }
        }
        setVertexAttribPointers(t, s, h) {
          for (let _ = 0; _ < this.attributes.length; _++) {
            const y = this.attributes[_], T = s.attributes[y.name];
            T !== void 0 && t.vertexAttribPointer(T, y.components, t[xd[y.type]], !1, this.itemSize, y.offset + this.itemSize * (h || 0));
          }
        }
        setVertexAttribDivisor(t, s, h) {
          for (let _ = 0; _ < this.attributes.length; _++) {
            const y = s.attributes[this.attributes[_].name];
            y !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(y, h);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class br {
        constructor(t, s, h, _, y) {
          this.context = t, this.width = s, this.height = h;
          const T = this.framebuffer = t.gl.createFramebuffer();
          _ && (this.colorAttachment = new ic(t, T)), y && (this.depthAttachmentType = y, this.depthAttachment = y === "renderbuffer" ? new es(t, T) : new Po(t, T));
        }
        destroy() {
          const t = this.context.gl;
          if (this.colorAttachment) {
            const s = this.colorAttachment.get();
            s && t.deleteTexture(s);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if (this.depthAttachmentType === "renderbuffer") {
              const s = this.depthAttachment.get();
              s && t.deleteRenderbuffer(s);
            } else {
              const s = this.depthAttachment.get();
              s && t.deleteTexture(s);
            }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class qa {
        constructor(t, s) {
          this.gl = t, this.clearColor = new Wh(this), this.clearDepth = new $h(this), this.clearStencil = new Ql(this), this.colorMask = new ec(this), this.depthMask = new tc(this), this.stencilMask = new Wc(this), this.stencilFunc = new $c(this), this.stencilOp = new Xc(this), this.stencilTest = new id(this), this.depthRange = new p(this), this.depthTest = new P(this), this.depthFunc = new B(this), this.blend = new X(this), this.blendFunc = new ne(this), this.blendColor = new ye(this), this.blendEquation = new We(this), this.cullFace = new at(this), this.cullFaceSide = new ft(this), this.frontFace = new Rt(this), this.program = new ii(this), this.activeTexture = new Ci(this), this.viewport = new Wi(this), this.bindFramebuffer = new Hs(this), this.bindRenderbuffer = new ws(this), this.bindTexture = new Rs(this), this.bindVertexBuffer = new ur(this), this.bindElementBuffer = new Za(this), this.bindVertexArrayOES = new nd(this), this.pixelStoreUnpack = new sd(this), this.pixelStoreUnpackPremultiplyAlpha = new rd(this), this.pixelStoreUnpackFlipY = new Xh(this), this.options = s ? { ...s } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = s && !!s.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1];
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(t, s, h) {
          return new ea(this, t, s, h);
        }
        createVertexBuffer(t, s, h, _, y) {
          return new vd(this, t, s, h, _, y);
        }
        createRenderbuffer(t, s, h) {
          const _ = this.gl, y = _.createRenderbuffer();
          return this.bindRenderbuffer.set(y), _.renderbufferStorage(_.RENDERBUFFER, t, s, h), this.bindRenderbuffer.set(null), y;
        }
        createFramebuffer(t, s, h, _) {
          return new br(this, t, s, h, _);
        }
        clear({ color: t, depth: s, stencil: h, colorMask: _ }) {
          const y = this.gl;
          let T = 0;
          t && (T |= y.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set(_ || [!0, !0, !0, !0])), s !== void 0 && (T |= y.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), h !== void 0 && (T |= y.STENCIL_BUFFER_BIT, this.clearStencil.set(h), this.stencilMask.set(255)), y.clear(T);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          i.bn(t.blendFunction, bi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      let th;
      function ou(c, t, s, h, _, y, T) {
        const z = c.context, R = z.gl, F = c.transform, N = c.getOrCreateProgram("collisionBox"), G = [];
        let Z = 0, W = 0;
        for (let pe = 0; pe < h.length; pe++) {
          const Me = h[pe], xe = t.getTile(Me), we = xe.getBucket(s);
          if (!we)
            continue;
          const ve = qn(Me, we, F);
          let Pe = ve;
          _[0] === 0 && _[1] === 0 || (Pe = c.translatePosMatrix(ve, xe, _, y));
          const Oe = T ? we.textCollisionBox : we.iconCollisionBox, Xe = we.collisionCircleArray;
          if (Xe.length > 0) {
            const He = i.ab.mat4.create(), ke = Pe;
            i.ab.mat4.mul(He, we.placementInvProjMatrix, F.glCoordMatrix), i.ab.mat4.mul(He, He, we.placementViewportMatrix), G.push({ circleArray: Xe, circleOffset: W, transform: ke, invTransform: He, projection: we.getProjection() }), Z += Xe.length / 4, W = Z;
          }
          Oe && (c.terrain && c.terrain.setupElevationDraw(xe, N), N.draw(c, R.LINES, Wt.disabled, ci.disabled, c.colorModeForRenderPass(), ti.disabled, dd(Pe, F, xe, we.getProjection()), s.id, Oe.layoutVertexBuffer, Oe.indexBuffer, Oe.segments, null, F.zoom, null, [Oe.collisionVertexBuffer, Oe.collisionVertexBufferExt]));
        }
        if (!T || !G.length)
          return;
        const te = c.getOrCreateProgram("collisionCircle"), ee = new i.cV();
        ee.resize(4 * Z), ee._trim();
        let se = 0;
        for (const pe of G)
          for (let Me = 0; Me < pe.circleArray.length / 4; Me++) {
            const xe = 4 * Me, we = pe.circleArray[xe + 0], ve = pe.circleArray[xe + 1], Pe = pe.circleArray[xe + 2], Oe = pe.circleArray[xe + 3];
            ee.emplace(se++, we, ve, Pe, Oe, 0), ee.emplace(se++, we, ve, Pe, Oe, 1), ee.emplace(se++, we, ve, Pe, Oe, 2), ee.emplace(se++, we, ve, Pe, Oe, 3);
          }
        (!th || th.length < 2 * Z) && (th = function(pe) {
          const Me = 2 * pe, xe = new i.aU();
          xe.resize(Me), xe._trim();
          for (let we = 0; we < Me; we++) {
            const ve = 6 * we;
            xe.uint16[ve + 0] = 4 * we + 0, xe.uint16[ve + 1] = 4 * we + 1, xe.uint16[ve + 2] = 4 * we + 2, xe.uint16[ve + 3] = 4 * we + 2, xe.uint16[ve + 4] = 4 * we + 3, xe.uint16[ve + 5] = 4 * we + 0;
          }
          return xe;
        }(Z));
        const oe = z.createIndexBuffer(th, !0), he = z.createVertexBuffer(ee, i.cW.members, !0);
        for (const pe of G) {
          const Me = { u_matrix: pe.transform, u_inv_matrix: pe.invTransform, u_camera_to_center_distance: (_e = F).getCameraToCenterDistance(pe.projection), u_viewport_size: [_e.width, _e.height] };
          te.draw(c, R.TRIANGLES, Wt.disabled, ci.disabled, c.colorModeForRenderPass(), ti.disabled, Me, s.id, he, oe, i.b7.simpleSegment(0, 2 * pe.circleOffset, pe.circleArray.length, pe.circleArray.length / 2), null, F.zoom);
        }
        var _e;
        he.destroy(), oe.destroy();
      }
      const oc = i.ab.mat4.create();
      function au(c) {
        const t = c._camera.getWorldToCamera(c.worldSize, 1), s = i.ab.mat4.multiply([], t, c.globeMatrix);
        i.ab.mat4.invert(s, s);
        const h = [0, 0, 0], _ = [0, 1, 0, 0];
        return i.ab.vec4.transformMat4(_, _, s), h[0] = _[0], h[1] = _[1], h[2] = _[2], i.ab.vec3.normalize(h, h), h;
      }
      function ep({ width: c, height: t, anchor: s, textOffset: h, textScale: _ }, y) {
        const { horizontalAlign: T, verticalAlign: z } = i.bD(s), R = -(T - 0.5) * c, F = -(z - 0.5) * t, N = i.bC(s, h);
        return new i.P((R / _ + N[0]) * y, (F / _ + N[1]) * y);
      }
      function co(c, t, s, h, _, y, T, z, R, F, N) {
        const G = c.text.placedSymbolArray, Z = c.text.dynamicLayoutVertexArray, W = c.icon.dynamicLayoutVertexArray, te = {}, ee = c.getProjection(), se = pa(z, ee, y), oe = y.elevation, he = ee.upVectorScale(z.canonical, y.center.lat, y.worldSize).metersToTile;
        Z.clear();
        for (let _e = 0; _e < G.length; _e++) {
          const pe = G.get(_e), { tileAnchorX: Me, tileAnchorY: xe, numGlyphs: we } = pe, ve = pe.hidden || !pe.crossTileID || c.allowVerticalPlacement && !pe.placedOrientation ? null : h[pe.crossTileID];
          if (ve) {
            let Pe = 0, Oe = 0, Xe = 0;
            if (oe) {
              const Je = oe ? oe.getAtTileOffset(z, Me, xe) : 0, [_t, ct, nt] = ee.upVector(z.canonical, Me, xe);
              Pe = Je * _t * he, Oe = Je * ct * he, Xe = Je * nt * he;
            }
            let [He, ke, Ne, st] = un(pe.projectedAnchorX + Pe, pe.projectedAnchorY + Oe, pe.projectedAnchorZ + Xe, s ? se : T);
            const ut = Bc(y.getCameraToCenterDistance(ee), st);
            let xt = _.evaluateSizeForFeature(c.textSizeData, F, pe) * ut / i.bw;
            s && (xt *= c.tilePixelRatio / R);
            const Ge = ep(ve, xt);
            s ? ({ x: He, y: ke, z: Ne } = ee.projectTilePoint(Me + Ge.x, xe + Ge.y, z.canonical), [He, ke, Ne] = un(He + Pe, ke + Oe, Ne + Xe, T)) : (t && Ge._rotate(-y.angle), He += Ge.x, ke += Ge.y, Ne = 0);
            const lt = c.allowVerticalPlacement && pe.placedOrientation === i.bq.vertical ? Math.PI / 2 : 0;
            for (let Je = 0; Je < we; Je++)
              i.bt(Z, He, ke, Ne, lt);
            N && pe.associatedIconIndex >= 0 && (te[pe.associatedIconIndex] = { x: He, y: ke, z: Ne, angle: lt });
          } else
            fa(we, Z);
        }
        if (N) {
          W.clear();
          const _e = c.icon.placedSymbolArray;
          for (let pe = 0; pe < _e.length; pe++) {
            const Me = _e.get(pe), { numGlyphs: xe } = Me, we = te[pe];
            if (Me.hidden || !we)
              fa(xe, W);
            else {
              const { x: ve, y: Pe, z: Oe, angle: Xe } = we;
              for (let He = 0; He < xe; He++)
                i.bt(W, ve, Pe, Oe, Xe);
            }
          }
          c.icon.dynamicLayoutVertexBuffer.updateData(W);
        }
        c.text.dynamicLayoutVertexBuffer.updateData(Z);
      }
      function Tn(c, t, s, h, _, y, T = {}) {
        const z = s.paint.get("icon-translate"), R = s.paint.get("text-translate"), F = s.paint.get("icon-translate-anchor"), N = s.paint.get("text-translate-anchor"), G = s.layout.get("icon-rotation-alignment"), Z = s.layout.get("text-rotation-alignment"), W = s.layout.get("icon-pitch-alignment"), te = s.layout.get("text-pitch-alignment"), ee = s.layout.get("icon-keep-upright"), se = s.layout.get("text-keep-upright"), oe = s.paint.get("icon-color-saturation"), he = s.paint.get("icon-color-contrast"), _e = s.paint.get("icon-color-brightness-min"), pe = s.paint.get("icon-color-brightness-max"), Me = s.layout.get("symbol-elevation-reference") === "sea", xe = c.context, we = xe.gl, ve = c.transform, Pe = G === "map", Oe = Z === "map", Xe = W === "map", He = te === "map", ke = s.layout.get("symbol-sort-key").constantOr(1) !== void 0;
        let Ne = !1;
        const st = c.depthModeForSublayer(0, Wt.ReadOnly), ut = [i.at(ve.center.lng), i.aA(ve.center.lat)], xt = s.layout.get("text-variable-anchor"), Ge = ve.projection.name === "globe", lt = [], Je = [0, -1, 0];
        for (const _t of h) {
          const ct = t.getTile(_t), nt = ct.getBucket(s);
          if (!nt || nt.projection.name === "mercator" && Ge || nt.fullyClipped)
            continue;
          const Lt = nt.projection.name === "globe", bt = Lt ? i.ae(ve.zoom) : 0, zt = pa(_t, nt.getProjection(), ve), Bt = ve.calculatePixelsToTileUnitsMatrix(ct), oi = xt && nt.hasTextData(), $t = nt.hasIconTextFit() && oi && nt.hasIconData(), Xt = nt.getProjection().createInversionMatrix(ve, _t.canonical), ai = (ji) => {
            ve.depthOcclusionForSymbolsAndCircles && (s.hasInitialOcclusionOpacityProperties || c.terrain) && (ji.push("DEPTH_D24"), ji.push("DEPTH_OCCLUSION"));
          }, zi = () => {
            const ji = Pe && s.layout.get("symbol-placement") !== "point", Yi = [];
            ai(Yi);
            const In = ji || $t, Fs = s.paint.get("icon-image-cross-fade").constantOr(0);
            c.terrainRenderModeElevated() && Xe && Yi.push("PITCH_WITH_MAP_TERRAIN"), Lt && (Yi.push("PROJECTION_GLOBE_VIEW"), In && Yi.push("PROJECTED_POS_ON_VIEWPORT")), Fs > 0 && Yi.push("ICON_TRANSITION"), nt.icon.zOffsetVertexBuffer && Yi.push("Z_OFFSET"), oe === 0 && he === 0 && _e === 0 && pe === 1 || Yi.push("COLOR_ADJUSTMENT"), nt.sdfIcons && Yi.push("RENDER_SDF");
            const pr = nt.icon.programConfigurations.get(s.id), ts = c.getOrCreateProgram("symbol", { config: pr, defines: Yi }), As = ct.imageAtlasTexture ? ct.imageAtlasTexture.size : [0, 0], Qs = nt.iconSizeData, jn = i.bp(Qs, ve.zoom), dn = Xe || ve.pitch !== 0, _n = Js(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt), Ri = Ss(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt), Gn = c.translatePosMatrix(Ri, ct, z, F, !0), Bs = c.translatePosMatrix(zt, ct, z, F), cn = In ? oc : _n, er = Pe && !Xe && !ji;
            let eo = Je;
            !Ge && !ve.mercatorFromTransition || Pe || (eo = au(ve));
            const Br = Lt ? eo : Je, Ma = s.getColorAdjustmentMatrix(oe, he, _e, pe), mr = Jf(Qs.kind, jn, er, Xe, c, Bs, cn, Gn, Me, !1, As, [0, 0], !0, _t, bt, ut, Xt, Br, nt.getProjection(), Ma, Fs), ko = ct.imageAtlasTexture ? ct.imageAtlasTexture : null, Nr = s.layout.get("icon-size").constantOr(0) !== 1 || nt.iconsNeedLinear, il = nt.sdfIcons || c.options.rotating || c.options.zooming || Nr || dn ? we.LINEAR : we.NEAREST, ia = nt.sdfIcons && s.paint.get("icon-halo-width").constantOr(1) !== 0, Ll = c.terrain && Xe && ji ? i.ab.mat4.invert(i.ab.mat4.create(), _n) : oc;
            if (ji && nt.icon) {
              const yh = ve.elevation, Au = yh ? yh.getAtTileOffsetFunc(_t, ve.center.lat, ve.worldSize, nt.getProjection()) : null, Pu = Ho(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt);
              Zl(nt, zt, c, !1, Pu, Ri, Xe, ee, Au, _t);
            }
            return { program: ts, buffers: nt.icon, uniformValues: mr, atlasTexture: ko, atlasTextureIcon: null, atlasInterpolation: il, atlasInterpolationIcon: null, isSDF: nt.sdfIcons, hasHalo: ia, tile: ct, labelPlaneMatrixInv: Ll };
          }, wi = () => {
            const ji = Oe && s.layout.get("symbol-placement") !== "point", Yi = [], In = ji || xt || $t;
            c.terrainRenderModeElevated() && He && Yi.push("PITCH_WITH_MAP_TERRAIN"), Lt && (Yi.push("PROJECTION_GLOBE_VIEW"), In && Yi.push("PROJECTED_POS_ON_VIEWPORT")), nt.text.zOffsetVertexBuffer && Yi.push("Z_OFFSET"), nt.iconsInText && Yi.push("RENDER_TEXT_AND_SYMBOL"), Yi.push("RENDER_SDF"), ai(Yi);
            const Fs = nt.text.programConfigurations.get(s.id), pr = c.getOrCreateProgram("symbol", { config: Fs, defines: Yi });
            let ts, As = [0, 0], Qs = null;
            const jn = nt.textSizeData;
            nt.iconsInText && (As = ct.imageAtlasTexture ? ct.imageAtlasTexture.size : [0, 0], Qs = ct.imageAtlasTexture ? ct.imageAtlasTexture : null, ts = He || ve.pitch !== 0 || c.options.rotating || c.options.zooming || jn.kind === "composite" || jn.kind === "camera" ? we.LINEAR : we.NEAREST);
            const dn = ct.glyphAtlasTexture ? ct.glyphAtlasTexture.size : [0, 0], _n = s.layout.get("text-size-scale-range"), Ri = i.aw(c.scaleFactor, _n[0], _n[1]), Gn = i.bp(jn, ve.zoom, Ri), Bs = Js(zt, ct.tileID.canonical, He, Oe, ve, nt.getProjection(), Bt), cn = Ss(zt, ct.tileID.canonical, He, Oe, ve, nt.getProjection(), Bt), er = c.translatePosMatrix(cn, ct, R, N, !0), eo = c.translatePosMatrix(zt, ct, R, N), Br = In ? oc : Bs, Ma = Oe && !He && !ji;
            let mr = Je;
            !Ge && !ve.mercatorFromTransition || Oe || (mr = au(ve));
            const ko = Jf(jn.kind, Gn, Ma, He, c, eo, Br, er, Me, !0, dn, As, !0, _t, bt, ut, Xt, Lt ? mr : Je, nt.getProjection(), null, null, Ri), Nr = ct.glyphAtlasTexture ? ct.glyphAtlasTexture : null, il = we.LINEAR, ia = s.paint.get("text-halo-width").constantOr(1) !== 0, Ll = c.terrain && He && ji ? i.ab.mat4.invert(i.ab.mat4.create(), Bs) : oc;
            if (ji && nt.text) {
              const yh = ve.elevation, Au = yh ? yh.getAtTileOffsetFunc(_t, ve.center.lat, ve.worldSize, nt.getProjection()) : null, Pu = Ho(zt, ct.tileID.canonical, He, Oe, ve, nt.getProjection(), Bt);
              Zl(nt, zt, c, !0, Pu, cn, He, se, Au, _t);
            }
            return { program: pr, buffers: nt.text, uniformValues: ko, atlasTexture: Nr, atlasTextureIcon: Qs, atlasInterpolation: il, atlasInterpolationIcon: ts, isSDF: !0, hasHalo: ia, tile: ct, labelPlaneMatrixInv: Ll };
          }, mn = nt.icon.segments.get().length, Mn = nt.text.segments.get().length, Xi = mn && !T.onlyText ? zi() : null, sn = Mn && !T.onlyIcons ? wi() : null, _i = s.paint.get("icon-opacity").constantOr(1), Jt = s.paint.get("text-opacity").constantOr(1);
          if (ke && nt.canOverlap) {
            Ne = !0;
            const ji = _i && !T.onlyText ? nt.icon.segments.get() : [], Yi = Jt && !T.onlyIcons ? nt.text.segments.get() : [];
            for (const In of ji)
              lt.push({ segments: new i.b7([In]), sortKey: In.sortKey, state: Xi });
            for (const In of Yi)
              lt.push({ segments: new i.b7([In]), sortKey: In.sortKey, state: sn });
          } else
            T.onlyText || lt.push({ segments: _i ? nt.icon.segments : new i.b7([]), sortKey: 0, state: Xi }), T.onlyIcons || lt.push({ segments: Jt ? nt.text.segments : new i.b7([]), sortKey: 0, state: sn });
        }
        Ne && lt.sort((_t, ct) => _t.sortKey - ct.sortKey);
        for (const _t of lt) {
          const ct = _t.state;
          if (ct)
            if (c.terrain ? c.terrain.setupElevationDraw(ct.tile, ct.program, { useDepthForOcclusion: ve.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: ct.labelPlaneMatrixInv }) : c.setupDepthForOcclusion(ve.depthOcclusionForSymbolsAndCircles, ct.program), xe.activeTexture.set(we.TEXTURE0), ct.atlasTexture && ct.atlasTexture.bind(ct.atlasInterpolation, we.CLAMP_TO_EDGE, !0), ct.atlasTextureIcon && (xe.activeTexture.set(we.TEXTURE1), ct.atlasTextureIcon && ct.atlasTextureIcon.bind(ct.atlasInterpolationIcon, we.CLAMP_TO_EDGE, !0)), c.uploadCommonLightUniforms(c.context, ct.program), ct.hasHalo) {
              const nt = ct.uniformValues;
              nt.u_is_halo = 1, ac(ct.buffers, _t.segments, s, c, ct.program, st, _, y, nt, 2), nt.u_is_halo = 0;
            } else {
              if (ct.isSDF) {
                const nt = ct.uniformValues;
                ct.hasHalo && (nt.u_is_halo = 1, ac(ct.buffers, _t.segments, s, c, ct.program, st, _, y, nt, 1)), nt.u_is_halo = 0;
              }
              ac(ct.buffers, _t.segments, s, c, ct.program, st, _, y, ct.uniformValues, 1);
            }
        }
      }
      function ac(c, t, s, h, _, y, T, z, R, F) {
        const N = [c.dynamicLayoutVertexBuffer, c.opacityVertexBuffer, c.iconTransitioningVertexBuffer, c.globeExtVertexBuffer, c.zOffsetVertexBuffer];
        _.draw(h, h.context.gl.TRIANGLES, y, T, z, ti.disabled, R, s.id, c.layoutVertexBuffer, c.indexBuffer, t, s.paint, h.transform.zoom, c.programConfigurations.get(s.id), N, F);
      }
      function lu(c, t, s, h, _, y, T) {
        const z = c.context.gl, R = s.paint.get("fill-pattern"), F = s.is3D(), N = F ? c.stencilModeFor3D() : ci.disabled, G = R && R.constantOr(1);
        let Z, W, te, ee, se;
        T ? (W = G && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", Z = z.LINES) : (W = G ? "fillPattern" : "fill", Z = z.TRIANGLES);
        for (const oe of h) {
          const he = t.getTile(oe);
          if (G && !he.patternsLoaded())
            continue;
          const _e = he.getBucket(s);
          if (!_e)
            continue;
          c.prepareDrawTile();
          const pe = _e.programConfigurations.get(s.id), Me = c.isTileAffectedByFog(oe), xe = c.getOrCreateProgram(W, { config: pe, overrideFog: Me });
          G && (c.context.activeTexture.set(z.TEXTURE0), he.imageAtlasTexture && he.imageAtlasTexture.bind(z.LINEAR, z.CLAMP_TO_EDGE), pe.updatePaintBuffers());
          const we = R.constantOr(null);
          if (we && he.imageAtlas) {
            const Oe = he.imageAtlas, Xe = i.A.from(we), He = Oe.patternPositions[Xe.getSerializedPrimary()];
            He && pe.setConstantPatternPositions(He);
          }
          const ve = c.translatePosMatrix(oe.projMatrix, he, s.paint.get("fill-translate"), s.paint.get("fill-translate-anchor")), Pe = s.paint.get("fill-emissive-strength");
          if (T) {
            ee = _e.indexBuffer2, se = _e.segments2;
            const Oe = c.terrain && c.terrain.renderingToTexture ? c.terrain.drapeBufferSize : [z.drawingBufferWidth, z.drawingBufferHeight];
            te = W === "fillOutlinePattern" && G ? nu(ve, Pe, c, he, Oe) : iu(ve, Pe, Oe);
          } else
            ee = _e.indexBuffer, se = _e.segments, te = G ? ud(ve, Pe, c, he) : sc(ve, Pe);
          c.uploadCommonUniforms(c.context, xe, oe.toUnwrapped()), xe.draw(c, Z, _, F ? N : c.stencilModeForClipping(oe), y, ti.disabled, te, s.id, _e.layoutVertexBuffer, ee, se, s.paint, c.transform.zoom, pe, void 0);
        }
      }
      function ih(c, t, s, h, _, y, T, z) {
        s.resetLayerRenderingStats(c);
        const R = c.context, F = R.gl, N = c.transform, G = s.paint.get("fill-extrusion-pattern"), Z = G.constantOr(1), W = s.paint.get("fill-extrusion-opacity"), te = c.style.enable3dLights(), ee = s.paint.get(te && !Z ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), se = [s.paint.get("fill-extrusion-ambient-occlusion-intensity"), ee], oe = s.layout.get("fill-extrusion-edge-radius"), he = oe > 0 && !s.paint.get("fill-extrusion-rounded-roof"), _e = he ? 0 : oe, pe = N.projection.name === "globe" ? i.d3() : 0, Me = N.projection.name === "globe", xe = Me ? i.ae(N.zoom) : 0, we = [i.at(N.center.lng), i.aA(N.center.lat)], ve = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", Pe = s.paint.get("fill-extrusion-flood-light-color").toRenderColor(ve ? null : s.lut).toArray01().slice(0, 3), Oe = s.paint.get("fill-extrusion-flood-light-intensity"), Xe = s.paint.get("fill-extrusion-vertical-scale"), He = s.paint.get("fill-extrusion-line-width").constantOr(1) !== 0, ke = s.paint.get("fill-extrusion-height-alignment"), Ne = s.paint.get("fill-extrusion-base-alignment"), st = Mo(c, s.paint.get("fill-extrusion-cutoff-fade-range")), ut = [];
        let xt;
        Me && ut.push("PROJECTION_GLOBE_VIEW"), se[0] > 0 && ut.push("FAUX_AO"), he && ut.push("ZERO_ROOF_RADIUS"), z && ut.push("HAS_CENTROID"), Oe > 0 && ut.push("FLOOD_LIGHT"), st.shouldRenderCutoff && ut.push("RENDER_CUTOFF"), He && ut.push("RENDER_WALL_MODE");
        const Ge = c.renderPass === "shadow", lt = c.shadowRenderer, Je = Ge && !!lt;
        c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !0);
        let _t = [0, 0, 0];
        if (lt) {
          const Lt = c.style.directionalLight, bt = c.style.ambientLight;
          Lt && bt && (_t = cr(c.style, Lt, bt)), Ge || (ut.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), lt.useNormalOffset && ut.push("NORMAL_OFFSET")), xt = ut.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const ct = Je ? "fillExtrusionDepth" : Z ? "fillExtrusionPattern" : "fillExtrusion", nt = s.getLayerRenderingStats();
        for (const Lt of h) {
          const bt = t.getTile(Lt), zt = bt.getBucket(s);
          if (!zt || zt.projection.name !== N.projection.name)
            continue;
          let Bt = !1;
          lt && (Bt = lt.getMaxCascadeForTile(Lt.toUnwrapped()) === 0);
          const oi = c.isTileAffectedByFog(Lt), $t = zt.programConfigurations.get(s.id), Xt = c.getOrCreateProgram(ct, { config: $t, defines: Bt ? xt : ut, overrideFog: oi });
          if (c.terrain && c.terrain.setupElevationDraw(bt, Xt, { useMeterToDem: !0 }), !zt.centroidVertexBuffer) {
            const sn = Xt.attributes.a_centroid_pos;
            sn !== void 0 && F.vertexAttrib2f(sn, 0, 0);
          }
          !Ge && lt && lt.setupShadows(bt.tileID.toUnwrapped(), Xt, "vector-tile", bt.tileID.overscaledZ), Z && (c.context.activeTexture.set(F.TEXTURE0), bt.imageAtlasTexture && bt.imageAtlasTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), $t.updatePaintBuffers());
          const ai = G.constantOr(null);
          if (ai && bt.imageAtlas) {
            const sn = bt.imageAtlas, _i = i.A.from(ai), Jt = sn.patternPositions[_i.getSerializedPrimary()];
            Jt && $t.setConstantPatternPositions(Jt);
          }
          const zi = s.paint.get("fill-extrusion-vertical-gradient"), wi = 1 / zt.tileToMeter;
          let mn;
          if (Ge && lt) {
            if (yt(bt.tileID, zt, c))
              continue;
            const sn = lt.calculateShadowPassMatrixFromTile(bt.tileID.toUnwrapped());
            mn = Qc(sn, _e, wi, Xe, ke, Ne);
          } else {
            const sn = c.translatePosMatrix(Lt.expandedProjMatrix, bt, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), _i = N.projection.createInversionMatrix(N, Lt.canonical);
            mn = Z ? hd(sn, c, zi, W, se, _e, wi, Lt, bt, pe, ke, Ne, xe, we, _i, Pe, Xe) : tu(sn, c, zi, W, se, _e, wi, Lt, pe, ke, Ne, xe, we, _i, Pe, Xe, Oe, _t);
          }
          c.uploadCommonUniforms(R, Xt, Lt.toUnwrapped(), null, st);
          let Mn = zt.segments;
          if (N.projection.name === "mercator" && !Ge && (Mn = zt.getVisibleSegments(bt.tileID, c.terrain, c.transform.getFrustum(0)), !Mn.get().length))
            continue;
          if (nt)
            if (Ge)
              for (const sn of Mn.get())
                nt.numRenderedVerticesInShadowPass += sn.primitiveLength;
            else
              for (const sn of Mn.get())
                nt.numRenderedVerticesInTransparentPass += sn.primitiveLength;
          const Xi = [];
          (c.terrain || z) && Xi.push(zt.centroidVertexBuffer), Me && Xi.push(zt.layoutVertexExtBuffer), He && Xi.push(zt.wallVertexBuffer), Xt.draw(c, R.gl.TRIANGLES, _, y, T, ti.backCCW, mn, s.id, zt.layoutVertexBuffer, zt.indexBuffer, Mn, s.paint, c.transform.zoom, $t, Xi);
        }
        c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !1);
      }
      function Ml(c, t, s, h, _, y, T, z, R, F, N, G, Z, W, te, ee, se, oe, he) {
        const _e = c.context, pe = _e.gl, Me = c.transform, xe = c.transform.zoom, we = [], ve = Mo(c, s.paint.get("fill-extrusion-cutoff-fade-range"));
        F === "clear" ? (we.push("CLEAR_SUBPASS"), he && (we.push("CLEAR_FROM_TEXTURE"), _e.activeTexture.set(pe.TEXTURE0), he.bind(pe.LINEAR, pe.CLAMP_TO_EDGE))) : F === "sdf" && we.push("SDF_SUBPASS"), se && we.push("HAS_CENTROID"), ve.shouldRenderCutoff && we.push("RENDER_CUTOFF");
        const Pe = s.layout.get("fill-extrusion-edge-radius"), Oe = (Xe, He, ke, Ne, st) => {
          const ut = He.programConfigurations.get(s.id), xt = c.isTileAffectedByFog(Xe), Ge = c.getOrCreateProgram("fillExtrusionGroundEffect", { config: ut, defines: we, overrideFog: xt }), lt = ((_t, ct, nt, Lt, bt, zt, Bt, oi, $t, Xt, ai) => ({ u_matrix: ct, u_opacity: nt, u_ao_pass: Lt ? 1 : 0, u_meter_to_tile: bt, u_ao: zt, u_flood_light_intensity: Bt, u_flood_light_color: oi, u_attenuation: $t, u_edge_radius: Xt, u_fb: 0, u_fb_size: ai, u_dynamic_offset: 1 }))(0, Ne, N, R, st, [G, Z * st], W, te, ee, xe >= 17 ? 0 : Pe * st, he ? he.size[0] : 0), Je = [];
          se && Je.push(He.hiddenByLandmarkVertexBuffer), c.uploadCommonUniforms(_e, Ge, Xe.toUnwrapped(), null, ve), Ge.draw(c, _e.gl.TRIANGLES, _, y, T, z, lt, s.id, He.vertexBuffer, He.indexBuffer, ke, s.paint, xe, ut, Je);
        };
        for (const Xe of h) {
          const He = t.getTile(Xe), ke = He.getBucket(s);
          if (!ke || ke.projection.name !== Me.projection.name || !ke.groundEffect || ke.groundEffect && !ke.groundEffect.hasData())
            continue;
          const Ne = ke.groundEffect, st = 1 / ke.tileToMeter;
          {
            const ut = c.translatePosMatrix(Xe.projMatrix, He, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), xt = Ne.getDefaultSegment();
            Oe(Xe, Ne, xt, ut, st);
          }
          if (oe)
            for (let ut = 0; ut < 4; ut++) {
              const xt = i.d4[ut](Xe), Ge = t.getTile(xt);
              if (!Ge)
                continue;
              const lt = Ge.getBucket(s);
              if (!lt || lt.projection.name !== Me.projection.name || !lt.groundEffect || lt.groundEffect && !lt.groundEffect.hasData())
                continue;
              const Je = lt.groundEffect;
              let _t, ct;
              ut === 0 ? (_t = [-i.ag, 0, 0], ct = 1) : ut === 1 ? (_t = [i.ag, 0, 0], ct = 0) : ut === 2 ? (_t = [0, -i.ag, 0], ct = 3) : (_t = [0, i.ag, 0], ct = 2);
              const nt = Je.regionSegments[ct];
              if (!nt)
                continue;
              const Lt = new Float32Array(16);
              i.ab.mat4.translate(Lt, Xe.projMatrix, _t), Oe(Xe, Je, nt, c.translatePosMatrix(Lt, He, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), st);
            }
        }
      }
      function tp(c, t, s, h, _, y, T) {
        h.centroidVertexArray.length === 0 && h.createCentroidsBuffer();
        const z = y ? y.findDEMTileFor(s) : null;
        if (!(z && z.dem || T))
          return;
        y && z && z.dem && h.selfDEMTileTimestamp !== z.dem._timestamp && (h.borderDoneWithNeighborZ = [-1, -1, -1, -1], h.selfDEMTileTimestamp = z.dem._timestamp);
        const R = (oe) => new i.P(Math.ceil((oe + i.d7) * i.d8), 0), F = (oe) => {
          const he = t.getSource().minzoom, _e = (Me) => {
            const xe = t.getTileByID(Me);
            if (xe && xe.hasData())
              return xe.getBucket(_);
          }, pe = [0, -1, 1];
          for (const Me of pe) {
            if (oe.overscaledZ + Me < he)
              continue;
            const xe = _e(oe.calculateScaledKey(oe.overscaledZ + Me));
            if (xe)
              return xe;
          }
        }, N = [0, 0, 0], G = (oe, he) => (N[0] = Math.min(oe.min.y, he.min.y), N[1] = Math.max(oe.max.y, he.max.y), N[2] = i.ag - he.min.x > oe.max.x ? he.min.x - i.ag : oe.max.x, N), Z = (oe, he) => (N[0] = Math.min(oe.min.x, he.min.x), N[1] = Math.max(oe.max.x, he.max.x), N[2] = i.ag - he.min.y > oe.max.y ? he.min.y - i.ag : oe.max.y, N), W = [(oe, he) => G(oe, he), (oe, he) => G(he, oe), (oe, he) => Z(oe, he), (oe, he) => Z(he, oe)], te = (oe, he, _e, pe, Me, xe, we) => {
          if (!y)
            return 0;
          const ve = [[xe ? _e : oe, xe ? oe : _e, 0], [xe ? _e : he, xe ? he : _e, 0]], Pe = we < 0 ? i.ag + we : we, Oe = [xe ? Pe : (oe + he) / 2, xe ? (oe + he) / 2 : Pe, 0];
          return _e === 0 && we < 0 || _e !== 0 && we > 0 ? y.getForTilePoints(Me, [Oe], !0, pe) : ve.push(Oe), y.getForTilePoints(s, ve, !0, z), Math.max(ve[0][2], ve[1][2], Oe[2]) / y.exaggeration();
        };
        for (let oe = 0; oe < 4; oe++) {
          const he = h.borderFeatureIndices[oe];
          if (he.length === 0)
            continue;
          const _e = i.d4[oe](s), pe = F(_e);
          if (!(pe && pe instanceof i.d5))
            continue;
          const Me = y ? y.findDEMTileFor(_e) : null;
          if (!(Me && Me.dem || T) || (y && Me && Me.dem && h.borderDEMTileTimestamp[oe] !== Me.dem._timestamp && (h.borderDoneWithNeighborZ[oe] = -1, h.borderDEMTileTimestamp[oe] = Me.dem._timestamp), h.borderDoneWithNeighborZ[oe] === pe.canonical.z))
            continue;
          pe.centroidVertexArray.length === 0 && pe.createCentroidsBuffer();
          const xe = (oe < 2 ? 1 : 5) - oe, we = pe.borderDoneWithNeighborZ[xe] !== h.canonical.z, ve = pe.borderFeatureIndices[xe];
          let Pe = 0;
          if (h.canonical.z !== pe.canonical.z) {
            for (const Oe of he)
              h.showCentroid(h.featuresOnBorder[Oe]);
            if (we)
              for (const Oe of ve)
                pe.showCentroid(pe.featuresOnBorder[Oe]);
            h.borderDoneWithNeighborZ[oe] = pe.canonical.z, pe.borderDoneWithNeighborZ[xe] = h.canonical.z;
          }
          for (const Oe of he) {
            const Xe = h.featuresOnBorder[Oe], He = h.centroidData[Xe.centroidDataIndex], ke = Xe.borders[oe];
            let Ne;
            for (; Pe < ve.length; ) {
              Ne = pe.featuresOnBorder[ve[Pe]];
              const st = Ne.borders[xe];
              if (st[1] > ke[0] + 3 || st[0] > ke[0] - 3)
                break;
              pe.showCentroid(Ne), Pe++;
            }
            if (Ne && Pe < ve.length) {
              const st = Pe;
              let ut = 0;
              for (; !(Ne.borders[xe][0] > ke[1] - 3) && (ut++, ++Pe !== ve.length); )
                Ne = pe.featuresOnBorder[ve[Pe]];
              Ne = pe.featuresOnBorder[ve[st]];
              let xt = !1;
              if (ut >= 1) {
                const Je = Ne.borders[xe];
                Math.abs(ke[0] - Je[0]) < 3 && Math.abs(ke[1] - Je[1]) < 3 && (ut = 1, xt = !0, Pe = st + 1);
              } else if (ut === 0) {
                h.showCentroid(Xe);
                continue;
              }
              const Ge = pe.centroidData[Ne.centroidDataIndex];
              T && xt && (((ee = He).flags | (se = Ge).flags) & i.d6 ? (ee.flags |= i.d6, se.flags |= i.d6) : (ee.flags &= ~i.d6, se.flags &= ~i.d6));
              const lt = Xe.intersectsCount() > 1 || Ne.intersectsCount() > 1;
              if (ut > 1)
                Pe = st, He.centroidXY = Ge.centroidXY = new i.P(0, 0);
              else if (Me && Me.dem && !lt) {
                const Je = W[oe](He, Ge), _t = oe % 2 ? i.ag - 1 : 0, ct = te(Je[0], Math.min(i.ag - 1, Je[1]), _t, Me, _e, oe < 2, Je[2]);
                He.centroidXY = Ge.centroidXY = R(ct);
              } else
                lt ? He.centroidXY = Ge.centroidXY = new i.P(0, 0) : (He.centroidXY = h.encodeBorderCentroid(Xe), Ge.centroidXY = pe.encodeBorderCentroid(Ne));
              h.writeCentroidToBuffer(He), pe.writeCentroidToBuffer(Ge);
            } else
              h.showCentroid(Xe);
          }
          h.borderDoneWithNeighborZ[oe] = pe.canonical.z, pe.borderDoneWithNeighborZ[xe] = h.canonical.z;
        }
        var ee, se;
        (h.needsCentroidUpdate || !h.centroidVertexBuffer && h.centroidVertexArray.length !== 0) && h.uploadCentroid(c);
      }
      const e_ = [1, 0, 0], lc = [0, 1, 0], cc = [0, 0, 1];
      function yt(c, t, s) {
        const h = s.transform, _ = s.shadowRenderer;
        if (!_)
          return !0;
        const y = c.toUnwrapped(), T = h.tileSize * _._cascades[s.currentShadowCascade].scale;
        let z = t.maxHeight;
        if (h.elevation) {
          const ee = h.elevation.getMinMaxForTile(c);
          ee && (z += ee.max);
        }
        const R = [..._.shadowDirection];
        R[2] = -R[2];
        const F = _.computeSimplifiedTileShadowVolume(y, z, T, R);
        if (!F)
          return !1;
        const N = [e_, lc, cc, R, [R[0], 0, R[2]], [0, R[1], R[2]]], G = h.projection.name === "globe", Z = h.scaleZoom(T), W = i.bR.fromInvProjectionMatrix(h.invProjMatrix, h.worldSize, Z, !G), te = _.getCurrentCascadeFrustum();
        return W.intersectsPrecise(F.vertices, F.planes, N) === 0 || te.intersectsPrecise(F.vertices, F.planes, N) === 0;
      }
      function Dt(c) {
        return [c[0] * i.d9, c[1] * i.d9, c[2] * i.d9, 0];
      }
      function Wa(c, t, s, h, _, y, T, z, R) {
        const F = h.getSource(), N = s.globeSharedBuffers;
        if (!N)
          return;
        let G, Z, W;
        if (t && (G = h.getTile(t)), F instanceof i.aJ ? (Z = F.texture, W = i.cI(0, 0, s.transform)) : G && t && (Z = G.texture, W = i.cI(t.canonical.z, t.canonical.x, s.transform)), !Z || !W)
          return;
        c || (W = i.ab.mat4.scale(i.ab.mat4.create(), W, [1, -1, 1]));
        const te = s.context, ee = te.gl, se = _.paint.get("raster-resampling") === "nearest" ? ee.NEAREST : ee.LINEAR, oe = s.colorModeForDrapableLayerRenderPass(y), he = T.defines;
        he.push("GLOBE_POLES");
        const _e = new Wt(ee.LEQUAL, Wt.ReadWrite, s.depthRangeFor3D), pe = Float32Array.from(s.transform.expandedFarZProjMatrix), Me = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0))));
        s.terrain && s.terrain.prepareDrawTile(), te.activeTexture.set(ee.TEXTURE0), Z.bind(se, ee.CLAMP_TO_EDGE), te.activeTexture.set(ee.TEXTURE1), Z.bind(se, ee.CLAMP_TO_EDGE), Z.useMipmap && te.extTextureFilterAnisotropic && s.transform.pitch > 20 && ee.texParameterf(ee.TEXTURE_2D, te.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, te.extTextureFilterAnisotropicMax);
        const [xe, we, ve, Pe] = t ? N.getPoleBuffers(t.canonical.z, !1) : N.getPoleBuffers(0, !0), Oe = _.paint.get("raster-elevation");
        let Xe;
        c ? (Xe = xe, s.renderDefaultNorthPole = Oe !== 0) : (Xe = we, s.renderDefaultSouthPole = Oe !== 0);
        const He = Dt(T.mix), ke = ((st, ut, xt, Ge, lt, Je, _t, ct, nt, Lt, bt, zt, Bt) => pd(st, ut, xt, new Float32Array(16), new Float32Array(9), [0, 0], Ge, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, Je, [0, 0], ct, 2, Lt, bt, zt, 1, 0, Bt))(pe, Me, W, i.ae(s.transform.zoom), 0, _, 0, Oe, 0, He, T.offset, T.range, y), Ne = s.getOrCreateProgram("raster", { defines: he });
        s.uploadCommonUniforms(te, Ne, null), Ne.draw(s, ee.TRIANGLES, _e, R, oe, z, ke, _.id, Xe, ve, Pe);
      }
      function Bn(c) {
        const t = c._nearZ, s = c.projection.farthestPixelDistance(c), h = s - t, _ = 0.2 * c.height, y = t + _;
        return [t, s, (y - _ - t) / h, (y - t) / h];
      }
      function $e(c, t, s, h) {
        if (c)
          return t instanceof xn && c instanceof ka ? t.getTextureDescriptor(c, s, !0) : { texture: c.texture, mix: Dt(h.mix), offset: h.offset, buffer: 0, tileSize: 1 };
      }
      var ip = i.da([{ name: "a_index", type: "Int16", components: 1 }]);
      class cu {
        constructor(t, s, h, _) {
          const y = { width: h[0], height: h[1], data: null }, T = t.gl;
          this.targetColorTexture = new i.T(t, y, T.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new i.T(t, y, T.RGBA8, { useMipmap: !1 }), this.context = t, this.updateParticleTexture(s, _), this.lastInvalidatedAt = 0;
        }
        updateParticleTexture(t, s) {
          if (this.particleTextureDimension === s.width)
            return;
          (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
          const h = this.context.gl, _ = s.width * s.height;
          this.particleTexture0 = new i.T(this.context, s, h.RGBA8, { premultiply: !1, useMipmap: !1 }), this.particleTexture1 = new i.T(this.context, s, h.RGBA8, { premultiply: !1, useMipmap: !1 });
          const y = new i.db();
          y.reserve(_);
          for (let T = 0; T < _; T++)
            y.emplaceBack(T);
          this.particleIndexBuffer = this.context.createVertexBuffer(y, ip.members, !0), this.particleSegment = i.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = s.width;
        }
        update(t) {
          return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = i.q.now(), 1));
        }
        destroy() {
          this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
        }
      }
      function bd(c, t, s) {
        if (!c)
          return null;
        const h = t.getTextureDescriptor(c, s, !0);
        if (!h)
          return null;
        let { texture: _, mix: y, offset: T, tileSize: z, buffer: R, format: F } = h;
        if (!_ || !F)
          return null;
        let N = !1;
        return F === "uint32" && (N = !0, y[3] = 0, y = eh(i.dc, y, [0, s.paint.get("raster-particle-max-speed")]), T = Ft(i.dc, T, [0, s.paint.get("raster-particle-max-speed")])), { texture: _, textureOffset: [R / (z + 2 * R), z / (z + 2 * R)], tileSize: z, scalarData: N, scale: y, offset: T, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[F]] };
      }
      function np(c) {
        const t = c._nearZ, s = c.projection.farthestPixelDistance(c), h = s - t, _ = 0.2 * c.height, y = t + _;
        return [t, s, (y - _ - t) / h, (y - t) / h];
      }
      const sp = new i.aj(1, 0, 0, 1), rp = new i.aj(0, 1, 0, 1), hc = new i.aj(0, 0, 1, 1), t_ = new i.aj(1, 0, 1, 1), i_ = new i.aj(0, 1, 1, 1);
      function Sl(c, t, s, h, _, y, T) {
        const z = c.context, R = c.transform, F = z.gl, N = R.projection.name === "globe", G = N ? ["PROJECTION_GLOBE_VIEW"] : [];
        let Z = i.ab.mat4.clone(s.projMatrix);
        if (N && i.ae(R.zoom) > 0) {
          const He = i.ba(s.canonical, R), ke = i.dd(He);
          Z = i.ab.mat4.multiply(new Float32Array(16), R.globeMatrix, ke), i.ab.mat4.multiply(Z, R.projMatrix, Z);
        }
        const W = i.ab.mat4.create();
        W[12] += 2 * _ / (i.q.devicePixelRatio * R.width), W[13] += 2 * y / (i.q.devicePixelRatio * R.height), i.ab.mat4.multiply(Z, W, Z);
        const te = c.getOrCreateProgram("debug", { defines: G }), ee = t.getTileByID(s.key);
        c.terrain && c.terrain.setupElevationDraw(ee, te);
        const se = Wt.disabled, oe = ci.disabled, he = c.colorModeForRenderPass(), _e = "$debug";
        z.activeTexture.set(F.TEXTURE0), c.emptyTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), N ? ee._makeGlobeTileDebugBuffers(c.context, R) : ee._makeDebugTileBoundsBuffers(c.context, R.projection);
        const pe = ee._tileDebugBuffer || c.debugBuffer, Me = ee._tileDebugIndexBuffer || c.debugIndexBuffer, xe = ee._tileDebugSegments || c.debugSegments;
        if (te.draw(c, F.LINE_STRIP, se, oe, he, ti.disabled, fd(Z, h), _e, pe, Me, xe, null, null, null, [ee._globeTileDebugBorderBuffer]), T) {
          const He = ee.latestRawTileData, ke = Math.floor((He && He.byteLength || 0) / 1024);
          let Ne = s.canonical.toString();
          s.overscaledZ !== s.canonical.z && (Ne += ` => ${s.overscaledZ}`), Ne += ` ${ee.state}`, Ne += ` ${ke}kb`, function(st, ut) {
            st.initDebugOverlayCanvas();
            const xt = st.debugOverlayCanvas, Ge = st.context.gl, lt = st.debugOverlayCanvas.getContext("2d");
            lt.clearRect(0, 0, xt.width, xt.height), lt.shadowColor = "white", lt.shadowBlur = 2, lt.lineWidth = 1.5, lt.strokeStyle = "white", lt.textBaseline = "top", lt.font = "bold 36px Open Sans, sans-serif", lt.fillText(ut, 5, 5), lt.strokeText(ut, 5, 5), st.debugOverlayTexture.update(xt), st.debugOverlayTexture.bind(Ge.LINEAR, Ge.CLAMP_TO_EDGE);
          }(c, Ne);
        }
        const we = t.getTile(s).tileSize, ve = 512 / Math.min(we, 512) * (s.overscaledZ / R.zoom) * 0.5, Pe = ee._tileDebugTextBuffer || c.debugBuffer, Oe = ee._tileDebugTextIndexBuffer || c.quadTriangleIndexBuffer, Xe = ee._tileDebugTextSegments || c.debugSegments;
        te.draw(c, F.TRIANGLES, se, oe, bi.alphaBlended, ti.disabled, fd(Z, i.aj.transparent, ve), _e, Pe, Oe, Xe, null, null, null, [ee._globeTileDebugTextBuffer]);
      }
      function nh(c, t, s, h) {
        sh(c, 0, t + s / 2, c.transform.width, s, h);
      }
      function hu(c, t, s, h) {
        sh(c, t - s / 2, 0, s, c.transform.height, h);
      }
      function sh(c, t, s, h, _, y) {
        const T = c.context, z = T.gl;
        z.enable(z.SCISSOR_TEST), z.scissor(t * i.q.devicePixelRatio, s * i.q.devicePixelRatio, h * i.q.devicePixelRatio, _ * i.q.devicePixelRatio), T.clear({ color: y }), z.disable(z.SCISSOR_TEST);
      }
      const op = i.da([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: uu } = op;
      function Co(c, t, s, h) {
        c.emplaceBack(t, s, h);
      }
      class Io {
        constructor(t) {
          this.vertexArray = new i.de(), this.indices = new i.aU(), Co(this.vertexArray, -1, -1, 1), Co(this.vertexArray, 1, -1, 1), Co(this.vertexArray, -1, 1, 1), Co(this.vertexArray, 1, 1, 1), Co(this.vertexArray, -1, -1, -1), Co(this.vertexArray, 1, -1, -1), Co(this.vertexArray, -1, 1, -1), Co(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, uu), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = i.b7.simpleSegment(0, 0, 36, 12);
        }
      }
      function El(c, t, s, h, _, y) {
        const T = c.context.gl, z = t.paint.get("sky-atmosphere-color"), R = t.paint.get("sky-atmosphere-halo-color"), F = t.paint.get("sky-atmosphere-sun-intensity"), N = ((G, Z, W, te, ee) => ({ u_matrix_3f: G, u_sun_direction: Z, u_sun_intensity: W, u_color_tint_r: [te.r, te.g, te.b, te.a], u_color_tint_m: [ee.r, ee.g, ee.b, ee.a], u_luminance: 5e-5 }))(i.ab.mat3.fromMat4(i.ab.mat3.create(), h), _, F, z, R);
        T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_CUBE_MAP_POSITIVE_X + y, t.skyboxTexture, 0), s.draw(c, T.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.frontCW, N, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);
      }
      const n_ = i.da([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class wr {
        constructor(t) {
          const s = new i.df();
          s.emplaceBack(-1, 1, 1, 0, 0), s.emplaceBack(1, 1, 1, 1, 0), s.emplaceBack(1, -1, 1, 1, 1), s.emplaceBack(-1, -1, 1, 0, 1);
          const h = new i.aU();
          h.emplaceBack(0, 1, 2), h.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(s, n_.members), this.indexBuffer = t.createIndexBuffer(h), this.segments = i.b7.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const s_ = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class rh {
        constructor() {
          this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
        }
      }
      class bn {
        constructor(t) {
          this.colorModeAlphaBlendedWriteRGB = new bi([1, Xo, 1, Xo], i.aj.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new bi([1, 0, 1, 0], i.aj.transparent, [!1, !1, !1, !0]), this.params = new rh(), this.updateNeeded = !0, t.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
            this.updateNeeded = !0;
          }), t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = !0;
          }), t.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = !0;
          });
        }
        update(t) {
          const s = t.context;
          if (!this.atmosphereBuffer || this.updateNeeded) {
            this.updateNeeded = !1, this.atmosphereBuffer = new wr(s);
            const h = this.params.sizeRange, _ = this.params.intensityRange, y = function(N) {
              const G = i.di(30), Z = [];
              for (let W = 0; W < N; ++W) {
                const te = 2 * Math.PI * G(), ee = Math.acos(1 - 2 * G()) - 0.5 * Math.PI;
                Z.push(i.ab.vec3.fromValues(Math.cos(ee) * Math.cos(te), Math.cos(ee) * Math.sin(te), Math.sin(ee)));
              }
              return Z;
            }(this.params.starsCount), T = i.di(300), z = new i.dg(), R = new i.aU();
            let F = 0;
            for (let N = 0; N < y.length; ++N) {
              const G = i.ab.vec3.scale([], y[N], 200), Z = Math.max(0, 1 + 0.01 * h * (1 * T() - 0.5)), W = Math.max(0, 1 + 0.01 * _ * (1 * T() - 0.5));
              z.emplaceBack(G[0], G[1], G[2], -1, -1, Z, W), z.emplaceBack(G[0], G[1], G[2], 1, -1, Z, W), z.emplaceBack(G[0], G[1], G[2], 1, 1, Z, W), z.emplaceBack(G[0], G[1], G[2], -1, 1, Z, W), R.emplaceBack(F + 0, F + 1, F + 2), R.emplaceBack(F + 0, F + 2, F + 3), F += 4;
            }
            this.starsVx = s.createVertexBuffer(z, s_.members), this.starsIdx = s.createIndexBuffer(R), this.starsSegments = i.b7.simpleSegment(0, 0, z.length, R.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t, s) {
          const h = t.context, _ = h.gl, y = t.transform, T = new Wt(_.LEQUAL, Wt.ReadOnly, [0, 1]), z = i.ae(y.zoom), R = t.style.getLut(s.scope), F = s.properties.get("color-use-theme") === "none", N = s.properties.get("color").toRenderColor(F ? null : R).toArray01(), G = s.properties.get("high-color-use-theme") === "none", Z = s.properties.get("high-color").toRenderColor(G ? null : R).toArray01(), W = s.properties.get("space-color-use-theme") === "none", te = s.properties.get("space-color").toRenderColor(W ? null : R).toArray01PremultipliedAlpha(), ee = 5e-4, se = i.dh(s.properties.get("horizon-blend"), 0, 1, ee, 0.25), oe = i.cC(t, h, y) && se === ee ? y.worldSize / (2 * Math.PI * 1.025) - 1 : y.globeRadius, he = t.frameCounter / 1e3 % 1, _e = i.ab.vec3.length(y.globeCenterInViewSpace), pe = Math.sqrt(Math.pow(_e, 2) - Math.pow(oe, 2)), Me = Math.acos(pe / _e), xe = (we) => {
            const ve = y.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            we && ve.push("ALPHA_PASS");
            const Pe = t.getOrCreateProgram("globeAtmosphere", { defines: ve }), Oe = ((He, ke, Ne, st, ut, xt, Ge, lt, Je, _t, ct, nt) => ({ u_frustum_tl: He, u_frustum_tr: ke, u_frustum_br: Ne, u_frustum_bl: st, u_horizon: ut, u_transition: xt, u_fadeout_range: Ge, u_color: lt, u_high_color: Je, u_space_color: _t, u_temporal_offset: ct, u_horizon_angle: nt }))(y.frustumCorners.TL, y.frustumCorners.TR, y.frustumCorners.BR, y.frustumCorners.BL, y.frustumCorners.horizon, z, se, N, Z, te, he, Me);
            t.uploadCommonUniforms(h, Pe);
            const Xe = this.atmosphereBuffer;
            Xe && Pe.draw(t, _.TRIANGLES, T, ci.disabled, we ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, ti.backCW, Oe, we ? "atmosphere_glow_alpha" : "atmosphere_glow", Xe.vertexBuffer, Xe.indexBuffer, Xe.segments);
          };
          xe(!1), xe(!0);
        }
        drawStars(t, s) {
          const h = i.aw(s.properties.get("star-intensity"), 0, 1);
          if (h === 0)
            return;
          const _ = t.context, y = _.gl, T = t.transform, z = t.getOrCreateProgram("stars"), R = i.ab.quat.identity([]);
          i.ab.quat.rotateX(R, R, -T._pitch), i.ab.quat.rotateZ(R, R, -T.angle), i.ab.quat.rotateX(R, R, i.ai(T._center.lat)), i.ab.quat.rotateY(R, R, -i.ai(T._center.lng));
          const F = i.ab.mat4.fromQuat(new Float32Array(16), R), N = i.ab.mat4.multiply([], T.starsProjMatrix, F), G = i.ab.mat3.fromMat4([], F), Z = i.ab.mat3.invert([], G), W = [0, 1, 0];
          i.ab.vec3.transformMat3(W, W, Z), i.ab.vec3.scale(W, W, this.params.sizeMultiplier);
          const te = [1, 0, 0];
          i.ab.vec3.transformMat3(te, te, Z), i.ab.vec3.scale(te, te, this.params.sizeMultiplier);
          const ee = (se = W, oe = te, he = h, { u_matrix: Float32Array.from(N), u_up: se, u_right: oe, u_intensity_multiplier: he });
          var se, oe, he;
          t.uploadCommonUniforms(_, z), this.starsVx && this.starsIdx && z.draw(t, y.TRIANGLES, Wt.disabled, ci.disabled, this.colorModeAlphaBlendedWriteRGB, ti.disabled, ee, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function qi(c, t) {
        const s = [...c], h = t.cameraWorldSizeForFog / t.worldSize, _ = i.ab.mat4.identity([]);
        return i.ab.mat4.scale(_, _, [h, h, 1]), i.ab.mat4.multiply(s, _, s), i.ab.mat4.multiply(s, t.worldToFogMatrix, s), s;
      }
      function du(c, t, s, h, _) {
        const y = s.material, T = h.context, { baseColorTexture: z, metallicRoughnessTexture: R } = y.pbrMetallicRoughness, { normalTexture: F, occlusionTexture: N, emissionTexture: G } = y;
        function Z(te, ee, se) {
          if (te && (c.push(ee), T.activeTexture.set(T.gl.TEXTURE0 + se), te.gfxTexture)) {
            const { minFilter: oe, magFilter: he, wrapS: _e, wrapT: pe } = te.sampler;
            te.gfxTexture.bindExtraParam(oe, he, _e, pe);
          }
        }
        Z(z, "HAS_TEXTURE_u_baseColorTexture", bs.BaseColor), Z(R, "HAS_TEXTURE_u_metallicRoughnessTexture", bs.MetallicRoughness), Z(F, "HAS_TEXTURE_u_normalTexture", bs.Normal), Z(N, "HAS_TEXTURE_u_occlusionTexture", bs.Occlusion), Z(G, "HAS_TEXTURE_u_emissionTexture", bs.Emission), _ && (_.texture || (_.texture = new i.dk(h.context, _.image, [_.image.height, _.image.height, _.image.height], T.gl.RGBA8)), T.activeTexture.set(T.gl.TEXTURE0 + bs.LUT), _.texture && _.texture.bind(T.gl.LINEAR, T.gl.CLAMP_TO_EDGE), c.push("APPLY_LUT_ON_GPU")), s.texcoordBuffer && (c.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(s.texcoordBuffer)), s.colorBuffer && (c.push(s.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t.push(s.colorBuffer)), s.normalBuffer && (c.push("HAS_ATTRIBUTE_a_normal_3f"), t.push(s.normalBuffer)), s.pbrBuffer && (c.push("HAS_ATTRIBUTE_a_pbr"), c.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t.push(s.pbrBuffer)), y.alphaMode !== "OPAQUE" && y.alphaMode !== "MASK" || c.push("UNPREMULT_TEXTURE_IN_SHADER"), y.defined || c.push("DIFFUSE_SHADED"), c.push("USE_STANDARD_DERIVATIVES");
        const W = h.shadowRenderer;
        W && (c.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), W.useNormalOffset && c.push("NORMAL_OFFSET"));
      }
      function Lo(c, t, s, h, _, y) {
        const T = s.paint.get("model-opacity").constantOr(1), z = t.context, R = new Wt(t.context.gl.LEQUAL, Wt.ReadWrite, t.depthRangeFor3D), F = t.transform, N = c.mesh, G = N.material, Z = G.pbrMetallicRoughness, W = t.style.fog;
        let te;
        te = t.transform.projection.zAxisUnit === "pixels" ? [...c.nodeModelMatrix] : i.ab.mat4.multiply([], h.zScaleMatrix, c.nodeModelMatrix), i.ab.mat4.multiply(te, h.negCameraPosMatrix, te);
        const ee = i.ab.mat4.invert([], te);
        i.ab.mat4.transpose(ee, ee);
        const se = s.paint.get("model-color-use-theme").constantOr("default") === "none", oe = s.paint.get("model-emissive-strength").constantOr(0), he = gd(new Float32Array(c.worldViewProjection), new Float32Array(te), new Float32Array(ee), null, t, T, Z.baseColorFactor.toRenderColor(null), G.emissiveFactor, Z.metallicFactor, Z.roughnessFactor, G, oe, s), _e = { defines: [] }, pe = [], Me = t.shadowRenderer;
        Me && (Me.useNormalOffset = !1), du(_e.defines, pe, N, t, se ? null : s.lut);
        let xe = null;
        if (W) {
          const Pe = qi(c.nodeModelMatrix, t.transform);
          if (xe = new Float32Array(Pe), F.projection.name !== "globe") {
            const Oe = N.aabb.min, Xe = N.aabb.max, [He, ke] = W.getOpacityForBounds(Pe, Oe[0], Oe[1], Xe[0], Xe[1]);
            _e.overrideFog = He >= It || ke >= It;
          }
        }
        const we = Mo(t, s.paint.get("model-cutoff-fade-range"));
        we.shouldRenderCutoff && _e.defines.push("RENDER_CUTOFF");
        const ve = t.getOrCreateProgram("model", _e);
        t.uploadCommonUniforms(z, ve, null, xe, we), t.renderPass !== "shadow" && Me && Me.setupShadowsFromMatrix(c.nodeModelMatrix, ve), ve.draw(t, z.gl.TRIANGLES, R, _, y, N.material.doubleSided ? ti.disabled : ti.backCCW, he, s.id, N.vertexBuffer, N.indexBuffer, N.segments, s.paint, t.transform.zoom, void 0, pe);
      }
      function oh(c, t, s, h, _, y, T) {
        let z;
        z = c.projection.name === "globe" ? i.dl(s, c) : [...s], i.ab.mat4.multiply(z, z, t.matrix);
        const R = i.ab.mat4.multiply([], h, z);
        if (t.meshes)
          for (const F of t.meshes) {
            if (F.material.alphaMode !== "BLEND") {
              T.push({ mesh: F, depth: 0, modelIndex: _, worldViewProjection: R, nodeModelMatrix: z });
              continue;
            }
            const N = i.ab.vec3.transformMat4([], F.centroid, R);
            N[2] > 0 && y.push({ mesh: F, depth: N[2], modelIndex: _, worldViewProjection: R, nodeModelMatrix: z });
          }
        if (t.children)
          for (const F of t.children)
            oh(c, F, s, h, _, y, T);
      }
      function $a(c, t, s, h) {
        const _ = s.shadowRenderer;
        if (!_)
          return;
        const y = _.getShadowPassDepthMode(), T = _.getShadowPassColorMode(), z = _.calculateShadowPassMatrixFromMatrix(t), R = Qf(z);
        s.getOrCreateProgram("modelDepth", { defines: s._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(s, s.context.gl.TRIANGLES, y, ci.disabled, T, ti.backCCW, R, h.id, c.vertexBuffer, c.indexBuffer, c.segments, h.paint, s.transform.zoom, void 0, void 0);
      }
      function wd(c, t, s) {
        const h = t.updateZoomBasedPaintProperties(), _ = function(y, T, z) {
          let R, F, N, G = y.terrain ? y.terrain.exaggeration() : 0;
          if (y.terrain && G > 0) {
            const Z = y.terrain, W = Z.findDEMTileFor(z);
            W && W.dem ? R = i.dn.create(Z, z, W) : G = 0;
          }
          if (G === 0 && (T.terrainElevationMin = 0, T.terrainElevationMax = 0), G === T.validForExaggeration && (G === 0 || R && R._demTile && R._demTile.tileID === T.validForDEMTile.id && R._dem._timestamp === T.validForDEMTile.timestamp))
            return !1;
          for (const Z in T.instancesPerModel) {
            const W = T.instancesPerModel[Z];
            for (let te = 0; te < W.instancedDataArray.length; ++te) {
              const ee = (R ? G * R.getElevationAt(0 | W.instancedDataArray.float32[16 * te], 0 | W.instancedDataArray.float32[16 * te + 1], !0, !0) : 0) + W.instancesEvaluatedElevation[te];
              W.instancedDataArray.float32[16 * te + 6] = ee, F = F ? Math.min(T.terrainElevationMin, ee) : ee, N = N ? Math.max(T.terrainElevationMax, ee) : ee;
            }
          }
          return T.terrainElevationMin = F || 0, T.terrainElevationMax = N || 0, T.validForExaggeration = G, T.validForDEMTile = R && R._demTile ? { id: R._demTile.tileID, timestamp: R._dem._timestamp } : { id: void 0, timestamp: 0 }, !0;
        }(c, t, s);
        (h || _) && (t.uploaded = !1, t.upload(c.context));
      }
      const ho = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new i.cd([0, 0, 0], [i.ag, i.ag, 0]) };
      function Xa(c, t) {
        const s = 1 << c.canonical.z, h = t.getFreeCameraOptions().position, _ = t.elevation, y = c.canonical.x / s, T = (c.canonical.x + 1) / s, z = c.canonical.y / s, R = (c.canonical.y + 1) / s;
        let F = t._centerAltitude;
        if (_) {
          const W = _.getMinMaxForTile(c);
          W && W.max > F && (F = W.max);
        }
        const N = i.aw(h.x, y, T) - h.x, G = i.aw(h.y, z, R) - h.y, Z = i.bH(F, t.center.lat) - h.z;
        return t._zoomFromMercatorZ(Math.sqrt(N * N + G * G + Z * Z));
      }
      function va(c, t, s, h, _, y, T) {
        const z = c.context, R = c.renderPass === "shadow", F = c.shadowRenderer, N = R && F ? F.getShadowPassDepthMode() : new Wt(z.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D), G = c.isTileAffectedByFog(y);
        if (s.meshes)
          for (const Z of s.meshes) {
            const W = ["MODEL_POSITION_ON_GPU"], te = [];
            let ee, se, oe;
            h.instancedDataArray.length > 20 && W.push("INSTANCED_ARRAYS");
            const he = Mo(c, t.paint.get("model-cutoff-fade-range"));
            if (he.shouldRenderCutoff && W.push("RENDER_CUTOFF"), R && F)
              ee = c.getOrCreateProgram("modelDepth", { defines: W }), se = Qf(T.shadowTileMatrix, T.shadowTileMatrix, Float32Array.from(s.matrix)), oe = F.getShadowPassColorMode();
            else {
              du(W, te, Z, c, t.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : t.lut), ee = c.getOrCreateProgram("model", { defines: W, overrideFog: G });
              const pe = Z.material, Me = pe.pbrMetallicRoughness, xe = t.paint.get("model-opacity").constantOr(1), we = t.paint.get("model-emissive-strength").constantOr(0);
              se = gd(y.expandedProjMatrix, Float32Array.from(s.matrix), new Float32Array(16), null, c, xe, Me.baseColorFactor.toRenderColor(null), pe.emissiveFactor, Me.metallicFactor, Me.roughnessFactor, pe, we, t, _), F && (T.shadowUniformsInitialized ? ee.setShadowUniformValues(z, F.getShadowUniformValues()) : (F.setupShadows(y.toUnwrapped(), ee, "model-tile", y.overscaledZ), T.shadowUniformsInitialized = !0)), oe = he.shouldRenderCutoff || xe < 1 || pe.alphaMode !== "OPAQUE" ? bi.alphaBlended : bi.unblended;
            }
            c.uploadCommonUniforms(z, ee, y.toUnwrapped(), null, he);
            const _e = Z.material.doubleSided ? ti.disabled : ti.backCCW;
            if (h.instancedDataArray.length > 20)
              te.push(h.instancedDataBuffer), ee.draw(c, z.gl.TRIANGLES, N, ci.disabled, oe, _e, se, t.id, Z.vertexBuffer, Z.indexBuffer, Z.segments, t.paint, c.transform.zoom, void 0, te, h.instancedDataArray.length);
            else {
              const pe = R ? "u_instance" : "u_normal_matrix";
              for (let Me = 0; Me < h.instancedDataArray.length; ++Me)
                se[pe] = new Float32Array(h.instancedDataArray.arrayBuffer, 64 * Me, 16), ee.draw(c, z.gl.TRIANGLES, N, ci.disabled, oe, _e, se, t.id, Z.vertexBuffer, Z.indexBuffer, Z.segments, t.paint, c.transform.zoom, void 0, te);
            }
          }
        if (s.children)
          for (const Z of s.children)
            va(c, t, Z, h, _, y, T);
      }
      const Ya = [1, -1, 1];
      function fu(c, t, s, h) {
        if (!s.modelManager)
          return !0;
        const _ = s.modelManager;
        if (!s.shadowRenderer)
          return !0;
        const y = s.shadowRenderer, T = t.aabb;
        let z = !0, R = c.maxHeight;
        if (R === 0) {
          let N = 0;
          for (const G in c.instancesPerModel) {
            const Z = _.getModel(G, h);
            Z ? N = Math.max(N, Math.max(Math.max(Z.aabb.max[0], Z.aabb.max[1]), Z.aabb.max[2])) : z = !1;
          }
          R = c.maxScale * N * 1.41 + c.maxVerticalOffset, z && (c.maxHeight = R);
        }
        T.max[2] = R, T.min[2] += c.terrainElevationMin, T.max[2] += c.terrainElevationMax, i.ab.vec3.transformMat4(T.min, T.min, t.tileMatrix), i.ab.vec3.transformMat4(T.max, T.max, t.tileMatrix);
        const F = T.intersects(y.getCurrentCascadeFrustum());
        return s.currentShadowCascade === 0 && (c.isInsideFirstShadowMapFrustum = F === 2), F === 0;
      }
      function pu(c, t) {
        const s = c.uniformValues.u_cutoff_params[0], h = c.uniformValues.u_cutoff_params[1], _ = c.uniformValues.u_cutoff_params[2], y = c.uniformValues.u_cutoff_params[3];
        return h === s || y === _ ? 1 : i.aw(((t - s) / (h - s) - _) / (y - _), 0, 1);
      }
      function Td(c, t, s, h) {
        if (t.pitch < 20)
          return 1;
        const _ = t.getWorldToCameraMatrix();
        i.ab.mat4.multiply(_, _, c);
        const y = i.ab.vec4.fromValues(s.min[0], s.min[1], s.min[2], 1);
        let T = i.ab.vec4.transformMat4(i.ab.vec4.create(), y, _), z = T, R = T;
        y[1] = s.max[1], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), y, _), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R, y[0] = s.max[0], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), y, _), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R, y[1] = s.min[1], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), y, _), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R;
        const F = i.aw(h[0], 0, 1), N = 100 * t.pixelsPerMeter * i.aw(h[1], 0, 1), G = i.aw(h[2], 0, 1), Z = i.ab.vec4.lerp(i.ab.vec4.create(), z, R, F), W = Math.tan(0.5 * t.fovX), te = -Z[2] * W;
        if (N === 0)
          return Z[1] < -Math.abs(te) ? G : 1;
        const ee = (-Math.abs(te) - Z[1]) / N, se = (he, _e, pe) => (1 - pe) * he + pe * _e, oe = i.aw(se(1, G, ee), G, 1);
        return se(1, oe, i.aw((t.pitch - 20) / 20, 0, 1));
      }
      class Md {
      }
      class Sd {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(t, s, h) {
          {
            const G = this._storage.get(s.id);
            if (G)
              return G.lastUsedFrameIdx = t, G.buf;
          }
          const _ = h.gl, y = _.getBufferParameter(_.ELEMENT_ARRAY_BUFFER, _.BUFFER_SIZE), T = new ArrayBuffer(y), z = new Int16Array(T);
          _.getBufferSubData(_.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(T));
          const R = new i.dq();
          for (let G = 0; G < y / 2; G += 3) {
            const Z = z[G], W = z[G + 1], te = z[G + 2];
            R.emplaceBack(Z, W), R.emplaceBack(W, te), R.emplaceBack(te, Z);
          }
          const F = h.bindVertexArrayOES.current, N = new Md();
          return N.buf = new ea(h, R), N.lastUsedFrameIdx = t, this._storage.set(s.id, N), h.bindVertexArrayOES.set(F), N.buf;
        }
        update(t) {
          for (const [s, h] of this._storage)
            t - h.lastUsedFrameIdx > 30 && (h.buf.destroy(), this._storage.delete(s));
        }
        destroy() {
          for (const [t, s] of this._storage)
            s.buf.destroy(), this._storage.delete(t);
        }
      }
      class Ka {
        constructor(t) {
          this.occluderSize = 30, this.depthOffset = -1e-4, t.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), t.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
        }
      }
      const Ed = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
      class mu {
        registerParameter() {
        }
        registerButton() {
        }
        registerBinding() {
        }
        refreshUI() {
        }
      }
      class _u {
        constructor(t, s) {
          this.revealStart = 11, this.revealRange = 2, t.registerParameter(this, [...s, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), t.registerParameter(this, [...s, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
        }
      }
      const Ad = i.da([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
      class qs {
        destroy() {
          this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
        }
        draw(t, s) {
          const h = t.getOrCreateProgram("vignette");
          if (!this.vignetteVx || !this.vignetteIdx) {
            const T = new i.dr(), z = new i.aU();
            T.emplaceBack(-1, -1), T.emplaceBack(1, -1), T.emplaceBack(1, 1), T.emplaceBack(-1, 1), z.emplaceBack(0, 1, 2), z.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(T, Ad.members), this.vignetteIdx = t.context.createIndexBuffer(z);
          }
          const _ = i.b7.simpleSegment(0, 0, 4, 6);
          if (this.vignetteVx && this.vignetteIdx) {
            t.uploadCommonUniforms(t.context, h);
            const T = { u_vignetteShape: (y = { vignetteShape: [s.start, s.range, Math.pow(10, s.fadePower)], vignetteColor: [s.color.r, s.color.g, s.color.b, s.color.a * s.strength] }).vignetteShape, u_vignetteColor: y.vignetteColor };
            h.draw(t, t.context.gl.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, T, "vignette", this.vignetteVx, this.vignetteIdx, _, {});
          }
          var y;
        }
      }
      class Pd {
        constructor() {
          this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
        }
        update(t, s) {
          const h = t.getFreeCameraOptions().position, _ = h.toAltitude(), y = h.toLngLat(), T = i.ai(y.lng), z = i.ai(y.lat), R = t.pixelsPerMeter / s, F = T * i.ds, N = i.ds * Math.log(Math.tan(Math.PI / 4 + z / 2));
          if (this._offsetXPrev === void 0)
            this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          else {
            const G = -this._offsetYPrev + N, Z = -this._elevationPrev + _;
            this._accumulatedOffsetX += (-this._offsetXPrev + F) * R, this._accumulatedOffsetY += G * R, this._accumulatedElevation += Z * R, this._offsetXPrev = F, this._offsetYPrev = N, this._elevationPrev = _;
          }
        }
        getPosition() {
          return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
        }
      }
      function gu(c, t) {
        return [-(c[0] - Math.floor(c[0] / t) * t), -(c[1] - Math.floor(c[1] / t) * t), -(c[2] - Math.floor(c[2] / t) * t)];
      }
      function uc(c) {
        const t = i.di(1323123451230), s = [];
        for (let h = 0; h < c; ++h) {
          const _ = 2 * t() - 1, y = 2 * t() - 1, T = 2 * t() - 1;
          s.push(i.ab.vec3.fromValues(_, y, T));
        }
        return s;
      }
      function Rr(c, t, s, h, _) {
        const y = i.aw((_ - s) / (h - s), 0, 1);
        return (1 - y) * c + y * t;
      }
      class yu {
        constructor(t) {
          this._movement = new Pd(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new qs(), this._ppmScaleFactor = t;
        }
        destroy() {
          this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
        }
        updateOnRender(t, s) {
          const h = t.transform;
          this._movement.update(h, this._ppmScaleFactor);
          const _ = h.starsProjMatrix, y = i.ab.quat.identity([]);
          i.ab.quat.rotateX(y, y, i.ai(90) - h._pitch), i.ab.quat.rotateZ(y, y, -h.angle);
          const T = i.ab.mat4.fromQuat(new Float32Array(16), y), z = i.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), R = i.ab.mat4.transpose([], z), F = i.ab.mat4.multiply([], R, T), N = Date.now() / 1e3;
          return this._accumulatedTimeFromStart += (N - this._prevTime) * s, this._prevTime = N, { projectionMatrix: _, modelviewMatrix: F };
        }
      }
      class Cd extends yu {
        constructor(t) {
          super(4.25), this._params = { overrideStyleParameters: !1, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new _u(t.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t) {
          const s = t.context;
          if (!this.particlesVx) {
            const h = uc(this.particlesCount), _ = new i.dt(), y = new i.aU();
            let T = 0;
            const z = i.di(1323123451230);
            for (let R = 0; R < h.length; ++R) {
              const F = h[R], N = [2 * z() - 1, z(), z(), z()];
              _.emplaceBack(F[0], F[1], F[2], -1, -1, ...N), _.emplaceBack(F[0], F[1], F[2], 1, -1, ...N), _.emplaceBack(F[0], F[1], F[2], 1, 1, ...N), _.emplaceBack(F[0], F[1], F[2], -1, 1, ...N), y.emplaceBack(T + 0, T + 1, T + 2), y.emplaceBack(T + 0, T + 2, T + 3), T += 4;
            }
            this.particlesVx = s.createVertexBuffer(_, Ed.members), this.particlesIdx = s.createIndexBuffer(y);
          }
        }
        draw(t) {
          if (!this._params.overrideStyleParameters && !t.style.rain)
            return;
          const s = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, h = t.transform.zoom;
          if (s.revealStart > h)
            return;
          const _ = Rr(0, 1, s.revealStart, s.revealStart + s.revealRange, h);
          if (!this.particlesVx || !this.particlesIdx)
            return;
          const y = structuredClone(this._params);
          let T = [-y.direction.x, y.direction.y, -100];
          i.ab.vec3.normalize(T, T);
          const z = structuredClone(this._vignetteParams);
          z.strength *= _, y.overrideStyleParameters || (y.intensity = t.style.rain.state.density, y.timeFactor = t.style.rain.state.intensity, y.color = structuredClone(t.style.rain.state.color), T = structuredClone(t.style.rain.state.direction), y.screenThinning.intensity = t.style.rain.state.centerThinning, y.dropletSizeX = t.style.rain.state.dropletSize[0], y.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], y.distortionStrength = 100 * t.style.rain.state.distortionStrength, z.strength = 1, z.color = structuredClone(t.style.rain.state.vignetteColor));
          const R = this.updateOnRender(t, y.timeFactor), F = t.context, N = F.gl, G = t.transform;
          this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new i.T(F, { width: t.width, height: t.height, data: null }, N.RGBA8)), y.distortionStrength > 0 && (F.activeTexture.set(N.TEXTURE0), this.screenTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE), N.copyTexSubImage2D(N.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
          const Z = t.getOrCreateProgram("rainParticle");
          t.uploadCommonUniforms(F, Z), F.activeTexture.set(N.TEXTURE0), this.screenTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
          const W = [y.color.r, y.color.g, y.color.b, y.color.a], te = (ee, se) => {
            const oe = gu(this._movement.getPosition(), ee), he = y.dropletSizeX, _e = y.dropletSizeX * y.dropletSizeYScale, pe = t.width / 2, Me = t.height / 2, xe = Rr(0, y.screenThinning.start, 0, 1, y.screenThinning.intensity), we = Rr(1e-3, y.screenThinning.range, 0, 1, y.screenThinning.intensity), ve = Rr(0, y.screenThinning.particleOffset, 0, 1, y.screenThinning.intensity), Pe = (Oe = { modelview: R.modelviewMatrix, projection: R.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: oe, velocityConeAperture: y.velocityConeAperture, velocity: y.velocity, boxSize: ee, rainDropletSize: [he, _e], distortionStrength: y.distortionStrength, rainDirection: T, color: W, screenSize: [G.width, G.height], thinningCenterPos: [pe, Me], thinningShape: [xe, we, Math.pow(10, y.screenThinning.fadePower)], thinningAffectedRatio: y.screenThinning.affectedRatio, thinningParticleOffset: ve, shapeDirectionalPower: y.shapeDirPower, shapeNormalPower: y.shapeNormalPower, mode: se ? 0 : 1 }, { u_modelview: Float32Array.from(Oe.modelview), u_projection: Float32Array.from(Oe.projection), u_time: Oe.time, u_cam_pos: Oe.camPos, u_texScreen: 0, u_velocityConeAperture: Oe.velocityConeAperture, u_velocity: Oe.velocity, u_boxSize: Oe.boxSize, u_rainDropletSize: Oe.rainDropletSize, u_distortionStrength: Oe.distortionStrength, u_rainDirection: Oe.rainDirection, u_color: Oe.color, u_screenSize: Oe.screenSize, u_thinningCenterPos: Oe.thinningCenterPos, u_thinningShape: Oe.thinningShape, u_thinningAffectedRatio: Oe.thinningAffectedRatio, u_thinningParticleOffset: Oe.thinningParticleOffset, u_shapeDirectionalPower: Oe.shapeDirectionalPower, u_shapeNormalPower: Oe.shapeNormalPower, u_mode: Oe.mode });
            var Oe;
            const Xe = Math.round(_ * y.intensity * this.particlesCount), He = i.b7.simpleSegment(0, 0, 4 * Xe, 2 * Xe);
            Z.draw(t, N.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, Pe, "rain_particles", this.particlesVx, this.particlesIdx, He, {});
          };
          y.distortionStrength > 0 && te(y.boxSize, !0), te(y.boxSize, !1), this._vignette.draw(t, z);
        }
      }
      const Id = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
      class Al extends yu {
        constructor(t) {
          super(2.25), this._params = { overrideStyleParameters: !1, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new _u(t.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t) {
          const s = t.context;
          if (!this.particlesVx) {
            const h = uc(this.particlesCount), _ = new i.du(), y = new i.aU();
            let T = 0;
            const z = i.di(1323123451230);
            for (let R = 0; R < h.length; ++R) {
              const F = h[R], N = z(), G = z(), Z = z(), W = [R / h.length, N, G, Z], te = [z(), z()];
              _.emplaceBack(F[0], F[1], F[2], -1, -1, ...W, ...te), _.emplaceBack(F[0], F[1], F[2], 1, -1, ...W, ...te), _.emplaceBack(F[0], F[1], F[2], 1, 1, ...W, ...te), _.emplaceBack(F[0], F[1], F[2], -1, 1, ...W, ...te), y.emplaceBack(T + 0, T + 1, T + 2), y.emplaceBack(T + 0, T + 2, T + 3), T += 4;
            }
            this.particlesVx = s.createVertexBuffer(_, Id.members), this.particlesIdx = s.createIndexBuffer(y);
          }
        }
        draw(t) {
          if (!this._params.overrideStyleParameters && !t.style.snow)
            return;
          const s = structuredClone(this._params);
          let h = [-s.direction.x, s.direction.y, -100];
          i.ab.vec3.normalize(h, h);
          const _ = structuredClone(this._vignetteParams), y = s.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, T = t.transform.zoom;
          if (y.revealStart > T)
            return;
          const z = Rr(0, 1, y.revealStart, y.revealStart + y.revealRange, T);
          _.strength *= z, s.overrideStyleParameters || (s.intensity = t.style.snow.state.density, s.timeFactor = t.style.snow.state.intensity, s.color = structuredClone(t.style.snow.state.color), h = structuredClone(t.style.snow.state.direction), s.screenThinning.intensity = t.style.snow.state.centerThinning, s.billboardSize = 2.79 * t.style.snow.state.flakeSize, _.strength = 1, _.color = structuredClone(t.style.snow.state.vignetteColor));
          const R = this.updateOnRender(t, s.timeFactor);
          if (!this.particlesVx || !this.particlesIdx)
            return;
          const F = t.context, N = F.gl, G = t.transform, Z = t.getOrCreateProgram("snowParticle");
          t.uploadCommonUniforms(F, Z), ((W, te, ee) => {
            const se = gu(this._movement.getPosition(), W), oe = G.width / 2, he = G.height / 2, _e = Rr(0, ee.screenThinning.start, 0, 1, ee.screenThinning.intensity), pe = Rr(1e-3, ee.screenThinning.range, 0, 1, ee.screenThinning.intensity), Me = Rr(0, ee.screenThinning.particleOffset, 0, 1, ee.screenThinning.intensity), xe = (we = { modelview: R.modelviewMatrix, projection: R.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: se, velocityConeAperture: ee.velocityConeAperture, velocity: ee.velocity, horizontalOscillationRadius: ee.horizontalOscillationRadius, horizontalOscillationRate: ee.horizontalOscillationRate, boxSize: W, billboardSize: 1 * ee.billboardSize, simpleShapeParameters: [ee.shapeFadeStart, ee.shapeFadePower], screenSize: [G.width, G.height], thinningCenterPos: [oe, he], thinningShape: [_e, pe, Math.pow(10, ee.screenThinning.fadePower)], thinningAffectedRatio: ee.screenThinning.affectedRatio, thinningParticleOffset: Me, color: [ee.color.r, ee.color.g, ee.color.b, ee.color.a], direction: h }, { u_modelview: Float32Array.from(we.modelview), u_projection: Float32Array.from(we.projection), u_time: we.time, u_cam_pos: we.camPos, u_velocityConeAperture: we.velocityConeAperture, u_velocity: we.velocity, u_horizontalOscillationRadius: we.horizontalOscillationRadius, u_horizontalOscillationRate: we.horizontalOscillationRate, u_boxSize: we.boxSize, u_billboardSize: we.billboardSize, u_simpleShapeParameters: we.simpleShapeParameters, u_screenSize: we.screenSize, u_thinningCenterPos: we.thinningCenterPos, u_thinningShape: we.thinningShape, u_thinningAffectedRatio: we.thinningAffectedRatio, u_thinningParticleOffset: we.thinningParticleOffset, u_particleColor: we.color, u_direction: we.direction });
            var we;
            const ve = Math.round(z * ee.intensity * this.particlesCount), Pe = i.b7.simpleSegment(0, 0, 4 * ve, 2 * ve);
            this.particlesVx && this.particlesIdx && Z.draw(t, N.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, xe, "snow_particles", this.particlesVx, this.particlesIdx, Pe, {});
          })(s.boxSize, 0, s), this._vignette.draw(t, _);
        }
      }
      const ah = { symbol: function(c, t, s, h, _) {
        if (c.renderPass !== "translucent")
          return;
        const y = ci.disabled, T = c.colorModeForRenderPass(), z = s.layout.get("text-variable-anchor"), R = s.layout.get("text-size-scale-range"), F = i.aw(c.scaleFactor, R[0], R[1]);
        z && function(Z, W, te, ee, se, oe, he, _e) {
          const pe = W.transform, Me = se === "map", xe = oe === "map";
          for (const we of Z) {
            const ve = ee.getTile(we), Pe = ve.getBucket(te);
            if (!Pe || !Pe.text || !Pe.text.segments.get().length)
              continue;
            const Oe = i.bp(Pe.textSizeData, pe.zoom, _e), Xe = pa(we, Pe.getProjection(), pe), He = pe.calculatePixelsToTileUnitsMatrix(ve), ke = Js(Xe, ve.tileID.canonical, xe, Me, pe, Pe.getProjection(), He), Ne = Pe.hasIconTextFit() && Pe.hasIconData();
            if (Oe) {
              const st = Math.pow(2, pe.zoom - ve.tileID.overscaledZ);
              co(Pe, Me, xe, he, i.cX, pe, ke, we, st, Oe, Ne);
            }
          }
        }(h, c, s, t, s.layout.get("text-rotation-alignment"), s.layout.get("text-pitch-alignment"), _, F);
        const N = s.paint.get("icon-opacity").constantOr(1) !== 0, G = s.paint.get("text-opacity").constantOr(1) !== 0;
        s.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (N || G) ? Tn(c, t, s, h, y, T) : (N && Tn(c, t, s, h, y, T, { onlyIcons: !0 }), G && Tn(c, t, s, h, y, T, { onlyText: !0 })), t.map.showCollisionBoxes && (ou(c, t, s, h, s.paint.get("text-translate"), s.paint.get("text-translate-anchor"), !0), ou(c, t, s, h, s.paint.get("icon-translate"), s.paint.get("icon-translate-anchor"), !1));
      }, circle: function(c, t, s, h) {
        if (c.renderPass !== "translucent")
          return;
        const _ = s.paint.get("circle-opacity"), y = s.paint.get("circle-stroke-width"), T = s.paint.get("circle-stroke-opacity"), z = s.layout.get("circle-sort-key").constantOr(1) !== void 0, R = s.paint.get("circle-emissive-strength");
        if (_.constantOr(1) === 0 && (y.constantOr(1) === 0 || T.constantOr(1) === 0))
          return;
        const F = c.context, N = F.gl, G = c.transform, Z = c.depthModeForSublayer(0, Wt.ReadOnly), W = ci.disabled, te = c.colorModeForDrapableLayerRenderPass(R), ee = G.projection.name === "globe", se = [i.at(G.center.lng), i.aA(G.center.lat)], oe = [];
        for (let _e = 0; _e < h.length; _e++) {
          const pe = h[_e], Me = t.getTile(pe), xe = Me.getBucket(s);
          if (!xe || xe.projection.name !== G.projection.name)
            continue;
          const we = xe.programConfigurations.get(s.id), ve = i.cY(s), Pe = c.isTileAffectedByFog(pe);
          ee && ve.push("PROJECTION_GLOBE_VIEW"), ve.push("DEPTH_D24"), c.terrain && G.depthOcclusionForSymbolsAndCircles && ve.push("DEPTH_OCCLUSION");
          const Oe = c.getOrCreateProgram("circle", { config: we, defines: ve, overrideFog: Pe }), Xe = xe.layoutVertexBuffer, He = xe.globeExtVertexBuffer, ke = xe.indexBuffer, Ne = G.projection.createInversionMatrix(G, pe.canonical), st = { programConfiguration: we, program: Oe, layoutVertexBuffer: Xe, globeExtVertexBuffer: He, indexBuffer: ke, uniformValues: i.cZ(c, pe, Me, Ne, se, s), tile: Me };
          if (z) {
            const ut = xe.segments.get();
            for (const xt of ut)
              oe.push({ segments: new i.b7([xt]), sortKey: xt.sortKey, state: st });
          } else
            oe.push({ segments: xe.segments, sortKey: 0, state: st });
        }
        z && oe.sort((_e, pe) => _e.sortKey - pe.sortKey);
        const he = { useDepthForOcclusion: G.depthOcclusionForSymbolsAndCircles };
        for (const _e of oe) {
          const { programConfiguration: pe, program: Me, layoutVertexBuffer: xe, globeExtVertexBuffer: we, indexBuffer: ve, uniformValues: Pe, tile: Oe } = _e.state, Xe = _e.segments;
          c.terrain && c.terrain.setupElevationDraw(Oe, Me, he), c.uploadCommonUniforms(F, Me, Oe.tileID.toUnwrapped()), Me.draw(c, N.TRIANGLES, Z, W, te, ti.disabled, Pe, s.id, xe, ve, Xe, s.paint, G.zoom, pe, [we]);
        }
      }, heatmap: function(c, t, s, h) {
        if (s.paint.get("heatmap-opacity") !== 0)
          if (c.renderPass === "offscreen") {
            const _ = c.context, y = _.gl, T = ci.disabled, z = new bi([y.ONE, y.ONE, y.ONE, y.ONE], i.aj.transparent, [!0, !0, !0, !0]);
            (function(W, te, ee, se) {
              const oe = W.gl, he = te.width * se, _e = te.height * se;
              W.activeTexture.set(oe.TEXTURE1), W.viewport.set([0, 0, he, _e]);
              let pe = ee.heatmapFbo;
              if (!pe || pe && (pe.width !== he || pe.height !== _e)) {
                pe && pe.destroy();
                const Me = oe.createTexture();
                oe.bindTexture(oe.TEXTURE_2D, Me), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_S, oe.CLAMP_TO_EDGE), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_T, oe.CLAMP_TO_EDGE), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MIN_FILTER, oe.LINEAR), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MAG_FILTER, oe.LINEAR), pe = ee.heatmapFbo = W.createFramebuffer(he, _e, !0, null), function(xe, we, ve, Pe, Oe, Xe) {
                  const He = xe.gl;
                  He.texImage2D(He.TEXTURE_2D, 0, xe.extRenderToTextureHalfFloat ? He.RGBA16F : He.RGBA, Oe, Xe, 0, He.RGBA, xe.extRenderToTextureHalfFloat ? He.HALF_FLOAT : He.UNSIGNED_BYTE, null), Pe.colorAttachment.set(ve);
                }(W, 0, Me, pe, he, _e);
              } else
                oe.bindTexture(oe.TEXTURE_2D, pe.colorAttachment.get()), W.bindFramebuffer.set(pe.framebuffer);
            })(_, c, s, c.transform.projection.name === "globe" ? 0.5 : 0.25), _.clear({ color: i.aj.transparent });
            const R = c.transform, F = R.projection.name === "globe", N = F ? ["PROJECTION_GLOBE_VIEW"] : [], G = F ? ti.frontCCW : ti.disabled, Z = [i.at(R.center.lng), i.aA(R.center.lat)];
            for (let W = 0; W < h.length; W++) {
              const te = h[W];
              if (t.hasRenderableParent(te))
                continue;
              const ee = t.getTile(te), se = ee.getBucket(s);
              if (!se || se.projection.name !== R.projection.name)
                continue;
              const oe = c.isTileAffectedByFog(te), he = se.programConfigurations.get(s.id), _e = c.getOrCreateProgram("heatmap", { config: he, defines: N, overrideFog: oe }), { zoom: pe } = c.transform;
              c.terrain && c.terrain.setupElevationDraw(ee, _e), c.uploadCommonUniforms(_, _e, te.toUnwrapped());
              const Me = R.projection.createInversionMatrix(R, te.canonical);
              _e.draw(c, y.TRIANGLES, Wt.disabled, T, z, G, rc(c, te, ee, Me, Z, pe, s.paint.get("heatmap-intensity")), s.id, se.layoutVertexBuffer, se.indexBuffer, se.segments, s.paint, c.transform.zoom, he, F ? [se.globeExtVertexBuffer] : null);
            }
            _.viewport.set([0, 0, c.width, c.height]);
          } else
            c.renderPass === "translucent" && (c.context.setColorMode(c.colorModeForRenderPass()), function(_, y) {
              const T = _.context, z = T.gl, R = y.heatmapFbo;
              if (!R)
                return;
              T.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, R.colorAttachment.get()), T.activeTexture.set(z.TEXTURE1);
              let F = y.colorRampTexture;
              F || (F = y.colorRampTexture = new i.T(T, y.colorRamp, z.RGBA8)), F.bind(z.LINEAR, z.CLAMP_TO_EDGE), _.getOrCreateProgram("heatmapTexture").draw(_, z.TRIANGLES, Wt.disabled, ci.disabled, _.colorModeForRenderPass(), ti.disabled, ((N, G, Z, W) => ({ u_image: 0, u_color_ramp: 1, u_opacity: G.paint.get("heatmap-opacity") }))(0, y), y.id, _.viewportBuffer, _.quadTriangleIndexBuffer, _.viewportSegments, y.paint, _.transform.zoom);
            }(c, s));
      }, line: function(c, t, s, h) {
        if (c.renderPass !== "translucent")
          return;
        const _ = s.paint.get("line-opacity"), y = s.paint.get("line-width");
        if (_.constantOr(1) === 0 || y.constantOr(1) === 0)
          return;
        const T = s.paint.get("line-emissive-strength"), z = s.paint.get("line-occlusion-opacity"), R = s.layout.get("line-elevation-reference"), F = s.layout.get("line-width-unit") === "meters", N = R === "sea", G = c.context, Z = G.gl, W = !s.isDraped();
        if (W && c.transform.projection.name === "globe")
          return;
        const te = s.layout.get("line-cross-slope"), ee = te !== void 0, se = te < 1, oe = W ? new Wt(c.depthOcclusion ? Z.GREATER : Z.LEQUAL, Wt.ReadOnly, c.depthRangeFor3D) : c.depthModeForSublayer(0, Wt.ReadOnly), he = c.colorModeForDrapableLayerRenderPass(T), _e = c.terrain && c.terrain.renderingToTexture, pe = _e ? 1 : i.q.devicePixelRatio, Me = s.paint.get("line-dasharray"), xe = Me.constantOr(1), we = s.layout.get("line-cap"), ve = Me.constantOr(null), Pe = we.constantOr(null), Oe = s.paint.get("line-pattern"), Xe = Oe.constantOr(1), He = Oe.constantOr(null), ke = s.paint.get("line-opacity").constantOr(1);
        let Ne = !Xe && ke !== 1 || c.depthOcclusion && z > 0 && z < 1;
        const st = s.paint.get("line-gradient"), ut = Xe ? "linePattern" : "line", xt = i.c_(s);
        let Ge;
        if (_e && c.terrain && c.terrain.clipOrMaskOverlapStencilType() && (Ne = !1), z !== 0 && c.depthOcclusion) {
          const Je = s.paint._values["line-opacity"];
          Je && Je.value && Je.value.kind === "constant" ? Ge = Je.value : i.w(`Occlusion opacity for layer ${s.id} is supported only when line-opacity isn't data-driven.`);
        }
        if (W && (c.forceTerrainMode = !0), !W && z !== 0 && c.terrain && !_e)
          return void i.w(`Occlusion opacity for layer ${s.id} is supported on terrain only if the layer has line-z-offset enabled.`);
        const lt = Ne && W ? c.stencilModeFor3D() : ci.disabled;
        W && (xt.push("ELEVATED"), ee && xt.push(se ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), N && xt.push("ELEVATION_REFERENCE_SEA")), y.value.kind !== "constant" && y.value.isLineProgressConstant === !1 && xt.push("VARIABLE_LINE_WIDTH");
        for (const Je of h) {
          const _t = t.getTile(Je);
          if (Xe && !_t.patternsLoaded())
            continue;
          const ct = _t.getBucket(s);
          if (!ct)
            continue;
          c.prepareDrawTile();
          const nt = ct.programConfigurations.get(s.id), Lt = c.isTileAffectedByFog(Je), bt = c.getOrCreateProgram(ut, { config: nt, defines: xt, overrideFog: Lt, overrideRtt: !W && void 0 });
          if (He && _t.imageAtlas) {
            const wi = i.A.from(He), mn = _t.imageAtlas.patternPositions[wi.getSerializedPrimary()];
            mn && nt.setConstantPatternPositions(mn);
          }
          if (!Xe && ve && Pe && _t.lineAtlas) {
            const wi = _t.lineAtlas.getDash(ve, Pe);
            wi && nt.setConstantPatternPositions(wi);
          }
          let [zt, Bt] = s.paint.get("line-trim-offset");
          (Pe === "round" || Pe === "square") && zt !== Bt && (zt === 0 && (zt -= 1), Bt === 1 && (Bt += 1));
          const oi = _e ? Je.projMatrix : null, $t = F ? 1 / ct.tileToMeter / i.ar(_t, 1, c.transform.zoom) : 1, Xt = F ? 1 / ct.tileToMeter / i.ar(_t, 1, Math.floor(c.transform.zoom)) : 1, ai = Xe ? i.c$(c, _t, s, oi, pe, $t, Xt, [zt, Bt]) : i.d0(c, _t, s, oi, ct.lineClipsArray.length, pe, $t, Xt, [zt, Bt]);
          if (st) {
            const wi = ct.gradients[s.id];
            let mn = wi.texture;
            if (s.gradientVersion !== wi.version) {
              let Mn = 256;
              if (s.stepInterpolant) {
                const Xi = t.getSource().maxzoom, sn = Je.canonical.z === Xi ? Math.ceil(1 << c.transform.maxZoom - Je.canonical.z) : 1;
                Mn = i.aw(i.d1(ct.maxLineLength / i.ag * 1024 * sn), 256, G.maxTextureSize);
              }
              wi.gradient = i.d2({ expression: s.gradientExpression(), evaluationKey: "lineProgress", resolution: Mn, image: wi.gradient || void 0, clips: ct.lineClipsArray }), wi.texture ? wi.texture.update(wi.gradient) : wi.texture = new i.T(G, wi.gradient, Z.RGBA8), wi.version = s.gradientVersion, mn = wi.texture;
            }
            G.activeTexture.set(Z.TEXTURE1), mn.bind(s.stepInterpolant ? Z.NEAREST : Z.LINEAR, Z.CLAMP_TO_EDGE);
          }
          xe && (G.activeTexture.set(Z.TEXTURE0), _t.lineAtlasTexture && _t.lineAtlasTexture.bind(Z.LINEAR, Z.REPEAT), nt.updatePaintBuffers()), Xe && (G.activeTexture.set(Z.TEXTURE0), _t.imageAtlasTexture && _t.imageAtlasTexture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE), nt.updatePaintBuffers()), W && !N && c.terrain.setupElevationDraw(_t, bt), c.uploadCommonUniforms(G, bt, Je.toUnwrapped());
          const zi = (wi) => {
            Ge != null && (Ge.value = ke * z), bt.draw(c, Z.TRIANGLES, oe, wi, he, ti.disabled, ai, s.id, ct.layoutVertexBuffer, ct.indexBuffer, ct.segments, s.paint, c.transform.zoom, nt, [ct.layoutVertexBuffer2, ct.patternVertexBuffer, ct.zOffsetVertexBuffer]), Ge != null && (Ge.value = ke);
          };
          if (Ne && !W) {
            const wi = c.stencilModeForClipping(Je).ref;
            wi === 0 && _e && G.clear({ stencil: 0 });
            const mn = { func: Z.EQUAL, mask: 255 };
            ai.u_alpha_discard_threshold = 0.8, zi(new ci(mn, wi, 255, Z.KEEP, Z.KEEP, Z.INVERT)), ai.u_alpha_discard_threshold = 0, zi(new ci(mn, wi, 255, Z.KEEP, Z.KEEP, Z.KEEP));
          } else
            Ne && W && (ai.u_alpha_discard_threshold = 1e-3), zi(W ? lt : c.stencilModeForClipping(Je));
        }
        W && (c.forceTerrainMode = !1), Ne && (c.resetStencilClippingMasks(), _e && G.clear({ stencil: 0 })), z === 0 || c.depthOcclusion || _e || c.layersWithOcclusionOpacity.push(c.currentLayer);
      }, fill: function(c, t, s, h) {
        const _ = s.paint.get("fill-color"), y = s.paint.get("fill-opacity"), T = s.is3D(), z = new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D);
        if (y.constantOr(1) === 0)
          return;
        const R = s.paint.get("fill-emissive-strength"), F = c.colorModeForDrapableLayerRenderPass(R), N = s.paint.get("fill-pattern"), G = c.opaquePassEnabledForLayer() && !N.constantOr(1) && _.constantOr(i.aj.transparent).a === 1 && y.constantOr(0) === 1 ? "opaque" : "translucent";
        if (c.renderPass === G) {
          const Z = T ? z : c.depthModeForSublayer(1, c.renderPass === "opaque" ? Wt.ReadWrite : Wt.ReadOnly);
          lu(c, t, s, h, Z, F, !1);
        }
        if (!T && c.renderPass === "translucent" && s.paint.get("fill-antialias")) {
          const Z = T ? z : c.depthModeForSublayer(s.getPaintProperty("fill-outline-color") ? 2 : 0, Wt.ReadOnly);
          lu(c, t, s, h, Z, F, !0);
        }
      }, "fill-extrusion": function(c, t, s, h) {
        const _ = s.paint.get("fill-extrusion-opacity"), y = c.context, T = y.gl, z = c.terrain, R = z && z.renderingToTexture;
        if (_ === 0)
          return;
        const F = c.conflationActive && c.style.isLayerClipped(s, t.getSource()), N = c.style.order.indexOf(s.fqid);
        if (F && function(G, Z, W, te, ee) {
          for (const se of te) {
            const oe = Z.getTile(se).getBucket(W);
            oe && (oe.updateReplacement(se, G.replacementSource, ee), oe.uploadCentroid(G.context));
          }
        }(c, t, s, h, N), z || F)
          for (const G of h) {
            const Z = t.getTile(G).getBucket(s);
            Z && tp(c.context, t, G, Z, s, z, F);
          }
        if (c.renderPass === "shadow" && c.shadowRenderer) {
          const G = c.shadowRenderer;
          if (z && _ < 0.65 && s._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof i.a9)
            return;
          const Z = G.getShadowPassDepthMode(), W = G.getShadowPassColorMode();
          ih(c, t, s, h, Z, ci.disabled, W, F);
        } else if (c.renderPass === "translucent") {
          const G = !s.paint.get("fill-extrusion-pattern").constantOr(1), Z = s.paint.get("fill-extrusion-color").constantOr(i.aj.white);
          if (!R && Z.a !== 0) {
            const W = new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D);
            _ === 1 && G ? ih(c, t, s, h, W, ci.disabled, bi.unblended, F) : (ih(c, t, s, h, W, ci.disabled, bi.disabled, F), ih(c, t, s, h, W, c.stencilModeFor3D(), c.colorModeForRenderPass(), F), c.resetStencilClippingMasks());
          }
          if (c.style.enable3dLights() && G && (!z && c.transform.projection.name !== "globe" || R)) {
            const W = s.paint.get("fill-extrusion-opacity"), te = s.paint.get("fill-extrusion-ambient-occlusion-intensity"), ee = s.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), se = s.paint.get("fill-extrusion-flood-light-intensity"), oe = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", he = s.paint.get("fill-extrusion-flood-light-color").toRenderColor(oe ? null : s.lut).toArray01().slice(0, 3), _e = te > 0 && ee > 0, pe = se > 0, Me = (we, ve, Pe) => (1 - Pe) * we + Pe * ve, xe = (we) => {
              const ve = c.depthModeForSublayer(1, Wt.ReadOnly, T.LEQUAL, !0), Pe = s.paint.get(we ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), Oe = Me(0.1, 3, Pe), Xe = c._showOverdrawInspector;
              if (!Xe) {
                const He = new ci({ func: T.ALWAYS, mask: 255 }, 255, 255, T.KEEP, T.KEEP, T.REPLACE), ke = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0], T.MIN);
                Ml(c, t, s, h, ve, He, ke, ti.disabled, we, "sdf", W, te, ee, se, he, Oe, F, !1);
              }
              {
                const He = Xe ? ci.disabled : new ci({ func: T.EQUAL, mask: 255 }, 255, 255, T.KEEP, T.DECR, T.DECR), ke = Xe ? c.colorModeForRenderPass() : new bi([T.ONE_MINUS_DST_ALPHA, T.DST_ALPHA, T.ONE, T.ONE], i.aj.transparent, [!0, !0, !0, !0]);
                Ml(c, t, s, h, ve, He, ke, ti.disabled, we, "color", W, te, ee, se, he, Oe, F, !1);
              }
            };
            if (R) {
              const we = (ve, Pe, Oe) => {
                const Xe = c.depthModeForSublayer(1, Wt.ReadOnly, T.LEQUAL, !1), He = s.paint.get(ve ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), ke = Me(0.1, 3, He);
                {
                  const Ne = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0]);
                  Ml(c, t, s, h, Xe, ci.disabled, Ne, ti.disabled, ve, "clear", W, te, ee, se, he, ke, F, Pe);
                }
                {
                  const Ne = new ci({ func: T.ALWAYS, mask: 255 }, 255, 255, T.KEEP, T.KEEP, T.REPLACE), st = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0], T.MIN);
                  Ml(c, t, s, h, Xe, Ne, st, ti.disabled, ve, "sdf", W, te, ee, se, he, ke, F, Pe);
                }
                {
                  const Ne = ve ? T.ZERO : T.ONE_MINUS_DST_ALPHA, st = new ci({ func: T.EQUAL, mask: 255 }, 255, 255, T.KEEP, T.DECR, T.DECR), ut = new bi([Ne, T.DST_ALPHA, T.ONE_MINUS_DST_ALPHA, T.ZERO], i.aj.transparent, [!0, !0, !0, !0]);
                  Ml(c, t, s, h, Xe, st, ut, ti.disabled, ve, "color", W, te, ee, se, he, ke, F, Pe);
                }
                {
                  const Ne = new bi([T.ONE, T.ONE, T.ONE, ve ? T.ZERO : T.ONE], i.aj.transparent, [!1, !1, !1, !0], ve ? T.FUNC_ADD : T.MAX);
                  Ml(c, t, s, h, Xe, ci.disabled, Ne, ti.disabled, ve, "clear", W, te, ee, se, he, ke, F, Pe, Oe);
                }
              };
              if (_e || pe) {
                let ve;
                if (c.prepareDrawTile(), z) {
                  const Pe = z.drapeBufferSize[0], Oe = z.drapeBufferSize[1];
                  ve = z.framebufferCopyTexture, ve && (!ve || ve.size[0] === Pe && ve.size[1] === Oe) || (ve && ve.destroy(), ve = z.framebufferCopyTexture = new i.T(y, new i.r({ width: Pe, height: Oe }), T.RGBA8)), ve.bind(T.LINEAR, T.CLAMP_TO_EDGE), T.copyTexSubImage2D(T.TEXTURE_2D, 0, 0, 0, 0, 0, Pe, Oe);
                }
                _e && we(!0, !1, ve), pe && we(!1, !0, ve);
              }
            } else
              _e && xe(!0), pe && xe(!1), (_e || pe) && c.resetStencilClippingMasks();
          }
        }
      }, hillshade: function(c, t, s, h) {
        if (c.renderPass !== "offscreen" && c.renderPass !== "translucent" || c.style.disableElevatedTerrain)
          return;
        const _ = c.context, y = c.terrain && c.terrain.renderingToTexture, [T, z] = c.renderPass !== "translucent" || y ? [{}, h] : c.stencilConfigForOverlap(h);
        for (const R of z) {
          const F = t.getTile(R);
          if (F.needsHillshadePrepare && c.renderPass === "offscreen")
            qc(c, F, s);
          else if (c.renderPass === "translucent") {
            const N = c.depthModeForSublayer(0, Wt.ReadOnly), G = s.paint.get("hillshade-emissive-strength"), Z = c.colorModeForDrapableLayerRenderPass(G), W = y && c.terrain ? c.terrain.stencilModeForRTTOverlap(R) : T[R.overscaledZ];
            Ga(c, R, F, s, N, W, Z);
          }
        }
        _.viewport.set([0, 0, c.width, c.height]), c.resetStencilClippingMasks();
      }, raster: function(c, t, s, h, _, y) {
        if (c.renderPass !== "translucent" || s.paint.get("raster-opacity") === 0)
          return;
        const T = c.transform.projection.name === "globe", z = s.paint.get("raster-elevation") !== 0, R = z && T;
        if (c.renderElevatedRasterBackface && !R)
          return;
        const F = c.context, N = F.gl, G = t.getSource(), Z = function(xe, we, ve, Pe) {
          const Oe = we.paint.get("raster-color"), Xe = xe.type === "raster-array", He = [], ke = we.paint.get("raster-resampling"), Ne = we.paint.get("raster-color-mix");
          let st = we.paint.get("raster-color-range");
          const ut = [Ne[0], Ne[1], Ne[2], 0], xt = Ne[3];
          let Ge = ke === "nearest" ? Pe.NEAREST : Pe.LINEAR;
          if (Xe && (He.push("RASTER_ARRAY"), Oe || He.push("RASTER_COLOR"), ke === "linear" && He.push("RASTER_ARRAY_LINEAR"), Ge = Pe.NEAREST, !st && xe.rasterLayers)) {
            const lt = xe.rasterLayers.find(({ id: Je }) => Je === we.sourceLayer);
            lt && lt.fields && lt.fields.range && (st = lt.fields.range);
          }
          if (st = st || [0, 1], Oe) {
            He.push("RASTER_COLOR"), ve.activeTexture.set(Pe.TEXTURE2), we.updateColorRamp(st);
            let lt = we.colorRampTexture;
            lt || (lt = we.colorRampTexture = new i.T(ve, we.colorRamp, Pe.RGBA8)), lt.bind(Pe.LINEAR, Pe.CLAMP_TO_EDGE);
          }
          return { mix: ut, range: st, offset: xt, defines: He, resampling: Ge };
        }(G, s, F, N);
        if (G instanceof i.aJ && !h.length && !T)
          return;
        const W = s.paint.get("raster-emissive-strength"), te = c.colorModeForDrapableLayerRenderPass(W), ee = c.terrain && c.terrain.renderingToTexture, se = !c.options.moving, oe = s.paint.get("raster-resampling") === "nearest" ? N.NEAREST : N.LINEAR;
        if (G instanceof i.aJ && !h.length && (G.onNorthPole || G.onSouthPole)) {
          const xe = z ? c.stencilModeFor3D() : ci.disabled;
          return void Wa(!!G.onNorthPole, null, c, t, s, W, Z, ti.disabled, xe);
        }
        if (!h.length)
          return;
        const [he, _e] = G instanceof i.aJ || ee ? [{}, h] : c.stencilConfigForOverlap(h), pe = _e[_e.length - 1].overscaledZ;
        R && Z.defines.push("PROJECTION_GLOBE_VIEW"), z && Z.defines.push("RENDER_CUTOFF");
        const Me = (xe, we, ve) => {
          for (const Pe of xe) {
            const Oe = Pe.toUnwrapped(), Xe = t.getTile(Pe);
            if (ee && (!Xe || !Xe.hasData()))
              continue;
            F.activeTexture.set(N.TEXTURE0);
            const He = $e(Xe, G, s, Z);
            if (!He || !He.texture)
              continue;
            const { texture: ke, mix: Ne, offset: st, tileSize: ut, buffer: xt } = He;
            let Ge, lt;
            ee ? (Ge = Wt.disabled, lt = Pe.projMatrix) : z ? (Ge = new Wt(N.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D), lt = T ? Float32Array.from(c.transform.expandedFarZProjMatrix) : c.transform.calculateProjMatrix(Oe, se)) : (Ge = c.depthModeForSublayer(Pe.overscaledZ - pe, s.paint.get("raster-opacity") === 1 ? Wt.ReadWrite : Wt.ReadOnly, N.LESS), lt = c.transform.calculateProjMatrix(Oe, se));
            const Je = c.terrain && ee ? c.terrain.stencilModeForRTTOverlap(Pe) : he[Pe.overscaledZ], _t = y ? 0 : s.paint.get("raster-fade-duration");
            Xe.registerFadeDuration(_t);
            const ct = t.findLoadedParent(Pe, 0), nt = Jh(Xe, ct, t, c.transform, _t);
            let Lt, bt;
            c.terrain && c.terrain.prepareDrawTile(), F.activeTexture.set(N.TEXTURE0), ke.bind(oe, N.CLAMP_TO_EDGE), F.activeTexture.set(N.TEXTURE1), ct ? (ct.texture && ct.texture.bind(oe, N.CLAMP_TO_EDGE), Lt = Math.pow(2, ct.tileID.overscaledZ - Xe.tileID.overscaledZ), bt = [Xe.tileID.canonical.x * Lt % 1, Xe.tileID.canonical.y * Lt % 1]) : ke.bind(oe, N.CLAMP_TO_EDGE), ke.useMipmap && F.extTextureFilterAnisotropic && c.transform.pitch > 20 && N.texParameterf(N.TEXTURE_2D, F.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, F.extTextureFilterAnisotropicMax);
            const zt = c.transform;
            let Bt;
            const oi = z ? Bn(zt) : [0, 0, 0, 0];
            let $t, Xt, ai, zi, wi, mn = 0;
            if (R && G instanceof i.aJ && G.coordinates.length > 3)
              $t = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0)))), Xt = Float32Array.from(zt.globeMatrix), ai = Float32Array.from(i.cD(zt)), zi = [i.at(zt.center.lng), i.aA(zt.center.lat)], Bt = G.elevatedGlobePerspectiveTransform, wi = G.elevatedGlobeGridMatrix || new Float32Array(9);
            else if (R) {
              const _i = i.cE(Pe.canonical);
              mn = i.cF(_i.getCenter().lat), $t = Float32Array.from(i.bb(i.cH(Pe.canonical))), Xt = Float32Array.from(zt.globeMatrix), ai = Float32Array.from(i.cD(zt)), zi = [i.at(zt.center.lng), i.aA(zt.center.lat)], Bt = [0, 0], wi = Float32Array.from(i.cG(Pe.canonical, _i, mn, zt.worldSize / zt._pixelsPerMercatorPixel));
            } else
              Bt = G instanceof i.aJ ? G.perspectiveTransform : [0, 0], $t = new Float32Array(16), Xt = new Float32Array(9), ai = new Float32Array(16), zi = [0, 0], wi = new Float32Array(9);
            const Mn = pd(lt, $t, Xt, ai, wi, bt || [0, 0], i.ae(c.transform.zoom), zi, oi, Lt || 1, nt, s, Bt, z ? s.paint.get("raster-elevation") : 0, 2, Ne, st, Z.range, ut, xt, W), Xi = c.isTileAffectedByFog(Pe), sn = c.getOrCreateProgram("raster", { defines: Z.defines, overrideFog: Xi });
            if (c.uploadCommonUniforms(F, sn, Oe), G instanceof i.aJ) {
              const _i = G.elevatedGlobeVertexBuffer, Jt = G.elevatedGlobeIndexBuffer;
              if (ee || !T)
                G.boundsBuffer && G.boundsSegments && sn.draw(c, N.TRIANGLES, Ge, ci.disabled, te, ti.disabled, Mn, s.id, G.boundsBuffer, c.quadTriangleIndexBuffer, G.boundsSegments);
              else if (_i && Jt) {
                const ji = zt.zoom <= i.c6 ? G.elevatedGlobeSegments : G.getSegmentsForLongitude(zt.center.lng);
                ji && sn.draw(c, N.TRIANGLES, Ge, ci.disabled, te, we, Mn, s.id, _i, Jt, ji);
              }
            } else if (R) {
              Ge = new Wt(N.LEQUAL, Wt.ReadOnly, c.depthRangeFor3D);
              const _i = c.globeSharedBuffers;
              if (_i) {
                const [Jt, ji, Yi] = _i.getGridBuffers(mn, !1);
                sn.draw(c, N.TRIANGLES, Ge, ve || Je, c.colorModeForRenderPass(), we, Mn, s.id, Jt, ji, Yi);
              }
            } else {
              const { tileBoundsBuffer: _i, tileBoundsIndexBuffer: Jt, tileBoundsSegments: ji } = c.getTileBoundsBuffers(Xe);
              sn.draw(c, N.TRIANGLES, Ge, Je, te, ti.disabled, Mn, s.id, _i, Jt, ji);
            }
          }
          if (!(G instanceof i.aJ) && R)
            for (const Pe of xe) {
              const Oe = Pe.canonical.y === (1 << Pe.canonical.z) - 1;
              Pe.canonical.y === 0 && Wa(!0, Pe, c, t, s, W, Z, we, ve || ci.disabled), Oe && Wa(!1, Pe, c, t, s, W, Z, we === ti.frontCW ? ti.backCW : ti.frontCW, ve || ci.disabled);
            }
        };
        R ? Me(_e, c.renderElevatedRasterBackface ? ti.backCW : ti.frontCW, c.stencilModeFor3D()) : Me(_e, ti.disabled, void 0), c.resetStencilClippingMasks();
      }, "raster-particle": function(c, t, s, h, _, y) {
        c.renderPass === "offscreen" && function(T, z, R, F) {
          if (!F.length)
            return;
          const N = T.context, G = N.gl, Z = z.getSource();
          if (!(Z instanceof xn))
            return;
          const W = Math.ceil(Math.sqrt(R.paint.get("raster-particle-count")));
          let te = R.particlePositionRGBAImage;
          if (!te || te.width !== W) {
            const _e = function(pe) {
              const Me = pe * pe, xe = new Uint8Array(4 * Me), we = function(Pe) {
                return Pe |= 0, Pe = Math.imul(2747636419 ^ Pe, 2654435769), Pe = Math.imul(Pe ^ Pe >>> 16, 2654435769), ((Pe = Math.imul(Pe ^ Pe >>> 16, 2654435769)) >>> 0) / 4294967296;
              }, ve = 1 / 1.1;
              for (let Pe = 0; Pe < Me; Pe++) {
                const Oe = ve * (we(2 * Pe + 0) + lo), Xe = ve * (we(2 * Pe + 1) + lo), He = 255 * Oe % 1, ke = 255 * Xe % 1, Ne = He, st = Xe - ke / 255, ut = ke;
                xe[4 * Pe + 0] = 255 * (Oe - He / 255), xe[4 * Pe + 1] = 255 * Ne, xe[4 * Pe + 2] = 255 * st, xe[4 * Pe + 3] = 255 * ut;
              }
              return xe;
            }(W);
            te = R.particlePositionRGBAImage = new i.r({ width: W, height: W }, _e);
          }
          let ee = R.particleFramebuffer;
          ee ? ee.width !== W && (ee.destroy(), ee = R.particleFramebuffer = N.createFramebuffer(W, W, !0, null)) : ee = R.particleFramebuffer = N.createFramebuffer(W, W, !0, null);
          const se = [];
          for (const _e of F) {
            const pe = z.getTile(_e);
            if (!(pe instanceof ka))
              continue;
            const Me = bd(pe, Z, R);
            if (!Me)
              continue;
            const xe = [pe.tileSize, pe.tileSize];
            let we = R.tileFramebuffer;
            we || (we = R.tileFramebuffer = N.createFramebuffer(xe[0], xe[1], !0, null));
            let ve = pe.rasterParticleState;
            ve || (ve = pe.rasterParticleState = new cu(N, _e, xe, te));
            const Pe = ve.update(R.lastInvalidatedAt);
            ve.particleTextureDimension !== W && ve.updateParticleTexture(_e, te);
            const Oe = ve.targetColorTexture;
            ve.targetColorTexture = ve.backgroundColorTexture, ve.backgroundColorTexture = Oe;
            const Xe = ve.particleTexture0;
            ve.particleTexture0 = ve.particleTexture1, ve.particleTexture1 = Xe, se.push([_e, Me, ve, Pe]);
          }
          if (se.length === 0)
            return;
          const oe = i.q.now(), he = R.previousDrawTimestamp ? 1e-3 * (oe - R.previousDrawTimestamp) : 0.0167;
          if (R.previousDrawTimestamp = oe, R.hasColorMap()) {
            N.activeTexture.set(G.TEXTURE0 + 2);
            let _e = R.colorRampTexture;
            _e || (_e = R.colorRampTexture = new i.T(N, R.colorRamp, G.RGBA8)), _e.bind(G.LINEAR, G.CLAMP_TO_EDGE);
          }
          N.bindFramebuffer.set(R.tileFramebuffer.framebuffer), function(_e, pe, Me) {
            const xe = _e.context, we = xe.gl, ve = pe.tileFramebuffer;
            xe.activeTexture.set(we.TEXTURE0);
            const Pe = { u_texture: 0, u_opacity: 1.05 * (Xe = pe.paint.get("raster-particle-fade-opacity-factor")) / (Xe + 0.05) }, Oe = _e.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: !1 });
            var Xe;
            for (const He of Me) {
              const [, , ke, Ne] = He;
              ve.colorAttachment.set(ke.targetColorTexture.texture), xe.viewport.set([0, 0, ve.width, ve.height]), xe.clear({ color: i.aj.transparent }), Ne && (ke.backgroundColorTexture.bind(we.NEAREST, we.CLAMP_TO_EDGE), Oe.draw(_e, we.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, Pe, pe.id, _e.viewportBuffer, _e.quadTriangleIndexBuffer, _e.viewportSegments));
            }
          }(T, R, se), function(_e, pe, Me, xe) {
            const we = _e.context, ve = we.gl, Pe = Me.tileFramebuffer, Oe = _e.transform.projection.name === "globe", Xe = Me.paint.get("raster-particle-max-speed");
            for (const He of xe) {
              const [ke, Ne, st] = He;
              we.activeTexture.set(ve.TEXTURE0 + 0), Ne.texture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), Pe.colorAttachment.set(st.targetColorTexture.texture);
              const ut = _e.getOrCreateProgram("rasterParticleDraw", { defines: Ne.defines, overrideFog: !1 });
              we.activeTexture.set(ve.TEXTURE0 + 1);
              const xt = Ne.scalarData ? [] : [0, 1, 2, 3].map((Je) => i.d4[Je](ke));
              xt.push(ke);
              const Ge = ke.canonical.x, lt = ke.canonical.y;
              for (const Je of xt) {
                const _t = pe.getTile(Oe ? Je.wrapped() : Je);
                if (!_t)
                  continue;
                const ct = _t.rasterParticleState;
                if (!ct)
                  continue;
                const nt = Je.canonical.x + (1 << Je.canonical.z) * (Je.wrap - ke.wrap), Lt = Je.canonical.y;
                ct.particleTexture0.bind(ve.NEAREST, ve.CLAMP_TO_EDGE);
                const bt = Zt(1, ct.particleTexture0.size[0], [nt - Ge, Lt - lt], 0, Ne.texture.size, 2, Xe, Ne.textureOffset, Ne.scale, Ne.offset);
                ut.draw(_e, ve.POINTS, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, bt, Me.id, ct.particleIndexBuffer, void 0, ct.particleSegment);
              }
            }
          }(T, z, R, se), N.bindFramebuffer.set(R.particleFramebuffer.framebuffer), function(_e, pe, Me, xe) {
            const we = _e.context, ve = we.gl, Pe = pe.paint.get("raster-particle-max-speed"), Oe = xe * pe.paint.get("raster-particle-speed-factor") * 0.15, Xe = function(ke) {
              return Math.pow(ke, 6);
            }(0.01 + 1 * pe.paint.get("raster-particle-reset-rate-factor")), He = pe.particleFramebuffer;
            we.viewport.set([0, 0, He.width, He.height]);
            for (const ke of Me) {
              const [, Ne, st] = ke;
              we.activeTexture.set(ve.TEXTURE0 + 0), Ne.texture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), we.activeTexture.set(ve.TEXTURE0 + 1);
              const ut = st.particleTexture0;
              ut.bind(ve.NEAREST, ve.CLAMP_TO_EDGE);
              const xt = md(1, ut.size[0], 0, Ne.texture.size, Pe, Oe, Xe, Ne.textureOffset, Ne.scale, Ne.offset);
              He.colorAttachment.set(st.particleTexture1.texture), we.clear({ color: i.aj.transparent }), _e.getOrCreateProgram("rasterParticleUpdate", { defines: Ne.defines }).draw(_e, ve.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.disabled, xt, pe.id, _e.viewportBuffer, _e.quadTriangleIndexBuffer, _e.viewportSegments);
            }
          }(T, R, se, he);
        }(c, t, s, h), c.renderPass === "translucent" && (function(T, z, R, F, N) {
          const G = T.context, Z = G.gl, W = z.getSource().tileSize, te = 5 * (1 - i.ac(i.bY, i.bY + 1, T.transform.zoom)) * W + R.paint.get("raster-particle-elevation"), ee = !T.options.moving, se = T.transform.projection.name === "globe";
          if (!F.length)
            return;
          const [oe, he] = T.stencilConfigForOverlap(F), _e = [];
          se && _e.push("PROJECTION_GLOBE_VIEW");
          const pe = T.stencilModeFor3D();
          for (const Me of he) {
            const xe = Me.toUnwrapped(), we = z.getTile(Me);
            if (!we.rasterParticleState)
              continue;
            const ve = we.rasterParticleState, Pe = 100;
            we.registerFadeDuration(Pe);
            const Oe = z.findLoadedParent(Me, 0), Xe = Jh(we, Oe, z, T.transform, Pe);
            let He, ke;
            T.terrain && T.terrain.prepareDrawTile(), G.activeTexture.set(Z.TEXTURE0), ve.targetColorTexture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE), G.activeTexture.set(Z.TEXTURE1), Oe && Oe.rasterParticleState ? (Oe.rasterParticleState.targetColorTexture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE), He = Math.pow(2, Oe.tileID.overscaledZ - we.tileID.overscaledZ), ke = [we.tileID.canonical.x * He % 1, we.tileID.canonical.y * He % 1]) : ve.targetColorTexture.bind(Z.LINEAR, Z.CLAMP_TO_EDGE);
            const Ne = se ? Float32Array.from(T.transform.expandedFarZProjMatrix) : T.transform.calculateProjMatrix(xe, ee), st = T.transform, ut = np(st), xt = i.cE(Me.canonical), Ge = i.cF(xt.getCenter().lat);
            let lt, Je, _t, ct, nt;
            se ? (lt = Float32Array.from(i.bb(i.cH(Me.canonical))), Je = Float32Array.from(st.globeMatrix), _t = Float32Array.from(i.cD(st)), ct = [i.at(st.center.lng), i.aA(st.center.lat)], nt = Float32Array.from(i.cG(Me.canonical, xt, Ge, st.worldSize / st._pixelsPerMercatorPixel))) : (lt = new Float32Array(16), Je = new Float32Array(9), _t = new Float32Array(16), ct = [0, 0], nt = new Float32Array(9));
            const Lt = Tl(Ne, lt, Je, _t, nt, ke || [0, 0], i.ae(T.transform.zoom), ct, ut, He || 1, Xe, te), bt = T.isTileAffectedByFog(Me), zt = T.getOrCreateProgram("rasterParticle", { defines: _e, overrideFog: bt });
            if (T.uploadCommonUniforms(G, zt, xe), se) {
              const Bt = new Wt(Z.LEQUAL, Wt.ReadOnly, T.depthRangeFor3D), oi = 0, $t = T.globeSharedBuffers;
              if ($t) {
                const [Xt, ai, zi] = $t.getGridBuffers(Ge, oi !== 0);
                zt.draw(T, Z.TRIANGLES, Bt, pe, bi.alphaBlended, T.renderElevatedRasterBackface ? ti.frontCCW : ti.backCCW, Lt, R.id, Xt, ai, zi);
              }
            } else {
              const Bt = T.depthModeForSublayer(0, Wt.ReadOnly), oi = oe[Me.overscaledZ], { tileBoundsBuffer: $t, tileBoundsIndexBuffer: Xt, tileBoundsSegments: ai } = T.getTileBoundsBuffers(we);
              zt.draw(T, Z.TRIANGLES, Bt, oi, bi.alphaBlended, ti.disabled, Lt, R.id, $t, Xt, ai);
            }
          }
          T.resetStencilClippingMasks();
        }(c, t, s, h), c.style.map.triggerRepaint());
      }, background: function(c, t, s, h) {
        const _ = s.paint.get("background-color"), y = s.paint.get("background-color-use-theme").constantOr("default") === "none", T = s.paint.get("background-opacity"), z = s.paint.get("background-emissive-strength"), R = s.paint.get("background-pitch-alignment") === "viewport";
        if (T === 0)
          return;
        const F = c.context, N = F.gl, G = c.transform, Z = G.tileSize, W = s.paint.get("background-pattern");
        let te;
        if (W !== void 0 && (W === null || (te = c.imageManager.getPattern(W.toString(), s.scope, c.style.getLut(s.scope)), !te)))
          return;
        const ee = !W && _.a === 1 && T === 1 && c.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (c.renderPass !== ee)
          return;
        const se = ci.disabled, oe = c.depthModeForSublayer(0, ee === "opaque" ? Wt.ReadWrite : Wt.ReadOnly), he = c.colorModeForDrapableLayerRenderPass(z), _e = W ? "backgroundPattern" : "background";
        let pe, Me = h;
        if (Me || (pe = c.getBackgroundTiles(), Me = Object.values(pe).map((xe) => xe.tileID)), W && (F.activeTexture.set(N.TEXTURE0), c.imageManager.bind(c.context, s.scope)), R) {
          const xe = c.getOrCreateProgram(_e, { overrideFog: !1, overrideRtt: !0 }), we = new Float32Array(i.ab.mat4.identity([])), ve = new i.aG(0, 0, 0, 0, 0), Pe = W ? _d(we, z, T, c, 0, s.scope, te, R, { tileID: ve, tileSize: Z }) : su(we, z, T, _.toRenderColor(y ? null : s.lut));
          xe.draw(c, N.TRIANGLES, oe, se, he, ti.disabled, Pe, s.id, c.viewportBuffer, c.quadTriangleIndexBuffer, c.viewportSegments);
        } else
          for (const xe of Me) {
            const we = c.isTileAffectedByFog(xe), ve = c.getOrCreateProgram(_e, { overrideFog: we }), Pe = xe.toUnwrapped(), Oe = h ? xe.projMatrix : c.transform.calculateProjMatrix(Pe);
            c.prepareDrawTile();
            const Xe = t ? t.getTile(xe) : pe ? pe[xe.key] : new Cr(xe, Z, G.zoom, c), He = W ? _d(Oe, z, T, c, 0, s.scope, te, R, { tileID: xe, tileSize: Z }) : su(Oe, z, T, _.toRenderColor(y ? null : s.lut));
            c.uploadCommonUniforms(F, ve, Pe);
            const { tileBoundsBuffer: ke, tileBoundsIndexBuffer: Ne, tileBoundsSegments: st } = c.getTileBoundsBuffers(Xe);
            ve.draw(c, N.TRIANGLES, oe, se, he, ti.disabled, He, s.id, ke, Ne, st);
          }
      }, sky: function(c, t, s) {
        const h = c._atmosphere ? i.ae(c.transform.zoom) : 1, _ = s.paint.get("sky-opacity") * h;
        if (_ === 0)
          return;
        const y = c.context, T = s.paint.get("sky-type"), z = new Wt(y.gl.LEQUAL, Wt.ReadOnly, [0, 1]), R = c.frameCounter / 1e3 % 1;
        T === "atmosphere" ? c.renderPass === "offscreen" ? s.needsSkyboxCapture(c) && (function(F, N, G, Z) {
          const W = F.context, te = W.gl;
          let ee = N.skyboxFbo;
          if (!ee) {
            ee = N.skyboxFbo = W.createFramebuffer(32, 32, !0, null), N.skyboxGeometry = new Io(W), N.skyboxTexture = W.gl.createTexture(), te.bindTexture(te.TEXTURE_CUBE_MAP, N.skyboxTexture), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_WRAP_S, te.CLAMP_TO_EDGE), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_WRAP_T, te.CLAMP_TO_EDGE), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_MIN_FILTER, te.LINEAR), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_MAG_FILTER, te.LINEAR);
            for (let _e = 0; _e < 6; ++_e)
              te.texImage2D(te.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, te.RGBA, 32, 32, 0, te.RGBA, te.UNSIGNED_BYTE, null);
          }
          W.bindFramebuffer.set(ee.framebuffer), W.viewport.set([0, 0, 32, 32]);
          const se = N.getCenter(F, !0), oe = F.getOrCreateProgram("skyboxCapture"), he = new Float64Array(16);
          i.ab.mat4.identity(he), i.ab.mat4.rotateY(he, he, 0.5 * -Math.PI), El(F, N, oe, he, se, 0), i.ab.mat4.identity(he), i.ab.mat4.rotateY(he, he, 0.5 * Math.PI), El(F, N, oe, he, se, 1), i.ab.mat4.identity(he), i.ab.mat4.rotateX(he, he, 0.5 * -Math.PI), El(F, N, oe, he, se, 2), i.ab.mat4.identity(he), i.ab.mat4.rotateX(he, he, 0.5 * Math.PI), El(F, N, oe, he, se, 3), i.ab.mat4.identity(he), El(F, N, oe, he, se, 4), i.ab.mat4.identity(he), i.ab.mat4.rotateY(he, he, Math.PI), El(F, N, oe, he, se, 5), W.viewport.set([0, 0, F.width, F.height]);
        }(c, s), s.markSkyboxValid(c)) : c.renderPass === "sky" && function(F, N, G, Z, W) {
          const te = F.context, ee = te.gl, se = F.transform, oe = F.getOrCreateProgram("skybox");
          te.activeTexture.set(ee.TEXTURE0), ee.bindTexture(ee.TEXTURE_CUBE_MAP, N.skyboxTexture);
          const he = ((_e, pe, Me, xe, we) => ({ u_matrix: _e, u_sun_direction: pe, u_cubemap: 0, u_opacity: xe, u_temporal_offset: we }))(se.skyboxMatrix, N.getCenter(F, !1), 0, Z, W);
          F.uploadCommonUniforms(te, oe), oe.draw(F, ee.TRIANGLES, G, ci.disabled, F.colorModeForRenderPass(), ti.backCW, he, "skybox", N.skyboxGeometry.vertexBuffer, N.skyboxGeometry.indexBuffer, N.skyboxGeometry.segment);
        }(c, s, z, _, R) : T === "gradient" && c.renderPass === "sky" && function(F, N, G, Z, W) {
          const te = F.context, ee = te.gl, se = F.transform, oe = F.getOrCreateProgram("skyboxGradient");
          N.skyboxGeometry || (N.skyboxGeometry = new Io(te)), te.activeTexture.set(ee.TEXTURE0);
          let he = N.colorRampTexture;
          he || (he = N.colorRampTexture = new i.T(te, N.colorRamp, ee.RGBA8)), he.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
          const _e = ((pe, Me, xe, we, ve) => ({ u_matrix: pe, u_color_ramp: 0, u_center_direction: Me, u_radius: i.ai(xe), u_opacity: we, u_temporal_offset: ve }))(se.skyboxMatrix, N.getCenter(F, !1), N.paint.get("sky-gradient-radius"), Z, W);
          F.uploadCommonUniforms(te, oe), oe.draw(F, ee.TRIANGLES, G, ci.disabled, F.colorModeForRenderPass(), ti.backCW, _e, "skyboxGradient", N.skyboxGeometry.vertexBuffer, N.skyboxGeometry.indexBuffer, N.skyboxGeometry.segment);
        }(c, s, z, _, R);
      }, debug: function(c, t, s, h, _, y) {
        for (let T = 0; T < s.length; T++)
          if (_) {
            const F = new i.aj(h.r * 0.8, h.g * 0.8, h.b * 0.8, 1);
            Sl(c, t, s[T], h, -1, -1, y), Sl(c, t, s[T], h, -1, 1, y), Sl(c, t, s[T], h, 1, 1, y), Sl(c, t, s[T], h, 1, -1, y), Sl(c, t, s[T], F, 0, 0, y);
          } else
            Sl(c, t, s[T], h, 0, 0, y);
      }, custom: function(c, t, s, h) {
        const _ = c.context, y = s.implementation;
        if (!c.transform.projection.unsupportedLayers || !c.transform.projection.unsupportedLayers.includes("custom") || c.terrain && (c.terrain.renderingToTexture || c.renderPass === "offscreen") && s.isDraped(t)) {
          if (c.renderPass === "offscreen") {
            const T = y.prerender;
            if (T) {
              if (c.setCustomLayerDefaults(), _.setColorMode(c.colorModeForRenderPass()), c.transform.projection.name === "globe") {
                const z = c.transform.pointMerc;
                T.call(y, _.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), i.ae(c.transform.zoom), [z.x, z.y], c.transform.pixelsPerMeterRatio);
              } else
                T.call(y, _.gl, c.transform.customLayerMatrix());
              _.setDirty(), c.setBaseState();
            }
          } else if (c.renderPass === "translucent") {
            if (c.terrain && c.terrain.renderingToTexture) {
              const z = y.renderToTile;
              if (z) {
                const R = h[0].canonical, F = new i.aa(R.x + h[0].wrap * (1 << R.z), R.y, R.z);
                _.setDepthMode(Wt.disabled), _.setStencilMode(ci.disabled), _.setColorMode(c.colorModeForRenderPass()), c.setCustomLayerDefaults(), z.call(y, _.gl, F), _.setDirty(), c.setBaseState();
              }
              return;
            }
            c.setCustomLayerDefaults(), _.setColorMode(c.colorModeForRenderPass()), _.setStencilMode(ci.disabled);
            const T = y.renderingMode === "3d" ? new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D) : c.depthModeForSublayer(0, Wt.ReadOnly);
            if (_.setDepthMode(T), c.transform.projection.name === "globe") {
              const z = c.transform.pointMerc;
              y.render(_.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), i.ae(c.transform.zoom), [z.x, z.y], c.transform.pixelsPerMeterRatio);
            } else
              y.render(_.gl, c.transform.customLayerMatrix());
            _.setDirty(), c.setBaseState(), _.bindFramebuffer.set(null);
          }
        } else
          i.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(c, t, s, h) {
        if (c.renderPass === "opaque")
          return;
        const _ = s.paint.get("model-opacity").constantOr(1);
        if (_ === 0)
          return;
        const y = s.paint.get("model-cast-shadows");
        if (c.renderPass === "shadow" && (!y || c.terrain && _ < 0.65 && s._transitionablePaint._values["model-opacity"].value.expression instanceof i.a9))
          return;
        const T = c.shadowRenderer, z = s.paint.get("model-receive-shadows");
        T && (T.useNormalOffset = !0, z || (T.enabled = !1));
        const R = () => {
          T && (T.useNormalOffset = !0, z || (T.enabled = !0));
        }, F = t.getSource();
        if (c.renderPass === "light-beam" && F.type !== "batched-model")
          return;
        if (F.type === "vector" || F.type === "geojson")
          return function(oe, he, _e, pe, Me) {
            const xe = oe.transform;
            if (xe.projection.name !== "mercator")
              return void i.w(`Drawing 3D models for ${xe.projection.name} projection is not yet implemented`);
            const we = xe.getFreeCameraOptions().position;
            if (!oe.modelManager)
              return;
            const ve = oe.modelManager;
            _e.modelManager = ve;
            const Pe = oe.shadowRenderer;
            if (!_e._unevaluatedLayout._values.hasOwnProperty("model-id"))
              return;
            const Oe = _e._unevaluatedLayout._values["model-id"], Xe = { ..._e.layout.get("model-id").parameters }, He = oe.style.order.indexOf(_e.fqid);
            for (const ke of pe) {
              const Ne = he.getTile(ke).getBucket(_e);
              if (!Ne || Ne.projection.name !== xe.projection.name)
                continue;
              const st = Ne.getModelUris();
              st && !Ne.modelsRequested && (ve.addModelsFromBucket(st, Me), Ne.modelsRequested = !0);
              const ut = Xa(ke, xe);
              Xe.zoom = ut;
              const xt = Oe.possiblyEvaluate(Xe);
              if (wd(oe, Ne, ke), ho.shadowUniformsInitialized = !1, ho.useSingleShadowCascade = !!Pe && Pe.getMaxCascadeForTile(ke.toUnwrapped()) === 0, oe.renderPass === "shadow" && Pe) {
                if (oe.currentShadowCascade === 1 && Ne.isInsideFirstShadowMapFrustum)
                  continue;
                const Je = xe.calculatePosMatrix(ke.toUnwrapped(), xe.worldSize);
                if (ho.tileMatrix.set(Je), ho.shadowTileMatrix = Float32Array.from(Pe.calculateShadowPassMatrixFromMatrix(Je)), ho.aabb.min.fill(0), ho.aabb.max[0] = ho.aabb.max[1] = i.ag, ho.aabb.max[2] = 0, fu(Ne, ho, oe, _e.scope))
                  continue;
              }
              const Ge = 1 << ke.canonical.z, lt = [((we.x - ke.wrap) * Ge - ke.canonical.x) * i.ag, (we.y * Ge - ke.canonical.y) * i.ag, we.z * Ge * i.ag];
              oe.conflationActive && Object.keys(Ne.instancesPerModel).length > 0 && oe.style.isLayerClipped(_e, he.getSource()) && Ne.updateReplacement(ke, oe.replacementSource, He, Me) && (Ne.uploaded = !1, Ne.upload(oe.context));
              for (let Je in Ne.instancesPerModel) {
                const _t = Ne.instancesPerModel[Je];
                _t.features.length > 0 && (Je = xt.evaluate(_t.features[0].feature, {}));
                const ct = ve.getModel(Je, Me);
                if (ct && ct.uploaded)
                  for (const nt of ct.nodes)
                    va(oe, _e, nt, _t, lt, ke, ho);
              }
            }
          }(c, t, s, h, F.type === "vector" ? s.scope : ""), void R();
        if (!F.loaded())
          return;
        if (F.type === "batched-model")
          return function(oe, he, _e, pe) {
            _e.resetLayerRenderingStats(oe);
            const Me = oe.context, xe = oe.transform, we = oe.style.fog, ve = oe.shadowRenderer;
            if (xe.projection.name !== "mercator")
              return void i.w(`Drawing 3D landmark models for ${xe.projection.name} projection is not yet implemented`);
            const Pe = oe.transform.getFreeCameraOptions().position, Oe = i.ab.vec3.scale([], [Pe.x, Pe.y, Pe.z], oe.transform.worldSize), Xe = i.ab.vec3.negate([], Oe), He = i.ab.mat4.identity([]), ke = i.dj(xe.center.lat, xe.zoom), Ne = i.ab.mat4.fromScaling([], [1, 1, 1 / ke]);
            i.ab.mat4.translate(He, He, Xe);
            const st = _e.paint.get("model-opacity").constantOr(1), ut = new Wt(Me.gl.LEQUAL, Wt.ReadWrite, oe.depthRangeFor3D), xt = new Wt(Me.gl.LEQUAL, Wt.ReadOnly, oe.depthRangeFor3D), Ge = new i.cd([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), lt = oe.renderPass === "shadow", Je = lt && ve ? ve.getCurrentCascadeFrustum() : xe.getFrustum(xe.scaleZoom(xe.worldSize)), _t = _e.paint.get("model-front-cutoff"), ct = _t[2] < 1, nt = Mo(oe, _e.paint.get("model-cutoff-fade-range")), Lt = _e.getLayerRenderingStats();
            (function(bt, zt, Bt, oi) {
              const $t = bt.terrain ? bt.terrain.exaggeration() : 0, Xt = bt.transform.zoom;
              for (const ai of oi) {
                const zi = zt.getTile(ai).getBucket(Bt);
                zi && (bt.conflationActive && zi.updateReplacement(ai, bt.replacementSource), zi.evaluateScale(bt, Bt), bt.terrain && $t > 0 && zi.elevationUpdate(bt.terrain, $t, ai, Bt.source), zi.needsReEvaluation(bt, Xt, Bt) && zi.evaluate(Bt));
              }
            })(oe, he, _e, pe), function() {
              let bt, zt, Bt;
              ct ? (bt = pe.length - 1, zt = -1, Bt = -1) : (bt = 0, zt = pe.length, Bt = 1);
              const oi = new Float64Array(16), $t = i.ab.vec3.create(), Xt = new i.P(0, 0);
              for (let ai = bt; ai !== zt; ai += Bt) {
                const zi = pe[ai], wi = he.getTile(zi).getBucket(_e);
                if (!wi || !wi.uploaded)
                  continue;
                let mn = !1;
                ve && (mn = ve.getMaxCascadeForTile(zi.toUnwrapped()) === 0);
                const Mn = xe.calculatePosMatrix(zi.toUnwrapped(), xe.worldSize), Xi = wi.modelTraits;
                !lt && ct && (i.ab.mat4.invert(oi, Mn), i.ab.vec3.transformMat4($t, Oe, oi), Xt.x = $t[0], Xt.y = $t[1]);
                const sn = [];
                for (const _i of wi.getNodesInfo()) {
                  if (_i.hiddenByReplacement || !_i.node.meshes)
                    continue;
                  const Jt = _i.node;
                  let ji = 0;
                  oe.terrain && Jt.elevation && (ji = Jt.elevation * oe.terrain.exaggeration());
                  const Yi = (() => {
                    const Ri = _i.aabb;
                    return Ge.min = [...Ri.min], Ge.max = [...Ri.max], Ge.min[2] += ji, Ge.max[2] += ji, i.ab.vec3.transformMat4(Ge.min, Ge.min, Mn), i.ab.vec3.transformMat4(Ge.max, Ge.max, Mn), Ge;
                  })(), In = _i.evaluatedScale;
                  if (In[0] <= 1 && In[1] <= 1 && In[2] <= 1 && Yi.intersects(Je) === 0)
                    continue;
                  if (!lt && ct) {
                    const Ri = 0.16666666666666666;
                    _i.cameraCollisionOpacity = Oe[0] > Yi.min[0] && Oe[0] < Yi.max[0] && Oe[1] > Yi.min[1] && Oe[1] < Yi.max[1] && Oe[2] * ke < Yi.max[2] && Jt.footprint && i.bA(Xt, Jt.footprint) ? Math.max(_i.cameraCollisionOpacity - Ri, 0) : Math.min(1, _i.cameraCollisionOpacity + Ri);
                  }
                  const Fs = [...Mn], pr = Jt.anchor ? Jt.anchor[0] : 0, ts = Jt.anchor ? Jt.anchor[1] : 0;
                  i.ab.mat4.translate(Fs, Fs, [pr * (In[0] - 1), ts * (In[1] - 1), ji]), i.ab.vec3.exactEquals(In, i.dm) || i.ab.mat4.scale(Fs, Fs, In);
                  const As = i.ab.mat4.multiply([], Fs, Jt.matrix), Qs = i.ab.mat4.multiply([], xe.expandedFarZProjMatrix, As), jn = i.ab.mat4.multiply([], xe.expandedFarZProjMatrix, Fs), dn = i.ab.vec4.transformMat4([], [pr, ts, ji, 1], Qs)[2];
                  Jt.hidden = !1;
                  let _n = st;
                  lt || (ct && (_n *= _i.cameraCollisionOpacity, _n *= Td(Fs, xe, _i.aabb, _t)), _n *= pu(nt, dn)), _n !== 0 ? sn.push({ nodeInfo: _i, depth: dn, opacity: _n, wvpForNode: Qs, wvpForTile: jn, nodeModelMatrix: As, tileModelMatrix: Fs }) : Jt.hidden = !0;
                }
                lt || sn.sort((_i, Jt) => !ct || _i.opacity === 1 && Jt.opacity === 1 ? _i.depth < Jt.depth ? -1 : 1 : _i.opacity === 1 ? -1 : Jt.opacity === 1 ? 1 : _i.depth > Jt.depth ? -1 : 1);
                for (const _i of sn) {
                  const Jt = _i.nodeInfo, ji = Jt.node;
                  let Yi = i.ab.mat4.multiply([], Ne, _i.tileModelMatrix);
                  i.ab.mat4.multiply(Yi, He, Yi);
                  const In = i.ab.mat4.invert([], Yi);
                  i.ab.mat4.transpose(In, In), i.ab.mat4.scale(In, In, Ya), Yi = i.ab.mat4.multiply(Yi, Yi, ji.matrix);
                  const Fs = oe.renderPass === "light-beam", pr = _e.paint.get("model-color-use-theme").constantOr("default") === "none", ts = Xi & i.dp.HasMapboxMeshFeatures, As = ts ? 0 : Jt.evaluatedRMEA[0][2];
                  for (let Qs = 0; Qs < ji.meshes.length; ++Qs) {
                    const jn = ji.meshes[Qs], dn = Qs === ji.lightMeshIndex;
                    let _n = _i.wvpForNode;
                    if (dn) {
                      if (!Fs && !oe.terrain && oe.shadowRenderer) {
                        oe.currentLayer < oe.firstLightBeamLayer && (oe.firstLightBeamLayer = oe.currentLayer);
                        continue;
                      }
                      _n = _i.wvpForTile;
                    } else if (Fs)
                      continue;
                    const Ri = { defines: [] }, Gn = [];
                    if (!lt && ve && (ve.useNormalOffset = !!jn.normalBuffer), du(Ri.defines, Gn, jn, oe, pr ? null : _e.lut), ts || Ri.defines.push("DIFFUSE_SHADED"), mn && Ri.defines.push("SHADOWS_SINGLE_CASCADE"), Lt && (lt ? Lt.numRenderedVerticesInShadowPass += jn.vertexArray.length : Lt.numRenderedVerticesInTransparentPass += jn.vertexArray.length), lt) {
                      $a(jn, _i.nodeModelMatrix, oe, _e);
                      continue;
                    }
                    let Bs = null;
                    if (we) {
                      const mr = qi(_i.nodeModelMatrix, oe.transform);
                      if (Bs = new Float32Array(mr), xe.projection.name !== "globe") {
                        const ko = jn.aabb.min, Nr = jn.aabb.max, [il, ia] = we.getOpacityForBounds(mr, ko[0], ko[1], Nr[0], Nr[1]);
                        Ri.overrideFog = il >= It || ia >= It;
                      }
                    }
                    const cn = jn.material;
                    let er;
                    cn.occlusionTexture && cn.occlusionTexture.offsetScale && (er = cn.occlusionTexture.offsetScale, Ri.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                    const eo = oe.getOrCreateProgram("model", Ri);
                    !lt && ve && ve.setupShadowsFromMatrix(_i.tileModelMatrix, eo, ve.useNormalOffset), oe.uploadCommonUniforms(Me, eo, null, Bs);
                    const Br = cn.pbrMetallicRoughness;
                    Br.metallicFactor = 0.9, Br.roughnessFactor = 0.5;
                    const Ma = gd(new Float32Array(_n), new Float32Array(Yi), new Float32Array(In), new Float32Array(ji.matrix), oe, _i.opacity, Br.baseColorFactor.toRenderColor(null), cn.emissiveFactor, Br.metallicFactor, Br.roughnessFactor, cn, As, _e, [0, 0, 0], er);
                    !dn && (Jt.hasTranslucentParts || _i.opacity < 1) && eo.draw(oe, Me.gl.TRIANGLES, ut, ci.disabled, bi.disabled, ti.backCCW, Ma, _e.id, jn.vertexBuffer, jn.indexBuffer, jn.segments, _e.paint, oe.transform.zoom, void 0, Gn), eo.draw(oe, Me.gl.TRIANGLES, dn ? xt : ut, ci.disabled, dn || _i.opacity < 1 || Jt.hasTranslucentParts ? bi.alphaBlended : bi.unblended, ti.backCCW, Ma, _e.id, jn.vertexBuffer, jn.indexBuffer, jn.segments, _e.paint, oe.transform.zoom, void 0, Gn);
                  }
                }
              }
            }();
          }(c, t, s, h), void R();
        if (F.type !== "model")
          return;
        const N = F.getModels(), G = [], Z = c.transform.getFreeCameraOptions().position, W = i.ab.vec3.scale([], [Z.x, Z.y, Z.z], c.transform.worldSize);
        i.ab.vec3.negate(W, W);
        const te = [], ee = [];
        let se = 0;
        for (const oe of N) {
          const he = s.paint.get("model-rotation").constantOr(null), _e = s.paint.get("model-scale").constantOr(null), pe = s.paint.get("model-translation").constantOr(null);
          oe.computeModelMatrix(c, he, _e, pe, !0, !0, !1);
          const Me = i.ab.mat4.identity([]), xe = i.dj(oe.position.lat, c.transform.zoom), we = i.ab.mat4.fromScaling([], [1, 1, 1 / xe]);
          i.ab.mat4.translate(Me, Me, W), G.push({ zScaleMatrix: we, negCameraPosMatrix: Me });
          for (const ve of oe.nodes)
            oh(c.transform, ve, oe.matrix, c.transform.expandedFarZProjMatrix, se, te, ee);
          se++;
        }
        if (te.sort((oe, he) => he.depth - oe.depth), c.renderPass !== "shadow") {
          if (_ === 1)
            for (const oe of ee)
              Lo(oe, c, s, G[oe.modelIndex], ci.disabled, c.colorModeForRenderPass());
          else {
            for (const oe of ee)
              Lo(oe, c, s, G[oe.modelIndex], ci.disabled, bi.disabled);
            for (const oe of ee)
              Lo(oe, c, s, G[oe.modelIndex], c.stencilModeFor3D(), c.colorModeForRenderPass());
            c.resetStencilClippingMasks();
          }
          for (const oe of te)
            Lo(oe, c, s, G[oe.modelIndex], ci.disabled, c.colorModeForRenderPass());
          R();
        } else {
          for (const oe of ee)
            $a(oe.mesh, oe.nodeModelMatrix, c, s);
          for (const oe of te)
            $a(oe.mesh, oe.nodeModelMatrix, c, s);
          R();
        }
      } }, xu = { model: function(c, t, s) {
        const h = t.getSource();
        if (!h.loaded())
          return;
        if (h.type === "vector" || h.type === "geojson")
          return void (s.modelManager && s.modelManager.upload(s, h.type === "vector" ? c.scope : ""));
        if (h.type === "batched-model" || h.type !== "model")
          return;
        const _ = h.getModels();
        for (const y of _)
          y.upload(s.context);
      }, raster: function(c, t, s) {
        const h = t.getSource();
        if (!(h instanceof xn && h.loaded()))
          return;
        const _ = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
        if (!_)
          return;
        const y = c.paint.get("raster-array-band") || h.getInitialBand(_);
        if (y == null)
          return;
        const T = t.getIds().map((z) => t.getTileByID(z));
        for (const z of T)
          z.updateNeeded(_, y) && h.prepareTile(z, _, y);
      }, "raster-particle": function(c, t, s) {
        const h = t.getSource();
        if (!(h instanceof xn && h.loaded()))
          return;
        const _ = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
        if (!_)
          return;
        const y = c.paint.get("raster-particle-array-band") || h.getInitialBand(_);
        if (y == null)
          return;
        const T = t.getIds().map((z) => t.getTileByID(z));
        for (const z of T)
          z.updateNeeded(_, y) && h.prepareTile(z, _, y);
      } };
      class Ld {
        constructor(t, s, h, _, y) {
          this.context = new qa(t, s), this.transform = h, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = y, this._timeStamp = i.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: !1, showTerrainProxyTiles: !1, fpsWindow: 30, continousRedraw: !1, enabledLayers: {} };
          const T = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
          for (const R of T)
            this._debugParams.enabledLayers[R] = !0;
          y.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
            this.style.map.triggerRepaint();
          }), y.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), y.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), y.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: !0, label: "continuous redraw" }), y.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "value" }), y.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "graph", view: "graph", min: 0, max: 200 });
          for (const R of T)
            y.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], R);
          this.occlusionParams = new Ka(y), this.setup(), this.numSublayers = sr.maxUnderzooming + sr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new i.dv(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new So(this), this._wireframeDebugCache = new Sd(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
          const z = new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
          this.emptyDepthTexture = new i.T(this.context, z, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = _;
        }
        updateTerrain(t, s) {
          const h = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
          if (!(h || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new Wf(this, t));
          const _ = this._terrain;
          this.transform.elevation = h ? _ : null, _.update(t, this.transform, s), this.transform.elevation && !_.enabled && (this.transform.elevation = null);
        }
        _updateFog(t) {
          const s = t.fog;
          if (!s || this.transform.projection.name === "globe" || s.getOpacity(this.transform.pitch) < 1 || s.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [h, _] = s.getFovAdjustedRange(this.transform._fov);
          if (h > _)
            return void (this.transform.fogCullDistSq = null);
          const y = h + 0.78 * (_ - h);
          this.transform.fogCullDistSq = y * y;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
        }
        get forceTerrainMode() {
          return this._forceTerrainMode;
        }
        set forceTerrainMode(t) {
          t && !this._terrain && (this._terrain = new Wf(this, this.style)), this._forceTerrainMode = t;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t, s) {
          if (this.width = t * i.q.devicePixelRatio, this.height = s * i.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const h of this.style.order)
              this.style._mergedLayers[h].resize();
        }
        setup() {
          const t = this.context, s = new i.b4();
          s.emplaceBack(0, 0), s.emplaceBack(i.ag, 0), s.emplaceBack(0, i.ag), s.emplaceBack(i.ag, i.ag), this.tileExtentBuffer = t.createVertexBuffer(s, i.b6.members), this.tileExtentSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const h = new i.b4();
          h.emplaceBack(0, 0), h.emplaceBack(i.ag, 0), h.emplaceBack(0, i.ag), h.emplaceBack(i.ag, i.ag), this.debugBuffer = t.createVertexBuffer(h, i.b6.members), this.debugSegments = i.b7.simpleSegment(0, 0, 4, 5);
          const _ = new i.b4();
          _.emplaceBack(-1, -1), _.emplaceBack(1, -1), _.emplaceBack(-1, 1), _.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(_, i.b6.members), this.viewportSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const y = new i.aT();
          y.emplaceBack(0, 0, 0, 0), y.emplaceBack(i.ag, 0, i.ag, 0), y.emplaceBack(0, i.ag, 0, i.ag), y.emplaceBack(i.ag, i.ag, i.ag, i.ag), this.mercatorBoundsBuffer = t.createVertexBuffer(y, i.b9.members), this.mercatorBoundsSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const T = new i.aU();
          T.emplaceBack(0, 1, 2), T.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(T);
          const z = new i.b5();
          for (const F of [0, 1, 3, 2, 0])
            z.emplaceBack(F);
          this.debugIndexBuffer = t.createIndexBuffer(z), this.emptyTexture = new i.T(t, new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = i.ab.mat4.create();
          const R = this.context.gl;
          this.stencilClearMode = new ci({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.loadTimeStamps.push(performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(t) {
          return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? { tileBoundsBuffer: t._tileBoundsBuffer, tileBoundsIndexBuffer: t._tileBoundsIndexBuffer, tileBoundsSegments: t._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, Wt.disabled, this.stencilClearMode, bi.disabled, ti.disabled, nc(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(t, s, h) {
          if (!s || this.currentStencilSource === s.id || !t.isTileClipped() || !h || h.length === 0)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let z = !1;
            for (const R of h)
              if (this._tileClippingMaskIDs[R.key] === void 0) {
                z = !0;
                break;
              }
            if (!z)
              return;
          }
          this.currentStencilSource = s.id;
          const _ = this.context, y = _.gl;
          this.nextStencilID + h.length > 256 && this.clearStencil(), _.setColorMode(bi.disabled), _.setDepthMode(Wt.disabled);
          const T = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const z of h) {
            const R = s.getTile(z), F = this._tileClippingMaskIDs[z.key] = this.nextStencilID++, { tileBoundsBuffer: N, tileBoundsIndexBuffer: G, tileBoundsSegments: Z } = this.getTileBoundsBuffers(R);
            T.draw(this, y.TRIANGLES, Wt.disabled, new ci({ func: y.ALWAYS, mask: 0 }, F, 255, y.KEEP, y.KEEP, y.REPLACE), bi.disabled, ti.disabled, nc(z.projMatrix), "$clipping", N, G, Z);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++, s = this.context.gl;
          return new ci({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilModeForClipping(t) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t);
          const s = this.context.gl;
          return new ci({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const s = this.context.gl, h = t.sort((T, z) => z.overscaledZ - T.overscaledZ), _ = h[h.length - 1].overscaledZ, y = h[0].overscaledZ - _ + 1;
          if (y > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + y > 256 && this.clearStencil();
            const T = {};
            for (let z = 0; z < y; z++)
              T[z + _] = new ci({ func: s.GEQUAL, mask: 255 }, z + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
            return this.nextStencilID += y, [T, h];
          }
          return [{ [_]: ci.disabled }, h];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new bi([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new i.aj(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? bi.unblended : bi.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t) {
          const s = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && this.renderPass === "translucent" ? new bi([s.ONE, s.ONE_MINUS_SRC_ALPHA, s.CONSTANT_ALPHA, s.ONE_MINUS_SRC_ALPHA], new i.aj(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(t, s, h, _ = !1) {
          if (this.depthOcclusion)
            return new Wt(this.context.gl.GREATER, Wt.ReadOnly, this.depthRangeFor3D);
          if (!this.opaquePassEnabledForLayer() && !_)
            return Wt.disabled;
          const y = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Wt(h || this.context.gl.LEQUAL, s, [y, y]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        blitDepth() {
          const t = this.context.gl, s = Math.ceil(this.width), h = Math.ceil(this.height), _ = this.context.bindFramebuffer.get(), y = t.getParameter(t.TEXTURE_BINDING_2D);
          this.depthFBO && this.depthFBO.width === s && this.depthFBO.height === h || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), s !== 0 && h !== 0 && (this.depthFBO = new br(this.context, s, h, !1, "texture"), this.depthTexture = new i.T(this.context, { width: s, height: h, data: null }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(_), t.bindTexture(t.TEXTURE_2D, y), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, s, h, 0, 0, s, h, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));
        }
        updateAverageFPS() {
          this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((t, s) => t + s / this._fpsHistory.length, 0));
        }
        render(t, s) {
          const h = i.q.now();
          this._dt = h - this._timeStamp, this._timeStamp = h, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = s;
          const _ = this.style._mergedLayers, y = this.style._getOrder(!(!this.terrain || !this.terrain.enabled)).filter((ke) => {
            const Ne = _[ke];
            return !(Ne.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[Ne.type];
          });
          let T = !1, z = !1;
          for (const ke of y) {
            const Ne = _[ke];
            Ne.type === "circle" && (T = !0), Ne.type === "symbol" && (Ne.hasInitialOcclusionOpacityProperties ? z = !0 : T = !0);
          }
          const R = y.map((ke) => _[ke]), F = this.style._mergedSourceCaches;
          this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(i.q.now()), this.imageManager.beginFrame();
          let N = 0, G = !1;
          for (const ke in F) {
            const Ne = F[ke];
            Ne.used && (Ne.prepare(this.context), Ne.getSource().usedInConflation && ++N);
          }
          let Z = !1;
          for (const ke of R)
            ke.isHidden(this.transform.zoom) || (ke.type === "clip" && (Z = !0), this.prepareLayer(ke));
          const W = {}, te = {}, ee = {}, se = {}, oe = {};
          for (const ke in F) {
            const Ne = F[ke];
            W[ke] = Ne.getVisibleCoordinates(), te[ke] = W[ke].slice().reverse(), ee[ke] = Ne.getVisibleCoordinates(!0).reverse(), se[ke] = Ne.getShadowCasterCoordinates(), oe[ke] = Ne.sortCoordinatesByDistance(W[ke]);
          }
          const he = (ke) => {
            const Ne = this.style.getLayerSourceCache(ke);
            return Ne && Ne.used ? Ne.getSource() : null;
          };
          if (N || Z || this._clippingActiveLastFrame) {
            const ke = [], Ne = [];
            let st = 0;
            for (const ut of R)
              this.isSourceForClippingOrConflation(ut, he(ut)) && (ke.push(ut), Ne.push(st)), st++;
            if (ke && (Z || ke.length > 1) || this._clippingActiveLastFrame) {
              Z = !1;
              const ut = [];
              for (let xt = 0; xt < ke.length; xt++) {
                const Ge = ke[xt], lt = Ne[xt], Je = this.style.getLayerSourceCache(Ge);
                if (!Je || !Je.used || !Je.getSource().usedInConflation && Ge.type !== "clip")
                  continue;
                let _t = i.dx, ct = i.by.None;
                const nt = [];
                let Lt = !0;
                if (Ge.type === "clip") {
                  _t = lt;
                  for (const bt of Ge.layout.get("clip-layer-types"))
                    ct |= bt === "model" ? i.by.Model : bt === "symbol" ? i.by.Symbol : i.by.FillExtrusion;
                  for (const bt of Ge.layout.get("clip-layer-scope"))
                    nt.push(bt);
                  Ge.isHidden(this.transform.zoom) ? Lt = !1 : Z = !0;
                }
                Lt && ut.push({ layer: Ge.fqid, cache: Je, order: _t, clipMask: ct, clipScope: nt });
              }
              this.replacementSource.setSources(ut), G = !0;
            }
          }
          this._clippingActiveLastFrame = Z, G || this.replacementSource.clear(), this.conflationActive = G, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
          for (let ke = 0; ke < R.length; ke++) {
            const Ne = R[ke], st = Ne.cutoffRange();
            if (this.longestCutoffRange = Math.max(st, this.longestCutoffRange), st > 0) {
              const ut = he(Ne);
              ut && (this.minCutoffZoom = Math.max(ut.minzoom, this.minCutoffZoom)), Ne.minzoom && (this.minCutoffZoom = Math.max(Ne.minzoom, this.minCutoffZoom));
            }
            Ne.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = ke), this._lastOcclusionLayer = ke);
          }
          const _e = this.style && this.style.fog;
          _e ? (this._fogVisible = _e.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = _e.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(ee), this.opaquePassCutoff = 0);
          const pe = this._shadowRenderer;
          if (pe) {
            pe.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const ke in F)
              for (const Ne of W[ke]) {
                let st = { min: 0, max: 0 };
                this.terrain && (st = this.terrain.getMinMaxForTile(Ne) || st), pe.addShadowReceiver(Ne.toUnwrapped(), st.min, st.max);
              }
          }
          this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new i.dw(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new bn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
          const Me = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), xe = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
          if (Me && !this._snow && (this._snow = new Al(this)), !Me && this._snow && (this._snow.destroy(), delete this._snow), xe && !this._rain && (this._rain = new Cd(this)), !xe && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !Vs.has(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const ke of R) {
            const Ne = t.getLayerSourceCache(ke);
            if (!ke.hasOffscreenPass() || ke.isHidden(this.transform.zoom))
              continue;
            const st = Ne ? te[Ne.id] : void 0;
            (ke.type === "custom" || ke.type === "raster" || ke.type === "raster-particle" || ke.isSky() || st && st.length) && this.renderLayer(this, Ne, ke, st);
          }
          this.depthRangeFor3D = [0, 1 - (R.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, se)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const we = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(), ve = (() => {
            if (s.showOverdrawInspector)
              return i.aj.black;
            const ke = this.style.fog;
            if (ke && this.transform.projection.supportsFog) {
              const Ne = this.style.getLut(ke.scope);
              if (!we) {
                const st = ke.properties.get("color-use-theme") === "none", ut = ke.properties.get("color").toRenderColor(st ? null : Ne).toArray01();
                return new i.aj(...ut);
              }
              if (we) {
                const st = ke.properties.get("space-color-use-theme") === "none", ut = ke.properties.get("space-color").toRenderColor(st ? null : Ne).toArray01();
                return new i.aj(...ut);
              }
            }
            return i.aj.transparent;
          })();
          if (this.context.clear({ color: ve, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = s.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && we && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
            for (this.currentLayer = y.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
              if (ke.isSky())
                continue;
              const st = Ne ? (ke.is3D() ? oe : te)[Ne.id] : void 0;
              this._renderTileClippingMasks(ke, Ne, st), this.renderLayer(this, Ne, ke, st);
            }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && we && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || i.ae(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible()))
            for (this.currentLayer = 0; this.currentLayer < y.length; this.currentLayer++) {
              const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
              ke.isSky() && this.renderLayer(this, Ne, ke, Ne ? te[Ne.id] : void 0);
            }
          function Pe(ke, Ne) {
            let st;
            return Ne && (st = (ke.type === "symbol" ? ee : ke.is3D() ? oe : te)[Ne.id]), st;
          }
          if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
            for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < y.length; ) {
              const ke = R[this.currentLayer];
              if (ke.type === "raster" || ke.type === "raster-particle") {
                const Ne = t.getLayerSourceCache(ke);
                this.renderLayer(this, Ne, ke, Pe(ke, Ne));
              }
              ++this.currentLayer;
            }
            this.renderElevatedRasterBackface = !1;
          }
          this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let Oe = 0;
          pe && (Oe = pe.getShadowCastingLayerCount());
          let Xe = !1, He = -1;
          for (let ke = 0; ke < y.length; ++ke) {
            const Ne = R[ke];
            Ne.isHidden(this.transform.zoom) || Ne.is3D() && (He = ke);
          }
          for (z && He === -1 && (T = !0); this.currentLayer < y.length; ) {
            const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
            if (ke.isSky())
              ++this.currentLayer;
            else if (this.terrain && this.style.isLayerDraped(ke)) {
              if (ke.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
            } else {
              if (T && !Xe && this.terrain && !this.transform.isOrthographic && (Xe = !0, this.blitDepth()), z && He !== -1 && this.currentLayer === He + 1 && !this.transform.isOrthographic && this.blitDepth(), ke.is3D() || this.terrain || this._renderTileClippingMasks(ke, Ne, Ne ? W[Ne.id] : void 0), this.renderLayer(this, Ne, ke, Pe(ke, Ne)), !this.terrain && pe && Oe > 0 && ke.hasShadowPass() && --Oe == 0 && (pe.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                const st = this.currentLayer;
                for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= st; this.currentLayer++) {
                  const ut = R[this.currentLayer];
                  if (!ut.hasLightBeamPass())
                    continue;
                  const xt = t.getLayerSourceCache(ut);
                  this.renderLayer(this, xt, ut, xt ? te[xt.id] : void 0);
                }
                this.currentLayer = st, this.renderPass = "translucent";
              }
              if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                const st = this.currentLayer;
                this.depthOcclusion = !0;
                for (const ut of this.layersWithOcclusionOpacity) {
                  this.currentLayer = ut;
                  const xt = R[this.currentLayer], Ge = t.getLayerSourceCache(xt), lt = Ge ? te[Ge.id] : void 0;
                  xt.is3D() || this.terrain || this._renderTileClippingMasks(xt, Ge, Ge ? W[Ge.id] : void 0), this.renderLayer(this, Ge, xt, lt);
                }
                this.depthOcclusion = !1, this.currentLayer = st, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
              }
              ++this.currentLayer;
            }
          }
          if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let ke = null;
            R.forEach((Ne) => {
              const st = t.getLayerSourceCache(Ne);
              st && !Ne.isHidden(this.transform.zoom) && st.getVisibleCoordinates().length && (!ke || ke.getSource().maxzoom < st.getSource().maxzoom) && (ke = st);
            }), ke && this.options.showTileBoundaries && ah.debug(this, ke, ke.getVisibleCoordinates(), i.aj.red, !1, this.options.showParseStatus);
          }
          this.terrain && this._debugParams.showTerrainProxyTiles && ah.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new i.aj(1, 0.8, 0.1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(ke) {
            const Ne = ke.transform.padding;
            nh(ke, ke.transform.height - (Ne.top || 0), 3, sp), nh(ke, Ne.bottom || 0, 3, rp), hu(ke, Ne.left || 0, 3, hc), hu(ke, ke.transform.width - (Ne.right || 0), 3, t_);
            const st = ke.transform.centerPoint;
            (function(ut, xt, Ge, lt) {
              sh(ut, xt - 1, Ge - 10, 2, 20, lt), sh(ut, xt - 10, Ge - 1, 20, 2, lt);
            })(ke, st.x, ke.transform.height - st.y, i_);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), G || (this.conflationActive = !1);
        }
        prepareLayer(t) {
          this.gpuTimingStart(t);
          const { unsupportedLayers: s } = this.transform.projection, h = !s || !s.includes(t.type);
          if (xu[t.type] && (h || this.terrain && t.type === "custom")) {
            const _ = this.style.getLayerSourceCache(t);
            xu[t.type](t, _, this);
          }
          this.gpuTimingEnd();
        }
        renderLayer(t, s, h, _) {
          h.isHidden(this.transform.zoom) || (h.type === "background" || h.type === "sky" || h.type === "custom" || h.type === "model" || h.type === "raster" || h.type === "raster-particle" || _ && _.length) && (this.id = h.id, this.gpuTimingStart(h), t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(h.type) && (!t.terrain || h.type !== "custom") || h.type === "clip" || ah[h.type](t, s, h, _, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(t) {
          if (!this.options.gpuTiming)
            return;
          const s = this.context.extTimerQuery, h = this.context.gl;
          let _ = this.gpuTimers[t.id];
          _ || (_ = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: h.createQuery() }), _.calls++, h.beginQuery(s.TIME_ELAPSED_EXT, _.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const t = this.context.extTimerQuery, s = this.context.gl, h = s.createQuery();
            this.deferredRenderGpuTimeQueries.push(h), s.beginQuery(t.TIME_ELAPSED_EXT, h);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const t = this.gpuTimers;
          return this.gpuTimers = {}, t;
        }
        collectDeferredRenderGpuQueries() {
          const t = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], t;
        }
        queryGpuTimers(t) {
          const s = {};
          for (const h in t) {
            const _ = t[h], y = this.context.extTimerQuery, T = y.getQueryParameter(_.query, this.context.gl.QUERY_RESULT) / 1e6;
            y.deleteQueryEXT(_.query), s[h] = T;
          }
          return s;
        }
        queryGpuTimeDeferredRender(t) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const s = this.context.gl;
          let h = 0;
          for (const _ of t)
            h += s.getQueryParameter(_, s.QUERY_RESULT) / 1e6, s.deleteQuery(_);
          return h;
        }
        translatePosMatrix(t, s, h, _, y) {
          if (!h[0] && !h[1])
            return t;
          const T = y ? _ === "map" ? this.transform.angle : 0 : _ === "viewport" ? -this.transform.angle : 0;
          if (T) {
            const F = Math.sin(T), N = Math.cos(T);
            h = [h[0] * N - h[1] * F, h[0] * F + h[1] * N];
          }
          const z = [y ? h[0] : i.ar(s, h[0], this.transform.zoom), y ? h[1] : i.ar(s, h[1], this.transform.zoom), 0], R = new Float32Array(16);
          return i.ab.mat4.translate(R, t, z), R;
        }
        saveTileTexture(t) {
          const s = t.size[0], h = this._tileTextures[s];
          h ? h.push(t) : this._tileTextures[s] = [t];
        }
        getTileTexture(t) {
          const s = this._tileTextures[t];
          return s && s.length > 0 ? s.pop() : null;
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
        }
        linearFloatFilteringSupported() {
          return this.context.extTextureFloatLinear != null;
        }
        currentGlobalDefines(t, s, h) {
          const _ = h === void 0 ? this.terrain && this.terrain.renderingToTexture : h, y = [];
          return this.style && this.style.enable3dLights() && (t === "globeRaster" || t === "terrainRaster" ? (y.push("LIGHTING_3D_MODE"), y.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : _ || y.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || y.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (y.push("TERRAIN"), this.linearFloatFilteringSupported() && y.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && y.push("GLOBE"), !this._fogVisible || _ || s !== void 0 && !s || y.push("FOG", "FOG_DITHERING"), _ && y.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && y.push("OVERDRAW_INSPECTOR"), y;
        }
        getOrCreateProgram(t, s) {
          this.cache = this.cache || {};
          const h = s && s.defines || [], _ = s && s.config, y = this.currentGlobalDefines(t, s && s.overrideFog, s && s.overrideRtt).concat(h), T = Xf.cacheKey(vl[t], t, y, _);
          return this.cache[T] || (this.cache[T] = new Xf(this.context, t, vl[t], _, yd[t], y)), this.cache[T];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new i.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t, s) {
          if (this.style.enable3dLights()) {
            const h = this.style.directionalLight, _ = this.style.ambientLight;
            if (h && _) {
              const y = ((T, z, R) => {
                const F = T.properties.get("direction"), N = T.properties.get("color-use-theme") === "none", G = T.properties.get("color").toRenderColor(N ? null : R.getLut(T.scope)).toArray01(), Z = T.properties.get("intensity"), W = z.properties.get("color-use-theme") === "none", te = z.properties.get("color").toRenderColor(W ? null : R.getLut(z.scope)).toArray01(), ee = z.properties.get("intensity"), se = [F.x, F.y, F.z], oe = i.cM(te, ee), he = i.cM(G, Z);
                return { u_lighting_ambient_color: oe, u_lighting_directional_dir: se, u_lighting_directional_color: he, u_ground_radiance: $f(se, he, oe) };
              })(h, _, this.style);
              s.setLightsUniformValues(t, y);
            }
          }
        }
        uploadCommonUniforms(t, s, h, _, y) {
          if (this.uploadCommonLightUniforms(t, s), this.terrain && this.terrain.renderingToTexture)
            return;
          const T = this.style.fog;
          if (T) {
            const z = T.getOpacity(this.transform.pitch), R = ((F, N, G, Z, W, te, ee, se, oe, he, _e, pe) => {
              const Me = F.transform, xe = N.properties.get("color-use-theme") === "none", we = N.properties.get("color").toRenderColor(xe ? null : F.style.getLut(N.scope)).toArray01();
              we[3] = Z;
              const ve = F.frameCounter / 1e3 % 1, [Pe, Oe] = N.properties.get("vertical-range");
              return { u_fog_matrix: G ? Me.calculateFogTileMatrix(G) : pe || F.identityMat, u_fog_range: N.getFovAdjustedRange(Me._fov), u_fog_color: we, u_fog_horizon_blend: N.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(Pe, Oe), Oe], u_fog_temporal_offset: ve, u_frustum_tl: W, u_frustum_tr: te, u_frustum_br: ee, u_frustum_bl: se, u_globe_pos: oe, u_globe_radius: he, u_viewport: _e, u_globe_transition: i.ae(Me.zoom), u_is_globe: +(Me.projection.name === "globe") };
            })(this, T, h, z, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * i.q.devicePixelRatio, this.transform.height * i.q.devicePixelRatio], _);
            s.setFogUniformValues(t, R);
          }
          y && s.setCutoffUniformValues(t, y.uniformValues);
        }
        setTileLoadedFlag(t) {
          this.tileLoaded = t;
        }
        saveCanvasCopy() {
          const t = this.canvasCopy();
          t && (this.frameCopies.push(t), this.tileLoaded = !1);
        }
        canvasCopy() {
          const t = this.context.gl, s = t.createTexture();
          return t.bindTexture(t.TEXTURE_2D, s), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), s;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return !1;
          const t = this.style && this.style.fog;
          return !!t && t.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const t = this._backgroundTiles, s = this._backgroundTiles = {}, h = this.transform.coveringTiles({ tileSize: 512 });
          for (const _ of h)
            s[_.key] = t[_.key] || new Cr(_, 512, this.transform.tileZoom, this);
          return s;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        isSourceForClippingOrConflation(t, s) {
          return !(!t.is3D() || t.type !== "clip" && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || t.sourceLayer !== "building") && (!s || s.type !== "batched-model")));
        }
        isTileAffectedByFog(t) {
          if (!this.style || !this.style.fog)
            return !1;
          if (this.transform.projection.name === "globe")
            return !0;
          let s = this._cachedTileFogOpacities[t.key];
          return s || (this._cachedTileFogOpacities[t.key] = s = this.style.fog.getOpacityForTile(t)), s[0] >= It || s[1] >= It;
        }
        setupDepthForOcclusion(t, s, h) {
          const _ = this.context, y = _.gl, T = !!h;
          var z;
          h || (h = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), _.activeTexture.set(y.TEXTURE3), t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(y.NEAREST, y.CLAMP_TO_EDGE), h.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], h.u_depth_range_unpack = [2 / ((z = this.depthRangeFor3D)[1] - z[0]), -1 - 2 * z[0] / (z[1] - z[0])], h.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, h.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(y.NEAREST, y.CLAMP_TO_EDGE), _.activeTexture.set(y.TEXTURE0), T || s.setTerrainUniformValues(_, h);
        }
      }
      function lh(c, t) {
        let s = !1, h = null;
        const _ = () => {
          h = null, s && (c(), h = setTimeout(_, t), s = !1);
        };
        return () => (s = !0, h || _(), h);
      }
      class zd {
        constructor(t) {
          this._hashName = t && encodeURIComponent(t), i.aP(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = lh(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t) {
          return this._map = t, window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const t = this._map;
          if (!t)
            return "";
          const s = vu(t);
          if (this._hashName) {
            const h = this._hashName;
            let _ = !1;
            const y = location.hash.slice(1).split("&").map((T) => {
              const z = T.split("=")[0];
              return z === h ? (_ = !0, `${z}=${s}`) : T;
            }).filter((T) => T);
            return _ || y.push(`${h}=${s}`), `#${y.join("&")}`;
          }
          return `#${s}`;
        }
        _getCurrentHash() {
          const t = location.hash.replace("#", "");
          if (this._hashName) {
            let s;
            return t.split("&").map((h) => h.split("=")).forEach((h) => {
              h[0] === this._hashName && (s = h);
            }), (s && s[1] || "").split("/");
          }
          return t.split("/");
        }
        _onHashChange() {
          const t = this._map;
          if (!t)
            return !1;
          const s = this._getCurrentHash();
          if (s.length >= 3 && !s.some((h) => isNaN(h))) {
            const h = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(s[3] || 0) : t.getBearing();
            return t.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: h, pitch: +(s[4] || 0) }), !0;
          }
          return !1;
        }
        _updateHashUnthrottled() {
          history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
        }
      }
      function vu(c, t) {
        const s = c.getCenter(), h = Math.round(100 * c.getZoom()) / 100, _ = Math.ceil((h * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), y = Math.pow(10, _), T = Math.round(s.lng * y) / y, z = Math.round(s.lat * y) / y, R = c.getBearing(), F = c.getPitch();
        let N = t ? `/${T}/${z}/${h}` : `${h}/${z}/${T}`;
        return (R || F) && (N += "/" + Math.round(10 * R) / 10), F && (N += `/${Math.round(F)}`), N;
      }
      const ch = { linearity: 0.3, easing: i.dy(0, 0, 0.3, 1) }, ap = i.l({ deceleration: 2500, maxSpeed: 1400 }, ch), lp = i.l({ deceleration: 20, maxSpeed: 1400 }, ch), cp = i.l({ deceleration: 1e3, maxSpeed: 360 }, ch), hp = i.l({ deceleration: 1e3, maxSpeed: 90 }, ch);
      class up {
        constructor(t) {
          this._map = t, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: i.q.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer, s = i.q.now();
          for (; t.length > 0 && s - t[0].time > 160; )
            t.shift();
        }
        _onMoveEnd(t) {
          if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
            return;
          const s = { zoom: 0, bearing: 0, pitch: 0, pan: new i.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: y } of this._inertiaBuffer)
            s.zoom += y.zoomDelta || 0, s.bearing += y.bearingDelta || 0, s.pitch += y.pitchDelta || 0, y.panDelta && s.pan._add(y.panDelta), y.around && (s.around = y.around), y.pinchAround && (s.pinchAround = y.pinchAround);
          const h = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, _ = {};
          if (s.pan.mag()) {
            const y = uh(s.pan.mag(), h, i.l({}, ap, t || {}));
            _.offset = s.pan.mult(y.amount / s.pan.mag()), _.center = this._map.transform.center, hh(_, y);
          }
          if (s.zoom) {
            const y = uh(s.zoom, h, lp);
            _.zoom = this._map.transform.zoom + y.amount, hh(_, y);
          }
          if (s.bearing) {
            const y = uh(s.bearing, h, cp);
            _.bearing = this._map.transform.bearing + i.aw(y.amount, -179, 179), hh(_, y);
          }
          if (s.pitch) {
            const y = uh(s.pitch, h, hp);
            _.pitch = this._map.transform.pitch + y.amount, hh(_, y);
          }
          if (_.zoom || _.bearing) {
            const y = s.pinchAround === void 0 ? s.around : s.pinchAround;
            _.around = y ? this._map.unproject(y) : this._map.getCenter();
          }
          return this.clear(), _.noMoveStart = !0, _;
        }
      }
      function hh(c, t) {
        (!c.duration || c.duration < t.duration) && (c.duration = t.duration, c.easing = t.easing);
      }
      function uh(c, t, s) {
        const { maxSpeed: h, linearity: _, deceleration: y } = s, T = i.aw(c * _ / (t / 1e3), -h, h), z = Math.abs(T) / (y * _);
        return { easing: s.easing, duration: 1e3 * z, amount: T * (z / 2) };
      }
      class Or extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, h, _ = {}) {
          const y = Gt(s.getCanvasContainer(), h), T = s.unproject(y);
          super(t, i.l({ point: y, lngLat: T, originalEvent: h }, _)), this._defaultPrevented = !1, this.target = s;
        }
      }
      class dh extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, h) {
          const _ = t === "touchend" ? h.changedTouches : h.touches, y = ui(s.getCanvasContainer(), _), T = y.map((R) => s.unproject(R)), z = y.reduce((R, F, N, G) => R.add(F.div(G.length)), new i.P(0, 0));
          super(t, { points: y, point: z, lngLats: T, lngLat: s.unproject(z), originalEvent: h }), this._defaultPrevented = !1;
        }
      }
      class dp extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s) {
          super("wheel", { originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class fp {
        constructor(t, s) {
          this._map = t, this._clickTolerance = s.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(t) {
          return this._firePreventable(new dp(this._map, t));
        }
        mousedown(t, s) {
          return this._mousedownPos = s, this._firePreventable(new Or(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        preclick(t) {
          const s = i.l({}, t);
          s.type = "preclick", this._map.fire(new Or(s.type, this._map, s));
        }
        click(t, s) {
          this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || (this.preclick(t), this._map.fire(new Or(t.type, this._map, t)));
        }
        dblclick(t) {
          return this._firePreventable(new Or(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new dh(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new dh(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new dh(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new dh(t.type, this._map, t));
        }
        _firePreventable(t) {
          if (this._map.fire(t), t.defaultPrevented)
            return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class pp {
        constructor(t) {
          this._map = t;
        }
        reset() {
          this._delayContextMenu = !1, this._contextMenuEvent = void 0;
        }
        mousemove(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Or("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Or(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class r_ {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, s) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (ht(), this._startPos = this._lastPos = s, this._active = !0);
        }
        mousemoveWindow(t, s) {
          if (!this._active)
            return;
          const h = s, _ = this._startPos, y = this._lastPos;
          if (!_ || !y || y.equals(h) || !this._box && h.dist(_) < this._clickTolerance)
            return;
          this._lastPos = h, this._box || (this._box = be("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));
          const T = Math.min(_.x, h.x), z = Math.max(_.x, h.x), R = Math.min(_.y, h.y), F = Math.max(_.y, h.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${T}px,${R}px)`, this._box.style.width = z - T + "px", this._box.style.height = F - R + "px");
          });
        }
        mouseupWindow(t, s) {
          if (!this._active)
            return;
          const h = this._startPos, _ = s;
          if (h && t.button === 0) {
            if (this.reset(), pt(), h.x !== _.x || h.y !== _.y)
              return this._map.fire(new i.z("boxzoomend", { originalEvent: t })), { cameraAnimation: (y) => y.fitScreenCoordinates(h, _, this._map.getBearing(), { linear: !1 }) };
            this._fireEvent("boxzoomcancel", t);
          }
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), gt(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, s) {
          return this._map.fire(new i.z(t, { originalEvent: s }));
        }
      }
      function Dd(c, t) {
        const s = {};
        for (let h = 0; h < c.length; h++)
          s[c[h].identifier] = t[h];
        return s;
      }
      class Wn {
        constructor(t) {
          this.reset(), this.numTouches = t.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
        }
        touchstart(t, s, h) {
          (this.centroid || h.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = t.timeStamp), h.length === this.numTouches && (this.centroid = function(_) {
            const y = new i.P(0, 0);
            for (const T of _)
              y._add(T);
            return y.div(_.length);
          }(s), this.touches = Dd(h, s)));
        }
        touchmove(t, s, h) {
          if (this.aborted || !this.centroid)
            return;
          const _ = Dd(h, s);
          for (const y in this.touches) {
            const T = _[y];
            (!T || T.dist(this.touches[y]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, s, h) {
          if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), h.length === 0) {
            const _ = !this.aborted && this.centroid;
            if (this.reset(), _)
              return _;
          }
        }
      }
      class bu {
        constructor(t) {
          this.singleTap = new Wn(t), this.numTaps = t.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(t, s, h) {
          this.singleTap.touchstart(t, s, h);
        }
        touchmove(t, s, h) {
          this.singleTap.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          const _ = this.singleTap.touchend(t, s, h);
          if (_) {
            const y = t.timeStamp - this.lastTime < 500, T = !this.lastTap || this.lastTap.dist(_) < 30;
            if (y && T || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = _, this.count === this.numTaps)
              return this.reset(), _;
          }
        }
      }
      class o_ {
        constructor() {
          this._zoomIn = new bu({ numTouches: 1, numTaps: 2 }), this._zoomOut = new bu({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, s, h) {
          this._zoomIn.touchstart(t, s, h), this._zoomOut.touchstart(t, s, h);
        }
        touchmove(t, s, h) {
          this._zoomIn.touchmove(t, s, h), this._zoomOut.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          const _ = this._zoomIn.touchend(t, s, h), y = this._zoomOut.touchend(t, s, h);
          return _ ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: T.getZoom() + 1, around: T.unproject(_) }, { originalEvent: t }) }) : y ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: T.getZoom() - 1, around: T.unproject(y) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const a_ = { 0: 1, 2: 2 };
      class Pl {
        constructor(t) {
          this.reset(), this._clickTolerance = t.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(t, s) {
          return !1;
        }
        _move(t, s) {
          return {};
        }
        mousedown(t, s) {
          if (this._lastPoint)
            return;
          const h = kt(t);
          this._correctButton(t, h) && (this._lastPoint = s, this._eventButton = h);
        }
        mousemoveWindow(t, s) {
          const h = this._lastPoint;
          if (h) {
            if (t.preventDefault(), this._eventButton != null && function(_, y) {
              const T = a_[y];
              return _.buttons === void 0 || (_.buttons & T) !== T;
            }(t, this._eventButton))
              this.reset();
            else if (this._moved || !(s.dist(h) < this._clickTolerance))
              return this._moved = !0, this._lastPoint = s, this._move(h, s);
          }
        }
        mouseupWindow(t) {
          this._lastPoint && kt(t) === this._eventButton && (this._moved && pt(), this.reset());
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class mp extends Pl {
        mousedown(t, s) {
          super.mousedown(t, s), this._lastPoint && (this._active = !0);
        }
        _correctButton(t, s) {
          return s === 0 && !t.ctrlKey;
        }
        _move(t, s) {
          return { around: s, panDelta: s.sub(t) };
        }
      }
      class wu extends Pl {
        _correctButton(t, s) {
          return s === 0 && t.ctrlKey || s === 2;
        }
        _move(t, s) {
          const h = 0.8 * (s.x - t.x);
          if (h)
            return this._active = !0, { bearingDelta: h };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class fh extends Pl {
        _correctButton(t, s) {
          return s === 0 && t.ctrlKey || s === 2;
        }
        _move(t, s) {
          const h = -0.5 * (s.y - t.y);
          if (h)
            return this._active = !0, { pitchDelta: h };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class ba {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = s.clickTolerance || 1, this.reset(), i.aP(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new i.P(0, 0);
        }
        touchstart(t, s, h) {
          return this._calculateTransform(t, s, h);
        }
        touchmove(t, s, h) {
          if (this._active && !(h.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (h.length === 1 && !i.dz())
                return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t.cancelable && t.preventDefault(), this._calculateTransform(t, s, h);
          }
        }
        touchend(t, s, h) {
          this._calculateTransform(t, s, h), this._active && h.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, s, h) {
          h.length > 0 && (this._active = !0);
          const _ = Dd(h, s), y = new i.P(0, 0), T = new i.P(0, 0);
          let z = 0;
          for (const F in _) {
            const N = _[F], G = this._touches[F];
            G && (y._add(N), T._add(N.sub(G)), z++, _[F] = N);
          }
          if (this._touches = _, z < this._minTouches || !T.mag())
            return;
          const R = T.div(z);
          return this._sum._add(R), this._sum.mag() < this._clickTolerance ? void 0 : { around: y.div(z), panDelta: R };
        }
        enable() {
          this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = be("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 500);
        }
      }
      class dc {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, this._firstTwoTouches = void 0;
        }
        _start(t) {
        }
        _move(t, s, h) {
          return {};
        }
        touchstart(t, s, h) {
          this._firstTwoTouches || h.length < 2 || (this._firstTwoTouches = [h[0].identifier, h[1].identifier], this._start([s[0], s[1]]));
        }
        touchmove(t, s, h) {
          const _ = this._firstTwoTouches;
          if (!_)
            return;
          t.preventDefault();
          const [y, T] = _, z = Nn(h, s, y), R = Nn(h, s, T);
          if (!z || !R)
            return;
          const F = this._aroundCenter ? null : z.add(R).div(2);
          return this._move([z, R], F, t);
        }
        touchend(t, s, h) {
          if (!this._firstTwoTouches)
            return;
          const [_, y] = this._firstTwoTouches, T = Nn(h, s, _), z = Nn(h, s, y);
          T && z || (this._active && pt(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Nn(c, t, s) {
        for (let h = 0; h < c.length; h++)
          if (c[h].identifier === s)
            return t[h];
      }
      function zo(c, t) {
        return Math.log(c / t) / Math.LN2;
      }
      class kd extends dc {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, s) {
          const h = this._distance;
          if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(zo(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: zo(this._distance, h), pinchAround: s };
        }
      }
      function ph(c, t) {
        return 180 * c.angleWith(t) / Math.PI;
      }
      class _p extends dc {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(t) {
          this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
        }
        _move(t, s) {
          const h = this._vector;
          if (this._vector = t[0].sub(t[1]), h && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = !0, { bearingDelta: ph(this._vector, h), pinchAround: s };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const s = 25 / (Math.PI * this._minDiameter) * 360, h = this._startVector;
          if (!h)
            return !1;
          const _ = ph(t, h);
          return Math.abs(_) < s;
        }
      }
      function Rd(c) {
        return Math.abs(c.y) > Math.abs(c.x);
      }
      class mh extends dc {
        constructor(t) {
          super(), this._map = t;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(t) {
          this._lastPoints = t, Rd(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, s, h) {
          const _ = this._lastPoints;
          if (!_)
            return;
          const y = t[0].sub(_[0]), T = t[1].sub(_[1]);
          return this._map._cooperativeGestures && !i.dz() && h.touches.length < 3 || (this._valid = this.gestureBeginsVertically(y, T, h.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (y.y + T.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(t, s, h) {
          if (this._valid !== void 0)
            return this._valid;
          const _ = t.mag() >= 2, y = s.mag() >= 2;
          if (!_ && !y)
            return;
          if (!_ || !y)
            return this._firstMove == null && (this._firstMove = h), h - this._firstMove < 100 && void 0;
          const T = t.y > 0 == s.y > 0;
          return Rd(t) && Rd(s) && T;
        }
      }
      const l_ = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class c_ {
        constructor() {
          const t = l_;
          this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey)
            return;
          let s = 0, h = 0, _ = 0, y = 0, T = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              s = 1;
              break;
            case 189:
            case 109:
            case 173:
              s = -1;
              break;
            case 37:
              t.shiftKey ? h = -1 : (t.preventDefault(), y = -1);
              break;
            case 39:
              t.shiftKey ? h = 1 : (t.preventDefault(), y = 1);
              break;
            case 38:
              t.shiftKey ? _ = 1 : (t.preventDefault(), T = -1);
              break;
            case 40:
              t.shiftKey ? _ = -1 : (t.preventDefault(), T = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (h = 0, _ = 0), { cameraAnimation: (z) => {
            const R = z.getZoom();
            z.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Od, zoom: s ? Math.round(R) + s * (t.shiftKey ? 2 : 1) : R, bearing: z.getBearing() + h * this._bearingStep, pitch: z.getPitch() + _ * this._pitchStep, offset: [-y * this._panStep, -T * this._panStep], center: z.getCenter() }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Od(c) {
        return c * (2 - c);
      }
      const Tu = 4.000244140625, fc = 1 / 450;
      class pc {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._handler = s, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = fc, i.aP(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t.ctrlKey || t.metaKey || this.isZooming() || i.dz()))
              return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const h = i.q.now(), _ = h - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = h, s !== 0 && s % Tu == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = s, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(_ * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault();
        }
        _onTimeout(t) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);
        }
        _start(t) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const s = Gt(this._el, t);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : s, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive()))
            return;
          const t = this._map.transform;
          this._type === "wheel" && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const s = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
          if (this._delta !== 0) {
            const F = this._type === "wheel" && Math.abs(this._delta) > Tu ? this._wheelZoomRate : this._defaultZoomRate;
            let N = 2 / (1 + Math.exp(-Math.abs(this._delta * F)));
            this._delta < 0 && N !== 0 && (N = 1 / N);
            const G = s(), Z = Math.pow(2, G), W = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : Z;
            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(W * N))), this._type === "wheel" && (this._startZoom = G, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const h = typeof this._targetZoom == "number" ? this._targetZoom : s(), _ = this._startZoom, y = this._easing;
          let T, z = !1;
          if (this._type === "wheel" && _ && y) {
            const F = Math.min((i.q.now() - this._lastWheelEventTime) / 200, 1), N = y(F);
            T = i.af(_, h, N), F < 1 ? this._frameId || (this._frameId = !0) : z = !0;
          } else
            T = h, z = !0;
          this._active = !0, z && (this._active = !1, this._finishTimeout = window.setTimeout(() => {
            this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let R = T - s();
          return R * this._lastDelta < 0 && (R = 0), { noInertia: !0, needsRenderFrame: !z, zoomDelta: R, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let s = i.dA;
          if (this._prevEase) {
            const h = this._prevEase, _ = (i.q.now() - h.start) / h.duration, y = h.easing(_ + 0.01) - h.easing(_), T = 0.27 / Math.sqrt(y * y + 1e-4) * 0.01, z = Math.sqrt(0.0729 - T * T);
            s = i.dy(T, z, 0.25, 1);
          }
          return this._prevEase = { start: i.q.now(), duration: t, easing: s }, s;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = be("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 200);
        }
      }
      class wa {
        constructor(t, s) {
          this._clickZoom = t, this._tapZoom = s;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class Do {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        blur() {
          this.reset();
        }
        dblclick(t, s) {
          return t.preventDefault(), { cameraAnimation: (h) => {
            h.easeTo({ duration: 300, zoom: h.getZoom() + (t.shiftKey ? -1 : 1), around: h.unproject(s) }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ja {
        constructor() {
          this._tap = new bu({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(t, s, h) {
          this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? h.length > 0 && (this._swipePoint = s[0], this._swipeTouch = h[0].identifier) : this._tap.touchstart(t, s, h));
        }
        touchmove(t, s, h) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (h[0].identifier !== this._swipeTouch)
                return;
              const _ = s[0], y = _.y - this._swipePoint.y;
              return this._swipePoint = _, t.preventDefault(), this._active = !0, { zoomDelta: y / 128 };
            }
          } else
            this._tap.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          this._tapTime ? this._swipePoint && h.length === 0 && this.reset() : this._tap.touchend(t, s, h) && (this._tapTime = t.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Cl {
        constructor(t, s, h) {
          this._el = t, this._mousePan = s, this._touchPan = h;
        }
        enable(t) {
          this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Qa {
        constructor(t, s, h) {
          this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = s, this._mousePitch = h;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class h_ {
        constructor(t, s, h, _) {
          this._el = t, this._touchZoom = s, this._touchRotate = h, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Mu = (c) => c.zoom || c.drag || c.pitch || c.rotate;
      class u_ extends i.z {
      }
      class d_ {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t, s) {
          const h = i.ab.vec3.sub([], s, t);
          this.radius = i.ab.vec3.length(h[2] < 0 ? i.ab.vec3.div([], h, this.constants) : [h[0], h[1], 0]);
        }
        projectRay(t) {
          i.ab.vec3.div(t, t, this.constants), i.ab.vec3.normalize(t, t), i.ab.vec3.mul(t, t, this.constants);
          const s = i.ab.vec3.scale([], t, this.radius);
          if (s[2] > 0) {
            const h = i.ab.vec3.scale([], [0, 0, 1], i.ab.vec3.dot(s, [0, 0, 1])), _ = i.ab.vec3.scale([], i.ab.vec3.normalize([], [s[0], s[1], 0]), this.radius), y = i.ab.vec3.add([], s, i.ab.vec3.scale([], i.ab.vec3.sub([], i.ab.vec3.add([], _, h), s), 2));
            s[0] = y[0], s[1] = y[1];
          }
          return s;
        }
      }
      function _h(c) {
        return c.panDelta && c.panDelta.mag() || c.zoomDelta || c.bearingDelta || c.pitchDelta;
      }
      class dr {
        constructor(t, s) {
          this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new up(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new d_(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(s), i.aP(["handleEvent", "handleWindowEvent"], this);
          const h = this._el;
          this._listeners = [[h, "touchstart", { passive: !0 }], [h, "touchmove", { passive: !1 }], [h, "touchend", void 0], [h, "touchcancel", void 0], [h, "mousedown", void 0], [h, "mousemove", void 0], [h, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [h, "mouseover", void 0], [h, "mouseout", void 0], [h, "dblclick", void 0], [h, "click", void 0], [h, "keydown", { capture: !1 }], [h, "keyup", void 0], [h, "wheel", { passive: !1 }], [h, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [_, y, T] of this._listeners) {
            const z = _ === document ? this.handleWindowEvent : this.handleEvent;
            _.addEventListener(y, z, T);
          }
        }
        destroy() {
          for (const [t, s, h] of this._listeners) {
            const _ = t === document ? this.handleWindowEvent : this.handleEvent;
            t.removeEventListener(s, _, h);
          }
        }
        _addDefaultHandlers(t) {
          const s = this._map, h = s.getCanvasContainer();
          this._add("mapEvent", new fp(s, t));
          const _ = s.boxZoom = new r_(s, t);
          this._add("boxZoom", _);
          const y = new o_(), T = new Do();
          s.doubleClickZoom = new wa(T, y), this._add("tapZoom", y), this._add("clickZoom", T);
          const z = new Ja();
          this._add("tapDragZoom", z);
          const R = s.touchPitch = new mh(s);
          this._add("touchPitch", R);
          const F = new wu(t), N = new fh(t);
          s.dragRotate = new Qa(t, F, N), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]);
          const G = new mp(t), Z = new ba(s, t);
          s.dragPan = new Cl(h, G, Z), this._add("mousePan", G), this._add("touchPan", Z, ["touchZoom", "touchRotate"]);
          const W = new _p(), te = new kd();
          s.touchZoomRotate = new h_(h, te, W, z), this._add("touchRotate", W, ["touchPan", "touchZoom"]), this._add("touchZoom", te, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new pp(s));
          const ee = s.scrollZoom = new pc(s, this);
          this._add("scrollZoom", ee, ["mousePan"]);
          const se = s.keyboard = new c_();
          this._add("keyboard", se);
          for (const oe of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            t.interactive && t[oe] && s[oe].enable(t[oe]);
        }
        _add(t, s, h) {
          this._handlers.push({ handlerName: t, handler: s, allowed: h }), this._handlersById[t] = s;
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: s } of this._handlers)
              s.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers)
            if (t.isActive())
              return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Mu(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(t, s, h) {
          for (const _ in t)
            if (_ !== h && (!s || s.indexOf(_) < 0))
              return !0;
          return !1;
        }
        handleWindowEvent(t) {
          this.handleEvent(t, `${t.type}Window`);
        }
        _getMapTouches(t) {
          const s = [];
          for (const h of t)
            this._el.contains(h.target) && s.push(h);
          return s;
        }
        handleEvent(t, s) {
          this._updatingCamera = !0;
          const h = t.type === "renderFrame", _ = h ? void 0 : t, y = { needsRenderFrame: !1 }, T = {}, z = {}, R = t.touches ? this._getMapTouches(t.touches) : void 0, F = R ? ui(this._el, R) : h ? void 0 : Gt(this._el, t);
          for (const { handlerName: Z, handler: W, allowed: te } of this._handlers) {
            if (!W.isEnabled())
              continue;
            let ee;
            this._blockedByActive(z, te, Z) ? W.reset() : W[s || t.type] && (ee = W[s || t.type](t, F, R), this.mergeHandlerResult(y, T, ee, Z, _), ee && ee.needsRenderFrame && this._triggerRenderFrame()), (ee || W.isActive()) && (z[Z] = W);
          }
          const N = {};
          for (const Z in this._previousActiveHandlers)
            z[Z] || (N[Z] = _);
          this._previousActiveHandlers = z, (Object.keys(N).length || _h(y)) && (this._changes.push([y, T, N]), this._triggerRenderFrame()), (Object.keys(z).length || _h(y)) && this._map._stop(!0), this._updatingCamera = !1;
          const { cameraAnimation: G } = y;
          G && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], G(this._map));
        }
        mergeHandlerResult(t, s, h, _, y) {
          if (!h)
            return;
          i.l(t, h);
          const T = { handlerName: _, originalEvent: h.originalEvent || y };
          h.zoomDelta !== void 0 && (s.zoom = T), h.panDelta !== void 0 && (s.drag = T), h.pitchDelta !== void 0 && (s.pitch = T), h.bearingDelta !== void 0 && (s.rotate = T);
        }
        _applyChanges() {
          const t = {}, s = {}, h = {};
          for (const [_, y, T] of this._changes)
            _.panDelta && (t.panDelta = (t.panDelta || new i.P(0, 0))._add(_.panDelta)), _.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + _.pitchDelta), _.around !== void 0 && (t.around = _.around), _.aroundCoord !== void 0 && (t.aroundCoord = _.aroundCoord), _.pinchAround !== void 0 && (t.pinchAround = _.pinchAround), _.noInertia && (t.noInertia = _.noInertia), i.l(s, y), i.l(h, T);
          this._updateMapTransform(t, s, h), this._changes = [];
        }
        _updateMapTransform(t, s, h) {
          const _ = this._map, y = _.transform, T = (he) => [he.x, he.y, he.z];
          if (((he) => {
            const _e = this._eventsInProgress.drag;
            return _e && !this._handlersById[_e.handlerName].isActive();
          })() && !_h(t)) {
            const he = y.zoom;
            y.cameraElevationReference = "sea", this._originalZoom != null && y._orthographicProjectionAtLowPitch && y.projection.name !== "globe" && y.pitch === 0 ? (y.cameraElevationReference = "ground", y.zoom = this._originalZoom) : (y.recenterOnTerrain(), y.cameraElevationReference = "ground"), he !== y.zoom && this._map._update(!0);
          }
          if (y._isCameraConstrained && _._stop(!0), !_h(t))
            return void this._fireEvents(s, h, !0);
          let { panDelta: z, zoomDelta: R, bearingDelta: F, pitchDelta: N, around: G, aroundCoord: Z, pinchAround: W } = t;
          y._isCameraConstrained && (R > 0 && (R = 0), y._isCameraConstrained = !1), W !== void 0 && (G = W), (R || ((he) => s[he] && !this._eventsInProgress[he])("drag")) && G && (this._dragOrigin = T(y.pointCoordinate3D(G)), this._originalZoom = y.zoom, this._trackingEllipsoid.setup(y._camera.position, this._dragOrigin)), y.cameraElevationReference = "sea", _._stop(!0), G = G || _.transform.centerPoint, F && (y.bearing += F), N && (y.pitch += N), y._updateCameraState();
          const te = [0, 0, 0];
          if (z)
            if (y.projection.name === "mercator") {
              const he = this._trackingEllipsoid.projectRay(y.screenPointToMercatorRay(G).dir), _e = this._trackingEllipsoid.projectRay(y.screenPointToMercatorRay(G.sub(z)).dir);
              te[0] = _e[0] - he[0], te[1] = _e[1] - he[1];
            } else {
              const he = y.pointCoordinate(G);
              if (y.projection.name === "globe") {
                z = z.rotate(-y.angle);
                const _e = y._pixelsPerMercatorPixel / y.worldSize;
                te[0] = -z.x * i.dB(i.aS(he.y)) * _e, te[1] = -z.y * i.dB(y.center.lat) * _e;
              } else {
                const _e = y.pointCoordinate(G.sub(z));
                he && _e && (te[0] = _e.x - he.x, te[1] = _e.y - he.y);
              }
            }
          const ee = y.zoom, se = [0, 0, 0];
          if (R) {
            const he = T(Z || y.pointCoordinate3D(G)), _e = { dir: i.ab.vec3.normalize([], i.ab.vec3.sub([], he, y._camera.position)) };
            if (_e.dir[2] < 0) {
              const pe = y.zoomDeltaToMovement(he, R);
              i.ab.vec3.scale(se, _e.dir, pe);
            }
          }
          const oe = i.ab.vec3.add(te, te, se);
          y._translateCameraConstrained(oe), R && Math.abs(y.zoom - ee) > 1e-4 && y.recenterOnTerrain(), y.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, h, !0);
        }
        _fireEvents(t, s, h) {
          const _ = Mu(this._eventsInProgress), y = Mu(t), T = {};
          for (const N in t) {
            const { originalEvent: G } = t[N];
            this._eventsInProgress[N] || (T[`${N}start`] = G), this._eventsInProgress[N] = t[N];
          }
          !_ && y && this._fireEvent("movestart", y.originalEvent);
          for (const N in T)
            this._fireEvent(N, T[N]);
          y && this._fireEvent("move", y.originalEvent);
          for (const N in t) {
            const { originalEvent: G } = t[N];
            this._fireEvent(N, G);
          }
          const z = {};
          let R;
          for (const N in this._eventsInProgress) {
            const { handlerName: G, originalEvent: Z } = this._eventsInProgress[N];
            this._handlersById[G].isActive() || (delete this._eventsInProgress[N], R = s[G] || Z, z[`${N}end`] = R);
          }
          for (const N in z)
            this._fireEvent(N, z[N]);
          const F = Mu(this._eventsInProgress);
          if (h && (_ || y) && !F) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), G = (Z) => Z !== 0 && -this._bearingSnap < Z && Z < this._bearingSnap;
            N ? (G(N.bearing || this._map.getBearing()) && (N.bearing = 0), this._map.easeTo(N, { originalEvent: R })) : (this._map.fire(new i.z("moveend", { originalEvent: R })), G(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
          }
        }
        _fireEvent(t, s) {
          this._map.fire(new i.z(t, s ? { originalEvent: s } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
            this._frameId = void 0, this.handleEvent(new u_("renderFrame", { timeStamp: t })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const Su = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class gp extends i.E {
        constructor(t, s) {
          super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = s.bearingSnap, this._respectPrefersReducedMotion = s.respectPrefersReducedMotion !== !1, i.aP(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new i.bO(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, s) {
          return this.jumpTo({ center: t }, s);
        }
        panBy(t, s, h) {
          return t = i.P.convert(t).mult(-1), this.panTo(this.transform.center, i.l({ offset: t }, s), h);
        }
        panTo(t, s, h) {
          return this.easeTo(i.l({ center: t }, s), h);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, s) {
          return this.jumpTo({ zoom: t }, s), this;
        }
        zoomTo(t, s, h) {
          return this.easeTo(i.l({ zoom: t }, s), h);
        }
        zoomIn(t, s) {
          return this.zoomTo(this.getZoom() + 1, t, s), this;
        }
        zoomOut(t, s) {
          return this.zoomTo(this.getZoom() - 1, t, s), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, s) {
          return this.jumpTo({ bearing: t }, s), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, s) {
          return this.jumpTo({ padding: t }, s), this;
        }
        rotateTo(t, s, h) {
          return this.easeTo(i.l({ bearing: t }, s), h);
        }
        resetNorth(t, s) {
          return this.rotateTo(0, i.l({ duration: 1e3 }, t), s), this;
        }
        resetNorthPitch(t, s) {
          return this.easeTo(i.l({ bearing: 0, pitch: 0, duration: 1e3 }, t), s), this;
        }
        snapToNorth(t, s) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, s) {
          return this.jumpTo({ pitch: t }, s), this;
        }
        cameraForBounds(t, s) {
          t = i.az.convert(t);
          const h = s && s.bearing || 0, _ = s && s.pitch || 0, y = t.getNorthWest(), T = t.getSouthEast();
          return this._cameraForBounds(this.transform, y, T, h, _, s);
        }
        _extendPadding(t) {
          const s = { top: 0, right: 0, bottom: 0, left: 0 };
          return t == null ? i.l({}, s, this.transform.padding) : typeof t == "number" ? { top: t, bottom: t, right: t, left: t } : i.l({}, s, t);
        }
        _extendCameraOptions(t) {
          return (t = i.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding = this._extendPadding(t.padding), t;
        }
        _minimumAABBFrustumDistance(t, s) {
          const h = s.max[0] - s.min[0], _ = s.max[1] - s.min[1];
          return h / _ > t.aspect ? h / (2 * Math.tan(0.5 * t.fovX) * t.aspect) : _ / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
        }
        _cameraForBoundsOnGlobe(t, s, h, _, y, T) {
          const z = t.clone(), R = this._extendCameraOptions(T);
          z.bearing = _, z.pitch = y;
          const F = i.bO.convert(s), N = i.bO.convert(h), G = 0.5 * (F.lat + N.lat), Z = 0.5 * (F.lng + N.lng), W = i.dC(G, Z), te = i.ab.vec3.normalize([], W), ee = i.ab.vec3.normalize([], i.ab.vec3.cross([], te, [0, 1, 0])), se = i.ab.vec3.cross([], ee, te), oe = [ee[0], ee[1], ee[2], 0, se[0], se[1], se[2], 0, te[0], te[1], te[2], 0, 0, 0, 0, 1], he = [W, i.dC(F.lat, F.lng), i.dC(N.lat, F.lng), i.dC(N.lat, N.lng), i.dC(F.lat, N.lng), i.dC(G, F.lng), i.dC(G, N.lng), i.dC(F.lat, Z), i.dC(N.lat, Z)];
          let _e = i.cd.fromPoints(he.map((Je) => [i.ab.vec3.dot(ee, Je), i.ab.vec3.dot(se, Je), i.ab.vec3.dot(te, Je)]));
          const pe = i.ab.vec3.transformMat4([], _e.center, oe);
          i.ab.vec3.squaredLength(pe) === 0 && i.ab.vec3.set(pe, 0, 0, 1), i.ab.vec3.normalize(pe, pe), i.ab.vec3.scale(pe, pe, i.ax), z.center = i.dD(pe);
          const Me = z.getWorldToCameraMatrix(), xe = i.ab.mat4.invert(new Float64Array(16), Me);
          _e = i.cd.applyTransform(_e, i.ab.mat4.multiply([], Me, oe));
          const we = this._extendAABB(_e, z, R, _);
          if (!we)
            return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          _e = we, i.ab.vec3.transformMat4(pe, pe, Me);
          const ve = 0.5 * (_e.max[2] - _e.min[2]), Pe = this._minimumAABBFrustumDistance(z, _e), Oe = i.ab.vec3.scale([], [0, 0, 1], ve), Xe = i.ab.vec3.add(Oe, pe, Oe), He = Pe + (z.pitch === 0 ? 0 : i.ab.vec3.distance(pe, Xe)), ke = z.globeCenterInViewSpace, Ne = i.ab.vec3.sub([], pe, [ke[0], ke[1], ke[2]]);
          i.ab.vec3.normalize(Ne, Ne), i.ab.vec3.scale(Ne, Ne, He);
          const st = i.ab.vec3.add([], pe, Ne);
          i.ab.vec3.transformMat4(st, st, xe);
          const ut = i.ds / i.ax, xt = i.ab.vec3.length(st), Ge = i.bH(Math.max(xt * ut - i.ds, Number.EPSILON), 0), lt = Math.min(z.zoomFromMercatorZAdjusted(Ge), R.maxZoom);
          return lt > 0.5 * (i.c6 + i.bY) ? (z.setProjection({ name: "mercator" }), z.zoom = lt, this._cameraForBounds(z, s, h, _, y, T)) : { center: z.center, zoom: lt, bearing: _, pitch: y };
        }
        _extendAABB(t, s, h, _) {
          const y = 0.5 * ((h.padding.left || 0) + (h.padding.right || 0)), T = 0.5 * ((h.padding.top || 0) + (h.padding.bottom || 0)), z = T, R = y, F = y, N = T, G = s.width - (R + F), Z = s.height - (z + N), W = i.ab.vec3.sub([], t.max, t.min), te = Math.min(G / W[0], Z / W[1]), ee = Math.min(s.scaleZoom(s.scale * te), h.maxZoom);
          if (isNaN(ee))
            return null;
          const se = s.scale / s.zoomScale(ee), oe = new i.cd([t.min[0] - R * se, t.min[1] - N * se, t.min[2]], [t.max[0] + F * se, t.max[1] + z * se, t.max[2]]), he = (typeof h.offset.x == "number" && typeof h.offset.y == "number" ? new i.P(h.offset.x, h.offset.y) : i.P.convert(h.offset)).rotate(-i.ai(_));
          return oe.center[0] -= he.x * se, oe.center[1] += he.y * se, oe;
        }
        queryTerrainElevation(t, s) {
          const h = this.transform.elevation;
          return h ? (s = i.l({}, { exaggerated: !0 }, s), h.getAtPoint(i.aa.fromLngLat(t), null, s.exaggerated)) : null;
        }
        _cameraForBounds(t, s, h, _, y, T) {
          if (t.projection.name === "globe")
            return this._cameraForBoundsOnGlobe(t, s, h, _, y, T);
          const z = t.clone(), R = this._extendCameraOptions(T);
          z.bearing = _, z.pitch = y;
          const F = i.bO.convert(s), N = i.bO.convert(h), G = new i.bO(F.lng, N.lat), Z = new i.bO(N.lng, F.lat), W = z.project(F), te = z.project(N), ee = this.queryTerrainElevation(F), se = this.queryTerrainElevation(N), oe = this.queryTerrainElevation(G), he = this.queryTerrainElevation(Z), _e = [[W.x, W.y, Math.min(ee || 0, se || 0, oe || 0, he || 0)], [te.x, te.y, Math.max(ee || 0, se || 0, oe || 0, he || 0)]];
          let pe = i.cd.fromPoints(_e);
          const Me = z.getWorldToCameraMatrix(), xe = i.ab.mat4.invert(new Float64Array(16), Me);
          pe = i.cd.applyTransform(pe, Me);
          const we = this._extendAABB(pe, z, R, _);
          if (!we)
            return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          pe = we;
          const ve = 0.5 * i.ab.vec3.sub([], pe.max, pe.min)[2], Pe = this._minimumAABBFrustumDistance(z, pe), Oe = [0, 0, 1, 0];
          i.ab.vec4.transformMat4(Oe, Oe, Me), i.ab.vec4.normalize(Oe, Oe);
          const Xe = i.ab.vec3.scale([], Oe, Pe + ve), He = i.ab.vec3.add([], pe.center, Xe);
          i.ab.vec3.transformMat4(pe.center, pe.center, xe), i.ab.vec3.transformMat4(He, He, xe);
          const ke = z.unproject(new i.P(pe.center[0], pe.center[1])), Ne = i.dE(z.projection, ke), st = Math.pow(2, Ne), ut = Math.min(z._zoomFromMercatorZ(He[2] * z.pixelsPerMeter * st / z.worldSize), R.maxZoom);
          return z.mercatorFromTransition && ut < 0.5 * (i.c6 + i.bY) ? (z.setProjection({ name: "globe" }), z.zoom = ut, this._cameraForBounds(z, s, h, _, y, T)) : { center: ke, zoom: ut, bearing: _, pitch: y };
        }
        fitBounds(t, s, h) {
          const _ = this.cameraForBounds(t, s);
          return this._fitInternal(_, s, h);
        }
        fitScreenCoordinates(t, s, h, _, y) {
          const T = i.P.convert(t), z = i.P.convert(s), R = new i.P(Math.min(T.x, z.x), Math.min(T.y, z.y)), F = new i.P(Math.max(T.x, z.x), Math.max(T.y, z.y));
          if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(T, z))
            return this;
          const N = this.transform.pointLocation3D(R), G = this.transform.pointLocation3D(F), Z = this.transform.pointLocation3D(new i.P(R.x, F.y)), W = this.transform.pointLocation3D(new i.P(F.x, R.y)), te = [Math.min(N.lng, G.lng, Z.lng, W.lng), Math.min(N.lat, G.lat, Z.lat, W.lat)], ee = [Math.max(N.lng, G.lng, Z.lng, W.lng), Math.max(N.lat, G.lat, Z.lat, W.lat)], se = _ && _.pitch ? _.pitch : this.getPitch(), oe = this._cameraForBounds(this.transform, te, ee, h, se, _);
          return this._fitInternal(oe, _, y);
        }
        _fitInternal(t, s, h) {
          return t ? (s = i.l(t, s)).linear ? this.easeTo(s, h) : this.flyTo(s, h) : this;
        }
        jumpTo(t, s) {
          this.stop();
          const h = t.preloadOnly ? this.transform.clone() : this.transform;
          let _ = !1, y = !1, T = !1;
          "zoom" in t && h.zoom !== +t.zoom && (_ = !0, h.zoom = +t.zoom), t.center !== void 0 && (h.center = i.bO.convert(t.center)), "bearing" in t && h.bearing !== +t.bearing && (y = !0, h.bearing = +t.bearing), "pitch" in t && h.pitch !== +t.pitch && (T = !0, h.pitch = +t.pitch);
          const z = typeof t.padding == "number" ? this._extendPadding(t.padding) : t.padding;
          if (t.padding != null && !h.isPaddingEqual(z))
            if (t.retainPadding === !1) {
              const R = h.clone();
              R.padding = z, h.setLocationAtPoint(h.center, R.centerPoint);
            } else
              h.padding = z;
          return t.preloadOnly ? (this._preloadTiles(h), this) : (this.fire(new i.z("movestart", s)).fire(new i.z("move", s)), _ && this.fire(new i.z("zoomstart", s)).fire(new i.z("zoom", s)).fire(new i.z("zoomend", s)), y && this.fire(new i.z("rotatestart", s)).fire(new i.z("rotate", s)).fire(new i.z("rotateend", s)), T && this.fire(new i.z("pitchstart", s)).fire(new i.z("pitch", s)).fire(new i.z("pitchend", s)), this.fire(new i.z("moveend", s)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || i.w(Su), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t, s) {
          const h = this.transform;
          if (!h.projection.supportsFreeCamera)
            return i.w(Su), this;
          this.stop();
          const _ = h.zoom, y = h.pitch, T = h.bearing;
          h.setFreeCameraOptions(t);
          const z = _ !== h.zoom, R = y !== h.pitch, F = T !== h.bearing;
          return this.fire(new i.z("movestart", s)).fire(new i.z("move", s)), z && this.fire(new i.z("zoomstart", s)).fire(new i.z("zoom", s)).fire(new i.z("zoomend", s)), F && this.fire(new i.z("rotatestart", s)).fire(new i.z("rotate", s)).fire(new i.z("rotateend", s)), R && this.fire(new i.z("pitchstart", s)).fire(new i.z("pitch", s)).fire(new i.z("pitchend", s)), this.fire(new i.z("moveend", s)), this;
        }
        easeTo(t, s) {
          this._stop(!1, t.easeId), ((t = i.l({ offset: [0, 0], duration: 500, easing: i.dA }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
          const h = this.transform, _ = this.getZoom(), y = this.getBearing(), T = this.getPitch(), z = this.getPadding(), R = "zoom" in t ? +t.zoom : _, F = "bearing" in t ? this._normalizeBearing(t.bearing, y) : y, N = "pitch" in t ? +t.pitch : T, G = this._extendPadding(t.padding), Z = i.P.convert(t.offset);
          let W, te, ee;
          if (h.projection.name === "globe") {
            const Oe = i.aa.fromLngLat(h.center), Xe = Z.rotate(-h.angle);
            Oe.x += Xe.x / h.worldSize, Oe.y += Xe.y / h.worldSize;
            const He = Oe.toLngLat(), ke = i.bO.convert(t.center || He);
            this._normalizeCenter(ke), W = h.centerPoint.add(Xe), te = new i.P(Oe.x, Oe.y).mult(h.worldSize), ee = new i.P(i.at(ke.lng), i.aA(ke.lat)).mult(h.worldSize).sub(te);
          } else {
            W = h.centerPoint.add(Z);
            const Oe = h.pointLocation(W), Xe = i.bO.convert(t.center || Oe);
            this._normalizeCenter(Xe), te = h.project(Oe), ee = h.project(Xe).sub(te);
          }
          const se = h.zoomScale(R - _);
          let oe, he;
          t.around && (oe = i.bO.convert(t.around), he = h.locationPoint(oe));
          const _e = this._zooming || R !== _, pe = this._rotating || y !== F, Me = this._pitching || N !== T, xe = !h.isPaddingEqual(G), we = t.retainPadding === !1 ? h.clone() : h, ve = (Oe) => (Xe) => {
            if (_e && (Oe.zoom = i.af(_, R, Xe)), pe && (Oe.bearing = i.af(y, F, Xe)), Me && (Oe.pitch = i.af(T, N, Xe)), xe && (we.interpolatePadding(z, G, Xe), W = we.centerPoint.add(Z)), oe)
              Oe.setLocationAtPoint(oe, he);
            else {
              const He = Oe.zoomScale(Oe.zoom - _), ke = R > _ ? Math.min(2, se) : Math.max(0.5, se), Ne = Math.pow(ke, 1 - Xe), st = Oe.unproject(te.add(ee.mult(Xe * Ne)).mult(He));
              Oe.setLocationAtPoint(Oe.renderWorldCopies ? st.wrap() : st, W);
            }
            return t.preloadOnly || this._fireMoveEvents(s), Oe;
          };
          if (t.preloadOnly) {
            const Oe = this._emulate(ve, t.duration, h);
            return this._preloadTiles(Oe), this;
          }
          const Pe = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = _e, this._rotating = pe, this._pitching = Me, this._padding = xe, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, Pe), this._ease(ve(h), (Oe) => {
            h.cameraElevationReference === "sea" && h.recenterOnTerrain(), this._afterEase(s, Oe);
          }, t), this;
        }
        _prepareEase(t, s, h = {}) {
          this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), s || h.moving || this.fire(new i.z("movestart", t)), this._zooming && !h.zooming && this.fire(new i.z("zoomstart", t)), this._rotating && !h.rotating && this.fire(new i.z("rotatestart", t)), this._pitching && !h.pitching && this.fire(new i.z("pitchstart", t));
        }
        _fireMoveEvents(t) {
          this.fire(new i.z("move", t)), this._zooming && this.fire(new i.z("zoom", t)), this._rotating && this.fire(new i.z("rotate", t)), this._pitching && this.fire(new i.z("pitch", t));
        }
        _afterEase(t, s) {
          if (this._easeId && s && this._easeId === s)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const h = this._zooming, _ = this._rotating, y = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, h && this.fire(new i.z("zoomend", t)), _ && this.fire(new i.z("rotateend", t)), y && this.fire(new i.z("pitchend", t)), this.fire(new i.z("moveend", t));
        }
        flyTo(t, s) {
          if (this._prefersReducedMotion(t)) {
            const Je = i.ay(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
            return this.jumpTo(Je, s);
          }
          this.stop(), t = i.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: i.dA }, t);
          const h = this.transform, _ = this.getZoom(), y = this.getBearing(), T = this.getPitch(), z = this.getPadding(), R = "zoom" in t ? i.aw(+t.zoom, h.minZoom, h.maxZoom) : _, F = "bearing" in t ? this._normalizeBearing(t.bearing, y) : y, N = "pitch" in t ? +t.pitch : T, G = this._extendPadding(t.padding), Z = h.zoomScale(R - _), W = i.P.convert(t.offset);
          let te = h.centerPoint.add(W);
          const ee = h.pointLocation(te), se = i.bO.convert(t.center || ee);
          this._normalizeCenter(se);
          const oe = h.project(ee), he = h.project(se).sub(oe);
          let _e = t.curve;
          const pe = Math.max(h.width, h.height), Me = pe / Z, xe = he.mag();
          if ("minZoom" in t) {
            const Je = i.aw(Math.min(t.minZoom, _, R), h.minZoom, h.maxZoom), _t = pe / h.zoomScale(Je - _);
            _e = Math.sqrt(_t / xe * 2);
          }
          const we = _e * _e;
          function ve(Je) {
            const _t = (Me * Me - pe * pe + (Je ? -1 : 1) * we * we * xe * xe) / (2 * (Je ? Me : pe) * we * xe);
            return Math.log(Math.sqrt(_t * _t + 1) - _t);
          }
          function Pe(Je) {
            return (Math.exp(Je) - Math.exp(-Je)) / 2;
          }
          function Oe(Je) {
            return (Math.exp(Je) + Math.exp(-Je)) / 2;
          }
          const Xe = ve(0);
          let He = function(Je) {
            return Oe(Xe) / Oe(Xe + _e * Je);
          }, ke = function(Je) {
            return pe * ((Oe(Xe) * (Pe(_t = Xe + _e * Je) / Oe(_t)) - Pe(Xe)) / we) / xe;
            var _t;
          }, Ne = (ve(1) - Xe) / _e;
          if (Math.abs(xe) < 1e-6 || !isFinite(Ne)) {
            if (Math.abs(pe - Me) < 1e-6)
              return this.easeTo(t, s);
            const Je = Me < pe ? -1 : 1;
            Ne = Math.abs(Math.log(Me / pe)) / _e, ke = function() {
              return 0;
            }, He = function(_t) {
              return Math.exp(Je * _e * _t);
            };
          }
          t.duration = "duration" in t ? +t.duration : 1e3 * Ne / ("screenSpeed" in t ? +t.screenSpeed / _e : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
          const st = y !== F, ut = N !== T, xt = !h.isPaddingEqual(G), Ge = t.retainPadding === !1 ? h.clone() : h, lt = (Je) => (_t) => {
            const ct = _t * Ne, nt = 1 / He(ct);
            Je.zoom = _t === 1 ? R : _ + Je.scaleZoom(nt), st && (Je.bearing = i.af(y, F, _t)), ut && (Je.pitch = i.af(T, N, _t)), xt && (Ge.interpolatePadding(z, G, _t), te = Ge.centerPoint.add(W));
            const Lt = _t === 1 ? se : Je.unproject(oe.add(he.mult(ke(ct))).mult(nt));
            return Je.setLocationAtPoint(Je.renderWorldCopies ? Lt.wrap() : Lt, te), Je._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(s), Je;
          };
          if (t.preloadOnly) {
            const Je = this._emulate(lt, t.duration, h);
            return this._preloadTiles(Je), this;
          }
          return this._zooming = !0, this._rotating = st, this._pitching = ut, this._padding = xt, this._prepareEase(s, !1), this._ease(lt(h), () => this._afterEase(s), t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _requestRenderFrame(t) {
        }
        _cancelRenderFrame(t) {
        }
        _stop(t, s) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const h = this._onEaseEnd;
            this._onEaseEnd = void 0, h.call(this, s);
          }
          if (!t) {
            const h = this.handlers;
            h && h.stop(!1);
          }
          return this;
        }
        _ease(t, s, h) {
          h.animate === !1 || h.duration === 0 ? (t(1), s()) : (this._easeStart = i.q.now(), this._easeOptions = h, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t = Math.min((i.q.now() - this._easeStart) / this._easeOptions.duration, 1), s = this._onEaseFrame;
          s && s(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t, s) {
          t = i.bF(t, -180, 180);
          const h = Math.abs(t - s);
          return Math.abs(t - 360 - s) < h && (t -= 360), Math.abs(t + 360 - s) < h && (t += 360), t;
        }
        _normalizeCenter(t) {
          const s = this.transform;
          if (s.maxBounds || s.projection.name !== "globe" && !s.renderWorldCopies)
            return;
          const h = t.lng - s.center.lng;
          t.lng += h > 180 ? -360 : h < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t) {
          return this._respectPrefersReducedMotion && i.q.prefersReducedMotion && !(t && t.essential);
        }
        _emulate(t, s, h) {
          const _ = Math.ceil(15 * s / 1e3), y = [], T = t(h.clone());
          for (let z = 0; z <= _; z++) {
            const R = T(z / _);
            y.push(R.clone());
          }
          return y;
        }
        _preloadTiles(t, s) {
        }
      }
      class yp {
        constructor(t = {}) {
          this.options = t, i.aP(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t) {
          const s = this.options && this.options.compact, h = t._getUIString("AttributionControl.ToggleAttribution");
          this._map = t, this._container = be("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = be("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", h);
          const _ = be("span", "mapboxgl-ctrl-icon", this._compactButton);
          return _.setAttribute("aria-hidden", "true"), _.setAttribute("title", h), this._innerContainer = be("div", "mapboxgl-ctrl-attrib-inner", this._container), s && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), s === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t = this._editLink;
          t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const s = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || i.e.ACCESS_TOKEN }];
          if (t) {
            const h = s.reduce((_, y, T) => (y.value && (_ += `${y.key}=${y.value}${T < s.length - 1 ? "&" : ""}`), _), "?");
            t.href = `${i.e.FEEDBACK_URL}/${h}#${vu(this._map, !0)}`, t.rel = "noopener nofollow";
          }
        }
        _updateData(t) {
          !t || t.sourceDataType !== "metadata" && t.sourceDataType !== "visibility" && t.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let t = [];
          if (this._map.style.stylesheet) {
            const _ = this._map.style.stylesheet;
            this.styleOwner = _.owner, this.styleId = _.id;
          }
          const s = this._map.style._mergedSourceCaches;
          for (const _ in s) {
            const y = s[_];
            if (y.used) {
              const T = y.getSource();
              T.attribution && t.indexOf(T.attribution) < 0 && t.push(T.attribution);
            }
          }
          t.sort((_, y) => _.length - y.length), t = t.filter((_, y) => {
            for (let T = y + 1; T < t.length; T++)
              if (t[T].indexOf(_) >= 0)
                return !1;
            return !0;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
          const h = t.join(" | ");
          h !== this._attribHTML && (this._attribHTML = h, t.length ? (this._innerContainer.innerHTML = h, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Il {
        constructor() {
          i.aP(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(t) {
          this._map = t, this._container = be("div", "mapboxgl-ctrl");
          const s = be("a", "mapboxgl-ctrl-logo");
          return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://www.mapbox.com/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(t) {
          t && t.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return !0;
          const t = this._map.style._sourceCaches;
          if (Object.entries(t).length === 0)
            return !0;
          for (const s in t) {
            const h = t[s].getSource();
            if (h.hasOwnProperty("mapbox_logo") && !h.mapbox_logo)
              return !1;
          }
          return !0;
        }
        _updateCompact() {
          const t = this._container.children;
          if (t.length) {
            const s = t[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? s.classList.add("mapboxgl-compact") : s.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Eu {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(t) {
          const s = ++this._id;
          return this._queue.push({ callback: t, id: s, cancelled: !1 }), s;
        }
        remove(t) {
          const s = this._currentlyRunning, h = s ? this._queue.concat(s) : this._queue;
          for (const _ of h)
            if (_.id === t)
              return void (_.cancelled = !0);
        }
        run(t = 0) {
          const s = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const h of s)
            if (!h.cancelled && (h.callback(t), this._cleared))
              break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      class uo {
        constructor(t) {
          this.jumpTo(t);
        }
        getValue(t) {
          if (t <= this._startTime)
            return this._start;
          if (t >= this._endTime)
            return this._end;
          const s = i.cB((t - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - s) + this._end * s;
        }
        isEasing(t) {
          return t >= this._startTime && t <= this._endTime;
        }
        jumpTo(t) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t, this._end = t;
        }
        easeTo(t, s, h) {
          this._start = this.getValue(s), this._end = t, this._startTime = s, this._endTime = s + h;
        }
      }
      const fo = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, mc = ["mouseenter", "mouseover", "mouseleave", "mouseout"];
      class el extends i.z {
        constructor(t, s, h, _) {
          const { point: y, lngLat: T, originalEvent: z, target: R } = t;
          super(t.type, { point: y, lngLat: T, originalEvent: z, target: R }), this.preventDefault = () => {
            t.preventDefault();
          }, this.id = s, this.interaction = h, this.feature = _;
        }
      }
      class _c {
        constructor(t) {
          this.map = t, this.interactionsByType = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.delegatedHandlers = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this);
        }
        add(t, s) {
          if (this.typeById.has(t))
            throw new Error(`Interaction id "${t}" already exists.`);
          const { type: h, filter: _ } = s;
          _ && this.filters.set(t, i.aZ(_));
          const y = this.interactionsByType.get(h) || /* @__PURE__ */ new Map();
          if (y.size === 0) {
            if (mc.includes(h)) {
              const { mousemove: T, mouseout: z } = this._createDelegatedHandlers(t, s);
              this.map.on("mousemove", T), this.map.on("mouseout", z), this.delegatedHandlers.set(t, { mousemove: T, mouseout: z });
            } else
              this.map.on(h, this.handleType);
            this.interactionsByType.set(h, y);
          }
          y.set(t, s), this.typeById.set(t, h);
        }
        get(t) {
          const s = this.typeById.get(t);
          if (!s)
            return;
          const h = this.interactionsByType.get(s);
          return h ? h.get(t) : void 0;
        }
        remove(t) {
          const s = this.typeById.get(t);
          if (!s)
            return;
          this.typeById.delete(t), this.filters.delete(t);
          const h = this.interactionsByType.get(s);
          if (h) {
            if (h.delete(t), this.delegatedHandlers.has(t)) {
              const { mousemove: _, mouseout: y } = this.delegatedHandlers.get(t);
              this.map.off("mousemove", _), this.map.off("mouseout", y), this.delegatedHandlers.delete(t);
            }
            h.size === 0 && this.map.off(s, this.handleType);
          }
        }
        queryTargets(t, s) {
          const h = [];
          for (const [_, y] of s)
            y.target && h.push({ targetId: _, target: y.target, filter: this.filters.get(_) });
          return this.map.style.queryRenderedTargets(t, h, this.map.transform);
        }
        handleType(t, s) {
          const h = this.interactionsByType.get(t.type), _ = Array.from(h).reverse();
          s = s || this.queryTargets(t.point, _);
          let y = !1;
          for (const T of s) {
            for (const [z, R] of _) {
              if (!R.target)
                continue;
              const F = T.variants ? T.variants[z] : null;
              if (F) {
                for (const N of F) {
                  const G = new i.cw(T, N);
                  if (R.handler(new el(t, z, R, G)) !== !1) {
                    y = !0;
                    break;
                  }
                }
                if (y)
                  break;
              }
            }
            if (y)
              break;
          }
          if (!y)
            for (const [T, z] of _) {
              const { handler: R, target: F } = z;
              if (!F && R(new el(t, T, z, null)) !== !1)
                break;
            }
        }
        _createDelegatedHandlers(t, s) {
          switch (s.type) {
            case "mouseenter":
            case "mouseover": {
              let h = !1, _ = /* @__PURE__ */ new Set();
              return { mousemove: (y) => {
                const T = this.queryTargets(y.point, [[t, s]]), z = /* @__PURE__ */ new Set();
                if (!T.length)
                  return h = !1, void _.clear();
                const R = [];
                for (const F of T)
                  _.has(F.id) || (z.add(F.id), R.push(F));
                h && !R.length || (h = !0, _ = z, y.type = s.type, this.handleType(y, R));
              }, mouseout: () => {
                h = !1, _.clear();
              } };
            }
            case "mouseleave":
            case "mouseout": {
              let h = [];
              return { mousemove: (_) => {
                const y = this.queryTargets(_.point, [[t, s]]);
                if (!y.length)
                  return _.type = s.type, this.handleType(_, h), void (h = y);
                const T = [], z = new Set(y.map((R) => R.id));
                for (const R of h)
                  z.has(R.id) || T.push(R);
                T.length && (_.type = s.type, this.handleType(_, T)), h = y;
              }, mouseout: (_) => {
                h.length && (_.type = s.type, this.handleType(_, h), h = []);
              } };
            }
          }
        }
      }
      function Fd(c, t) {
        if (Array.isArray(c) && Array.isArray(t)) {
          const s = new Set(c), h = new Set(t);
          return s.size === h.size && c.every((_) => h.has(_));
        }
        return i.bn(c, t);
      }
      const Ui = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1, precompilePrograms: !0, scaleFactor: 1, spriteFormat: "auto" }, tl = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class f_ {
        constructor(t, s, h = !1) {
          this._clickTolerance = 10, this.element = s, this.mouseRotate = new wu({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, h && (this.mousePitch = new fh({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), i.aP(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), s.addEventListener("mousedown", this.mousedown), s.addEventListener("touchstart", this.touchstart, { passive: !1 }), s.addEventListener("touchmove", this.touchmove), s.addEventListener("touchend", this.touchend), s.addEventListener("touchcancel", this.reset);
        }
        down(t, s) {
          this.mouseRotate.mousedown(t, s), this.mousePitch && this.mousePitch.mousedown(t, s), ht();
        }
        move(t, s) {
          const h = this.map, _ = this.mouseRotate.mousemoveWindow(t, s), y = _ && _.bearingDelta;
          if (y && h.setBearing(h.getBearing() + y), this.mousePitch) {
            const T = this.mousePitch.mousemoveWindow(t, s), z = T && T.pitchDelta;
            z && h.setPitch(h.getPitch() + z);
          }
        }
        off() {
          const t = this.element;
          t.removeEventListener("mousedown", this.mousedown), t.removeEventListener("touchstart", this.touchstart, { passive: !1 }), t.removeEventListener("touchmove", this.touchmove), t.removeEventListener("touchend", this.touchend), t.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          gt(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t) {
          this.down(i.l({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), Gt(this.element, t)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(t) {
          this.move(t, Gt(this.element, t));
        }
        mouseup(t) {
          this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();
        }
        touchstart(t) {
          t.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ui(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => t.preventDefault() }, this._startPos));
        }
        touchmove(t) {
          t.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ui(this.element, t.targetTouches)[0], this.move({ preventDefault: () => t.preventDefault() }, this._lastPos));
        }
        touchend(t) {
          t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      function xp(c, t, s) {
        if (c = new i.bO(c.lng, c.lat), t) {
          const h = new i.bO(c.lng - 360, c.lat), _ = new i.bO(c.lng + 360, c.lat), y = 360 * Math.ceil(Math.abs(c.lng - s.center.lng) / 360), T = s.locationPoint(c).distSqr(t), z = t.x < 0 || t.y < 0 || t.x > s.width || t.y > s.height;
          s.locationPoint(h).distSqr(t) < T && (z || Math.abs(h.lng - s.center.lng) < y) ? c = h : s.locationPoint(_).distSqr(t) < T && (z || Math.abs(_.lng - s.center.lng) < y) && (c = _);
        }
        for (; Math.abs(c.lng - s.center.lng) > 180; ) {
          const h = s.locationPoint(c);
          if (h.x >= 0 && h.y >= 0 && h.x <= s.width && h.y <= s.height)
            break;
          c.lng > s.center.lng ? c.lng -= 360 : c.lng += 360;
        }
        return c;
      }
      const gh = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class ta extends i.E {
        constructor(t, s) {
          if (super(), (t instanceof HTMLElement || s) && (t = i.l({ element: t }, s)), i.aP(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || 0.2, t && t.element)
            this._element = t.element, this._offset = i.P.convert(t && t.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = be("div");
            const y = 41, T = 27, z = Ze("svg", { display: "block", height: y * this._scale + "px", width: T * this._scale + "px", viewBox: `0 0 ${T} ${y}` }, this._element), R = Ze("radialGradient", { id: "shadowGradient" }, Ze("defs", {}, z));
            Ze("stop", { offset: "10%", "stop-opacity": 0.4 }, R), Ze("stop", { offset: "100%", "stop-opacity": 0.05 }, R), Ze("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, z), Ze("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, z), Ze("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, z), Ze("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, z), this._offset = i.P.convert(t && t.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (y) => {
            y.preventDefault();
          }), this._element.addEventListener("mousedown", (y) => {
            y.preventDefault();
          });
          const h = this._element.classList;
          for (const y in gh)
            h.remove(`mapboxgl-marker-anchor-${y}`);
          h.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const _ = t && t.className ? t.className.trim().split(/\s+/) : [];
          h.add(..._), this._popup = null;
        }
        addTo(t) {
          return t === this._map || (this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._updateMoving), t.on("moveend", this._update), t.on("remove", this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on("click", this._onMapClick)), this;
        }
        remove() {
          const t = this._map;
          return t && (t.off("click", this._onMapClick), t.off("move", this._updateMoving), t.off("moveend", this._update), t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler), t.off("mouseup", this._onUp), t.off("touchend", this._onUp), t.off("mousemove", this._onMove), t.off("touchmove", this._onMove), t.off("remove", this._clearFadeTimer), t._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return this._lngLat = i.bO.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
            if (!("offset" in t.options)) {
              const _ = Math.sqrt(Math.pow(13.5, 2) / 2);
              t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [_, -1 * (38.1 - 13.5 + _)], "bottom-right": [-_, -1 * (38.1 - 13.5 + _)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = t, t._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(t) {
          const s = t.code, h = t.charCode || t.keyCode;
          s !== "Space" && s !== "Enter" && h !== 32 && h !== 13 || this.togglePopup();
        }
        _onMapClick(t) {
          const s = t.originalEvent.target, h = this._element;
          this._popup && (s === h || h.contains(s)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const t = this._map, s = this._pos;
          if (!t || !s)
            return !1;
          const h = t.unproject(s), _ = t.getFreeCameraOptions();
          if (!_.position)
            return !1;
          const y = _.position.toLngLat();
          return y.distanceTo(h) < 0.9 * y.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t = this._map;
          if (!t)
            return;
          const s = this._pos;
          if (!s || s.x < 0 || s.x > t.transform.width || s.y < 0 || s.y > t.transform.height)
            return void this._clearFadeTimer();
          const h = t.unproject(s);
          let _;
          t._showingGlobe() && i.dH(t.transform, this._lngLat) ? _ = 0 : (_ = 1 - t._queryFogOpacity(h), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (_ *= this._occludedOpacity)), this._element.style.opacity = `${_}`, this._element.style.pointerEvents = _ > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(_), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const t = this._pos;
          if (!t || !this._map)
            return;
          const s = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${gh[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${s.x}px,${s.y}px)
        `;
        }
        _calculateXYTransform() {
          const t = this._pos, s = this._map, h = this.getPitchAlignment();
          if (!s || !t || h !== "map")
            return "";
          if (!s._showingGlobe()) {
            const R = s.getPitch();
            return R ? `rotateX(${R}deg)` : "";
          }
          const _ = i.c4(i.dI(s.transform, this._lngLat)), y = t.sub(i.dJ(s.transform)), T = Math.abs(y.x) + Math.abs(y.y);
          if (T === 0)
            return "";
          const z = _ / T;
          return `rotateX(${-y.y * z}deg) rotateY(${y.x * z}deg)`;
        }
        _calculateZTransform() {
          const t = this._pos, s = this._map;
          if (!s || !t)
            return "";
          let h = 0;
          const _ = this.getRotationAlignment();
          if (_ === "map")
            if (s._showingGlobe()) {
              const y = s.project(new i.bO(this._lngLat.lng, this._lngLat.lat + 1e-3)), T = s.project(new i.bO(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(y);
              h = i.c4(Math.atan2(T.y, T.x)) - 90;
            } else
              h = -s.getBearing();
          else if (_ === "horizon") {
            const y = i.ac(4, 6, s.getZoom()), T = i.dJ(s.transform);
            T.y += y * s.transform.height;
            const z = t.sub(T), R = i.c4(Math.atan2(z.y, z.x));
            h = (R > 90 ? R - 270 : R + 90) * (1 - y);
          }
          return h += this._rotation, h ? `rotateZ(${h}deg)` : "";
        }
        _update(t) {
          cancelAnimationFrame(this._updateFrameId);
          const s = this._map;
          s && (s.transform.renderWorldCopies && (this._lngLat = xp(this._lngLat, this._pos, s.transform)), this._pos = s.project(this._lngLat), t === !0 ? this._updateFrameId = requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), s._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (s._showingGlobe() || s.getTerrain() || s.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return this._offset = i.P.convert(t), this._update(), this;
        }
        addClassName(t) {
          return this._element.classList.add(t), this;
        }
        removeClassName(t) {
          return this._element.classList.remove(t), this;
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        _onMove(t) {
          const s = this._map;
          if (!s)
            return;
          const h = this._pointerdownPos, _ = this._positionDelta;
          if (h && _) {
            if (!this._isDragging) {
              const y = this._clickTolerance || s._clickTolerance;
              if (t.point.dist(h) < y)
                return;
              this._isDragging = !0;
            }
            this._pos = t.point.sub(_), this._lngLat = s.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new i.z("dragstart"))), this.fire(new i.z("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
          const t = this._map;
          t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), this._state === "active" && this.fire(new i.z("dragend")), this._state = "inactive";
        }
        _addDragHandler(t) {
          const s = this._map, h = this._pos;
          s && h && this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(h), this._pointerdownPos = t.point, this._state = "pending", s.on("mousemove", this._onMove), s.on("touchmove", this._onMove), s.once("mouseup", this._onUp), s.once("touchend", this._onUp));
        }
        setDraggable(t) {
          this._draggable = !!t;
          const s = this._map;
          return s && (t ? (s.on("mousedown", this._addDragHandler), s.on("touchstart", this._addDragHandler)) : (s.off("mousedown", this._addDragHandler), s.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return this._rotation = t || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return this._rotationAlignment = t || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return this._pitchAlignment = t || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(t) {
          return this._occludedOpacity = t || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const Ta = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, fr = { maxWidth: 100, unit: "metric" }, Fr = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Os = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, vp = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Un(c = new i.P(0, 0), t = "bottom") {
        if (typeof c == "number") {
          const s = Math.round(Math.sqrt(0.5 * Math.pow(c, 2)));
          switch (t) {
            case "top":
              return new i.P(0, c);
            case "top-left":
              return new i.P(s, s);
            case "top-right":
              return new i.P(-s, s);
            case "bottom":
              return new i.P(0, -c);
            case "bottom-left":
              return new i.P(s, -s);
            case "bottom-right":
              return new i.P(-s, -s);
            case "left":
              return new i.P(c, 0);
            case "right":
              return new i.P(-c, 0);
          }
          return new i.P(0, 0);
        }
        return c instanceof i.P || Array.isArray(c) ? i.P.convert(c) : i.P.convert(c[t] || [0, 0]);
      }
      return { version: O, supported: Te.supported, setRTLTextPlugin: i.dK, getRTLTextPluginStatus: i.dL, Map: class extends gp {
        constructor(c) {
          Y.mark(j.create);
          const t = c;
          if ((c = i.l({}, Ui, c)).minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (c.minPitch != null && c.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (c.maxPitch != null && c.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (c.antialias && i.dF(window) && (c.antialias = !1, i.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new ma(c.minZoom, c.maxZoom, c.minPitch, c.maxPitch, c.renderWorldCopies), c), this._repaint = !!c.repaint, this._interactive = c.interactive, this._minTileCacheSize = c.minTileCacheSize, this._maxTileCacheSize = c.maxTileCacheSize, this._failIfMajorPerformanceCaveat = c.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = c.preserveDrawingBuffer, this._antialias = c.antialias, this._trackResize = c.trackResize, this._bearingSnap = c.bearingSnap, this._refreshExpiredTiles = c.refreshExpiredTiles, this._fadeDuration = c.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = c.crossSourceCollisions, this._collectResourceTiming = c.collectResourceTiming, this._language = this._parseLanguage(c.language), this._worldview = c.worldview, this._renderTaskQueue = new Eu(), this._domRenderTaskQueue = new Eu(), this._controls = [], this._markers = [], this._popups = [], this._mapId = i.aV(), this._locale = i.l({}, fo, c.locale), this._clickTolerance = c.clickTolerance, this._cooperativeGestures = c.cooperativeGestures, this._performanceMetricsCollection = c.performanceMetricsCollection, this._tessellationStep = c.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = c.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new uo(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = c.scaleFactor, this._requestManager = new hn(c.transformRequest, c.accessToken, c.testMode), this._silenceAuthErrors = !!c.testMode, this._contextCreateOptions = c.contextCreateOptions ? { ...c.contextCreateOptions } : {}, typeof c.container == "string") {
            const s = document.getElementById(c.container);
            if (!s)
              throw new Error(`Container '${c.container.toString()}' not found.`);
            this._container = s;
          } else {
            if (!(c.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = c.container;
          }
          if (this._container.childNodes.length > 0 && i.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), c.maxBounds && this.setMaxBounds(c.maxBounds), this._spriteFormat = c.spriteFormat, i.aP(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new mu()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: !0 }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: !0 }, () => {
            this._update();
          }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
            this.setScaleFactor(this._scaleFactor);
          }), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new dr(this, c), this._localFontFamily = c.localFontFamily, this._localIdeographFontFamily = c.localIdeographFontFamily, (c.style || !c.testMode) && this.setStyle(c.style || i.e.DEFAULT_STYLE, { config: c.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), c.projection && this.setProjection(c.projection), this.indoor = new yl(this), c.hash && (this._hash = new zd(typeof c.hash == "string" && c.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            t.center == null && t.zoom == null || (this.transform._unmodified = !1), this.jumpTo({ center: c.center, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch });
            const s = c.bounds;
            s && (this.resize(), this.fitBounds(s, i.l({}, c.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), c.attributionControl && this.addControl(new yp({ customAttribution: c.customAttribution })), this._logoControl = new Il(), this.addControl(this._logoControl, c.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
          }), this.on("data", (s) => {
            this._update(s.dataType === "style"), this.fire(new i.z(`${s.dataType}data`, s));
          }), this.on("dataloading", (s) => {
            this.fire(new i.z(`${s.dataType}dataloading`, s));
          }), this._interactions = new _c(this);
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(c, t) {
          if (t === void 0 && (t = c.getDefaultPosition ? c.getDefaultPosition() : "top-right"), !c || !c.onAdd)
            return this.fire(new i.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s = c.onAdd(this);
          this._controls.push(c);
          const h = this._controlPositions[t];
          return t.indexOf("bottom") !== -1 ? h.insertBefore(s, h.firstChild) : h.appendChild(s), this;
        }
        removeControl(c) {
          if (!c || !c.onRemove)
            return this.fire(new i.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t = this._controls.indexOf(c);
          return t > -1 && this._controls.splice(t, 1), c.onRemove(this), this;
        }
        hasControl(c) {
          return this._controls.indexOf(c) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(c) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const t = !this._moving;
          return t && this.fire(new i.z("movestart", c)).fire(new i.z("move", c)), this.fire(new i.z("resize", c)), t && this.fire(new i.z("moveend", c)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(c) {
          return this.transform.setMaxBounds(i.az.convert(c)), this._update();
        }
        setMinZoom(c) {
          if ((c = c ?? -2) >= -2 && c <= this.transform.maxZoom)
            return this.transform.minZoom = c, this._update(), this.getZoom() < c ? this.setZoom(c) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(c) {
          if ((c = c ?? 22) >= this.transform.minZoom)
            return this.transform.maxZoom = c, this._update(), this.getZoom() > c ? this.setZoom(c) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(c) {
          if ((c = c ?? 0) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (c >= 0 && c <= this.transform.maxPitch)
            return this.transform.minPitch = c, this._update(), this.getPitch() < c ? this.setPitch(c) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(c) {
          if ((c = c ?? 85) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (c >= this.transform.minPitch)
            return this.transform.maxPitch = c, this._update(), this.getPitch() > c ? this.setPitch(c) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getScaleFactor() {
          return this._scaleFactor;
        }
        setScaleFactor(c) {
          return this._scaleFactor = c, this.painter.scaleFactor = c, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((t) => t.type === "symbol"), this._update(!0), this;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(c) {
          return this.transform.renderWorldCopies = c, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(c) {
          return c === "auto" ? navigator.language : Array.isArray(c) ? c.length === 0 ? void 0 : c.map((t) => t === "auto" ? navigator.language : t) : c;
        }
        setLanguage(c) {
          const t = this._parseLanguage(c);
          if (!this.style || t === this._language)
            return this;
          this._language = t, this.style.reloadSources();
          for (const s of this._controls)
            s._setLanguage && s._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(c) {
          return this.style && c !== this._worldview ? (this._worldview = c, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return this.transform.projection.name === "globe";
        }
        setProjection(c) {
          return this._lazyInitEmptyStyle(), c ? typeof c == "string" && (c = { name: c }) : c = null, this._useExplicitProjection = !!c, this._prioritizeAndUpdateProjection(c, this.style.projection);
        }
        _updateProjectionTransition() {
          if (this.getProjection().name !== "globe")
            return;
          const c = this.transform, t = c.projection.name;
          let s;
          t === "globe" && c.zoom >= i.bY ? (c.setMercatorFromTransition(), s = !0) : t === "mercator" && c.zoom < i.bY && (c.setProjection({ name: "globe" }), s = !0), s && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(c, t) {
          return this._updateProjection(c || t || { name: "mercator" });
        }
        _updateProjection(c) {
          let t;
          return t = c.name === "globe" && this.transform.zoom >= i.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(c), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
        }
        project(c) {
          return this.transform.locationPoint3D(i.bO.convert(c));
        }
        unproject(c) {
          return this.transform.pointLocation3D(i.P.convert(c));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || !1;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || !1;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || !1;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || !1;
        }
        _createDelegatedListener(c, t, s) {
          const h = (_) => {
            let y = [];
            if (Array.isArray(t)) {
              const T = t.filter((z) => this.getLayer(z));
              y = T.length ? this.queryRenderedFeatures(_, { layers: T }) : [];
            } else
              y = this.queryRenderedFeatures(_, { target: t });
            return y;
          };
          if (c === "mouseenter" || c === "mouseover") {
            let _ = !1;
            return { listener: s, targets: t, delegates: { mousemove: (T) => {
              const z = h(T.point);
              z.length ? _ || (_ = !0, s.call(this, new Or(c, this, T.originalEvent, { features: z }))) : _ = !1;
            }, mouseout: () => {
              _ = !1;
            } } };
          }
          if (c === "mouseleave" || c === "mouseout") {
            let _ = !1;
            return { listener: s, targets: t, delegates: { mousemove: (z) => {
              h(z.point).length ? _ = !0 : _ && (_ = !1, s.call(this, new Or(c, this, z.originalEvent)));
            }, mouseout: (z) => {
              _ && (_ = !1, s.call(this, new Or(c, this, z.originalEvent)));
            } } };
          }
          {
            const _ = (y) => {
              const T = h(y.point);
              T.length && (y.features = T, s.call(this, y), delete y.features);
            };
            return { listener: s, targets: t, delegates: { [c]: _ } };
          }
        }
        on(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.on(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._createDelegatedListener(c, t, s);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[c] = this._delegatedListeners[c] || [], this._delegatedListeners[c].push(h);
          for (const _ in h.delegates)
            this.on(_, h.delegates[_]);
          return this;
        }
        once(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.once(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._createDelegatedListener(c, t, s);
          for (const _ in h.delegates)
            this.once(_, h.delegates[_]);
          return this;
        }
        off(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.off(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._delegatedListeners ? this._delegatedListeners[c] : void 0;
          return h && ((_) => {
            for (let y = 0; y < _.length; y++) {
              const T = _[y];
              if (T.listener === s && Fd(T.targets, t)) {
                for (const z in T.delegates)
                  this.off(z, T.delegates[z]);
                return _.splice(y, 1), this;
              }
            }
          })(h), this;
        }
        queryRenderedFeatures(c, t) {
          if (!this.style)
            return [];
          if (c === void 0 || c instanceof i.P || Array.isArray(c) || t !== void 0 || (t = c, c = void 0), c = c || [[0, 0], [this.transform.width, this.transform.height]], !t) {
            const y = this.style.queryRenderedFeatures(c, void 0, this.transform), T = this.style.queryRenderedFeatureset(c, void 0, this.transform);
            return y.concat(T);
          }
          let s = !0;
          if (t.target && (s = this._isTargetValid(t.target), s && !t.layers))
            return this.style.queryRenderedFeatureset(c, t, this.transform);
          let h = !0;
          if (t.layers && Array.isArray(t.layers)) {
            for (const y of t.layers)
              if (!this._isValidId(y)) {
                h = !1;
                break;
              }
            if (h && !t.target)
              return this.style.queryRenderedFeatures(c, t, this.transform);
          }
          let _ = [];
          return h && (_ = _.concat(this.style.queryRenderedFeatures(c, t, this.transform))), s && (_ = _.concat(this.style.queryRenderedFeatureset(c, t, this.transform))), _;
        }
        querySourceFeatures(c, t) {
          return !c || typeof c == "string" && !this._isValidId(c) ? [] : this.style.querySourceFeatures(c, t);
        }
        isPointOnSurface(c) {
          const { name: t } = this.transform.projection;
          return t !== "globe" && t !== "mercator" && i.w(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(i.P.convert(c));
        }
        addInteraction(c, t) {
          return this._interactions.add(c, t), this;
        }
        removeInteraction(c) {
          return this._interactions.remove(c), this;
        }
        setStyle(c, t) {
          return t = i.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t), this.style && c && t.diff !== !1 && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(c, (s, h) => {
            s ? (i.w(`Unable to perform style diff: ${String(s.message || s.error || s)}. Rebuilding the style from scratch.`), this._updateStyle(c, t)) : h && this._update(!0);
          }, () => {
            this._postStyleLoadEvent();
          }), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._localFontFamily = t.localFontFamily, this._updateStyle(c, t));
        }
        _getUIString(c) {
          const t = this._locale[c];
          if (t == null)
            throw new Error(`Missing UI string '${c}'`);
          return t;
        }
        _updateStyle(c, t) {
          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), c) {
            const s = i.l({}, t);
            t && t.config && (s.initialConfig = t.config, delete s.config), this.style = new hr(this, s).load(c), this.style.setEventedParent(this, { style: this.style });
          }
          return this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new hr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (i.w("There is no style added to the map."), !1);
        }
        _isValidId(c) {
          return c == null ? (this.fire(new i.y(new Error("IDs can't be empty."))), !1) : !i.cr(c) || (this.fire(new i.y(new Error(`IDs can't contain special symbols: "${c}".`))), !1);
        }
        _isTargetValid(c) {
          return "featuresetId" in c ? this._isValidId("importId" in c ? c.importId : c.featuresetId) : "layerId" in c && this._isValidId(c.layerId);
        }
        _areTargetsValid(c) {
          if (Array.isArray(c)) {
            for (const t of c)
              if (!this._isValidId(t))
                return !1;
            return !0;
          }
          return this._isTargetValid(c);
        }
        addSource(c, t) {
          return this._isValidId(c) ? (this._lazyInitEmptyStyle(), this.style.addSource(c, t), this._update(!0)) : this;
        }
        isSourceLoaded(c) {
          return !!this._isValidId(c) && !!this.style && this.style._isSourceCacheLoaded(c);
        }
        areTilesLoaded() {
          return this.style.areTilesLoaded();
        }
        addSourceType(c, t, s) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(c, t, s);
        }
        removeSource(c) {
          return this._isValidId(c) ? (this.style.removeSource(c), this._updateTerrain(), this._update(!0)) : this;
        }
        getSource(c) {
          return this._isValidId(c) ? this.style.getOwnSource(c) : null;
        }
        addImage(c, t, { pixelRatio: s = 1, sdf: h = !1, stretchX: _, stretchY: y, content: T } = {}) {
          if (this._lazyInitEmptyStyle(), t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
            const { width: z, height: R, data: F } = i.q.getImageData(t);
            this.style.addImage(c, { data: new i.r({ width: z, height: R }, F), pixelRatio: s, stretchX: _, stretchY: y, content: T, sdf: h, version: 0, usvg: !1 });
          } else if (t.width === void 0 || t.height === void 0)
            this.fire(new i.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: z, height: R } = t, F = t;
            this.style.addImage(c, { data: new i.r({ width: z, height: R }, new Uint8Array(F.data)), pixelRatio: s, stretchX: _, stretchY: y, content: T, sdf: h, usvg: !1, version: 0, userImage: F }), F.onAdd && F.onAdd(this, c);
          }
        }
        updateImage(c, t) {
          this._lazyInitEmptyStyle();
          const s = this.style.getImage(c);
          if (!s)
            return void this.fire(new i.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const h = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? i.q.getImageData(t) : t, { width: _, height: y, data: T } = h;
          if (_ === void 0 || y === void 0)
            return void this.fire(new i.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (_ !== (s.usvg ? s.icon.usvg_tree.width : s.data.width) || y !== (s.usvg ? s.icon.usvg_tree.height : s.data.height))
            return void this.fire(new i.y(new Error(`The width and height of the updated image (${_}, ${y})
                must be that same as the previous version of the image
                (${s.data.width}, ${s.data.height})`)));
          const z = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
          let R = !1;
          s.usvg ? (s.data = new i.r({ width: _, height: y }, new Uint8Array(T)), s.usvg = !1, s.icon = void 0, R = !0) : s.data.replace(T, z), this.style.updateImage(c, s, R);
        }
        hasImage(c) {
          return c ? !!this.style && !!this.style.getImage(c) : (this.fire(new i.y(new Error("Missing required image id"))), !1);
        }
        removeImage(c) {
          this.style.removeImage(c);
        }
        loadImage(c, t) {
          i.o(this._requestManager.transformRequest(c, i.R.Image), (s, h) => {
            t(s, h instanceof HTMLImageElement ? i.q.getImageData(h) : h);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addModel(c, t) {
          this._lazyInitEmptyStyle(), this.style.addModel(c, t);
        }
        hasModel(c) {
          return c ? this.style.hasModel(c) : (this.fire(new i.y(new Error("Missing required model id"))), !1);
        }
        removeModel(c) {
          this.style.removeModel(c);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(c, t) {
          return this._isValidId(c.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(c, t), this._update(!0)) : this;
        }
        getSlot(c) {
          const t = this.getLayer(c);
          return t && t.slot || null;
        }
        setSlot(c, t) {
          return this.style.setSlot(c, t), this.style.mergeLayers(), this._update(!0);
        }
        addImport(c, t) {
          return this.style.addImport(c, t), this;
        }
        updateImport(c, t) {
          return typeof t != "string" && t.id !== c ? (this.removeImport(c), this.addImport(t)) : (this.style.updateImport(c, t), this._update(!0));
        }
        removeImport(c) {
          return this.style.removeImport(c), this;
        }
        moveImport(c, t) {
          return this.style.moveImport(c, t), this._update(!0);
        }
        moveLayer(c, t) {
          return this._isValidId(c) ? (this.style.moveLayer(c, t), this._update(!0)) : this;
        }
        removeLayer(c) {
          return this._isValidId(c) ? (this.style.removeLayer(c), this._update(!0)) : this;
        }
        getLayer(c) {
          if (!this._isValidId(c))
            return null;
          const t = this.style.getOwnLayer(c);
          return t ? t.type === "custom" ? t.implementation : t.serialize() : void 0;
        }
        getSlots() {
          return this.style.getSlots();
        }
        setLayerZoomRange(c, t, s) {
          return this._isValidId(c) ? (this.style.setLayerZoomRange(c, t, s), this._update(!0)) : this;
        }
        setFilter(c, t, s = {}) {
          return this._isValidId(c) ? (this.style.setFilter(c, t, s), this._update(!0)) : this;
        }
        getFilter(c) {
          return this._isValidId(c) ? this.style.getFilter(c) : null;
        }
        setPaintProperty(c, t, s, h = {}) {
          return this._isValidId(c) ? (this.style.setPaintProperty(c, t, s, h), this._update(!0)) : this;
        }
        getPaintProperty(c, t) {
          return this._isValidId(c) ? this.style.getPaintProperty(c, t) : null;
        }
        setLayoutProperty(c, t, s, h = {}) {
          return this._isValidId(c) ? (this.style.setLayoutProperty(c, t, s, h), this._update(!0)) : this;
        }
        getLayoutProperty(c, t) {
          return this._isValidId(c) ? this.style.getLayoutProperty(c, t) : null;
        }
        getSchema(c) {
          return this.style.getSchema(c);
        }
        setSchema(c, t) {
          return this.style.setSchema(c, t), this._update(!0);
        }
        getConfig(c) {
          return this.style.getConfig(c);
        }
        setConfig(c, t) {
          return this.style.setConfig(c, t), this._update(!0);
        }
        getConfigProperty(c, t) {
          return this.style.getConfigProperty(c, t);
        }
        setConfigProperty(c, t, s) {
          return this.style.setConfigProperty(c, t, s), this._update(!0);
        }
        getFeaturesetDescriptors(c) {
          return this.style.getFeaturesetDescriptors(c);
        }
        setLights(c) {
          if (this._lazyInitEmptyStyle(), c && c.length === 1 && c[0].type === "flat") {
            const t = c[0];
            t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat");
          } else
            this.style.setLights(c), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
          return this._update(!0);
        }
        getLights() {
          const c = this.style.getLights() || [];
          return c.length === 0 && c.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), c;
        }
        setLight(c, t = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: c }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(c) {
          return this._lazyInitEmptyStyle(), !c && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(c), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(c) {
          return this._lazyInitEmptyStyle(), this.style.setFog(c), this._update(!0);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setSnow(c) {
          return this._lazyInitEmptyStyle(), this.style.setSnow(c), this._update(!0);
        }
        getSnow() {
          return this.style ? this.style.getSnow() : null;
        }
        setRain(c) {
          return this._lazyInitEmptyStyle(), this.style.setRain(c), this._update(!0);
        }
        getRain() {
          return this.style ? this.style.getRain() : null;
        }
        setColorTheme(c) {
          return this._lazyInitEmptyStyle(), this.style.setColorTheme(c), this._update(!0);
        }
        setImportColorTheme(c, t) {
          return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(c, t), this._update(!0);
        }
        setCamera(c) {
          return this.style.setCamera(c), this._triggerCameraUpdate(c);
        }
        _triggerCameraUpdate(c) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch(c["camera-projection"] === "orthographic"));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(c) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(i.bO.convert(c), this.transform) : 0;
        }
        setFeatureState(c, t) {
          return c.source && !this._isValidId(c.source) ? this : (this.style.setFeatureState(c, t), this._update());
        }
        removeFeatureState(c, t) {
          return c.source && !this._isValidId(c.source) ? this : (this.style.removeFeatureState(c, t), this._update());
        }
        getFeatureState(c) {
          return c.source && !this._isValidId(c.source) ? null : this.style.getFeatureState(c);
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const c = this._container.getBoundingClientRect().width || 400, t = this._container.getBoundingClientRect().height || 300;
          let s, h, _, y = this._container;
          for (; y && (!h || !_); ) {
            const T = window.getComputedStyle(y).transform;
            T && T !== "none" && (s = T.match(/matrix.*\((.+)\)/)[1].split(", "), s[0] && s[0] !== "0" && s[0] !== "1" && (h = s[0]), s[3] && s[3] !== "0" && s[3] !== "1" && (_ = s[3])), y = y.parentElement;
          }
          this._containerWidth = h ? Math.abs(c / h) : c, this._containerHeight = _ ? Math.abs(t / _) : t;
        }
        _detectMissingCSS() {
          window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && i.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const c = this._container;
          c.classList.add("mapboxgl-map"), (this._missingCSSCanary = be("div", "mapboxgl-canary", c)).style.visibility = "hidden", this._detectMissingCSS();
          const t = this._canvasContainer = be("div", "mapboxgl-canvas-container", c);
          this._canvas = be("canvas", "mapboxgl-canvas", t), this._interactive && (t.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const s = this._controlContainer = be("div", "mapboxgl-control-container", c), h = this._controlPositions = {};
          ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((_) => {
            h[_] = be("div", `mapboxgl-ctrl-${_}`, s);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(c, t) {
          const s = i.q.devicePixelRatio || 1;
          this._canvas.width = s * Math.ceil(c), this._canvas.height = s * Math.ceil(t), this._canvas.style.width = `${c}px`, this._canvas.style.height = `${t}px`;
        }
        _addMarker(c) {
          this._markers.push(c);
        }
        _removeMarker(c) {
          const t = this._markers.indexOf(c);
          t !== -1 && this._markers.splice(t, 1);
        }
        _addPopup(c) {
          this._popups.push(c);
        }
        _removePopup(c) {
          const t = this._popups.indexOf(c);
          t !== -1 && this._popups.splice(t, 1);
        }
        _setupPainter() {
          const c = i.l({}, Te.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), t = this._canvas.getContext("webgl2", c);
          t ? (Us(t, !0), this.painter = new Ld(t, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (s) => {
            s.dataType === "source" && this.painter.setTileLoadedFlag(!0);
          }), i.m.testSupport(t)) : this.fire(new i.y(new Error("Failed to initialize WebGL")));
        }
        _contextLost(c) {
          c.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new i.z("webglcontextlost", { originalEvent: c }));
        }
        _contextRestored(c) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new i.z("webglcontextrestored", { originalEvent: c }));
        }
        _onMapScroll(c) {
          if (c.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }
        idle() {
          return !this.isMoving() && this.loaded();
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        frameReady() {
          return this.loaded() && !this._placementDirty;
        }
        _update(c) {
          return this.style ? (this._styleDirty = this._styleDirty || c, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(c) {
          return this._update(), this._renderTaskQueue.add(c);
        }
        _cancelRenderFrame(c) {
          this._renderTaskQueue.remove(c);
        }
        _requestDomTask(c) {
          !this.loaded() || this.loaded() && !this.isMoving() ? c() : this._domRenderTaskQueue.add(c);
        }
        _render(c) {
          let t;
          this.fire(new i.z("renderstart")), ++this._frameId;
          const s = this.painter.context.extTimerQuery, h = i.q.now(), _ = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (t = _.createQuery(), _.beginQuery(s.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(c), this._domRenderTaskQueue.run(c), this._removed)
            return;
          this._updateProjectionTransition();
          const y = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const F = this.transform.zoom, N = this.transform.pitch, G = i.q.now(), Z = new i.a8(F, { now: G, fadeDuration: y, pitch: N, transition: this.style.transition });
            this.style.update(Z);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
          let T = !1;
          this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), T = this._updateAverageElevation(h), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : T = this._updateAverageElevation(h);
          const z = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, y, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
          if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), z && (this._placementDirty = z.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: y, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new i.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, Y.mark(j.load), this.fire(new i.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t) {
            const F = i.q.now() - h;
            _.endQuery(s.TIME_ELAPSED_EXT), setTimeout(() => {
              const N = _.getQueryParameter(t, _.QUERY_RESULT) / 1e6;
              _.deleteQuery(t), this.fire(new i.z("gpu-timing-frame", { cpuTime: F, gpuTime: N }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const F = this.painter.collectGpuTimers();
            setTimeout(() => {
              const N = this.painter.queryGpuTimers(F);
              this.fire(new i.z("gpu-timing-layer", { layerTimes: N }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const F = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const N = this.painter.queryGpuTimeDeferredRender(F);
              this.fire(new i.z("gpu-timing-deferred-render", { gpuTime: N }));
            }, 50);
          }
          const R = this._sourcesDirty || this._styleDirty || this._placementDirty || T;
          if (R || this._repaint)
            this.triggerRepaint();
          else {
            const F = this.idle();
            if (F && (T = this._updateAverageElevation(h, !0)), T)
              this.triggerRepaint();
            else if (this._triggerFrame(!1), F && (this.fire(new i.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
              const N = this._calculateSpeedIndex();
              this.fire(new i.z("speedindexcompleted", { speedIndex: N })), this.speedIndexTiming = !1;
            }
          }
          !this._loaded || this._fullyLoaded || R || (this._fullyLoaded = !0, Y.mark(j.fullLoad), this._performanceMetricsCollection && xs(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(c) {
          for (const t of this._markers)
            c && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
          for (const t of this._popups)
            !c || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
        }
        _updateAverageElevation(c, t = !1) {
          const s = (_) => (this.transform.averageElevation = _, this._update(!1), !0);
          if (!this.painter.averageElevationNeedsEasing())
            return this.transform.averageElevation !== 0 && s(0);
          const h = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (h || (t || c - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(c)) {
            const _ = this.transform.averageElevation;
            let y = this.transform.sampleAverageElevation();
            this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(y) ? y = 0 : this._averageElevationLastSampledAt = c;
            const T = Math.abs(_ - y);
            if (T > 1) {
              if (this._isInitialLoad || h)
                return this._averageElevation.jumpTo(y), s(y);
              this._averageElevation.easeTo(y, c, 300);
            } else if (T > 1e-4)
              return this._averageElevation.jumpTo(y), s(y);
          }
          return !!this._averageElevation.isEasing(c) && s(this._averageElevation.getValue(c));
        }
        _authenticate() {
          De(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (c) => {
            if (c && (c.message === An || c.status === 401)) {
              const t = this.painter.context.gl;
              Us(t, !1), this._logoControl instanceof Il && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new i.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), ln(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _postStyleLoadEvent() {
          this.style.globalId && xi(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
        }
        _updateTerrain() {
          const c = this._isDragging();
          this.painter.updateTerrain(this.style, c);
        }
        _calculateSpeedIndex() {
          const c = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
          t.timeStamps.push(performance.now());
          const s = this.painter.context.gl, h = s.createFramebuffer();
          function _(y) {
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, y, 0);
            const T = new Uint8Array(s.drawingBufferWidth * s.drawingBufferHeight * 4);
            return s.readPixels(0, 0, s.drawingBufferWidth, s.drawingBufferHeight, s.RGBA, s.UNSIGNED_BYTE, T), T;
          }
          return s.bindFramebuffer(s.FRAMEBUFFER, h), this._canvasPixelComparison(_(c), t.canvasCopies.map(_), t.timeStamps);
        }
        _canvasPixelComparison(c, t, s) {
          let h = s[1] - s[0];
          const _ = c.length / 4;
          for (let y = 0; y < t.length; y++) {
            const T = t[y];
            let z = 0;
            for (let R = 0; R < T.length; R += 4)
              T[R] === c[R] && T[R + 1] === c[R + 1] && T[R + 2] === c[R + 2] && T[R + 3] === c[R + 3] && (z += 1);
            h += (s[y + 2] - s[y + 1]) * (1 - z / _);
          }
          return h;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const t of this._controls)
            t.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
          const c = this.painter.context.gl.getExtension("WEBGL_lose_context");
          c && c.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), Vs.delete(this.painter.context.gl), Is.remove(), qt.remove(), this._removed = !0, this.fire(new i.z("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(!0);
        }
        _triggerFrame(c) {
          this._renderNextFrame = this._renderNextFrame || c, this.style && !this._frame && (this._frame = i.q.frame((t) => {
            const s = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, s && this._render(t);
          }));
        }
        _preloadTiles(c) {
          const t = this.style ? this.style.getSourceCaches() : [];
          return i.bl(t, (s, h) => s._preloadTiles(c, h), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(c) {
          this._trackResize && this.resize({ originalEvent: c })._update();
        }
        _onVisibilityChange() {
          document.visibilityState === "hidden" && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(c) {
          this._showTileBoundaries !== c && (this._showTileBoundaries = c, this._tp.refreshUI(), this._update());
        }
        get showParseStatus() {
          return !!this._showParseStatus;
        }
        set showParseStatus(c) {
          this._showParseStatus !== c && (this._showParseStatus = c, this._tp.refreshUI(), this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(c) {
          this._showTerrainWireframe !== c && (this._showTerrainWireframe = c, this._tp.refreshUI(), this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(c) {
          this._showLayers2DWireframe !== c && (this._showLayers2DWireframe = c, this._tp.refreshUI(), this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(c) {
          this._showLayers3DWireframe !== c && (this._showLayers3DWireframe = c, this._tp.refreshUI(), this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(c) {
          this._speedIndexTiming !== c && (this._speedIndexTiming = c, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(c) {
          this._showPadding !== c && (this._showPadding = c, this._tp.refreshUI(), this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(c) {
          this._showCollisionBoxes !== c && (this._showCollisionBoxes = c, this._tp.refreshUI(), c ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(c) {
          this._showOverdrawInspector !== c && (this._showOverdrawInspector = c, this._tp.refreshUI(), this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(c) {
          this._repaint !== c && (this._repaint = c, this._tp.refreshUI(), this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(c) {
          this._vertices = c, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(c) {
          this._showTileAABBs !== c && (this._showTileAABBs = c, this._tp.refreshUI(), c && this._update());
        }
        _setCacheLimits(c, t) {
          i.dG(c, t);
        }
        get version() {
          return O;
        }
      }, NavigationControl: class {
        constructor(c = {}) {
          this.options = i.l({}, tl, c), this._container = be("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (i.aP(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t) => {
            this._map && this._map.zoomIn({}, { originalEvent: t });
          }), be("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t) => {
            this._map && this._map.zoomOut({}, { originalEvent: t });
          }), be("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (i.aP(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (t) => {
            const s = this._map;
            s && (this.options.visualizePitch ? s.resetNorthPitch({}, { originalEvent: t }) : s.resetNorth({}, { originalEvent: t }));
          }), this._compassIcon = be("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const c = this._map;
          if (!c)
            return;
          const t = c.getZoom(), s = t === c.getMaxZoom(), h = t === c.getMinZoom();
          this._zoomInButton.disabled = s, this._zoomOutButton.disabled = h, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", h.toString());
        }
        _rotateCompassArrow() {
          const c = this._map;
          if (!c)
            return;
          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(c.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${c.transform.pitch}deg) rotateZ(${c.transform.angle * (180 / Math.PI)}deg)` : `rotate(${c.transform.angle * (180 / Math.PI)}deg)`;
          c._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t);
          });
        }
        onAdd(c) {
          return this._map = c, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), c.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && c.on("pitch", this._rotateCompassArrow), c.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new f_(c, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const c = this._map;
          c && (this._container.remove(), this.options.showZoom && c.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && c.off("pitch", this._rotateCompassArrow), c.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(c, t) {
          const s = be("button", c, this._container);
          return s.type = "button", s.addEventListener("click", t), s;
        }
        _setButtonTitle(c, t) {
          if (!this._map)
            return;
          const s = this._map._getUIString(`NavigationControl.${t}`);
          c.setAttribute("aria-label", s), c.firstElementChild && c.firstElementChild.setAttribute("title", s);
        }
      }, GeolocateControl: class extends i.E {
        constructor(c = {}) {
          super();
          const t = navigator.geolocation;
          this.options = i.l({ geolocation: t }, Ta, c), i.aP(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = lh(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(c) {
          return this._map = c, this._container = be("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
        }
        _checkGeolocationSupport(c) {
          const t = (s = !!this.options.geolocation) => {
            this._supportsGeolocation = s, c(s);
          };
          this._supportsGeolocation !== void 0 ? c(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({ name: "geolocation" }).then((s) => t(s.state !== "denied")).catch(() => t()) : t();
        }
        _isOutOfMapMaxBounds(c) {
          const t = this._map.getMaxBounds(), s = c.coords;
          return !!t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new i.z("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("geolocate", c)), this._finish();
          }
        }
        _updateCamera(c) {
          const t = new i.bO(c.coords.longitude, c.coords.latitude), s = c.coords.accuracy, h = this._map.getBearing(), _ = i.l({ bearing: h }, this.options.fitBoundsOptions);
          this._map.fitBounds(t.toBounds(s), _, { geolocateSource: !0 });
        }
        _updateMarker(c) {
          if (c) {
            const t = new i.bO(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const c = this._map.transform, t = i.bH(1, c._center.lat) * c.worldSize, s = Math.ceil(2 * this._accuracy * t);
          this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && this._noTimeout)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("error", c)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(c) {
          if (this._map !== void 0) {
            if (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = be("button", "mapboxgl-ctrl-geolocate", this._container), be("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", c === !1) {
              i.w("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
            } else {
              const t = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = be("div", "mapboxgl-user-location"), this._dotElement.appendChild(be("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(be("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new ta({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = be("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ta({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t) => {
              t.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t.originalEvent && t.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new i.z("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(c) {
          this._userLocationDotMarker && (c.webkitCompassHeading ? this._heading = c.webkitCompassHeading : c.absolute === !0 && (this._heading = -1 * c.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return i.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new i.z("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new i.z("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new i.z("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (c = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, c), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
          return !0;
        }
        _addDeviceOrientationListener() {
          const c = () => {
            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
          };
          typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((t) => {
            t === "granted" && c();
          }).catch(console.error) : c();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: yp, ScaleControl: class {
        constructor(c = {}) {
          this.options = i.l({}, fr, c), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
            } catch {
              return !1;
            }
          }(), i.aP(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const c = this.options.maxWidth || 100, t = this._map, s = t._containerHeight / 2, h = t._containerWidth / 2 - c / 2, _ = t.unproject([h, s]), y = t.unproject([h + c, s]), T = _.distanceTo(y);
          if (this.options.unit === "imperial") {
            const z = 3.2808 * T;
            z > 5280 ? this._setScale(c, z / 5280, "mile") : this._setScale(c, z, "foot");
          } else
            this.options.unit === "nautical" ? this._setScale(c, T / 1852, "nautical-mile") : T >= 1e3 ? this._setScale(c, T / 1e3, "kilometer") : this._setScale(c, T, "meter");
        }
        _setScale(c, t, s) {
          this._map._requestDomTask(() => {
            const h = function(y) {
              const T = Math.pow(10, `${Math.floor(y)}`.length - 1);
              let z = y / T;
              return z = z >= 10 ? 10 : z >= 5 ? 5 : z >= 3 ? 3 : z >= 2 ? 2 : z >= 1 ? 1 : function(R) {
                const F = Math.pow(10, Math.ceil(-Math.log(R) / Math.LN10));
                return Math.round(R * F) / F;
              }(z), T * z;
            }(t), _ = h / t;
            this._container.innerHTML = this._isNumberFormatSupported && s !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: s }).format(h) : `${h}&nbsp;${Fr[s]}`, this._container.style.width = c * _ + "px";
          });
        }
        onAdd(c) {
          return this._map = c, this._language = c.getLanguage(), this._container = be("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", c.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(c) {
          this._language = c, this._update();
        }
        setUnit(c) {
          this.options.unit = c, this._update();
        }
      }, FullscreenControl: class {
        constructor(c = {}) {
          this._fullscreen = !1, c && c.container && (c.container instanceof HTMLElement ? this._container = c.container : i.w("Full screen control 'container' must be a DOM element.")), i.aP(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(c) {
          return this._map = c, this._container || (this._container = this._map.getContainer()), this._controlContainer = be("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", i.w("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const c = this._fullscreenButton = be("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          be("span", "mapboxgl-ctrl-icon", c).setAttribute("aria-hidden", "true"), c.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const c = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", c), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", c);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends i.E {
        constructor(c) {
          super(), this.options = i.l(Object.create(Os), c), i.aP(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(c && c.className ? c.className.trim().split(/\s+/) : []);
        }
        addTo(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && c.on("preclick", this._onClose), this.options.closeOnMove && c.on("move", this._onClose), c.on("remove", this.remove), this._update(), c._addPopup(this), this._focusFirstElement(), this._trackPointer ? (c.on("mousemove", this._onMouseEvent), c.on("mouseup", this._onMouseEvent), c._canvasContainer.classList.add("mapboxgl-track-pointer")) : c.on("move", this._update), this.fire(new i.z("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const c = this._map;
          return c && (c.off("move", this._update), c.off("move", this._onClose), c.off("preclick", this._onClose), c.off("click", this._onClose), c.off("remove", this.remove), c.off("mousemove", this._onMouseEvent), c.off("mouseup", this._onMouseEvent), c.off("drag", this._onMouseEvent), c._canvasContainer && c._canvasContainer.classList.remove("mapboxgl-track-pointer"), c._removePopup(this), this._map = void 0), this.fire(new i.z("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(c) {
          this._lngLat = i.bO.convert(c), this._pos = null, this._trackPointer = !1, this._update();
          const t = this._map;
          return t && (t.on("move", this._update), t.off("mousemove", this._onMouseEvent), t._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = !0, this._pos = null, this._update();
          const c = this._map;
          return c && (c.off("move", this._update), c.on("mousemove", this._onMouseEvent), c.on("drag", this._onMouseEvent), c._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(c) {
          return this.setDOMContent(document.createTextNode(c));
        }
        setHTML(c) {
          const t = document.createDocumentFragment(), s = document.createElement("body");
          let h;
          for (s.innerHTML = c; h = s.firstChild, h; )
            t.appendChild(h);
          return this.setDOMContent(t);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(c) {
          return this.options.maxWidth = c, this._update(), this;
        }
        setDOMContent(c) {
          let t = this._content;
          if (t)
            for (; t.hasChildNodes(); )
              t.firstChild && t.removeChild(t.firstChild);
          else
            t = this._content = be("div", "mapboxgl-popup-content", this._container || void 0);
          if (t.appendChild(c), this.options.closeButton) {
            const s = this._closeButton = be("button", "mapboxgl-popup-close-button", t);
            s.type = "button", s.setAttribute("aria-label", "Close popup"), s.setAttribute("aria-hidden", "true"), s.innerHTML = "&#215;", s.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(c) {
          return this._classList.add(c), this._updateClassList(), this;
        }
        removeClassName(c) {
          return this._classList.delete(c), this._updateClassList(), this;
        }
        setOffset(c) {
          return this.options.offset = c, this._update(), this;
        }
        toggleClassName(c) {
          let t;
          return this._classList.delete(c) ? t = !1 : (this._classList.add(c), t = !0), this._updateClassList(), t;
        }
        _onMouseEvent(c) {
          this._update(c.point);
        }
        _getAnchor(c) {
          if (this.options.anchor)
            return this.options.anchor;
          const t = this._map, s = this._container, h = this._pos;
          if (!t || !s || !h)
            return "bottom";
          const _ = s.offsetWidth, y = s.offsetHeight, T = h.x < _ / 2, z = h.x > t.transform.width - _ / 2;
          if (h.y + c < y)
            return T ? "top-left" : z ? "top-right" : "top";
          if (h.y > t.transform.height - y) {
            if (T)
              return "bottom-left";
            if (z)
              return "bottom-right";
          }
          return T ? "left" : z ? "right" : "bottom";
        }
        _updateClassList() {
          const c = this._container;
          if (!c)
            return;
          const t = [...this._classList];
          t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), c.className = t.join(" ");
        }
        _update(c) {
          const t = this._map, s = this._content;
          if (!t || !this._lngLat && !this._trackPointer || !s)
            return;
          let h = this._container;
          if (h || (h = this._container = be("div", "mapboxgl-popup", t.getContainer()), this._tip = be("div", "mapboxgl-popup-tip", h), h.appendChild(s)), this.options.maxWidth && h.style.maxWidth !== this.options.maxWidth && (h.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = xp(this._lngLat, this._pos, t.transform)), !this._trackPointer || c) {
            const _ = this._pos = this._trackPointer && c instanceof i.P ? c : t.project(this._lngLat), y = Un(this.options.offset), T = this._anchor = this._getAnchor(y.y), z = Un(this.options.offset, T), R = _.add(z).round();
            t._requestDomTask(() => {
              this._container && T && (this._container.style.transform = `${gh[T]} translate(${R.x}px,${R.y}px)`);
            });
          }
          if (!this._marker && t._showingGlobe()) {
            const _ = i.dH(t.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(_);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const c = this._container.querySelector(vp);
          c && c.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(c) {
          this._container && (this._container.style.opacity = `${c}`), this._content && (this._content.style.pointerEvents = c ? "auto" : "none");
        }
      }, Marker: ta, Style: hr, LngLat: i.bO, LngLatBounds: i.az, Point: i.P, MercatorCoordinate: i.aa, FreeCameraOptions: Va, Evented: i.E, config: i.e, prewarm: i.dM, clearPrewarmedResources: i.dN, get accessToken() {
        return i.e.ACCESS_TOKEN;
      }, set accessToken(c) {
        i.e.ACCESS_TOKEN = c;
      }, get baseApiUrl() {
        return i.e.API_URL;
      }, set baseApiUrl(c) {
        i.e.API_URL = c;
      }, get workerCount() {
        return i.dO.workerCount;
      }, set workerCount(c) {
        i.dO.workerCount = c;
      }, get maxParallelImageRequests() {
        return i.e.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(c) {
        i.e.MAX_PARALLEL_IMAGE_REQUESTS = c;
      }, clearStorage(c) {
        i.dP(c);
      }, get workerUrl() {
        return i.dQ.workerUrl;
      }, set workerUrl(c) {
        i.dQ.workerUrl = c;
      }, get workerClass() {
        return i.dQ.workerClass;
      }, set workerClass(c) {
        i.dQ.workerClass = c;
      }, get workerParams() {
        return i.dQ.workerParams;
      }, set workerParams(c) {
        i.dQ.workerParams = c;
      }, get dracoUrl() {
        return i.dR();
      }, set dracoUrl(c) {
        i.dS(c);
      }, get meshoptUrl() {
        return i.dT();
      }, set meshoptUrl(c) {
        i.dU(c);
      }, setNow: i.q.setNow, restoreNow: i.q.restoreNow };
    });
    var E = w;
    return E;
  });
})(vw);
var LC = vw.exports;
const Cc = /* @__PURE__ */ gw(LC);
var _o = 63710088e-1, ww = {
  centimeters: _o * 100,
  centimetres: _o * 100,
  degrees: _o / 111325,
  feet: _o * 3.28084,
  inches: _o * 39.37,
  kilometers: _o / 1e3,
  kilometres: _o / 1e3,
  meters: _o,
  metres: _o,
  miles: _o / 1609.344,
  millimeters: _o * 1e3,
  millimetres: _o * 1e3,
  nauticalmiles: _o / 1852,
  radians: 1,
  yards: _o * 1.0936
};
function Hm(m, a, d) {
  d === void 0 && (d = {});
  var g = { type: "Feature" };
  return (d.id === 0 || d.id) && (g.id = d.id), d.bbox && (g.bbox = d.bbox), g.properties = a || {}, g.geometry = m, g;
}
function ry(m, a, d) {
  if (d === void 0 && (d = {}), !m)
    throw new Error("coordinates is required");
  if (!Array.isArray(m))
    throw new Error("coordinates must be an Array");
  if (m.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!yb(m[0]) || !yb(m[1]))
    throw new Error("coordinates must contain numbers");
  var g = {
    type: "Point",
    coordinates: m
  };
  return Hm(g, a, d);
}
function Pf(m, a, d) {
  if (d === void 0 && (d = {}), m.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var g = {
    type: "LineString",
    coordinates: m
  };
  return Hm(g, a, d);
}
function zC(m, a) {
  a === void 0 && (a = "kilometers");
  var d = ww[a];
  if (!d)
    throw new Error(a + " units is invalid");
  return m * d;
}
function DC(m, a) {
  a === void 0 && (a = "kilometers");
  var d = ww[a];
  if (!d)
    throw new Error(a + " units is invalid");
  return m / d;
}
function oy(m) {
  var a = m % (2 * Math.PI);
  return a * 180 / Math.PI;
}
function La(m) {
  var a = m % 360;
  return a * Math.PI / 180;
}
function yb(m) {
  return !isNaN(m) && m !== null && !Array.isArray(m);
}
function Tw(m, a, d) {
  if (m !== null)
    for (var g, w, b, E, i, O, j, Y = 0, J = 0, ae, ce = m.type, Te = ce === "FeatureCollection", be = ce === "Feature", Ze = Te ? m.features.length : 1, je = 0; je < Ze; je++) {
      j = Te ? m.features[je].geometry : be ? m.geometry : m, ae = j ? j.type === "GeometryCollection" : !1, i = ae ? j.geometries.length : 1;
      for (var ot = 0; ot < i; ot++) {
        var vt = 0, ht = 0;
        if (E = ae ? j.geometries[ot] : j, E !== null) {
          O = E.coordinates;
          var gt = E.type;
          switch (Y = d && (gt === "Polygon" || gt === "MultiPolygon") ? 1 : 0, gt) {
            case null:
              break;
            case "Point":
              if (a(
                O,
                J,
                je,
                vt,
                ht
              ) === !1)
                return !1;
              J++, vt++;
              break;
            case "LineString":
            case "MultiPoint":
              for (g = 0; g < O.length; g++) {
                if (a(
                  O[g],
                  J,
                  je,
                  vt,
                  ht
                ) === !1)
                  return !1;
                J++, gt === "MultiPoint" && vt++;
              }
              gt === "LineString" && vt++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (g = 0; g < O.length; g++) {
                for (w = 0; w < O[g].length - Y; w++) {
                  if (a(
                    O[g][w],
                    J,
                    je,
                    vt,
                    ht
                  ) === !1)
                    return !1;
                  J++;
                }
                gt === "MultiLineString" && vt++, gt === "Polygon" && ht++;
              }
              gt === "Polygon" && vt++;
              break;
            case "MultiPolygon":
              for (g = 0; g < O.length; g++) {
                for (ht = 0, w = 0; w < O[g].length; w++) {
                  for (b = 0; b < O[g][w].length - Y; b++) {
                    if (a(
                      O[g][w][b],
                      J,
                      je,
                      vt,
                      ht
                    ) === !1)
                      return !1;
                    J++;
                  }
                  ht++;
                }
                vt++;
              }
              break;
            case "GeometryCollection":
              for (g = 0; g < E.geometries.length; g++)
                if (Tw(E.geometries[g], a, d) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function kC(m, a) {
  var d, g, w, b, E, i, O, j, Y, J, ae = 0, ce = m.type === "FeatureCollection", Te = m.type === "Feature", be = ce ? m.features.length : 1;
  for (d = 0; d < be; d++) {
    for (i = ce ? m.features[d].geometry : Te ? m.geometry : m, j = ce ? m.features[d].properties : Te ? m.properties : {}, Y = ce ? m.features[d].bbox : Te ? m.bbox : void 0, J = ce ? m.features[d].id : Te ? m.id : void 0, O = i ? i.type === "GeometryCollection" : !1, E = O ? i.geometries.length : 1, w = 0; w < E; w++) {
      if (b = O ? i.geometries[w] : i, b === null) {
        if (a(
          null,
          ae,
          j,
          Y,
          J
        ) === !1)
          return !1;
        continue;
      }
      switch (b.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (a(
            b,
            ae,
            j,
            Y,
            J
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (g = 0; g < b.geometries.length; g++)
            if (a(
              b.geometries[g],
              ae,
              j,
              Y,
              J
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    ae++;
  }
}
function RC(m, a) {
  kC(m, function(d, g, w, b, E) {
    var i = d === null ? null : d.type;
    switch (i) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return a(
          Hm(d, w, { bbox: b, id: E }),
          g,
          0
        ) === !1 ? !1 : void 0;
    }
    var O;
    switch (i) {
      case "MultiPoint":
        O = "Point";
        break;
      case "MultiLineString":
        O = "LineString";
        break;
      case "MultiPolygon":
        O = "Polygon";
        break;
    }
    for (var j = 0; j < d.coordinates.length; j++) {
      var Y = d.coordinates[j], J = {
        type: O,
        coordinates: Y
      };
      if (a(Hm(J, w), g, j) === !1)
        return !1;
    }
  });
}
function OC(m, a) {
  RC(m, function(d, g, w) {
    var b = 0;
    if (d.geometry) {
      var E = d.geometry.type;
      if (!(E === "Point" || E === "MultiPoint")) {
        var i, O = 0, j = 0, Y = 0;
        if (Tw(
          d,
          function(J, ae, ce, Te, be) {
            if (i === void 0 || g > O || Te > j || be > Y) {
              i = J, O = g, j = Te, Y = be, b = 0;
              return;
            }
            var Ze = Pf(
              [i, J],
              d.properties
            );
            if (a(
              Ze,
              g,
              w,
              be,
              b
            ) === !1)
              return !1;
            b++, i = J;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function FC(m, a, d) {
  var g = d, w = !1;
  return OC(
    m,
    function(b, E, i, O, j) {
      w === !1 && d === void 0 ? g = b : g = a(
        g,
        b,
        E,
        i,
        O,
        j
      ), w = !0;
    }
  ), g;
}
function jf(m) {
  if (!m)
    throw new Error("coord is required");
  if (!Array.isArray(m)) {
    if (m.type === "Feature" && m.geometry !== null && m.geometry.type === "Point")
      return m.geometry.coordinates;
    if (m.type === "Point")
      return m.coordinates;
  }
  if (Array.isArray(m) && m.length >= 2 && !Array.isArray(m[0]) && !Array.isArray(m[1]))
    return m;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function BC(m) {
  return m.type === "Feature" ? m.geometry : m;
}
function Mw(m, a, d) {
  d === void 0 && (d = {});
  var g = jf(m), w = jf(a), b = La(w[1] - g[1]), E = La(w[0] - g[0]), i = La(g[1]), O = La(w[1]), j = Math.pow(Math.sin(b / 2), 2) + Math.pow(Math.sin(E / 2), 2) * Math.cos(i) * Math.cos(O);
  return zC(2 * Math.atan2(Math.sqrt(j), Math.sqrt(1 - j)), d.units);
}
function NC(m, a, d, g) {
  g === void 0 && (g = {});
  var w = jf(m), b = La(w[0]), E = La(w[1]), i = La(d), O = DC(a, g.units), j = Math.asin(Math.sin(E) * Math.cos(O) + Math.cos(E) * Math.sin(O) * Math.cos(i)), Y = b + Math.atan2(Math.sin(i) * Math.sin(O) * Math.cos(E), Math.cos(O) - Math.sin(E) * Math.sin(j)), J = oy(Y), ae = oy(j);
  return ry([J, ae], g.properties);
}
function Sw(m, a, d) {
  if (d === void 0 && (d = {}), d.final === !0)
    return VC(m, a);
  var g = jf(m), w = jf(a), b = La(g[0]), E = La(w[0]), i = La(g[1]), O = La(w[1]), j = Math.sin(E - b) * Math.cos(O), Y = Math.cos(i) * Math.sin(O) - Math.sin(i) * Math.cos(O) * Math.cos(E - b);
  return oy(Math.atan2(j, Y));
}
function VC(m, a) {
  var d = Sw(a, m);
  return d = (d + 180) % 360, d;
}
function xb(m, a, d) {
  d === void 0 && (d = {});
  for (var g = BC(m), w = g.coordinates, b = 0, E = 0; E < w.length && !(a >= b && E === w.length - 1); E++)
    if (b >= a) {
      var i = a - b;
      if (i) {
        var O = Sw(w[E], w[E - 1]) - 180, j = NC(w[E], i, O, d);
        return j;
      } else
        return ry(w[E]);
    } else
      b += Mw(w[E], w[E + 1], d);
  return ry(w[w.length - 1]);
}
function vb(m, a) {
  return a === void 0 && (a = {}), FC(m, function(d, g) {
    var w = g.geometry.coordinates;
    return d + Mw(w[0], w[1], a);
  }, 0);
}
class UC {
  constructor() {
    this.start = 0, this.animationDuration = 8e4, this.cameraAltitude = 1e3, this.targetRoute = [], this.cameraRoute = [], this.iconDefault = "/wp-content/plugins/wp-gpx-maps/img/map-play-svgrepo-com.svg", this.iconStop = "/wp-content/plugins/wp-gpx-maps/img/stop-svgrepo-com.svg", this.routeDistance = 0, this.cameraRouteDistance = 0, this.isPlaying = !1;
  }
  onAdd(a) {
    return this.map = a, this.container = document.createElement("div"), this.container.className = "mapboxgl-ctrl mapboxgl-ctrl-group mapboxgl-wp-gpx-maps", this.container.innerHTML = `<button style='background-image: url(${this.iconDefault});'>&nbsp;</div>`, this.container.onclick = () => {
      this.isPlaying == !1 ? (this.isPlaying = !0, this._playAnimation()) : this.isPlaying = !1;
    }, this.container;
  }
  _animationFrame(a) {
    if (this.isPlaying == !1) {
      this.start = 0;
      return;
    }
    this.start || (this.start = a);
    const d = (a - this.start) / this.animationDuration;
    d > 1 && setTimeout(() => {
      this.start = 0;
    }, 1500);
    const g = xb(
      Pf(this.targetRoute),
      this.routeDistance * d
    ).geometry.coordinates, w = xb(
      Pf(this.cameraRoute),
      this.cameraRouteDistance * d
    ).geometry.coordinates, b = this.map.getFreeCameraOptions();
    b.position = Cc.MercatorCoordinate.fromLngLat(
      {
        lng: w[0],
        lat: w[1]
      },
      this.cameraAltitude
    ), b.lookAtPoint({
      lng: g[0],
      lat: g[1]
    }), this.map.setFreeCameraOptions(b), window.requestAnimationFrame((E) => this._animationFrame(E));
  }
  _stopAnimation() {
  }
  _playAnimation() {
    this.cameraRouteDistance = vb(
      Pf(this.cameraRoute)
    ), this.routeDistance = vb(
      Pf(this.targetRoute)
    ), window.requestAnimationFrame((a) => this._animationFrame(a));
  }
  onRemove(a) {
    this.container.remove();
  }
}
class jC {
  constructor() {
    this.Bounds = [], this.EventSelectChart = null, this.CurrentLocationMarker = null, this.animationControl = null;
  }
  init(a, d, g, w, b) {
    this.map = new Cc.Map({
      container: a,
      style: "mapbox://styles/mapbox/streets-v11",
      accessToken: "pk.eyJ1Ijoic2VjdXJjdWJlbWF4IiwiYSI6ImNsbW94MzRodjE4YjEya3BuM3liZXl6MXYifQ.db3c6nnAcFwFm5jD2NCg6w",
      // MapBoxApiKey ?? 
      center: [0, 0],
      zoom: 1,
      scrollZoom: g
    }), this.animationControl = new UC(), this.map.addControl(new Cc.NavigationControl()), this.map.addControl(new Cc.FullscreenControl()), this.map.addControl(new IC(), "top-left"), this.map.addControl(this.animationControl), this.map.on("style.load", () => {
      b.MapBoxFog && this.map.setFog({
        range: [-1, 2],
        "horizon-blend": 0.3,
        color: "white",
        "high-color": "#add8e6",
        "space-color": "#d8f2ff",
        "star-intensity": 0
      }), b.MapBox3dTerrain && (this.map.addSource("mapbox-dem", {
        type: "raster-dem",
        url: "mapbox://mapbox.mapbox-terrain-dem-v1",
        tileSize: 512,
        maxzoom: 14
      }), this.map.setTerrain({ source: "mapbox-dem", exaggeration: 1.5 }));
    });
  }
  _addMarker(a, d, g) {
    const w = document.createElement("div"), b = 32, E = 32;
    return w.className = "marker", w.style.backgroundImage = `url(${d})`, w.style.width = `${b}px`, w.style.height = `${E}px`, w.style.backgroundSize = "100%", w.addEventListener("click", (i) => {
      g == null || g.call(this, i);
    }), new Cc.Marker(w).setLngLat([a[1], a[0]]).addTo(this.map);
  }
  AppPolylines(a, d, g, w, b) {
    this.Bounds = a.filter((E) => E != null), this.map.on("style.load", () => {
      const E = Zm.Utils.DividePolylinesPoints(a), i = this.Bounds.map((O) => [O[1], O[0]]);
      if (this.animationControl.cameraRoute = i, this.animationControl.targetRoute = i, this.map.addSource("route", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: E.map((O, j) => ({
            type: "Feature",
            properties: {
              color: j < d.length ? d[j] : d[d.length - 1]
            },
            geometry: {
              type: "LineString",
              coordinates: O.map((Y) => [Y[1], Y[0]])
            }
          }))
        }
      }), this.map.addLayer({
        id: "route",
        type: "line",
        source: "route",
        layout: {
          "line-join": "round",
          "line-cap": "round"
        },
        paint: {
          "line-color": ["get", "color"],
          "line-width": 3
        }
      }), (g == "" || g == null) && (g = "https://maps.google.com/mapfiles/kml/pal4/icon25.png"), this.CurrentLocationMarker = this._addMarker(a[0], g, (O) => {
      }), w != "") {
        let O = a[0];
        O != null && this._addMarker(O, w, null);
      }
      if (b != "" && a[a.length - 1] != null) {
        let O = a[a.length - 1];
        O != null && this._addMarker(O, b, null);
      }
      this.CenterMap();
    });
  }
  AddWaypoints(a, d) {
  }
  MoveMarkerToPosition(a, d) {
    var g;
    (g = this.CurrentLocationMarker) == null || g.setLngLat([a[1], a[0]]);
  }
  SetCurrentGPSPosition(a, d, g) {
  }
  CenterMap() {
    var a;
    try {
      if (this.Bounds && this.Bounds.length > 0) {
        let d = {
          minLat: Number.POSITIVE_INFINITY,
          maxLat: Number.NEGATIVE_INFINITY,
          minLng: Number.POSITIVE_INFINITY,
          maxLng: Number.NEGATIVE_INFINITY
        };
        this.Bounds.forEach((b) => {
          if (!Array.isArray(b) || b.length !== 2)
            throw new Error("Each coordinate must be an array with [latitude, longitude].");
          const [E, i] = b;
          d.minLat = Math.min(d.minLat, E), d.maxLat = Math.max(d.maxLat, E), d.minLng = Math.min(d.minLng, i), d.maxLng = Math.max(d.maxLng, i);
        });
        const g = new Cc.LngLat(d.minLng, d.minLat), w = new Cc.LngLat(d.maxLng, d.maxLat);
        (a = this.map) == null || a.fitBounds(new Cc.LngLatBounds(g, w), { padding: 30, animate: !1 });
      }
    } catch (d) {
      console.log(d);
    }
  }
  AddPhotos(a) {
    for (const w of a) {
      let b = this._addMarker([w.lat, w.lng], w.thumbnail, (E) => {
        let i = `a[data-image-id='${w.image_id}']`, O = document.querySelector(i);
        O == null || O.click();
      });
      b._element.classList.add("wp-gpx-maps-photo-marker"), b._element.style.width = "40px", b._element.style.height = "40px";
    }
  }
}
const GC = "1", ZC = "2", HC = "3", qC = "4", WC = "5", $C = "6", XC = "5", YC = "4", KC = "3", JC = "2", QC = "1";
class iI {
  constructor(a) {
    this.map = null, this.myChart = null, this.params = a, this.init();
  }
  init() {
    var yo, xo, vo, yr, Mr, io, Ys, Sr, mi;
    let {
      targetId: a,
      mapType: d,
      mapData: g,
      graphDist: w,
      graphEle: b,
      graphSpeed: E,
      graphHr: i,
      graphAtemp: O,
      graphCad: j,
      graphGrade: Y,
      waypoints: J,
      unit: ae,
      unitspeed: ce,
      color1: Te,
      color2: be,
      color3: Ze,
      color4: je,
      color5: ot,
      color6: vt,
      color7: ht,
      chartFrom1: gt,
      chartTo1: Vt,
      chartFrom2: pt,
      chartTo2: Gt,
      startIcon: ui,
      waypointIcon: kt,
      endIcon: At,
      currentIcon: Mi,
      zoomOnScrollWheel: An,
      langs: hn,
      pluginUrl: Ht,
      usegpsposition: Si,
      currentpositioncon: Ji,
      TFApiKey: fi
    } = this.params;
    var jt = [], ni = { suf: "", dec: 0 }, Gi = { suf: "", dec: 0 }, an = { suf: "", dec: 0 }, qt = { suf: "%", dec: 1 }, ln = { suf: "", dec: 0 }, Di = { suf: "", dec: 0 }, xi = document.getElementById("wpgpxmaps_" + a), Cs = document.getElementById("map_" + a), xs = document.getElementById("chart_" + a);
    if (document.getElementById("report_" + a), document.getElementById("wpgpxmaps_" + a + "_osm_footer"), Cs == null)
      return;
    let Is = this;
    this.params.MapBoxApiKey && this.params.MapBoxApiKey.length > 20 ? this.map = new jC() : this.map = new CC(), this.map.init(
      Cs,
      d,
      An == "true",
      fi,
      this.params
    ), this.map.EventSelectChart = function(On) {
      var Vo, Ke;
      if (Is.myChart) {
        for (var Vn = On[0], Zi = On[1], Jn = Is.getClosestIndex(g, Vn, Zi), Fn = [], Ls = Is.myChart._metasets.length, zs = 0; zs < Ls; zs++)
          Fn.push(Is.myChart._metasets[zs].data[Jn]);
        if (Fn.length > 0) {
          let re = (Vo = Is.myChart.tooltip) == null ? void 0 : Vo.getActiveElements();
          (re == null || re.length == 0) && ((Ke = Is.myChart.tooltip) == null || Ke.setActiveElements([{
            datasetIndex: 0,
            index: Jn
          }], {
            x: Fn[0].x,
            y: Fn[0].y
          })), Is.myChart.tooltip.setActiveElements(Fn), Is.myChart.draw();
        }
      }
    }, Si == "true" && navigator.geolocation && navigator.geolocation.watchPosition(
      function(On) {
        On.coords.accuracy / 2;
        var Vn = [On.coords.latitude, On.coords.longitude];
        this.map.SetCurrentGPSPosition([Vn[0], Vn[1]], Ji, hn);
      },
      function(On) {
      },
      {
        enableHighAccuracy: !1,
        timeout: 5e3,
        maximumAge: 0
      }
    ), J != null && J.length > 0 && this.map.AddWaypoints(J, kt);
    let De = document.getElementById("ngimages_" + a);
    De == null || De.setAttribute("style", "display:block;position:absolute;left:-50000px");
    var Vs = De == null ? void 0 : De.querySelectorAll("span");
    if (Vs && Vs.length > 0) {
      for (var Us = [], Zr = 0; Zr < Vs.length; Zr++) {
        var Et = Vs[Zr], Ws = Et.children[0], $n = [
          Number(Et.getAttribute("lat")),
          Number(Et.getAttribute("lon"))
        ];
        this.map.Bounds.push($n), Us.push({
          lat: $n[0],
          lng: $n[1],
          name: Ws.children[0].getAttribute("alt"),
          image_id: Ws.getAttribute("data-image-id"),
          url: Ws.getAttribute("href"),
          thumbnail: Ws.children[0].getAttribute("src")
        });
      }
      Us.length > 0 && this.map.AddPhotos(Us);
    }
    g && this.map.AppPolylines(g, Te, Mi, ui, At);
    var $s = this.map;
    let vi = null, kn = xi == null ? void 0 : xi.parentElement;
    for (; kn != null; ) {
      if (kn.classList.contains("wordpress-post-tabs") && kn.classList.contains("tab-pane")) {
        vi = kn;
        break;
      }
      kn = kn.parentElement;
    }
    if (vi) {
      var Xs = function(On) {
        setTimeout(function(Vn) {
          var Zi;
          (Zi = $s.map) == null || Zi.invalidateSize(), $s.CenterMap();
        }, 300);
      };
      (yo = document.querySelector(".wpsm_nav-tabs a")) == null || yo.addEventListener("click", Xs, !1), (xo = vi.querySelector("div > ul > li > a")) == null || xo.addEventListener("click", Xs, !1);
    }
    var Hr = xs == null ? void 0 : xs.style.height;
    if (w && (b || E || i || O || j) && Hr != "0px") {
      w.length, GC == ae ? (Gi = { suf: "mi", dec: 1 }, an = { suf: "ft", dec: 0 }) : ZC == ae ? (Gi = { suf: "km", dec: 1 }, an = { suf: "m", dec: 2 }) : HC == ae ? (Gi = { suf: "NM", dec: 1 }, an = { suf: "m", dec: 0 }) : qC == ae ? (Gi = { suf: "mi", dec: 1 }, an = { suf: "m", dec: 0 }) : WC == ae ? (Gi = { suf: "NM", dec: 1 }, an = { suf: "ft", dec: 0 }) : (Gi = { suf: "m", dec: 0 }, an = { suf: "m", dec: 0 });
      var qr = 1111.1, Wr = qr.toLocaleString(), si = Wr.length;
      Wr.substring(si - 2, si - 1), Wr.substring(1, 2), Bl.register(...EC);
      var fs = {
        type: "line",
        data: {
          datasets: []
        },
        //borderWidth: 1,
        options: {
          animation: {
            // duration: 0,
            // general animation time
          },
          hover: {
            // animationDuration: 0,
            // duration of animations when hovering an item
          },
          interaction: {
            intersect: !1,
            mode: "index"
          },
          // responsiveAnimationDuration: 0,
          // animation duration after a resize
          //customLine: {
          //	color: 'gray'
          //},
          scales: {
            xAxe: {
              type: "linear",
              min: 0,
              max: w[w.length - 1],
              ticks: {
                /* Include a dollar sign in the ticks. */
                callback: function(Vn, Zi, Jn) {
                  return parseFloat(Vn + "").toFixed(Gi.dec) + Gi.suf;
                }
              }
            }
          },
          plugins: {
            tooltip: {
              position: "average",
              mode: "index",
              intersect: !1,
              callbacks: {
                title: function(Vn) {
                  var Zi = jt[0].label_x, Jn = Vn[0].element.x, Fn = Zi.dec, Ls = Zi.suf;
                  return Jn.toFixed(Fn) + Ls;
                },
                label: function(Vn) {
                  var Zi = Vn.label || "", Jn = jt[Vn.datasetIndex].label_y, Fn = Jn.dec, Ls = Jn.suf, zs = Vn.element.y;
                  return Zi && (Zi += ": "), Zi += zs.toFixed(Fn) + Ls, Zi;
                },
                footer: function(Vn) {
                  var Zi = Vn[0].dataIndex, Jn = Zm.Utils.GetItemFromArray(g, Zi);
                  Jn && $s.MoveMarkerToPosition(Jn, !1);
                }
              }
            }
            /*
            							decimation: {
            								beforeEvent: function (chart, args, options) {
            									if ((args.event.type === 'mousemove' && args.event.x)
            										&& (args.event.x >= chart.chartArea.left)
            										&& (args.event.x <= chart.chartArea.right)
            									) {
            										chart.options.customLine.x = args.event.x;
            									}
            								},
            								afterDraw: function (chart, args, opt) {
            									var ctx = chart.ctx;
            									var chartArea = chart.chartArea;
            									var x = chart.options.customLine.x;
            									if (!isNaN(x)) {
            										ctx.save();
            										ctx.strokeStyle = chart.options.customLine.color;
            										ctx.moveTo(chart.options.customLine.x, chartArea.bottom);
            										ctx.lineTo(chart.options.customLine.x, chartArea.top);
            										ctx.stroke();
            										ctx.restore();
            									}
            								}
            
            							}						
            						*/
          }
        }
        //labels: graphDist
      };
      let On = 1;
      if (b && b.length > 0) {
        var zn = this.mergeArrayForChart(w, b);
        let Vn, Zi;
        gt != "" ? Vn = parseFloat(gt) : Vn = zn.Min, Vt != "" ? Zi = parseFloat(Vt) : Zi = zn.Max;
        var Rn = "yaxis" + On++, Pn = {
          type: "linear",
          max: Zi,
          min: Vn,
          ticks: {
            callback(Jn, Fn, Ls) {
              return parseFloat(Jn + "").toFixed(an.dec) + an.suf;
            }
          }
        };
        ((vo = fs.options) == null ? void 0 : vo.scales)[Rn] = Pn, jt.push({ label_x: Gi, label_y: an }), fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.altitude, zn.Items, be, Rn));
      }
      if (E && E.length > 0) {
        $C == ce ? ni = { suf: "min/100m", dec: 2 } : XC == ce ? ni = { suf: "knots", dec: 2 } : YC == ce ? ni = { suf: "min/mi", dec: 2 } : KC == ce ? ni = { suf: "min/km", dec: 2 } : JC == ce ? ni = { suf: "mi/h", dec: 0 } : QC == ce ? ni = { suf: "km/h", dec: 0 } : ni = { suf: "m/s", dec: 0 };
        var zn = this.mergeArrayForChart(w, E);
        let Zi = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(ni.dec) + ni.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        };
        pt != "" ? Zi.min = parseFloat(pt) : Zi.min = zn.Min, Gt != "" ? Zi.max = parseFloat(Gt) : Zi.max = zn.Max, jt.push({ label_x: jt[0].label_x, label_y: ni });
        var Rn = "yaxis" + On++;
        ((yr = fs.options) == null ? void 0 : yr.scales)[Rn] = Zi, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.speed, zn.Items, Ze, Rn));
      }
      if (i && i.length > 0) {
        var zn = this.mergeArrayForChart(w, i), Pn = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(ln.dec) + ln.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((Mr = fs.options) == null ? void 0 : Mr.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.heartRate, zn.Items, je, Rn)), jt.push({ label_x: jt[0].label_x, label_y: ln });
      }
      if (O && O.length > 0) {
        var zn = this.mergeArrayForChart(w, O), Pn = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(1) + "C";
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((io = fs.options) == null ? void 0 : io.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.atemp, zn.Items, ht, Rn)), jt.push({ label_x: jt[0].label_x, label_y: { suf: "C", dec: 1 } });
      }
      if (j && j.length > 0) {
        var zn = this.mergeArrayForChart(w, j, !0), Pn = {
          type: "linear",
          ticks: {
            // Include a dollar sign in the ticks.
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(Di.dec) + Di.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((Ys = fs.options) == null ? void 0 : Ys.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.cadence, zn.Items, ot, Rn)), jt.push({ label_x: jt[0].label_x, label_y: Di });
      }
      if (Y && Y.length > 0) {
        var zn = this.mergeArrayForChart(w, Y), Pn = {
          type: "linear",
          ticks: {
            // Include a dollar sign in the ticks.
            callback: function(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(qt.dec) + qt.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        };
        jt.push({ label_x: jt[0].label_x, label_y: qt });
        var Rn = "yaxis" + On++;
        ((Sr = fs.options) == null ? void 0 : Sr.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.grade, zn.Items, vt, Rn));
      }
      var js = (mi = document.getElementById("myChart_" + a)) == null ? void 0 : mi.getContext("2d");
      js && (this.myChart = new Bl(js, fs));
    } else
      xs == null || xs.style.setProperty("display", "none");
    return this;
  }
  mergeArrayForChart(a, d, g) {
    const w = a.length, b = new Array(w);
    let E = 1e4, i = -1e4;
    for (let O = 0; O < w; O++)
      if (a[O] != null) {
        let j = d[O];
        g === !0 && j === 0 && (j = null), b[O] = {
          x: a[O],
          y: j
        }, j > i && (i = j), j < E && (E = j);
      }
    return {
      Items: b,
      Min: E,
      Max: i
    };
  }
  wpgpxmapsGetDataset(a, d, g, w) {
    return {
      label: a,
      data: d,
      borderColor: g,
      backgroundColor: this.hexToRgbA(g, 0.3),
      pointRadius: 0,
      borderWidth: 1,
      pointHoverRadius: 1,
      yAxisID: w
    };
  }
  hexToRgbA(a, d) {
    let g;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(a))
      return g = a.substring(1).split(""), g.length == 3 && (g = [g[0], g[0], g[1], g[1], g[2], g[2]]), g = "0x" + g.join(""), "rgba(" + [g >> 16 & 255, g >> 8 & 255, g & 255].join(",") + "," + d + ")";
    throw new Error("Bad Hex");
  }
  getItemFromArray(a, d) {
    try {
      return a[d];
    } catch {
      return [0, 0];
    }
  }
  getClosestIndex(a, d, g) {
    let w = 1e4, b = 0;
    for (let E = 0; E < a.length; E++) {
      if (a[E] === null)
        continue;
      const i = this.wpgpxmapsDist(a[E][0], a[E][1], d, g);
      i < w && (b = E, w = i);
    }
    return b;
  }
  getClosestImage(a, d, g) {
    let w = 1e4, b;
    const E = document.getElementById("ngimages_" + g);
    if (E == null)
      return;
    const i = E.getElementsByTagName("span");
    for (let O = 0; O < i.length; O++) {
      let j = i[O].getAttribute("lat"), Y = i[O].getAttribute("lon");
      if (j == null || Y == null)
        return;
      j = j.replace(",", "."), Y = Y.replace(",", ".");
      const J = this.wpgpxmapsDist(parseFloat(j), parseFloat(Y), a, d);
      J < w && (b = i[O], w = J);
    }
    return b;
  }
  isNumeric(a) {
    return /^-{0,1}\d*\.{0,1}\d+$/.test(a);
  }
  wpgpxmapsDist(a, d, g, w) {
    const b = g - a, E = w - d;
    return Math.sqrt(b * b + E * E);
  }
}
export {
  iI as WPGPXMaps
};
//# sourceMappingURL=WP-GPX-Maps.es.js.map
