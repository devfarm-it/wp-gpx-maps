var nS = Object.defineProperty;
var sS = (_, a, f) => a in _ ? nS(_, a, { enumerable: !0, configurable: !0, writable: !0, value: f }) : _[a] = f;
var Yt = (_, a, f) => (sS(_, typeof a != "symbol" ? a + "" : a, f), f);
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
function Bf(_) {
  return _ + 0.5 | 0;
}
const Ac = (_, a, f) => Math.max(Math.min(_, f), a);
function xf(_) {
  return Ac(Bf(_ * 2.55), 0, 255);
}
function Lc(_) {
  return Ac(Bf(_ * 255), 0, 255);
}
function Rl(_) {
  return Ac(Bf(_ / 2.55) / 100, 0, 1);
}
function Vv(_) {
  return Ac(Bf(_ * 100), 0, 100);
}
const na = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Fg = [..."0123456789ABCDEF"], rS = (_) => Fg[_ & 15], oS = (_) => Fg[(_ & 240) >> 4] + Fg[_ & 15], om = (_) => (_ & 240) >> 4 === (_ & 15), aS = (_) => om(_.r) && om(_.g) && om(_.b) && om(_.a);
function lS(_) {
  var a = _.length, f;
  return _[0] === "#" && (a === 4 || a === 5 ? f = {
    r: 255 & na[_[1]] * 17,
    g: 255 & na[_[2]] * 17,
    b: 255 & na[_[3]] * 17,
    a: a === 5 ? na[_[4]] * 17 : 255
  } : (a === 7 || a === 9) && (f = {
    r: na[_[1]] << 4 | na[_[2]],
    g: na[_[3]] << 4 | na[_[4]],
    b: na[_[5]] << 4 | na[_[6]],
    a: a === 9 ? na[_[7]] << 4 | na[_[8]] : 255
  })), f;
}
const cS = (_, a) => _ < 255 ? a(_) : "";
function hS(_) {
  var a = aS(_) ? rS : oS;
  return _ ? "#" + a(_.r) + a(_.g) + a(_.b) + cS(_.a, a) : void 0;
}
const uS = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hb(_, a, f) {
  const y = a * Math.min(f, 1 - f), w = (b, P = (b + _ / 30) % 12) => f - y * Math.max(Math.min(P - 3, 9 - P, 1), -1);
  return [w(0), w(8), w(4)];
}
function dS(_, a, f) {
  const y = (w, b = (w + _ / 60) % 6) => f - f * a * Math.max(Math.min(b, 4 - b, 1), 0);
  return [y(5), y(3), y(1)];
}
function fS(_, a, f) {
  const y = hb(_, 1, 0.5);
  let w;
  for (a + f > 1 && (w = 1 / (a + f), a *= w, f *= w), w = 0; w < 3; w++)
    y[w] *= 1 - a - f, y[w] += a;
  return y;
}
function pS(_, a, f, y, w) {
  return _ === w ? (a - f) / y + (a < f ? 6 : 0) : a === w ? (f - _) / y + 2 : (_ - a) / y + 4;
}
function Qg(_) {
  const f = _.r / 255, y = _.g / 255, w = _.b / 255, b = Math.max(f, y, w), P = Math.min(f, y, w), i = (b + P) / 2;
  let O, Z, Y;
  return b !== P && (Y = b - P, Z = i > 0.5 ? Y / (2 - b - P) : Y / (b + P), O = pS(f, y, w, Y, b), O = O * 60 + 0.5), [O | 0, Z || 0, i];
}
function ey(_, a, f, y) {
  return (Array.isArray(a) ? _(a[0], a[1], a[2]) : _(a, f, y)).map(Lc);
}
function ty(_, a, f) {
  return ey(hb, _, a, f);
}
function mS(_, a, f) {
  return ey(fS, _, a, f);
}
function _S(_, a, f) {
  return ey(dS, _, a, f);
}
function ub(_) {
  return (_ % 360 + 360) % 360;
}
function gS(_) {
  const a = uS.exec(_);
  let f = 255, y;
  if (!a)
    return;
  a[5] !== y && (f = a[6] ? xf(+a[5]) : Lc(+a[5]));
  const w = ub(+a[2]), b = +a[3] / 100, P = +a[4] / 100;
  return a[1] === "hwb" ? y = mS(w, b, P) : a[1] === "hsv" ? y = _S(w, b, P) : y = ty(w, b, P), {
    r: y[0],
    g: y[1],
    b: y[2],
    a: f
  };
}
function yS(_, a) {
  var f = Qg(_);
  f[0] = ub(f[0] + a), f = ty(f), _.r = f[0], _.g = f[1], _.b = f[2];
}
function xS(_) {
  if (!_)
    return;
  const a = Qg(_), f = a[0], y = Vv(a[1]), w = Vv(a[2]);
  return _.a < 255 ? `hsla(${f}, ${y}%, ${w}%, ${Rl(_.a)})` : `hsl(${f}, ${y}%, ${w}%)`;
}
const Uv = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, jv = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function vS() {
  const _ = {}, a = Object.keys(jv), f = Object.keys(Uv);
  let y, w, b, P, i;
  for (y = 0; y < a.length; y++) {
    for (P = i = a[y], w = 0; w < f.length; w++)
      b = f[w], i = i.replace(b, Uv[b]);
    b = parseInt(jv[P], 16), _[i] = [b >> 16 & 255, b >> 8 & 255, b & 255];
  }
  return _;
}
let am;
function bS(_) {
  am || (am = vS(), am.transparent = [0, 0, 0, 0]);
  const a = am[_.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
const wS = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function TS(_) {
  const a = wS.exec(_);
  let f = 255, y, w, b;
  if (a) {
    if (a[7] !== y) {
      const P = +a[7];
      f = a[8] ? xf(P) : Ac(P * 255, 0, 255);
    }
    return y = +a[1], w = +a[3], b = +a[5], y = 255 & (a[2] ? xf(y) : Ac(y, 0, 255)), w = 255 & (a[4] ? xf(w) : Ac(w, 0, 255)), b = 255 & (a[6] ? xf(b) : Ac(b, 0, 255)), {
      r: y,
      g: w,
      b,
      a: f
    };
  }
}
function SS(_) {
  return _ && (_.a < 255 ? `rgba(${_.r}, ${_.g}, ${_.b}, ${Rl(_.a)})` : `rgb(${_.r}, ${_.g}, ${_.b})`);
}
const Sg = (_) => _ <= 31308e-7 ? _ * 12.92 : Math.pow(_, 1 / 2.4) * 1.055 - 0.055, Zu = (_) => _ <= 0.04045 ? _ / 12.92 : Math.pow((_ + 0.055) / 1.055, 2.4);
function MS(_, a, f) {
  const y = Zu(Rl(_.r)), w = Zu(Rl(_.g)), b = Zu(Rl(_.b));
  return {
    r: Lc(Sg(y + f * (Zu(Rl(a.r)) - y))),
    g: Lc(Sg(w + f * (Zu(Rl(a.g)) - w))),
    b: Lc(Sg(b + f * (Zu(Rl(a.b)) - b))),
    a: _.a + f * (a.a - _.a)
  };
}
function lm(_, a, f) {
  if (_) {
    let y = Qg(_);
    y[a] = Math.max(0, Math.min(y[a] + y[a] * f, a === 0 ? 360 : 1)), y = ty(y), _.r = y[0], _.g = y[1], _.b = y[2];
  }
}
function db(_, a) {
  return _ && Object.assign(a || {}, _);
}
function Gv(_) {
  var a = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(_) ? _.length >= 3 && (a = { r: _[0], g: _[1], b: _[2], a: 255 }, _.length > 3 && (a.a = Lc(_[3]))) : (a = db(_, { r: 0, g: 0, b: 0, a: 1 }), a.a = Lc(a.a)), a;
}
function ES(_) {
  return _.charAt(0) === "r" ? TS(_) : gS(_);
}
class If {
  constructor(a) {
    if (a instanceof If)
      return a;
    const f = typeof a;
    let y;
    f === "object" ? y = Gv(a) : f === "string" && (y = lS(a) || bS(a) || ES(a)), this._rgb = y, this._valid = !!y;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var a = db(this._rgb);
    return a && (a.a = Rl(a.a)), a;
  }
  set rgb(a) {
    this._rgb = Gv(a);
  }
  rgbString() {
    return this._valid ? SS(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hS(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? xS(this._rgb) : void 0;
  }
  mix(a, f) {
    if (a) {
      const y = this.rgb, w = a.rgb;
      let b;
      const P = f === b ? 0.5 : f, i = 2 * P - 1, O = y.a - w.a, Z = ((i * O === -1 ? i : (i + O) / (1 + i * O)) + 1) / 2;
      b = 1 - Z, y.r = 255 & Z * y.r + b * w.r + 0.5, y.g = 255 & Z * y.g + b * w.g + 0.5, y.b = 255 & Z * y.b + b * w.b + 0.5, y.a = P * y.a + (1 - P) * w.a, this.rgb = y;
    }
    return this;
  }
  interpolate(a, f) {
    return a && (this._rgb = MS(this._rgb, a._rgb, f)), this;
  }
  clone() {
    return new If(this.rgb);
  }
  alpha(a) {
    return this._rgb.a = Lc(a), this;
  }
  clearer(a) {
    const f = this._rgb;
    return f.a *= 1 - a, this;
  }
  greyscale() {
    const a = this._rgb, f = Bf(a.r * 0.3 + a.g * 0.59 + a.b * 0.11);
    return a.r = a.g = a.b = f, this;
  }
  opaquer(a) {
    const f = this._rgb;
    return f.a *= 1 + a, this;
  }
  negate() {
    const a = this._rgb;
    return a.r = 255 - a.r, a.g = 255 - a.g, a.b = 255 - a.b, this;
  }
  lighten(a) {
    return lm(this._rgb, 2, a), this;
  }
  darken(a) {
    return lm(this._rgb, 2, -a), this;
  }
  saturate(a) {
    return lm(this._rgb, 1, a), this;
  }
  desaturate(a) {
    return lm(this._rgb, 1, -a), this;
  }
  rotate(a) {
    return yS(this._rgb, a), this;
  }
}
/*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
function zl() {
}
const AS = (() => {
  let _ = 0;
  return () => _++;
})();
function En(_) {
  return _ == null;
}
function hs(_) {
  if (Array.isArray && Array.isArray(_))
    return !0;
  const a = Object.prototype.toString.call(_);
  return a.slice(0, 7) === "[object" && a.slice(-6) === "Array]";
}
function yn(_) {
  return _ !== null && Object.prototype.toString.call(_) === "[object Object]";
}
function Ps(_) {
  return (typeof _ == "number" || _ instanceof Number) && isFinite(+_);
}
function Fo(_, a) {
  return Ps(_) ? _ : a;
}
function en(_, a) {
  return typeof _ > "u" ? a : _;
}
const PS = (_, a) => typeof _ == "string" && _.endsWith("%") ? parseFloat(_) / 100 : +_ / a, fb = (_, a) => typeof _ == "string" && _.endsWith("%") ? parseFloat(_) / 100 * a : +_;
function is(_, a, f) {
  if (_ && typeof _.call == "function")
    return _.apply(f, a);
}
function Zn(_, a, f, y) {
  let w, b, P;
  if (hs(_))
    if (b = _.length, y)
      for (w = b - 1; w >= 0; w--)
        a.call(f, _[w], w);
    else
      for (w = 0; w < b; w++)
        a.call(f, _[w], w);
  else if (yn(_))
    for (P = Object.keys(_), b = P.length, w = 0; w < b; w++)
      a.call(f, _[P[w]], P[w]);
}
function Lm(_, a) {
  let f, y, w, b;
  if (!_ || !a || _.length !== a.length)
    return !1;
  for (f = 0, y = _.length; f < y; ++f)
    if (w = _[f], b = a[f], w.datasetIndex !== b.datasetIndex || w.index !== b.index)
      return !1;
  return !0;
}
function zm(_) {
  if (hs(_))
    return _.map(zm);
  if (yn(_)) {
    const a = /* @__PURE__ */ Object.create(null), f = Object.keys(_), y = f.length;
    let w = 0;
    for (; w < y; ++w)
      a[f[w]] = zm(_[f[w]]);
    return a;
  }
  return _;
}
function pb(_) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(_) === -1;
}
function CS(_, a, f, y) {
  if (!pb(_))
    return;
  const w = a[_], b = f[_];
  yn(w) && yn(b) ? Lf(w, b, y) : a[_] = zm(b);
}
function Lf(_, a, f) {
  const y = hs(a) ? a : [
    a
  ], w = y.length;
  if (!yn(_))
    return _;
  f = f || {};
  const b = f.merger || CS;
  let P;
  for (let i = 0; i < w; ++i) {
    if (P = y[i], !yn(P))
      continue;
    const O = Object.keys(P);
    for (let Z = 0, Y = O.length; Z < Y; ++Z)
      b(O[Z], _, P, f);
  }
  return _;
}
function Mf(_, a) {
  return Lf(_, a, {
    merger: IS
  });
}
function IS(_, a, f) {
  if (!pb(_))
    return;
  const y = a[_], w = f[_];
  yn(y) && yn(w) ? Mf(y, w) : Object.prototype.hasOwnProperty.call(a, _) || (a[_] = zm(w));
}
const Zv = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (_) => _,
  // default resolvers
  x: (_) => _.x,
  y: (_) => _.y
};
function LS(_) {
  const a = _.split("."), f = [];
  let y = "";
  for (const w of a)
    y += w, y.endsWith("\\") ? y = y.slice(0, -1) + "." : (f.push(y), y = "");
  return f;
}
function zS(_) {
  const a = LS(_);
  return (f) => {
    for (const y of a) {
      if (y === "")
        break;
      f = f && f[y];
    }
    return f;
  };
}
function zc(_, a) {
  return (Zv[a] || (Zv[a] = zS(a)))(_);
}
function iy(_) {
  return _.charAt(0).toUpperCase() + _.slice(1);
}
const zf = (_) => typeof _ < "u", Dc = (_) => typeof _ == "function", Hv = (_, a) => {
  if (_.size !== a.size)
    return !1;
  for (const f of _)
    if (!a.has(f))
      return !1;
  return !0;
};
function DS(_) {
  return _.type === "mouseup" || _.type === "click" || _.type === "contextmenu";
}
const ds = Math.PI, us = 2 * ds, kS = us + ds, Dm = Number.POSITIVE_INFINITY, RS = ds / 180, Ns = ds / 2, Sh = ds / 4, qv = ds * 2 / 3, Pc = Math.log10, ol = Math.sign;
function Ef(_, a, f) {
  return Math.abs(_ - a) < f;
}
function Wv(_) {
  const a = Math.round(_);
  _ = Ef(_, a, _ / 1e3) ? a : _;
  const f = Math.pow(10, Math.floor(Pc(_))), y = _ / f;
  return (y <= 1 ? 1 : y <= 2 ? 2 : y <= 5 ? 5 : 10) * f;
}
function OS(_) {
  const a = [], f = Math.sqrt(_);
  let y;
  for (y = 1; y < f; y++)
    _ % y === 0 && (a.push(y), a.push(_ / y));
  return f === (f | 0) && a.push(f), a.sort((w, b) => w - b).pop(), a;
}
function Wu(_) {
  return !isNaN(parseFloat(_)) && isFinite(_);
}
function FS(_, a) {
  const f = Math.round(_);
  return f - a <= _ && f + a >= _;
}
function mb(_, a, f) {
  let y, w, b;
  for (y = 0, w = _.length; y < w; y++)
    b = _[y][f], isNaN(b) || (a.min = Math.min(a.min, b), a.max = Math.max(a.max, b));
}
function Ca(_) {
  return _ * (ds / 180);
}
function ny(_) {
  return _ * (180 / ds);
}
function $v(_) {
  if (!Ps(_))
    return;
  let a = 1, f = 0;
  for (; Math.round(_ * a) / a !== _; )
    a *= 10, f++;
  return f;
}
function _b(_, a) {
  const f = a.x - _.x, y = a.y - _.y, w = Math.sqrt(f * f + y * y);
  let b = Math.atan2(y, f);
  return b < -0.5 * ds && (b += us), {
    angle: b,
    distance: w
  };
}
function Bg(_, a) {
  return Math.sqrt(Math.pow(a.x - _.x, 2) + Math.pow(a.y - _.y, 2));
}
function BS(_, a) {
  return (_ - a + kS) % us - ds;
}
function Bo(_) {
  return (_ % us + us) % us;
}
function Df(_, a, f, y) {
  const w = Bo(_), b = Bo(a), P = Bo(f), i = Bo(b - w), O = Bo(P - w), Z = Bo(w - b), Y = Bo(w - P);
  return w === b || w === P || y && b === P || i > O && Z < Y;
}
function gr(_, a, f) {
  return Math.max(a, Math.min(f, _));
}
function NS(_) {
  return gr(_, -32768, 32767);
}
function Fl(_, a, f, y = 1e-6) {
  return _ >= Math.min(a, f) - y && _ <= Math.max(a, f) + y;
}
function sy(_, a, f) {
  f = f || ((P) => _[P] < a);
  let y = _.length - 1, w = 0, b;
  for (; y - w > 1; )
    b = w + y >> 1, f(b) ? w = b : y = b;
  return {
    lo: w,
    hi: y
  };
}
const Bl = (_, a, f, y) => sy(_, f, y ? (w) => {
  const b = _[w][a];
  return b < f || b === f && _[w + 1][a] === f;
} : (w) => _[w][a] < f), VS = (_, a, f) => sy(_, f, (y) => _[y][a] >= f);
function US(_, a, f) {
  let y = 0, w = _.length;
  for (; y < w && _[y] < a; )
    y++;
  for (; w > y && _[w - 1] > f; )
    w--;
  return y > 0 || w < _.length ? _.slice(y, w) : _;
}
const gb = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function jS(_, a) {
  if (_._chartjs) {
    _._chartjs.listeners.push(a);
    return;
  }
  Object.defineProperty(_, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        a
      ]
    }
  }), gb.forEach((f) => {
    const y = "_onData" + iy(f), w = _[f];
    Object.defineProperty(_, f, {
      configurable: !0,
      enumerable: !1,
      value(...b) {
        const P = w.apply(this, b);
        return _._chartjs.listeners.forEach((i) => {
          typeof i[y] == "function" && i[y](...b);
        }), P;
      }
    });
  });
}
function Xv(_, a) {
  const f = _._chartjs;
  if (!f)
    return;
  const y = f.listeners, w = y.indexOf(a);
  w !== -1 && y.splice(w, 1), !(y.length > 0) && (gb.forEach((b) => {
    delete _[b];
  }), delete _._chartjs);
}
function yb(_) {
  const a = new Set(_);
  return a.size === _.length ? _ : Array.from(a);
}
const xb = function() {
  return typeof window > "u" ? function(_) {
    return _();
  } : window.requestAnimationFrame;
}();
function vb(_, a) {
  let f = [], y = !1;
  return function(...w) {
    f = w, y || (y = !0, xb.call(window, () => {
      y = !1, _.apply(a, f);
    }));
  };
}
function GS(_, a) {
  let f;
  return function(...y) {
    return a ? (clearTimeout(f), f = setTimeout(_, a, y)) : _.apply(this, y), a;
  };
}
const ry = (_) => _ === "start" ? "left" : _ === "end" ? "right" : "center", Ur = (_, a, f) => _ === "start" ? a : _ === "end" ? f : (a + f) / 2, ZS = (_, a, f, y) => _ === (y ? "left" : "right") ? f : _ === "center" ? (a + f) / 2 : a;
function bb(_, a, f) {
  const y = a.length;
  let w = 0, b = y;
  if (_._sorted) {
    const { iScale: P, _parsed: i } = _, O = P.axis, { min: Z, max: Y, minDefined: J, maxDefined: ae } = P.getUserBounds();
    J && (w = gr(Math.min(
      // @ts-expect-error Need to type _parsed
      Bl(i, O, Z).lo,
      // @ts-expect-error Need to fix types on _lookupByKey
      f ? y : Bl(a, O, P.getPixelForValue(Z)).lo
    ), 0, y - 1)), ae ? b = gr(Math.max(
      // @ts-expect-error Need to type _parsed
      Bl(i, P.axis, Y, !0).hi + 1,
      // @ts-expect-error Need to fix types on _lookupByKey
      f ? 0 : Bl(a, O, P.getPixelForValue(Y), !0).hi + 1
    ), w, y) - w : b = y - w;
  }
  return {
    start: w,
    count: b
  };
}
function wb(_) {
  const { xScale: a, yScale: f, _scaleRanges: y } = _, w = {
    xmin: a.min,
    xmax: a.max,
    ymin: f.min,
    ymax: f.max
  };
  if (!y)
    return _._scaleRanges = w, !0;
  const b = y.xmin !== a.min || y.xmax !== a.max || y.ymin !== f.min || y.ymax !== f.max;
  return Object.assign(y, w), b;
}
const cm = (_) => _ === 0 || _ === 1, Yv = (_, a, f) => -(Math.pow(2, 10 * (_ -= 1)) * Math.sin((_ - a) * us / f)), Kv = (_, a, f) => Math.pow(2, -10 * _) * Math.sin((_ - a) * us / f) + 1, Af = {
  linear: (_) => _,
  easeInQuad: (_) => _ * _,
  easeOutQuad: (_) => -_ * (_ - 2),
  easeInOutQuad: (_) => (_ /= 0.5) < 1 ? 0.5 * _ * _ : -0.5 * (--_ * (_ - 2) - 1),
  easeInCubic: (_) => _ * _ * _,
  easeOutCubic: (_) => (_ -= 1) * _ * _ + 1,
  easeInOutCubic: (_) => (_ /= 0.5) < 1 ? 0.5 * _ * _ * _ : 0.5 * ((_ -= 2) * _ * _ + 2),
  easeInQuart: (_) => _ * _ * _ * _,
  easeOutQuart: (_) => -((_ -= 1) * _ * _ * _ - 1),
  easeInOutQuart: (_) => (_ /= 0.5) < 1 ? 0.5 * _ * _ * _ * _ : -0.5 * ((_ -= 2) * _ * _ * _ - 2),
  easeInQuint: (_) => _ * _ * _ * _ * _,
  easeOutQuint: (_) => (_ -= 1) * _ * _ * _ * _ + 1,
  easeInOutQuint: (_) => (_ /= 0.5) < 1 ? 0.5 * _ * _ * _ * _ * _ : 0.5 * ((_ -= 2) * _ * _ * _ * _ + 2),
  easeInSine: (_) => -Math.cos(_ * Ns) + 1,
  easeOutSine: (_) => Math.sin(_ * Ns),
  easeInOutSine: (_) => -0.5 * (Math.cos(ds * _) - 1),
  easeInExpo: (_) => _ === 0 ? 0 : Math.pow(2, 10 * (_ - 1)),
  easeOutExpo: (_) => _ === 1 ? 1 : -Math.pow(2, -10 * _) + 1,
  easeInOutExpo: (_) => cm(_) ? _ : _ < 0.5 ? 0.5 * Math.pow(2, 10 * (_ * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (_ * 2 - 1)) + 2),
  easeInCirc: (_) => _ >= 1 ? _ : -(Math.sqrt(1 - _ * _) - 1),
  easeOutCirc: (_) => Math.sqrt(1 - (_ -= 1) * _),
  easeInOutCirc: (_) => (_ /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - _ * _) - 1) : 0.5 * (Math.sqrt(1 - (_ -= 2) * _) + 1),
  easeInElastic: (_) => cm(_) ? _ : Yv(_, 0.075, 0.3),
  easeOutElastic: (_) => cm(_) ? _ : Kv(_, 0.075, 0.3),
  easeInOutElastic(_) {
    return cm(_) ? _ : _ < 0.5 ? 0.5 * Yv(_ * 2, 0.1125, 0.45) : 0.5 + 0.5 * Kv(_ * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(_) {
    return _ * _ * ((1.70158 + 1) * _ - 1.70158);
  },
  easeOutBack(_) {
    return (_ -= 1) * _ * ((1.70158 + 1) * _ + 1.70158) + 1;
  },
  easeInOutBack(_) {
    let a = 1.70158;
    return (_ /= 0.5) < 1 ? 0.5 * (_ * _ * (((a *= 1.525) + 1) * _ - a)) : 0.5 * ((_ -= 2) * _ * (((a *= 1.525) + 1) * _ + a) + 2);
  },
  easeInBounce: (_) => 1 - Af.easeOutBounce(1 - _),
  easeOutBounce(_) {
    return _ < 1 / 2.75 ? 7.5625 * _ * _ : _ < 2 / 2.75 ? 7.5625 * (_ -= 1.5 / 2.75) * _ + 0.75 : _ < 2.5 / 2.75 ? 7.5625 * (_ -= 2.25 / 2.75) * _ + 0.9375 : 7.5625 * (_ -= 2.625 / 2.75) * _ + 0.984375;
  },
  easeInOutBounce: (_) => _ < 0.5 ? Af.easeInBounce(_ * 2) * 0.5 : Af.easeOutBounce(_ * 2 - 1) * 0.5 + 0.5
};
function oy(_) {
  if (_ && typeof _ == "object") {
    const a = _.toString();
    return a === "[object CanvasPattern]" || a === "[object CanvasGradient]";
  }
  return !1;
}
function Jv(_) {
  return oy(_) ? _ : new If(_);
}
function Mg(_) {
  return oy(_) ? _ : new If(_).saturate(0.5).darken(0.1).hexString();
}
const HS = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], qS = [
  "color",
  "borderColor",
  "backgroundColor"
];
function WS(_) {
  _.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), _.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (a) => a !== "onProgress" && a !== "onComplete" && a !== "fn"
  }), _.set("animations", {
    colors: {
      type: "color",
      properties: qS
    },
    numbers: {
      type: "number",
      properties: HS
    }
  }), _.describe("animations", {
    _fallback: "animation"
  }), _.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (a) => a | 0
        }
      }
    }
  });
}
function $S(_) {
  _.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const Qv = /* @__PURE__ */ new Map();
function XS(_, a) {
  a = a || {};
  const f = _ + JSON.stringify(a);
  let y = Qv.get(f);
  return y || (y = new Intl.NumberFormat(_, a), Qv.set(f, y)), y;
}
function Nf(_, a, f) {
  return XS(a, f).format(_);
}
const Tb = {
  values(_) {
    return hs(_) ? _ : "" + _;
  },
  numeric(_, a, f) {
    if (_ === 0)
      return "0";
    const y = this.chart.options.locale;
    let w, b = _;
    if (f.length > 1) {
      const Z = Math.max(Math.abs(f[0].value), Math.abs(f[f.length - 1].value));
      (Z < 1e-4 || Z > 1e15) && (w = "scientific"), b = YS(_, f);
    }
    const P = Pc(Math.abs(b)), i = isNaN(P) ? 1 : Math.max(Math.min(-1 * Math.floor(P), 20), 0), O = {
      notation: w,
      minimumFractionDigits: i,
      maximumFractionDigits: i
    };
    return Object.assign(O, this.options.ticks.format), Nf(_, y, O);
  },
  logarithmic(_, a, f) {
    if (_ === 0)
      return "0";
    const y = f[a].significand || _ / Math.pow(10, Math.floor(Pc(_)));
    return [
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(y) || a > 0.8 * f.length ? Tb.numeric.call(this, _, a, f) : "";
  }
};
function YS(_, a) {
  let f = a.length > 3 ? a[2].value - a[1].value : a[1].value - a[0].value;
  return Math.abs(f) >= 1 && _ !== Math.floor(_) && (f = _ - Math.floor(_)), f;
}
var Vm = {
  formatters: Tb
};
function KS(_) {
  _.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (a, f) => f.lineWidth,
      tickColor: (a, f) => f.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Vm.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), _.route("scale.ticks", "color", "", "color"), _.route("scale.grid", "color", "", "borderColor"), _.route("scale.border", "color", "", "borderColor"), _.route("scale.title", "color", "", "color"), _.describe("scale", {
    _fallback: !1,
    _scriptable: (a) => !a.startsWith("before") && !a.startsWith("after") && a !== "callback" && a !== "parser",
    _indexable: (a) => a !== "borderDash" && a !== "tickBorderDash" && a !== "dash"
  }), _.describe("scales", {
    _fallback: "scale"
  }), _.describe("scale.ticks", {
    _scriptable: (a) => a !== "backdropPadding" && a !== "callback",
    _indexable: (a) => a !== "backdropPadding"
  });
}
const kh = /* @__PURE__ */ Object.create(null), Ng = /* @__PURE__ */ Object.create(null);
function Pf(_, a) {
  if (!a)
    return _;
  const f = a.split(".");
  for (let y = 0, w = f.length; y < w; ++y) {
    const b = f[y];
    _ = _[b] || (_[b] = /* @__PURE__ */ Object.create(null));
  }
  return _;
}
function Eg(_, a, f) {
  return typeof a == "string" ? Lf(Pf(_, a), f) : Lf(Pf(_, ""), a);
}
class JS {
  constructor(a, f) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (y) => y.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (y, w) => Mg(w.backgroundColor), this.hoverBorderColor = (y, w) => Mg(w.borderColor), this.hoverColor = (y, w) => Mg(w.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(a), this.apply(f);
  }
  set(a, f) {
    return Eg(this, a, f);
  }
  get(a) {
    return Pf(this, a);
  }
  describe(a, f) {
    return Eg(Ng, a, f);
  }
  override(a, f) {
    return Eg(kh, a, f);
  }
  route(a, f, y, w) {
    const b = Pf(this, a), P = Pf(this, y), i = "_" + f;
    Object.defineProperties(b, {
      [i]: {
        value: b[f],
        writable: !0
      },
      [f]: {
        enumerable: !0,
        get() {
          const O = this[i], Z = P[w];
          return yn(O) ? Object.assign({}, Z, O) : en(O, Z);
        },
        set(O) {
          this[i] = O;
        }
      }
    });
  }
  apply(a) {
    a.forEach((f) => f(this));
  }
}
var ys = /* @__PURE__ */ new JS({
  _scriptable: (_) => !_.startsWith("on"),
  _indexable: (_) => _ !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  WS,
  $S,
  KS
]);
function QS(_) {
  return !_ || En(_.size) || En(_.family) ? null : (_.style ? _.style + " " : "") + (_.weight ? _.weight + " " : "") + _.size + "px " + _.family;
}
function km(_, a, f, y, w) {
  let b = a[w];
  return b || (b = a[w] = _.measureText(w).width, f.push(w)), b > y && (y = b), y;
}
function eM(_, a, f, y) {
  y = y || {};
  let w = y.data = y.data || {}, b = y.garbageCollect = y.garbageCollect || [];
  y.font !== a && (w = y.data = {}, b = y.garbageCollect = [], y.font = a), _.save(), _.font = a;
  let P = 0;
  const i = f.length;
  let O, Z, Y, J, ae;
  for (O = 0; O < i; O++)
    if (J = f[O], J != null && !hs(J))
      P = km(_, w, b, P, J);
    else if (hs(J))
      for (Z = 0, Y = J.length; Z < Y; Z++)
        ae = J[Z], ae != null && !hs(ae) && (P = km(_, w, b, P, ae));
  _.restore();
  const ue = b.length / 2;
  if (ue > f.length) {
    for (O = 0; O < ue; O++)
      delete w[b[O]];
    b.splice(0, ue);
  }
  return P;
}
function Mh(_, a, f) {
  const y = _.currentDevicePixelRatio, w = f !== 0 ? Math.max(f / 2, 0.5) : 0;
  return Math.round((a - w) * y) / y + w;
}
function e1(_, a) {
  !a && !_ || (a = a || _.getContext("2d"), a.save(), a.resetTransform(), a.clearRect(0, 0, _.width, _.height), a.restore());
}
function Vg(_, a, f, y) {
  Sb(_, a, f, y, null);
}
function Sb(_, a, f, y, w) {
  let b, P, i, O, Z, Y, J, ae;
  const ue = a.pointStyle, Se = a.rotation, we = a.radius;
  let qe = (Se || 0) * RS;
  if (ue && typeof ue == "object" && (b = ue.toString(), b === "[object HTMLImageElement]" || b === "[object HTMLCanvasElement]")) {
    _.save(), _.translate(f, y), _.rotate(qe), _.drawImage(ue, -ue.width / 2, -ue.height / 2, ue.width, ue.height), _.restore();
    return;
  }
  if (!(isNaN(we) || we <= 0)) {
    switch (_.beginPath(), ue) {
      default:
        w ? _.ellipse(f, y, w / 2, we, 0, 0, us) : _.arc(f, y, we, 0, us), _.closePath();
        break;
      case "triangle":
        Y = w ? w / 2 : we, _.moveTo(f + Math.sin(qe) * Y, y - Math.cos(qe) * we), qe += qv, _.lineTo(f + Math.sin(qe) * Y, y - Math.cos(qe) * we), qe += qv, _.lineTo(f + Math.sin(qe) * Y, y - Math.cos(qe) * we), _.closePath();
        break;
      case "rectRounded":
        Z = we * 0.516, O = we - Z, P = Math.cos(qe + Sh) * O, J = Math.cos(qe + Sh) * (w ? w / 2 - Z : O), i = Math.sin(qe + Sh) * O, ae = Math.sin(qe + Sh) * (w ? w / 2 - Z : O), _.arc(f - J, y - i, Z, qe - ds, qe - Ns), _.arc(f + ae, y - P, Z, qe - Ns, qe), _.arc(f + J, y + i, Z, qe, qe + Ns), _.arc(f - ae, y + P, Z, qe + Ns, qe + ds), _.closePath();
        break;
      case "rect":
        if (!Se) {
          O = Math.SQRT1_2 * we, Y = w ? w / 2 : O, _.rect(f - Y, y - O, 2 * Y, 2 * O);
          break;
        }
        qe += Sh;
      case "rectRot":
        J = Math.cos(qe) * (w ? w / 2 : we), P = Math.cos(qe) * we, i = Math.sin(qe) * we, ae = Math.sin(qe) * (w ? w / 2 : we), _.moveTo(f - J, y - i), _.lineTo(f + ae, y - P), _.lineTo(f + J, y + i), _.lineTo(f - ae, y + P), _.closePath();
        break;
      case "crossRot":
        qe += Sh;
      case "cross":
        J = Math.cos(qe) * (w ? w / 2 : we), P = Math.cos(qe) * we, i = Math.sin(qe) * we, ae = Math.sin(qe) * (w ? w / 2 : we), _.moveTo(f - J, y - i), _.lineTo(f + J, y + i), _.moveTo(f + ae, y - P), _.lineTo(f - ae, y + P);
        break;
      case "star":
        J = Math.cos(qe) * (w ? w / 2 : we), P = Math.cos(qe) * we, i = Math.sin(qe) * we, ae = Math.sin(qe) * (w ? w / 2 : we), _.moveTo(f - J, y - i), _.lineTo(f + J, y + i), _.moveTo(f + ae, y - P), _.lineTo(f - ae, y + P), qe += Sh, J = Math.cos(qe) * (w ? w / 2 : we), P = Math.cos(qe) * we, i = Math.sin(qe) * we, ae = Math.sin(qe) * (w ? w / 2 : we), _.moveTo(f - J, y - i), _.lineTo(f + J, y + i), _.moveTo(f + ae, y - P), _.lineTo(f - ae, y + P);
        break;
      case "line":
        P = w ? w / 2 : Math.cos(qe) * we, i = Math.sin(qe) * we, _.moveTo(f - P, y - i), _.lineTo(f + P, y + i);
        break;
      case "dash":
        _.moveTo(f, y), _.lineTo(f + Math.cos(qe) * (w ? w / 2 : we), y + Math.sin(qe) * we);
        break;
      case !1:
        _.closePath();
        break;
    }
    _.fill(), a.borderWidth > 0 && _.stroke();
  }
}
function Nl(_, a, f) {
  return f = f || 0.5, !a || _ && _.x > a.left - f && _.x < a.right + f && _.y > a.top - f && _.y < a.bottom + f;
}
function Um(_, a) {
  _.save(), _.beginPath(), _.rect(a.left, a.top, a.right - a.left, a.bottom - a.top), _.clip();
}
function jm(_) {
  _.restore();
}
function tM(_, a, f, y, w) {
  if (!a)
    return _.lineTo(f.x, f.y);
  if (w === "middle") {
    const b = (a.x + f.x) / 2;
    _.lineTo(b, a.y), _.lineTo(b, f.y);
  } else
    w === "after" != !!y ? _.lineTo(a.x, f.y) : _.lineTo(f.x, a.y);
  _.lineTo(f.x, f.y);
}
function iM(_, a, f, y) {
  if (!a)
    return _.lineTo(f.x, f.y);
  _.bezierCurveTo(y ? a.cp1x : a.cp2x, y ? a.cp1y : a.cp2y, y ? f.cp2x : f.cp1x, y ? f.cp2y : f.cp1y, f.x, f.y);
}
function nM(_, a) {
  a.translation && _.translate(a.translation[0], a.translation[1]), En(a.rotation) || _.rotate(a.rotation), a.color && (_.fillStyle = a.color), a.textAlign && (_.textAlign = a.textAlign), a.textBaseline && (_.textBaseline = a.textBaseline);
}
function sM(_, a, f, y, w) {
  if (w.strikethrough || w.underline) {
    const b = _.measureText(y), P = a - b.actualBoundingBoxLeft, i = a + b.actualBoundingBoxRight, O = f - b.actualBoundingBoxAscent, Z = f + b.actualBoundingBoxDescent, Y = w.strikethrough ? (O + Z) / 2 : Z;
    _.strokeStyle = _.fillStyle, _.beginPath(), _.lineWidth = w.decorationWidth || 2, _.moveTo(P, Y), _.lineTo(i, Y), _.stroke();
  }
}
function rM(_, a) {
  const f = _.fillStyle;
  _.fillStyle = a.color, _.fillRect(a.left, a.top, a.width, a.height), _.fillStyle = f;
}
function Rh(_, a, f, y, w, b = {}) {
  const P = hs(a) ? a : [
    a
  ], i = b.strokeWidth > 0 && b.strokeColor !== "";
  let O, Z;
  for (_.save(), _.font = w.string, nM(_, b), O = 0; O < P.length; ++O)
    Z = P[O], b.backdrop && rM(_, b.backdrop), i && (b.strokeColor && (_.strokeStyle = b.strokeColor), En(b.strokeWidth) || (_.lineWidth = b.strokeWidth), _.strokeText(Z, f, y, b.maxWidth)), _.fillText(Z, f, y, b.maxWidth), sM(_, f, y, Z, b), y += Number(w.lineHeight);
  _.restore();
}
function kf(_, a) {
  const { x: f, y, w, h: b, radius: P } = a;
  _.arc(f + P.topLeft, y + P.topLeft, P.topLeft, 1.5 * ds, ds, !0), _.lineTo(f, y + b - P.bottomLeft), _.arc(f + P.bottomLeft, y + b - P.bottomLeft, P.bottomLeft, ds, Ns, !0), _.lineTo(f + w - P.bottomRight, y + b), _.arc(f + w - P.bottomRight, y + b - P.bottomRight, P.bottomRight, Ns, 0, !0), _.lineTo(f + w, y + P.topRight), _.arc(f + w - P.topRight, y + P.topRight, P.topRight, 0, -Ns, !0), _.lineTo(f + P.topLeft, y);
}
const oM = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, aM = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function lM(_, a) {
  const f = ("" + _).match(oM);
  if (!f || f[1] === "normal")
    return a * 1.2;
  switch (_ = +f[2], f[3]) {
    case "px":
      return _;
    case "%":
      _ /= 100;
      break;
  }
  return a * _;
}
const cM = (_) => +_ || 0;
function ay(_, a) {
  const f = {}, y = yn(a), w = y ? Object.keys(a) : a, b = yn(_) ? y ? (P) => en(_[P], _[a[P]]) : (P) => _[P] : () => _;
  for (const P of w)
    f[P] = cM(b(P));
  return f;
}
function Mb(_) {
  return ay(_, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function zh(_) {
  return ay(_, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Gr(_) {
  const a = Mb(_);
  return a.width = a.left + a.right, a.height = a.top + a.bottom, a;
}
function tr(_, a) {
  _ = _ || {}, a = a || ys.font;
  let f = en(_.size, a.size);
  typeof f == "string" && (f = parseInt(f, 10));
  let y = en(_.style, a.style);
  y && !("" + y).match(aM) && (console.warn('Invalid font style specified: "' + y + '"'), y = void 0);
  const w = {
    family: en(_.family, a.family),
    lineHeight: lM(en(_.lineHeight, a.lineHeight), f),
    size: f,
    style: y,
    weight: en(_.weight, a.weight),
    string: ""
  };
  return w.string = QS(w), w;
}
function vf(_, a, f, y) {
  let w = !0, b, P, i;
  for (b = 0, P = _.length; b < P; ++b)
    if (i = _[b], i !== void 0 && (a !== void 0 && typeof i == "function" && (i = i(a), w = !1), f !== void 0 && hs(i) && (i = i[f % i.length], w = !1), i !== void 0))
      return y && !w && (y.cacheable = !1), i;
}
function hM(_, a, f) {
  const { min: y, max: w } = _, b = fb(a, (w - y) / 2), P = (i, O) => f && i === 0 ? 0 : i + O;
  return {
    min: P(y, -Math.abs(b)),
    max: P(w, b)
  };
}
function kc(_, a) {
  return Object.assign(Object.create(_), a);
}
function ly(_, a = [
  ""
], f, y, w = () => _[0]) {
  const b = f || _;
  typeof y > "u" && (y = Cb("_fallback", _));
  const P = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: _,
    _rootScopes: b,
    _fallback: y,
    _getTarget: w,
    override: (i) => ly([
      i,
      ..._
    ], a, b, y)
  };
  return new Proxy(P, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(i, O) {
      return delete i[O], delete i._keys, delete _[0][O], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(i, O) {
      return Ab(i, O, () => yM(O, a, _, i));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(i, O) {
      return Reflect.getOwnPropertyDescriptor(i._scopes[0], O);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(_[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(i, O) {
      return i1(i).includes(O);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(i) {
      return i1(i);
    },
    /**
    * A trap for setting property values.
    */
    set(i, O, Z) {
      const Y = i._storage || (i._storage = w());
      return i[O] = Y[O] = Z, delete i._keys, !0;
    }
  });
}
function $u(_, a, f, y) {
  const w = {
    _cacheable: !1,
    _proxy: _,
    _context: a,
    _subProxy: f,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Eb(_, y),
    setContext: (b) => $u(_, b, f, y),
    override: (b) => $u(_.override(b), a, f, y)
  };
  return new Proxy(w, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(b, P) {
      return delete b[P], delete _[P], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(b, P, i) {
      return Ab(b, P, () => dM(b, P, i));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(b, P) {
      return b._descriptors.allKeys ? Reflect.has(_, P) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(_, P);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(_);
    },
    /**
    * A trap for the in operator.
    */
    has(b, P) {
      return Reflect.has(_, P);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(_);
    },
    /**
    * A trap for setting property values.
    */
    set(b, P, i) {
      return _[P] = i, delete b[P], !0;
    }
  });
}
function Eb(_, a = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: f = a.scriptable, _indexable: y = a.indexable, _allKeys: w = a.allKeys } = _;
  return {
    allKeys: w,
    scriptable: f,
    indexable: y,
    isScriptable: Dc(f) ? f : () => f,
    isIndexable: Dc(y) ? y : () => y
  };
}
const uM = (_, a) => _ ? _ + iy(a) : a, cy = (_, a) => yn(a) && _ !== "adapters" && (Object.getPrototypeOf(a) === null || a.constructor === Object);
function Ab(_, a, f) {
  if (Object.prototype.hasOwnProperty.call(_, a) || a === "constructor")
    return _[a];
  const y = f();
  return _[a] = y, y;
}
function dM(_, a, f) {
  const { _proxy: y, _context: w, _subProxy: b, _descriptors: P } = _;
  let i = y[a];
  return Dc(i) && P.isScriptable(a) && (i = fM(a, i, _, f)), hs(i) && i.length && (i = pM(a, i, _, P.isIndexable)), cy(a, i) && (i = $u(i, w, b && b[a], P)), i;
}
function fM(_, a, f, y) {
  const { _proxy: w, _context: b, _subProxy: P, _stack: i } = f;
  if (i.has(_))
    throw new Error("Recursion detected: " + Array.from(i).join("->") + "->" + _);
  i.add(_);
  let O = a(b, P || y);
  return i.delete(_), cy(_, O) && (O = hy(w._scopes, w, _, O)), O;
}
function pM(_, a, f, y) {
  const { _proxy: w, _context: b, _subProxy: P, _descriptors: i } = f;
  if (typeof b.index < "u" && y(_))
    return a[b.index % a.length];
  if (yn(a[0])) {
    const O = a, Z = w._scopes.filter((Y) => Y !== O);
    a = [];
    for (const Y of O) {
      const J = hy(Z, w, _, Y);
      a.push($u(J, b, P && P[_], i));
    }
  }
  return a;
}
function Pb(_, a, f) {
  return Dc(_) ? _(a, f) : _;
}
const mM = (_, a) => _ === !0 ? a : typeof _ == "string" ? zc(a, _) : void 0;
function _M(_, a, f, y, w) {
  for (const b of a) {
    const P = mM(f, b);
    if (P) {
      _.add(P);
      const i = Pb(P._fallback, f, w);
      if (typeof i < "u" && i !== f && i !== y)
        return i;
    } else if (P === !1 && typeof y < "u" && f !== y)
      return null;
  }
  return !1;
}
function hy(_, a, f, y) {
  const w = a._rootScopes, b = Pb(a._fallback, f, y), P = [
    ..._,
    ...w
  ], i = /* @__PURE__ */ new Set();
  i.add(y);
  let O = t1(i, P, f, b || f, y);
  return O === null || typeof b < "u" && b !== f && (O = t1(i, P, b, O, y), O === null) ? !1 : ly(Array.from(i), [
    ""
  ], w, b, () => gM(a, f, y));
}
function t1(_, a, f, y, w) {
  for (; f; )
    f = _M(_, a, f, y, w);
  return f;
}
function gM(_, a, f) {
  const y = _._getTarget();
  a in y || (y[a] = {});
  const w = y[a];
  return hs(w) && yn(f) ? f : w || {};
}
function yM(_, a, f, y) {
  let w;
  for (const b of a)
    if (w = Cb(uM(b, _), f), typeof w < "u")
      return cy(_, w) ? hy(f, y, _, w) : w;
}
function Cb(_, a) {
  for (const f of a) {
    if (!f)
      continue;
    const y = f[_];
    if (typeof y < "u")
      return y;
  }
}
function i1(_) {
  let a = _._keys;
  return a || (a = _._keys = xM(_._scopes)), a;
}
function xM(_) {
  const a = /* @__PURE__ */ new Set();
  for (const f of _)
    for (const y of Object.keys(f).filter((w) => !w.startsWith("_")))
      a.add(y);
  return Array.from(a);
}
function Ib(_, a, f, y) {
  const { iScale: w } = _, { key: b = "r" } = this._parsing, P = new Array(y);
  let i, O, Z, Y;
  for (i = 0, O = y; i < O; ++i)
    Z = i + f, Y = a[Z], P[i] = {
      r: w.parse(zc(Y, b), Z)
    };
  return P;
}
const vM = Number.EPSILON || 1e-14, Xu = (_, a) => a < _.length && !_[a].skip && _[a], Lb = (_) => _ === "x" ? "y" : "x";
function bM(_, a, f, y) {
  const w = _.skip ? a : _, b = a, P = f.skip ? a : f, i = Bg(b, w), O = Bg(P, b);
  let Z = i / (i + O), Y = O / (i + O);
  Z = isNaN(Z) ? 0 : Z, Y = isNaN(Y) ? 0 : Y;
  const J = y * Z, ae = y * Y;
  return {
    previous: {
      x: b.x - J * (P.x - w.x),
      y: b.y - J * (P.y - w.y)
    },
    next: {
      x: b.x + ae * (P.x - w.x),
      y: b.y + ae * (P.y - w.y)
    }
  };
}
function wM(_, a, f) {
  const y = _.length;
  let w, b, P, i, O, Z = Xu(_, 0);
  for (let Y = 0; Y < y - 1; ++Y)
    if (O = Z, Z = Xu(_, Y + 1), !(!O || !Z)) {
      if (Ef(a[Y], 0, vM)) {
        f[Y] = f[Y + 1] = 0;
        continue;
      }
      w = f[Y] / a[Y], b = f[Y + 1] / a[Y], i = Math.pow(w, 2) + Math.pow(b, 2), !(i <= 9) && (P = 3 / Math.sqrt(i), f[Y] = w * P * a[Y], f[Y + 1] = b * P * a[Y]);
    }
}
function TM(_, a, f = "x") {
  const y = Lb(f), w = _.length;
  let b, P, i, O = Xu(_, 0);
  for (let Z = 0; Z < w; ++Z) {
    if (P = i, i = O, O = Xu(_, Z + 1), !i)
      continue;
    const Y = i[f], J = i[y];
    P && (b = (Y - P[f]) / 3, i[`cp1${f}`] = Y - b, i[`cp1${y}`] = J - b * a[Z]), O && (b = (O[f] - Y) / 3, i[`cp2${f}`] = Y + b, i[`cp2${y}`] = J + b * a[Z]);
  }
}
function SM(_, a = "x") {
  const f = Lb(a), y = _.length, w = Array(y).fill(0), b = Array(y);
  let P, i, O, Z = Xu(_, 0);
  for (P = 0; P < y; ++P)
    if (i = O, O = Z, Z = Xu(_, P + 1), !!O) {
      if (Z) {
        const Y = Z[a] - O[a];
        w[P] = Y !== 0 ? (Z[f] - O[f]) / Y : 0;
      }
      b[P] = i ? Z ? ol(w[P - 1]) !== ol(w[P]) ? 0 : (w[P - 1] + w[P]) / 2 : w[P - 1] : w[P];
    }
  wM(_, w, b), TM(_, b, a);
}
function hm(_, a, f) {
  return Math.max(Math.min(_, f), a);
}
function MM(_, a) {
  let f, y, w, b, P, i = Nl(_[0], a);
  for (f = 0, y = _.length; f < y; ++f)
    P = b, b = i, i = f < y - 1 && Nl(_[f + 1], a), b && (w = _[f], P && (w.cp1x = hm(w.cp1x, a.left, a.right), w.cp1y = hm(w.cp1y, a.top, a.bottom)), i && (w.cp2x = hm(w.cp2x, a.left, a.right), w.cp2y = hm(w.cp2y, a.top, a.bottom)));
}
function EM(_, a, f, y, w) {
  let b, P, i, O;
  if (a.spanGaps && (_ = _.filter((Z) => !Z.skip)), a.cubicInterpolationMode === "monotone")
    SM(_, w);
  else {
    let Z = y ? _[_.length - 1] : _[0];
    for (b = 0, P = _.length; b < P; ++b)
      i = _[b], O = bM(Z, i, _[Math.min(b + 1, P - (y ? 0 : 1)) % P], a.tension), i.cp1x = O.previous.x, i.cp1y = O.previous.y, i.cp2x = O.next.x, i.cp2y = O.next.y, Z = i;
  }
  a.capBezierPoints && MM(_, f);
}
function uy() {
  return typeof window < "u" && typeof document < "u";
}
function dy(_) {
  let a = _.parentNode;
  return a && a.toString() === "[object ShadowRoot]" && (a = a.host), a;
}
function Rm(_, a, f) {
  let y;
  return typeof _ == "string" ? (y = parseInt(_, 10), _.indexOf("%") !== -1 && (y = y / 100 * a.parentNode[f])) : y = _, y;
}
const Gm = (_) => _.ownerDocument.defaultView.getComputedStyle(_, null);
function AM(_, a) {
  return Gm(_).getPropertyValue(a);
}
const PM = [
  "top",
  "right",
  "bottom",
  "left"
];
function Dh(_, a, f) {
  const y = {};
  f = f ? "-" + f : "";
  for (let w = 0; w < 4; w++) {
    const b = PM[w];
    y[b] = parseFloat(_[a + "-" + b + f]) || 0;
  }
  return y.width = y.left + y.right, y.height = y.top + y.bottom, y;
}
const CM = (_, a, f) => (_ > 0 || a > 0) && (!f || !f.shadowRoot);
function IM(_, a) {
  const f = _.touches, y = f && f.length ? f[0] : _, { offsetX: w, offsetY: b } = y;
  let P = !1, i, O;
  if (CM(w, b, _.target))
    i = w, O = b;
  else {
    const Z = a.getBoundingClientRect();
    i = y.clientX - Z.left, O = y.clientY - Z.top, P = !0;
  }
  return {
    x: i,
    y: O,
    box: P
  };
}
function Ch(_, a) {
  if ("native" in _)
    return _;
  const { canvas: f, currentDevicePixelRatio: y } = a, w = Gm(f), b = w.boxSizing === "border-box", P = Dh(w, "padding"), i = Dh(w, "border", "width"), { x: O, y: Z, box: Y } = IM(_, f), J = P.left + (Y && i.left), ae = P.top + (Y && i.top);
  let { width: ue, height: Se } = a;
  return b && (ue -= P.width + i.width, Se -= P.height + i.height), {
    x: Math.round((O - J) / ue * f.width / y),
    y: Math.round((Z - ae) / Se * f.height / y)
  };
}
function LM(_, a, f) {
  let y, w;
  if (a === void 0 || f === void 0) {
    const b = _ && dy(_);
    if (!b)
      a = _.clientWidth, f = _.clientHeight;
    else {
      const P = b.getBoundingClientRect(), i = Gm(b), O = Dh(i, "border", "width"), Z = Dh(i, "padding");
      a = P.width - Z.width - O.width, f = P.height - Z.height - O.height, y = Rm(i.maxWidth, b, "clientWidth"), w = Rm(i.maxHeight, b, "clientHeight");
    }
  }
  return {
    width: a,
    height: f,
    maxWidth: y || Dm,
    maxHeight: w || Dm
  };
}
const um = (_) => Math.round(_ * 10) / 10;
function zM(_, a, f, y) {
  const w = Gm(_), b = Dh(w, "margin"), P = Rm(w.maxWidth, _, "clientWidth") || Dm, i = Rm(w.maxHeight, _, "clientHeight") || Dm, O = LM(_, a, f);
  let { width: Z, height: Y } = O;
  if (w.boxSizing === "content-box") {
    const ae = Dh(w, "border", "width"), ue = Dh(w, "padding");
    Z -= ue.width + ae.width, Y -= ue.height + ae.height;
  }
  return Z = Math.max(0, Z - b.width), Y = Math.max(0, y ? Z / y : Y - b.height), Z = um(Math.min(Z, P, O.maxWidth)), Y = um(Math.min(Y, i, O.maxHeight)), Z && !Y && (Y = um(Z / 2)), (a !== void 0 || f !== void 0) && y && O.height && Y > O.height && (Y = O.height, Z = um(Math.floor(Y * y))), {
    width: Z,
    height: Y
  };
}
function n1(_, a, f) {
  const y = a || 1, w = Math.floor(_.height * y), b = Math.floor(_.width * y);
  _.height = Math.floor(_.height), _.width = Math.floor(_.width);
  const P = _.canvas;
  return P.style && (f || !P.style.height && !P.style.width) && (P.style.height = `${_.height}px`, P.style.width = `${_.width}px`), _.currentDevicePixelRatio !== y || P.height !== w || P.width !== b ? (_.currentDevicePixelRatio = y, P.height = w, P.width = b, _.ctx.setTransform(y, 0, 0, y, 0, 0), !0) : !1;
}
const DM = function() {
  let _ = !1;
  try {
    const a = {
      get passive() {
        return _ = !0, !1;
      }
    };
    uy() && (window.addEventListener("test", null, a), window.removeEventListener("test", null, a));
  } catch {
  }
  return _;
}();
function s1(_, a) {
  const f = AM(_, a), y = f && f.match(/^(\d+)(\.\d+)?px$/);
  return y ? +y[1] : void 0;
}
function Ih(_, a, f, y) {
  return {
    x: _.x + f * (a.x - _.x),
    y: _.y + f * (a.y - _.y)
  };
}
function kM(_, a, f, y) {
  return {
    x: _.x + f * (a.x - _.x),
    y: y === "middle" ? f < 0.5 ? _.y : a.y : y === "after" ? f < 1 ? _.y : a.y : f > 0 ? a.y : _.y
  };
}
function RM(_, a, f, y) {
  const w = {
    x: _.cp2x,
    y: _.cp2y
  }, b = {
    x: a.cp1x,
    y: a.cp1y
  }, P = Ih(_, w, f), i = Ih(w, b, f), O = Ih(b, a, f), Z = Ih(P, i, f), Y = Ih(i, O, f);
  return Ih(Z, Y, f);
}
const OM = function(_, a) {
  return {
    x(f) {
      return _ + _ + a - f;
    },
    setWidth(f) {
      a = f;
    },
    textAlign(f) {
      return f === "center" ? f : f === "right" ? "left" : "right";
    },
    xPlus(f, y) {
      return f - y;
    },
    leftForLtr(f, y) {
      return f - y;
    }
  };
}, FM = function() {
  return {
    x(_) {
      return _;
    },
    setWidth(_) {
    },
    textAlign(_) {
      return _;
    },
    xPlus(_, a) {
      return _ + a;
    },
    leftForLtr(_, a) {
      return _;
    }
  };
};
function qu(_, a, f) {
  return _ ? OM(a, f) : FM();
}
function zb(_, a) {
  let f, y;
  (a === "ltr" || a === "rtl") && (f = _.canvas.style, y = [
    f.getPropertyValue("direction"),
    f.getPropertyPriority("direction")
  ], f.setProperty("direction", a, "important"), _.prevTextDirection = y);
}
function Db(_, a) {
  a !== void 0 && (delete _.prevTextDirection, _.canvas.style.setProperty("direction", a[0], a[1]));
}
function kb(_) {
  return _ === "angle" ? {
    between: Df,
    compare: BS,
    normalize: Bo
  } : {
    between: Fl,
    compare: (a, f) => a - f,
    normalize: (a) => a
  };
}
function r1({ start: _, end: a, count: f, loop: y, style: w }) {
  return {
    start: _ % f,
    end: a % f,
    loop: y && (a - _ + 1) % f === 0,
    style: w
  };
}
function BM(_, a, f) {
  const { property: y, start: w, end: b } = f, { between: P, normalize: i } = kb(y), O = a.length;
  let { start: Z, end: Y, loop: J } = _, ae, ue;
  if (J) {
    for (Z += O, Y += O, ae = 0, ue = O; ae < ue && P(i(a[Z % O][y]), w, b); ++ae)
      Z--, Y--;
    Z %= O, Y %= O;
  }
  return Y < Z && (Y += O), {
    start: Z,
    end: Y,
    loop: J,
    style: _.style
  };
}
function Rb(_, a, f) {
  if (!f)
    return [
      _
    ];
  const { property: y, start: w, end: b } = f, P = a.length, { compare: i, between: O, normalize: Z } = kb(y), { start: Y, end: J, loop: ae, style: ue } = BM(_, a, f), Se = [];
  let we = !1, qe = null, Ge, lt, Et;
  const ut = () => O(w, Et, Ge) && i(w, Et) !== 0, bt = () => i(b, Ge) === 0 || O(b, Et, Ge), Vt = () => we || ut(), pt = () => !we || bt();
  for (let Gt = Y, ui = Y; Gt <= J; ++Gt)
    lt = a[Gt % P], !lt.skip && (Ge = Z(lt[y]), Ge !== Et && (we = O(Ge, w, b), qe === null && Vt() && (qe = i(Ge, w) === 0 ? Gt : ui), qe !== null && pt() && (Se.push(r1({
      start: qe,
      end: Gt,
      loop: ae,
      count: P,
      style: ue
    })), qe = null), ui = Gt, Et = Ge));
  return qe !== null && Se.push(r1({
    start: qe,
    end: J,
    loop: ae,
    count: P,
    style: ue
  })), Se;
}
function Ob(_, a) {
  const f = [], y = _.segments;
  for (let w = 0; w < y.length; w++) {
    const b = Rb(y[w], _.points, a);
    b.length && f.push(...b);
  }
  return f;
}
function NM(_, a, f, y) {
  let w = 0, b = a - 1;
  if (f && !y)
    for (; w < a && !_[w].skip; )
      w++;
  for (; w < a && _[w].skip; )
    w++;
  for (w %= a, f && (b += w); b > w && _[b % a].skip; )
    b--;
  return b %= a, {
    start: w,
    end: b
  };
}
function VM(_, a, f, y) {
  const w = _.length, b = [];
  let P = a, i = _[a], O;
  for (O = a + 1; O <= f; ++O) {
    const Z = _[O % w];
    Z.skip || Z.stop ? i.skip || (y = !1, b.push({
      start: a % w,
      end: (O - 1) % w,
      loop: y
    }), a = P = Z.stop ? O : null) : (P = O, i.skip && (a = O)), i = Z;
  }
  return P !== null && b.push({
    start: a % w,
    end: P % w,
    loop: y
  }), b;
}
function UM(_, a) {
  const f = _.points, y = _.options.spanGaps, w = f.length;
  if (!w)
    return [];
  const b = !!_._loop, { start: P, end: i } = NM(f, w, b, y);
  if (y === !0)
    return o1(_, [
      {
        start: P,
        end: i,
        loop: b
      }
    ], f, a);
  const O = i < P ? i + w : i, Z = !!_._fullLoop && P === 0 && i === w - 1;
  return o1(_, VM(f, P, O, Z), f, a);
}
function o1(_, a, f, y) {
  return !y || !y.setContext || !f ? a : jM(_, a, f, y);
}
function jM(_, a, f, y) {
  const w = _._chart.getContext(), b = a1(_.options), { _datasetIndex: P, options: { spanGaps: i } } = _, O = f.length, Z = [];
  let Y = b, J = a[0].start, ae = J;
  function ue(Se, we, qe, Ge) {
    const lt = i ? -1 : 1;
    if (Se !== we) {
      for (Se += O; f[Se % O].skip; )
        Se -= lt;
      for (; f[we % O].skip; )
        we += lt;
      Se % O !== we % O && (Z.push({
        start: Se % O,
        end: we % O,
        loop: qe,
        style: Ge
      }), Y = Ge, J = we % O);
    }
  }
  for (const Se of a) {
    J = i ? J : Se.start;
    let we = f[J % O], qe;
    for (ae = J + 1; ae <= Se.end; ae++) {
      const Ge = f[ae % O];
      qe = a1(y.setContext(kc(w, {
        type: "segment",
        p0: we,
        p1: Ge,
        p0DataIndex: (ae - 1) % O,
        p1DataIndex: ae % O,
        datasetIndex: P
      }))), GM(qe, Y) && ue(J, ae - 1, Se.loop, Y), we = Ge, Y = qe;
    }
    J < ae - 1 && ue(J, ae - 1, Se.loop, Y);
  }
  return Z;
}
function a1(_) {
  return {
    backgroundColor: _.backgroundColor,
    borderCapStyle: _.borderCapStyle,
    borderDash: _.borderDash,
    borderDashOffset: _.borderDashOffset,
    borderJoinStyle: _.borderJoinStyle,
    borderWidth: _.borderWidth,
    borderColor: _.borderColor
  };
}
function GM(_, a) {
  if (!a)
    return !1;
  const f = [], y = function(w, b) {
    return oy(b) ? (f.includes(b) || f.push(b), f.indexOf(b)) : b;
  };
  return JSON.stringify(_, y) !== JSON.stringify(a, y);
}
/*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
class ZM {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(a, f, y, w) {
    const b = f.listeners[w], P = f.duration;
    b.forEach((i) => i({
      chart: a,
      initial: f.initial,
      numSteps: P,
      currentStep: Math.min(y - f.start, P)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = xb.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(a = Date.now()) {
    let f = 0;
    this._charts.forEach((y, w) => {
      if (!y.running || !y.items.length)
        return;
      const b = y.items;
      let P = b.length - 1, i = !1, O;
      for (; P >= 0; --P)
        O = b[P], O._active ? (O._total > y.duration && (y.duration = O._total), O.tick(a), i = !0) : (b[P] = b[b.length - 1], b.pop());
      i && (w.draw(), this._notify(w, y, a, "progress")), b.length || (y.running = !1, this._notify(w, y, a, "complete"), y.initial = !1), f += b.length;
    }), this._lastDate = a, f === 0 && (this._running = !1);
  }
  _getAnims(a) {
    const f = this._charts;
    let y = f.get(a);
    return y || (y = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, f.set(a, y)), y;
  }
  listen(a, f, y) {
    this._getAnims(a).listeners[f].push(y);
  }
  add(a, f) {
    !f || !f.length || this._getAnims(a).items.push(...f);
  }
  has(a) {
    return this._getAnims(a).items.length > 0;
  }
  start(a) {
    const f = this._charts.get(a);
    f && (f.running = !0, f.start = Date.now(), f.duration = f.items.reduce((y, w) => Math.max(y, w._duration), 0), this._refresh());
  }
  running(a) {
    if (!this._running)
      return !1;
    const f = this._charts.get(a);
    return !(!f || !f.running || !f.items.length);
  }
  stop(a) {
    const f = this._charts.get(a);
    if (!f || !f.items.length)
      return;
    const y = f.items;
    let w = y.length - 1;
    for (; w >= 0; --w)
      y[w].cancel();
    f.items = [], this._notify(a, f, Date.now(), "complete");
  }
  remove(a) {
    return this._charts.delete(a);
  }
}
var Dl = /* @__PURE__ */ new ZM();
const l1 = "transparent", HM = {
  boolean(_, a, f) {
    return f > 0.5 ? a : _;
  },
  color(_, a, f) {
    const y = Jv(_ || l1), w = y.valid && Jv(a || l1);
    return w && w.valid ? w.mix(y, f).hexString() : a;
  },
  number(_, a, f) {
    return _ + (a - _) * f;
  }
};
class qM {
  constructor(a, f, y, w) {
    const b = f[y];
    w = vf([
      a.to,
      w,
      b,
      a.from
    ]);
    const P = vf([
      a.from,
      b,
      w
    ]);
    this._active = !0, this._fn = a.fn || HM[a.type || typeof P], this._easing = Af[a.easing] || Af.linear, this._start = Math.floor(Date.now() + (a.delay || 0)), this._duration = this._total = Math.floor(a.duration), this._loop = !!a.loop, this._target = f, this._prop = y, this._from = P, this._to = w, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(a, f, y) {
    if (this._active) {
      this._notify(!1);
      const w = this._target[this._prop], b = y - this._start, P = this._duration - b;
      this._start = y, this._duration = Math.floor(Math.max(P, a.duration)), this._total += b, this._loop = !!a.loop, this._to = vf([
        a.to,
        f,
        w,
        a.from
      ]), this._from = vf([
        a.from,
        w,
        f
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(a) {
    const f = a - this._start, y = this._duration, w = this._prop, b = this._from, P = this._loop, i = this._to;
    let O;
    if (this._active = b !== i && (P || f < y), !this._active) {
      this._target[w] = i, this._notify(!0);
      return;
    }
    if (f < 0) {
      this._target[w] = b;
      return;
    }
    O = f / y % 2, O = P && O > 1 ? 2 - O : O, O = this._easing(Math.min(1, Math.max(0, O))), this._target[w] = this._fn(b, i, O);
  }
  wait() {
    const a = this._promises || (this._promises = []);
    return new Promise((f, y) => {
      a.push({
        res: f,
        rej: y
      });
    });
  }
  _notify(a) {
    const f = a ? "res" : "rej", y = this._promises || [];
    for (let w = 0; w < y.length; w++)
      y[w][f]();
  }
}
class Fb {
  constructor(a, f) {
    this._chart = a, this._properties = /* @__PURE__ */ new Map(), this.configure(f);
  }
  configure(a) {
    if (!yn(a))
      return;
    const f = Object.keys(ys.animation), y = this._properties;
    Object.getOwnPropertyNames(a).forEach((w) => {
      const b = a[w];
      if (!yn(b))
        return;
      const P = {};
      for (const i of f)
        P[i] = b[i];
      (hs(b.properties) && b.properties || [
        w
      ]).forEach((i) => {
        (i === w || !y.has(i)) && y.set(i, P);
      });
    });
  }
  _animateOptions(a, f) {
    const y = f.options, w = $M(a, y);
    if (!w)
      return [];
    const b = this._createAnimations(w, y);
    return y.$shared && WM(a.options.$animations, y).then(() => {
      a.options = y;
    }, () => {
    }), b;
  }
  _createAnimations(a, f) {
    const y = this._properties, w = [], b = a.$animations || (a.$animations = {}), P = Object.keys(f), i = Date.now();
    let O;
    for (O = P.length - 1; O >= 0; --O) {
      const Z = P[O];
      if (Z.charAt(0) === "$")
        continue;
      if (Z === "options") {
        w.push(...this._animateOptions(a, f));
        continue;
      }
      const Y = f[Z];
      let J = b[Z];
      const ae = y.get(Z);
      if (J)
        if (ae && J.active()) {
          J.update(ae, Y, i);
          continue;
        } else
          J.cancel();
      if (!ae || !ae.duration) {
        a[Z] = Y;
        continue;
      }
      b[Z] = J = new qM(ae, a, Z, Y), w.push(J);
    }
    return w;
  }
  update(a, f) {
    if (this._properties.size === 0) {
      Object.assign(a, f);
      return;
    }
    const y = this._createAnimations(a, f);
    if (y.length)
      return Dl.add(this._chart, y), !0;
  }
}
function WM(_, a) {
  const f = [], y = Object.keys(a);
  for (let w = 0; w < y.length; w++) {
    const b = _[y[w]];
    b && b.active() && f.push(b.wait());
  }
  return Promise.all(f);
}
function $M(_, a) {
  if (!a)
    return;
  let f = _.options;
  if (!f) {
    _.options = a;
    return;
  }
  return f.$shared && (_.options = f = Object.assign({}, f, {
    $shared: !1,
    $animations: {}
  })), f;
}
function c1(_, a) {
  const f = _ && _.options || {}, y = f.reverse, w = f.min === void 0 ? a : 0, b = f.max === void 0 ? a : 0;
  return {
    start: y ? b : w,
    end: y ? w : b
  };
}
function XM(_, a, f) {
  if (f === !1)
    return !1;
  const y = c1(_, f), w = c1(a, f);
  return {
    top: w.end,
    right: y.end,
    bottom: w.start,
    left: y.start
  };
}
function YM(_) {
  let a, f, y, w;
  return yn(_) ? (a = _.top, f = _.right, y = _.bottom, w = _.left) : a = f = y = w = _, {
    top: a,
    right: f,
    bottom: y,
    left: w,
    disabled: _ === !1
  };
}
function Bb(_, a) {
  const f = [], y = _._getSortedDatasetMetas(a);
  let w, b;
  for (w = 0, b = y.length; w < b; ++w)
    f.push(y[w].index);
  return f;
}
function h1(_, a, f, y = {}) {
  const w = _.keys, b = y.mode === "single";
  let P, i, O, Z;
  if (a === null)
    return;
  let Y = !1;
  for (P = 0, i = w.length; P < i; ++P) {
    if (O = +w[P], O === f) {
      if (Y = !0, y.all)
        continue;
      break;
    }
    Z = _.values[O], Ps(Z) && (b || a === 0 || ol(a) === ol(Z)) && (a += Z);
  }
  return !Y && !y.all ? 0 : a;
}
function KM(_, a) {
  const { iScale: f, vScale: y } = a, w = f.axis === "x" ? "x" : "y", b = y.axis === "x" ? "x" : "y", P = Object.keys(_), i = new Array(P.length);
  let O, Z, Y;
  for (O = 0, Z = P.length; O < Z; ++O)
    Y = P[O], i[O] = {
      [w]: Y,
      [b]: _[Y]
    };
  return i;
}
function Ag(_, a) {
  const f = _ && _.options.stacked;
  return f || f === void 0 && a.stack !== void 0;
}
function JM(_, a, f) {
  return `${_.id}.${a.id}.${f.stack || f.type}`;
}
function QM(_) {
  const { min: a, max: f, minDefined: y, maxDefined: w } = _.getUserBounds();
  return {
    min: y ? a : Number.NEGATIVE_INFINITY,
    max: w ? f : Number.POSITIVE_INFINITY
  };
}
function eE(_, a, f) {
  const y = _[a] || (_[a] = {});
  return y[f] || (y[f] = {});
}
function u1(_, a, f, y) {
  for (const w of a.getMatchingVisibleMetas(y).reverse()) {
    const b = _[w.index];
    if (f && b > 0 || !f && b < 0)
      return w.index;
  }
  return null;
}
function d1(_, a) {
  const { chart: f, _cachedMeta: y } = _, w = f._stacks || (f._stacks = {}), { iScale: b, vScale: P, index: i } = y, O = b.axis, Z = P.axis, Y = JM(b, P, y), J = a.length;
  let ae;
  for (let ue = 0; ue < J; ++ue) {
    const Se = a[ue], { [O]: we, [Z]: qe } = Se, Ge = Se._stacks || (Se._stacks = {});
    ae = Ge[Z] = eE(w, Y, we), ae[i] = qe, ae._top = u1(ae, P, !0, y.type), ae._bottom = u1(ae, P, !1, y.type);
    const lt = ae._visualValues || (ae._visualValues = {});
    lt[i] = qe;
  }
}
function Pg(_, a) {
  const f = _.scales;
  return Object.keys(f).filter((y) => f[y].axis === a).shift();
}
function tE(_, a) {
  return kc(_, {
    active: !1,
    dataset: void 0,
    datasetIndex: a,
    index: a,
    mode: "default",
    type: "dataset"
  });
}
function iE(_, a, f) {
  return kc(_, {
    active: !1,
    dataIndex: a,
    parsed: void 0,
    raw: void 0,
    element: f,
    index: a,
    mode: "default",
    type: "data"
  });
}
function pf(_, a) {
  const f = _.controller.index, y = _.vScale && _.vScale.axis;
  if (y) {
    a = a || _._parsed;
    for (const w of a) {
      const b = w._stacks;
      if (!b || b[y] === void 0 || b[y][f] === void 0)
        return;
      delete b[y][f], b[y]._visualValues !== void 0 && b[y]._visualValues[f] !== void 0 && delete b[y]._visualValues[f];
    }
  }
}
const Cg = (_) => _ === "reset" || _ === "none", f1 = (_, a) => a ? _ : Object.assign({}, _), nE = (_, a, f) => _ && !a.hidden && a._stacked && {
  keys: Bb(f, !0),
  values: null
};
class Ia {
  constructor(a, f) {
    this.chart = a, this._ctx = a.ctx, this.index = f, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const a = this._cachedMeta;
    this.configure(), this.linkScales(), a._stacked = Ag(a.vScale, a), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(a) {
    this.index !== a && pf(this._cachedMeta), this.index = a;
  }
  linkScales() {
    const a = this.chart, f = this._cachedMeta, y = this.getDataset(), w = (J, ae, ue, Se) => J === "x" ? ae : J === "r" ? Se : ue, b = f.xAxisID = en(y.xAxisID, Pg(a, "x")), P = f.yAxisID = en(y.yAxisID, Pg(a, "y")), i = f.rAxisID = en(y.rAxisID, Pg(a, "r")), O = f.indexAxis, Z = f.iAxisID = w(O, b, P, i), Y = f.vAxisID = w(O, P, b, i);
    f.xScale = this.getScaleForId(b), f.yScale = this.getScaleForId(P), f.rScale = this.getScaleForId(i), f.iScale = this.getScaleForId(Z), f.vScale = this.getScaleForId(Y);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(a) {
    return this.chart.scales[a];
  }
  _getOtherScale(a) {
    const f = this._cachedMeta;
    return a === f.iScale ? f.vScale : f.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const a = this._cachedMeta;
    this._data && Xv(this._data, this), a._stacked && pf(a);
  }
  _dataCheck() {
    const a = this.getDataset(), f = a.data || (a.data = []), y = this._data;
    if (yn(f)) {
      const w = this._cachedMeta;
      this._data = KM(f, w);
    } else if (y !== f) {
      if (y) {
        Xv(y, this);
        const w = this._cachedMeta;
        pf(w), w._parsed = [];
      }
      f && Object.isExtensible(f) && jS(f, this), this._syncList = [], this._data = f;
    }
  }
  addElements() {
    const a = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (a.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(a) {
    const f = this._cachedMeta, y = this.getDataset();
    let w = !1;
    this._dataCheck();
    const b = f._stacked;
    f._stacked = Ag(f.vScale, f), f.stack !== y.stack && (w = !0, pf(f), f.stack = y.stack), this._resyncElements(a), (w || b !== f._stacked) && (d1(this, f._parsed), f._stacked = Ag(f.vScale, f));
  }
  configure() {
    const a = this.chart.config, f = a.datasetScopeKeys(this._type), y = a.getOptionScopes(this.getDataset(), f, !0);
    this.options = a.createResolver(y, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(a, f) {
    const { _cachedMeta: y, _data: w } = this, { iScale: b, _stacked: P } = y, i = b.axis;
    let O = a === 0 && f === w.length ? !0 : y._sorted, Z = a > 0 && y._parsed[a - 1], Y, J, ae;
    if (this._parsing === !1)
      y._parsed = w, y._sorted = !0, ae = w;
    else {
      hs(w[a]) ? ae = this.parseArrayData(y, w, a, f) : yn(w[a]) ? ae = this.parseObjectData(y, w, a, f) : ae = this.parsePrimitiveData(y, w, a, f);
      const ue = () => J[i] === null || Z && J[i] < Z[i];
      for (Y = 0; Y < f; ++Y)
        y._parsed[Y + a] = J = ae[Y], O && (ue() && (O = !1), Z = J);
      y._sorted = O;
    }
    P && d1(this, ae);
  }
  parsePrimitiveData(a, f, y, w) {
    const { iScale: b, vScale: P } = a, i = b.axis, O = P.axis, Z = b.getLabels(), Y = b === P, J = new Array(w);
    let ae, ue, Se;
    for (ae = 0, ue = w; ae < ue; ++ae)
      Se = ae + y, J[ae] = {
        [i]: Y || b.parse(Z[Se], Se),
        [O]: P.parse(f[Se], Se)
      };
    return J;
  }
  parseArrayData(a, f, y, w) {
    const { xScale: b, yScale: P } = a, i = new Array(w);
    let O, Z, Y, J;
    for (O = 0, Z = w; O < Z; ++O)
      Y = O + y, J = f[Y], i[O] = {
        x: b.parse(J[0], Y),
        y: P.parse(J[1], Y)
      };
    return i;
  }
  parseObjectData(a, f, y, w) {
    const { xScale: b, yScale: P } = a, { xAxisKey: i = "x", yAxisKey: O = "y" } = this._parsing, Z = new Array(w);
    let Y, J, ae, ue;
    for (Y = 0, J = w; Y < J; ++Y)
      ae = Y + y, ue = f[ae], Z[Y] = {
        x: b.parse(zc(ue, i), ae),
        y: P.parse(zc(ue, O), ae)
      };
    return Z;
  }
  getParsed(a) {
    return this._cachedMeta._parsed[a];
  }
  getDataElement(a) {
    return this._cachedMeta.data[a];
  }
  applyStack(a, f, y) {
    const w = this.chart, b = this._cachedMeta, P = f[a.axis], i = {
      keys: Bb(w, !0),
      values: f._stacks[a.axis]._visualValues
    };
    return h1(i, P, b.index, {
      mode: y
    });
  }
  updateRangeFromParsed(a, f, y, w) {
    const b = y[f.axis];
    let P = b === null ? NaN : b;
    const i = w && y._stacks[f.axis];
    w && i && (w.values = i, P = h1(w, b, this._cachedMeta.index)), a.min = Math.min(a.min, P), a.max = Math.max(a.max, P);
  }
  getMinMax(a, f) {
    const y = this._cachedMeta, w = y._parsed, b = y._sorted && a === y.iScale, P = w.length, i = this._getOtherScale(a), O = nE(f, y, this.chart), Z = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: Y, max: J } = QM(i);
    let ae, ue;
    function Se() {
      ue = w[ae];
      const we = ue[i.axis];
      return !Ps(ue[a.axis]) || Y > we || J < we;
    }
    for (ae = 0; ae < P && !(!Se() && (this.updateRangeFromParsed(Z, a, ue, O), b)); ++ae)
      ;
    if (b) {
      for (ae = P - 1; ae >= 0; --ae)
        if (!Se()) {
          this.updateRangeFromParsed(Z, a, ue, O);
          break;
        }
    }
    return Z;
  }
  getAllParsedValues(a) {
    const f = this._cachedMeta._parsed, y = [];
    let w, b, P;
    for (w = 0, b = f.length; w < b; ++w)
      P = f[w][a.axis], Ps(P) && y.push(P);
    return y;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(a) {
    const f = this._cachedMeta, y = f.iScale, w = f.vScale, b = this.getParsed(a);
    return {
      label: y ? "" + y.getLabelForValue(b[y.axis]) : "",
      value: w ? "" + w.getLabelForValue(b[w.axis]) : ""
    };
  }
  _update(a) {
    const f = this._cachedMeta;
    this.update(a || "default"), f._clip = YM(en(this.options.clip, XM(f.xScale, f.yScale, this.getMaxOverflow())));
  }
  update(a) {
  }
  draw() {
    const a = this._ctx, f = this.chart, y = this._cachedMeta, w = y.data || [], b = f.chartArea, P = [], i = this._drawStart || 0, O = this._drawCount || w.length - i, Z = this.options.drawActiveElementsOnTop;
    let Y;
    for (y.dataset && y.dataset.draw(a, b, i, O), Y = i; Y < i + O; ++Y) {
      const J = w[Y];
      J.hidden || (J.active && Z ? P.push(J) : J.draw(a, b));
    }
    for (Y = 0; Y < P.length; ++Y)
      P[Y].draw(a, b);
  }
  getStyle(a, f) {
    const y = f ? "active" : "default";
    return a === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(y) : this.resolveDataElementOptions(a || 0, y);
  }
  getContext(a, f, y) {
    const w = this.getDataset();
    let b;
    if (a >= 0 && a < this._cachedMeta.data.length) {
      const P = this._cachedMeta.data[a];
      b = P.$context || (P.$context = iE(this.getContext(), a, P)), b.parsed = this.getParsed(a), b.raw = w.data[a], b.index = b.dataIndex = a;
    } else
      b = this.$context || (this.$context = tE(this.chart.getContext(), this.index)), b.dataset = w, b.index = b.datasetIndex = this.index;
    return b.active = !!f, b.mode = y, b;
  }
  resolveDatasetElementOptions(a) {
    return this._resolveElementOptions(this.datasetElementType.id, a);
  }
  resolveDataElementOptions(a, f) {
    return this._resolveElementOptions(this.dataElementType.id, f, a);
  }
  _resolveElementOptions(a, f = "default", y) {
    const w = f === "active", b = this._cachedDataOpts, P = a + "-" + f, i = b[P], O = this.enableOptionSharing && zf(y);
    if (i)
      return f1(i, O);
    const Z = this.chart.config, Y = Z.datasetElementScopeKeys(this._type, a), J = w ? [
      `${a}Hover`,
      "hover",
      a,
      ""
    ] : [
      a,
      ""
    ], ae = Z.getOptionScopes(this.getDataset(), Y), ue = Object.keys(ys.elements[a]), Se = () => this.getContext(y, w, f), we = Z.resolveNamedOptions(ae, ue, Se, J);
    return we.$shared && (we.$shared = O, b[P] = Object.freeze(f1(we, O))), we;
  }
  _resolveAnimations(a, f, y) {
    const w = this.chart, b = this._cachedDataOpts, P = `animation-${f}`, i = b[P];
    if (i)
      return i;
    let O;
    if (w.options.animation !== !1) {
      const Y = this.chart.config, J = Y.datasetAnimationScopeKeys(this._type, f), ae = Y.getOptionScopes(this.getDataset(), J);
      O = Y.createResolver(ae, this.getContext(a, y, f));
    }
    const Z = new Fb(w, O && O.animations);
    return O && O._cacheable && (b[P] = Object.freeze(Z)), Z;
  }
  getSharedOptions(a) {
    if (a.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, a));
  }
  includeOptions(a, f) {
    return !f || Cg(a) || this.chart._animationsDisabled;
  }
  _getSharedOptions(a, f) {
    const y = this.resolveDataElementOptions(a, f), w = this._sharedOptions, b = this.getSharedOptions(y), P = this.includeOptions(f, b) || b !== w;
    return this.updateSharedOptions(b, f, y), {
      sharedOptions: b,
      includeOptions: P
    };
  }
  updateElement(a, f, y, w) {
    Cg(w) ? Object.assign(a, y) : this._resolveAnimations(f, w).update(a, y);
  }
  updateSharedOptions(a, f, y) {
    a && !Cg(f) && this._resolveAnimations(void 0, f).update(a, y);
  }
  _setStyle(a, f, y, w) {
    a.active = w;
    const b = this.getStyle(f, w);
    this._resolveAnimations(f, y, w).update(a, {
      options: !w && this.getSharedOptions(b) || b
    });
  }
  removeHoverStyle(a, f, y) {
    this._setStyle(a, y, "active", !1);
  }
  setHoverStyle(a, f, y) {
    this._setStyle(a, y, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const a = this._cachedMeta.dataset;
    a && this._setStyle(a, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const a = this._cachedMeta.dataset;
    a && this._setStyle(a, void 0, "active", !0);
  }
  _resyncElements(a) {
    const f = this._data, y = this._cachedMeta.data;
    for (const [i, O, Z] of this._syncList)
      this[i](O, Z);
    this._syncList = [];
    const w = y.length, b = f.length, P = Math.min(b, w);
    P && this.parse(0, P), b > w ? this._insertElements(w, b - w, a) : b < w && this._removeElements(b, w - b);
  }
  _insertElements(a, f, y = !0) {
    const w = this._cachedMeta, b = w.data, P = a + f;
    let i;
    const O = (Z) => {
      for (Z.length += f, i = Z.length - 1; i >= P; i--)
        Z[i] = Z[i - f];
    };
    for (O(b), i = a; i < P; ++i)
      b[i] = new this.dataElementType();
    this._parsing && O(w._parsed), this.parse(a, f), y && this.updateElements(b, a, f, "reset");
  }
  updateElements(a, f, y, w) {
  }
  _removeElements(a, f) {
    const y = this._cachedMeta;
    if (this._parsing) {
      const w = y._parsed.splice(a, f);
      y._stacked && pf(y, w);
    }
    y.data.splice(a, f);
  }
  _sync(a) {
    if (this._parsing)
      this._syncList.push(a);
    else {
      const [f, y, w] = a;
      this[f](y, w);
    }
    this.chart._dataChanges.push([
      this.index,
      ...a
    ]);
  }
  _onDataPush() {
    const a = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - a,
      a
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(a, f) {
    f && this._sync([
      "_removeElements",
      a,
      f
    ]);
    const y = arguments.length - 2;
    y && this._sync([
      "_insertElements",
      a,
      y
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
Yt(Ia, "defaults", {}), Yt(Ia, "datasetElementType", null), Yt(Ia, "dataElementType", null);
function sE(_, a) {
  if (!_._cache.$bar) {
    const f = _.getMatchingVisibleMetas(a);
    let y = [];
    for (let w = 0, b = f.length; w < b; w++)
      y = y.concat(f[w].controller.getAllParsedValues(_));
    _._cache.$bar = yb(y.sort((w, b) => w - b));
  }
  return _._cache.$bar;
}
function rE(_) {
  const a = _.iScale, f = sE(a, _.type);
  let y = a._length, w, b, P, i;
  const O = () => {
    P === 32767 || P === -32768 || (zf(i) && (y = Math.min(y, Math.abs(P - i) || y)), i = P);
  };
  for (w = 0, b = f.length; w < b; ++w)
    P = a.getPixelForValue(f[w]), O();
  for (i = void 0, w = 0, b = a.ticks.length; w < b; ++w)
    P = a.getPixelForTick(w), O();
  return y;
}
function oE(_, a, f, y) {
  const w = f.barThickness;
  let b, P;
  return En(w) ? (b = a.min * f.categoryPercentage, P = f.barPercentage) : (b = w * y, P = 1), {
    chunk: b / y,
    ratio: P,
    start: a.pixels[_] - b / 2
  };
}
function aE(_, a, f, y) {
  const w = a.pixels, b = w[_];
  let P = _ > 0 ? w[_ - 1] : null, i = _ < w.length - 1 ? w[_ + 1] : null;
  const O = f.categoryPercentage;
  P === null && (P = b - (i === null ? a.end - a.start : i - b)), i === null && (i = b + b - P);
  const Z = b - (b - Math.min(P, i)) / 2 * O;
  return {
    chunk: Math.abs(i - P) / 2 * O / y,
    ratio: f.barPercentage,
    start: Z
  };
}
function lE(_, a, f, y) {
  const w = f.parse(_[0], y), b = f.parse(_[1], y), P = Math.min(w, b), i = Math.max(w, b);
  let O = P, Z = i;
  Math.abs(P) > Math.abs(i) && (O = i, Z = P), a[f.axis] = Z, a._custom = {
    barStart: O,
    barEnd: Z,
    start: w,
    end: b,
    min: P,
    max: i
  };
}
function Nb(_, a, f, y) {
  return hs(_) ? lE(_, a, f, y) : a[f.axis] = f.parse(_, y), a;
}
function p1(_, a, f, y) {
  const w = _.iScale, b = _.vScale, P = w.getLabels(), i = w === b, O = [];
  let Z, Y, J, ae;
  for (Z = f, Y = f + y; Z < Y; ++Z)
    ae = a[Z], J = {}, J[w.axis] = i || w.parse(P[Z], Z), O.push(Nb(ae, J, b, Z));
  return O;
}
function Ig(_) {
  return _ && _.barStart !== void 0 && _.barEnd !== void 0;
}
function cE(_, a, f) {
  return _ !== 0 ? ol(_) : (a.isHorizontal() ? 1 : -1) * (a.min >= f ? 1 : -1);
}
function hE(_) {
  let a, f, y, w, b;
  return _.horizontal ? (a = _.base > _.x, f = "left", y = "right") : (a = _.base < _.y, f = "bottom", y = "top"), a ? (w = "end", b = "start") : (w = "start", b = "end"), {
    start: f,
    end: y,
    reverse: a,
    top: w,
    bottom: b
  };
}
function uE(_, a, f, y) {
  let w = a.borderSkipped;
  const b = {};
  if (!w) {
    _.borderSkipped = b;
    return;
  }
  if (w === !0) {
    _.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: P, end: i, reverse: O, top: Z, bottom: Y } = hE(_);
  w === "middle" && f && (_.enableBorderRadius = !0, (f._top || 0) === y ? w = Z : (f._bottom || 0) === y ? w = Y : (b[m1(Y, P, i, O)] = !0, w = Z)), b[m1(w, P, i, O)] = !0, _.borderSkipped = b;
}
function m1(_, a, f, y) {
  return y ? (_ = dE(_, a, f), _ = _1(_, f, a)) : _ = _1(_, a, f), _;
}
function dE(_, a, f) {
  return _ === a ? f : _ === f ? a : _;
}
function _1(_, a, f) {
  return _ === "start" ? a : _ === "end" ? f : _;
}
function fE(_, { inflateAmount: a }, f) {
  _.inflateAmount = a === "auto" ? f === 1 ? 0.33 : 0 : a;
}
class wm extends Ia {
  parsePrimitiveData(a, f, y, w) {
    return p1(a, f, y, w);
  }
  parseArrayData(a, f, y, w) {
    return p1(a, f, y, w);
  }
  parseObjectData(a, f, y, w) {
    const { iScale: b, vScale: P } = a, { xAxisKey: i = "x", yAxisKey: O = "y" } = this._parsing, Z = b.axis === "x" ? i : O, Y = P.axis === "x" ? i : O, J = [];
    let ae, ue, Se, we;
    for (ae = y, ue = y + w; ae < ue; ++ae)
      we = f[ae], Se = {}, Se[b.axis] = b.parse(zc(we, Z), ae), J.push(Nb(zc(we, Y), Se, P, ae));
    return J;
  }
  updateRangeFromParsed(a, f, y, w) {
    super.updateRangeFromParsed(a, f, y, w);
    const b = y._custom;
    b && f === this._cachedMeta.vScale && (a.min = Math.min(a.min, b.min), a.max = Math.max(a.max, b.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(a) {
    const f = this._cachedMeta, { iScale: y, vScale: w } = f, b = this.getParsed(a), P = b._custom, i = Ig(P) ? "[" + P.start + ", " + P.end + "]" : "" + w.getLabelForValue(b[w.axis]);
    return {
      label: "" + y.getLabelForValue(b[y.axis]),
      value: i
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const a = this._cachedMeta;
    a.stack = this.getDataset().stack;
  }
  update(a) {
    const f = this._cachedMeta;
    this.updateElements(f.data, 0, f.data.length, a);
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", { index: P, _cachedMeta: { vScale: i } } = this, O = i.getBasePixel(), Z = i.isHorizontal(), Y = this._getRuler(), { sharedOptions: J, includeOptions: ae } = this._getSharedOptions(f, w);
    for (let ue = f; ue < f + y; ue++) {
      const Se = this.getParsed(ue), we = b || En(Se[i.axis]) ? {
        base: O,
        head: O
      } : this._calculateBarValuePixels(ue), qe = this._calculateBarIndexPixels(ue, Y), Ge = (Se._stacks || {})[i.axis], lt = {
        horizontal: Z,
        base: we.base,
        enableBorderRadius: !Ge || Ig(Se._custom) || P === Ge._top || P === Ge._bottom,
        x: Z ? we.head : qe.center,
        y: Z ? qe.center : we.head,
        height: Z ? qe.size : Math.abs(we.size),
        width: Z ? Math.abs(we.size) : qe.size
      };
      ae && (lt.options = J || this.resolveDataElementOptions(ue, a[ue].active ? "active" : w));
      const Et = lt.options || a[ue].options;
      uE(lt, Et, Ge, P), fE(lt, Et, Y.ratio), this.updateElement(a[ue], ue, lt, w);
    }
  }
  _getStacks(a, f) {
    const { iScale: y } = this._cachedMeta, w = y.getMatchingVisibleMetas(this._type).filter((Y) => Y.controller.options.grouped), b = y.options.stacked, P = [], i = this._cachedMeta.controller.getParsed(f), O = i && i[y.axis], Z = (Y) => {
      const J = Y._parsed.find((ue) => ue[y.axis] === O), ae = J && J[Y.vScale.axis];
      if (En(ae) || isNaN(ae))
        return !0;
    };
    for (const Y of w)
      if (!(f !== void 0 && Z(Y)) && ((b === !1 || P.indexOf(Y.stack) === -1 || b === void 0 && Y.stack === void 0) && P.push(Y.stack), Y.index === a))
        break;
    return P.length || P.push(void 0), P;
  }
  _getStackCount(a) {
    return this._getStacks(void 0, a).length;
  }
  _getStackIndex(a, f, y) {
    const w = this._getStacks(a, y), b = f !== void 0 ? w.indexOf(f) : -1;
    return b === -1 ? w.length - 1 : b;
  }
  _getRuler() {
    const a = this.options, f = this._cachedMeta, y = f.iScale, w = [];
    let b, P;
    for (b = 0, P = f.data.length; b < P; ++b)
      w.push(y.getPixelForValue(this.getParsed(b)[y.axis], b));
    const i = a.barThickness;
    return {
      min: i || rE(f),
      pixels: w,
      start: y._startPixel,
      end: y._endPixel,
      stackCount: this._getStackCount(),
      scale: y,
      grouped: a.grouped,
      ratio: i ? 1 : a.categoryPercentage * a.barPercentage
    };
  }
  _calculateBarValuePixels(a) {
    const { _cachedMeta: { vScale: f, _stacked: y, index: w }, options: { base: b, minBarLength: P } } = this, i = b || 0, O = this.getParsed(a), Z = O._custom, Y = Ig(Z);
    let J = O[f.axis], ae = 0, ue = y ? this.applyStack(f, O, y) : J, Se, we;
    ue !== J && (ae = ue - J, ue = J), Y && (J = Z.barStart, ue = Z.barEnd - Z.barStart, J !== 0 && ol(J) !== ol(Z.barEnd) && (ae = 0), ae += J);
    const qe = !En(b) && !Y ? b : ae;
    let Ge = f.getPixelForValue(qe);
    if (this.chart.getDataVisibility(a) ? Se = f.getPixelForValue(ae + ue) : Se = Ge, we = Se - Ge, Math.abs(we) < P) {
      we = cE(we, f, i) * P, J === i && (Ge -= we / 2);
      const lt = f.getPixelForDecimal(0), Et = f.getPixelForDecimal(1), ut = Math.min(lt, Et), bt = Math.max(lt, Et);
      Ge = Math.max(Math.min(Ge, bt), ut), Se = Ge + we, y && !Y && (O._stacks[f.axis]._visualValues[w] = f.getValueForPixel(Se) - f.getValueForPixel(Ge));
    }
    if (Ge === f.getPixelForValue(i)) {
      const lt = ol(we) * f.getLineWidthForValue(i) / 2;
      Ge += lt, we -= lt;
    }
    return {
      size: we,
      base: Ge,
      head: Se,
      center: Se + we / 2
    };
  }
  _calculateBarIndexPixels(a, f) {
    const y = f.scale, w = this.options, b = w.skipNull, P = en(w.maxBarThickness, 1 / 0);
    let i, O;
    if (f.grouped) {
      const Z = b ? this._getStackCount(a) : f.stackCount, Y = w.barThickness === "flex" ? aE(a, f, w, Z) : oE(a, f, w, Z), J = this._getStackIndex(this.index, this._cachedMeta.stack, b ? a : void 0);
      i = Y.start + Y.chunk * J + Y.chunk / 2, O = Math.min(P, Y.chunk * Y.ratio);
    } else
      i = y.getPixelForValue(this.getParsed(a)[y.axis], a), O = Math.min(P, f.min * f.ratio);
    return {
      base: i - O / 2,
      head: i + O / 2,
      center: i,
      size: O
    };
  }
  draw() {
    const a = this._cachedMeta, f = a.vScale, y = a.data, w = y.length;
    let b = 0;
    for (; b < w; ++b)
      this.getParsed(b)[f.axis] !== null && !y[b].hidden && y[b].draw(this._ctx);
  }
}
Yt(wm, "id", "bar"), Yt(wm, "defaults", {
  datasetElementType: !1,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: !0,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
}), Yt(wm, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: !0,
      grid: {
        offset: !0
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: !0
    }
  }
});
class Tm extends Ia {
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
  }
  parsePrimitiveData(a, f, y, w) {
    const b = super.parsePrimitiveData(a, f, y, w);
    for (let P = 0; P < b.length; P++)
      b[P]._custom = this.resolveDataElementOptions(P + y).radius;
    return b;
  }
  parseArrayData(a, f, y, w) {
    const b = super.parseArrayData(a, f, y, w);
    for (let P = 0; P < b.length; P++) {
      const i = f[y + P];
      b[P]._custom = en(i[2], this.resolveDataElementOptions(P + y).radius);
    }
    return b;
  }
  parseObjectData(a, f, y, w) {
    const b = super.parseObjectData(a, f, y, w);
    for (let P = 0; P < b.length; P++) {
      const i = f[y + P];
      b[P]._custom = en(i && i.r && +i.r, this.resolveDataElementOptions(P + y).radius);
    }
    return b;
  }
  getMaxOverflow() {
    const a = this._cachedMeta.data;
    let f = 0;
    for (let y = a.length - 1; y >= 0; --y)
      f = Math.max(f, a[y].size(this.resolveDataElementOptions(y)) / 2);
    return f > 0 && f;
  }
  getLabelAndValue(a) {
    const f = this._cachedMeta, y = this.chart.data.labels || [], { xScale: w, yScale: b } = f, P = this.getParsed(a), i = w.getLabelForValue(P.x), O = b.getLabelForValue(P.y), Z = P._custom;
    return {
      label: y[a] || "",
      value: "(" + i + ", " + O + (Z ? ", " + Z : "") + ")"
    };
  }
  update(a) {
    const f = this._cachedMeta.data;
    this.updateElements(f, 0, f.length, a);
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", { iScale: P, vScale: i } = this._cachedMeta, { sharedOptions: O, includeOptions: Z } = this._getSharedOptions(f, w), Y = P.axis, J = i.axis;
    for (let ae = f; ae < f + y; ae++) {
      const ue = a[ae], Se = !b && this.getParsed(ae), we = {}, qe = we[Y] = b ? P.getPixelForDecimal(0.5) : P.getPixelForValue(Se[Y]), Ge = we[J] = b ? i.getBasePixel() : i.getPixelForValue(Se[J]);
      we.skip = isNaN(qe) || isNaN(Ge), Z && (we.options = O || this.resolveDataElementOptions(ae, ue.active ? "active" : w), b && (we.options.radius = 0)), this.updateElement(ue, ae, we, w);
    }
  }
  resolveDataElementOptions(a, f) {
    const y = this.getParsed(a);
    let w = super.resolveDataElementOptions(a, f);
    w.$shared && (w = Object.assign({}, w, {
      $shared: !1
    }));
    const b = w.radius;
    return f !== "active" && (w.radius = 0), w.radius += en(y && y._custom, b), w;
  }
}
Yt(Tm, "id", "bubble"), Yt(Tm, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
}), Yt(Tm, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function pE(_, a, f) {
  let y = 1, w = 1, b = 0, P = 0;
  if (a < us) {
    const i = _, O = i + a, Z = Math.cos(i), Y = Math.sin(i), J = Math.cos(O), ae = Math.sin(O), ue = (Et, ut, bt) => Df(Et, i, O, !0) ? 1 : Math.max(ut, ut * f, bt, bt * f), Se = (Et, ut, bt) => Df(Et, i, O, !0) ? -1 : Math.min(ut, ut * f, bt, bt * f), we = ue(0, Z, J), qe = ue(Ns, Y, ae), Ge = Se(ds, Z, J), lt = Se(ds + Ns, Y, ae);
    y = (we - Ge) / 2, w = (qe - lt) / 2, b = -(we + Ge) / 2, P = -(qe + lt) / 2;
  }
  return {
    ratioX: y,
    ratioY: w,
    offsetX: b,
    offsetY: P
  };
}
class Lh extends Ia {
  constructor(a, f) {
    super(a, f), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(a, f) {
    const y = this.getDataset().data, w = this._cachedMeta;
    if (this._parsing === !1)
      w._parsed = y;
    else {
      let b = (O) => +y[O];
      if (yn(y[a])) {
        const { key: O = "value" } = this._parsing;
        b = (Z) => +zc(y[Z], O);
      }
      let P, i;
      for (P = a, i = a + f; P < i; ++P)
        w._parsed[P] = b(P);
    }
  }
  _getRotation() {
    return Ca(this.options.rotation - 90);
  }
  _getCircumference() {
    return Ca(this.options.circumference);
  }
  _getRotationExtents() {
    let a = us, f = -us;
    for (let y = 0; y < this.chart.data.datasets.length; ++y)
      if (this.chart.isDatasetVisible(y) && this.chart.getDatasetMeta(y).type === this._type) {
        const w = this.chart.getDatasetMeta(y).controller, b = w._getRotation(), P = w._getCircumference();
        a = Math.min(a, b), f = Math.max(f, b + P);
      }
    return {
      rotation: a,
      circumference: f - a
    };
  }
  update(a) {
    const f = this.chart, { chartArea: y } = f, w = this._cachedMeta, b = w.data, P = this.getMaxBorderWidth() + this.getMaxOffset(b) + this.options.spacing, i = Math.max((Math.min(y.width, y.height) - P) / 2, 0), O = Math.min(PS(this.options.cutout, i), 1), Z = this._getRingWeight(this.index), { circumference: Y, rotation: J } = this._getRotationExtents(), { ratioX: ae, ratioY: ue, offsetX: Se, offsetY: we } = pE(J, Y, O), qe = (y.width - P) / ae, Ge = (y.height - P) / ue, lt = Math.max(Math.min(qe, Ge) / 2, 0), Et = fb(this.options.radius, lt), ut = Math.max(Et * O, 0), bt = (Et - ut) / this._getVisibleDatasetWeightTotal();
    this.offsetX = Se * Et, this.offsetY = we * Et, w.total = this.calculateTotal(), this.outerRadius = Et - bt * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - bt * Z, 0), this.updateElements(b, 0, b.length, a);
  }
  _circumference(a, f) {
    const y = this.options, w = this._cachedMeta, b = this._getCircumference();
    return f && y.animation.animateRotate || !this.chart.getDataVisibility(a) || w._parsed[a] === null || w.data[a].hidden ? 0 : this.calculateCircumference(w._parsed[a] * b / us);
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", P = this.chart, i = P.chartArea, Z = P.options.animation, Y = (i.left + i.right) / 2, J = (i.top + i.bottom) / 2, ae = b && Z.animateScale, ue = ae ? 0 : this.innerRadius, Se = ae ? 0 : this.outerRadius, { sharedOptions: we, includeOptions: qe } = this._getSharedOptions(f, w);
    let Ge = this._getRotation(), lt;
    for (lt = 0; lt < f; ++lt)
      Ge += this._circumference(lt, b);
    for (lt = f; lt < f + y; ++lt) {
      const Et = this._circumference(lt, b), ut = a[lt], bt = {
        x: Y + this.offsetX,
        y: J + this.offsetY,
        startAngle: Ge,
        endAngle: Ge + Et,
        circumference: Et,
        outerRadius: Se,
        innerRadius: ue
      };
      qe && (bt.options = we || this.resolveDataElementOptions(lt, ut.active ? "active" : w)), Ge += Et, this.updateElement(ut, lt, bt, w);
    }
  }
  calculateTotal() {
    const a = this._cachedMeta, f = a.data;
    let y = 0, w;
    for (w = 0; w < f.length; w++) {
      const b = a._parsed[w];
      b !== null && !isNaN(b) && this.chart.getDataVisibility(w) && !f[w].hidden && (y += Math.abs(b));
    }
    return y;
  }
  calculateCircumference(a) {
    const f = this._cachedMeta.total;
    return f > 0 && !isNaN(a) ? us * (Math.abs(a) / f) : 0;
  }
  getLabelAndValue(a) {
    const f = this._cachedMeta, y = this.chart, w = y.data.labels || [], b = Nf(f._parsed[a], y.options.locale);
    return {
      label: w[a] || "",
      value: b
    };
  }
  getMaxBorderWidth(a) {
    let f = 0;
    const y = this.chart;
    let w, b, P, i, O;
    if (!a) {
      for (w = 0, b = y.data.datasets.length; w < b; ++w)
        if (y.isDatasetVisible(w)) {
          P = y.getDatasetMeta(w), a = P.data, i = P.controller;
          break;
        }
    }
    if (!a)
      return 0;
    for (w = 0, b = a.length; w < b; ++w)
      O = i.resolveDataElementOptions(w), O.borderAlign !== "inner" && (f = Math.max(f, O.borderWidth || 0, O.hoverBorderWidth || 0));
    return f;
  }
  getMaxOffset(a) {
    let f = 0;
    for (let y = 0, w = a.length; y < w; ++y) {
      const b = this.resolveDataElementOptions(y);
      f = Math.max(f, b.offset || 0, b.hoverOffset || 0);
    }
    return f;
  }
  _getRingWeightOffset(a) {
    let f = 0;
    for (let y = 0; y < a; ++y)
      this.chart.isDatasetVisible(y) && (f += this._getRingWeight(y));
    return f;
  }
  _getRingWeight(a) {
    return Math.max(en(this.chart.data.datasets[a].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
Yt(Lh, "id", "doughnut"), Yt(Lh, "defaults", {
  datasetElementType: !1,
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !1
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
}), Yt(Lh, "descriptors", {
  _scriptable: (a) => a !== "spacing",
  _indexable: (a) => a !== "spacing" && !a.startsWith("borderDash") && !a.startsWith("hoverBorderDash")
}), Yt(Lh, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(a) {
          const f = a.data;
          if (f.labels.length && f.datasets.length) {
            const { labels: { pointStyle: y, color: w } } = a.legend.options;
            return f.labels.map((b, P) => {
              const O = a.getDatasetMeta(0).controller.getStyle(P);
              return {
                text: b,
                fillStyle: O.backgroundColor,
                strokeStyle: O.borderColor,
                fontColor: w,
                lineWidth: O.borderWidth,
                pointStyle: y,
                hidden: !a.getDataVisibility(P),
                index: P
              };
            });
          }
          return [];
        }
      },
      onClick(a, f, y) {
        y.chart.toggleDataVisibility(f.index), y.chart.update();
      }
    }
  }
});
class Sm extends Ia {
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(a) {
    const f = this._cachedMeta, { dataset: y, data: w = [], _dataset: b } = f, P = this.chart._animationsDisabled;
    let { start: i, count: O } = bb(f, w, P);
    this._drawStart = i, this._drawCount = O, wb(f) && (i = 0, O = w.length), y._chart = this.chart, y._datasetIndex = this.index, y._decimated = !!b._decimated, y.points = w;
    const Z = this.resolveDatasetElementOptions(a);
    this.options.showLine || (Z.borderWidth = 0), Z.segment = this.options.segment, this.updateElement(y, void 0, {
      animated: !P,
      options: Z
    }, a), this.updateElements(w, i, O, a);
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", { iScale: P, vScale: i, _stacked: O, _dataset: Z } = this._cachedMeta, { sharedOptions: Y, includeOptions: J } = this._getSharedOptions(f, w), ae = P.axis, ue = i.axis, { spanGaps: Se, segment: we } = this.options, qe = Wu(Se) ? Se : Number.POSITIVE_INFINITY, Ge = this.chart._animationsDisabled || b || w === "none", lt = f + y, Et = a.length;
    let ut = f > 0 && this.getParsed(f - 1);
    for (let bt = 0; bt < Et; ++bt) {
      const Vt = a[bt], pt = Ge ? Vt : {};
      if (bt < f || bt >= lt) {
        pt.skip = !0;
        continue;
      }
      const Gt = this.getParsed(bt), ui = En(Gt[ue]), kt = pt[ae] = P.getPixelForValue(Gt[ae], bt), At = pt[ue] = b || ui ? i.getBasePixel() : i.getPixelForValue(O ? this.applyStack(i, Gt, O) : Gt[ue], bt);
      pt.skip = isNaN(kt) || isNaN(At) || ui, pt.stop = bt > 0 && Math.abs(Gt[ae] - ut[ae]) > qe, we && (pt.parsed = Gt, pt.raw = Z.data[bt]), J && (pt.options = Y || this.resolveDataElementOptions(bt, Vt.active ? "active" : w)), Ge || this.updateElement(Vt, bt, pt, w), ut = Gt;
    }
  }
  getMaxOverflow() {
    const a = this._cachedMeta, f = a.dataset, y = f.options && f.options.borderWidth || 0, w = a.data || [];
    if (!w.length)
      return y;
    const b = w[0].size(this.resolveDataElementOptions(0)), P = w[w.length - 1].size(this.resolveDataElementOptions(w.length - 1));
    return Math.max(y, b, P) / 2;
  }
  draw() {
    const a = this._cachedMeta;
    a.dataset.updateControlPoints(this.chart.chartArea, a.iScale.axis), super.draw();
  }
}
Yt(Sm, "id", "line"), Yt(Sm, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: !0,
  spanGaps: !1
}), Yt(Sm, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class Cf extends Ia {
  constructor(a, f) {
    super(a, f), this.innerRadius = void 0, this.outerRadius = void 0;
  }
  getLabelAndValue(a) {
    const f = this._cachedMeta, y = this.chart, w = y.data.labels || [], b = Nf(f._parsed[a].r, y.options.locale);
    return {
      label: w[a] || "",
      value: b
    };
  }
  parseObjectData(a, f, y, w) {
    return Ib.bind(this)(a, f, y, w);
  }
  update(a) {
    const f = this._cachedMeta.data;
    this._updateRadius(), this.updateElements(f, 0, f.length, a);
  }
  getMinMax() {
    const a = this._cachedMeta, f = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    return a.data.forEach((y, w) => {
      const b = this.getParsed(w).r;
      !isNaN(b) && this.chart.getDataVisibility(w) && (b < f.min && (f.min = b), b > f.max && (f.max = b));
    }), f;
  }
  _updateRadius() {
    const a = this.chart, f = a.chartArea, y = a.options, w = Math.min(f.right - f.left, f.bottom - f.top), b = Math.max(w / 2, 0), P = Math.max(y.cutoutPercentage ? b / 100 * y.cutoutPercentage : 1, 0), i = (b - P) / a.getVisibleDatasetCount();
    this.outerRadius = b - i * this.index, this.innerRadius = this.outerRadius - i;
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", P = this.chart, O = P.options.animation, Z = this._cachedMeta.rScale, Y = Z.xCenter, J = Z.yCenter, ae = Z.getIndexAngle(0) - 0.5 * ds;
    let ue = ae, Se;
    const we = 360 / this.countVisibleElements();
    for (Se = 0; Se < f; ++Se)
      ue += this._computeAngle(Se, w, we);
    for (Se = f; Se < f + y; Se++) {
      const qe = a[Se];
      let Ge = ue, lt = ue + this._computeAngle(Se, w, we), Et = P.getDataVisibility(Se) ? Z.getDistanceFromCenterForValue(this.getParsed(Se).r) : 0;
      ue = lt, b && (O.animateScale && (Et = 0), O.animateRotate && (Ge = lt = ae));
      const ut = {
        x: Y,
        y: J,
        innerRadius: 0,
        outerRadius: Et,
        startAngle: Ge,
        endAngle: lt,
        options: this.resolveDataElementOptions(Se, qe.active ? "active" : w)
      };
      this.updateElement(qe, Se, ut, w);
    }
  }
  countVisibleElements() {
    const a = this._cachedMeta;
    let f = 0;
    return a.data.forEach((y, w) => {
      !isNaN(this.getParsed(w).r) && this.chart.getDataVisibility(w) && f++;
    }), f;
  }
  _computeAngle(a, f, y) {
    return this.chart.getDataVisibility(a) ? Ca(this.resolveDataElementOptions(a, f).angle || y) : 0;
  }
}
Yt(Cf, "id", "polarArea"), Yt(Cf, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: !0,
    animateScale: !0
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
}), Yt(Cf, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(a) {
          const f = a.data;
          if (f.labels.length && f.datasets.length) {
            const { labels: { pointStyle: y, color: w } } = a.legend.options;
            return f.labels.map((b, P) => {
              const O = a.getDatasetMeta(0).controller.getStyle(P);
              return {
                text: b,
                fillStyle: O.backgroundColor,
                strokeStyle: O.borderColor,
                fontColor: w,
                lineWidth: O.borderWidth,
                pointStyle: y,
                hidden: !a.getDataVisibility(P),
                index: P
              };
            });
          }
          return [];
        }
      },
      onClick(a, f, y) {
        y.chart.toggleDataVisibility(f.index), y.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: !1
      },
      beginAtZero: !0,
      grid: {
        circular: !0
      },
      pointLabels: {
        display: !1
      },
      startAngle: 0
    }
  }
});
class Ug extends Lh {
}
Yt(Ug, "id", "pie"), Yt(Ug, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class Mm extends Ia {
  getLabelAndValue(a) {
    const f = this._cachedMeta.vScale, y = this.getParsed(a);
    return {
      label: f.getLabels()[a],
      value: "" + f.getLabelForValue(y[f.axis])
    };
  }
  parseObjectData(a, f, y, w) {
    return Ib.bind(this)(a, f, y, w);
  }
  update(a) {
    const f = this._cachedMeta, y = f.dataset, w = f.data || [], b = f.iScale.getLabels();
    if (y.points = w, a !== "resize") {
      const P = this.resolveDatasetElementOptions(a);
      this.options.showLine || (P.borderWidth = 0);
      const i = {
        _loop: !0,
        _fullLoop: b.length === w.length,
        options: P
      };
      this.updateElement(y, void 0, i, a);
    }
    this.updateElements(w, 0, w.length, a);
  }
  updateElements(a, f, y, w) {
    const b = this._cachedMeta.rScale, P = w === "reset";
    for (let i = f; i < f + y; i++) {
      const O = a[i], Z = this.resolveDataElementOptions(i, O.active ? "active" : w), Y = b.getPointPositionForValue(i, this.getParsed(i).r), J = P ? b.xCenter : Y.x, ae = P ? b.yCenter : Y.y, ue = {
        x: J,
        y: ae,
        angle: Y.angle,
        skip: isNaN(J) || isNaN(ae),
        options: Z
      };
      this.updateElement(O, i, ue, w);
    }
  }
}
Yt(Mm, "id", "radar"), Yt(Mm, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: !0,
  elements: {
    line: {
      fill: "start"
    }
  }
}), Yt(Mm, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class Em extends Ia {
  getLabelAndValue(a) {
    const f = this._cachedMeta, y = this.chart.data.labels || [], { xScale: w, yScale: b } = f, P = this.getParsed(a), i = w.getLabelForValue(P.x), O = b.getLabelForValue(P.y);
    return {
      label: y[a] || "",
      value: "(" + i + ", " + O + ")"
    };
  }
  update(a) {
    const f = this._cachedMeta, { data: y = [] } = f, w = this.chart._animationsDisabled;
    let { start: b, count: P } = bb(f, y, w);
    if (this._drawStart = b, this._drawCount = P, wb(f) && (b = 0, P = y.length), this.options.showLine) {
      this.datasetElementType || this.addElements();
      const { dataset: i, _dataset: O } = f;
      i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!O._decimated, i.points = y;
      const Z = this.resolveDatasetElementOptions(a);
      Z.segment = this.options.segment, this.updateElement(i, void 0, {
        animated: !w,
        options: Z
      }, a);
    } else
      this.datasetElementType && (delete f.dataset, this.datasetElementType = !1);
    this.updateElements(y, b, P, a);
  }
  addElements() {
    const { showLine: a } = this.options;
    !this.datasetElementType && a && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements();
  }
  updateElements(a, f, y, w) {
    const b = w === "reset", { iScale: P, vScale: i, _stacked: O, _dataset: Z } = this._cachedMeta, Y = this.resolveDataElementOptions(f, w), J = this.getSharedOptions(Y), ae = this.includeOptions(w, J), ue = P.axis, Se = i.axis, { spanGaps: we, segment: qe } = this.options, Ge = Wu(we) ? we : Number.POSITIVE_INFINITY, lt = this.chart._animationsDisabled || b || w === "none";
    let Et = f > 0 && this.getParsed(f - 1);
    for (let ut = f; ut < f + y; ++ut) {
      const bt = a[ut], Vt = this.getParsed(ut), pt = lt ? bt : {}, Gt = En(Vt[Se]), ui = pt[ue] = P.getPixelForValue(Vt[ue], ut), kt = pt[Se] = b || Gt ? i.getBasePixel() : i.getPixelForValue(O ? this.applyStack(i, Vt, O) : Vt[Se], ut);
      pt.skip = isNaN(ui) || isNaN(kt) || Gt, pt.stop = ut > 0 && Math.abs(Vt[ue] - Et[ue]) > Ge, qe && (pt.parsed = Vt, pt.raw = Z.data[ut]), ae && (pt.options = J || this.resolveDataElementOptions(ut, bt.active ? "active" : w)), lt || this.updateElement(bt, ut, pt, w), Et = Vt;
    }
    this.updateSharedOptions(J, w, Y);
  }
  getMaxOverflow() {
    const a = this._cachedMeta, f = a.data || [];
    if (!this.options.showLine) {
      let i = 0;
      for (let O = f.length - 1; O >= 0; --O)
        i = Math.max(i, f[O].size(this.resolveDataElementOptions(O)) / 2);
      return i > 0 && i;
    }
    const y = a.dataset, w = y.options && y.options.borderWidth || 0;
    if (!f.length)
      return w;
    const b = f[0].size(this.resolveDataElementOptions(0)), P = f[f.length - 1].size(this.resolveDataElementOptions(f.length - 1));
    return Math.max(w, b, P) / 2;
  }
}
Yt(Em, "id", "scatter"), Yt(Em, "defaults", {
  datasetElementType: !1,
  dataElementType: "point",
  showLine: !1,
  fill: !1
}), Yt(Em, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var mE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController: wm,
  BubbleController: Tm,
  DoughnutController: Lh,
  LineController: Sm,
  PieController: Ug,
  PolarAreaController: Cf,
  RadarController: Mm,
  ScatterController: Em
});
function Eh() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class fy {
  constructor(a) {
    Yt(this, "options");
    this.options = a || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(a) {
    Object.assign(fy.prototype, a);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Eh();
  }
  parse() {
    return Eh();
  }
  format() {
    return Eh();
  }
  add() {
    return Eh();
  }
  diff() {
    return Eh();
  }
  startOf() {
    return Eh();
  }
  endOf() {
    return Eh();
  }
}
var _E = {
  _date: fy
};
function gE(_, a, f, y) {
  const { controller: w, data: b, _sorted: P } = _, i = w._cachedMeta.iScale;
  if (i && a === i.axis && a !== "r" && P && b.length) {
    const O = i._reversePixels ? VS : Bl;
    if (y) {
      if (w._sharedOptions) {
        const Z = b[0], Y = typeof Z.getRange == "function" && Z.getRange(a);
        if (Y) {
          const J = O(b, a, f - Y), ae = O(b, a, f + Y);
          return {
            lo: J.lo,
            hi: ae.hi
          };
        }
      }
    } else
      return O(b, a, f);
  }
  return {
    lo: 0,
    hi: b.length - 1
  };
}
function Vf(_, a, f, y, w) {
  const b = _.getSortedVisibleDatasetMetas(), P = f[a];
  for (let i = 0, O = b.length; i < O; ++i) {
    const { index: Z, data: Y } = b[i], { lo: J, hi: ae } = gE(b[i], a, P, w);
    for (let ue = J; ue <= ae; ++ue) {
      const Se = Y[ue];
      Se.skip || y(Se, Z, ue);
    }
  }
}
function yE(_) {
  const a = _.indexOf("x") !== -1, f = _.indexOf("y") !== -1;
  return function(y, w) {
    const b = a ? Math.abs(y.x - w.x) : 0, P = f ? Math.abs(y.y - w.y) : 0;
    return Math.sqrt(Math.pow(b, 2) + Math.pow(P, 2));
  };
}
function Lg(_, a, f, y, w) {
  const b = [];
  return !w && !_.isPointInArea(a) || Vf(_, f, a, function(i, O, Z) {
    !w && !Nl(i, _.chartArea, 0) || i.inRange(a.x, a.y, y) && b.push({
      element: i,
      datasetIndex: O,
      index: Z
    });
  }, !0), b;
}
function xE(_, a, f, y) {
  let w = [];
  function b(P, i, O) {
    const { startAngle: Z, endAngle: Y } = P.getProps([
      "startAngle",
      "endAngle"
    ], y), { angle: J } = _b(P, {
      x: a.x,
      y: a.y
    });
    Df(J, Z, Y) && w.push({
      element: P,
      datasetIndex: i,
      index: O
    });
  }
  return Vf(_, f, a, b), w;
}
function vE(_, a, f, y, w, b) {
  let P = [];
  const i = yE(f);
  let O = Number.POSITIVE_INFINITY;
  function Z(Y, J, ae) {
    const ue = Y.inRange(a.x, a.y, w);
    if (y && !ue)
      return;
    const Se = Y.getCenterPoint(w);
    if (!(!!b || _.isPointInArea(Se)) && !ue)
      return;
    const qe = i(a, Se);
    qe < O ? (P = [
      {
        element: Y,
        datasetIndex: J,
        index: ae
      }
    ], O = qe) : qe === O && P.push({
      element: Y,
      datasetIndex: J,
      index: ae
    });
  }
  return Vf(_, f, a, Z), P;
}
function zg(_, a, f, y, w, b) {
  return !b && !_.isPointInArea(a) ? [] : f === "r" && !y ? xE(_, a, f, w) : vE(_, a, f, y, w, b);
}
function g1(_, a, f, y, w) {
  const b = [], P = f === "x" ? "inXRange" : "inYRange";
  let i = !1;
  return Vf(_, f, a, (O, Z, Y) => {
    O[P] && O[P](a[f], w) && (b.push({
      element: O,
      datasetIndex: Z,
      index: Y
    }), i = i || O.inRange(a.x, a.y, w));
  }), y && !i ? [] : b;
}
var bE = {
  evaluateInteractionItems: Vf,
  modes: {
    index(_, a, f, y) {
      const w = Ch(a, _), b = f.axis || "x", P = f.includeInvisible || !1, i = f.intersect ? Lg(_, w, b, y, P) : zg(_, w, b, !1, y, P), O = [];
      return i.length ? (_.getSortedVisibleDatasetMetas().forEach((Z) => {
        const Y = i[0].index, J = Z.data[Y];
        J && !J.skip && O.push({
          element: J,
          datasetIndex: Z.index,
          index: Y
        });
      }), O) : [];
    },
    dataset(_, a, f, y) {
      const w = Ch(a, _), b = f.axis || "xy", P = f.includeInvisible || !1;
      let i = f.intersect ? Lg(_, w, b, y, P) : zg(_, w, b, !1, y, P);
      if (i.length > 0) {
        const O = i[0].datasetIndex, Z = _.getDatasetMeta(O).data;
        i = [];
        for (let Y = 0; Y < Z.length; ++Y)
          i.push({
            element: Z[Y],
            datasetIndex: O,
            index: Y
          });
      }
      return i;
    },
    point(_, a, f, y) {
      const w = Ch(a, _), b = f.axis || "xy", P = f.includeInvisible || !1;
      return Lg(_, w, b, y, P);
    },
    nearest(_, a, f, y) {
      const w = Ch(a, _), b = f.axis || "xy", P = f.includeInvisible || !1;
      return zg(_, w, b, f.intersect, y, P);
    },
    x(_, a, f, y) {
      const w = Ch(a, _);
      return g1(_, w, "x", f.intersect, y);
    },
    y(_, a, f, y) {
      const w = Ch(a, _);
      return g1(_, w, "y", f.intersect, y);
    }
  }
};
const Vb = [
  "left",
  "top",
  "right",
  "bottom"
];
function mf(_, a) {
  return _.filter((f) => f.pos === a);
}
function y1(_, a) {
  return _.filter((f) => Vb.indexOf(f.pos) === -1 && f.box.axis === a);
}
function _f(_, a) {
  return _.sort((f, y) => {
    const w = a ? y : f, b = a ? f : y;
    return w.weight === b.weight ? w.index - b.index : w.weight - b.weight;
  });
}
function wE(_) {
  const a = [];
  let f, y, w, b, P, i;
  for (f = 0, y = (_ || []).length; f < y; ++f)
    w = _[f], { position: b, options: { stack: P, stackWeight: i = 1 } } = w, a.push({
      index: f,
      box: w,
      pos: b,
      horizontal: w.isHorizontal(),
      weight: w.weight,
      stack: P && b + P,
      stackWeight: i
    });
  return a;
}
function TE(_) {
  const a = {};
  for (const f of _) {
    const { stack: y, pos: w, stackWeight: b } = f;
    if (!y || !Vb.includes(w))
      continue;
    const P = a[y] || (a[y] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    P.count++, P.weight += b;
  }
  return a;
}
function SE(_, a) {
  const f = TE(_), { vBoxMaxWidth: y, hBoxMaxHeight: w } = a;
  let b, P, i;
  for (b = 0, P = _.length; b < P; ++b) {
    i = _[b];
    const { fullSize: O } = i.box, Z = f[i.stack], Y = Z && i.stackWeight / Z.weight;
    i.horizontal ? (i.width = Y ? Y * y : O && a.availableWidth, i.height = w) : (i.width = y, i.height = Y ? Y * w : O && a.availableHeight);
  }
  return f;
}
function ME(_) {
  const a = wE(_), f = _f(a.filter((Z) => Z.box.fullSize), !0), y = _f(mf(a, "left"), !0), w = _f(mf(a, "right")), b = _f(mf(a, "top"), !0), P = _f(mf(a, "bottom")), i = y1(a, "x"), O = y1(a, "y");
  return {
    fullSize: f,
    leftAndTop: y.concat(b),
    rightAndBottom: w.concat(O).concat(P).concat(i),
    chartArea: mf(a, "chartArea"),
    vertical: y.concat(w).concat(O),
    horizontal: b.concat(P).concat(i)
  };
}
function x1(_, a, f, y) {
  return Math.max(_[f], a[f]) + Math.max(_[y], a[y]);
}
function Ub(_, a) {
  _.top = Math.max(_.top, a.top), _.left = Math.max(_.left, a.left), _.bottom = Math.max(_.bottom, a.bottom), _.right = Math.max(_.right, a.right);
}
function EE(_, a, f, y) {
  const { pos: w, box: b } = f, P = _.maxPadding;
  if (!yn(w)) {
    f.size && (_[w] -= f.size);
    const J = y[f.stack] || {
      size: 0,
      count: 1
    };
    J.size = Math.max(J.size, f.horizontal ? b.height : b.width), f.size = J.size / J.count, _[w] += f.size;
  }
  b.getPadding && Ub(P, b.getPadding());
  const i = Math.max(0, a.outerWidth - x1(P, _, "left", "right")), O = Math.max(0, a.outerHeight - x1(P, _, "top", "bottom")), Z = i !== _.w, Y = O !== _.h;
  return _.w = i, _.h = O, f.horizontal ? {
    same: Z,
    other: Y
  } : {
    same: Y,
    other: Z
  };
}
function AE(_) {
  const a = _.maxPadding;
  function f(y) {
    const w = Math.max(a[y] - _[y], 0);
    return _[y] += w, w;
  }
  _.y += f("top"), _.x += f("left"), f("right"), f("bottom");
}
function PE(_, a) {
  const f = a.maxPadding;
  function y(w) {
    const b = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return w.forEach((P) => {
      b[P] = Math.max(a[P], f[P]);
    }), b;
  }
  return y(_ ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function bf(_, a, f, y) {
  const w = [];
  let b, P, i, O, Z, Y;
  for (b = 0, P = _.length, Z = 0; b < P; ++b) {
    i = _[b], O = i.box, O.update(i.width || a.w, i.height || a.h, PE(i.horizontal, a));
    const { same: J, other: ae } = EE(a, f, i, y);
    Z |= J && w.length, Y = Y || ae, O.fullSize || w.push(i);
  }
  return Z && bf(w, a, f, y) || Y;
}
function dm(_, a, f, y, w) {
  _.top = f, _.left = a, _.right = a + y, _.bottom = f + w, _.width = y, _.height = w;
}
function v1(_, a, f, y) {
  const w = f.padding;
  let { x: b, y: P } = a;
  for (const i of _) {
    const O = i.box, Z = y[i.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    }, Y = i.stackWeight / Z.weight || 1;
    if (i.horizontal) {
      const J = a.w * Y, ae = Z.size || O.height;
      zf(Z.start) && (P = Z.start), O.fullSize ? dm(O, w.left, P, f.outerWidth - w.right - w.left, ae) : dm(O, a.left + Z.placed, P, J, ae), Z.start = P, Z.placed += J, P = O.bottom;
    } else {
      const J = a.h * Y, ae = Z.size || O.width;
      zf(Z.start) && (b = Z.start), O.fullSize ? dm(O, b, w.top, ae, f.outerHeight - w.bottom - w.top) : dm(O, b, a.top + Z.placed, ae, J), Z.start = b, Z.placed += J, b = O.right;
    }
  }
  a.x = b, a.y = P;
}
var jr = {
  addBox(_, a) {
    _.boxes || (_.boxes = []), a.fullSize = a.fullSize || !1, a.position = a.position || "top", a.weight = a.weight || 0, a._layers = a._layers || function() {
      return [
        {
          z: 0,
          draw(f) {
            a.draw(f);
          }
        }
      ];
    }, _.boxes.push(a);
  },
  removeBox(_, a) {
    const f = _.boxes ? _.boxes.indexOf(a) : -1;
    f !== -1 && _.boxes.splice(f, 1);
  },
  configure(_, a, f) {
    a.fullSize = f.fullSize, a.position = f.position, a.weight = f.weight;
  },
  update(_, a, f, y) {
    if (!_)
      return;
    const w = Gr(_.options.layout.padding), b = Math.max(a - w.width, 0), P = Math.max(f - w.height, 0), i = ME(_.boxes), O = i.vertical, Z = i.horizontal;
    Zn(_.boxes, (we) => {
      typeof we.beforeLayout == "function" && we.beforeLayout();
    });
    const Y = O.reduce((we, qe) => qe.box.options && qe.box.options.display === !1 ? we : we + 1, 0) || 1, J = Object.freeze({
      outerWidth: a,
      outerHeight: f,
      padding: w,
      availableWidth: b,
      availableHeight: P,
      vBoxMaxWidth: b / 2 / Y,
      hBoxMaxHeight: P / 2
    }), ae = Object.assign({}, w);
    Ub(ae, Gr(y));
    const ue = Object.assign({
      maxPadding: ae,
      w: b,
      h: P,
      x: w.left,
      y: w.top
    }, w), Se = SE(O.concat(Z), J);
    bf(i.fullSize, ue, J, Se), bf(O, ue, J, Se), bf(Z, ue, J, Se) && bf(O, ue, J, Se), AE(ue), v1(i.leftAndTop, ue, J, Se), ue.x += ue.w, ue.y += ue.h, v1(i.rightAndBottom, ue, J, Se), _.chartArea = {
      left: ue.left,
      top: ue.top,
      right: ue.left + ue.w,
      bottom: ue.top + ue.h,
      height: ue.h,
      width: ue.w
    }, Zn(i.chartArea, (we) => {
      const qe = we.box;
      Object.assign(qe, _.chartArea), qe.update(ue.w, ue.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class jb {
  acquireContext(a, f) {
  }
  releaseContext(a) {
    return !1;
  }
  addEventListener(a, f, y) {
  }
  removeEventListener(a, f, y) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(a, f, y, w) {
    return f = Math.max(0, f || a.width), y = y || a.height, {
      width: f,
      height: Math.max(0, w ? Math.floor(f / w) : y)
    };
  }
  isAttached(a) {
    return !0;
  }
  updateConfig(a) {
  }
}
class CE extends jb {
  acquireContext(a) {
    return a && a.getContext && a.getContext("2d") || null;
  }
  updateConfig(a) {
    a.options.animation = !1;
  }
}
const Am = "$chartjs", IE = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, b1 = (_) => _ === null || _ === "";
function LE(_, a) {
  const f = _.style, y = _.getAttribute("height"), w = _.getAttribute("width");
  if (_[Am] = {
    initial: {
      height: y,
      width: w,
      style: {
        display: f.display,
        height: f.height,
        width: f.width
      }
    }
  }, f.display = f.display || "block", f.boxSizing = f.boxSizing || "border-box", b1(w)) {
    const b = s1(_, "width");
    b !== void 0 && (_.width = b);
  }
  if (b1(y))
    if (_.style.height === "")
      _.height = _.width / (a || 2);
    else {
      const b = s1(_, "height");
      b !== void 0 && (_.height = b);
    }
  return _;
}
const Gb = DM ? {
  passive: !0
} : !1;
function zE(_, a, f) {
  _ && _.addEventListener(a, f, Gb);
}
function DE(_, a, f) {
  _ && _.canvas && _.canvas.removeEventListener(a, f, Gb);
}
function kE(_, a) {
  const f = IE[_.type] || _.type, { x: y, y: w } = Ch(_, a);
  return {
    type: f,
    chart: a,
    native: _,
    x: y !== void 0 ? y : null,
    y: w !== void 0 ? w : null
  };
}
function Om(_, a) {
  for (const f of _)
    if (f === a || f.contains(a))
      return !0;
}
function RE(_, a, f) {
  const y = _.canvas, w = new MutationObserver((b) => {
    let P = !1;
    for (const i of b)
      P = P || Om(i.addedNodes, y), P = P && !Om(i.removedNodes, y);
    P && f();
  });
  return w.observe(document, {
    childList: !0,
    subtree: !0
  }), w;
}
function OE(_, a, f) {
  const y = _.canvas, w = new MutationObserver((b) => {
    let P = !1;
    for (const i of b)
      P = P || Om(i.removedNodes, y), P = P && !Om(i.addedNodes, y);
    P && f();
  });
  return w.observe(document, {
    childList: !0,
    subtree: !0
  }), w;
}
const Rf = /* @__PURE__ */ new Map();
let w1 = 0;
function Zb() {
  const _ = window.devicePixelRatio;
  _ !== w1 && (w1 = _, Rf.forEach((a, f) => {
    f.currentDevicePixelRatio !== _ && a();
  }));
}
function FE(_, a) {
  Rf.size || window.addEventListener("resize", Zb), Rf.set(_, a);
}
function BE(_) {
  Rf.delete(_), Rf.size || window.removeEventListener("resize", Zb);
}
function NE(_, a, f) {
  const y = _.canvas, w = y && dy(y);
  if (!w)
    return;
  const b = vb((i, O) => {
    const Z = w.clientWidth;
    f(i, O), Z < w.clientWidth && f();
  }, window), P = new ResizeObserver((i) => {
    const O = i[0], Z = O.contentRect.width, Y = O.contentRect.height;
    Z === 0 && Y === 0 || b(Z, Y);
  });
  return P.observe(w), FE(_, b), P;
}
function Dg(_, a, f) {
  f && f.disconnect(), a === "resize" && BE(_);
}
function VE(_, a, f) {
  const y = _.canvas, w = vb((b) => {
    _.ctx !== null && f(kE(b, _));
  }, _);
  return zE(y, a, w), w;
}
class UE extends jb {
  acquireContext(a, f) {
    const y = a && a.getContext && a.getContext("2d");
    return y && y.canvas === a ? (LE(a, f), y) : null;
  }
  releaseContext(a) {
    const f = a.canvas;
    if (!f[Am])
      return !1;
    const y = f[Am].initial;
    [
      "height",
      "width"
    ].forEach((b) => {
      const P = y[b];
      En(P) ? f.removeAttribute(b) : f.setAttribute(b, P);
    });
    const w = y.style || {};
    return Object.keys(w).forEach((b) => {
      f.style[b] = w[b];
    }), f.width = f.width, delete f[Am], !0;
  }
  addEventListener(a, f, y) {
    this.removeEventListener(a, f);
    const w = a.$proxies || (a.$proxies = {}), P = {
      attach: RE,
      detach: OE,
      resize: NE
    }[f] || VE;
    w[f] = P(a, f, y);
  }
  removeEventListener(a, f) {
    const y = a.$proxies || (a.$proxies = {}), w = y[f];
    if (!w)
      return;
    ({
      attach: Dg,
      detach: Dg,
      resize: Dg
    }[f] || DE)(a, f, w), y[f] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(a, f, y, w) {
    return zM(a, f, y, w);
  }
  isAttached(a) {
    const f = a && dy(a);
    return !!(f && f.isConnected);
  }
}
function jE(_) {
  return !uy() || typeof OffscreenCanvas < "u" && _ instanceof OffscreenCanvas ? CE : UE;
}
var bm;
let Vl = (bm = class {
  constructor() {
    Yt(this, "x");
    Yt(this, "y");
    Yt(this, "active", !1);
    Yt(this, "options");
    Yt(this, "$animations");
  }
  tooltipPosition(a) {
    const { x: f, y } = this.getProps([
      "x",
      "y"
    ], a);
    return {
      x: f,
      y
    };
  }
  hasValue() {
    return Wu(this.x) && Wu(this.y);
  }
  getProps(a, f) {
    const y = this.$animations;
    if (!f || !y)
      return this;
    const w = {};
    return a.forEach((b) => {
      w[b] = y[b] && y[b].active() ? y[b]._to : this[b];
    }), w;
  }
}, Yt(bm, "defaults", {}), Yt(bm, "defaultRoutes"), bm);
function GE(_, a) {
  const f = _.options.ticks, y = ZE(_), w = Math.min(f.maxTicksLimit || y, y), b = f.major.enabled ? qE(a) : [], P = b.length, i = b[0], O = b[P - 1], Z = [];
  if (P > w)
    return WE(a, Z, b, P / w), Z;
  const Y = HE(b, a, w);
  if (P > 0) {
    let J, ae;
    const ue = P > 1 ? Math.round((O - i) / (P - 1)) : null;
    for (fm(a, Z, Y, En(ue) ? 0 : i - ue, i), J = 0, ae = P - 1; J < ae; J++)
      fm(a, Z, Y, b[J], b[J + 1]);
    return fm(a, Z, Y, O, En(ue) ? a.length : O + ue), Z;
  }
  return fm(a, Z, Y), Z;
}
function ZE(_) {
  const a = _.options.offset, f = _._tickSize(), y = _._length / f + (a ? 0 : 1), w = _._maxLength / f;
  return Math.floor(Math.min(y, w));
}
function HE(_, a, f) {
  const y = $E(_), w = a.length / f;
  if (!y)
    return Math.max(w, 1);
  const b = OS(y);
  for (let P = 0, i = b.length - 1; P < i; P++) {
    const O = b[P];
    if (O > w)
      return O;
  }
  return Math.max(w, 1);
}
function qE(_) {
  const a = [];
  let f, y;
  for (f = 0, y = _.length; f < y; f++)
    _[f].major && a.push(f);
  return a;
}
function WE(_, a, f, y) {
  let w = 0, b = f[0], P;
  for (y = Math.ceil(y), P = 0; P < _.length; P++)
    P === b && (a.push(_[P]), w++, b = f[w * y]);
}
function fm(_, a, f, y, w) {
  const b = en(y, 0), P = Math.min(en(w, _.length), _.length);
  let i = 0, O, Z, Y;
  for (f = Math.ceil(f), w && (O = w - y, f = O / Math.floor(O / f)), Y = b; Y < 0; )
    i++, Y = Math.round(b + i * f);
  for (Z = Math.max(b, 0); Z < P; Z++)
    Z === Y && (a.push(_[Z]), i++, Y = Math.round(b + i * f));
}
function $E(_) {
  const a = _.length;
  let f, y;
  if (a < 2)
    return !1;
  for (y = _[0], f = 1; f < a; ++f)
    if (_[f] - _[f - 1] !== y)
      return !1;
  return y;
}
const XE = (_) => _ === "left" ? "right" : _ === "right" ? "left" : _, T1 = (_, a, f) => a === "top" || a === "left" ? _[a] + f : _[a] - f, S1 = (_, a) => Math.min(a || _, _);
function M1(_, a) {
  const f = [], y = _.length / a, w = _.length;
  let b = 0;
  for (; b < w; b += y)
    f.push(_[Math.floor(b)]);
  return f;
}
function YE(_, a, f) {
  const y = _.ticks.length, w = Math.min(a, y - 1), b = _._startPixel, P = _._endPixel, i = 1e-6;
  let O = _.getPixelForTick(w), Z;
  if (!(f && (y === 1 ? Z = Math.max(O - b, P - O) : a === 0 ? Z = (_.getPixelForTick(1) - O) / 2 : Z = (O - _.getPixelForTick(w - 1)) / 2, O += w < a ? Z : -Z, O < b - i || O > P + i)))
    return O;
}
function KE(_, a) {
  Zn(_, (f) => {
    const y = f.gc, w = y.length / 2;
    let b;
    if (w > a) {
      for (b = 0; b < w; ++b)
        delete f.data[y[b]];
      y.splice(0, w);
    }
  });
}
function gf(_) {
  return _.drawTicks ? _.tickLength : 0;
}
function E1(_, a) {
  if (!_.display)
    return 0;
  const f = tr(_.font, a), y = Gr(_.padding);
  return (hs(_.text) ? _.text.length : 1) * f.lineHeight + y.height;
}
function JE(_, a) {
  return kc(_, {
    scale: a,
    type: "scale"
  });
}
function QE(_, a, f) {
  return kc(_, {
    tick: f,
    index: a,
    type: "tick"
  });
}
function eA(_, a, f) {
  let y = ry(_);
  return (f && a !== "right" || !f && a === "right") && (y = XE(y)), y;
}
function tA(_, a, f, y) {
  const { top: w, left: b, bottom: P, right: i, chart: O } = _, { chartArea: Z, scales: Y } = O;
  let J = 0, ae, ue, Se;
  const we = P - w, qe = i - b;
  if (_.isHorizontal()) {
    if (ue = Ur(y, b, i), yn(f)) {
      const Ge = Object.keys(f)[0], lt = f[Ge];
      Se = Y[Ge].getPixelForValue(lt) + we - a;
    } else
      f === "center" ? Se = (Z.bottom + Z.top) / 2 + we - a : Se = T1(_, f, a);
    ae = i - b;
  } else {
    if (yn(f)) {
      const Ge = Object.keys(f)[0], lt = f[Ge];
      ue = Y[Ge].getPixelForValue(lt) - qe + a;
    } else
      f === "center" ? ue = (Z.left + Z.right) / 2 - qe + a : ue = T1(_, f, a);
    Se = Ur(y, P, w), J = f === "left" ? -Ns : Ns;
  }
  return {
    titleX: ue,
    titleY: Se,
    maxWidth: ae,
    rotation: J
  };
}
class Oh extends Vl {
  constructor(a) {
    super(), this.id = a.id, this.type = a.type, this.options = void 0, this.ctx = a.ctx, this.chart = a.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(a) {
    this.options = a.setContext(this.getContext()), this.axis = a.axis, this._userMin = this.parse(a.min), this._userMax = this.parse(a.max), this._suggestedMin = this.parse(a.suggestedMin), this._suggestedMax = this.parse(a.suggestedMax);
  }
  parse(a, f) {
    return a;
  }
  getUserBounds() {
    let { _userMin: a, _userMax: f, _suggestedMin: y, _suggestedMax: w } = this;
    return a = Fo(a, Number.POSITIVE_INFINITY), f = Fo(f, Number.NEGATIVE_INFINITY), y = Fo(y, Number.POSITIVE_INFINITY), w = Fo(w, Number.NEGATIVE_INFINITY), {
      min: Fo(a, y),
      max: Fo(f, w),
      minDefined: Ps(a),
      maxDefined: Ps(f)
    };
  }
  getMinMax(a) {
    let { min: f, max: y, minDefined: w, maxDefined: b } = this.getUserBounds(), P;
    if (w && b)
      return {
        min: f,
        max: y
      };
    const i = this.getMatchingVisibleMetas();
    for (let O = 0, Z = i.length; O < Z; ++O)
      P = i[O].controller.getMinMax(this, a), w || (f = Math.min(f, P.min)), b || (y = Math.max(y, P.max));
    return f = b && f > y ? y : f, y = w && f > y ? f : y, {
      min: Fo(f, Fo(y, f)),
      max: Fo(y, Fo(f, y))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const a = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? a.xLabels : a.yLabels) || a.labels || [];
  }
  getLabelItems(a = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(a));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    is(this.options.beforeUpdate, [
      this
    ]);
  }
  update(a, f, y) {
    const { beginAtZero: w, grace: b, ticks: P } = this.options, i = P.sampleSize;
    this.beforeUpdate(), this.maxWidth = a, this.maxHeight = f, this._margins = y = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, y), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + y.left + y.right : this.height + y.top + y.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = hM(this, b, w), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const O = i < this.ticks.length;
    this._convertTicksToLabels(O ? M1(this.ticks, i) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), P.display && (P.autoSkip || P.source === "auto") && (this.ticks = GE(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), O && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let a = this.options.reverse, f, y;
    this.isHorizontal() ? (f = this.left, y = this.right) : (f = this.top, y = this.bottom, a = !a), this._startPixel = f, this._endPixel = y, this._reversePixels = a, this._length = y - f, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    is(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    is(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    is(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(a) {
    this.chart.notifyPlugins(a, this.getContext()), is(this.options[a], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    is(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(a) {
    const f = this.options.ticks;
    let y, w, b;
    for (y = 0, w = a.length; y < w; y++)
      b = a[y], b.label = is(f.callback, [
        b.value,
        y,
        a
      ], this);
  }
  afterTickToLabelConversion() {
    is(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    is(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const a = this.options, f = a.ticks, y = S1(this.ticks.length, a.ticks.maxTicksLimit), w = f.minRotation || 0, b = f.maxRotation;
    let P = w, i, O, Z;
    if (!this._isVisible() || !f.display || w >= b || y <= 1 || !this.isHorizontal()) {
      this.labelRotation = w;
      return;
    }
    const Y = this._getLabelSizes(), J = Y.widest.width, ae = Y.highest.height, ue = gr(this.chart.width - J, 0, this.maxWidth);
    i = a.offset ? this.maxWidth / y : ue / (y - 1), J + 6 > i && (i = ue / (y - (a.offset ? 0.5 : 1)), O = this.maxHeight - gf(a.grid) - f.padding - E1(a.title, this.chart.options.font), Z = Math.sqrt(J * J + ae * ae), P = ny(Math.min(Math.asin(gr((Y.highest.height + 6) / i, -1, 1)), Math.asin(gr(O / Z, -1, 1)) - Math.asin(gr(ae / Z, -1, 1)))), P = Math.max(w, Math.min(b, P))), this.labelRotation = P;
  }
  afterCalculateLabelRotation() {
    is(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    is(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const a = {
      width: 0,
      height: 0
    }, { chart: f, options: { ticks: y, title: w, grid: b } } = this, P = this._isVisible(), i = this.isHorizontal();
    if (P) {
      const O = E1(w, f.options.font);
      if (i ? (a.width = this.maxWidth, a.height = gf(b) + O) : (a.height = this.maxHeight, a.width = gf(b) + O), y.display && this.ticks.length) {
        const { first: Z, last: Y, widest: J, highest: ae } = this._getLabelSizes(), ue = y.padding * 2, Se = Ca(this.labelRotation), we = Math.cos(Se), qe = Math.sin(Se);
        if (i) {
          const Ge = y.mirror ? 0 : qe * J.width + we * ae.height;
          a.height = Math.min(this.maxHeight, a.height + Ge + ue);
        } else {
          const Ge = y.mirror ? 0 : we * J.width + qe * ae.height;
          a.width = Math.min(this.maxWidth, a.width + Ge + ue);
        }
        this._calculatePadding(Z, Y, qe, we);
      }
    }
    this._handleMargins(), i ? (this.width = this._length = f.width - this._margins.left - this._margins.right, this.height = a.height) : (this.width = a.width, this.height = this._length = f.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(a, f, y, w) {
    const { ticks: { align: b, padding: P }, position: i } = this.options, O = this.labelRotation !== 0, Z = i !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const Y = this.getPixelForTick(0) - this.left, J = this.right - this.getPixelForTick(this.ticks.length - 1);
      let ae = 0, ue = 0;
      O ? Z ? (ae = w * a.width, ue = y * f.height) : (ae = y * a.height, ue = w * f.width) : b === "start" ? ue = f.width : b === "end" ? ae = a.width : b !== "inner" && (ae = a.width / 2, ue = f.width / 2), this.paddingLeft = Math.max((ae - Y + P) * this.width / (this.width - Y), 0), this.paddingRight = Math.max((ue - J + P) * this.width / (this.width - J), 0);
    } else {
      let Y = f.height / 2, J = a.height / 2;
      b === "start" ? (Y = 0, J = a.height) : b === "end" && (Y = f.height, J = 0), this.paddingTop = Y + P, this.paddingBottom = J + P;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    is(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: a, position: f } = this.options;
    return f === "top" || f === "bottom" || a === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(a) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(a);
    let f, y;
    for (f = 0, y = a.length; f < y; f++)
      En(a[f].label) && (a.splice(f, 1), y--, f--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let a = this._labelSizes;
    if (!a) {
      const f = this.options.ticks.sampleSize;
      let y = this.ticks;
      f < y.length && (y = M1(y, f)), this._labelSizes = a = this._computeLabelSizes(y, y.length, this.options.ticks.maxTicksLimit);
    }
    return a;
  }
  _computeLabelSizes(a, f, y) {
    const { ctx: w, _longestTextCache: b } = this, P = [], i = [], O = Math.floor(f / S1(f, y));
    let Z = 0, Y = 0, J, ae, ue, Se, we, qe, Ge, lt, Et, ut, bt;
    for (J = 0; J < f; J += O) {
      if (Se = a[J].label, we = this._resolveTickFontOptions(J), w.font = qe = we.string, Ge = b[qe] = b[qe] || {
        data: {},
        gc: []
      }, lt = we.lineHeight, Et = ut = 0, !En(Se) && !hs(Se))
        Et = km(w, Ge.data, Ge.gc, Et, Se), ut = lt;
      else if (hs(Se))
        for (ae = 0, ue = Se.length; ae < ue; ++ae)
          bt = Se[ae], !En(bt) && !hs(bt) && (Et = km(w, Ge.data, Ge.gc, Et, bt), ut += lt);
      P.push(Et), i.push(ut), Z = Math.max(Et, Z), Y = Math.max(ut, Y);
    }
    KE(b, f);
    const Vt = P.indexOf(Z), pt = i.indexOf(Y), Gt = (ui) => ({
      width: P[ui] || 0,
      height: i[ui] || 0
    });
    return {
      first: Gt(0),
      last: Gt(f - 1),
      widest: Gt(Vt),
      highest: Gt(pt),
      widths: P,
      heights: i
    };
  }
  getLabelForValue(a) {
    return a;
  }
  getPixelForValue(a, f) {
    return NaN;
  }
  getValueForPixel(a) {
  }
  getPixelForTick(a) {
    const f = this.ticks;
    return a < 0 || a > f.length - 1 ? null : this.getPixelForValue(f[a].value);
  }
  getPixelForDecimal(a) {
    this._reversePixels && (a = 1 - a);
    const f = this._startPixel + a * this._length;
    return NS(this._alignToPixels ? Mh(this.chart, f, 0) : f);
  }
  getDecimalForPixel(a) {
    const f = (a - this._startPixel) / this._length;
    return this._reversePixels ? 1 - f : f;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: a, max: f } = this;
    return a < 0 && f < 0 ? f : a > 0 && f > 0 ? a : 0;
  }
  getContext(a) {
    const f = this.ticks || [];
    if (a >= 0 && a < f.length) {
      const y = f[a];
      return y.$context || (y.$context = QE(this.getContext(), a, y));
    }
    return this.$context || (this.$context = JE(this.chart.getContext(), this));
  }
  _tickSize() {
    const a = this.options.ticks, f = Ca(this.labelRotation), y = Math.abs(Math.cos(f)), w = Math.abs(Math.sin(f)), b = this._getLabelSizes(), P = a.autoSkipPadding || 0, i = b ? b.widest.width + P : 0, O = b ? b.highest.height + P : 0;
    return this.isHorizontal() ? O * y > i * w ? i / y : O / w : O * w < i * y ? O / y : i / w;
  }
  _isVisible() {
    const a = this.options.display;
    return a !== "auto" ? !!a : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(a) {
    const f = this.axis, y = this.chart, w = this.options, { grid: b, position: P, border: i } = w, O = b.offset, Z = this.isHorizontal(), J = this.ticks.length + (O ? 1 : 0), ae = gf(b), ue = [], Se = i.setContext(this.getContext()), we = Se.display ? Se.width : 0, qe = we / 2, Ge = function(Mi) {
      return Mh(y, Mi, we);
    };
    let lt, Et, ut, bt, Vt, pt, Gt, ui, kt, At, Si, An;
    if (P === "top")
      lt = Ge(this.bottom), pt = this.bottom - ae, ui = lt - qe, At = Ge(a.top) + qe, An = a.bottom;
    else if (P === "bottom")
      lt = Ge(this.top), At = a.top, An = Ge(a.bottom) - qe, pt = lt + qe, ui = this.top + ae;
    else if (P === "left")
      lt = Ge(this.right), Vt = this.right - ae, Gt = lt - qe, kt = Ge(a.left) + qe, Si = a.right;
    else if (P === "right")
      lt = Ge(this.left), kt = a.left, Si = Ge(a.right) - qe, Vt = lt + qe, Gt = this.left + ae;
    else if (f === "x") {
      if (P === "center")
        lt = Ge((a.top + a.bottom) / 2 + 0.5);
      else if (yn(P)) {
        const Mi = Object.keys(P)[0], Ji = P[Mi];
        lt = Ge(this.chart.scales[Mi].getPixelForValue(Ji));
      }
      At = a.top, An = a.bottom, pt = lt + qe, ui = pt + ae;
    } else if (f === "y") {
      if (P === "center")
        lt = Ge((a.left + a.right) / 2);
      else if (yn(P)) {
        const Mi = Object.keys(P)[0], Ji = P[Mi];
        lt = Ge(this.chart.scales[Mi].getPixelForValue(Ji));
      }
      Vt = lt - qe, Gt = Vt - ae, kt = a.left, Si = a.right;
    }
    const hn = en(w.ticks.maxTicksLimit, J), Ht = Math.max(1, Math.ceil(J / hn));
    for (Et = 0; Et < J; Et += Ht) {
      const Mi = this.getContext(Et), Ji = b.setContext(Mi), fi = i.setContext(Mi), jt = Ji.lineWidth, ni = Ji.color, Gi = fi.dash || [], an = fi.dashOffset, qt = Ji.tickWidth, ln = Ji.tickColor, Di = Ji.tickBorderDash || [], xi = Ji.tickBorderDashOffset;
      ut = YE(this, Et, O), ut !== void 0 && (bt = Mh(y, ut, jt), Z ? Vt = Gt = kt = Si = bt : pt = ui = At = An = bt, ue.push({
        tx1: Vt,
        ty1: pt,
        tx2: Gt,
        ty2: ui,
        x1: kt,
        y1: At,
        x2: Si,
        y2: An,
        width: jt,
        color: ni,
        borderDash: Gi,
        borderDashOffset: an,
        tickWidth: qt,
        tickColor: ln,
        tickBorderDash: Di,
        tickBorderDashOffset: xi
      }));
    }
    return this._ticksLength = J, this._borderValue = lt, ue;
  }
  _computeLabelItems(a) {
    const f = this.axis, y = this.options, { position: w, ticks: b } = y, P = this.isHorizontal(), i = this.ticks, { align: O, crossAlign: Z, padding: Y, mirror: J } = b, ae = gf(y.grid), ue = ae + Y, Se = J ? -Y : ue, we = -Ca(this.labelRotation), qe = [];
    let Ge, lt, Et, ut, bt, Vt, pt, Gt, ui, kt, At, Si, An = "middle";
    if (w === "top")
      Vt = this.bottom - Se, pt = this._getXAxisLabelAlignment();
    else if (w === "bottom")
      Vt = this.top + Se, pt = this._getXAxisLabelAlignment();
    else if (w === "left") {
      const Ht = this._getYAxisLabelAlignment(ae);
      pt = Ht.textAlign, bt = Ht.x;
    } else if (w === "right") {
      const Ht = this._getYAxisLabelAlignment(ae);
      pt = Ht.textAlign, bt = Ht.x;
    } else if (f === "x") {
      if (w === "center")
        Vt = (a.top + a.bottom) / 2 + ue;
      else if (yn(w)) {
        const Ht = Object.keys(w)[0], Mi = w[Ht];
        Vt = this.chart.scales[Ht].getPixelForValue(Mi) + ue;
      }
      pt = this._getXAxisLabelAlignment();
    } else if (f === "y") {
      if (w === "center")
        bt = (a.left + a.right) / 2 - ue;
      else if (yn(w)) {
        const Ht = Object.keys(w)[0], Mi = w[Ht];
        bt = this.chart.scales[Ht].getPixelForValue(Mi);
      }
      pt = this._getYAxisLabelAlignment(ae).textAlign;
    }
    f === "y" && (O === "start" ? An = "top" : O === "end" && (An = "bottom"));
    const hn = this._getLabelSizes();
    for (Ge = 0, lt = i.length; Ge < lt; ++Ge) {
      Et = i[Ge], ut = Et.label;
      const Ht = b.setContext(this.getContext(Ge));
      Gt = this.getPixelForTick(Ge) + b.labelOffset, ui = this._resolveTickFontOptions(Ge), kt = ui.lineHeight, At = hs(ut) ? ut.length : 1;
      const Mi = At / 2, Ji = Ht.color, fi = Ht.textStrokeColor, jt = Ht.textStrokeWidth;
      let ni = pt;
      P ? (bt = Gt, pt === "inner" && (Ge === lt - 1 ? ni = this.options.reverse ? "left" : "right" : Ge === 0 ? ni = this.options.reverse ? "right" : "left" : ni = "center"), w === "top" ? Z === "near" || we !== 0 ? Si = -At * kt + kt / 2 : Z === "center" ? Si = -hn.highest.height / 2 - Mi * kt + kt : Si = -hn.highest.height + kt / 2 : Z === "near" || we !== 0 ? Si = kt / 2 : Z === "center" ? Si = hn.highest.height / 2 - Mi * kt : Si = hn.highest.height - At * kt, J && (Si *= -1), we !== 0 && !Ht.showLabelBackdrop && (bt += kt / 2 * Math.sin(we))) : (Vt = Gt, Si = (1 - At) * kt / 2);
      let Gi;
      if (Ht.showLabelBackdrop) {
        const an = Gr(Ht.backdropPadding), qt = hn.heights[Ge], ln = hn.widths[Ge];
        let Di = Si - an.top, xi = 0 - an.left;
        switch (An) {
          case "middle":
            Di -= qt / 2;
            break;
          case "bottom":
            Di -= qt;
            break;
        }
        switch (pt) {
          case "center":
            xi -= ln / 2;
            break;
          case "right":
            xi -= ln;
            break;
          case "inner":
            Ge === lt - 1 ? xi -= ln : Ge > 0 && (xi -= ln / 2);
            break;
        }
        Gi = {
          left: xi,
          top: Di,
          width: ln + an.width,
          height: qt + an.height,
          color: Ht.backdropColor
        };
      }
      qe.push({
        label: ut,
        font: ui,
        textOffset: Si,
        options: {
          rotation: we,
          color: Ji,
          strokeColor: fi,
          strokeWidth: jt,
          textAlign: ni,
          textBaseline: An,
          translation: [
            bt,
            Vt
          ],
          backdrop: Gi
        }
      });
    }
    return qe;
  }
  _getXAxisLabelAlignment() {
    const { position: a, ticks: f } = this.options;
    if (-Ca(this.labelRotation))
      return a === "top" ? "left" : "right";
    let w = "center";
    return f.align === "start" ? w = "left" : f.align === "end" ? w = "right" : f.align === "inner" && (w = "inner"), w;
  }
  _getYAxisLabelAlignment(a) {
    const { position: f, ticks: { crossAlign: y, mirror: w, padding: b } } = this.options, P = this._getLabelSizes(), i = a + b, O = P.widest.width;
    let Z, Y;
    return f === "left" ? w ? (Y = this.right + b, y === "near" ? Z = "left" : y === "center" ? (Z = "center", Y += O / 2) : (Z = "right", Y += O)) : (Y = this.right - i, y === "near" ? Z = "right" : y === "center" ? (Z = "center", Y -= O / 2) : (Z = "left", Y = this.left)) : f === "right" ? w ? (Y = this.left + b, y === "near" ? Z = "right" : y === "center" ? (Z = "center", Y -= O / 2) : (Z = "left", Y -= O)) : (Y = this.left + i, y === "near" ? Z = "left" : y === "center" ? (Z = "center", Y += O / 2) : (Z = "right", Y = this.right)) : Z = "right", {
      textAlign: Z,
      x: Y
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const a = this.chart, f = this.options.position;
    if (f === "left" || f === "right")
      return {
        top: 0,
        left: this.left,
        bottom: a.height,
        right: this.right
      };
    if (f === "top" || f === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: a.width
      };
  }
  drawBackground() {
    const { ctx: a, options: { backgroundColor: f }, left: y, top: w, width: b, height: P } = this;
    f && (a.save(), a.fillStyle = f, a.fillRect(y, w, b, P), a.restore());
  }
  getLineWidthForValue(a) {
    const f = this.options.grid;
    if (!this._isVisible() || !f.display)
      return 0;
    const w = this.ticks.findIndex((b) => b.value === a);
    return w >= 0 ? f.setContext(this.getContext(w)).lineWidth : 0;
  }
  drawGrid(a) {
    const f = this.options.grid, y = this.ctx, w = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(a));
    let b, P;
    const i = (O, Z, Y) => {
      !Y.width || !Y.color || (y.save(), y.lineWidth = Y.width, y.strokeStyle = Y.color, y.setLineDash(Y.borderDash || []), y.lineDashOffset = Y.borderDashOffset, y.beginPath(), y.moveTo(O.x, O.y), y.lineTo(Z.x, Z.y), y.stroke(), y.restore());
    };
    if (f.display)
      for (b = 0, P = w.length; b < P; ++b) {
        const O = w[b];
        f.drawOnChartArea && i({
          x: O.x1,
          y: O.y1
        }, {
          x: O.x2,
          y: O.y2
        }, O), f.drawTicks && i({
          x: O.tx1,
          y: O.ty1
        }, {
          x: O.tx2,
          y: O.ty2
        }, {
          color: O.tickColor,
          width: O.tickWidth,
          borderDash: O.tickBorderDash,
          borderDashOffset: O.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: a, ctx: f, options: { border: y, grid: w } } = this, b = y.setContext(this.getContext()), P = y.display ? b.width : 0;
    if (!P)
      return;
    const i = w.setContext(this.getContext(0)).lineWidth, O = this._borderValue;
    let Z, Y, J, ae;
    this.isHorizontal() ? (Z = Mh(a, this.left, P) - P / 2, Y = Mh(a, this.right, i) + i / 2, J = ae = O) : (J = Mh(a, this.top, P) - P / 2, ae = Mh(a, this.bottom, i) + i / 2, Z = Y = O), f.save(), f.lineWidth = b.width, f.strokeStyle = b.color, f.beginPath(), f.moveTo(Z, J), f.lineTo(Y, ae), f.stroke(), f.restore();
  }
  drawLabels(a) {
    if (!this.options.ticks.display)
      return;
    const y = this.ctx, w = this._computeLabelArea();
    w && Um(y, w);
    const b = this.getLabelItems(a);
    for (const P of b) {
      const i = P.options, O = P.font, Z = P.label, Y = P.textOffset;
      Rh(y, Z, 0, Y, O, i);
    }
    w && jm(y);
  }
  drawTitle() {
    const { ctx: a, options: { position: f, title: y, reverse: w } } = this;
    if (!y.display)
      return;
    const b = tr(y.font), P = Gr(y.padding), i = y.align;
    let O = b.lineHeight / 2;
    f === "bottom" || f === "center" || yn(f) ? (O += P.bottom, hs(y.text) && (O += b.lineHeight * (y.text.length - 1))) : O += P.top;
    const { titleX: Z, titleY: Y, maxWidth: J, rotation: ae } = tA(this, O, f, i);
    Rh(a, y.text, 0, 0, b, {
      color: y.color,
      maxWidth: J,
      rotation: ae,
      textAlign: eA(i, f, w),
      textBaseline: "middle",
      translation: [
        Z,
        Y
      ]
    });
  }
  draw(a) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(a), this.drawBorder(), this.drawTitle(), this.drawLabels(a));
  }
  _layers() {
    const a = this.options, f = a.ticks && a.ticks.z || 0, y = en(a.grid && a.grid.z, -1), w = en(a.border && a.border.z, 0);
    return !this._isVisible() || this.draw !== Oh.prototype.draw ? [
      {
        z: f,
        draw: (b) => {
          this.draw(b);
        }
      }
    ] : [
      {
        z: y,
        draw: (b) => {
          this.drawBackground(), this.drawGrid(b), this.drawTitle();
        }
      },
      {
        z: w,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: f,
        draw: (b) => {
          this.drawLabels(b);
        }
      }
    ];
  }
  getMatchingVisibleMetas(a) {
    const f = this.chart.getSortedVisibleDatasetMetas(), y = this.axis + "AxisID", w = [];
    let b, P;
    for (b = 0, P = f.length; b < P; ++b) {
      const i = f[b];
      i[y] === this.id && (!a || i.type === a) && w.push(i);
    }
    return w;
  }
  _resolveTickFontOptions(a) {
    const f = this.options.ticks.setContext(this.getContext(a));
    return tr(f.font);
  }
  _maxDigits() {
    const a = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / a;
  }
}
class pm {
  constructor(a, f, y) {
    this.type = a, this.scope = f, this.override = y, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(a) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, a.prototype);
  }
  register(a) {
    const f = Object.getPrototypeOf(a);
    let y;
    sA(f) && (y = this.register(f));
    const w = this.items, b = a.id, P = this.scope + "." + b;
    if (!b)
      throw new Error("class does not have id: " + a);
    return b in w || (w[b] = a, iA(a, P, y), this.override && ys.override(a.id, a.overrides)), P;
  }
  get(a) {
    return this.items[a];
  }
  unregister(a) {
    const f = this.items, y = a.id, w = this.scope;
    y in f && delete f[y], w && y in ys[w] && (delete ys[w][y], this.override && delete kh[y]);
  }
}
function iA(_, a, f) {
  const y = Lf(/* @__PURE__ */ Object.create(null), [
    f ? ys.get(f) : {},
    ys.get(a),
    _.defaults
  ]);
  ys.set(a, y), _.defaultRoutes && nA(a, _.defaultRoutes), _.descriptors && ys.describe(a, _.descriptors);
}
function nA(_, a) {
  Object.keys(a).forEach((f) => {
    const y = f.split("."), w = y.pop(), b = [
      _
    ].concat(y).join("."), P = a[f].split("."), i = P.pop(), O = P.join(".");
    ys.route(b, w, O, i);
  });
}
function sA(_) {
  return "id" in _ && "defaults" in _;
}
class rA {
  constructor() {
    this.controllers = new pm(Ia, "datasets", !0), this.elements = new pm(Vl, "elements"), this.plugins = new pm(Object, "plugins"), this.scales = new pm(Oh, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...a) {
    this._each("register", a);
  }
  remove(...a) {
    this._each("unregister", a);
  }
  addControllers(...a) {
    this._each("register", a, this.controllers);
  }
  addElements(...a) {
    this._each("register", a, this.elements);
  }
  addPlugins(...a) {
    this._each("register", a, this.plugins);
  }
  addScales(...a) {
    this._each("register", a, this.scales);
  }
  getController(a) {
    return this._get(a, this.controllers, "controller");
  }
  getElement(a) {
    return this._get(a, this.elements, "element");
  }
  getPlugin(a) {
    return this._get(a, this.plugins, "plugin");
  }
  getScale(a) {
    return this._get(a, this.scales, "scale");
  }
  removeControllers(...a) {
    this._each("unregister", a, this.controllers);
  }
  removeElements(...a) {
    this._each("unregister", a, this.elements);
  }
  removePlugins(...a) {
    this._each("unregister", a, this.plugins);
  }
  removeScales(...a) {
    this._each("unregister", a, this.scales);
  }
  _each(a, f, y) {
    [
      ...f
    ].forEach((w) => {
      const b = y || this._getRegistryForType(w);
      y || b.isForType(w) || b === this.plugins && w.id ? this._exec(a, b, w) : Zn(w, (P) => {
        const i = y || this._getRegistryForType(P);
        this._exec(a, i, P);
      });
    });
  }
  _exec(a, f, y) {
    const w = iy(a);
    is(y["before" + w], [], y), f[a](y), is(y["after" + w], [], y);
  }
  _getRegistryForType(a) {
    for (let f = 0; f < this._typedRegistries.length; f++) {
      const y = this._typedRegistries[f];
      if (y.isForType(a))
        return y;
    }
    return this.plugins;
  }
  _get(a, f, y) {
    const w = f.get(a);
    if (w === void 0)
      throw new Error('"' + a + '" is not a registered ' + y + ".");
    return w;
  }
}
var rl = /* @__PURE__ */ new rA();
class oA {
  constructor() {
    this._init = [];
  }
  notify(a, f, y, w) {
    f === "beforeInit" && (this._init = this._createDescriptors(a, !0), this._notify(this._init, a, "install"));
    const b = w ? this._descriptors(a).filter(w) : this._descriptors(a), P = this._notify(b, a, f, y);
    return f === "afterDestroy" && (this._notify(b, a, "stop"), this._notify(this._init, a, "uninstall")), P;
  }
  _notify(a, f, y, w) {
    w = w || {};
    for (const b of a) {
      const P = b.plugin, i = P[y], O = [
        f,
        w,
        b.options
      ];
      if (is(i, O, P) === !1 && w.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    En(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(a) {
    if (this._cache)
      return this._cache;
    const f = this._cache = this._createDescriptors(a);
    return this._notifyStateChanges(a), f;
  }
  _createDescriptors(a, f) {
    const y = a && a.config, w = en(y.options && y.options.plugins, {}), b = aA(y);
    return w === !1 && !f ? [] : cA(a, b, w, f);
  }
  _notifyStateChanges(a) {
    const f = this._oldCache || [], y = this._cache, w = (b, P) => b.filter((i) => !P.some((O) => i.plugin.id === O.plugin.id));
    this._notify(w(f, y), a, "stop"), this._notify(w(y, f), a, "start");
  }
}
function aA(_) {
  const a = {}, f = [], y = Object.keys(rl.plugins.items);
  for (let b = 0; b < y.length; b++)
    f.push(rl.getPlugin(y[b]));
  const w = _.plugins || [];
  for (let b = 0; b < w.length; b++) {
    const P = w[b];
    f.indexOf(P) === -1 && (f.push(P), a[P.id] = !0);
  }
  return {
    plugins: f,
    localIds: a
  };
}
function lA(_, a) {
  return !a && _ === !1 ? null : _ === !0 ? {} : _;
}
function cA(_, { plugins: a, localIds: f }, y, w) {
  const b = [], P = _.getContext();
  for (const i of a) {
    const O = i.id, Z = lA(y[O], w);
    Z !== null && b.push({
      plugin: i,
      options: hA(_.config, {
        plugin: i,
        local: f[O]
      }, Z, P)
    });
  }
  return b;
}
function hA(_, { plugin: a, local: f }, y, w) {
  const b = _.pluginScopeKeys(a), P = _.getOptionScopes(y, b);
  return f && a.defaults && P.push(a.defaults), _.createResolver(P, w, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function jg(_, a) {
  const f = ys.datasets[_] || {};
  return ((a.datasets || {})[_] || {}).indexAxis || a.indexAxis || f.indexAxis || "x";
}
function uA(_, a) {
  let f = _;
  return _ === "_index_" ? f = a : _ === "_value_" && (f = a === "x" ? "y" : "x"), f;
}
function dA(_, a) {
  return _ === a ? "_index_" : "_value_";
}
function A1(_) {
  if (_ === "x" || _ === "y" || _ === "r")
    return _;
}
function fA(_) {
  if (_ === "top" || _ === "bottom")
    return "x";
  if (_ === "left" || _ === "right")
    return "y";
}
function Gg(_, ...a) {
  if (A1(_))
    return _;
  for (const f of a) {
    const y = f.axis || fA(f.position) || _.length > 1 && A1(_[0].toLowerCase());
    if (y)
      return y;
  }
  throw new Error(`Cannot determine type of '${_}' axis. Please provide 'axis' or 'position' option.`);
}
function P1(_, a, f) {
  if (f[a + "AxisID"] === _)
    return {
      axis: a
    };
}
function pA(_, a) {
  if (a.data && a.data.datasets) {
    const f = a.data.datasets.filter((y) => y.xAxisID === _ || y.yAxisID === _);
    if (f.length)
      return P1(_, "x", f[0]) || P1(_, "y", f[0]);
  }
  return {};
}
function mA(_, a) {
  const f = kh[_.type] || {
    scales: {}
  }, y = a.scales || {}, w = jg(_.type, a), b = /* @__PURE__ */ Object.create(null);
  return Object.keys(y).forEach((P) => {
    const i = y[P];
    if (!yn(i))
      return console.error(`Invalid scale configuration for scale: ${P}`);
    if (i._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${P}`);
    const O = Gg(P, i, pA(P, _), ys.scales[i.type]), Z = dA(O, w), Y = f.scales || {};
    b[P] = Mf(/* @__PURE__ */ Object.create(null), [
      {
        axis: O
      },
      i,
      Y[O],
      Y[Z]
    ]);
  }), _.data.datasets.forEach((P) => {
    const i = P.type || _.type, O = P.indexAxis || jg(i, a), Y = (kh[i] || {}).scales || {};
    Object.keys(Y).forEach((J) => {
      const ae = uA(J, O), ue = P[ae + "AxisID"] || ae;
      b[ue] = b[ue] || /* @__PURE__ */ Object.create(null), Mf(b[ue], [
        {
          axis: ae
        },
        y[ue],
        Y[J]
      ]);
    });
  }), Object.keys(b).forEach((P) => {
    const i = b[P];
    Mf(i, [
      ys.scales[i.type],
      ys.scale
    ]);
  }), b;
}
function Hb(_) {
  const a = _.options || (_.options = {});
  a.plugins = en(a.plugins, {}), a.scales = mA(_, a);
}
function qb(_) {
  return _ = _ || {}, _.datasets = _.datasets || [], _.labels = _.labels || [], _;
}
function _A(_) {
  return _ = _ || {}, _.data = qb(_.data), Hb(_), _;
}
const C1 = /* @__PURE__ */ new Map(), Wb = /* @__PURE__ */ new Set();
function mm(_, a) {
  let f = C1.get(_);
  return f || (f = a(), C1.set(_, f), Wb.add(f)), f;
}
const yf = (_, a, f) => {
  const y = zc(a, f);
  y !== void 0 && _.add(y);
};
class gA {
  constructor(a) {
    this._config = _A(a), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(a) {
    this._config.type = a;
  }
  get data() {
    return this._config.data;
  }
  set data(a) {
    this._config.data = qb(a);
  }
  get options() {
    return this._config.options;
  }
  set options(a) {
    this._config.options = a;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const a = this._config;
    this.clearCache(), Hb(a);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(a) {
    return mm(a, () => [
      [
        `datasets.${a}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(a, f) {
    return mm(`${a}.transition.${f}`, () => [
      [
        `datasets.${a}.transitions.${f}`,
        `transitions.${f}`
      ],
      [
        `datasets.${a}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(a, f) {
    return mm(`${a}-${f}`, () => [
      [
        `datasets.${a}.elements.${f}`,
        `datasets.${a}`,
        `elements.${f}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(a) {
    const f = a.id, y = this.type;
    return mm(`${y}-plugin-${f}`, () => [
      [
        `plugins.${f}`,
        ...a.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(a, f) {
    const y = this._scopeCache;
    let w = y.get(a);
    return (!w || f) && (w = /* @__PURE__ */ new Map(), y.set(a, w)), w;
  }
  getOptionScopes(a, f, y) {
    const { options: w, type: b } = this, P = this._cachedScopes(a, y), i = P.get(f);
    if (i)
      return i;
    const O = /* @__PURE__ */ new Set();
    f.forEach((Y) => {
      a && (O.add(a), Y.forEach((J) => yf(O, a, J))), Y.forEach((J) => yf(O, w, J)), Y.forEach((J) => yf(O, kh[b] || {}, J)), Y.forEach((J) => yf(O, ys, J)), Y.forEach((J) => yf(O, Ng, J));
    });
    const Z = Array.from(O);
    return Z.length === 0 && Z.push(/* @__PURE__ */ Object.create(null)), Wb.has(f) && P.set(f, Z), Z;
  }
  chartOptionScopes() {
    const { options: a, type: f } = this;
    return [
      a,
      kh[f] || {},
      ys.datasets[f] || {},
      {
        type: f
      },
      ys,
      Ng
    ];
  }
  resolveNamedOptions(a, f, y, w = [
    ""
  ]) {
    const b = {
      $shared: !0
    }, { resolver: P, subPrefixes: i } = I1(this._resolverCache, a, w);
    let O = P;
    if (xA(P, f)) {
      b.$shared = !1, y = Dc(y) ? y() : y;
      const Z = this.createResolver(a, y, i);
      O = $u(P, y, Z);
    }
    for (const Z of f)
      b[Z] = O[Z];
    return b;
  }
  createResolver(a, f, y = [
    ""
  ], w) {
    const { resolver: b } = I1(this._resolverCache, a, y);
    return yn(f) ? $u(b, f, void 0, w) : b;
  }
}
function I1(_, a, f) {
  let y = _.get(a);
  y || (y = /* @__PURE__ */ new Map(), _.set(a, y));
  const w = f.join();
  let b = y.get(w);
  return b || (b = {
    resolver: ly(a, f),
    subPrefixes: f.filter((i) => !i.toLowerCase().includes("hover"))
  }, y.set(w, b)), b;
}
const yA = (_) => yn(_) && Object.getOwnPropertyNames(_).some((a) => Dc(_[a]));
function xA(_, a) {
  const { isScriptable: f, isIndexable: y } = Eb(_);
  for (const w of a) {
    const b = f(w), P = y(w), i = (P || b) && _[w];
    if (b && (Dc(i) || yA(i)) || P && hs(i))
      return !0;
  }
  return !1;
}
var vA = "4.4.7";
const bA = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function L1(_, a) {
  return _ === "top" || _ === "bottom" || bA.indexOf(_) === -1 && a === "x";
}
function z1(_, a) {
  return function(f, y) {
    return f[_] === y[_] ? f[a] - y[a] : f[_] - y[_];
  };
}
function D1(_) {
  const a = _.chart, f = a.options.animation;
  a.notifyPlugins("afterRender"), is(f && f.onComplete, [
    _
  ], a);
}
function wA(_) {
  const a = _.chart, f = a.options.animation;
  is(f && f.onProgress, [
    _
  ], a);
}
function $b(_) {
  return uy() && typeof _ == "string" ? _ = document.getElementById(_) : _ && _.length && (_ = _[0]), _ && _.canvas && (_ = _.canvas), _;
}
const Pm = {}, k1 = (_) => {
  const a = $b(_);
  return Object.values(Pm).filter((f) => f.canvas === a).pop();
};
function TA(_, a, f) {
  const y = Object.keys(_);
  for (const w of y) {
    const b = +w;
    if (b >= a) {
      const P = _[w];
      delete _[w], (f > 0 || b > a) && (_[b + f] = P);
    }
  }
}
function SA(_, a, f, y) {
  return !f || _.type === "mouseout" ? null : y ? a : _;
}
function _m(_, a, f) {
  return _.options.clip ? _[f] : a[f];
}
function MA(_, a) {
  const { xScale: f, yScale: y } = _;
  return f && y ? {
    left: _m(f, a, "left"),
    right: _m(f, a, "right"),
    top: _m(y, a, "top"),
    bottom: _m(y, a, "bottom")
  } : a;
}
class Ol {
  static register(...a) {
    rl.add(...a), R1();
  }
  static unregister(...a) {
    rl.remove(...a), R1();
  }
  constructor(a, f) {
    const y = this.config = new gA(f), w = $b(a), b = k1(w);
    if (b)
      throw new Error("Canvas is already in use. Chart with ID '" + b.id + "' must be destroyed before the canvas with ID '" + b.canvas.id + "' can be reused.");
    const P = y.createResolver(y.chartOptionScopes(), this.getContext());
    this.platform = new (y.platform || jE(w))(), this.platform.updateConfig(y);
    const i = this.platform.acquireContext(w, P.aspectRatio), O = i && i.canvas, Z = O && O.height, Y = O && O.width;
    if (this.id = AS(), this.ctx = i, this.canvas = O, this.width = Y, this.height = Z, this._options = P, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new oA(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = GS((J) => this.update(J), P.resizeDelay || 0), this._dataChanges = [], Pm[this.id] = this, !i || !O) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Dl.listen(this, "complete", D1), Dl.listen(this, "progress", wA), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: a, maintainAspectRatio: f }, width: y, height: w, _aspectRatio: b } = this;
    return En(a) ? f && b ? b : w ? y / w : null : a;
  }
  get data() {
    return this.config.data;
  }
  set data(a) {
    this.config.data = a;
  }
  get options() {
    return this._options;
  }
  set options(a) {
    this.config.options = a;
  }
  get registry() {
    return rl;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : n1(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return e1(this.canvas, this.ctx), this;
  }
  stop() {
    return Dl.stop(this), this;
  }
  resize(a, f) {
    Dl.running(this) ? this._resizeBeforeDraw = {
      width: a,
      height: f
    } : this._resize(a, f);
  }
  _resize(a, f) {
    const y = this.options, w = this.canvas, b = y.maintainAspectRatio && this.aspectRatio, P = this.platform.getMaximumSize(w, a, f, b), i = y.devicePixelRatio || this.platform.getDevicePixelRatio(), O = this.width ? "resize" : "attach";
    this.width = P.width, this.height = P.height, this._aspectRatio = this.aspectRatio, n1(this, i, !0) && (this.notifyPlugins("resize", {
      size: P
    }), is(y.onResize, [
      this,
      P
    ], this), this.attached && this._doResize(O) && this.render());
  }
  ensureScalesHaveIDs() {
    const f = this.options.scales || {};
    Zn(f, (y, w) => {
      y.id = w;
    });
  }
  buildOrUpdateScales() {
    const a = this.options, f = a.scales, y = this.scales, w = Object.keys(y).reduce((P, i) => (P[i] = !1, P), {});
    let b = [];
    f && (b = b.concat(Object.keys(f).map((P) => {
      const i = f[P], O = Gg(P, i), Z = O === "r", Y = O === "x";
      return {
        options: i,
        dposition: Z ? "chartArea" : Y ? "bottom" : "left",
        dtype: Z ? "radialLinear" : Y ? "category" : "linear"
      };
    }))), Zn(b, (P) => {
      const i = P.options, O = i.id, Z = Gg(O, i), Y = en(i.type, P.dtype);
      (i.position === void 0 || L1(i.position, Z) !== L1(P.dposition)) && (i.position = P.dposition), w[O] = !0;
      let J = null;
      if (O in y && y[O].type === Y)
        J = y[O];
      else {
        const ae = rl.getScale(Y);
        J = new ae({
          id: O,
          type: Y,
          ctx: this.ctx,
          chart: this
        }), y[J.id] = J;
      }
      J.init(i, a);
    }), Zn(w, (P, i) => {
      P || delete y[i];
    }), Zn(y, (P) => {
      jr.configure(this, P, P.options), jr.addBox(this, P);
    });
  }
  _updateMetasets() {
    const a = this._metasets, f = this.data.datasets.length, y = a.length;
    if (a.sort((w, b) => w.index - b.index), y > f) {
      for (let w = f; w < y; ++w)
        this._destroyDatasetMeta(w);
      a.splice(f, y - f);
    }
    this._sortedMetasets = a.slice(0).sort(z1("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: a, data: { datasets: f } } = this;
    a.length > f.length && delete this._stacks, a.forEach((y, w) => {
      f.filter((b) => b === y._dataset).length === 0 && this._destroyDatasetMeta(w);
    });
  }
  buildOrUpdateControllers() {
    const a = [], f = this.data.datasets;
    let y, w;
    for (this._removeUnreferencedMetasets(), y = 0, w = f.length; y < w; y++) {
      const b = f[y];
      let P = this.getDatasetMeta(y);
      const i = b.type || this.config.type;
      if (P.type && P.type !== i && (this._destroyDatasetMeta(y), P = this.getDatasetMeta(y)), P.type = i, P.indexAxis = b.indexAxis || jg(i, this.options), P.order = b.order || 0, P.index = y, P.label = "" + b.label, P.visible = this.isDatasetVisible(y), P.controller)
        P.controller.updateIndex(y), P.controller.linkScales();
      else {
        const O = rl.getController(i), { datasetElementType: Z, dataElementType: Y } = ys.datasets[i];
        Object.assign(O, {
          dataElementType: rl.getElement(Y),
          datasetElementType: Z && rl.getElement(Z)
        }), P.controller = new O(this, y), a.push(P.controller);
      }
    }
    return this._updateMetasets(), a;
  }
  _resetElements() {
    Zn(this.data.datasets, (a, f) => {
      this.getDatasetMeta(f).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(a) {
    const f = this.config;
    f.update();
    const y = this._options = f.createResolver(f.chartOptionScopes(), this.getContext()), w = this._animationsDisabled = !y.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: a,
      cancelable: !0
    }) === !1)
      return;
    const b = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let P = 0;
    for (let Z = 0, Y = this.data.datasets.length; Z < Y; Z++) {
      const { controller: J } = this.getDatasetMeta(Z), ae = !w && b.indexOf(J) === -1;
      J.buildOrUpdateElements(ae), P = Math.max(+J.getMaxOverflow(), P);
    }
    P = this._minPadding = y.layout.autoPadding ? P : 0, this._updateLayout(P), w || Zn(b, (Z) => {
      Z.reset();
    }), this._updateDatasets(a), this.notifyPlugins("afterUpdate", {
      mode: a
    }), this._layers.sort(z1("z", "_idx"));
    const { _active: i, _lastEvent: O } = this;
    O ? this._eventHandler(O, !0) : i.length && this._updateHoverStyles(i, i, !0), this.render();
  }
  _updateScales() {
    Zn(this.scales, (a) => {
      jr.removeBox(this, a);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const a = this.options, f = new Set(Object.keys(this._listeners)), y = new Set(a.events);
    (!Hv(f, y) || !!this._responsiveListeners !== a.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: a } = this, f = this._getUniformDataChanges() || [];
    for (const { method: y, start: w, count: b } of f) {
      const P = y === "_removeElements" ? -b : b;
      TA(a, w, P);
    }
  }
  _getUniformDataChanges() {
    const a = this._dataChanges;
    if (!a || !a.length)
      return;
    this._dataChanges = [];
    const f = this.data.datasets.length, y = (b) => new Set(a.filter((P) => P[0] === b).map((P, i) => i + "," + P.splice(1).join(","))), w = y(0);
    for (let b = 1; b < f; b++)
      if (!Hv(w, y(b)))
        return;
    return Array.from(w).map((b) => b.split(",")).map((b) => ({
      method: b[1],
      start: +b[2],
      count: +b[3]
    }));
  }
  _updateLayout(a) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    jr.update(this, this.width, this.height, a);
    const f = this.chartArea, y = f.width <= 0 || f.height <= 0;
    this._layers = [], Zn(this.boxes, (w) => {
      y && w.position === "chartArea" || (w.configure && w.configure(), this._layers.push(...w._layers()));
    }, this), this._layers.forEach((w, b) => {
      w._idx = b;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(a) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: a,
      cancelable: !0
    }) !== !1) {
      for (let f = 0, y = this.data.datasets.length; f < y; ++f)
        this.getDatasetMeta(f).controller.configure();
      for (let f = 0, y = this.data.datasets.length; f < y; ++f)
        this._updateDataset(f, Dc(a) ? a({
          datasetIndex: f
        }) : a);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: a
      });
    }
  }
  _updateDataset(a, f) {
    const y = this.getDatasetMeta(a), w = {
      meta: y,
      index: a,
      mode: f,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", w) !== !1 && (y.controller._update(f), w.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", w));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Dl.has(this) ? this.attached && !Dl.running(this) && Dl.start(this) : (this.draw(), D1({
      chart: this
    })));
  }
  draw() {
    let a;
    if (this._resizeBeforeDraw) {
      const { width: y, height: w } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(y, w);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const f = this._layers;
    for (a = 0; a < f.length && f[a].z <= 0; ++a)
      f[a].draw(this.chartArea);
    for (this._drawDatasets(); a < f.length; ++a)
      f[a].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(a) {
    const f = this._sortedMetasets, y = [];
    let w, b;
    for (w = 0, b = f.length; w < b; ++w) {
      const P = f[w];
      (!a || P.visible) && y.push(P);
    }
    return y;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const a = this.getSortedVisibleDatasetMetas();
    for (let f = a.length - 1; f >= 0; --f)
      this._drawDataset(a[f]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(a) {
    const f = this.ctx, y = a._clip, w = !y.disabled, b = MA(a, this.chartArea), P = {
      meta: a,
      index: a.index,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetDraw", P) !== !1 && (w && Um(f, {
      left: y.left === !1 ? 0 : b.left - y.left,
      right: y.right === !1 ? this.width : b.right + y.right,
      top: y.top === !1 ? 0 : b.top - y.top,
      bottom: y.bottom === !1 ? this.height : b.bottom + y.bottom
    }), a.controller.draw(), w && jm(f), P.cancelable = !1, this.notifyPlugins("afterDatasetDraw", P));
  }
  isPointInArea(a) {
    return Nl(a, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(a, f, y, w) {
    const b = bE.modes[f];
    return typeof b == "function" ? b(this, a, y, w) : [];
  }
  getDatasetMeta(a) {
    const f = this.data.datasets[a], y = this._metasets;
    let w = y.filter((b) => b && b._dataset === f).pop();
    return w || (w = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: f && f.order || 0,
      index: a,
      _dataset: f,
      _parsed: [],
      _sorted: !1
    }, y.push(w)), w;
  }
  getContext() {
    return this.$context || (this.$context = kc(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(a) {
    const f = this.data.datasets[a];
    if (!f)
      return !1;
    const y = this.getDatasetMeta(a);
    return typeof y.hidden == "boolean" ? !y.hidden : !f.hidden;
  }
  setDatasetVisibility(a, f) {
    const y = this.getDatasetMeta(a);
    y.hidden = !f;
  }
  toggleDataVisibility(a) {
    this._hiddenIndices[a] = !this._hiddenIndices[a];
  }
  getDataVisibility(a) {
    return !this._hiddenIndices[a];
  }
  _updateVisibility(a, f, y) {
    const w = y ? "show" : "hide", b = this.getDatasetMeta(a), P = b.controller._resolveAnimations(void 0, w);
    zf(f) ? (b.data[f].hidden = !y, this.update()) : (this.setDatasetVisibility(a, y), P.update(b, {
      visible: y
    }), this.update((i) => i.datasetIndex === a ? w : void 0));
  }
  hide(a, f) {
    this._updateVisibility(a, f, !1);
  }
  show(a, f) {
    this._updateVisibility(a, f, !0);
  }
  _destroyDatasetMeta(a) {
    const f = this._metasets[a];
    f && f.controller && f.controller._destroy(), delete this._metasets[a];
  }
  _stop() {
    let a, f;
    for (this.stop(), Dl.remove(this), a = 0, f = this.data.datasets.length; a < f; ++a)
      this._destroyDatasetMeta(a);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: a, ctx: f } = this;
    this._stop(), this.config.clearCache(), a && (this.unbindEvents(), e1(a, f), this.platform.releaseContext(f), this.canvas = null, this.ctx = null), delete Pm[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...a) {
    return this.canvas.toDataURL(...a);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const a = this._listeners, f = this.platform, y = (b, P) => {
      f.addEventListener(this, b, P), a[b] = P;
    }, w = (b, P, i) => {
      b.offsetX = P, b.offsetY = i, this._eventHandler(b);
    };
    Zn(this.options.events, (b) => y(b, w));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const a = this._responsiveListeners, f = this.platform, y = (O, Z) => {
      f.addEventListener(this, O, Z), a[O] = Z;
    }, w = (O, Z) => {
      a[O] && (f.removeEventListener(this, O, Z), delete a[O]);
    }, b = (O, Z) => {
      this.canvas && this.resize(O, Z);
    };
    let P;
    const i = () => {
      w("attach", i), this.attached = !0, this.resize(), y("resize", b), y("detach", P);
    };
    P = () => {
      this.attached = !1, w("resize", b), this._stop(), this._resize(0, 0), y("attach", i);
    }, f.isAttached(this.canvas) ? i() : P();
  }
  unbindEvents() {
    Zn(this._listeners, (a, f) => {
      this.platform.removeEventListener(this, f, a);
    }), this._listeners = {}, Zn(this._responsiveListeners, (a, f) => {
      this.platform.removeEventListener(this, f, a);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(a, f, y) {
    const w = y ? "set" : "remove";
    let b, P, i, O;
    for (f === "dataset" && (b = this.getDatasetMeta(a[0].datasetIndex), b.controller["_" + w + "DatasetHoverStyle"]()), i = 0, O = a.length; i < O; ++i) {
      P = a[i];
      const Z = P && this.getDatasetMeta(P.datasetIndex).controller;
      Z && Z[w + "HoverStyle"](P.element, P.datasetIndex, P.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(a) {
    const f = this._active || [], y = a.map(({ datasetIndex: b, index: P }) => {
      const i = this.getDatasetMeta(b);
      if (!i)
        throw new Error("No dataset found at index " + b);
      return {
        datasetIndex: b,
        element: i.data[P],
        index: P
      };
    });
    !Lm(y, f) && (this._active = y, this._lastEvent = null, this._updateHoverStyles(y, f));
  }
  notifyPlugins(a, f, y) {
    return this._plugins.notify(this, a, f, y);
  }
  isPluginEnabled(a) {
    return this._plugins._cache.filter((f) => f.plugin.id === a).length === 1;
  }
  _updateHoverStyles(a, f, y) {
    const w = this.options.hover, b = (O, Z) => O.filter((Y) => !Z.some((J) => Y.datasetIndex === J.datasetIndex && Y.index === J.index)), P = b(f, a), i = y ? a : b(a, f);
    P.length && this.updateHoverStyle(P, w.mode, !1), i.length && w.mode && this.updateHoverStyle(i, w.mode, !0);
  }
  _eventHandler(a, f) {
    const y = {
      event: a,
      replay: f,
      cancelable: !0,
      inChartArea: this.isPointInArea(a)
    }, w = (P) => (P.options.events || this.options.events).includes(a.native.type);
    if (this.notifyPlugins("beforeEvent", y, w) === !1)
      return;
    const b = this._handleEvent(a, f, y.inChartArea);
    return y.cancelable = !1, this.notifyPlugins("afterEvent", y, w), (b || y.changed) && this.render(), this;
  }
  _handleEvent(a, f, y) {
    const { _active: w = [], options: b } = this, P = f, i = this._getActiveElements(a, w, y, P), O = DS(a), Z = SA(a, this._lastEvent, y, O);
    y && (this._lastEvent = null, is(b.onHover, [
      a,
      i,
      this
    ], this), O && is(b.onClick, [
      a,
      i,
      this
    ], this));
    const Y = !Lm(i, w);
    return (Y || f) && (this._active = i, this._updateHoverStyles(i, w, f)), this._lastEvent = Z, Y;
  }
  _getActiveElements(a, f, y, w) {
    if (a.type === "mouseout")
      return [];
    if (!y)
      return f;
    const b = this.options.hover;
    return this.getElementsAtEventForMode(a, b.mode, b, w);
  }
}
Yt(Ol, "defaults", ys), Yt(Ol, "instances", Pm), Yt(Ol, "overrides", kh), Yt(Ol, "registry", rl), Yt(Ol, "version", vA), Yt(Ol, "getChart", k1);
function R1() {
  return Zn(Ol.instances, (_) => _._plugins.invalidate());
}
function EA(_, a, f) {
  const { startAngle: y, pixelMargin: w, x: b, y: P, outerRadius: i, innerRadius: O } = a;
  let Z = w / i;
  _.beginPath(), _.arc(b, P, i, y - Z, f + Z), O > w ? (Z = w / O, _.arc(b, P, O, f + Z, y - Z, !0)) : _.arc(b, P, w, f + Ns, y - Ns), _.closePath(), _.clip();
}
function AA(_) {
  return ay(_, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function PA(_, a, f, y) {
  const w = AA(_.options.borderRadius), b = (f - a) / 2, P = Math.min(b, y * a / 2), i = (O) => {
    const Z = (f - Math.min(b, O)) * y / 2;
    return gr(O, 0, Math.min(b, Z));
  };
  return {
    outerStart: i(w.outerStart),
    outerEnd: i(w.outerEnd),
    innerStart: gr(w.innerStart, 0, P),
    innerEnd: gr(w.innerEnd, 0, P)
  };
}
function Hu(_, a, f, y) {
  return {
    x: f + _ * Math.cos(a),
    y: y + _ * Math.sin(a)
  };
}
function Fm(_, a, f, y, w, b) {
  const { x: P, y: i, startAngle: O, pixelMargin: Z, innerRadius: Y } = a, J = Math.max(a.outerRadius + y + f - Z, 0), ae = Y > 0 ? Y + y + f + Z : 0;
  let ue = 0;
  const Se = w - O;
  if (y) {
    const Ht = Y > 0 ? Y - y : 0, Mi = J > 0 ? J - y : 0, Ji = (Ht + Mi) / 2, fi = Ji !== 0 ? Se * Ji / (Ji + y) : Se;
    ue = (Se - fi) / 2;
  }
  const we = Math.max(1e-3, Se * J - f / ds) / J, qe = (Se - we) / 2, Ge = O + qe + ue, lt = w - qe - ue, { outerStart: Et, outerEnd: ut, innerStart: bt, innerEnd: Vt } = PA(a, ae, J, lt - Ge), pt = J - Et, Gt = J - ut, ui = Ge + Et / pt, kt = lt - ut / Gt, At = ae + bt, Si = ae + Vt, An = Ge + bt / At, hn = lt - Vt / Si;
  if (_.beginPath(), b) {
    const Ht = (ui + kt) / 2;
    if (_.arc(P, i, J, ui, Ht), _.arc(P, i, J, Ht, kt), ut > 0) {
      const jt = Hu(Gt, kt, P, i);
      _.arc(jt.x, jt.y, ut, kt, lt + Ns);
    }
    const Mi = Hu(Si, lt, P, i);
    if (_.lineTo(Mi.x, Mi.y), Vt > 0) {
      const jt = Hu(Si, hn, P, i);
      _.arc(jt.x, jt.y, Vt, lt + Ns, hn + Math.PI);
    }
    const Ji = (lt - Vt / ae + (Ge + bt / ae)) / 2;
    if (_.arc(P, i, ae, lt - Vt / ae, Ji, !0), _.arc(P, i, ae, Ji, Ge + bt / ae, !0), bt > 0) {
      const jt = Hu(At, An, P, i);
      _.arc(jt.x, jt.y, bt, An + Math.PI, Ge - Ns);
    }
    const fi = Hu(pt, Ge, P, i);
    if (_.lineTo(fi.x, fi.y), Et > 0) {
      const jt = Hu(pt, ui, P, i);
      _.arc(jt.x, jt.y, Et, Ge - Ns, ui);
    }
  } else {
    _.moveTo(P, i);
    const Ht = Math.cos(ui) * J + P, Mi = Math.sin(ui) * J + i;
    _.lineTo(Ht, Mi);
    const Ji = Math.cos(kt) * J + P, fi = Math.sin(kt) * J + i;
    _.lineTo(Ji, fi);
  }
  _.closePath();
}
function CA(_, a, f, y, w) {
  const { fullCircles: b, startAngle: P, circumference: i } = a;
  let O = a.endAngle;
  if (b) {
    Fm(_, a, f, y, O, w);
    for (let Z = 0; Z < b; ++Z)
      _.fill();
    isNaN(i) || (O = P + (i % us || us));
  }
  return Fm(_, a, f, y, O, w), _.fill(), O;
}
function IA(_, a, f, y, w) {
  const { fullCircles: b, startAngle: P, circumference: i, options: O } = a, { borderWidth: Z, borderJoinStyle: Y, borderDash: J, borderDashOffset: ae } = O, ue = O.borderAlign === "inner";
  if (!Z)
    return;
  _.setLineDash(J || []), _.lineDashOffset = ae, ue ? (_.lineWidth = Z * 2, _.lineJoin = Y || "round") : (_.lineWidth = Z, _.lineJoin = Y || "bevel");
  let Se = a.endAngle;
  if (b) {
    Fm(_, a, f, y, Se, w);
    for (let we = 0; we < b; ++we)
      _.stroke();
    isNaN(i) || (Se = P + (i % us || us));
  }
  ue && EA(_, a, Se), b || (Fm(_, a, f, y, Se, w), _.stroke());
}
class wf extends Vl {
  constructor(f) {
    super();
    Yt(this, "circumference");
    Yt(this, "endAngle");
    Yt(this, "fullCircles");
    Yt(this, "innerRadius");
    Yt(this, "outerRadius");
    Yt(this, "pixelMargin");
    Yt(this, "startAngle");
    this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, f && Object.assign(this, f);
  }
  inRange(f, y, w) {
    const b = this.getProps([
      "x",
      "y"
    ], w), { angle: P, distance: i } = _b(b, {
      x: f,
      y
    }), { startAngle: O, endAngle: Z, innerRadius: Y, outerRadius: J, circumference: ae } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], w), ue = (this.options.spacing + this.options.borderWidth) / 2, Se = en(ae, Z - O), we = Df(P, O, Z) && O !== Z, qe = Se >= us || we, Ge = Fl(i, Y + ue, J + ue);
    return qe && Ge;
  }
  getCenterPoint(f) {
    const { x: y, y: w, startAngle: b, endAngle: P, innerRadius: i, outerRadius: O } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], f), { offset: Z, spacing: Y } = this.options, J = (b + P) / 2, ae = (i + O + Y + Z) / 2;
    return {
      x: y + Math.cos(J) * ae,
      y: w + Math.sin(J) * ae
    };
  }
  tooltipPosition(f) {
    return this.getCenterPoint(f);
  }
  draw(f) {
    const { options: y, circumference: w } = this, b = (y.offset || 0) / 4, P = (y.spacing || 0) / 2, i = y.circular;
    if (this.pixelMargin = y.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = w > us ? Math.floor(w / us) : 0, w === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    f.save();
    const O = (this.startAngle + this.endAngle) / 2;
    f.translate(Math.cos(O) * b, Math.sin(O) * b);
    const Z = 1 - Math.sin(Math.min(ds, w || 0)), Y = b * Z;
    f.fillStyle = y.backgroundColor, f.strokeStyle = y.borderColor, CA(f, this, Y, P, i), IA(f, this, Y, P, i), f.restore();
  }
}
Yt(wf, "id", "arc"), Yt(wf, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: !0
}), Yt(wf, "defaultRoutes", {
  backgroundColor: "backgroundColor"
}), Yt(wf, "descriptors", {
  _scriptable: !0,
  _indexable: (f) => f !== "borderDash"
});
function Xb(_, a, f = a) {
  _.lineCap = en(f.borderCapStyle, a.borderCapStyle), _.setLineDash(en(f.borderDash, a.borderDash)), _.lineDashOffset = en(f.borderDashOffset, a.borderDashOffset), _.lineJoin = en(f.borderJoinStyle, a.borderJoinStyle), _.lineWidth = en(f.borderWidth, a.borderWidth), _.strokeStyle = en(f.borderColor, a.borderColor);
}
function LA(_, a, f) {
  _.lineTo(f.x, f.y);
}
function zA(_) {
  return _.stepped ? tM : _.tension || _.cubicInterpolationMode === "monotone" ? iM : LA;
}
function Yb(_, a, f = {}) {
  const y = _.length, { start: w = 0, end: b = y - 1 } = f, { start: P, end: i } = a, O = Math.max(w, P), Z = Math.min(b, i), Y = w < P && b < P || w > i && b > i;
  return {
    count: y,
    start: O,
    loop: a.loop,
    ilen: Z < O && !Y ? y + Z - O : Z - O
  };
}
function DA(_, a, f, y) {
  const { points: w, options: b } = a, { count: P, start: i, loop: O, ilen: Z } = Yb(w, f, y), Y = zA(b);
  let { move: J = !0, reverse: ae } = y || {}, ue, Se, we;
  for (ue = 0; ue <= Z; ++ue)
    Se = w[(i + (ae ? Z - ue : ue)) % P], !Se.skip && (J ? (_.moveTo(Se.x, Se.y), J = !1) : Y(_, we, Se, ae, b.stepped), we = Se);
  return O && (Se = w[(i + (ae ? Z : 0)) % P], Y(_, we, Se, ae, b.stepped)), !!O;
}
function kA(_, a, f, y) {
  const w = a.points, { count: b, start: P, ilen: i } = Yb(w, f, y), { move: O = !0, reverse: Z } = y || {};
  let Y = 0, J = 0, ae, ue, Se, we, qe, Ge;
  const lt = (ut) => (P + (Z ? i - ut : ut)) % b, Et = () => {
    we !== qe && (_.lineTo(Y, qe), _.lineTo(Y, we), _.lineTo(Y, Ge));
  };
  for (O && (ue = w[lt(0)], _.moveTo(ue.x, ue.y)), ae = 0; ae <= i; ++ae) {
    if (ue = w[lt(ae)], ue.skip)
      continue;
    const ut = ue.x, bt = ue.y, Vt = ut | 0;
    Vt === Se ? (bt < we ? we = bt : bt > qe && (qe = bt), Y = (J * Y + ut) / ++J) : (Et(), _.lineTo(ut, bt), Se = Vt, J = 0, we = qe = bt), Ge = bt;
  }
  Et();
}
function Zg(_) {
  const a = _.options, f = a.borderDash && a.borderDash.length;
  return !_._decimated && !_._loop && !a.tension && a.cubicInterpolationMode !== "monotone" && !a.stepped && !f ? kA : DA;
}
function RA(_) {
  return _.stepped ? kM : _.tension || _.cubicInterpolationMode === "monotone" ? RM : Ih;
}
function OA(_, a, f, y) {
  let w = a._path;
  w || (w = a._path = new Path2D(), a.path(w, f, y) && w.closePath()), Xb(_, a.options), _.stroke(w);
}
function FA(_, a, f, y) {
  const { segments: w, options: b } = a, P = Zg(a);
  for (const i of w)
    Xb(_, b, i.style), _.beginPath(), P(_, a, i, {
      start: f,
      end: f + y - 1
    }) && _.closePath(), _.stroke();
}
const BA = typeof Path2D == "function";
function NA(_, a, f, y) {
  BA && !a.options.segment ? OA(_, a, f, y) : FA(_, a, f, y);
}
class Cc extends Vl {
  constructor(a) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, a && Object.assign(this, a);
  }
  updateControlPoints(a, f) {
    const y = this.options;
    if ((y.tension || y.cubicInterpolationMode === "monotone") && !y.stepped && !this._pointsUpdated) {
      const w = y.spanGaps ? this._loop : this._fullLoop;
      EM(this._points, y, a, w, f), this._pointsUpdated = !0;
    }
  }
  set points(a) {
    this._points = a, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = UM(this, this.options.segment));
  }
  first() {
    const a = this.segments, f = this.points;
    return a.length && f[a[0].start];
  }
  last() {
    const a = this.segments, f = this.points, y = a.length;
    return y && f[a[y - 1].end];
  }
  interpolate(a, f) {
    const y = this.options, w = a[f], b = this.points, P = Ob(this, {
      property: f,
      start: w,
      end: w
    });
    if (!P.length)
      return;
    const i = [], O = RA(y);
    let Z, Y;
    for (Z = 0, Y = P.length; Z < Y; ++Z) {
      const { start: J, end: ae } = P[Z], ue = b[J], Se = b[ae];
      if (ue === Se) {
        i.push(ue);
        continue;
      }
      const we = Math.abs((w - ue[f]) / (Se[f] - ue[f])), qe = O(ue, Se, we, y.stepped);
      qe[f] = a[f], i.push(qe);
    }
    return i.length === 1 ? i[0] : i;
  }
  pathSegment(a, f, y) {
    return Zg(this)(a, this, f, y);
  }
  path(a, f, y) {
    const w = this.segments, b = Zg(this);
    let P = this._loop;
    f = f || 0, y = y || this.points.length - f;
    for (const i of w)
      P &= b(a, this, i, {
        start: f,
        end: f + y - 1
      });
    return !!P;
  }
  draw(a, f, y, w) {
    const b = this.options || {};
    (this.points || []).length && b.borderWidth && (a.save(), NA(a, this, y, w), a.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
Yt(Cc, "id", "line"), Yt(Cc, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: !0,
  cubicInterpolationMode: "default",
  fill: !1,
  spanGaps: !1,
  stepped: !1,
  tension: 0
}), Yt(Cc, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
}), Yt(Cc, "descriptors", {
  _scriptable: !0,
  _indexable: (a) => a !== "borderDash" && a !== "fill"
});
function O1(_, a, f, y) {
  const w = _.options, { [f]: b } = _.getProps([
    f
  ], y);
  return Math.abs(a - b) < w.radius + w.hitRadius;
}
class Cm extends Vl {
  constructor(f) {
    super();
    Yt(this, "parsed");
    Yt(this, "skip");
    Yt(this, "stop");
    this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, f && Object.assign(this, f);
  }
  inRange(f, y, w) {
    const b = this.options, { x: P, y: i } = this.getProps([
      "x",
      "y"
    ], w);
    return Math.pow(f - P, 2) + Math.pow(y - i, 2) < Math.pow(b.hitRadius + b.radius, 2);
  }
  inXRange(f, y) {
    return O1(this, f, "x", y);
  }
  inYRange(f, y) {
    return O1(this, f, "y", y);
  }
  getCenterPoint(f) {
    const { x: y, y: w } = this.getProps([
      "x",
      "y"
    ], f);
    return {
      x: y,
      y: w
    };
  }
  size(f) {
    f = f || this.options || {};
    let y = f.radius || 0;
    y = Math.max(y, y && f.hoverRadius || 0);
    const w = y && f.borderWidth || 0;
    return (y + w) * 2;
  }
  draw(f, y) {
    const w = this.options;
    this.skip || w.radius < 0.1 || !Nl(this, y, this.size(w) / 2) || (f.strokeStyle = w.borderColor, f.lineWidth = w.borderWidth, f.fillStyle = w.backgroundColor, Vg(f, w, this.x, this.y));
  }
  getRange() {
    const f = this.options || {};
    return f.radius + f.hitRadius;
  }
}
Yt(Cm, "id", "point"), /**
* @type {any}
*/
Yt(Cm, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
}), /**
* @type {any}
*/
Yt(Cm, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function Kb(_, a) {
  const { x: f, y, base: w, width: b, height: P } = _.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], a);
  let i, O, Z, Y, J;
  return _.horizontal ? (J = P / 2, i = Math.min(f, w), O = Math.max(f, w), Z = y - J, Y = y + J) : (J = b / 2, i = f - J, O = f + J, Z = Math.min(y, w), Y = Math.max(y, w)), {
    left: i,
    top: Z,
    right: O,
    bottom: Y
  };
}
function Ic(_, a, f, y) {
  return _ ? 0 : gr(a, f, y);
}
function VA(_, a, f) {
  const y = _.options.borderWidth, w = _.borderSkipped, b = Mb(y);
  return {
    t: Ic(w.top, b.top, 0, f),
    r: Ic(w.right, b.right, 0, a),
    b: Ic(w.bottom, b.bottom, 0, f),
    l: Ic(w.left, b.left, 0, a)
  };
}
function UA(_, a, f) {
  const { enableBorderRadius: y } = _.getProps([
    "enableBorderRadius"
  ]), w = _.options.borderRadius, b = zh(w), P = Math.min(a, f), i = _.borderSkipped, O = y || yn(w);
  return {
    topLeft: Ic(!O || i.top || i.left, b.topLeft, 0, P),
    topRight: Ic(!O || i.top || i.right, b.topRight, 0, P),
    bottomLeft: Ic(!O || i.bottom || i.left, b.bottomLeft, 0, P),
    bottomRight: Ic(!O || i.bottom || i.right, b.bottomRight, 0, P)
  };
}
function jA(_) {
  const a = Kb(_), f = a.right - a.left, y = a.bottom - a.top, w = VA(_, f / 2, y / 2), b = UA(_, f / 2, y / 2);
  return {
    outer: {
      x: a.left,
      y: a.top,
      w: f,
      h: y,
      radius: b
    },
    inner: {
      x: a.left + w.l,
      y: a.top + w.t,
      w: f - w.l - w.r,
      h: y - w.t - w.b,
      radius: {
        topLeft: Math.max(0, b.topLeft - Math.max(w.t, w.l)),
        topRight: Math.max(0, b.topRight - Math.max(w.t, w.r)),
        bottomLeft: Math.max(0, b.bottomLeft - Math.max(w.b, w.l)),
        bottomRight: Math.max(0, b.bottomRight - Math.max(w.b, w.r))
      }
    }
  };
}
function kg(_, a, f, y) {
  const w = a === null, b = f === null, i = _ && !(w && b) && Kb(_, y);
  return i && (w || Fl(a, i.left, i.right)) && (b || Fl(f, i.top, i.bottom));
}
function GA(_) {
  return _.topLeft || _.topRight || _.bottomLeft || _.bottomRight;
}
function ZA(_, a) {
  _.rect(a.x, a.y, a.w, a.h);
}
function Rg(_, a, f = {}) {
  const y = _.x !== f.x ? -a : 0, w = _.y !== f.y ? -a : 0, b = (_.x + _.w !== f.x + f.w ? a : 0) - y, P = (_.y + _.h !== f.y + f.h ? a : 0) - w;
  return {
    x: _.x + y,
    y: _.y + w,
    w: _.w + b,
    h: _.h + P,
    radius: _.radius
  };
}
class Im extends Vl {
  constructor(a) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, a && Object.assign(this, a);
  }
  draw(a) {
    const { inflateAmount: f, options: { borderColor: y, backgroundColor: w } } = this, { inner: b, outer: P } = jA(this), i = GA(P.radius) ? kf : ZA;
    a.save(), (P.w !== b.w || P.h !== b.h) && (a.beginPath(), i(a, Rg(P, f, b)), a.clip(), i(a, Rg(b, -f, P)), a.fillStyle = y, a.fill("evenodd")), a.beginPath(), i(a, Rg(b, f)), a.fillStyle = w, a.fill(), a.restore();
  }
  inRange(a, f, y) {
    return kg(this, a, f, y);
  }
  inXRange(a, f) {
    return kg(this, a, null, f);
  }
  inYRange(a, f) {
    return kg(this, null, a, f);
  }
  getCenterPoint(a) {
    const { x: f, y, base: w, horizontal: b } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], a);
    return {
      x: b ? (f + w) / 2 : f,
      y: b ? y : (y + w) / 2
    };
  }
  getRange(a) {
    return a === "x" ? this.width / 2 : this.height / 2;
  }
}
Yt(Im, "id", "bar"), Yt(Im, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
}), Yt(Im, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var HA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement: wf,
  BarElement: Im,
  LineElement: Cc,
  PointElement: Cm
});
const Hg = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
], F1 = /* @__PURE__ */ Hg.map((_) => _.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function Jb(_) {
  return Hg[_ % Hg.length];
}
function Qb(_) {
  return F1[_ % F1.length];
}
function qA(_, a) {
  return _.borderColor = Jb(a), _.backgroundColor = Qb(a), ++a;
}
function WA(_, a) {
  return _.backgroundColor = _.data.map(() => Jb(a++)), a;
}
function $A(_, a) {
  return _.backgroundColor = _.data.map(() => Qb(a++)), a;
}
function XA(_) {
  let a = 0;
  return (f, y) => {
    const w = _.getDatasetMeta(y).controller;
    w instanceof Lh ? a = WA(f, a) : w instanceof Cf ? a = $A(f, a) : w && (a = qA(f, a));
  };
}
function B1(_) {
  let a;
  for (a in _)
    if (_[a].borderColor || _[a].backgroundColor)
      return !0;
  return !1;
}
function YA(_) {
  return _ && (_.borderColor || _.backgroundColor);
}
function KA() {
  return ys.borderColor !== "rgba(0,0,0,0.1)" || ys.backgroundColor !== "rgba(0,0,0,0.1)";
}
var JA = {
  id: "colors",
  defaults: {
    enabled: !0,
    forceOverride: !1
  },
  beforeLayout(_, a, f) {
    if (!f.enabled)
      return;
    const { data: { datasets: y }, options: w } = _.config, { elements: b } = w, P = B1(y) || YA(w) || b && B1(b) || KA();
    if (!f.forceOverride && P)
      return;
    const i = XA(_);
    y.forEach(i);
  }
};
function QA(_, a, f, y, w) {
  const b = w.samples || y;
  if (b >= f)
    return _.slice(a, a + f);
  const P = [], i = (f - 2) / (b - 2);
  let O = 0;
  const Z = a + f - 1;
  let Y = a, J, ae, ue, Se, we;
  for (P[O++] = _[Y], J = 0; J < b - 2; J++) {
    let qe = 0, Ge = 0, lt;
    const Et = Math.floor((J + 1) * i) + 1 + a, ut = Math.min(Math.floor((J + 2) * i) + 1, f) + a, bt = ut - Et;
    for (lt = Et; lt < ut; lt++)
      qe += _[lt].x, Ge += _[lt].y;
    qe /= bt, Ge /= bt;
    const Vt = Math.floor(J * i) + 1 + a, pt = Math.min(Math.floor((J + 1) * i) + 1, f) + a, { x: Gt, y: ui } = _[Y];
    for (ue = Se = -1, lt = Vt; lt < pt; lt++)
      Se = 0.5 * Math.abs((Gt - qe) * (_[lt].y - ui) - (Gt - _[lt].x) * (Ge - ui)), Se > ue && (ue = Se, ae = _[lt], we = lt);
    P[O++] = ae, Y = we;
  }
  return P[O++] = _[Z], P;
}
function eP(_, a, f, y) {
  let w = 0, b = 0, P, i, O, Z, Y, J, ae, ue, Se, we;
  const qe = [], Ge = a + f - 1, lt = _[a].x, ut = _[Ge].x - lt;
  for (P = a; P < a + f; ++P) {
    i = _[P], O = (i.x - lt) / ut * y, Z = i.y;
    const bt = O | 0;
    if (bt === Y)
      Z < Se ? (Se = Z, J = P) : Z > we && (we = Z, ae = P), w = (b * w + i.x) / ++b;
    else {
      const Vt = P - 1;
      if (!En(J) && !En(ae)) {
        const pt = Math.min(J, ae), Gt = Math.max(J, ae);
        pt !== ue && pt !== Vt && qe.push({
          ..._[pt],
          x: w
        }), Gt !== ue && Gt !== Vt && qe.push({
          ..._[Gt],
          x: w
        });
      }
      P > 0 && Vt !== ue && qe.push(_[Vt]), qe.push(i), Y = bt, b = 0, Se = we = Z, J = ae = ue = P;
    }
  }
  return qe;
}
function ew(_) {
  if (_._decimated) {
    const a = _._data;
    delete _._decimated, delete _._data, Object.defineProperty(_, "data", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: a
    });
  }
}
function N1(_) {
  _.data.datasets.forEach((a) => {
    ew(a);
  });
}
function tP(_, a) {
  const f = a.length;
  let y = 0, w;
  const { iScale: b } = _, { min: P, max: i, minDefined: O, maxDefined: Z } = b.getUserBounds();
  return O && (y = gr(Bl(a, b.axis, P).lo, 0, f - 1)), Z ? w = gr(Bl(a, b.axis, i).hi + 1, y, f) - y : w = f - y, {
    start: y,
    count: w
  };
}
var iP = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: !1
  },
  beforeElementsUpdate: (_, a, f) => {
    if (!f.enabled) {
      N1(_);
      return;
    }
    const y = _.width;
    _.data.datasets.forEach((w, b) => {
      const { _data: P, indexAxis: i } = w, O = _.getDatasetMeta(b), Z = P || w.data;
      if (vf([
        i,
        _.options.indexAxis
      ]) === "y" || !O.controller.supportsDecimation)
        return;
      const Y = _.scales[O.xAxisID];
      if (Y.type !== "linear" && Y.type !== "time" || _.options.parsing)
        return;
      let { start: J, count: ae } = tP(O, Z);
      const ue = f.threshold || 4 * y;
      if (ae <= ue) {
        ew(w);
        return;
      }
      En(P) && (w._data = Z, delete w.data, Object.defineProperty(w, "data", {
        configurable: !0,
        enumerable: !0,
        get: function() {
          return this._decimated;
        },
        set: function(we) {
          this._data = we;
        }
      }));
      let Se;
      switch (f.algorithm) {
        case "lttb":
          Se = QA(Z, J, ae, y, f);
          break;
        case "min-max":
          Se = eP(Z, J, ae, y);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${f.algorithm}'`);
      }
      w._decimated = Se;
    });
  },
  destroy(_) {
    N1(_);
  }
};
function nP(_, a, f) {
  const y = _.segments, w = _.points, b = a.points, P = [];
  for (const i of y) {
    let { start: O, end: Z } = i;
    Z = py(O, Z, w);
    const Y = qg(f, w[O], w[Z], i.loop);
    if (!a.segments) {
      P.push({
        source: i,
        target: Y,
        start: w[O],
        end: w[Z]
      });
      continue;
    }
    const J = Ob(a, Y);
    for (const ae of J) {
      const ue = qg(f, b[ae.start], b[ae.end], ae.loop), Se = Rb(i, w, ue);
      for (const we of Se)
        P.push({
          source: we,
          target: ae,
          start: {
            [f]: V1(Y, ue, "start", Math.max)
          },
          end: {
            [f]: V1(Y, ue, "end", Math.min)
          }
        });
    }
  }
  return P;
}
function qg(_, a, f, y) {
  if (y)
    return;
  let w = a[_], b = f[_];
  return _ === "angle" && (w = Bo(w), b = Bo(b)), {
    property: _,
    start: w,
    end: b
  };
}
function sP(_, a) {
  const { x: f = null, y = null } = _ || {}, w = a.points, b = [];
  return a.segments.forEach(({ start: P, end: i }) => {
    i = py(P, i, w);
    const O = w[P], Z = w[i];
    y !== null ? (b.push({
      x: O.x,
      y
    }), b.push({
      x: Z.x,
      y
    })) : f !== null && (b.push({
      x: f,
      y: O.y
    }), b.push({
      x: f,
      y: Z.y
    }));
  }), b;
}
function py(_, a, f) {
  for (; a > _; a--) {
    const y = f[a];
    if (!isNaN(y.x) && !isNaN(y.y))
      break;
  }
  return a;
}
function V1(_, a, f, y) {
  return _ && a ? y(_[f], a[f]) : _ ? _[f] : a ? a[f] : 0;
}
function tw(_, a) {
  let f = [], y = !1;
  return hs(_) ? (y = !0, f = _) : f = sP(_, a), f.length ? new Cc({
    points: f,
    options: {
      tension: 0
    },
    _loop: y,
    _fullLoop: y
  }) : null;
}
function U1(_) {
  return _ && _.fill !== !1;
}
function rP(_, a, f) {
  let w = _[a].fill;
  const b = [
    a
  ];
  let P;
  if (!f)
    return w;
  for (; w !== !1 && b.indexOf(w) === -1; ) {
    if (!Ps(w))
      return w;
    if (P = _[w], !P)
      return !1;
    if (P.visible)
      return w;
    b.push(w), w = P.fill;
  }
  return !1;
}
function oP(_, a, f) {
  const y = hP(_);
  if (yn(y))
    return isNaN(y.value) ? !1 : y;
  let w = parseFloat(y);
  return Ps(w) && Math.floor(w) === w ? aP(y[0], a, w, f) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(y) >= 0 && y;
}
function aP(_, a, f, y) {
  return (_ === "-" || _ === "+") && (f = a + f), f === a || f < 0 || f >= y ? !1 : f;
}
function lP(_, a) {
  let f = null;
  return _ === "start" ? f = a.bottom : _ === "end" ? f = a.top : yn(_) ? f = a.getPixelForValue(_.value) : a.getBasePixel && (f = a.getBasePixel()), f;
}
function cP(_, a, f) {
  let y;
  return _ === "start" ? y = f : _ === "end" ? y = a.options.reverse ? a.min : a.max : yn(_) ? y = _.value : y = a.getBaseValue(), y;
}
function hP(_) {
  const a = _.options, f = a.fill;
  let y = en(f && f.target, f);
  return y === void 0 && (y = !!a.backgroundColor), y === !1 || y === null ? !1 : y === !0 ? "origin" : y;
}
function uP(_) {
  const { scale: a, index: f, line: y } = _, w = [], b = y.segments, P = y.points, i = dP(a, f);
  i.push(tw({
    x: null,
    y: a.bottom
  }, y));
  for (let O = 0; O < b.length; O++) {
    const Z = b[O];
    for (let Y = Z.start; Y <= Z.end; Y++)
      fP(w, P[Y], i);
  }
  return new Cc({
    points: w,
    options: {}
  });
}
function dP(_, a) {
  const f = [], y = _.getMatchingVisibleMetas("line");
  for (let w = 0; w < y.length; w++) {
    const b = y[w];
    if (b.index === a)
      break;
    b.hidden || f.unshift(b.dataset);
  }
  return f;
}
function fP(_, a, f) {
  const y = [];
  for (let w = 0; w < f.length; w++) {
    const b = f[w], { first: P, last: i, point: O } = pP(b, a, "x");
    if (!(!O || P && i)) {
      if (P)
        y.unshift(O);
      else if (_.push(O), !i)
        break;
    }
  }
  _.push(...y);
}
function pP(_, a, f) {
  const y = _.interpolate(a, f);
  if (!y)
    return {};
  const w = y[f], b = _.segments, P = _.points;
  let i = !1, O = !1;
  for (let Z = 0; Z < b.length; Z++) {
    const Y = b[Z], J = P[Y.start][f], ae = P[Y.end][f];
    if (Fl(w, J, ae)) {
      i = w === J, O = w === ae;
      break;
    }
  }
  return {
    first: i,
    last: O,
    point: y
  };
}
class iw {
  constructor(a) {
    this.x = a.x, this.y = a.y, this.radius = a.radius;
  }
  pathSegment(a, f, y) {
    const { x: w, y: b, radius: P } = this;
    return f = f || {
      start: 0,
      end: us
    }, a.arc(w, b, P, f.end, f.start, !0), !y.bounds;
  }
  interpolate(a) {
    const { x: f, y, radius: w } = this, b = a.angle;
    return {
      x: f + Math.cos(b) * w,
      y: y + Math.sin(b) * w,
      angle: b
    };
  }
}
function mP(_) {
  const { chart: a, fill: f, line: y } = _;
  if (Ps(f))
    return _P(a, f);
  if (f === "stack")
    return uP(_);
  if (f === "shape")
    return !0;
  const w = gP(_);
  return w instanceof iw ? w : tw(w, y);
}
function _P(_, a) {
  const f = _.getDatasetMeta(a);
  return f && _.isDatasetVisible(a) ? f.dataset : null;
}
function gP(_) {
  return (_.scale || {}).getPointPositionForValue ? xP(_) : yP(_);
}
function yP(_) {
  const { scale: a = {}, fill: f } = _, y = lP(f, a);
  if (Ps(y)) {
    const w = a.isHorizontal();
    return {
      x: w ? y : null,
      y: w ? null : y
    };
  }
  return null;
}
function xP(_) {
  const { scale: a, fill: f } = _, y = a.options, w = a.getLabels().length, b = y.reverse ? a.max : a.min, P = cP(f, a, b), i = [];
  if (y.grid.circular) {
    const O = a.getPointPositionForValue(0, b);
    return new iw({
      x: O.x,
      y: O.y,
      radius: a.getDistanceFromCenterForValue(P)
    });
  }
  for (let O = 0; O < w; ++O)
    i.push(a.getPointPositionForValue(O, P));
  return i;
}
function Og(_, a, f) {
  const y = mP(a), { line: w, scale: b, axis: P } = a, i = w.options, O = i.fill, Z = i.backgroundColor, { above: Y = Z, below: J = Z } = O || {};
  y && w.points.length && (Um(_, f), vP(_, {
    line: w,
    target: y,
    above: Y,
    below: J,
    area: f,
    scale: b,
    axis: P
  }), jm(_));
}
function vP(_, a) {
  const { line: f, target: y, above: w, below: b, area: P, scale: i } = a, O = f._loop ? "angle" : a.axis;
  _.save(), O === "x" && b !== w && (j1(_, y, P.top), G1(_, {
    line: f,
    target: y,
    color: w,
    scale: i,
    property: O
  }), _.restore(), _.save(), j1(_, y, P.bottom)), G1(_, {
    line: f,
    target: y,
    color: b,
    scale: i,
    property: O
  }), _.restore();
}
function j1(_, a, f) {
  const { segments: y, points: w } = a;
  let b = !0, P = !1;
  _.beginPath();
  for (const i of y) {
    const { start: O, end: Z } = i, Y = w[O], J = w[py(O, Z, w)];
    b ? (_.moveTo(Y.x, Y.y), b = !1) : (_.lineTo(Y.x, f), _.lineTo(Y.x, Y.y)), P = !!a.pathSegment(_, i, {
      move: P
    }), P ? _.closePath() : _.lineTo(J.x, f);
  }
  _.lineTo(a.first().x, f), _.closePath(), _.clip();
}
function G1(_, a) {
  const { line: f, target: y, property: w, color: b, scale: P } = a, i = nP(f, y, w);
  for (const { source: O, target: Z, start: Y, end: J } of i) {
    const { style: { backgroundColor: ae = b } = {} } = O, ue = y !== !0;
    _.save(), _.fillStyle = ae, bP(_, P, ue && qg(w, Y, J)), _.beginPath();
    const Se = !!f.pathSegment(_, O);
    let we;
    if (ue) {
      Se ? _.closePath() : Z1(_, y, J, w);
      const qe = !!y.pathSegment(_, Z, {
        move: Se,
        reverse: !0
      });
      we = Se && qe, we || Z1(_, y, Y, w);
    }
    _.closePath(), _.fill(we ? "evenodd" : "nonzero"), _.restore();
  }
}
function bP(_, a, f) {
  const { top: y, bottom: w } = a.chart.chartArea, { property: b, start: P, end: i } = f || {};
  b === "x" && (_.beginPath(), _.rect(P, y, i - P, w - y), _.clip());
}
function Z1(_, a, f, y) {
  const w = a.interpolate(f, y);
  w && _.lineTo(w.x, w.y);
}
var wP = {
  id: "filler",
  afterDatasetsUpdate(_, a, f) {
    const y = (_.data.datasets || []).length, w = [];
    let b, P, i, O;
    for (P = 0; P < y; ++P)
      b = _.getDatasetMeta(P), i = b.dataset, O = null, i && i.options && i instanceof Cc && (O = {
        visible: _.isDatasetVisible(P),
        index: P,
        fill: oP(i, P, y),
        chart: _,
        axis: b.controller.options.indexAxis,
        scale: b.vScale,
        line: i
      }), b.$filler = O, w.push(O);
    for (P = 0; P < y; ++P)
      O = w[P], !(!O || O.fill === !1) && (O.fill = rP(w, P, f.propagate));
  },
  beforeDraw(_, a, f) {
    const y = f.drawTime === "beforeDraw", w = _.getSortedVisibleDatasetMetas(), b = _.chartArea;
    for (let P = w.length - 1; P >= 0; --P) {
      const i = w[P].$filler;
      i && (i.line.updateControlPoints(b, i.axis), y && i.fill && Og(_.ctx, i, b));
    }
  },
  beforeDatasetsDraw(_, a, f) {
    if (f.drawTime !== "beforeDatasetsDraw")
      return;
    const y = _.getSortedVisibleDatasetMetas();
    for (let w = y.length - 1; w >= 0; --w) {
      const b = y[w].$filler;
      U1(b) && Og(_.ctx, b, _.chartArea);
    }
  },
  beforeDatasetDraw(_, a, f) {
    const y = a.meta.$filler;
    !U1(y) || f.drawTime !== "beforeDatasetDraw" || Og(_.ctx, y, _.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const H1 = (_, a) => {
  let { boxHeight: f = a, boxWidth: y = a } = _;
  return _.usePointStyle && (f = Math.min(f, a), y = _.pointStyleWidth || Math.min(y, a)), {
    boxWidth: y,
    boxHeight: f,
    itemHeight: Math.max(a, f)
  };
}, TP = (_, a) => _ !== null && a !== null && _.datasetIndex === a.datasetIndex && _.index === a.index;
class q1 extends Vl {
  constructor(a) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(a, f, y) {
    this.maxWidth = a, this.maxHeight = f, this._margins = y, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const a = this.options.labels || {};
    let f = is(a.generateLabels, [
      this.chart
    ], this) || [];
    a.filter && (f = f.filter((y) => a.filter(y, this.chart.data))), a.sort && (f = f.sort((y, w) => a.sort(y, w, this.chart.data))), this.options.reverse && f.reverse(), this.legendItems = f;
  }
  fit() {
    const { options: a, ctx: f } = this;
    if (!a.display) {
      this.width = this.height = 0;
      return;
    }
    const y = a.labels, w = tr(y.font), b = w.size, P = this._computeTitleHeight(), { boxWidth: i, itemHeight: O } = H1(y, b);
    let Z, Y;
    f.font = w.string, this.isHorizontal() ? (Z = this.maxWidth, Y = this._fitRows(P, b, i, O) + 10) : (Y = this.maxHeight, Z = this._fitCols(P, w, i, O) + 10), this.width = Math.min(Z, a.maxWidth || this.maxWidth), this.height = Math.min(Y, a.maxHeight || this.maxHeight);
  }
  _fitRows(a, f, y, w) {
    const { ctx: b, maxWidth: P, options: { labels: { padding: i } } } = this, O = this.legendHitBoxes = [], Z = this.lineWidths = [
      0
    ], Y = w + i;
    let J = a;
    b.textAlign = "left", b.textBaseline = "middle";
    let ae = -1, ue = -Y;
    return this.legendItems.forEach((Se, we) => {
      const qe = y + f / 2 + b.measureText(Se.text).width;
      (we === 0 || Z[Z.length - 1] + qe + 2 * i > P) && (J += Y, Z[Z.length - (we > 0 ? 0 : 1)] = 0, ue += Y, ae++), O[we] = {
        left: 0,
        top: ue,
        row: ae,
        width: qe,
        height: w
      }, Z[Z.length - 1] += qe + i;
    }), J;
  }
  _fitCols(a, f, y, w) {
    const { ctx: b, maxHeight: P, options: { labels: { padding: i } } } = this, O = this.legendHitBoxes = [], Z = this.columnSizes = [], Y = P - a;
    let J = i, ae = 0, ue = 0, Se = 0, we = 0;
    return this.legendItems.forEach((qe, Ge) => {
      const { itemWidth: lt, itemHeight: Et } = SP(y, f, b, qe, w);
      Ge > 0 && ue + Et + 2 * i > Y && (J += ae + i, Z.push({
        width: ae,
        height: ue
      }), Se += ae + i, we++, ae = ue = 0), O[Ge] = {
        left: Se,
        top: ue,
        col: we,
        width: lt,
        height: Et
      }, ae = Math.max(ae, lt), ue += Et + i;
    }), J += ae, Z.push({
      width: ae,
      height: ue
    }), J;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const a = this._computeTitleHeight(), { legendHitBoxes: f, options: { align: y, labels: { padding: w }, rtl: b } } = this, P = qu(b, this.left, this.width);
    if (this.isHorizontal()) {
      let i = 0, O = Ur(y, this.left + w, this.right - this.lineWidths[i]);
      for (const Z of f)
        i !== Z.row && (i = Z.row, O = Ur(y, this.left + w, this.right - this.lineWidths[i])), Z.top += this.top + a + w, Z.left = P.leftForLtr(P.x(O), Z.width), O += Z.width + w;
    } else {
      let i = 0, O = Ur(y, this.top + a + w, this.bottom - this.columnSizes[i].height);
      for (const Z of f)
        Z.col !== i && (i = Z.col, O = Ur(y, this.top + a + w, this.bottom - this.columnSizes[i].height)), Z.top = O, Z.left += this.left + w, Z.left = P.leftForLtr(P.x(Z.left), Z.width), O += Z.height + w;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const a = this.ctx;
      Um(a, this), this._draw(), jm(a);
    }
  }
  _draw() {
    const { options: a, columnSizes: f, lineWidths: y, ctx: w } = this, { align: b, labels: P } = a, i = ys.color, O = qu(a.rtl, this.left, this.width), Z = tr(P.font), { padding: Y } = P, J = Z.size, ae = J / 2;
    let ue;
    this.drawTitle(), w.textAlign = O.textAlign("left"), w.textBaseline = "middle", w.lineWidth = 0.5, w.font = Z.string;
    const { boxWidth: Se, boxHeight: we, itemHeight: qe } = H1(P, J), Ge = function(Vt, pt, Gt) {
      if (isNaN(Se) || Se <= 0 || isNaN(we) || we < 0)
        return;
      w.save();
      const ui = en(Gt.lineWidth, 1);
      if (w.fillStyle = en(Gt.fillStyle, i), w.lineCap = en(Gt.lineCap, "butt"), w.lineDashOffset = en(Gt.lineDashOffset, 0), w.lineJoin = en(Gt.lineJoin, "miter"), w.lineWidth = ui, w.strokeStyle = en(Gt.strokeStyle, i), w.setLineDash(en(Gt.lineDash, [])), P.usePointStyle) {
        const kt = {
          radius: we * Math.SQRT2 / 2,
          pointStyle: Gt.pointStyle,
          rotation: Gt.rotation,
          borderWidth: ui
        }, At = O.xPlus(Vt, Se / 2), Si = pt + ae;
        Sb(w, kt, At, Si, P.pointStyleWidth && Se);
      } else {
        const kt = pt + Math.max((J - we) / 2, 0), At = O.leftForLtr(Vt, Se), Si = zh(Gt.borderRadius);
        w.beginPath(), Object.values(Si).some((An) => An !== 0) ? kf(w, {
          x: At,
          y: kt,
          w: Se,
          h: we,
          radius: Si
        }) : w.rect(At, kt, Se, we), w.fill(), ui !== 0 && w.stroke();
      }
      w.restore();
    }, lt = function(Vt, pt, Gt) {
      Rh(w, Gt.text, Vt, pt + qe / 2, Z, {
        strikethrough: Gt.hidden,
        textAlign: O.textAlign(Gt.textAlign)
      });
    }, Et = this.isHorizontal(), ut = this._computeTitleHeight();
    Et ? ue = {
      x: Ur(b, this.left + Y, this.right - y[0]),
      y: this.top + Y + ut,
      line: 0
    } : ue = {
      x: this.left + Y,
      y: Ur(b, this.top + ut + Y, this.bottom - f[0].height),
      line: 0
    }, zb(this.ctx, a.textDirection);
    const bt = qe + Y;
    this.legendItems.forEach((Vt, pt) => {
      w.strokeStyle = Vt.fontColor, w.fillStyle = Vt.fontColor;
      const Gt = w.measureText(Vt.text).width, ui = O.textAlign(Vt.textAlign || (Vt.textAlign = P.textAlign)), kt = Se + ae + Gt;
      let At = ue.x, Si = ue.y;
      O.setWidth(this.width), Et ? pt > 0 && At + kt + Y > this.right && (Si = ue.y += bt, ue.line++, At = ue.x = Ur(b, this.left + Y, this.right - y[ue.line])) : pt > 0 && Si + bt > this.bottom && (At = ue.x = At + f[ue.line].width + Y, ue.line++, Si = ue.y = Ur(b, this.top + ut + Y, this.bottom - f[ue.line].height));
      const An = O.x(At);
      if (Ge(An, Si, Vt), At = ZS(ui, At + Se + ae, Et ? At + kt : this.right, a.rtl), lt(O.x(At), Si, Vt), Et)
        ue.x += kt + Y;
      else if (typeof Vt.text != "string") {
        const hn = Z.lineHeight;
        ue.y += nw(Vt, hn) + Y;
      } else
        ue.y += bt;
    }), Db(this.ctx, a.textDirection);
  }
  drawTitle() {
    const a = this.options, f = a.title, y = tr(f.font), w = Gr(f.padding);
    if (!f.display)
      return;
    const b = qu(a.rtl, this.left, this.width), P = this.ctx, i = f.position, O = y.size / 2, Z = w.top + O;
    let Y, J = this.left, ae = this.width;
    if (this.isHorizontal())
      ae = Math.max(...this.lineWidths), Y = this.top + Z, J = Ur(a.align, J, this.right - ae);
    else {
      const Se = this.columnSizes.reduce((we, qe) => Math.max(we, qe.height), 0);
      Y = Z + Ur(a.align, this.top, this.bottom - Se - a.labels.padding - this._computeTitleHeight());
    }
    const ue = Ur(i, J, J + ae);
    P.textAlign = b.textAlign(ry(i)), P.textBaseline = "middle", P.strokeStyle = f.color, P.fillStyle = f.color, P.font = y.string, Rh(P, f.text, ue, Y, y);
  }
  _computeTitleHeight() {
    const a = this.options.title, f = tr(a.font), y = Gr(a.padding);
    return a.display ? f.lineHeight + y.height : 0;
  }
  _getLegendItemAt(a, f) {
    let y, w, b;
    if (Fl(a, this.left, this.right) && Fl(f, this.top, this.bottom)) {
      for (b = this.legendHitBoxes, y = 0; y < b.length; ++y)
        if (w = b[y], Fl(a, w.left, w.left + w.width) && Fl(f, w.top, w.top + w.height))
          return this.legendItems[y];
    }
    return null;
  }
  handleEvent(a) {
    const f = this.options;
    if (!AP(a.type, f))
      return;
    const y = this._getLegendItemAt(a.x, a.y);
    if (a.type === "mousemove" || a.type === "mouseout") {
      const w = this._hoveredItem, b = TP(w, y);
      w && !b && is(f.onLeave, [
        a,
        w,
        this
      ], this), this._hoveredItem = y, y && !b && is(f.onHover, [
        a,
        y,
        this
      ], this);
    } else
      y && is(f.onClick, [
        a,
        y,
        this
      ], this);
  }
}
function SP(_, a, f, y, w) {
  const b = MP(y, _, a, f), P = EP(w, y, a.lineHeight);
  return {
    itemWidth: b,
    itemHeight: P
  };
}
function MP(_, a, f, y) {
  let w = _.text;
  return w && typeof w != "string" && (w = w.reduce((b, P) => b.length > P.length ? b : P)), a + f.size / 2 + y.measureText(w).width;
}
function EP(_, a, f) {
  let y = _;
  return typeof a.text != "string" && (y = nw(a, f)), y;
}
function nw(_, a) {
  const f = _.text ? _.text.length : 0;
  return a * f;
}
function AP(_, a) {
  return !!((_ === "mousemove" || _ === "mouseout") && (a.onHover || a.onLeave) || a.onClick && (_ === "click" || _ === "mouseup"));
}
var PP = {
  id: "legend",
  _element: q1,
  start(_, a, f) {
    const y = _.legend = new q1({
      ctx: _.ctx,
      options: f,
      chart: _
    });
    jr.configure(_, y, f), jr.addBox(_, y);
  },
  stop(_) {
    jr.removeBox(_, _.legend), delete _.legend;
  },
  beforeUpdate(_, a, f) {
    const y = _.legend;
    jr.configure(_, y, f), y.options = f;
  },
  afterUpdate(_) {
    const a = _.legend;
    a.buildLabels(), a.adjustHitBoxes();
  },
  afterEvent(_, a) {
    a.replay || _.legend.handleEvent(a.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(_, a, f) {
      const y = a.datasetIndex, w = f.chart;
      w.isDatasetVisible(y) ? (w.hide(y), a.hidden = !0) : (w.show(y), a.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (_) => _.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(_) {
        const a = _.data.datasets, { labels: { usePointStyle: f, pointStyle: y, textAlign: w, color: b, useBorderRadius: P, borderRadius: i } } = _.legend.options;
        return _._getSortedDatasetMetas().map((O) => {
          const Z = O.controller.getStyle(f ? 0 : void 0), Y = Gr(Z.borderWidth);
          return {
            text: a[O.index].label,
            fillStyle: Z.backgroundColor,
            fontColor: b,
            hidden: !O.visible,
            lineCap: Z.borderCapStyle,
            lineDash: Z.borderDash,
            lineDashOffset: Z.borderDashOffset,
            lineJoin: Z.borderJoinStyle,
            lineWidth: (Y.width + Y.height) / 4,
            strokeStyle: Z.borderColor,
            pointStyle: y || Z.pointStyle,
            rotation: Z.rotation,
            textAlign: w || Z.textAlign,
            borderRadius: P && (i || Z.borderRadius),
            datasetIndex: O.index
          };
        }, this);
      }
    },
    title: {
      color: (_) => _.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (_) => !_.startsWith("on"),
    labels: {
      _scriptable: (_) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(_)
    }
  }
};
class my extends Vl {
  constructor(a) {
    super(), this.chart = a.chart, this.options = a.options, this.ctx = a.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(a, f) {
    const y = this.options;
    if (this.left = 0, this.top = 0, !y.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = a, this.height = this.bottom = f;
    const w = hs(y.text) ? y.text.length : 1;
    this._padding = Gr(y.padding);
    const b = w * tr(y.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = b : this.width = b;
  }
  isHorizontal() {
    const a = this.options.position;
    return a === "top" || a === "bottom";
  }
  _drawArgs(a) {
    const { top: f, left: y, bottom: w, right: b, options: P } = this, i = P.align;
    let O = 0, Z, Y, J;
    return this.isHorizontal() ? (Y = Ur(i, y, b), J = f + a, Z = b - y) : (P.position === "left" ? (Y = y + a, J = Ur(i, w, f), O = ds * -0.5) : (Y = b - a, J = Ur(i, f, w), O = ds * 0.5), Z = w - f), {
      titleX: Y,
      titleY: J,
      maxWidth: Z,
      rotation: O
    };
  }
  draw() {
    const a = this.ctx, f = this.options;
    if (!f.display)
      return;
    const y = tr(f.font), b = y.lineHeight / 2 + this._padding.top, { titleX: P, titleY: i, maxWidth: O, rotation: Z } = this._drawArgs(b);
    Rh(a, f.text, 0, 0, y, {
      color: f.color,
      maxWidth: O,
      rotation: Z,
      textAlign: ry(f.align),
      textBaseline: "middle",
      translation: [
        P,
        i
      ]
    });
  }
}
function CP(_, a) {
  const f = new my({
    ctx: _.ctx,
    options: a,
    chart: _
  });
  jr.configure(_, f, a), jr.addBox(_, f), _.titleBlock = f;
}
var IP = {
  id: "title",
  _element: my,
  start(_, a, f) {
    CP(_, f);
  },
  stop(_) {
    const a = _.titleBlock;
    jr.removeBox(_, a), delete _.titleBlock;
  },
  beforeUpdate(_, a, f) {
    const y = _.titleBlock;
    jr.configure(_, y, f), y.options = f;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const gm = /* @__PURE__ */ new WeakMap();
var LP = {
  id: "subtitle",
  start(_, a, f) {
    const y = new my({
      ctx: _.ctx,
      options: f,
      chart: _
    });
    jr.configure(_, y, f), jr.addBox(_, y), gm.set(_, y);
  },
  stop(_) {
    jr.removeBox(_, gm.get(_)), gm.delete(_);
  },
  beforeUpdate(_, a, f) {
    const y = gm.get(_);
    jr.configure(_, y, f), y.options = f;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "normal"
    },
    fullSize: !0,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Tf = {
  average(_) {
    if (!_.length)
      return !1;
    let a, f, y = /* @__PURE__ */ new Set(), w = 0, b = 0;
    for (a = 0, f = _.length; a < f; ++a) {
      const i = _[a].element;
      if (i && i.hasValue()) {
        const O = i.tooltipPosition();
        y.add(O.x), w += O.y, ++b;
      }
    }
    return b === 0 || y.size === 0 ? !1 : {
      x: [
        ...y
      ].reduce((i, O) => i + O) / y.size,
      y: w / b
    };
  },
  nearest(_, a) {
    if (!_.length)
      return !1;
    let f = a.x, y = a.y, w = Number.POSITIVE_INFINITY, b, P, i;
    for (b = 0, P = _.length; b < P; ++b) {
      const O = _[b].element;
      if (O && O.hasValue()) {
        const Z = O.getCenterPoint(), Y = Bg(a, Z);
        Y < w && (w = Y, i = O);
      }
    }
    if (i) {
      const O = i.tooltipPosition();
      f = O.x, y = O.y;
    }
    return {
      x: f,
      y
    };
  }
};
function sl(_, a) {
  return a && (hs(a) ? Array.prototype.push.apply(_, a) : _.push(a)), _;
}
function kl(_) {
  return (typeof _ == "string" || _ instanceof String) && _.indexOf(`
`) > -1 ? _.split(`
`) : _;
}
function zP(_, a) {
  const { element: f, datasetIndex: y, index: w } = a, b = _.getDatasetMeta(y).controller, { label: P, value: i } = b.getLabelAndValue(w);
  return {
    chart: _,
    label: P,
    parsed: b.getParsed(w),
    raw: _.data.datasets[y].data[w],
    formattedValue: i,
    dataset: b.getDataset(),
    dataIndex: w,
    datasetIndex: y,
    element: f
  };
}
function W1(_, a) {
  const f = _.chart.ctx, { body: y, footer: w, title: b } = _, { boxWidth: P, boxHeight: i } = a, O = tr(a.bodyFont), Z = tr(a.titleFont), Y = tr(a.footerFont), J = b.length, ae = w.length, ue = y.length, Se = Gr(a.padding);
  let we = Se.height, qe = 0, Ge = y.reduce((ut, bt) => ut + bt.before.length + bt.lines.length + bt.after.length, 0);
  if (Ge += _.beforeBody.length + _.afterBody.length, J && (we += J * Z.lineHeight + (J - 1) * a.titleSpacing + a.titleMarginBottom), Ge) {
    const ut = a.displayColors ? Math.max(i, O.lineHeight) : O.lineHeight;
    we += ue * ut + (Ge - ue) * O.lineHeight + (Ge - 1) * a.bodySpacing;
  }
  ae && (we += a.footerMarginTop + ae * Y.lineHeight + (ae - 1) * a.footerSpacing);
  let lt = 0;
  const Et = function(ut) {
    qe = Math.max(qe, f.measureText(ut).width + lt);
  };
  return f.save(), f.font = Z.string, Zn(_.title, Et), f.font = O.string, Zn(_.beforeBody.concat(_.afterBody), Et), lt = a.displayColors ? P + 2 + a.boxPadding : 0, Zn(y, (ut) => {
    Zn(ut.before, Et), Zn(ut.lines, Et), Zn(ut.after, Et);
  }), lt = 0, f.font = Y.string, Zn(_.footer, Et), f.restore(), qe += Se.width, {
    width: qe,
    height: we
  };
}
function DP(_, a) {
  const { y: f, height: y } = a;
  return f < y / 2 ? "top" : f > _.height - y / 2 ? "bottom" : "center";
}
function kP(_, a, f, y) {
  const { x: w, width: b } = y, P = f.caretSize + f.caretPadding;
  if (_ === "left" && w + b + P > a.width || _ === "right" && w - b - P < 0)
    return !0;
}
function RP(_, a, f, y) {
  const { x: w, width: b } = f, { width: P, chartArea: { left: i, right: O } } = _;
  let Z = "center";
  return y === "center" ? Z = w <= (i + O) / 2 ? "left" : "right" : w <= b / 2 ? Z = "left" : w >= P - b / 2 && (Z = "right"), kP(Z, _, a, f) && (Z = "center"), Z;
}
function $1(_, a, f) {
  const y = f.yAlign || a.yAlign || DP(_, f);
  return {
    xAlign: f.xAlign || a.xAlign || RP(_, a, f, y),
    yAlign: y
  };
}
function OP(_, a) {
  let { x: f, width: y } = _;
  return a === "right" ? f -= y : a === "center" && (f -= y / 2), f;
}
function FP(_, a, f) {
  let { y, height: w } = _;
  return a === "top" ? y += f : a === "bottom" ? y -= w + f : y -= w / 2, y;
}
function X1(_, a, f, y) {
  const { caretSize: w, caretPadding: b, cornerRadius: P } = _, { xAlign: i, yAlign: O } = f, Z = w + b, { topLeft: Y, topRight: J, bottomLeft: ae, bottomRight: ue } = zh(P);
  let Se = OP(a, i);
  const we = FP(a, O, Z);
  return O === "center" ? i === "left" ? Se += Z : i === "right" && (Se -= Z) : i === "left" ? Se -= Math.max(Y, ae) + w : i === "right" && (Se += Math.max(J, ue) + w), {
    x: gr(Se, 0, y.width - a.width),
    y: gr(we, 0, y.height - a.height)
  };
}
function ym(_, a, f) {
  const y = Gr(f.padding);
  return a === "center" ? _.x + _.width / 2 : a === "right" ? _.x + _.width - y.right : _.x + y.left;
}
function Y1(_) {
  return sl([], kl(_));
}
function BP(_, a, f) {
  return kc(_, {
    tooltip: a,
    tooltipItems: f,
    type: "tooltip"
  });
}
function K1(_, a) {
  const f = a && a.dataset && a.dataset.tooltip && a.dataset.tooltip.callbacks;
  return f ? _.override(f) : _;
}
const sw = {
  beforeTitle: zl,
  title(_) {
    if (_.length > 0) {
      const a = _[0], f = a.chart.data.labels, y = f ? f.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return a.dataset.label || "";
      if (a.label)
        return a.label;
      if (y > 0 && a.dataIndex < y)
        return f[a.dataIndex];
    }
    return "";
  },
  afterTitle: zl,
  beforeBody: zl,
  beforeLabel: zl,
  label(_) {
    if (this && this.options && this.options.mode === "dataset")
      return _.label + ": " + _.formattedValue || _.formattedValue;
    let a = _.dataset.label || "";
    a && (a += ": ");
    const f = _.formattedValue;
    return En(f) || (a += f), a;
  },
  labelColor(_) {
    const f = _.chart.getDatasetMeta(_.datasetIndex).controller.getStyle(_.dataIndex);
    return {
      borderColor: f.borderColor,
      backgroundColor: f.backgroundColor,
      borderWidth: f.borderWidth,
      borderDash: f.borderDash,
      borderDashOffset: f.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(_) {
    const f = _.chart.getDatasetMeta(_.datasetIndex).controller.getStyle(_.dataIndex);
    return {
      pointStyle: f.pointStyle,
      rotation: f.rotation
    };
  },
  afterLabel: zl,
  afterBody: zl,
  beforeFooter: zl,
  footer: zl,
  afterFooter: zl
};
function mo(_, a, f, y) {
  const w = _[a].call(f, y);
  return typeof w > "u" ? sw[a].call(f, y) : w;
}
class Wg extends Vl {
  constructor(a) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = a.chart, this.options = a.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(a) {
    this.options = a, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const a = this._cachedAnimations;
    if (a)
      return a;
    const f = this.chart, y = this.options.setContext(this.getContext()), w = y.enabled && f.options.animation && y.animations, b = new Fb(this.chart, w);
    return w._cacheable && (this._cachedAnimations = Object.freeze(b)), b;
  }
  getContext() {
    return this.$context || (this.$context = BP(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(a, f) {
    const { callbacks: y } = f, w = mo(y, "beforeTitle", this, a), b = mo(y, "title", this, a), P = mo(y, "afterTitle", this, a);
    let i = [];
    return i = sl(i, kl(w)), i = sl(i, kl(b)), i = sl(i, kl(P)), i;
  }
  getBeforeBody(a, f) {
    return Y1(mo(f.callbacks, "beforeBody", this, a));
  }
  getBody(a, f) {
    const { callbacks: y } = f, w = [];
    return Zn(a, (b) => {
      const P = {
        before: [],
        lines: [],
        after: []
      }, i = K1(y, b);
      sl(P.before, kl(mo(i, "beforeLabel", this, b))), sl(P.lines, mo(i, "label", this, b)), sl(P.after, kl(mo(i, "afterLabel", this, b))), w.push(P);
    }), w;
  }
  getAfterBody(a, f) {
    return Y1(mo(f.callbacks, "afterBody", this, a));
  }
  getFooter(a, f) {
    const { callbacks: y } = f, w = mo(y, "beforeFooter", this, a), b = mo(y, "footer", this, a), P = mo(y, "afterFooter", this, a);
    let i = [];
    return i = sl(i, kl(w)), i = sl(i, kl(b)), i = sl(i, kl(P)), i;
  }
  _createItems(a) {
    const f = this._active, y = this.chart.data, w = [], b = [], P = [];
    let i = [], O, Z;
    for (O = 0, Z = f.length; O < Z; ++O)
      i.push(zP(this.chart, f[O]));
    return a.filter && (i = i.filter((Y, J, ae) => a.filter(Y, J, ae, y))), a.itemSort && (i = i.sort((Y, J) => a.itemSort(Y, J, y))), Zn(i, (Y) => {
      const J = K1(a.callbacks, Y);
      w.push(mo(J, "labelColor", this, Y)), b.push(mo(J, "labelPointStyle", this, Y)), P.push(mo(J, "labelTextColor", this, Y));
    }), this.labelColors = w, this.labelPointStyles = b, this.labelTextColors = P, this.dataPoints = i, i;
  }
  update(a, f) {
    const y = this.options.setContext(this.getContext()), w = this._active;
    let b, P = [];
    if (!w.length)
      this.opacity !== 0 && (b = {
        opacity: 0
      });
    else {
      const i = Tf[y.position].call(this, w, this._eventPosition);
      P = this._createItems(y), this.title = this.getTitle(P, y), this.beforeBody = this.getBeforeBody(P, y), this.body = this.getBody(P, y), this.afterBody = this.getAfterBody(P, y), this.footer = this.getFooter(P, y);
      const O = this._size = W1(this, y), Z = Object.assign({}, i, O), Y = $1(this.chart, y, Z), J = X1(y, Z, Y, this.chart);
      this.xAlign = Y.xAlign, this.yAlign = Y.yAlign, b = {
        opacity: 1,
        x: J.x,
        y: J.y,
        width: O.width,
        height: O.height,
        caretX: i.x,
        caretY: i.y
      };
    }
    this._tooltipItems = P, this.$context = void 0, b && this._resolveAnimations().update(this, b), a && y.external && y.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: f
    });
  }
  drawCaret(a, f, y, w) {
    const b = this.getCaretPosition(a, y, w);
    f.lineTo(b.x1, b.y1), f.lineTo(b.x2, b.y2), f.lineTo(b.x3, b.y3);
  }
  getCaretPosition(a, f, y) {
    const { xAlign: w, yAlign: b } = this, { caretSize: P, cornerRadius: i } = y, { topLeft: O, topRight: Z, bottomLeft: Y, bottomRight: J } = zh(i), { x: ae, y: ue } = a, { width: Se, height: we } = f;
    let qe, Ge, lt, Et, ut, bt;
    return b === "center" ? (ut = ue + we / 2, w === "left" ? (qe = ae, Ge = qe - P, Et = ut + P, bt = ut - P) : (qe = ae + Se, Ge = qe + P, Et = ut - P, bt = ut + P), lt = qe) : (w === "left" ? Ge = ae + Math.max(O, Y) + P : w === "right" ? Ge = ae + Se - Math.max(Z, J) - P : Ge = this.caretX, b === "top" ? (Et = ue, ut = Et - P, qe = Ge - P, lt = Ge + P) : (Et = ue + we, ut = Et + P, qe = Ge + P, lt = Ge - P), bt = Et), {
      x1: qe,
      x2: Ge,
      x3: lt,
      y1: Et,
      y2: ut,
      y3: bt
    };
  }
  drawTitle(a, f, y) {
    const w = this.title, b = w.length;
    let P, i, O;
    if (b) {
      const Z = qu(y.rtl, this.x, this.width);
      for (a.x = ym(this, y.titleAlign, y), f.textAlign = Z.textAlign(y.titleAlign), f.textBaseline = "middle", P = tr(y.titleFont), i = y.titleSpacing, f.fillStyle = y.titleColor, f.font = P.string, O = 0; O < b; ++O)
        f.fillText(w[O], Z.x(a.x), a.y + P.lineHeight / 2), a.y += P.lineHeight + i, O + 1 === b && (a.y += y.titleMarginBottom - i);
    }
  }
  _drawColorBox(a, f, y, w, b) {
    const P = this.labelColors[y], i = this.labelPointStyles[y], { boxHeight: O, boxWidth: Z } = b, Y = tr(b.bodyFont), J = ym(this, "left", b), ae = w.x(J), ue = O < Y.lineHeight ? (Y.lineHeight - O) / 2 : 0, Se = f.y + ue;
    if (b.usePointStyle) {
      const we = {
        radius: Math.min(Z, O) / 2,
        pointStyle: i.pointStyle,
        rotation: i.rotation,
        borderWidth: 1
      }, qe = w.leftForLtr(ae, Z) + Z / 2, Ge = Se + O / 2;
      a.strokeStyle = b.multiKeyBackground, a.fillStyle = b.multiKeyBackground, Vg(a, we, qe, Ge), a.strokeStyle = P.borderColor, a.fillStyle = P.backgroundColor, Vg(a, we, qe, Ge);
    } else {
      a.lineWidth = yn(P.borderWidth) ? Math.max(...Object.values(P.borderWidth)) : P.borderWidth || 1, a.strokeStyle = P.borderColor, a.setLineDash(P.borderDash || []), a.lineDashOffset = P.borderDashOffset || 0;
      const we = w.leftForLtr(ae, Z), qe = w.leftForLtr(w.xPlus(ae, 1), Z - 2), Ge = zh(P.borderRadius);
      Object.values(Ge).some((lt) => lt !== 0) ? (a.beginPath(), a.fillStyle = b.multiKeyBackground, kf(a, {
        x: we,
        y: Se,
        w: Z,
        h: O,
        radius: Ge
      }), a.fill(), a.stroke(), a.fillStyle = P.backgroundColor, a.beginPath(), kf(a, {
        x: qe,
        y: Se + 1,
        w: Z - 2,
        h: O - 2,
        radius: Ge
      }), a.fill()) : (a.fillStyle = b.multiKeyBackground, a.fillRect(we, Se, Z, O), a.strokeRect(we, Se, Z, O), a.fillStyle = P.backgroundColor, a.fillRect(qe, Se + 1, Z - 2, O - 2));
    }
    a.fillStyle = this.labelTextColors[y];
  }
  drawBody(a, f, y) {
    const { body: w } = this, { bodySpacing: b, bodyAlign: P, displayColors: i, boxHeight: O, boxWidth: Z, boxPadding: Y } = y, J = tr(y.bodyFont);
    let ae = J.lineHeight, ue = 0;
    const Se = qu(y.rtl, this.x, this.width), we = function(Gt) {
      f.fillText(Gt, Se.x(a.x + ue), a.y + ae / 2), a.y += ae + b;
    }, qe = Se.textAlign(P);
    let Ge, lt, Et, ut, bt, Vt, pt;
    for (f.textAlign = P, f.textBaseline = "middle", f.font = J.string, a.x = ym(this, qe, y), f.fillStyle = y.bodyColor, Zn(this.beforeBody, we), ue = i && qe !== "right" ? P === "center" ? Z / 2 + Y : Z + 2 + Y : 0, ut = 0, Vt = w.length; ut < Vt; ++ut) {
      for (Ge = w[ut], lt = this.labelTextColors[ut], f.fillStyle = lt, Zn(Ge.before, we), Et = Ge.lines, i && Et.length && (this._drawColorBox(f, a, ut, Se, y), ae = Math.max(J.lineHeight, O)), bt = 0, pt = Et.length; bt < pt; ++bt)
        we(Et[bt]), ae = J.lineHeight;
      Zn(Ge.after, we);
    }
    ue = 0, ae = J.lineHeight, Zn(this.afterBody, we), a.y -= b;
  }
  drawFooter(a, f, y) {
    const w = this.footer, b = w.length;
    let P, i;
    if (b) {
      const O = qu(y.rtl, this.x, this.width);
      for (a.x = ym(this, y.footerAlign, y), a.y += y.footerMarginTop, f.textAlign = O.textAlign(y.footerAlign), f.textBaseline = "middle", P = tr(y.footerFont), f.fillStyle = y.footerColor, f.font = P.string, i = 0; i < b; ++i)
        f.fillText(w[i], O.x(a.x), a.y + P.lineHeight / 2), a.y += P.lineHeight + y.footerSpacing;
    }
  }
  drawBackground(a, f, y, w) {
    const { xAlign: b, yAlign: P } = this, { x: i, y: O } = a, { width: Z, height: Y } = y, { topLeft: J, topRight: ae, bottomLeft: ue, bottomRight: Se } = zh(w.cornerRadius);
    f.fillStyle = w.backgroundColor, f.strokeStyle = w.borderColor, f.lineWidth = w.borderWidth, f.beginPath(), f.moveTo(i + J, O), P === "top" && this.drawCaret(a, f, y, w), f.lineTo(i + Z - ae, O), f.quadraticCurveTo(i + Z, O, i + Z, O + ae), P === "center" && b === "right" && this.drawCaret(a, f, y, w), f.lineTo(i + Z, O + Y - Se), f.quadraticCurveTo(i + Z, O + Y, i + Z - Se, O + Y), P === "bottom" && this.drawCaret(a, f, y, w), f.lineTo(i + ue, O + Y), f.quadraticCurveTo(i, O + Y, i, O + Y - ue), P === "center" && b === "left" && this.drawCaret(a, f, y, w), f.lineTo(i, O + J), f.quadraticCurveTo(i, O, i + J, O), f.closePath(), f.fill(), w.borderWidth > 0 && f.stroke();
  }
  _updateAnimationTarget(a) {
    const f = this.chart, y = this.$animations, w = y && y.x, b = y && y.y;
    if (w || b) {
      const P = Tf[a.position].call(this, this._active, this._eventPosition);
      if (!P)
        return;
      const i = this._size = W1(this, a), O = Object.assign({}, P, this._size), Z = $1(f, a, O), Y = X1(a, O, Z, f);
      (w._to !== Y.x || b._to !== Y.y) && (this.xAlign = Z.xAlign, this.yAlign = Z.yAlign, this.width = i.width, this.height = i.height, this.caretX = P.x, this.caretY = P.y, this._resolveAnimations().update(this, Y));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(a) {
    const f = this.options.setContext(this.getContext());
    let y = this.opacity;
    if (!y)
      return;
    this._updateAnimationTarget(f);
    const w = {
      width: this.width,
      height: this.height
    }, b = {
      x: this.x,
      y: this.y
    };
    y = Math.abs(y) < 1e-3 ? 0 : y;
    const P = Gr(f.padding), i = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    f.enabled && i && (a.save(), a.globalAlpha = y, this.drawBackground(b, a, w, f), zb(a, f.textDirection), b.y += P.top, this.drawTitle(b, a, f), this.drawBody(b, a, f), this.drawFooter(b, a, f), Db(a, f.textDirection), a.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(a, f) {
    const y = this._active, w = a.map(({ datasetIndex: i, index: O }) => {
      const Z = this.chart.getDatasetMeta(i);
      if (!Z)
        throw new Error("Cannot find a dataset at index " + i);
      return {
        datasetIndex: i,
        element: Z.data[O],
        index: O
      };
    }), b = !Lm(y, w), P = this._positionChanged(w, f);
    (b || P) && (this._active = w, this._eventPosition = f, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(a, f, y = !0) {
    if (f && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const w = this.options, b = this._active || [], P = this._getActiveElements(a, b, f, y), i = this._positionChanged(P, a), O = f || !Lm(P, b) || i;
    return O && (this._active = P, (w.enabled || w.external) && (this._eventPosition = {
      x: a.x,
      y: a.y
    }, this.update(!0, f))), O;
  }
  _getActiveElements(a, f, y, w) {
    const b = this.options;
    if (a.type === "mouseout")
      return [];
    if (!w)
      return f.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    const P = this.chart.getElementsAtEventForMode(a, b.mode, b, y);
    return b.reverse && P.reverse(), P;
  }
  _positionChanged(a, f) {
    const { caretX: y, caretY: w, options: b } = this, P = Tf[b.position].call(this, a, f);
    return P !== !1 && (y !== P.x || w !== P.y);
  }
}
Yt(Wg, "positioners", Tf);
var NP = {
  id: "tooltip",
  _element: Wg,
  positioners: Tf,
  afterInit(_, a, f) {
    f && (_.tooltip = new Wg({
      chart: _,
      options: f
    }));
  },
  beforeUpdate(_, a, f) {
    _.tooltip && _.tooltip.initialize(f);
  },
  reset(_, a, f) {
    _.tooltip && _.tooltip.initialize(f);
  },
  afterDraw(_) {
    const a = _.tooltip;
    if (a && a._willRender()) {
      const f = {
        tooltip: a
      };
      if (_.notifyPlugins("beforeTooltipDraw", {
        ...f,
        cancelable: !0
      }) === !1)
        return;
      a.draw(_.ctx), _.notifyPlugins("afterTooltipDraw", f);
    }
  },
  afterEvent(_, a) {
    if (_.tooltip) {
      const f = a.replay;
      _.tooltip.handleEvent(a.event, f, a.inChartArea) && (a.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (_, a) => a.bodyFont.size,
    boxWidth: (_, a) => a.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: sw
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (_) => _ !== "filter" && _ !== "itemSort" && _ !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
}, VP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: JA,
  Decimation: iP,
  Filler: wP,
  Legend: PP,
  SubTitle: LP,
  Title: IP,
  Tooltip: NP
});
const UP = (_, a, f, y) => (typeof a == "string" ? (f = _.push(a) - 1, y.unshift({
  index: f,
  label: a
})) : isNaN(a) && (f = null), f);
function jP(_, a, f, y) {
  const w = _.indexOf(a);
  if (w === -1)
    return UP(_, a, f, y);
  const b = _.lastIndexOf(a);
  return w !== b ? f : w;
}
const GP = (_, a) => _ === null ? null : gr(Math.round(_), 0, a);
function J1(_) {
  const a = this.getLabels();
  return _ >= 0 && _ < a.length ? a[_] : _;
}
class $g extends Oh {
  constructor(a) {
    super(a), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(a) {
    const f = this._addedLabels;
    if (f.length) {
      const y = this.getLabels();
      for (const { index: w, label: b } of f)
        y[w] === b && y.splice(w, 1);
      this._addedLabels = [];
    }
    super.init(a);
  }
  parse(a, f) {
    if (En(a))
      return null;
    const y = this.getLabels();
    return f = isFinite(f) && y[f] === a ? f : jP(y, a, en(f, a), this._addedLabels), GP(f, y.length - 1);
  }
  determineDataLimits() {
    const { minDefined: a, maxDefined: f } = this.getUserBounds();
    let { min: y, max: w } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (a || (y = 0), f || (w = this.getLabels().length - 1)), this.min = y, this.max = w;
  }
  buildTicks() {
    const a = this.min, f = this.max, y = this.options.offset, w = [];
    let b = this.getLabels();
    b = a === 0 && f === b.length - 1 ? b : b.slice(a, f + 1), this._valueRange = Math.max(b.length - (y ? 0 : 1), 1), this._startValue = this.min - (y ? 0.5 : 0);
    for (let P = a; P <= f; P++)
      w.push({
        value: P
      });
    return w;
  }
  getLabelForValue(a) {
    return J1.call(this, a);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(a) {
    return typeof a != "number" && (a = this.parse(a)), a === null ? NaN : this.getPixelForDecimal((a - this._startValue) / this._valueRange);
  }
  getPixelForTick(a) {
    const f = this.ticks;
    return a < 0 || a > f.length - 1 ? null : this.getPixelForValue(f[a].value);
  }
  getValueForPixel(a) {
    return Math.round(this._startValue + this.getDecimalForPixel(a) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
Yt($g, "id", "category"), Yt($g, "defaults", {
  ticks: {
    callback: J1
  }
});
function ZP(_, a) {
  const f = [], { bounds: w, step: b, min: P, max: i, precision: O, count: Z, maxTicks: Y, maxDigits: J, includeBounds: ae } = _, ue = b || 1, Se = Y - 1, { min: we, max: qe } = a, Ge = !En(P), lt = !En(i), Et = !En(Z), ut = (qe - we) / (J + 1);
  let bt = Wv((qe - we) / Se / ue) * ue, Vt, pt, Gt, ui;
  if (bt < 1e-14 && !Ge && !lt)
    return [
      {
        value: we
      },
      {
        value: qe
      }
    ];
  ui = Math.ceil(qe / bt) - Math.floor(we / bt), ui > Se && (bt = Wv(ui * bt / Se / ue) * ue), En(O) || (Vt = Math.pow(10, O), bt = Math.ceil(bt * Vt) / Vt), w === "ticks" ? (pt = Math.floor(we / bt) * bt, Gt = Math.ceil(qe / bt) * bt) : (pt = we, Gt = qe), Ge && lt && b && FS((i - P) / b, bt / 1e3) ? (ui = Math.round(Math.min((i - P) / bt, Y)), bt = (i - P) / ui, pt = P, Gt = i) : Et ? (pt = Ge ? P : pt, Gt = lt ? i : Gt, ui = Z - 1, bt = (Gt - pt) / ui) : (ui = (Gt - pt) / bt, Ef(ui, Math.round(ui), bt / 1e3) ? ui = Math.round(ui) : ui = Math.ceil(ui));
  const kt = Math.max($v(bt), $v(pt));
  Vt = Math.pow(10, En(O) ? kt : O), pt = Math.round(pt * Vt) / Vt, Gt = Math.round(Gt * Vt) / Vt;
  let At = 0;
  for (Ge && (ae && pt !== P ? (f.push({
    value: P
  }), pt < P && At++, Ef(Math.round((pt + At * bt) * Vt) / Vt, P, Q1(P, ut, _)) && At++) : pt < P && At++); At < ui; ++At) {
    const Si = Math.round((pt + At * bt) * Vt) / Vt;
    if (lt && Si > i)
      break;
    f.push({
      value: Si
    });
  }
  return lt && ae && Gt !== i ? f.length && Ef(f[f.length - 1].value, i, Q1(i, ut, _)) ? f[f.length - 1].value = i : f.push({
    value: i
  }) : (!lt || Gt === i) && f.push({
    value: Gt
  }), f;
}
function Q1(_, a, { horizontal: f, minRotation: y }) {
  const w = Ca(y), b = (f ? Math.sin(w) : Math.cos(w)) || 1e-3, P = 0.75 * a * ("" + _).length;
  return Math.min(a / b, P);
}
class Bm extends Oh {
  constructor(a) {
    super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(a, f) {
    return En(a) || (typeof a == "number" || a instanceof Number) && !isFinite(+a) ? null : +a;
  }
  handleTickRangeOptions() {
    const { beginAtZero: a } = this.options, { minDefined: f, maxDefined: y } = this.getUserBounds();
    let { min: w, max: b } = this;
    const P = (O) => w = f ? w : O, i = (O) => b = y ? b : O;
    if (a) {
      const O = ol(w), Z = ol(b);
      O < 0 && Z < 0 ? i(0) : O > 0 && Z > 0 && P(0);
    }
    if (w === b) {
      let O = b === 0 ? 1 : Math.abs(b * 0.05);
      i(b + O), a || P(w - O);
    }
    this.min = w, this.max = b;
  }
  getTickLimit() {
    const a = this.options.ticks;
    let { maxTicksLimit: f, stepSize: y } = a, w;
    return y ? (w = Math.ceil(this.max / y) - Math.floor(this.min / y) + 1, w > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${y} would result generating up to ${w} ticks. Limiting to 1000.`), w = 1e3)) : (w = this.computeTickLimit(), f = f || 11), f && (w = Math.min(f, w)), w;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const a = this.options, f = a.ticks;
    let y = this.getTickLimit();
    y = Math.max(2, y);
    const w = {
      maxTicks: y,
      bounds: a.bounds,
      min: a.min,
      max: a.max,
      precision: f.precision,
      step: f.stepSize,
      count: f.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: f.minRotation || 0,
      includeBounds: f.includeBounds !== !1
    }, b = this._range || this, P = ZP(w, b);
    return a.bounds === "ticks" && mb(P, this, "value"), a.reverse ? (P.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), P;
  }
  configure() {
    const a = this.ticks;
    let f = this.min, y = this.max;
    if (super.configure(), this.options.offset && a.length) {
      const w = (y - f) / Math.max(a.length - 1, 1) / 2;
      f -= w, y += w;
    }
    this._startValue = f, this._endValue = y, this._valueRange = y - f;
  }
  getLabelForValue(a) {
    return Nf(a, this.chart.options.locale, this.options.ticks.format);
  }
}
class Xg extends Bm {
  determineDataLimits() {
    const { min: a, max: f } = this.getMinMax(!0);
    this.min = Ps(a) ? a : 0, this.max = Ps(f) ? f : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const a = this.isHorizontal(), f = a ? this.width : this.height, y = Ca(this.options.ticks.minRotation), w = (a ? Math.sin(y) : Math.cos(y)) || 1e-3, b = this._resolveTickFontOptions(0);
    return Math.ceil(f / Math.min(40, b.lineHeight / w));
  }
  getPixelForValue(a) {
    return a === null ? NaN : this.getPixelForDecimal((a - this._startValue) / this._valueRange);
  }
  getValueForPixel(a) {
    return this._startValue + this.getDecimalForPixel(a) * this._valueRange;
  }
}
Yt(Xg, "id", "linear"), Yt(Xg, "defaults", {
  ticks: {
    callback: Vm.formatters.numeric
  }
});
const Of = (_) => Math.floor(Pc(_)), Ah = (_, a) => Math.pow(10, Of(_) + a);
function eb(_) {
  return _ / Math.pow(10, Of(_)) === 1;
}
function tb(_, a, f) {
  const y = Math.pow(10, f), w = Math.floor(_ / y);
  return Math.ceil(a / y) - w;
}
function HP(_, a) {
  const f = a - _;
  let y = Of(f);
  for (; tb(_, a, y) > 10; )
    y++;
  for (; tb(_, a, y) < 10; )
    y--;
  return Math.min(y, Of(_));
}
function qP(_, { min: a, max: f }) {
  a = Fo(_.min, a);
  const y = [], w = Of(a);
  let b = HP(a, f), P = b < 0 ? Math.pow(10, Math.abs(b)) : 1;
  const i = Math.pow(10, b), O = w > b ? Math.pow(10, w) : 0, Z = Math.round((a - O) * P) / P, Y = Math.floor((a - O) / i / 10) * i * 10;
  let J = Math.floor((Z - Y) / Math.pow(10, b)), ae = Fo(_.min, Math.round((O + Y + J * Math.pow(10, b)) * P) / P);
  for (; ae < f; )
    y.push({
      value: ae,
      major: eb(ae),
      significand: J
    }), J >= 10 ? J = J < 15 ? 15 : 20 : J++, J >= 20 && (b++, J = 2, P = b >= 0 ? 1 : P), ae = Math.round((O + Y + J * Math.pow(10, b)) * P) / P;
  const ue = Fo(_.max, ae);
  return y.push({
    value: ue,
    major: eb(ue),
    significand: J
  }), y;
}
class Yg extends Oh {
  constructor(a) {
    super(a), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;
  }
  parse(a, f) {
    const y = Bm.prototype.parse.apply(this, [
      a,
      f
    ]);
    if (y === 0) {
      this._zero = !0;
      return;
    }
    return Ps(y) && y > 0 ? y : null;
  }
  determineDataLimits() {
    const { min: a, max: f } = this.getMinMax(!0);
    this.min = Ps(a) ? Math.max(0, a) : null, this.max = Ps(f) ? Math.max(0, f) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !Ps(this._userMin) && (this.min = a === Ah(this.min, 0) ? Ah(this.min, -1) : Ah(this.min, 0)), this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined: a, maxDefined: f } = this.getUserBounds();
    let y = this.min, w = this.max;
    const b = (i) => y = a ? y : i, P = (i) => w = f ? w : i;
    y === w && (y <= 0 ? (b(1), P(10)) : (b(Ah(y, -1)), P(Ah(w, 1)))), y <= 0 && b(Ah(w, -1)), w <= 0 && P(Ah(y, 1)), this.min = y, this.max = w;
  }
  buildTicks() {
    const a = this.options, f = {
      min: this._userMin,
      max: this._userMax
    }, y = qP(f, this);
    return a.bounds === "ticks" && mb(y, this, "value"), a.reverse ? (y.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), y;
  }
  getLabelForValue(a) {
    return a === void 0 ? "0" : Nf(a, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const a = this.min;
    super.configure(), this._startValue = Pc(a), this._valueRange = Pc(this.max) - Pc(a);
  }
  getPixelForValue(a) {
    return (a === void 0 || a === 0) && (a = this.min), a === null || isNaN(a) ? NaN : this.getPixelForDecimal(a === this.min ? 0 : (Pc(a) - this._startValue) / this._valueRange);
  }
  getValueForPixel(a) {
    const f = this.getDecimalForPixel(a);
    return Math.pow(10, this._startValue + f * this._valueRange);
  }
}
Yt(Yg, "id", "logarithmic"), Yt(Yg, "defaults", {
  ticks: {
    callback: Vm.formatters.logarithmic,
    major: {
      enabled: !0
    }
  }
});
function Kg(_) {
  const a = _.ticks;
  if (a.display && _.display) {
    const f = Gr(a.backdropPadding);
    return en(a.font && a.font.size, ys.font.size) + f.height;
  }
  return 0;
}
function WP(_, a, f) {
  return f = hs(f) ? f : [
    f
  ], {
    w: eM(_, a.string, f),
    h: f.length * a.lineHeight
  };
}
function ib(_, a, f, y, w) {
  return _ === y || _ === w ? {
    start: a - f / 2,
    end: a + f / 2
  } : _ < y || _ > w ? {
    start: a - f,
    end: a
  } : {
    start: a,
    end: a + f
  };
}
function $P(_) {
  const a = {
    l: _.left + _._padding.left,
    r: _.right - _._padding.right,
    t: _.top + _._padding.top,
    b: _.bottom - _._padding.bottom
  }, f = Object.assign({}, a), y = [], w = [], b = _._pointLabels.length, P = _.options.pointLabels, i = P.centerPointLabels ? ds / b : 0;
  for (let O = 0; O < b; O++) {
    const Z = P.setContext(_.getPointLabelContext(O));
    w[O] = Z.padding;
    const Y = _.getPointPosition(O, _.drawingArea + w[O], i), J = tr(Z.font), ae = WP(_.ctx, J, _._pointLabels[O]);
    y[O] = ae;
    const ue = Bo(_.getIndexAngle(O) + i), Se = Math.round(ny(ue)), we = ib(Se, Y.x, ae.w, 0, 180), qe = ib(Se, Y.y, ae.h, 90, 270);
    XP(f, a, ue, we, qe);
  }
  _.setCenterPoint(a.l - f.l, f.r - a.r, a.t - f.t, f.b - a.b), _._pointLabelItems = JP(_, y, w);
}
function XP(_, a, f, y, w) {
  const b = Math.abs(Math.sin(f)), P = Math.abs(Math.cos(f));
  let i = 0, O = 0;
  y.start < a.l ? (i = (a.l - y.start) / b, _.l = Math.min(_.l, a.l - i)) : y.end > a.r && (i = (y.end - a.r) / b, _.r = Math.max(_.r, a.r + i)), w.start < a.t ? (O = (a.t - w.start) / P, _.t = Math.min(_.t, a.t - O)) : w.end > a.b && (O = (w.end - a.b) / P, _.b = Math.max(_.b, a.b + O));
}
function YP(_, a, f) {
  const y = _.drawingArea, { extra: w, additionalAngle: b, padding: P, size: i } = f, O = _.getPointPosition(a, y + w + P, b), Z = Math.round(ny(Bo(O.angle + Ns))), Y = tC(O.y, i.h, Z), J = QP(Z), ae = eC(O.x, i.w, J);
  return {
    visible: !0,
    x: O.x,
    y: Y,
    textAlign: J,
    left: ae,
    top: Y,
    right: ae + i.w,
    bottom: Y + i.h
  };
}
function KP(_, a) {
  if (!a)
    return !0;
  const { left: f, top: y, right: w, bottom: b } = _;
  return !(Nl({
    x: f,
    y
  }, a) || Nl({
    x: f,
    y: b
  }, a) || Nl({
    x: w,
    y
  }, a) || Nl({
    x: w,
    y: b
  }, a));
}
function JP(_, a, f) {
  const y = [], w = _._pointLabels.length, b = _.options, { centerPointLabels: P, display: i } = b.pointLabels, O = {
    extra: Kg(b) / 2,
    additionalAngle: P ? ds / w : 0
  };
  let Z;
  for (let Y = 0; Y < w; Y++) {
    O.padding = f[Y], O.size = a[Y];
    const J = YP(_, Y, O);
    y.push(J), i === "auto" && (J.visible = KP(J, Z), J.visible && (Z = J));
  }
  return y;
}
function QP(_) {
  return _ === 0 || _ === 180 ? "center" : _ < 180 ? "left" : "right";
}
function eC(_, a, f) {
  return f === "right" ? _ -= a : f === "center" && (_ -= a / 2), _;
}
function tC(_, a, f) {
  return f === 90 || f === 270 ? _ -= a / 2 : (f > 270 || f < 90) && (_ -= a), _;
}
function iC(_, a, f) {
  const { left: y, top: w, right: b, bottom: P } = f, { backdropColor: i } = a;
  if (!En(i)) {
    const O = zh(a.borderRadius), Z = Gr(a.backdropPadding);
    _.fillStyle = i;
    const Y = y - Z.left, J = w - Z.top, ae = b - y + Z.width, ue = P - w + Z.height;
    Object.values(O).some((Se) => Se !== 0) ? (_.beginPath(), kf(_, {
      x: Y,
      y: J,
      w: ae,
      h: ue,
      radius: O
    }), _.fill()) : _.fillRect(Y, J, ae, ue);
  }
}
function nC(_, a) {
  const { ctx: f, options: { pointLabels: y } } = _;
  for (let w = a - 1; w >= 0; w--) {
    const b = _._pointLabelItems[w];
    if (!b.visible)
      continue;
    const P = y.setContext(_.getPointLabelContext(w));
    iC(f, P, b);
    const i = tr(P.font), { x: O, y: Z, textAlign: Y } = b;
    Rh(f, _._pointLabels[w], O, Z + i.lineHeight / 2, i, {
      color: P.color,
      textAlign: Y,
      textBaseline: "middle"
    });
  }
}
function rw(_, a, f, y) {
  const { ctx: w } = _;
  if (f)
    w.arc(_.xCenter, _.yCenter, a, 0, us);
  else {
    let b = _.getPointPosition(0, a);
    w.moveTo(b.x, b.y);
    for (let P = 1; P < y; P++)
      b = _.getPointPosition(P, a), w.lineTo(b.x, b.y);
  }
}
function sC(_, a, f, y, w) {
  const b = _.ctx, P = a.circular, { color: i, lineWidth: O } = a;
  !P && !y || !i || !O || f < 0 || (b.save(), b.strokeStyle = i, b.lineWidth = O, b.setLineDash(w.dash || []), b.lineDashOffset = w.dashOffset, b.beginPath(), rw(_, f, P, y), b.closePath(), b.stroke(), b.restore());
}
function rC(_, a, f) {
  return kc(_, {
    label: f,
    index: a,
    type: "pointLabel"
  });
}
class Sf extends Bm {
  constructor(a) {
    super(a), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];
  }
  setDimensions() {
    const a = this._padding = Gr(Kg(this.options) / 2), f = this.width = this.maxWidth - a.width, y = this.height = this.maxHeight - a.height;
    this.xCenter = Math.floor(this.left + f / 2 + a.left), this.yCenter = Math.floor(this.top + y / 2 + a.top), this.drawingArea = Math.floor(Math.min(f, y) / 2);
  }
  determineDataLimits() {
    const { min: a, max: f } = this.getMinMax(!1);
    this.min = Ps(a) && !isNaN(a) ? a : 0, this.max = Ps(f) && !isNaN(f) ? f : 0, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / Kg(this.options));
  }
  generateTickLabels(a) {
    Bm.prototype.generateTickLabels.call(this, a), this._pointLabels = this.getLabels().map((f, y) => {
      const w = is(this.options.pointLabels.callback, [
        f,
        y
      ], this);
      return w || w === 0 ? w : "";
    }).filter((f, y) => this.chart.getDataVisibility(y));
  }
  fit() {
    const a = this.options;
    a.display && a.pointLabels.display ? $P(this) : this.setCenterPoint(0, 0, 0, 0);
  }
  setCenterPoint(a, f, y, w) {
    this.xCenter += Math.floor((a - f) / 2), this.yCenter += Math.floor((y - w) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(a, f, y, w));
  }
  getIndexAngle(a) {
    const f = us / (this._pointLabels.length || 1), y = this.options.startAngle || 0;
    return Bo(a * f + Ca(y));
  }
  getDistanceFromCenterForValue(a) {
    if (En(a))
      return NaN;
    const f = this.drawingArea / (this.max - this.min);
    return this.options.reverse ? (this.max - a) * f : (a - this.min) * f;
  }
  getValueForDistanceFromCenter(a) {
    if (En(a))
      return NaN;
    const f = a / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - f : this.min + f;
  }
  getPointLabelContext(a) {
    const f = this._pointLabels || [];
    if (a >= 0 && a < f.length) {
      const y = f[a];
      return rC(this.getContext(), a, y);
    }
  }
  getPointPosition(a, f, y = 0) {
    const w = this.getIndexAngle(a) - Ns + y;
    return {
      x: Math.cos(w) * f + this.xCenter,
      y: Math.sin(w) * f + this.yCenter,
      angle: w
    };
  }
  getPointPositionForValue(a, f) {
    return this.getPointPosition(a, this.getDistanceFromCenterForValue(f));
  }
  getBasePosition(a) {
    return this.getPointPositionForValue(a || 0, this.getBaseValue());
  }
  getPointLabelPosition(a) {
    const { left: f, top: y, right: w, bottom: b } = this._pointLabelItems[a];
    return {
      left: f,
      top: y,
      right: w,
      bottom: b
    };
  }
  drawBackground() {
    const { backgroundColor: a, grid: { circular: f } } = this.options;
    if (a) {
      const y = this.ctx;
      y.save(), y.beginPath(), rw(this, this.getDistanceFromCenterForValue(this._endValue), f, this._pointLabels.length), y.closePath(), y.fillStyle = a, y.fill(), y.restore();
    }
  }
  drawGrid() {
    const a = this.ctx, f = this.options, { angleLines: y, grid: w, border: b } = f, P = this._pointLabels.length;
    let i, O, Z;
    if (f.pointLabels.display && nC(this, P), w.display && this.ticks.forEach((Y, J) => {
      if (J !== 0 || J === 0 && this.min < 0) {
        O = this.getDistanceFromCenterForValue(Y.value);
        const ae = this.getContext(J), ue = w.setContext(ae), Se = b.setContext(ae);
        sC(this, ue, O, P, Se);
      }
    }), y.display) {
      for (a.save(), i = P - 1; i >= 0; i--) {
        const Y = y.setContext(this.getPointLabelContext(i)), { color: J, lineWidth: ae } = Y;
        !ae || !J || (a.lineWidth = ae, a.strokeStyle = J, a.setLineDash(Y.borderDash), a.lineDashOffset = Y.borderDashOffset, O = this.getDistanceFromCenterForValue(f.reverse ? this.min : this.max), Z = this.getPointPosition(i, O), a.beginPath(), a.moveTo(this.xCenter, this.yCenter), a.lineTo(Z.x, Z.y), a.stroke());
      }
      a.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const a = this.ctx, f = this.options, y = f.ticks;
    if (!y.display)
      return;
    const w = this.getIndexAngle(0);
    let b, P;
    a.save(), a.translate(this.xCenter, this.yCenter), a.rotate(w), a.textAlign = "center", a.textBaseline = "middle", this.ticks.forEach((i, O) => {
      if (O === 0 && this.min >= 0 && !f.reverse)
        return;
      const Z = y.setContext(this.getContext(O)), Y = tr(Z.font);
      if (b = this.getDistanceFromCenterForValue(this.ticks[O].value), Z.showLabelBackdrop) {
        a.font = Y.string, P = a.measureText(i.label).width, a.fillStyle = Z.backdropColor;
        const J = Gr(Z.backdropPadding);
        a.fillRect(-P / 2 - J.left, -b - Y.size / 2 - J.top, P + J.width, Y.size + J.height);
      }
      Rh(a, i.label, 0, -b, Y, {
        color: Z.color,
        strokeColor: Z.textStrokeColor,
        strokeWidth: Z.textStrokeWidth
      });
    }), a.restore();
  }
  drawTitle() {
  }
}
Yt(Sf, "id", "radialLinear"), Yt(Sf, "defaults", {
  display: !0,
  animate: !0,
  position: "chartArea",
  angleLines: {
    display: !0,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: !1
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: !0,
    callback: Vm.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: !0,
    font: {
      size: 10
    },
    callback(a) {
      return a;
    },
    padding: 5,
    centerPointLabels: !1
  }
}), Yt(Sf, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
}), Yt(Sf, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const Zm = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, _o = /* @__PURE__ */ Object.keys(Zm);
function nb(_, a) {
  return _ - a;
}
function sb(_, a) {
  if (En(a))
    return null;
  const f = _._adapter, { parser: y, round: w, isoWeekday: b } = _._parseOpts;
  let P = a;
  return typeof y == "function" && (P = y(P)), Ps(P) || (P = typeof y == "string" ? f.parse(P, y) : f.parse(P)), P === null ? null : (w && (P = w === "week" && (Wu(b) || b === !0) ? f.startOf(P, "isoWeek", b) : f.startOf(P, w)), +P);
}
function rb(_, a, f, y) {
  const w = _o.length;
  for (let b = _o.indexOf(_); b < w - 1; ++b) {
    const P = Zm[_o[b]], i = P.steps ? P.steps : Number.MAX_SAFE_INTEGER;
    if (P.common && Math.ceil((f - a) / (i * P.size)) <= y)
      return _o[b];
  }
  return _o[w - 1];
}
function oC(_, a, f, y, w) {
  for (let b = _o.length - 1; b >= _o.indexOf(f); b--) {
    const P = _o[b];
    if (Zm[P].common && _._adapter.diff(w, y, P) >= a - 1)
      return P;
  }
  return _o[f ? _o.indexOf(f) : 0];
}
function aC(_) {
  for (let a = _o.indexOf(_) + 1, f = _o.length; a < f; ++a)
    if (Zm[_o[a]].common)
      return _o[a];
}
function ob(_, a, f) {
  if (!f)
    _[a] = !0;
  else if (f.length) {
    const { lo: y, hi: w } = sy(f, a), b = f[y] >= a ? f[y] : f[w];
    _[b] = !0;
  }
}
function lC(_, a, f, y) {
  const w = _._adapter, b = +w.startOf(a[0].value, y), P = a[a.length - 1].value;
  let i, O;
  for (i = b; i <= P; i = +w.add(i, 1, y))
    O = f[i], O >= 0 && (a[O].major = !0);
  return a;
}
function ab(_, a, f) {
  const y = [], w = {}, b = a.length;
  let P, i;
  for (P = 0; P < b; ++P)
    i = a[P], w[i] = P, y.push({
      value: i,
      major: !1
    });
  return b === 0 || !f ? y : lC(_, y, w, f);
}
class Ff extends Oh {
  constructor(a) {
    super(a), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(a, f = {}) {
    const y = a.time || (a.time = {}), w = this._adapter = new _E._date(a.adapters.date);
    w.init(f), Mf(y.displayFormats, w.formats()), this._parseOpts = {
      parser: y.parser,
      round: y.round,
      isoWeekday: y.isoWeekday
    }, super.init(a), this._normalized = f.normalized;
  }
  parse(a, f) {
    return a === void 0 ? null : sb(this, a);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const a = this.options, f = this._adapter, y = a.time.unit || "day";
    let { min: w, max: b, minDefined: P, maxDefined: i } = this.getUserBounds();
    function O(Z) {
      !P && !isNaN(Z.min) && (w = Math.min(w, Z.min)), !i && !isNaN(Z.max) && (b = Math.max(b, Z.max));
    }
    (!P || !i) && (O(this._getLabelBounds()), (a.bounds !== "ticks" || a.ticks.source !== "labels") && O(this.getMinMax(!1))), w = Ps(w) && !isNaN(w) ? w : +f.startOf(Date.now(), y), b = Ps(b) && !isNaN(b) ? b : +f.endOf(Date.now(), y) + 1, this.min = Math.min(w, b - 1), this.max = Math.max(w + 1, b);
  }
  _getLabelBounds() {
    const a = this.getLabelTimestamps();
    let f = Number.POSITIVE_INFINITY, y = Number.NEGATIVE_INFINITY;
    return a.length && (f = a[0], y = a[a.length - 1]), {
      min: f,
      max: y
    };
  }
  buildTicks() {
    const a = this.options, f = a.time, y = a.ticks, w = y.source === "labels" ? this.getLabelTimestamps() : this._generate();
    a.bounds === "ticks" && w.length && (this.min = this._userMin || w[0], this.max = this._userMax || w[w.length - 1]);
    const b = this.min, P = this.max, i = US(w, b, P);
    return this._unit = f.unit || (y.autoSkip ? rb(f.minUnit, this.min, this.max, this._getLabelCapacity(b)) : oC(this, i.length, f.minUnit, this.min, this.max)), this._majorUnit = !y.major.enabled || this._unit === "year" ? void 0 : aC(this._unit), this.initOffsets(w), a.reverse && i.reverse(), ab(this, i, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((a) => +a.value));
  }
  initOffsets(a = []) {
    let f = 0, y = 0, w, b;
    this.options.offset && a.length && (w = this.getDecimalForValue(a[0]), a.length === 1 ? f = 1 - w : f = (this.getDecimalForValue(a[1]) - w) / 2, b = this.getDecimalForValue(a[a.length - 1]), a.length === 1 ? y = b : y = (b - this.getDecimalForValue(a[a.length - 2])) / 2);
    const P = a.length < 3 ? 0.5 : 0.25;
    f = gr(f, 0, P), y = gr(y, 0, P), this._offsets = {
      start: f,
      end: y,
      factor: 1 / (f + 1 + y)
    };
  }
  _generate() {
    const a = this._adapter, f = this.min, y = this.max, w = this.options, b = w.time, P = b.unit || rb(b.minUnit, f, y, this._getLabelCapacity(f)), i = en(w.ticks.stepSize, 1), O = P === "week" ? b.isoWeekday : !1, Z = Wu(O) || O === !0, Y = {};
    let J = f, ae, ue;
    if (Z && (J = +a.startOf(J, "isoWeek", O)), J = +a.startOf(J, Z ? "day" : P), a.diff(y, f, P) > 1e5 * i)
      throw new Error(f + " and " + y + " are too far apart with stepSize of " + i + " " + P);
    const Se = w.ticks.source === "data" && this.getDataTimestamps();
    for (ae = J, ue = 0; ae < y; ae = +a.add(ae, i, P), ue++)
      ob(Y, ae, Se);
    return (ae === y || w.bounds === "ticks" || ue === 1) && ob(Y, ae, Se), Object.keys(Y).sort(nb).map((we) => +we);
  }
  getLabelForValue(a) {
    const f = this._adapter, y = this.options.time;
    return y.tooltipFormat ? f.format(a, y.tooltipFormat) : f.format(a, y.displayFormats.datetime);
  }
  format(a, f) {
    const w = this.options.time.displayFormats, b = this._unit, P = f || w[b];
    return this._adapter.format(a, P);
  }
  _tickFormatFunction(a, f, y, w) {
    const b = this.options, P = b.ticks.callback;
    if (P)
      return is(P, [
        a,
        f,
        y
      ], this);
    const i = b.time.displayFormats, O = this._unit, Z = this._majorUnit, Y = O && i[O], J = Z && i[Z], ae = y[f], ue = Z && J && ae && ae.major;
    return this._adapter.format(a, w || (ue ? J : Y));
  }
  generateTickLabels(a) {
    let f, y, w;
    for (f = 0, y = a.length; f < y; ++f)
      w = a[f], w.label = this._tickFormatFunction(w.value, f, a);
  }
  getDecimalForValue(a) {
    return a === null ? NaN : (a - this.min) / (this.max - this.min);
  }
  getPixelForValue(a) {
    const f = this._offsets, y = this.getDecimalForValue(a);
    return this.getPixelForDecimal((f.start + y) * f.factor);
  }
  getValueForPixel(a) {
    const f = this._offsets, y = this.getDecimalForPixel(a) / f.factor - f.end;
    return this.min + y * (this.max - this.min);
  }
  _getLabelSize(a) {
    const f = this.options.ticks, y = this.ctx.measureText(a).width, w = Ca(this.isHorizontal() ? f.maxRotation : f.minRotation), b = Math.cos(w), P = Math.sin(w), i = this._resolveTickFontOptions(0).size;
    return {
      w: y * b + i * P,
      h: y * P + i * b
    };
  }
  _getLabelCapacity(a) {
    const f = this.options.time, y = f.displayFormats, w = y[f.unit] || y.millisecond, b = this._tickFormatFunction(a, 0, ab(this, [
      a
    ], this._majorUnit), w), P = this._getLabelSize(b), i = Math.floor(this.isHorizontal() ? this.width / P.w : this.height / P.h) - 1;
    return i > 0 ? i : 1;
  }
  getDataTimestamps() {
    let a = this._cache.data || [], f, y;
    if (a.length)
      return a;
    const w = this.getMatchingVisibleMetas();
    if (this._normalized && w.length)
      return this._cache.data = w[0].controller.getAllParsedValues(this);
    for (f = 0, y = w.length; f < y; ++f)
      a = a.concat(w[f].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(a);
  }
  getLabelTimestamps() {
    const a = this._cache.labels || [];
    let f, y;
    if (a.length)
      return a;
    const w = this.getLabels();
    for (f = 0, y = w.length; f < y; ++f)
      a.push(sb(this, w[f]));
    return this._cache.labels = this._normalized ? a : this.normalize(a);
  }
  normalize(a) {
    return yb(a.sort(nb));
  }
}
Yt(Ff, "id", "time"), Yt(Ff, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: !1,
    unit: !1,
    round: !1,
    isoWeekday: !1,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: !1,
    major: {
      enabled: !1
    }
  }
});
function xm(_, a, f) {
  let y = 0, w = _.length - 1, b, P, i, O;
  f ? (a >= _[y].pos && a <= _[w].pos && ({ lo: y, hi: w } = Bl(_, "pos", a)), { pos: b, time: i } = _[y], { pos: P, time: O } = _[w]) : (a >= _[y].time && a <= _[w].time && ({ lo: y, hi: w } = Bl(_, "time", a)), { time: b, pos: i } = _[y], { time: P, pos: O } = _[w]);
  const Z = P - b;
  return Z ? i + (O - i) * (a - b) / Z : i;
}
class Jg extends Ff {
  constructor(a) {
    super(a), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const a = this._getTimestampsForTable(), f = this._table = this.buildLookupTable(a);
    this._minPos = xm(f, this.min), this._tableRange = xm(f, this.max) - this._minPos, super.initOffsets(a);
  }
  buildLookupTable(a) {
    const { min: f, max: y } = this, w = [], b = [];
    let P, i, O, Z, Y;
    for (P = 0, i = a.length; P < i; ++P)
      Z = a[P], Z >= f && Z <= y && w.push(Z);
    if (w.length < 2)
      return [
        {
          time: f,
          pos: 0
        },
        {
          time: y,
          pos: 1
        }
      ];
    for (P = 0, i = w.length; P < i; ++P)
      Y = w[P + 1], O = w[P - 1], Z = w[P], Math.round((Y + O) / 2) !== Z && b.push({
        time: Z,
        pos: P / (i - 1)
      });
    return b;
  }
  _generate() {
    const a = this.min, f = this.max;
    let y = super.getDataTimestamps();
    return (!y.includes(a) || !y.length) && y.splice(0, 0, a), (!y.includes(f) || y.length === 1) && y.push(f), y.sort((w, b) => w - b);
  }
  _getTimestampsForTable() {
    let a = this._cache.all || [];
    if (a.length)
      return a;
    const f = this.getDataTimestamps(), y = this.getLabelTimestamps();
    return f.length && y.length ? a = this.normalize(f.concat(y)) : a = f.length ? f : y, a = this._cache.all = a, a;
  }
  getDecimalForValue(a) {
    return (xm(this._table, a) - this._minPos) / this._tableRange;
  }
  getValueForPixel(a) {
    const f = this._offsets, y = this.getDecimalForPixel(a) / f.factor - f.end;
    return xm(this._table, y * this._tableRange + this._minPos, !0);
  }
}
Yt(Jg, "id", "timeseries"), Yt(Jg, "defaults", Ff.defaults);
var cC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale: $g,
  LinearScale: Xg,
  LogarithmicScale: Yg,
  RadialLinearScale: Sf,
  TimeScale: Ff,
  TimeSeriesScale: Jg
});
const hC = [
  mE,
  HA,
  VP,
  cC
], Nm = {
  Utils: {
    DividePolylinesPoints(_) {
      let a = 0;
      const f = [], y = _.length;
      for (let w = 0; w < y; w++)
        _[w] === null && (f.push(_.slice(a === 0 ? 0 : a + 1, w)), a = w);
      return y - 1 !== a && f.push(_.slice(a)), f;
    },
    GetItemFromArray(_, a) {
      try {
        return _[a];
      } catch {
        return [0, 0];
      }
    }
  }
};
var Hm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ow(_) {
  return _ && _.__esModule && Object.prototype.hasOwnProperty.call(_, "default") ? _.default : _;
}
var vm = { exports: {} };
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
var lb;
function aw() {
  return lb || (lb = 1, function(_, a) {
    (function(f, y) {
      y(a);
    })(Hm, function(f) {
      var y = "1.9.4";
      function w(p) {
        var A, B, X, ne;
        for (B = 1, X = arguments.length; B < X; B++) {
          ne = arguments[B];
          for (A in ne)
            p[A] = ne[A];
        }
        return p;
      }
      var b = Object.create || function() {
        function p() {
        }
        return function(A) {
          return p.prototype = A, new p();
        };
      }();
      function P(p, A) {
        var B = Array.prototype.slice;
        if (p.bind)
          return p.bind.apply(p, B.call(arguments, 1));
        var X = B.call(arguments, 2);
        return function() {
          return p.apply(A, X.length ? X.concat(B.call(arguments)) : arguments);
        };
      }
      var i = 0;
      function O(p) {
        return "_leaflet_id" in p || (p._leaflet_id = ++i), p._leaflet_id;
      }
      function Z(p, A, B) {
        var X, ne, ye, We;
        return We = function() {
          X = !1, ne && (ye.apply(B, ne), ne = !1);
        }, ye = function() {
          X ? ne = arguments : (p.apply(B, arguments), setTimeout(We, A), X = !0);
        }, ye;
      }
      function Y(p, A, B) {
        var X = A[1], ne = A[0], ye = X - ne;
        return p === X && B ? p : ((p - ne) % ye + ye) % ye + ne;
      }
      function J() {
        return !1;
      }
      function ae(p, A) {
        if (A === !1)
          return p;
        var B = Math.pow(10, A === void 0 ? 6 : A);
        return Math.round(p * B) / B;
      }
      function ue(p) {
        return p.trim ? p.trim() : p.replace(/^\s+|\s+$/g, "");
      }
      function Se(p) {
        return ue(p).split(/\s+/);
      }
      function we(p, A) {
        Object.prototype.hasOwnProperty.call(p, "options") || (p.options = p.options ? b(p.options) : {});
        for (var B in A)
          p.options[B] = A[B];
        return p.options;
      }
      function qe(p, A, B) {
        var X = [];
        for (var ne in p)
          X.push(encodeURIComponent(B ? ne.toUpperCase() : ne) + "=" + encodeURIComponent(p[ne]));
        return (!A || A.indexOf("?") === -1 ? "?" : "&") + X.join("&");
      }
      var Ge = /\{ *([\w_ -]+) *\}/g;
      function lt(p, A) {
        return p.replace(Ge, function(B, X) {
          var ne = A[X];
          if (ne === void 0)
            throw new Error("No value provided for variable " + B);
          return typeof ne == "function" && (ne = ne(A)), ne;
        });
      }
      var Et = Array.isArray || function(p) {
        return Object.prototype.toString.call(p) === "[object Array]";
      };
      function ut(p, A) {
        for (var B = 0; B < p.length; B++)
          if (p[B] === A)
            return B;
        return -1;
      }
      var bt = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function Vt(p) {
        return window["webkit" + p] || window["moz" + p] || window["ms" + p];
      }
      var pt = 0;
      function Gt(p) {
        var A = +/* @__PURE__ */ new Date(), B = Math.max(0, 16 - (A - pt));
        return pt = A + B, window.setTimeout(p, B);
      }
      var ui = window.requestAnimationFrame || Vt("RequestAnimationFrame") || Gt, kt = window.cancelAnimationFrame || Vt("CancelAnimationFrame") || Vt("CancelRequestAnimationFrame") || function(p) {
        window.clearTimeout(p);
      };
      function At(p, A, B) {
        if (B && ui === Gt)
          p.call(A);
        else
          return ui.call(window, P(p, A));
      }
      function Si(p) {
        p && kt.call(window, p);
      }
      var An = {
        __proto__: null,
        extend: w,
        create: b,
        bind: P,
        get lastId() {
          return i;
        },
        stamp: O,
        throttle: Z,
        wrapNum: Y,
        falseFn: J,
        formatNum: ae,
        trim: ue,
        splitWords: Se,
        setOptions: we,
        getParamString: qe,
        template: lt,
        isArray: Et,
        indexOf: ut,
        emptyImageUrl: bt,
        requestFn: ui,
        cancelFn: kt,
        requestAnimFrame: At,
        cancelAnimFrame: Si
      };
      function hn() {
      }
      hn.extend = function(p) {
        var A = function() {
          we(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
        }, B = A.__super__ = this.prototype, X = b(B);
        X.constructor = A, A.prototype = X;
        for (var ne in this)
          Object.prototype.hasOwnProperty.call(this, ne) && ne !== "prototype" && ne !== "__super__" && (A[ne] = this[ne]);
        return p.statics && w(A, p.statics), p.includes && (Ht(p.includes), w.apply(null, [X].concat(p.includes))), w(X, p), delete X.statics, delete X.includes, X.options && (X.options = B.options ? b(B.options) : {}, w(X.options, p.options)), X._initHooks = [], X.callInitHooks = function() {
          if (!this._initHooksCalled) {
            B.callInitHooks && B.callInitHooks.call(this), this._initHooksCalled = !0;
            for (var ye = 0, We = X._initHooks.length; ye < We; ye++)
              X._initHooks[ye].call(this);
          }
        }, A;
      }, hn.include = function(p) {
        var A = this.prototype.options;
        return w(this.prototype, p), p.options && (this.prototype.options = A, this.mergeOptions(p.options)), this;
      }, hn.mergeOptions = function(p) {
        return w(this.prototype.options, p), this;
      }, hn.addInitHook = function(p) {
        var A = Array.prototype.slice.call(arguments, 1), B = typeof p == "function" ? p : function() {
          this[p].apply(this, A);
        };
        return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(B), this;
      };
      function Ht(p) {
        if (!(typeof L > "u" || !L || !L.Mixin)) {
          p = Et(p) ? p : [p];
          for (var A = 0; A < p.length; A++)
            p[A] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
        }
      }
      var Mi = {
        /* @method on(type: String, fn: Function, context?: Object): this
         * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
         *
         * @alternative
         * @method on(eventMap: Object): this
         * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
         */
        on: function(p, A, B) {
          if (typeof p == "object")
            for (var X in p)
              this._on(X, p[X], A);
          else {
            p = Se(p);
            for (var ne = 0, ye = p.length; ne < ye; ne++)
              this._on(p[ne], A, B);
          }
          return this;
        },
        /* @method off(type: String, fn?: Function, context?: Object): this
         * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
         *
         * @alternative
         * @method off(eventMap: Object): this
         * Removes a set of type/listener pairs.
         *
         * @alternative
         * @method off: this
         * Removes all listeners to all events on the object. This includes implicitly attached events.
         */
        off: function(p, A, B) {
          if (!arguments.length)
            delete this._events;
          else if (typeof p == "object")
            for (var X in p)
              this._off(X, p[X], A);
          else {
            p = Se(p);
            for (var ne = arguments.length === 1, ye = 0, We = p.length; ye < We; ye++)
              ne ? this._off(p[ye]) : this._off(p[ye], A, B);
          }
          return this;
        },
        // attach listener (without syntactic sugar now)
        _on: function(p, A, B, X) {
          if (typeof A != "function") {
            console.warn("wrong listener type: " + typeof A);
            return;
          }
          if (this._listens(p, A, B) === !1) {
            B === this && (B = void 0);
            var ne = { fn: A, ctx: B };
            X && (ne.once = !0), this._events = this._events || {}, this._events[p] = this._events[p] || [], this._events[p].push(ne);
          }
        },
        _off: function(p, A, B) {
          var X, ne, ye;
          if (this._events && (X = this._events[p], !!X)) {
            if (arguments.length === 1) {
              if (this._firingCount)
                for (ne = 0, ye = X.length; ne < ye; ne++)
                  X[ne].fn = J;
              delete this._events[p];
              return;
            }
            if (typeof A != "function") {
              console.warn("wrong listener type: " + typeof A);
              return;
            }
            var We = this._listens(p, A, B);
            if (We !== !1) {
              var ot = X[We];
              this._firingCount && (ot.fn = J, this._events[p] = X = X.slice()), X.splice(We, 1);
            }
          }
        },
        // @method fire(type: String, data?: Object, propagate?: Boolean): this
        // Fires an event of the specified type. You can optionally provide a data
        // object — the first argument of the listener function will contain its
        // properties. The event can optionally be propagated to event parents.
        fire: function(p, A, B) {
          if (!this.listens(p, B))
            return this;
          var X = w({}, A, {
            type: p,
            target: this,
            sourceTarget: A && A.sourceTarget || this
          });
          if (this._events) {
            var ne = this._events[p];
            if (ne) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var ye = 0, We = ne.length; ye < We; ye++) {
                var ot = ne[ye], ft = ot.fn;
                ot.once && this.off(p, ft, ot.ctx), ft.call(ot.ctx || this, X);
              }
              this._firingCount--;
            }
          }
          return B && this._propagateEvent(X), this;
        },
        // @method listens(type: String, propagate?: Boolean): Boolean
        // @method listens(type: String, fn: Function, context?: Object, propagate?: Boolean): Boolean
        // Returns `true` if a particular event type has any listeners attached to it.
        // The verification can optionally be propagated, it will return `true` if parents have the listener attached to it.
        listens: function(p, A, B, X) {
          typeof p != "string" && console.warn('"string" type argument expected');
          var ne = A;
          typeof A != "function" && (X = !!A, ne = void 0, B = void 0);
          var ye = this._events && this._events[p];
          if (ye && ye.length && this._listens(p, ne, B) !== !1)
            return !0;
          if (X) {
            for (var We in this._eventParents)
              if (this._eventParents[We].listens(p, A, B, X))
                return !0;
          }
          return !1;
        },
        // returns the index (number) or false
        _listens: function(p, A, B) {
          if (!this._events)
            return !1;
          var X = this._events[p] || [];
          if (!A)
            return !!X.length;
          B === this && (B = void 0);
          for (var ne = 0, ye = X.length; ne < ye; ne++)
            if (X[ne].fn === A && X[ne].ctx === B)
              return ne;
          return !1;
        },
        // @method once(…): this
        // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
        once: function(p, A, B) {
          if (typeof p == "object")
            for (var X in p)
              this._on(X, p[X], A, !0);
          else {
            p = Se(p);
            for (var ne = 0, ye = p.length; ne < ye; ne++)
              this._on(p[ne], A, B, !0);
          }
          return this;
        },
        // @method addEventParent(obj: Evented): this
        // Adds an event parent - an `Evented` that will receive propagated events
        addEventParent: function(p) {
          return this._eventParents = this._eventParents || {}, this._eventParents[O(p)] = p, this;
        },
        // @method removeEventParent(obj: Evented): this
        // Removes an event parent, so it will stop receiving propagated events
        removeEventParent: function(p) {
          return this._eventParents && delete this._eventParents[O(p)], this;
        },
        _propagateEvent: function(p) {
          for (var A in this._eventParents)
            this._eventParents[A].fire(p.type, w({
              layer: p.target,
              propagatedFrom: p.target
            }, p), !0);
        }
      };
      Mi.addEventListener = Mi.on, Mi.removeEventListener = Mi.clearAllEventListeners = Mi.off, Mi.addOneTimeEventListener = Mi.once, Mi.fireEvent = Mi.fire, Mi.hasEventListeners = Mi.listens;
      var Ji = hn.extend(Mi);
      function fi(p, A, B) {
        this.x = B ? Math.round(p) : p, this.y = B ? Math.round(A) : A;
      }
      var jt = Math.trunc || function(p) {
        return p > 0 ? Math.floor(p) : Math.ceil(p);
      };
      fi.prototype = {
        // @method clone(): Point
        // Returns a copy of the current point.
        clone: function() {
          return new fi(this.x, this.y);
        },
        // @method add(otherPoint: Point): Point
        // Returns the result of addition of the current and the given points.
        add: function(p) {
          return this.clone()._add(ni(p));
        },
        _add: function(p) {
          return this.x += p.x, this.y += p.y, this;
        },
        // @method subtract(otherPoint: Point): Point
        // Returns the result of subtraction of the given point from the current.
        subtract: function(p) {
          return this.clone()._subtract(ni(p));
        },
        _subtract: function(p) {
          return this.x -= p.x, this.y -= p.y, this;
        },
        // @method divideBy(num: Number): Point
        // Returns the result of division of the current point by the given number.
        divideBy: function(p) {
          return this.clone()._divideBy(p);
        },
        _divideBy: function(p) {
          return this.x /= p, this.y /= p, this;
        },
        // @method multiplyBy(num: Number): Point
        // Returns the result of multiplication of the current point by the given number.
        multiplyBy: function(p) {
          return this.clone()._multiplyBy(p);
        },
        _multiplyBy: function(p) {
          return this.x *= p, this.y *= p, this;
        },
        // @method scaleBy(scale: Point): Point
        // Multiply each coordinate of the current point by each coordinate of
        // `scale`. In linear algebra terms, multiply the point by the
        // [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
        // defined by `scale`.
        scaleBy: function(p) {
          return new fi(this.x * p.x, this.y * p.y);
        },
        // @method unscaleBy(scale: Point): Point
        // Inverse of `scaleBy`. Divide each coordinate of the current point by
        // each coordinate of `scale`.
        unscaleBy: function(p) {
          return new fi(this.x / p.x, this.y / p.y);
        },
        // @method round(): Point
        // Returns a copy of the current point with rounded coordinates.
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        },
        // @method floor(): Point
        // Returns a copy of the current point with floored coordinates (rounded down).
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        },
        // @method ceil(): Point
        // Returns a copy of the current point with ceiled coordinates (rounded up).
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        },
        // @method trunc(): Point
        // Returns a copy of the current point with truncated coordinates (rounded towards zero).
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          return this.x = jt(this.x), this.y = jt(this.y), this;
        },
        // @method distanceTo(otherPoint: Point): Number
        // Returns the cartesian distance between the current and the given points.
        distanceTo: function(p) {
          p = ni(p);
          var A = p.x - this.x, B = p.y - this.y;
          return Math.sqrt(A * A + B * B);
        },
        // @method equals(otherPoint: Point): Boolean
        // Returns `true` if the given point has the same coordinates.
        equals: function(p) {
          return p = ni(p), p.x === this.x && p.y === this.y;
        },
        // @method contains(otherPoint: Point): Boolean
        // Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
        contains: function(p) {
          return p = ni(p), Math.abs(p.x) <= Math.abs(this.x) && Math.abs(p.y) <= Math.abs(this.y);
        },
        // @method toString(): String
        // Returns a string representation of the point for debugging purposes.
        toString: function() {
          return "Point(" + ae(this.x) + ", " + ae(this.y) + ")";
        }
      };
      function ni(p, A, B) {
        return p instanceof fi ? p : Et(p) ? new fi(p[0], p[1]) : p == null ? p : typeof p == "object" && "x" in p && "y" in p ? new fi(p.x, p.y) : new fi(p, A, B);
      }
      function Gi(p, A) {
        if (p)
          for (var B = A ? [p, A] : p, X = 0, ne = B.length; X < ne; X++)
            this.extend(B[X]);
      }
      Gi.prototype = {
        // @method extend(point: Point): this
        // Extends the bounds to contain the given point.
        // @alternative
        // @method extend(otherBounds: Bounds): this
        // Extend the bounds to contain the given bounds
        extend: function(p) {
          var A, B;
          if (!p)
            return this;
          if (p instanceof fi || typeof p[0] == "number" || "x" in p)
            A = B = ni(p);
          else if (p = an(p), A = p.min, B = p.max, !A || !B)
            return this;
          return !this.min && !this.max ? (this.min = A.clone(), this.max = B.clone()) : (this.min.x = Math.min(A.x, this.min.x), this.max.x = Math.max(B.x, this.max.x), this.min.y = Math.min(A.y, this.min.y), this.max.y = Math.max(B.y, this.max.y)), this;
        },
        // @method getCenter(round?: Boolean): Point
        // Returns the center point of the bounds.
        getCenter: function(p) {
          return ni(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            p
          );
        },
        // @method getBottomLeft(): Point
        // Returns the bottom-left point of the bounds.
        getBottomLeft: function() {
          return ni(this.min.x, this.max.y);
        },
        // @method getTopRight(): Point
        // Returns the top-right point of the bounds.
        getTopRight: function() {
          return ni(this.max.x, this.min.y);
        },
        // @method getTopLeft(): Point
        // Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
        getTopLeft: function() {
          return this.min;
        },
        // @method getBottomRight(): Point
        // Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
        getBottomRight: function() {
          return this.max;
        },
        // @method getSize(): Point
        // Returns the size of the given bounds
        getSize: function() {
          return this.max.subtract(this.min);
        },
        // @method contains(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains(point: Point): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(p) {
          var A, B;
          return typeof p[0] == "number" || p instanceof fi ? p = ni(p) : p = an(p), p instanceof Gi ? (A = p.min, B = p.max) : A = B = p, A.x >= this.min.x && B.x <= this.max.x && A.y >= this.min.y && B.y <= this.max.y;
        },
        // @method intersects(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds
        // intersect if they have at least one point in common.
        intersects: function(p) {
          p = an(p);
          var A = this.min, B = this.max, X = p.min, ne = p.max, ye = ne.x >= A.x && X.x <= B.x, We = ne.y >= A.y && X.y <= B.y;
          return ye && We;
        },
        // @method overlaps(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds
        // overlap if their intersection is an area.
        overlaps: function(p) {
          p = an(p);
          var A = this.min, B = this.max, X = p.min, ne = p.max, ye = ne.x > A.x && X.x < B.x, We = ne.y > A.y && X.y < B.y;
          return ye && We;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this.min && this.max);
        },
        // @method pad(bufferRatio: Number): Bounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(p) {
          var A = this.min, B = this.max, X = Math.abs(A.x - B.x) * p, ne = Math.abs(A.y - B.y) * p;
          return an(
            ni(A.x - X, A.y - ne),
            ni(B.x + X, B.y + ne)
          );
        },
        // @method equals(otherBounds: Bounds): Boolean
        // Returns `true` if the rectangle is equivalent to the given bounds.
        equals: function(p) {
          return p ? (p = an(p), this.min.equals(p.getTopLeft()) && this.max.equals(p.getBottomRight())) : !1;
        }
      };
      function an(p, A) {
        return !p || p instanceof Gi ? p : new Gi(p, A);
      }
      function qt(p, A) {
        if (p)
          for (var B = A ? [p, A] : p, X = 0, ne = B.length; X < ne; X++)
            this.extend(B[X]);
      }
      qt.prototype = {
        // @method extend(latlng: LatLng): this
        // Extend the bounds to contain the given point
        // @alternative
        // @method extend(otherBounds: LatLngBounds): this
        // Extend the bounds to contain the given bounds
        extend: function(p) {
          var A = this._southWest, B = this._northEast, X, ne;
          if (p instanceof Di)
            X = p, ne = p;
          else if (p instanceof qt) {
            if (X = p._southWest, ne = p._northEast, !X || !ne)
              return this;
          } else
            return p ? this.extend(xi(p) || ln(p)) : this;
          return !A && !B ? (this._southWest = new Di(X.lat, X.lng), this._northEast = new Di(ne.lat, ne.lng)) : (A.lat = Math.min(X.lat, A.lat), A.lng = Math.min(X.lng, A.lng), B.lat = Math.max(ne.lat, B.lat), B.lng = Math.max(ne.lng, B.lng)), this;
        },
        // @method pad(bufferRatio: Number): LatLngBounds
        // Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
        // For example, a ratio of 0.5 extends the bounds by 50% in each direction.
        // Negative values will retract the bounds.
        pad: function(p) {
          var A = this._southWest, B = this._northEast, X = Math.abs(A.lat - B.lat) * p, ne = Math.abs(A.lng - B.lng) * p;
          return new qt(
            new Di(A.lat - X, A.lng - ne),
            new Di(B.lat + X, B.lng + ne)
          );
        },
        // @method getCenter(): LatLng
        // Returns the center point of the bounds.
        getCenter: function() {
          return new Di(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        // @method getSouthWest(): LatLng
        // Returns the south-west point of the bounds.
        getSouthWest: function() {
          return this._southWest;
        },
        // @method getNorthEast(): LatLng
        // Returns the north-east point of the bounds.
        getNorthEast: function() {
          return this._northEast;
        },
        // @method getNorthWest(): LatLng
        // Returns the north-west point of the bounds.
        getNorthWest: function() {
          return new Di(this.getNorth(), this.getWest());
        },
        // @method getSouthEast(): LatLng
        // Returns the south-east point of the bounds.
        getSouthEast: function() {
          return new Di(this.getSouth(), this.getEast());
        },
        // @method getWest(): Number
        // Returns the west longitude of the bounds
        getWest: function() {
          return this._southWest.lng;
        },
        // @method getSouth(): Number
        // Returns the south latitude of the bounds
        getSouth: function() {
          return this._southWest.lat;
        },
        // @method getEast(): Number
        // Returns the east longitude of the bounds
        getEast: function() {
          return this._northEast.lng;
        },
        // @method getNorth(): Number
        // Returns the north latitude of the bounds
        getNorth: function() {
          return this._northEast.lat;
        },
        // @method contains(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle contains the given one.
        // @alternative
        // @method contains (latlng: LatLng): Boolean
        // Returns `true` if the rectangle contains the given point.
        contains: function(p) {
          typeof p[0] == "number" || p instanceof Di || "lat" in p ? p = xi(p) : p = ln(p);
          var A = this._southWest, B = this._northEast, X, ne;
          return p instanceof qt ? (X = p.getSouthWest(), ne = p.getNorthEast()) : X = ne = p, X.lat >= A.lat && ne.lat <= B.lat && X.lng >= A.lng && ne.lng <= B.lng;
        },
        // @method intersects(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
        intersects: function(p) {
          p = ln(p);
          var A = this._southWest, B = this._northEast, X = p.getSouthWest(), ne = p.getNorthEast(), ye = ne.lat >= A.lat && X.lat <= B.lat, We = ne.lng >= A.lng && X.lng <= B.lng;
          return ye && We;
        },
        // @method overlaps(otherBounds: LatLngBounds): Boolean
        // Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
        overlaps: function(p) {
          p = ln(p);
          var A = this._southWest, B = this._northEast, X = p.getSouthWest(), ne = p.getNorthEast(), ye = ne.lat > A.lat && X.lat < B.lat, We = ne.lng > A.lng && X.lng < B.lng;
          return ye && We;
        },
        // @method toBBoxString(): String
        // Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        // @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
        // Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(p, A) {
          return p ? (p = ln(p), this._southWest.equals(p.getSouthWest(), A) && this._northEast.equals(p.getNorthEast(), A)) : !1;
        },
        // @method isValid(): Boolean
        // Returns `true` if the bounds are properly initialized.
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function ln(p, A) {
        return p instanceof qt ? p : new qt(p, A);
      }
      function Di(p, A, B) {
        if (isNaN(p) || isNaN(A))
          throw new Error("Invalid LatLng object: (" + p + ", " + A + ")");
        this.lat = +p, this.lng = +A, B !== void 0 && (this.alt = +B);
      }
      Di.prototype = {
        // @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
        // Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
        equals: function(p, A) {
          if (!p)
            return !1;
          p = xi(p);
          var B = Math.max(
            Math.abs(this.lat - p.lat),
            Math.abs(this.lng - p.lng)
          );
          return B <= (A === void 0 ? 1e-9 : A);
        },
        // @method toString(): String
        // Returns a string representation of the point (for debugging purposes).
        toString: function(p) {
          return "LatLng(" + ae(this.lat, p) + ", " + ae(this.lng, p) + ")";
        },
        // @method distanceTo(otherLatLng: LatLng): Number
        // Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
        distanceTo: function(p) {
          return xs.distance(this, xi(p));
        },
        // @method wrap(): LatLng
        // Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
        wrap: function() {
          return xs.wrapLatLng(this);
        },
        // @method toBounds(sizeInMeters: Number): LatLngBounds
        // Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
        toBounds: function(p) {
          var A = 180 * p / 40075017, B = A / Math.cos(Math.PI / 180 * this.lat);
          return ln(
            [this.lat - A, this.lng - B],
            [this.lat + A, this.lng + B]
          );
        },
        clone: function() {
          return new Di(this.lat, this.lng, this.alt);
        }
      };
      function xi(p, A, B) {
        return p instanceof Di ? p : Et(p) && typeof p[0] != "object" ? p.length === 3 ? new Di(p[0], p[1], p[2]) : p.length === 2 ? new Di(p[0], p[1]) : null : p == null ? p : typeof p == "object" && "lat" in p ? new Di(p.lat, "lng" in p ? p.lng : p.lon, p.alt) : A === void 0 ? null : new Di(p, A, B);
      }
      var Cs = {
        // @method latLngToPoint(latlng: LatLng, zoom: Number): Point
        // Projects geographical coordinates into pixel coordinates for a given zoom.
        latLngToPoint: function(p, A) {
          var B = this.projection.project(p), X = this.scale(A);
          return this.transformation._transform(B, X);
        },
        // @method pointToLatLng(point: Point, zoom: Number): LatLng
        // The inverse of `latLngToPoint`. Projects pixel coordinates on a given
        // zoom into geographical coordinates.
        pointToLatLng: function(p, A) {
          var B = this.scale(A), X = this.transformation.untransform(p, B);
          return this.projection.unproject(X);
        },
        // @method project(latlng: LatLng): Point
        // Projects geographical coordinates into coordinates in units accepted for
        // this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
        project: function(p) {
          return this.projection.project(p);
        },
        // @method unproject(point: Point): LatLng
        // Given a projected coordinate returns the corresponding LatLng.
        // The inverse of `project`.
        unproject: function(p) {
          return this.projection.unproject(p);
        },
        // @method scale(zoom: Number): Number
        // Returns the scale used when transforming projected coordinates into
        // pixel coordinates for a particular zoom. For example, it returns
        // `256 * 2^zoom` for Mercator-based CRS.
        scale: function(p) {
          return 256 * Math.pow(2, p);
        },
        // @method zoom(scale: Number): Number
        // Inverse of `scale()`, returns the zoom level corresponding to a scale
        // factor of `scale`.
        zoom: function(p) {
          return Math.log(p / 256) / Math.LN2;
        },
        // @method getProjectedBounds(zoom: Number): Bounds
        // Returns the projection's bounds scaled and transformed for the provided `zoom`.
        getProjectedBounds: function(p) {
          if (this.infinite)
            return null;
          var A = this.projection.bounds, B = this.scale(p), X = this.transformation.transform(A.min, B), ne = this.transformation.transform(A.max, B);
          return new Gi(X, ne);
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates.
        // @property code: String
        // Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
        //
        // @property wrapLng: Number[]
        // An array of two numbers defining whether the longitude (horizontal) coordinate
        // axis wraps around a given range and how. Defaults to `[-180, 180]` in most
        // geographical CRSs. If `undefined`, the longitude axis does not wrap around.
        //
        // @property wrapLat: Number[]
        // Like `wrapLng`, but for the latitude (vertical) axis.
        // wrapLng: [min, max],
        // wrapLat: [min, max],
        // @property infinite: Boolean
        // If true, the coordinate space will be unbounded (infinite in both axes)
        infinite: !1,
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where lat and lng has been wrapped according to the
        // CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
        wrapLatLng: function(p) {
          var A = this.wrapLng ? Y(p.lng, this.wrapLng, !0) : p.lng, B = this.wrapLat ? Y(p.lat, this.wrapLat, !0) : p.lat, X = p.alt;
          return new Di(B, A, X);
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring
        // that its center is within the CRS's bounds.
        // Only accepts actual `L.LatLngBounds` instances, not arrays.
        wrapLatLngBounds: function(p) {
          var A = p.getCenter(), B = this.wrapLatLng(A), X = A.lat - B.lat, ne = A.lng - B.lng;
          if (X === 0 && ne === 0)
            return p;
          var ye = p.getSouthWest(), We = p.getNorthEast(), ot = new Di(ye.lat - X, ye.lng - ne), ft = new Di(We.lat - X, We.lng - ne);
          return new qt(ot, ft);
        }
      }, xs = w({}, Cs, {
        wrapLng: [-180, 180],
        // Mean Earth Radius, as recommended for use by
        // the International Union of Geodesy and Geophysics,
        // see https://rosettacode.org/wiki/Haversine_formula
        R: 6371e3,
        // distance between two geographical points using spherical law of cosines approximation
        distance: function(p, A) {
          var B = Math.PI / 180, X = p.lat * B, ne = A.lat * B, ye = Math.sin((A.lat - p.lat) * B / 2), We = Math.sin((A.lng - p.lng) * B / 2), ot = ye * ye + Math.cos(X) * Math.cos(ne) * We * We, ft = 2 * Math.atan2(Math.sqrt(ot), Math.sqrt(1 - ot));
          return this.R * ft;
        }
      }), Is = 6378137, De = {
        R: Is,
        MAX_LATITUDE: 85.0511287798,
        project: function(p) {
          var A = Math.PI / 180, B = this.MAX_LATITUDE, X = Math.max(Math.min(B, p.lat), -B), ne = Math.sin(X * A);
          return new fi(
            this.R * p.lng * A,
            this.R * Math.log((1 + ne) / (1 - ne)) / 2
          );
        },
        unproject: function(p) {
          var A = 180 / Math.PI;
          return new Di(
            (2 * Math.atan(Math.exp(p.y / this.R)) - Math.PI / 2) * A,
            p.x * A / this.R
          );
        },
        bounds: function() {
          var p = Is * Math.PI;
          return new Gi([-p, -p], [p, p]);
        }()
      };
      function Vs(p, A, B, X) {
        if (Et(p)) {
          this._a = p[0], this._b = p[1], this._c = p[2], this._d = p[3];
          return;
        }
        this._a = p, this._b = A, this._c = B, this._d = X;
      }
      Vs.prototype = {
        // @method transform(point: Point, scale?: Number): Point
        // Returns a transformed point, optionally multiplied by the given scale.
        // Only accepts actual `L.Point` instances, not arrays.
        transform: function(p, A) {
          return this._transform(p.clone(), A);
        },
        // destructive transform (faster)
        _transform: function(p, A) {
          return A = A || 1, p.x = A * (this._a * p.x + this._b), p.y = A * (this._c * p.y + this._d), p;
        },
        // @method untransform(point: Point, scale?: Number): Point
        // Returns the reverse transformation of the given point, optionally divided
        // by the given scale. Only accepts actual `L.Point` instances, not arrays.
        untransform: function(p, A) {
          return A = A || 1, new fi(
            (p.x / A - this._b) / this._a,
            (p.y / A - this._d) / this._c
          );
        }
      };
      function Us(p, A, B, X) {
        return new Vs(p, A, B, X);
      }
      var Zr = w({}, xs, {
        code: "EPSG:3857",
        projection: De,
        transformation: function() {
          var p = 0.5 / (Math.PI * De.R);
          return Us(p, 0.5, -p, 0.5);
        }()
      }), Mt = w({}, Zr, {
        code: "EPSG:900913"
      });
      function ir(p) {
        return document.createElementNS("http://www.w3.org/2000/svg", p);
      }
      function $n(p, A) {
        var B = "", X, ne, ye, We, ot, ft;
        for (X = 0, ye = p.length; X < ye; X++) {
          for (ot = p[X], ne = 0, We = ot.length; ne < We; ne++)
            ft = ot[ne], B += (ne ? "L" : "M") + ft.x + " " + ft.y;
          B += A ? Ae.svg ? "z" : "x" : "";
        }
        return B || "M0 0";
      }
      var Ws = document.documentElement.style, vi = "ActiveXObject" in window, kn = vi && !document.addEventListener, $s = "msLaunchUri" in navigator && !("documentMode" in document), Hr = He("webkit"), qr = He("android"), Wr = He("android 2") || He("android 3"), si = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), fs = qr && He("Google") && si < 537 && !("AudioNode" in window), zn = !!window.opera, Rn = !$s && He("chrome"), Pn = He("gecko") && !Hr && !zn && !vi, js = !Rn && He("safari"), go = He("phantom"), yo = "OTransition" in Ws, xo = navigator.platform.indexOf("Win") === 0, yr = vi && "transition" in Ws, Sr = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !Wr, io = "MozPerspective" in Ws, Xs = !window.L_DISABLE_3D && (yr || Sr || io) && !yo && !go, Mr = typeof orientation < "u" || He("mobile"), mi = Mr && Hr, On = Mr && Sr, Vn = !window.PointerEvent && window.MSPointerEvent, Zi = !!(window.PointerEvent || Vn), Jn = "ontouchstart" in window || !!window.TouchEvent, Fn = !window.L_NO_TOUCH && (Jn || Zi), Ls = Mr && zn, zs = Mr && Pn, No = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, Ke = function() {
        var p = !1;
        try {
          var A = Object.defineProperty({}, "passive", {
            get: function() {
              p = !0;
            }
          });
          window.addEventListener("testPassiveEventSupport", J, A), window.removeEventListener("testPassiveEventSupport", J, A);
        } catch {
        }
        return p;
      }(), re = function() {
        return !!document.createElement("canvas").getContext;
      }(), le = !!(document.createElementNS && ir("svg").createSVGRect), ge = !!le && function() {
        var p = document.createElement("div");
        return p.innerHTML = "<svg/>", (p.firstChild && p.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }(), Le = !le && function() {
        try {
          var p = document.createElement("div");
          p.innerHTML = '<v:shape adj="1"/>';
          var A = p.firstChild;
          return A.style.behavior = "url(#default#VML)", A && typeof A.adj == "object";
        } catch {
          return !1;
        }
      }(), Ce = navigator.platform.indexOf("Mac") === 0, Be = navigator.platform.indexOf("Linux") === 0;
      function He(p) {
        return navigator.userAgent.toLowerCase().indexOf(p) >= 0;
      }
      var Ae = {
        ie: vi,
        ielt9: kn,
        edge: $s,
        webkit: Hr,
        android: qr,
        android23: Wr,
        androidStock: fs,
        opera: zn,
        chrome: Rn,
        gecko: Pn,
        safari: js,
        phantom: go,
        opera12: yo,
        win: xo,
        ie3d: yr,
        webkit3d: Sr,
        gecko3d: io,
        any3d: Xs,
        mobile: Mr,
        mobileWebkit: mi,
        mobileWebkit3d: On,
        msPointer: Vn,
        pointer: Zi,
        touch: Fn,
        touchNative: Jn,
        mobileOpera: Ls,
        mobileGecko: zs,
        retina: No,
        passiveEvents: Ke,
        canvas: re,
        svg: le,
        vml: Le,
        inlineSvg: ge,
        mac: Ce,
        linux: Be
      }, Ye = Ae.msPointer ? "MSPointerDown" : "pointerdown", Qe = Ae.msPointer ? "MSPointerMove" : "pointermove", it = Ae.msPointer ? "MSPointerUp" : "pointerup", mt = Ae.msPointer ? "MSPointerCancel" : "pointercancel", Ct = {
        touchstart: Ye,
        touchmove: Qe,
        touchend: it,
        touchcancel: mt
      }, It = {
        touchstart: Xn,
        touchmove: Hi,
        touchend: Hi,
        touchcancel: Hi
      }, Kt = {}, di = !1;
      function li(p, A, B) {
        return A === "touchstart" && $i(), It[A] ? (B = It[A].bind(this, B), p.addEventListener(Ct[A], B, !1), B) : (console.warn("wrong event specified:", A), J);
      }
      function ri(p, A, B) {
        if (!Ct[A]) {
          console.warn("wrong event specified:", A);
          return;
        }
        p.removeEventListener(Ct[A], B, !1);
      }
      function Ki(p) {
        Kt[p.pointerId] = p;
      }
      function Ni(p) {
        Kt[p.pointerId] && (Kt[p.pointerId] = p);
      }
      function Ei(p) {
        delete Kt[p.pointerId];
      }
      function $i() {
        di || (document.addEventListener(Ye, Ki, !0), document.addEventListener(Qe, Ni, !0), document.addEventListener(it, Ei, !0), document.addEventListener(mt, Ei, !0), di = !0);
      }
      function Hi(p, A) {
        if (A.pointerType !== (A.MSPOINTER_TYPE_MOUSE || "mouse")) {
          A.touches = [];
          for (var B in Kt)
            A.touches.push(Kt[B]);
          A.changedTouches = [A], p(A);
        }
      }
      function Xn(p, A) {
        A.MSPOINTER_TYPE_TOUCH && A.pointerType === A.MSPOINTER_TYPE_TOUCH && _s(A), Hi(p, A);
      }
      function Gs(p) {
        var A = {}, B, X;
        for (X in p)
          B = p[X], A[X] = B && B.bind ? B.bind(p) : B;
        return p = A, A.type = "dblclick", A.detail = 2, A.isTrusted = !1, A._simulated = !0, A;
      }
      var ps = 200;
      function vs(p, A) {
        p.addEventListener("dblclick", A);
        var B = 0, X;
        function ne(ye) {
          if (ye.detail !== 1) {
            X = ye.detail;
            return;
          }
          if (!(ye.pointerType === "mouse" || ye.sourceCapabilities && !ye.sourceCapabilities.firesTouchEvents)) {
            var We = Zo(ye);
            if (!(We.some(function(ft) {
              return ft instanceof HTMLLabelElement && ft.attributes.for;
            }) && !We.some(function(ft) {
              return ft instanceof HTMLInputElement || ft instanceof HTMLSelectElement;
            }))) {
              var ot = Date.now();
              ot - B <= ps ? (X++, X === 2 && A(Gs(ye))) : X = 1, B = ot;
            }
          }
        }
        return p.addEventListener("click", ne), {
          dblclick: A,
          simDblclick: ne
        };
      }
      function sa(p, A) {
        p.removeEventListener("dblclick", A.dblclick), p.removeEventListener("click", A.simDblclick);
      }
      var Er = nr(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      ), ra = nr(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      ), al = ra === "webkitTransition" || ra === "OTransition" ? ra + "End" : "transitionend";
      function Vo(p) {
        return typeof p == "string" ? document.getElementById(p) : p;
      }
      function Uo(p, A) {
        var B = p.style[A] || p.currentStyle && p.currentStyle[A];
        if ((!B || B === "auto") && document.defaultView) {
          var X = document.defaultView.getComputedStyle(p, null);
          B = X ? X[A] : null;
        }
        return B === "auto" ? null : B;
      }
      function tn(p, A, B) {
        var X = document.createElement(p);
        return X.className = A || "", B && B.appendChild(X), X;
      }
      function xn(p) {
        var A = p.parentNode;
        A && A.removeChild(p);
      }
      function no(p) {
        for (; p.firstChild; )
          p.removeChild(p.firstChild);
      }
      function jo(p) {
        var A = p.parentNode;
        A && A.lastChild !== p && A.appendChild(p);
      }
      function oa(p) {
        var A = p.parentNode;
        A && A.firstChild !== p && A.insertBefore(p, A.firstChild);
      }
      function La(p, A) {
        if (p.classList !== void 0)
          return p.classList.contains(A);
        var B = Zs(p);
        return B.length > 0 && new RegExp("(^|\\s)" + A + "(\\s|$)").test(B);
      }
      function Vi(p, A) {
        if (p.classList !== void 0)
          for (var B = Se(A), X = 0, ne = B.length; X < ne; X++)
            p.classList.add(B[X]);
        else if (!La(p, A)) {
          var ye = Zs(p);
          ll(p, (ye ? ye + " " : "") + A);
        }
      }
      function Hn(p, A) {
        p.classList !== void 0 ? p.classList.remove(A) : ll(p, ue((" " + Zs(p) + " ").replace(" " + A + " ", " ")));
      }
      function ll(p, A) {
        p.className.baseVal === void 0 ? p.className = A : p.className.baseVal = A;
      }
      function Zs(p) {
        return p.correspondingElement && (p = p.correspondingElement), p.className.baseVal === void 0 ? p.className : p.className.baseVal;
      }
      function Qn(p, A) {
        "opacity" in p.style ? p.style.opacity = A : "filter" in p.style && Ar(p, A);
      }
      function Ar(p, A) {
        var B = !1, X = "DXImageTransform.Microsoft.Alpha";
        try {
          B = p.filters.item(X);
        } catch {
          if (A === 1)
            return;
        }
        A = Math.round(A * 100), B ? (B.Enabled = A !== 100, B.Opacity = A) : p.style.filter += " progid:" + X + "(opacity=" + A + ")";
      }
      function nr(p) {
        for (var A = document.documentElement.style, B = 0; B < p.length; B++)
          if (p[B] in A)
            return p[B];
        return !1;
      }
      function Ys(p, A, B) {
        var X = A || new fi(0, 0);
        p.style[Er] = (Ae.ie3d ? "translate(" + X.x + "px," + X.y + "px)" : "translate3d(" + X.x + "px," + X.y + "px,0)") + (B ? " scale(" + B + ")" : "");
      }
      function Yn(p, A) {
        p._leaflet_pos = A, Ae.any3d ? Ys(p, A) : (p.style.left = A.x + "px", p.style.top = A.y + "px");
      }
      function $r(p) {
        return p._leaflet_pos || new fi(0, 0);
      }
      var Pr, Cr, za;
      if ("onselectstart" in document)
        Pr = function() {
          Bi(window, "selectstart", _s);
        }, Cr = function() {
          Cn(window, "selectstart", _s);
        };
      else {
        var aa = nr(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        Pr = function() {
          if (aa) {
            var p = document.documentElement.style;
            za = p[aa], p[aa] = "none";
          }
        }, Cr = function() {
          aa && (document.documentElement.style[aa] = za, za = void 0);
        };
      }
      function Go() {
        Bi(window, "dragstart", _s);
      }
      function sr() {
        Cn(window, "dragstart", _s);
      }
      var la, Da;
      function ki(p) {
        for (; p.tabIndex === -1; )
          p = p.parentNode;
        p.style && (Ul(), la = p, Da = p.style.outlineStyle, p.style.outlineStyle = "none", Bi(window, "keydown", Ul));
      }
      function Ul() {
        la && (la.style.outlineStyle = Da, la = void 0, Da = void 0, Cn(window, "keydown", Ul));
      }
      function ei(p) {
        do
          p = p.parentNode;
        while ((!p.offsetWidth || !p.offsetHeight) && p !== document.body);
        return p;
      }
      function cl(p) {
        var A = p.getBoundingClientRect();
        return {
          x: A.width / p.offsetWidth || 1,
          y: A.height / p.offsetHeight || 1,
          boundingClientRect: A
        };
      }
      var Oi = {
        __proto__: null,
        TRANSFORM: Er,
        TRANSITION: ra,
        TRANSITION_END: al,
        get: Vo,
        getStyle: Uo,
        create: tn,
        remove: xn,
        empty: no,
        toFront: jo,
        toBack: oa,
        hasClass: La,
        addClass: Vi,
        removeClass: Hn,
        setClass: ll,
        getClass: Zs,
        setOpacity: Qn,
        testProp: nr,
        setTransform: Ys,
        setPosition: Yn,
        getPosition: $r,
        get disableTextSelection() {
          return Pr;
        },
        get enableTextSelection() {
          return Cr;
        },
        disableImageDrag: Go,
        enableImageDrag: sr,
        preventOutline: ki,
        restoreOutline: Ul,
        getSizedParentNode: ei,
        getScale: cl
      };
      function Bi(p, A, B, X) {
        if (A && typeof A == "object")
          for (var ne in A)
            Fi(p, ne, A[ne], B);
        else {
          A = Se(A);
          for (var ye = 0, We = A.length; ye < We; ye++)
            Fi(p, A[ye], B, X);
        }
        return this;
      }
      var ns = "_leaflet_events";
      function Cn(p, A, B, X) {
        if (arguments.length === 1)
          ca(p), delete p[ns];
        else if (A && typeof A == "object")
          for (var ne in A)
            Li(p, ne, A[ne], B);
        else if (A = Se(A), arguments.length === 2)
          ca(p, function(ot) {
            return ut(A, ot) !== -1;
          });
        else
          for (var ye = 0, We = A.length; ye < We; ye++)
            Li(p, A[ye], B, X);
        return this;
      }
      function ca(p, A) {
        for (var B in p[ns]) {
          var X = B.split(/\d/)[0];
          (!A || A(X)) && Li(p, X, null, null, B);
        }
      }
      var Ot = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function Fi(p, A, B, X) {
        var ne = A + O(B) + (X ? "_" + O(X) : "");
        if (p[ns] && p[ns][ne])
          return this;
        var ye = function(ot) {
          return B.call(X || p, ot || window.event);
        }, We = ye;
        !Ae.touchNative && Ae.pointer && A.indexOf("touch") === 0 ? ye = li(p, A, ye) : Ae.touch && A === "dblclick" ? ye = vs(p, ye) : "addEventListener" in p ? A === "touchstart" || A === "touchmove" || A === "wheel" || A === "mousewheel" ? p.addEventListener(Ot[A] || A, ye, Ae.passiveEvents ? { passive: !1 } : !1) : A === "mouseenter" || A === "mouseleave" ? (ye = function(ot) {
          ot = ot || window.event, ha(p, ot) && We(ot);
        }, p.addEventListener(Ot[A], ye, !1)) : p.addEventListener(A, We, !1) : p.attachEvent("on" + A, ye), p[ns] = p[ns] || {}, p[ns][ne] = ye;
      }
      function Li(p, A, B, X, ne) {
        ne = ne || A + O(B) + (X ? "_" + O(X) : "");
        var ye = p[ns] && p[ns][ne];
        if (!ye)
          return this;
        !Ae.touchNative && Ae.pointer && A.indexOf("touch") === 0 ? ri(p, A, ye) : Ae.touch && A === "dblclick" ? sa(p, ye) : "removeEventListener" in p ? p.removeEventListener(Ot[A] || A, ye, !1) : p.detachEvent("on" + A, ye), p[ns][ne] = null;
      }
      function ms(p) {
        return p.stopPropagation ? p.stopPropagation() : p.originalEvent ? p.originalEvent._stopped = !0 : p.cancelBubble = !0, this;
      }
      function vo(p) {
        return Fi(p, "wheel", ms), this;
      }
      function Ai(p) {
        return Bi(p, "mousedown touchstart dblclick contextmenu", ms), p._leaflet_disable_click = !0, this;
      }
      function _s(p) {
        return p.preventDefault ? p.preventDefault() : p.returnValue = !1, this;
      }
      function Ks(p) {
        return _s(p), ms(p), this;
      }
      function Zo(p) {
        if (p.composedPath)
          return p.composedPath();
        for (var A = [], B = p.target; B; )
          A.push(B), B = B.parentNode;
        return A;
      }
      function Ms(p, A) {
        if (!A)
          return new fi(p.clientX, p.clientY);
        var B = cl(A), X = B.boundingClientRect;
        return new fi(
          // offset.left/top values are in page scale (like clientX/Y),
          // whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
          (p.clientX - X.left) / B.x - A.clientLeft,
          (p.clientY - X.top) / B.y - A.clientTop
        );
      }
      var un = Ae.linux && Ae.chrome ? window.devicePixelRatio : Ae.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function Rc(p) {
        return Ae.edge ? p.wheelDeltaY / 2 : (
          // Don't trust window-geometry-based delta
          p.deltaY && p.deltaMode === 0 ? -p.deltaY / un : (
            // Pixels
            p.deltaY && p.deltaMode === 1 ? -p.deltaY * 20 : (
              // Lines
              p.deltaY && p.deltaMode === 2 ? -p.deltaY * 60 : (
                // Pages
                p.deltaX || p.deltaZ ? 0 : (
                  // Skip horizontal/depth wheel events
                  p.wheelDelta ? (p.wheelDeltaY || p.wheelDelta) / 2 : (
                    // Legacy IE pixels
                    p.detail && Math.abs(p.detail) < 32765 ? -p.detail * 20 : (
                      // Legacy Moz lines
                      p.detail ? p.detail / -32765 * 60 : (
                        // Legacy Moz pages
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
      function ha(p, A) {
        var B = A.relatedTarget;
        if (!B)
          return !0;
        try {
          for (; B && B !== p; )
            B = B.parentNode;
        } catch {
          return !1;
        }
        return B !== p;
      }
      var jl = {
        __proto__: null,
        on: Bi,
        off: Cn,
        stopPropagation: ms,
        disableScrollPropagation: vo,
        disableClickPropagation: Ai,
        preventDefault: _s,
        stop: Ks,
        getPropagationPath: Zo,
        getMousePosition: Ms,
        getWheelDelta: Rc,
        isExternalTarget: ha,
        addListener: Bi,
        removeListener: Cn
      }, ua = Ji.extend({
        // @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
        // Run an animation of a given element to a new position, optionally setting
        // duration in seconds (`0.25` by default) and easing linearity factor (3rd
        // argument of the [cubic bezier curve](https://cubic-bezier.com/#0,0,.5,1),
        // `0.5` by default).
        run: function(p, A, B, X) {
          this.stop(), this._el = p, this._inProgress = !0, this._duration = B || 0.25, this._easeOutPower = 1 / Math.max(X || 0.5, 0.2), this._startPos = $r(p), this._offset = A.subtract(this._startPos), this._startTime = +/* @__PURE__ */ new Date(), this.fire("start"), this._animate();
        },
        // @method stop()
        // Stops the animation (if currently running).
        stop: function() {
          this._inProgress && (this._step(!0), this._complete());
        },
        _animate: function() {
          this._animId = At(this._animate, this), this._step();
        },
        _step: function(p) {
          var A = +/* @__PURE__ */ new Date() - this._startTime, B = this._duration * 1e3;
          A < B ? this._runFrame(this._easeOut(A / B), p) : (this._runFrame(1), this._complete());
        },
        _runFrame: function(p, A) {
          var B = this._startPos.add(this._offset.multiplyBy(p));
          A && B._round(), Yn(this._el, B), this.fire("step");
        },
        _complete: function() {
          Si(this._animId), this._inProgress = !1, this.fire("end");
        },
        _easeOut: function(p) {
          return 1 - Math.pow(1 - p, this._easeOutPower);
        }
      }), nn = Ji.extend({
        options: {
          // @section Map State Options
          // @option crs: CRS = L.CRS.EPSG3857
          // The [Coordinate Reference System](#crs) to use. Don't change this if you're not
          // sure what it means.
          crs: Zr,
          // @option center: LatLng = undefined
          // Initial geographic center of the map
          center: void 0,
          // @option zoom: Number = undefined
          // Initial map zoom level
          zoom: void 0,
          // @option minZoom: Number = *
          // Minimum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the lowest of their `minZoom` options will be used instead.
          minZoom: void 0,
          // @option maxZoom: Number = *
          // Maximum zoom level of the map.
          // If not specified and at least one `GridLayer` or `TileLayer` is in the map,
          // the highest of their `maxZoom` options will be used instead.
          maxZoom: void 0,
          // @option layers: Layer[] = []
          // Array of layers that will be added to the map initially
          layers: [],
          // @option maxBounds: LatLngBounds = null
          // When this option is set, the map restricts the view to the given
          // geographical bounds, bouncing the user back if the user tries to pan
          // outside the view. To set the restriction dynamically, use
          // [`setMaxBounds`](#map-setmaxbounds) method.
          maxBounds: void 0,
          // @option renderer: Renderer = *
          // The default method for drawing vector layers on the map. `L.SVG`
          // or `L.Canvas` by default depending on browser support.
          renderer: void 0,
          // @section Animation Options
          // @option zoomAnimation: Boolean = true
          // Whether the map zoom animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          zoomAnimation: !0,
          // @option zoomAnimationThreshold: Number = 4
          // Won't animate zoom if the zoom difference exceeds this value.
          zoomAnimationThreshold: 4,
          // @option fadeAnimation: Boolean = true
          // Whether the tile fade animation is enabled. By default it's enabled
          // in all browsers that support CSS3 Transitions except Android.
          fadeAnimation: !0,
          // @option markerZoomAnimation: Boolean = true
          // Whether markers animate their zoom with the zoom animation, if disabled
          // they will disappear for the length of the animation. By default it's
          // enabled in all browsers that support CSS3 Transitions except Android.
          markerZoomAnimation: !0,
          // @option transform3DLimit: Number = 2^23
          // Defines the maximum size of a CSS translation transform. The default
          // value should not be changed unless a web browser positions layers in
          // the wrong place after doing a large `panBy`.
          transform3DLimit: 8388608,
          // Precision limit of a 32-bit float
          // @section Interaction Options
          // @option zoomSnap: Number = 1
          // Forces the map's zoom level to always be a multiple of this, particularly
          // right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
          // By default, the zoom level snaps to the nearest integer; lower values
          // (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
          // means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
          zoomSnap: 1,
          // @option zoomDelta: Number = 1
          // Controls how much the map's zoom level will change after a
          // [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
          // or `-` on the keyboard, or using the [zoom controls](#control-zoom).
          // Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
          zoomDelta: 1,
          // @option trackResize: Boolean = true
          // Whether the map automatically handles browser window resize to update itself.
          trackResize: !0
        },
        initialize: function(p, A) {
          A = we(this, A), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(p), this._initLayout(), this._onResize = P(this._onResize, this), this._initEvents(), A.maxBounds && this.setMaxBounds(A.maxBounds), A.zoom !== void 0 && (this._zoom = this._limitZoom(A.zoom)), A.center && A.zoom !== void 0 && this.setView(xi(A.center), A.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = ra && Ae.any3d && !Ae.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), Bi(this._proxy, al, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);
        },
        // @section Methods for modifying map state
        // @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) with the given
        // animation options.
        setView: function(p, A, B) {
          if (A = A === void 0 ? this._zoom : this._limitZoom(A), p = this._limitCenter(xi(p), A, this.options.maxBounds), B = B || {}, this._stop(), this._loaded && !B.reset && B !== !0) {
            B.animate !== void 0 && (B.zoom = w({ animate: B.animate }, B.zoom), B.pan = w({ animate: B.animate, duration: B.duration }, B.pan));
            var X = this._zoom !== A ? this._tryAnimatedZoom && this._tryAnimatedZoom(p, A, B.zoom) : this._tryAnimatedPan(p, B.pan);
            if (X)
              return clearTimeout(this._sizeTimer), this;
          }
          return this._resetView(p, A, B.pan && B.pan.noMoveStart), this;
        },
        // @method setZoom(zoom: Number, options?: Zoom/pan options): this
        // Sets the zoom of the map.
        setZoom: function(p, A) {
          return this._loaded ? this.setView(this.getCenter(), p, { zoom: A }) : (this._zoom = p, this);
        },
        // @method zoomIn(delta?: Number, options?: Zoom options): this
        // Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomIn: function(p, A) {
          return p = p || (Ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + p, A);
        },
        // @method zoomOut(delta?: Number, options?: Zoom options): this
        // Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
        zoomOut: function(p, A) {
          return p = p || (Ae.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - p, A);
        },
        // @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified geographical point on the map
        // stationary (e.g. used internally for scroll zoom and double-click zoom).
        // @alternative
        // @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
        // Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
        setZoomAround: function(p, A, B) {
          var X = this.getZoomScale(A), ne = this.getSize().divideBy(2), ye = p instanceof fi ? p : this.latLngToContainerPoint(p), We = ye.subtract(ne).multiplyBy(1 - 1 / X), ot = this.containerPointToLatLng(ne.add(We));
          return this.setView(ot, A, { zoom: B });
        },
        _getBoundsCenterZoom: function(p, A) {
          A = A || {}, p = p.getBounds ? p.getBounds() : ln(p);
          var B = ni(A.paddingTopLeft || A.padding || [0, 0]), X = ni(A.paddingBottomRight || A.padding || [0, 0]), ne = this.getBoundsZoom(p, !1, B.add(X));
          if (ne = typeof A.maxZoom == "number" ? Math.min(A.maxZoom, ne) : ne, ne === 1 / 0)
            return {
              center: p.getCenter(),
              zoom: ne
            };
          var ye = X.subtract(B).divideBy(2), We = this.project(p.getSouthWest(), ne), ot = this.project(p.getNorthEast(), ne), ft = this.unproject(We.add(ot).divideBy(2).add(ye), ne);
          return {
            center: ft,
            zoom: ne
          };
        },
        // @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets a map view that contains the given geographical bounds with the
        // maximum zoom level possible.
        fitBounds: function(p, A) {
          if (p = ln(p), !p.isValid())
            throw new Error("Bounds are not valid.");
          var B = this._getBoundsCenterZoom(p, A);
          return this.setView(B.center, B.zoom, A);
        },
        // @method fitWorld(options?: fitBounds options): this
        // Sets a map view that mostly contains the whole world with the maximum
        // zoom level possible.
        fitWorld: function(p) {
          return this.fitBounds([[-90, -180], [90, 180]], p);
        },
        // @method panTo(latlng: LatLng, options?: Pan options): this
        // Pans the map to a given center.
        panTo: function(p, A) {
          return this.setView(p, this._zoom, { pan: A });
        },
        // @method panBy(offset: Point, options?: Pan options): this
        // Pans the map by a given number of pixels (animated).
        panBy: function(p, A) {
          if (p = ni(p).round(), A = A || {}, !p.x && !p.y)
            return this.fire("moveend");
          if (A.animate !== !0 && !this.getSize().contains(p))
            return this._resetView(this.unproject(this.project(this.getCenter()).add(p)), this.getZoom()), this;
          if (this._panAnim || (this._panAnim = new ua(), this._panAnim.on({
            step: this._onPanTransitionStep,
            end: this._onPanTransitionEnd
          }, this)), A.noMoveStart || this.fire("movestart"), A.animate !== !1) {
            Vi(this._mapPane, "leaflet-pan-anim");
            var B = this._getMapPanePos().subtract(p).round();
            this._panAnim.run(this._mapPane, B, A.duration || 0.25, A.easeLinearity);
          } else
            this._rawPanBy(p), this.fire("move").fire("moveend");
          return this;
        },
        // @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
        // Sets the view of the map (geographical center and zoom) performing a smooth
        // pan-zoom animation.
        flyTo: function(p, A, B) {
          if (B = B || {}, B.animate === !1 || !Ae.any3d)
            return this.setView(p, A, B);
          this._stop();
          var X = this.project(this.getCenter()), ne = this.project(p), ye = this.getSize(), We = this._zoom;
          p = xi(p), A = A === void 0 ? We : A;
          var ot = Math.max(ye.x, ye.y), ft = ot * this.getZoomScale(We, A), Rt = ne.distanceTo(X) || 1, ii = 1.42, Ci = ii * ii;
          function Wi(es) {
            var Ao = es ? -1 : 1, $h = es ? ft : ot, Xh = ft * ft - ot * ot + Ao * Ci * Ci * Rt * Rt, Wc = 2 * $h * Ci * Rt, Ga = Xh / Wc, vr = Math.sqrt(Ga * Ga + 1) - Ga, $c = vr < 1e-9 ? -18 : Math.log(vr);
            return $c;
          }
          function Hs(es) {
            return (Math.exp(es) - Math.exp(-es)) / 2;
          }
          function ws(es) {
            return (Math.exp(es) + Math.exp(-es)) / 2;
          }
          function Rs(es) {
            return Hs(es) / ws(es);
          }
          var ur = Wi(0);
          function ja(es) {
            return ot * (ws(ur) / ws(ur + ii * es));
          }
          function ed(es) {
            return ot * (ws(ur) * Rs(ur + ii * es) - Hs(ur)) / Ci;
          }
          function td(es) {
            return 1 - Math.pow(1 - es, 1.5);
          }
          var id = Date.now(), Wh = (Wi(1) - ur) / ii, vl = B.duration ? 1e3 * B.duration : 1e3 * Wh * 0.8;
          function ec() {
            var es = (Date.now() - id) / vl, Ao = td(es) * Wh;
            es <= 1 ? (this._flyToFrame = At(ec, this), this._move(
              this.unproject(X.add(ne.subtract(X).multiplyBy(ed(Ao) / Rt)), We),
              this.getScaleZoom(ot / ja(Ao), We),
              { flyTo: !0 }
            )) : this._move(p, A)._moveEnd(!0);
          }
          return this._moveStart(!0, B.noMoveStart), ec.call(this), this;
        },
        // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
        // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
        // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
        flyToBounds: function(p, A) {
          var B = this._getBoundsCenterZoom(p, A);
          return this.flyTo(B.center, B.zoom, A);
        },
        // @method setMaxBounds(bounds: LatLngBounds): this
        // Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
        setMaxBounds: function(p) {
          return p = ln(p), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), p.isValid() ? (this.options.maxBounds = p, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this);
        },
        // @method setMinZoom(zoom: Number): this
        // Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
        setMinZoom: function(p) {
          var A = this.options.minZoom;
          return this.options.minZoom = p, this._loaded && A !== p && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(p) : this;
        },
        // @method setMaxZoom(zoom: Number): this
        // Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
        setMaxZoom: function(p) {
          var A = this.options.maxZoom;
          return this.options.maxZoom = p, this._loaded && A !== p && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(p) : this;
        },
        // @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
        // Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
        panInsideBounds: function(p, A) {
          this._enforcingBounds = !0;
          var B = this.getCenter(), X = this._limitCenter(B, this._zoom, ln(p));
          return B.equals(X) || this.panTo(X, A), this._enforcingBounds = !1, this;
        },
        // @method panInside(latlng: LatLng, options?: padding options): this
        // Pans the map the minimum amount to make the `latlng` visible. Use
        // padding options to fit the display to more restricted bounds.
        // If `latlng` is already within the (optionally padded) display bounds,
        // the map will not be panned.
        panInside: function(p, A) {
          A = A || {};
          var B = ni(A.paddingTopLeft || A.padding || [0, 0]), X = ni(A.paddingBottomRight || A.padding || [0, 0]), ne = this.project(this.getCenter()), ye = this.project(p), We = this.getPixelBounds(), ot = an([We.min.add(B), We.max.subtract(X)]), ft = ot.getSize();
          if (!ot.contains(ye)) {
            this._enforcingBounds = !0;
            var Rt = ye.subtract(ot.getCenter()), ii = ot.extend(ye).getSize().subtract(ft);
            ne.x += Rt.x < 0 ? -ii.x : ii.x, ne.y += Rt.y < 0 ? -ii.y : ii.y, this.panTo(this.unproject(ne), A), this._enforcingBounds = !1;
          }
          return this;
        },
        // @method invalidateSize(options: Zoom/pan options): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default. If `options.pan` is `false`, panning will not occur.
        // If `options.debounceMoveend` is `true`, it will delay `moveend` event so
        // that it doesn't happen often even if the method is called many
        // times in a row.
        // @alternative
        // @method invalidateSize(animate: Boolean): this
        // Checks if the map container size changed and updates the map if so —
        // call it after you've changed the map size dynamically, also animating
        // pan by default.
        invalidateSize: function(p) {
          if (!this._loaded)
            return this;
          p = w({
            animate: !1,
            pan: !0
          }, p === !0 ? { animate: !0 } : p);
          var A = this.getSize();
          this._sizeChanged = !0, this._lastCenter = null;
          var B = this.getSize(), X = A.divideBy(2).round(), ne = B.divideBy(2).round(), ye = X.subtract(ne);
          return !ye.x && !ye.y ? this : (p.animate && p.pan ? this.panBy(ye) : (p.pan && this._rawPanBy(ye), this.fire("move"), p.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(P(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", {
            oldSize: A,
            newSize: B
          }));
        },
        // @section Methods for modifying map state
        // @method stop(): this
        // Stops the currently running `panTo` or `flyTo` animation, if any.
        stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop();
        },
        // @section Geolocation methods
        // @method locate(options?: Locate options): this
        // Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
        // event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
        // and optionally sets the map view to the user's location with respect to
        // detection accuracy (or to the world view if geolocation failed).
        // Note that, if your page doesn't use HTTPS, this method will fail in
        // modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
        // See `Locate options` for more details.
        locate: function(p) {
          if (p = this._locateOptions = w({
            timeout: 1e4,
            watch: !1
            // setView: false
            // maxZoom: <Number>
            // maximumAge: 0
            // enableHighAccuracy: false
          }, p), !("geolocation" in navigator))
            return this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            }), this;
          var A = P(this._handleGeolocationResponse, this), B = P(this._handleGeolocationError, this);
          return p.watch ? this._locationWatchId = navigator.geolocation.watchPosition(A, B, p) : navigator.geolocation.getCurrentPosition(A, B, p), this;
        },
        // @method stopLocate(): this
        // Stops watching location previously initiated by `map.locate({watch: true})`
        // and aborts resetting the map view if map.locate was called with
        // `{setView: true}`.
        stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;
        },
        _handleGeolocationError: function(p) {
          if (this._container._leaflet_id) {
            var A = p.code, B = p.message || (A === 1 ? "permission denied" : A === 2 ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
              code: A,
              message: "Geolocation error: " + B + "."
            });
          }
        },
        _handleGeolocationResponse: function(p) {
          if (this._container._leaflet_id) {
            var A = p.coords.latitude, B = p.coords.longitude, X = new Di(A, B), ne = X.toBounds(p.coords.accuracy * 2), ye = this._locateOptions;
            if (ye.setView) {
              var We = this.getBoundsZoom(ne);
              this.setView(X, ye.maxZoom ? Math.min(We, ye.maxZoom) : We);
            }
            var ot = {
              latlng: X,
              bounds: ne,
              timestamp: p.timestamp
            };
            for (var ft in p.coords)
              typeof p.coords[ft] == "number" && (ot[ft] = p.coords[ft]);
            this.fire("locationfound", ot);
          }
        },
        // TODO Appropriate docs section?
        // @section Other Methods
        // @method addHandler(name: String, HandlerClass: Function): this
        // Adds a new `Handler` to the map, given its name and constructor function.
        addHandler: function(p, A) {
          if (!A)
            return this;
          var B = this[p] = new A(this);
          return this._handlers.push(B), this.options[p] && B.enable(), this;
        },
        // @method remove(): this
        // Destroys the map and clears all related event listeners.
        remove: function() {
          if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id)
            throw new Error("Map container is being reused by another instance");
          try {
            delete this._container._leaflet_id, delete this._containerId;
          } catch {
            this._container._leaflet_id = void 0, this._containerId = void 0;
          }
          this._locationWatchId !== void 0 && this.stopLocate(), this._stop(), xn(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (Si(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload");
          var p;
          for (p in this._layers)
            this._layers[p].remove();
          for (p in this._panes)
            xn(this._panes[p]);
          return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;
        },
        // @section Other Methods
        // @method createPane(name: String, container?: HTMLElement): HTMLElement
        // Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
        // then returns it. The pane is created as a child of `container`, or
        // as a child of the main map pane if not set.
        createPane: function(p, A) {
          var B = "leaflet-pane" + (p ? " leaflet-" + p.replace("Pane", "") + "-pane" : ""), X = tn("div", B, A || this._mapPane);
          return p && (this._panes[p] = X), X;
        },
        // @section Methods for Getting Map State
        // @method getCenter(): LatLng
        // Returns the geographical center of the map view
        getCenter: function() {
          return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        // @method getZoom(): Number
        // Returns the current zoom level of the map view
        getZoom: function() {
          return this._zoom;
        },
        // @method getBounds(): LatLngBounds
        // Returns the geographical bounds visible in the current map view
        getBounds: function() {
          var p = this.getPixelBounds(), A = this.unproject(p.getBottomLeft()), B = this.unproject(p.getTopRight());
          return new qt(A, B);
        },
        // @method getMinZoom(): Number
        // Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        // @method getMaxZoom(): Number
        // Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
        },
        // @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
        // Returns the maximum zoom level on which the given bounds fit to the map
        // view in its entirety. If `inside` (optional) is set to `true`, the method
        // instead returns the minimum zoom level on which the map view fits into
        // the given bounds in its entirety.
        getBoundsZoom: function(p, A, B) {
          p = ln(p), B = ni(B || [0, 0]);
          var X = this.getZoom() || 0, ne = this.getMinZoom(), ye = this.getMaxZoom(), We = p.getNorthWest(), ot = p.getSouthEast(), ft = this.getSize().subtract(B), Rt = an(this.project(ot, X), this.project(We, X)).getSize(), ii = Ae.any3d ? this.options.zoomSnap : 1, Ci = ft.x / Rt.x, Wi = ft.y / Rt.y, Hs = A ? Math.max(Ci, Wi) : Math.min(Ci, Wi);
          return X = this.getScaleZoom(Hs, X), ii && (X = Math.round(X / (ii / 100)) * (ii / 100), X = A ? Math.ceil(X / ii) * ii : Math.floor(X / ii) * ii), Math.max(ne, Math.min(ye, X));
        },
        // @method getSize(): Point
        // Returns the current size of the map container (in pixels).
        getSize: function() {
          return (!this._size || this._sizeChanged) && (this._size = new fi(
            this._container.clientWidth || 0,
            this._container.clientHeight || 0
          ), this._sizeChanged = !1), this._size.clone();
        },
        // @method getPixelBounds(): Bounds
        // Returns the bounds of the current map view in projected pixel
        // coordinates (sometimes useful in layer and overlay implementations).
        getPixelBounds: function(p, A) {
          var B = this._getTopLeftPoint(p, A);
          return new Gi(B, B.add(this.getSize()));
        },
        // TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
        // the map pane? "left point of the map layer" can be confusing, specially
        // since there can be negative offsets.
        // @method getPixelOrigin(): Point
        // Returns the projected pixel coordinates of the top left point of
        // the map layer (useful in custom layer and overlay implementations).
        getPixelOrigin: function() {
          return this._checkIfLoaded(), this._pixelOrigin;
        },
        // @method getPixelWorldBounds(zoom?: Number): Bounds
        // Returns the world's bounds in pixel coordinates for zoom level `zoom`.
        // If `zoom` is omitted, the map's current zoom level is used.
        getPixelWorldBounds: function(p) {
          return this.options.crs.getProjectedBounds(p === void 0 ? this.getZoom() : p);
        },
        // @section Other Methods
        // @method getPane(pane: String|HTMLElement): HTMLElement
        // Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
        getPane: function(p) {
          return typeof p == "string" ? this._panes[p] : p;
        },
        // @method getPanes(): Object
        // Returns a plain object containing the names of all [panes](#map-pane) as keys and
        // the panes as values.
        getPanes: function() {
          return this._panes;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the map.
        getContainer: function() {
          return this._container;
        },
        // @section Conversion Methods
        // @method getZoomScale(toZoom: Number, fromZoom: Number): Number
        // Returns the scale factor to be applied to a map transition from zoom level
        // `fromZoom` to `toZoom`. Used internally to help with zoom animations.
        getZoomScale: function(p, A) {
          var B = this.options.crs;
          return A = A === void 0 ? this._zoom : A, B.scale(p) / B.scale(A);
        },
        // @method getScaleZoom(scale: Number, fromZoom: Number): Number
        // Returns the zoom level that the map would end up at, if it is at `fromZoom`
        // level and everything is scaled by a factor of `scale`. Inverse of
        // [`getZoomScale`](#map-getZoomScale).
        getScaleZoom: function(p, A) {
          var B = this.options.crs;
          A = A === void 0 ? this._zoom : A;
          var X = B.zoom(p * B.scale(A));
          return isNaN(X) ? 1 / 0 : X;
        },
        // @method project(latlng: LatLng, zoom: Number): Point
        // Projects a geographical coordinate `LatLng` according to the projection
        // of the map's CRS, then scales it according to `zoom` and the CRS's
        // `Transformation`. The result is pixel coordinate relative to
        // the CRS origin.
        project: function(p, A) {
          return A = A === void 0 ? this._zoom : A, this.options.crs.latLngToPoint(xi(p), A);
        },
        // @method unproject(point: Point, zoom: Number): LatLng
        // Inverse of [`project`](#map-project).
        unproject: function(p, A) {
          return A = A === void 0 ? this._zoom : A, this.options.crs.pointToLatLng(ni(p), A);
        },
        // @method layerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding geographical coordinate (for the current zoom level).
        layerPointToLatLng: function(p) {
          var A = ni(p).add(this.getPixelOrigin());
          return this.unproject(A);
        },
        // @method latLngToLayerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the [origin pixel](#map-getpixelorigin).
        latLngToLayerPoint: function(p) {
          var A = this.project(xi(p))._round();
          return A._subtract(this.getPixelOrigin());
        },
        // @method wrapLatLng(latlng: LatLng): LatLng
        // Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
        // map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
        // CRS's bounds.
        // By default this means longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees.
        wrapLatLng: function(p) {
          return this.options.crs.wrapLatLng(xi(p));
        },
        // @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
        // Returns a `LatLngBounds` with the same size as the given one, ensuring that
        // its center is within the CRS's bounds.
        // By default this means the center longitude is wrapped around the dateline so its
        // value is between -180 and +180 degrees, and the majority of the bounds
        // overlaps the CRS's bounds.
        wrapLatLngBounds: function(p) {
          return this.options.crs.wrapLatLngBounds(ln(p));
        },
        // @method distance(latlng1: LatLng, latlng2: LatLng): Number
        // Returns the distance between two geographical coordinates according to
        // the map's CRS. By default this measures distance in meters.
        distance: function(p, A) {
          return this.options.crs.distance(xi(p), xi(A));
        },
        // @method containerPointToLayerPoint(point: Point): Point
        // Given a pixel coordinate relative to the map container, returns the corresponding
        // pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
        containerPointToLayerPoint: function(p) {
          return ni(p).subtract(this._getMapPanePos());
        },
        // @method layerPointToContainerPoint(point: Point): Point
        // Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
        // returns the corresponding pixel coordinate relative to the map container.
        layerPointToContainerPoint: function(p) {
          return ni(p).add(this._getMapPanePos());
        },
        // @method containerPointToLatLng(point: Point): LatLng
        // Given a pixel coordinate relative to the map container, returns
        // the corresponding geographical coordinate (for the current zoom level).
        containerPointToLatLng: function(p) {
          var A = this.containerPointToLayerPoint(ni(p));
          return this.layerPointToLatLng(A);
        },
        // @method latLngToContainerPoint(latlng: LatLng): Point
        // Given a geographical coordinate, returns the corresponding pixel coordinate
        // relative to the map container.
        latLngToContainerPoint: function(p) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(xi(p)));
        },
        // @method mouseEventToContainerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to the
        // map container where the event took place.
        mouseEventToContainerPoint: function(p) {
          return Ms(p, this._container);
        },
        // @method mouseEventToLayerPoint(ev: MouseEvent): Point
        // Given a MouseEvent object, returns the pixel coordinate relative to
        // the [origin pixel](#map-getpixelorigin) where the event took place.
        mouseEventToLayerPoint: function(p) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(p));
        },
        // @method mouseEventToLatLng(ev: MouseEvent): LatLng
        // Given a MouseEvent object, returns geographical coordinate where the
        // event took place.
        mouseEventToLatLng: function(p) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(p));
        },
        // map initialization methods
        _initContainer: function(p) {
          var A = this._container = Vo(p);
          if (A) {
            if (A._leaflet_id)
              throw new Error("Map container is already initialized.");
          } else
            throw new Error("Map container not found.");
          Bi(A, "scroll", this._onScroll, this), this._containerId = O(A);
        },
        _initLayout: function() {
          var p = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Ae.any3d, Vi(p, "leaflet-container" + (Ae.touch ? " leaflet-touch" : "") + (Ae.retina ? " leaflet-retina" : "") + (Ae.ielt9 ? " leaflet-oldie" : "") + (Ae.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var A = Uo(p, "position");
          A !== "absolute" && A !== "relative" && A !== "fixed" && A !== "sticky" && (p.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos();
        },
        _initPanes: function() {
          var p = this._panes = {};
          this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Yn(this._mapPane, new fi(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (Vi(p.markerPane, "leaflet-zoom-hide"), Vi(p.shadowPane, "leaflet-zoom-hide"));
        },
        // private methods that modify map state
        // @section Map state change events
        _resetView: function(p, A, B) {
          Yn(this._mapPane, new fi(0, 0));
          var X = !this._loaded;
          this._loaded = !0, A = this._limitZoom(A), this.fire("viewprereset");
          var ne = this._zoom !== A;
          this._moveStart(ne, B)._move(p, A)._moveEnd(ne), this.fire("viewreset"), X && this.fire("load");
        },
        _moveStart: function(p, A) {
          return p && this.fire("zoomstart"), A || this.fire("movestart"), this;
        },
        _move: function(p, A, B, X) {
          A === void 0 && (A = this._zoom);
          var ne = this._zoom !== A;
          return this._zoom = A, this._lastCenter = p, this._pixelOrigin = this._getNewPixelOrigin(p), X ? B && B.pinch && this.fire("zoom", B) : ((ne || B && B.pinch) && this.fire("zoom", B), this.fire("move", B)), this;
        },
        _moveEnd: function(p) {
          return p && this.fire("zoomend"), this.fire("moveend");
        },
        _stop: function() {
          return Si(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;
        },
        _rawPanBy: function(p) {
          Yn(this._mapPane, this._getMapPanePos().subtract(p));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
        },
        _checkIfLoaded: function() {
          if (!this._loaded)
            throw new Error("Set map center and zoom first.");
        },
        // DOM event handling
        // @section Interaction events
        _initEvents: function(p) {
          this._targets = {}, this._targets[O(this._container)] = this;
          var A = p ? Cn : Bi;
          A(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && A(window, "resize", this._onResize, this), Ae.any3d && this.options.transform3DLimit && (p ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
        },
        _onResize: function() {
          Si(this._resizeRequest), this._resizeRequest = At(
            function() {
              this.invalidateSize({ debounceMoveend: !0 });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0, this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var p = this._getMapPanePos();
          Math.max(Math.abs(p.x), Math.abs(p.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
        },
        _findEventTargets: function(p, A) {
          for (var B = [], X, ne = A === "mouseout" || A === "mouseover", ye = p.target || p.srcElement, We = !1; ye; ) {
            if (X = this._targets[O(ye)], X && (A === "click" || A === "preclick") && this._draggableMoved(X)) {
              We = !0;
              break;
            }
            if (X && X.listens(A, !0) && (ne && !ha(ye, p) || (B.push(X), ne)) || ye === this._container)
              break;
            ye = ye.parentNode;
          }
          return !B.length && !We && !ne && this.listens(A, !0) && (B = [this]), B;
        },
        _isClickDisabled: function(p) {
          for (; p && p !== this._container; ) {
            if (p._leaflet_disable_click)
              return !0;
            p = p.parentNode;
          }
        },
        _handleDOMEvent: function(p) {
          var A = p.target || p.srcElement;
          if (!(!this._loaded || A._leaflet_disable_events || p.type === "click" && this._isClickDisabled(A))) {
            var B = p.type;
            B === "mousedown" && ki(A), this._fireDOMEvent(p, B);
          }
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(p, A, B) {
          if (p.type === "click") {
            var X = w({}, p);
            X.type = "preclick", this._fireDOMEvent(X, X.type, B);
          }
          var ne = this._findEventTargets(p, A);
          if (B) {
            for (var ye = [], We = 0; We < B.length; We++)
              B[We].listens(A, !0) && ye.push(B[We]);
            ne = ye.concat(ne);
          }
          if (ne.length) {
            A === "contextmenu" && _s(p);
            var ot = ne[0], ft = {
              originalEvent: p
            };
            if (p.type !== "keypress" && p.type !== "keydown" && p.type !== "keyup") {
              var Rt = ot.getLatLng && (!ot._radius || ot._radius <= 10);
              ft.containerPoint = Rt ? this.latLngToContainerPoint(ot.getLatLng()) : this.mouseEventToContainerPoint(p), ft.layerPoint = this.containerPointToLayerPoint(ft.containerPoint), ft.latlng = Rt ? ot.getLatLng() : this.layerPointToLatLng(ft.layerPoint);
            }
            for (We = 0; We < ne.length; We++)
              if (ne[We].fire(A, ft, !0), ft.originalEvent._stopped || ne[We].options.bubblingMouseEvents === !1 && ut(this._mouseEvents, A) !== -1)
                return;
          }
        },
        _draggableMoved: function(p) {
          return p = p.dragging && p.dragging.enabled() ? p : this, p.dragging && p.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var p = 0, A = this._handlers.length; p < A; p++)
            this._handlers[p].disable();
        },
        // @section Other Methods
        // @method whenReady(fn: Function, context?: Object): this
        // Runs the given function `fn` when the map gets initialized with
        // a view (center and zoom) and at least one layer, or immediately
        // if it's already initialized, optionally passing a function context.
        whenReady: function(p, A) {
          return this._loaded ? p.call(A || this, { target: this }) : this.on("load", p, A), this;
        },
        // private methods for getting map state
        _getMapPanePos: function() {
          return $r(this._mapPane) || new fi(0, 0);
        },
        _moved: function() {
          var p = this._getMapPanePos();
          return p && !p.equals([0, 0]);
        },
        _getTopLeftPoint: function(p, A) {
          var B = p && A !== void 0 ? this._getNewPixelOrigin(p, A) : this.getPixelOrigin();
          return B.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(p, A) {
          var B = this.getSize()._divideBy(2);
          return this.project(p, A)._subtract(B)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(p, A, B) {
          var X = this._getNewPixelOrigin(B, A);
          return this.project(p, A)._subtract(X);
        },
        _latLngBoundsToNewLayerBounds: function(p, A, B) {
          var X = this._getNewPixelOrigin(B, A);
          return an([
            this.project(p.getSouthWest(), A)._subtract(X),
            this.project(p.getNorthWest(), A)._subtract(X),
            this.project(p.getSouthEast(), A)._subtract(X),
            this.project(p.getNorthEast(), A)._subtract(X)
          ]);
        },
        // layer point of the current center
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        // offset of the specified place to the current center in pixels
        _getCenterOffset: function(p) {
          return this.latLngToLayerPoint(p).subtract(this._getCenterLayerPoint());
        },
        // adjust center for view to get inside bounds
        _limitCenter: function(p, A, B) {
          if (!B)
            return p;
          var X = this.project(p, A), ne = this.getSize().divideBy(2), ye = new Gi(X.subtract(ne), X.add(ne)), We = this._getBoundsOffset(ye, B, A);
          return Math.abs(We.x) <= 1 && Math.abs(We.y) <= 1 ? p : this.unproject(X.add(We), A);
        },
        // adjust offset for view to get inside bounds
        _limitOffset: function(p, A) {
          if (!A)
            return p;
          var B = this.getPixelBounds(), X = new Gi(B.min.add(p), B.max.add(p));
          return p.add(this._getBoundsOffset(X, A));
        },
        // returns offset needed for pxBounds to get inside maxBounds at a specified zoom
        _getBoundsOffset: function(p, A, B) {
          var X = an(
            this.project(A.getNorthEast(), B),
            this.project(A.getSouthWest(), B)
          ), ne = X.min.subtract(p.min), ye = X.max.subtract(p.max), We = this._rebound(ne.x, -ye.x), ot = this._rebound(ne.y, -ye.y);
          return new fi(We, ot);
        },
        _rebound: function(p, A) {
          return p + A > 0 ? Math.round(p - A) / 2 : Math.max(0, Math.ceil(p)) - Math.max(0, Math.floor(A));
        },
        _limitZoom: function(p) {
          var A = this.getMinZoom(), B = this.getMaxZoom(), X = Ae.any3d ? this.options.zoomSnap : 1;
          return X && (p = Math.round(p / X) * X), Math.max(A, Math.min(B, p));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          Hn(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
        },
        _tryAnimatedPan: function(p, A) {
          var B = this._getCenterOffset(p)._trunc();
          return (A && A.animate) !== !0 && !this.getSize().contains(B) ? !1 : (this.panBy(B, A), !0);
        },
        _createAnimProxy: function() {
          var p = this._proxy = tn("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(p), this.on("zoomanim", function(A) {
            var B = Er, X = this._proxy.style[B];
            Ys(this._proxy, this.project(A.center, A.zoom), this.getZoomScale(A.zoom, 1)), X === this._proxy.style[B] && this._animatingZoom && this._onZoomTransitionEnd();
          }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          xn(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
        },
        _animMoveEnd: function() {
          var p = this.getCenter(), A = this.getZoom();
          Ys(this._proxy, this.project(p, A), this.getZoomScale(A, 1));
        },
        _catchTransitionEnd: function(p) {
          this._animatingZoom && p.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(p, A, B) {
          if (this._animatingZoom)
            return !0;
          if (B = B || {}, !this._zoomAnimated || B.animate === !1 || this._nothingToAnimate() || Math.abs(A - this._zoom) > this.options.zoomAnimationThreshold)
            return !1;
          var X = this.getZoomScale(A), ne = this._getCenterOffset(p)._divideBy(1 - 1 / X);
          return B.animate !== !0 && !this.getSize().contains(ne) ? !1 : (At(function() {
            this._moveStart(!0, B.noMoveStart || !1)._animateZoom(p, A, !0);
          }, this), !0);
        },
        _animateZoom: function(p, A, B, X) {
          this._mapPane && (B && (this._animatingZoom = !0, this._animateToCenter = p, this._animateToZoom = A, Vi(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
            center: p,
            zoom: A,
            noUpdate: X
          }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(P(this._onZoomTransitionEnd, this), 250));
        },
        _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && Hn(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0));
        }
      });
      function hl(p, A) {
        return new nn(p, A);
      }
      var Dn = hn.extend({
        // @section
        // @aka Control Options
        options: {
          // @option position: String = 'topright'
          // The position of the control (one of the map corners). Possible values are `'topleft'`,
          // `'topright'`, `'bottomleft'` or `'bottomright'`
          position: "topright"
        },
        initialize: function(p) {
          we(this, p);
        },
        /* @section
         * Classes extending L.Control will inherit the following methods:
         *
         * @method getPosition: string
         * Returns the position of the control.
         */
        getPosition: function() {
          return this.options.position;
        },
        // @method setPosition(position: string): this
        // Sets the position of the control.
        setPosition: function(p) {
          var A = this._map;
          return A && A.removeControl(this), this.options.position = p, A && A.addControl(this), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTMLElement that contains the control.
        getContainer: function() {
          return this._container;
        },
        // @method addTo(map: Map): this
        // Adds the control to the given map.
        addTo: function(p) {
          this.remove(), this._map = p;
          var A = this._container = this.onAdd(p), B = this.getPosition(), X = p._controlCorners[B];
          return Vi(A, "leaflet-control"), B.indexOf("bottom") !== -1 ? X.insertBefore(A, X.firstChild) : X.appendChild(A), this._map.on("unload", this.remove, this), this;
        },
        // @method remove: this
        // Removes the control from the map it is currently active on.
        remove: function() {
          return this._map ? (xn(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null, this) : this;
        },
        _refocusOnMap: function(p) {
          this._map && p && p.screenX > 0 && p.screenY > 0 && this._map.getContainer().focus();
        }
      }), rr = function(p) {
        return new Dn(p);
      };
      nn.include({
        // @method addControl(control: Control): this
        // Adds the given control to the map
        addControl: function(p) {
          return p.addTo(this), this;
        },
        // @method removeControl(control: Control): this
        // Removes the given control from the map
        removeControl: function(p) {
          return p.remove(), this;
        },
        _initControlPos: function() {
          var p = this._controlCorners = {}, A = "leaflet-", B = this._controlContainer = tn("div", A + "control-container", this._container);
          function X(ne, ye) {
            var We = A + ne + " " + A + ye;
            p[ne + ye] = tn("div", We, B);
          }
          X("top", "left"), X("top", "right"), X("bottom", "left"), X("bottom", "right");
        },
        _clearControlPos: function() {
          for (var p in this._controlCorners)
            xn(this._controlCorners[p]);
          xn(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
        }
      });
      var ss = Dn.extend({
        // @section
        // @aka Control.Layers options
        options: {
          // @option collapsed: Boolean = true
          // If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
          collapsed: !0,
          position: "topright",
          // @option autoZIndex: Boolean = true
          // If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
          autoZIndex: !0,
          // @option hideSingleBase: Boolean = false
          // If `true`, the base layers in the control will be hidden when there is only one.
          hideSingleBase: !1,
          // @option sortLayers: Boolean = false
          // Whether to sort the layers. When `false`, layers will keep the order
          // in which they were added to the control.
          sortLayers: !1,
          // @option sortFunction: Function = *
          // A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
          // that will be used for sorting the layers, when `sortLayers` is `true`.
          // The function receives both the `L.Layer` instances and their names, as in
          // `sortFunction(layerA, layerB, nameA, nameB)`.
          // By default, it sorts layers alphabetically by their name.
          sortFunction: function(p, A, B, X) {
            return B < X ? -1 : X < B ? 1 : 0;
          }
        },
        initialize: function(p, A, B) {
          we(this, B), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1;
          for (var X in p)
            this._addLayer(p[X], X);
          for (X in A)
            this._addLayer(A[X], X, !0);
        },
        onAdd: function(p) {
          this._initLayout(), this._update(), this._map = p, p.on("zoomend", this._checkDisabledLayers, this);
          for (var A = 0; A < this._layers.length; A++)
            this._layers[A].layer.on("add remove", this._onLayerChange, this);
          return this._container;
        },
        addTo: function(p) {
          return Dn.prototype.addTo.call(this, p), this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var p = 0; p < this._layers.length; p++)
            this._layers[p].layer.off("add remove", this._onLayerChange, this);
        },
        // @method addBaseLayer(layer: Layer, name: String): this
        // Adds a base layer (radio button entry) with the given name to the control.
        addBaseLayer: function(p, A) {
          return this._addLayer(p, A), this._map ? this._update() : this;
        },
        // @method addOverlay(layer: Layer, name: String): this
        // Adds an overlay (checkbox entry) with the given name to the control.
        addOverlay: function(p, A) {
          return this._addLayer(p, A, !0), this._map ? this._update() : this;
        },
        // @method removeLayer(layer: Layer): this
        // Remove the given layer from the control.
        removeLayer: function(p) {
          p.off("add remove", this._onLayerChange, this);
          var A = this._getLayer(O(p));
          return A && this._layers.splice(this._layers.indexOf(A), 1), this._map ? this._update() : this;
        },
        // @method expand(): this
        // Expand the control container if collapsed.
        expand: function() {
          Vi(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
          var p = this._map.getSize().y - (this._container.offsetTop + 50);
          return p < this._section.clientHeight ? (Vi(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = p + "px") : Hn(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this;
        },
        // @method collapse(): this
        // Collapse the control container if expanded.
        collapse: function() {
          return Hn(this._container, "leaflet-control-layers-expanded"), this;
        },
        _initLayout: function() {
          var p = "leaflet-control-layers", A = this._container = tn("div", p), B = this.options.collapsed;
          A.setAttribute("aria-haspopup", !0), Ai(A), vo(A);
          var X = this._section = tn("section", p + "-list");
          B && (this._map.on("click", this.collapse, this), Bi(A, {
            mouseenter: this._expandSafely,
            mouseleave: this.collapse
          }, this));
          var ne = this._layersLink = tn("a", p + "-toggle", A);
          ne.href = "#", ne.title = "Layers", ne.setAttribute("role", "button"), Bi(ne, {
            keydown: function(ye) {
              ye.keyCode === 13 && this._expandSafely();
            },
            // Certain screen readers intercept the key event and instead send a click event
            click: function(ye) {
              _s(ye), this._expandSafely();
            }
          }, this), B || this.expand(), this._baseLayersList = tn("div", p + "-base", X), this._separator = tn("div", p + "-separator", X), this._overlaysList = tn("div", p + "-overlays", X), A.appendChild(X);
        },
        _getLayer: function(p) {
          for (var A = 0; A < this._layers.length; A++)
            if (this._layers[A] && O(this._layers[A].layer) === p)
              return this._layers[A];
        },
        _addLayer: function(p, A, B) {
          this._map && p.on("add remove", this._onLayerChange, this), this._layers.push({
            layer: p,
            name: A,
            overlay: B
          }), this.options.sortLayers && this._layers.sort(P(function(X, ne) {
            return this.options.sortFunction(X.layer, ne.layer, X.name, ne.name);
          }, this)), this.options.autoZIndex && p.setZIndex && (this._lastZIndex++, p.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container)
            return this;
          no(this._baseLayersList), no(this._overlaysList), this._layerControlInputs = [];
          var p, A, B, X, ne = 0;
          for (B = 0; B < this._layers.length; B++)
            X = this._layers[B], this._addItem(X), A = A || X.overlay, p = p || !X.overlay, ne += X.overlay ? 0 : 1;
          return this.options.hideSingleBase && (p = p && ne > 1, this._baseLayersList.style.display = p ? "" : "none"), this._separator.style.display = A && p ? "" : "none", this;
        },
        _onLayerChange: function(p) {
          this._handlingClick || this._update();
          var A = this._getLayer(O(p.target)), B = A.overlay ? p.type === "add" ? "overlayadd" : "overlayremove" : p.type === "add" ? "baselayerchange" : null;
          B && this._map.fire(B, A);
        },
        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see https://stackoverflow.com/a/119079)
        _createRadioElement: function(p, A) {
          var B = '<input type="radio" class="leaflet-control-layers-selector" name="' + p + '"' + (A ? ' checked="checked"' : "") + "/>", X = document.createElement("div");
          return X.innerHTML = B, X.firstChild;
        },
        _addItem: function(p) {
          var A = document.createElement("label"), B = this._map.hasLayer(p.layer), X;
          p.overlay ? (X = document.createElement("input"), X.type = "checkbox", X.className = "leaflet-control-layers-selector", X.defaultChecked = B) : X = this._createRadioElement("leaflet-base-layers_" + O(this), B), this._layerControlInputs.push(X), X.layerId = O(p.layer), Bi(X, "click", this._onInputClick, this);
          var ne = document.createElement("span");
          ne.innerHTML = " " + p.name;
          var ye = document.createElement("span");
          A.appendChild(ye), ye.appendChild(X), ye.appendChild(ne);
          var We = p.overlay ? this._overlaysList : this._baseLayersList;
          return We.appendChild(A), this._checkDisabledLayers(), A;
        },
        _onInputClick: function() {
          if (!this._preventClick) {
            var p = this._layerControlInputs, A, B, X = [], ne = [];
            this._handlingClick = !0;
            for (var ye = p.length - 1; ye >= 0; ye--)
              A = p[ye], B = this._getLayer(A.layerId).layer, A.checked ? X.push(B) : A.checked || ne.push(B);
            for (ye = 0; ye < ne.length; ye++)
              this._map.hasLayer(ne[ye]) && this._map.removeLayer(ne[ye]);
            for (ye = 0; ye < X.length; ye++)
              this._map.hasLayer(X[ye]) || this._map.addLayer(X[ye]);
            this._handlingClick = !1, this._refocusOnMap();
          }
        },
        _checkDisabledLayers: function() {
          for (var p = this._layerControlInputs, A, B, X = this._map.getZoom(), ne = p.length - 1; ne >= 0; ne--)
            A = p[ne], B = this._getLayer(A.layerId).layer, A.disabled = B.options.minZoom !== void 0 && X < B.options.minZoom || B.options.maxZoom !== void 0 && X > B.options.maxZoom;
        },
        _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(), this;
        },
        _expandSafely: function() {
          var p = this._section;
          this._preventClick = !0, Bi(p, "click", _s), this.expand();
          var A = this;
          setTimeout(function() {
            Cn(p, "click", _s), A._preventClick = !1;
          });
        }
      }), da = function(p, A, B) {
        return new ss(p, A, B);
      }, bo = Dn.extend({
        // @section
        // @aka Control.Zoom options
        options: {
          position: "topleft",
          // @option zoomInText: String = '<span aria-hidden="true">+</span>'
          // The text set on the 'zoom in' button.
          zoomInText: '<span aria-hidden="true">+</span>',
          // @option zoomInTitle: String = 'Zoom in'
          // The title set on the 'zoom in' button.
          zoomInTitle: "Zoom in",
          // @option zoomOutText: String = '<span aria-hidden="true">&#x2212;</span>'
          // The text set on the 'zoom out' button.
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          // @option zoomOutTitle: String = 'Zoom out'
          // The title set on the 'zoom out' button.
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(p) {
          var A = "leaflet-control-zoom", B = tn("div", A + " leaflet-bar"), X = this.options;
          return this._zoomInButton = this._createButton(
            X.zoomInText,
            X.zoomInTitle,
            A + "-in",
            B,
            this._zoomIn
          ), this._zoomOutButton = this._createButton(
            X.zoomOutText,
            X.zoomOutTitle,
            A + "-out",
            B,
            this._zoomOut
          ), this._updateDisabled(), p.on("zoomend zoomlevelschange", this._updateDisabled, this), B;
        },
        onRemove: function(p) {
          p.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          return this._disabled = !0, this._updateDisabled(), this;
        },
        enable: function() {
          return this._disabled = !1, this._updateDisabled(), this;
        },
        _zoomIn: function(p) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (p.shiftKey ? 3 : 1));
        },
        _zoomOut: function(p) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (p.shiftKey ? 3 : 1));
        },
        _createButton: function(p, A, B, X, ne) {
          var ye = tn("a", B, X);
          return ye.innerHTML = p, ye.href = "#", ye.title = A, ye.setAttribute("role", "button"), ye.setAttribute("aria-label", A), Ai(ye), Bi(ye, "click", Ks), Bi(ye, "click", ne, this), Bi(ye, "click", this._refocusOnMap, this), ye;
        },
        _updateDisabled: function() {
          var p = this._map, A = "leaflet-disabled";
          Hn(this._zoomInButton, A), Hn(this._zoomOutButton, A), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), (this._disabled || p._zoom === p.getMinZoom()) && (Vi(this._zoomOutButton, A), this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || p._zoom === p.getMaxZoom()) && (Vi(this._zoomInButton, A), this._zoomInButton.setAttribute("aria-disabled", "true"));
        }
      });
      nn.mergeOptions({
        zoomControl: !0
      }), nn.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new bo(), this.addControl(this.zoomControl));
      });
      var vn = function(p) {
        return new bo(p);
      }, Ir = Dn.extend({
        // @section
        // @aka Control.Scale options
        options: {
          position: "bottomleft",
          // @option maxWidth: Number = 100
          // Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
          maxWidth: 100,
          // @option metric: Boolean = True
          // Whether to show the metric scale line (m/km).
          metric: !0,
          // @option imperial: Boolean = True
          // Whether to show the imperial scale line (mi/ft).
          imperial: !0
          // @option updateWhenIdle: Boolean = false
          // If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
        },
        onAdd: function(p) {
          var A = "leaflet-control-scale", B = tn("div", A), X = this.options;
          return this._addScales(X, A + "-line", B), p.on(X.updateWhenIdle ? "moveend" : "move", this._update, this), p.whenReady(this._update, this), B;
        },
        onRemove: function(p) {
          p.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(p, A, B) {
          p.metric && (this._mScale = tn("div", A, B)), p.imperial && (this._iScale = tn("div", A, B));
        },
        _update: function() {
          var p = this._map, A = p.getSize().y / 2, B = p.distance(
            p.containerPointToLatLng([0, A]),
            p.containerPointToLatLng([this.options.maxWidth, A])
          );
          this._updateScales(B);
        },
        _updateScales: function(p) {
          this.options.metric && p && this._updateMetric(p), this.options.imperial && p && this._updateImperial(p);
        },
        _updateMetric: function(p) {
          var A = this._getRoundNum(p), B = A < 1e3 ? A + " m" : A / 1e3 + " km";
          this._updateScale(this._mScale, B, A / p);
        },
        _updateImperial: function(p) {
          var A = p * 3.2808399, B, X, ne;
          A > 5280 ? (B = A / 5280, X = this._getRoundNum(B), this._updateScale(this._iScale, X + " mi", X / B)) : (ne = this._getRoundNum(A), this._updateScale(this._iScale, ne + " ft", ne / A));
        },
        _updateScale: function(p, A, B) {
          p.style.width = Math.round(this.options.maxWidth * B) + "px", p.innerHTML = A;
        },
        _getRoundNum: function(p) {
          var A = Math.pow(10, (Math.floor(p) + "").length - 1), B = p / A;
          return B = B >= 10 ? 10 : B >= 5 ? 5 : B >= 3 ? 3 : B >= 2 ? 2 : 1, A * B;
        }
      }), Lr = function(p) {
        return new Ir(p);
      }, qn = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', fa = Dn.extend({
        // @section
        // @aka Control.Attribution options
        options: {
          position: "bottomright",
          // @option prefix: String|false = 'Leaflet'
          // The HTML text shown before the attributions. Pass `false` to disable.
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Ae.inlineSvg ? qn + " " : "") + "Leaflet</a>"
        },
        initialize: function(p) {
          we(this, p), this._attributions = {};
        },
        onAdd: function(p) {
          p.attributionControl = this, this._container = tn("div", "leaflet-control-attribution"), Ai(this._container);
          for (var A in p._layers)
            p._layers[A].getAttribution && this.addAttribution(p._layers[A].getAttribution());
          return this._update(), p.on("layeradd", this._addAttribution, this), this._container;
        },
        onRemove: function(p) {
          p.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(p) {
          p.layer.getAttribution && (this.addAttribution(p.layer.getAttribution()), p.layer.once("remove", function() {
            this.removeAttribution(p.layer.getAttribution());
          }, this));
        },
        // @method setPrefix(prefix: String|false): this
        // The HTML text shown before the attributions. Pass `false` to disable.
        setPrefix: function(p) {
          return this.options.prefix = p, this._update(), this;
        },
        // @method addAttribution(text: String): this
        // Adds an attribution text (e.g. `'&copy; OpenStreetMap contributors'`).
        addAttribution: function(p) {
          return p ? (this._attributions[p] || (this._attributions[p] = 0), this._attributions[p]++, this._update(), this) : this;
        },
        // @method removeAttribution(text: String): this
        // Removes an attribution text.
        removeAttribution: function(p) {
          return p ? (this._attributions[p] && (this._attributions[p]--, this._update()), this) : this;
        },
        _update: function() {
          if (this._map) {
            var p = [];
            for (var A in this._attributions)
              this._attributions[A] && p.push(A);
            var B = [];
            this.options.prefix && B.push(this.options.prefix), p.length && B.push(p.join(", ")), this._container.innerHTML = B.join(' <span aria-hidden="true">|</span> ');
          }
        }
      });
      nn.mergeOptions({
        attributionControl: !0
      }), nn.addInitHook(function() {
        this.options.attributionControl && new fa().addTo(this);
      });
      var zr = function(p) {
        return new fa(p);
      };
      Dn.Layers = ss, Dn.Zoom = bo, Dn.Scale = Ir, Dn.Attribution = fa, rr.layers = da, rr.zoom = vn, rr.scale = Lr, rr.attribution = zr;
      var Es = hn.extend({
        initialize: function(p) {
          this._map = p;
        },
        // @method enable(): this
        // Enables the handler
        enable: function() {
          return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);
        },
        // @method disable(): this
        // Disables the handler
        disable: function() {
          return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
        },
        // @method enabled(): Boolean
        // Returns `true` if the handler is enabled
        enabled: function() {
          return !!this._enabled;
        }
        // @section Extension methods
        // Classes inheriting from `Handler` must implement the two following methods:
        // @method addHooks()
        // Called when the handler is enabled, should add event hooks.
        // @method removeHooks()
        // Called when the handler is disabled, should remove the event hooks added previously.
      });
      Es.addTo = function(p, A) {
        return p.addHandler(A, this), this;
      };
      var ka = { Events: Mi }, Ho = Ae.touch ? "touchstart mousedown" : "mousedown", qo = Ji.extend({
        options: {
          // @section
          // @aka Draggable options
          // @option clickTolerance: Number = 3
          // The max number of pixels a user can shift the mouse pointer during a click
          // for it to be considered a valid click (as opposed to a mouse drag).
          clickTolerance: 3
        },
        // @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
        // Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
        initialize: function(p, A, B, X) {
          we(this, X), this._element = p, this._dragStartTarget = A || p, this._preventOutline = B;
        },
        // @method enable()
        // Enables the dragging ability
        enable: function() {
          this._enabled || (Bi(this._dragStartTarget, Ho, this._onDown, this), this._enabled = !0);
        },
        // @method disable()
        // Disables the dragging ability
        disable: function() {
          this._enabled && (qo._dragging === this && this.finishDrag(!0), Cn(this._dragStartTarget, Ho, this._onDown, this), this._enabled = !1, this._moved = !1);
        },
        _onDown: function(p) {
          if (this._enabled && (this._moved = !1, !La(this._element, "leaflet-zoom-anim"))) {
            if (p.touches && p.touches.length !== 1) {
              qo._dragging === this && this.finishDrag();
              return;
            }
            if (!(qo._dragging || p.shiftKey || p.which !== 1 && p.button !== 1 && !p.touches) && (qo._dragging = this, this._preventOutline && ki(this._element), Go(), Pr(), !this._moving)) {
              this.fire("down");
              var A = p.touches ? p.touches[0] : p, B = ei(this._element);
              this._startPoint = new fi(A.clientX, A.clientY), this._startPos = $r(this._element), this._parentScale = cl(B);
              var X = p.type === "mousedown";
              Bi(document, X ? "mousemove" : "touchmove", this._onMove, this), Bi(document, X ? "mouseup" : "touchend touchcancel", this._onUp, this);
            }
          }
        },
        _onMove: function(p) {
          if (this._enabled) {
            if (p.touches && p.touches.length > 1) {
              this._moved = !0;
              return;
            }
            var A = p.touches && p.touches.length === 1 ? p.touches[0] : p, B = new fi(A.clientX, A.clientY)._subtract(this._startPoint);
            !B.x && !B.y || Math.abs(B.x) + Math.abs(B.y) < this.options.clickTolerance || (B.x /= this._parentScale.x, B.y /= this._parentScale.y, _s(p), this._moved || (this.fire("dragstart"), this._moved = !0, Vi(document.body, "leaflet-dragging"), this._lastTarget = p.target || p.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), Vi(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(B), this._moving = !0, this._lastEvent = p, this._updatePosition());
          }
        },
        _updatePosition: function() {
          var p = { originalEvent: this._lastEvent };
          this.fire("predrag", p), Yn(this._element, this._newPos), this.fire("drag", p);
        },
        _onUp: function() {
          this._enabled && this.finishDrag();
        },
        finishDrag: function(p) {
          Hn(document.body, "leaflet-dragging"), this._lastTarget && (Hn(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), Cn(document, "mousemove touchmove", this._onMove, this), Cn(document, "mouseup touchend touchcancel", this._onUp, this), sr(), Cr();
          var A = this._moved && this._moving;
          this._moving = !1, qo._dragging = !1, A && this.fire("dragend", {
            noInertia: p,
            distance: this._newPos.distanceTo(this._startPos)
          });
        }
      });
      function so(p, A, B) {
        var X, ne = [1, 4, 2, 8], ye, We, ot, ft, Rt, ii, Ci, Wi;
        for (ye = 0, ii = p.length; ye < ii; ye++)
          p[ye]._code = Ds(p[ye], A);
        for (ot = 0; ot < 4; ot++) {
          for (Ci = ne[ot], X = [], ye = 0, ii = p.length, We = ii - 1; ye < ii; We = ye++)
            ft = p[ye], Rt = p[We], ft._code & Ci ? Rt._code & Ci || (Wi = pl(Rt, ft, Ci, A, B), Wi._code = Ds(Wi, A), X.push(Wi)) : (Rt._code & Ci && (Wi = pl(Rt, ft, Ci, A, B), Wi._code = Ds(Wi, A), X.push(Wi)), X.push(ft));
          p = X;
        }
        return p;
      }
      function Oc(p, A) {
        var B, X, ne, ye, We, ot, ft, Rt, ii;
        if (!p || p.length === 0)
          throw new Error("latlngs not passed");
        rs(p) || (console.warn("latlngs are not flat! Only the first ring will be used"), p = p[0]);
        var Ci = xi([0, 0]), Wi = ln(p), Hs = Wi.getNorthWest().distanceTo(Wi.getSouthWest()) * Wi.getNorthEast().distanceTo(Wi.getNorthWest());
        Hs < 1700 && (Ci = Ra(p));
        var ws = p.length, Rs = [];
        for (B = 0; B < ws; B++) {
          var ur = xi(p[B]);
          Rs.push(A.project(xi([ur.lat - Ci.lat, ur.lng - Ci.lng])));
        }
        for (ot = ft = Rt = 0, B = 0, X = ws - 1; B < ws; X = B++)
          ne = Rs[B], ye = Rs[X], We = ne.y * ye.x - ye.y * ne.x, ft += (ne.x + ye.x) * We, Rt += (ne.y + ye.y) * We, ot += We * 3;
        ot === 0 ? ii = Rs[0] : ii = [ft / ot, Rt / ot];
        var ja = A.unproject(ni(ii));
        return xi([ja.lat + Ci.lat, ja.lng + Ci.lng]);
      }
      function Ra(p) {
        for (var A = 0, B = 0, X = 0, ne = 0; ne < p.length; ne++) {
          var ye = xi(p[ne]);
          A += ye.lat, B += ye.lng, X++;
        }
        return xi([A / X, B / X]);
      }
      var or = {
        __proto__: null,
        clipPolygon: so,
        polygonCenter: Oc,
        centroid: Ra
      };
      function ul(p, A) {
        if (!A || !p.length)
          return p.slice();
        var B = A * A;
        return p = Yu(p, B), p = fl(p, B), p;
      }
      function dl(p, A, B) {
        return Math.sqrt(Wo(p, A, B, !0));
      }
      function Fh(p, A, B) {
        return Wo(p, A, B);
      }
      function fl(p, A) {
        var B = p.length, X = typeof Uint8Array != void 0 + "" ? Uint8Array : Array, ne = new X(B);
        ne[0] = ne[B - 1] = 1, Fc(p, ne, A, 0, B - 1);
        var ye, We = [];
        for (ye = 0; ye < B; ye++)
          ne[ye] && We.push(p[ye]);
        return We;
      }
      function Fc(p, A, B, X, ne) {
        var ye = 0, We, ot, ft;
        for (ot = X + 1; ot <= ne - 1; ot++)
          ft = Wo(p[ot], p[X], p[ne], !0), ft > ye && (We = ot, ye = ft);
        ye > B && (A[We] = 1, Fc(p, A, B, X, We), Fc(p, A, B, We, ne));
      }
      function Yu(p, A) {
        for (var B = [p[0]], X = 1, ne = 0, ye = p.length; X < ye; X++)
          Bh(p[X], p[ne]) > A && (B.push(p[X]), ne = X);
        return ne < ye - 1 && B.push(p[ye - 1]), B;
      }
      var Oa;
      function Fa(p, A, B, X, ne) {
        var ye = X ? Oa : Ds(p, B), We = Ds(A, B), ot, ft, Rt;
        for (Oa = We; ; ) {
          if (!(ye | We))
            return [p, A];
          if (ye & We)
            return !1;
          ot = ye || We, ft = pl(p, A, ot, B, ne), Rt = Ds(ft, B), ot === ye ? (p = ft, ye = Rt) : (A = ft, We = Rt);
        }
      }
      function pl(p, A, B, X, ne) {
        var ye = A.x - p.x, We = A.y - p.y, ot = X.min, ft = X.max, Rt, ii;
        return B & 8 ? (Rt = p.x + ye * (ft.y - p.y) / We, ii = ft.y) : B & 4 ? (Rt = p.x + ye * (ot.y - p.y) / We, ii = ot.y) : B & 2 ? (Rt = ft.x, ii = p.y + We * (ft.x - p.x) / ye) : B & 1 && (Rt = ot.x, ii = p.y + We * (ot.x - p.x) / ye), new fi(Rt, ii, ne);
      }
      function Ds(p, A) {
        var B = 0;
        return p.x < A.min.x ? B |= 1 : p.x > A.max.x && (B |= 2), p.y < A.min.y ? B |= 4 : p.y > A.max.y && (B |= 8), B;
      }
      function Bh(p, A) {
        var B = A.x - p.x, X = A.y - p.y;
        return B * B + X * X;
      }
      function Wo(p, A, B, X) {
        var ne = A.x, ye = A.y, We = B.x - ne, ot = B.y - ye, ft = We * We + ot * ot, Rt;
        return ft > 0 && (Rt = ((p.x - ne) * We + (p.y - ye) * ot) / ft, Rt > 1 ? (ne = B.x, ye = B.y) : Rt > 0 && (ne += We * Rt, ye += ot * Rt)), We = p.x - ne, ot = p.y - ye, X ? We * We + ot * ot : new fi(ne, ye);
      }
      function rs(p) {
        return !Et(p[0]) || typeof p[0][0] != "object" && typeof p[0][0] < "u";
      }
      function Nh(p) {
        return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), rs(p);
      }
      function Vh(p, A) {
        var B, X, ne, ye, We, ot, ft, Rt;
        if (!p || p.length === 0)
          throw new Error("latlngs not passed");
        rs(p) || (console.warn("latlngs are not flat! Only the first ring will be used"), p = p[0]);
        var ii = xi([0, 0]), Ci = ln(p), Wi = Ci.getNorthWest().distanceTo(Ci.getSouthWest()) * Ci.getNorthEast().distanceTo(Ci.getNorthWest());
        Wi < 1700 && (ii = Ra(p));
        var Hs = p.length, ws = [];
        for (B = 0; B < Hs; B++) {
          var Rs = xi(p[B]);
          ws.push(A.project(xi([Rs.lat - ii.lat, Rs.lng - ii.lng])));
        }
        for (B = 0, X = 0; B < Hs - 1; B++)
          X += ws[B].distanceTo(ws[B + 1]) / 2;
        if (X === 0)
          Rt = ws[0];
        else
          for (B = 0, ye = 0; B < Hs - 1; B++)
            if (We = ws[B], ot = ws[B + 1], ne = We.distanceTo(ot), ye += ne, ye > X) {
              ft = (ye - X) / ne, Rt = [
                ot.x - ft * (ot.x - We.x),
                ot.y - ft * (ot.y - We.y)
              ];
              break;
            }
        var ur = A.unproject(ni(Rt));
        return xi([ur.lat + ii.lat, ur.lng + ii.lng]);
      }
      var Ku = {
        __proto__: null,
        simplify: ul,
        pointToSegmentDistance: dl,
        closestPointOnSegment: Fh,
        clipSegment: Fa,
        _getEdgeIntersection: pl,
        _getBitCode: Ds,
        _sqClosestPointOnSegment: Wo,
        isFlat: rs,
        _flat: Nh,
        polylineCenter: Vh
      }, Gl = {
        project: function(p) {
          return new fi(p.lng, p.lat);
        },
        unproject: function(p) {
          return new Di(p.y, p.x);
        },
        bounds: new Gi([-180, -90], [180, 90])
      }, $o = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Gi([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(p) {
          var A = Math.PI / 180, B = this.R, X = p.lat * A, ne = this.R_MINOR / B, ye = Math.sqrt(1 - ne * ne), We = ye * Math.sin(X), ot = Math.tan(Math.PI / 4 - X / 2) / Math.pow((1 - We) / (1 + We), ye / 2);
          return X = -B * Math.log(Math.max(ot, 1e-10)), new fi(p.lng * A * B, X);
        },
        unproject: function(p) {
          for (var A = 180 / Math.PI, B = this.R, X = this.R_MINOR / B, ne = Math.sqrt(1 - X * X), ye = Math.exp(-p.y / B), We = Math.PI / 2 - 2 * Math.atan(ye), ot = 0, ft = 0.1, Rt; ot < 15 && Math.abs(ft) > 1e-7; ot++)
            Rt = ne * Math.sin(We), Rt = Math.pow((1 - Rt) / (1 + Rt), ne / 2), ft = Math.PI / 2 - 2 * Math.atan(ye * Rt) - We, We += ft;
          return new Di(We * A, p.x * A / B);
        }
      }, bi = {
        __proto__: null,
        LonLat: Gl,
        Mercator: $o,
        SphericalMercator: De
      }, Wt = w({}, xs, {
        code: "EPSG:3395",
        projection: $o,
        transformation: function() {
          var p = 0.5 / (Math.PI * $o.R);
          return Us(p, 0.5, -p, 0.5);
        }()
      }), ml = w({}, xs, {
        code: "EPSG:4326",
        projection: Gl,
        transformation: Us(1 / 180, 1, -1 / 180, 0.5)
      }), ci = w({}, Cs, {
        projection: Gl,
        transformation: Us(1, 0, -1, 0),
        scale: function(p) {
          return Math.pow(2, p);
        },
        zoom: function(p) {
          return Math.log(p) / Math.LN2;
        },
        distance: function(p, A) {
          var B = A.lng - p.lng, X = A.lat - p.lat;
          return Math.sqrt(B * B + X * X);
        },
        infinite: !0
      });
      Cs.Earth = xs, Cs.EPSG3395 = Wt, Cs.EPSG3857 = Zr, Cs.EPSG900913 = Mt, Cs.EPSG4326 = ml, Cs.Simple = ci;
      var ar = Ji.extend({
        // Classes extending `L.Layer` will inherit the following options:
        options: {
          // @option pane: String = 'overlayPane'
          // By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
          pane: "overlayPane",
          // @option attribution: String = null
          // String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
          attribution: null,
          bubblingMouseEvents: !0
        },
        /* @section
         * Classes extending `L.Layer` will inherit the following methods:
         *
         * @method addTo(map: Map|LayerGroup): this
         * Adds the layer to the given map or layer group.
         */
        addTo: function(p) {
          return p.addLayer(this), this;
        },
        // @method remove: this
        // Removes the layer from the map it is currently active on.
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        // @method removeFrom(map: Map): this
        // Removes the layer from the given map
        //
        // @alternative
        // @method removeFrom(group: LayerGroup): this
        // Removes the layer from the given `LayerGroup`
        removeFrom: function(p) {
          return p && p.removeLayer(this), this;
        },
        // @method getPane(name? : String): HTMLElement
        // Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
        getPane: function(p) {
          return this._map.getPane(p ? this.options[p] || p : this.options.pane);
        },
        addInteractiveTarget: function(p) {
          return this._map._targets[O(p)] = this, this;
        },
        removeInteractiveTarget: function(p) {
          return delete this._map._targets[O(p)], this;
        },
        // @method getAttribution: String
        // Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(p) {
          var A = p.target;
          if (A.hasLayer(this)) {
            if (this._map = A, this._zoomAnimated = A._zoomAnimated, this.getEvents) {
              var B = this.getEvents();
              A.on(B, this), this.once("remove", function() {
                A.off(B, this);
              }, this);
            }
            this.onAdd(A), this.fire("add"), A.fire("layeradd", { layer: this });
          }
        }
      });
      nn.include({
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the map
        addLayer: function(p) {
          if (!p._layerAdd)
            throw new Error("The provided object is not a Layer.");
          var A = O(p);
          return this._layers[A] ? this : (this._layers[A] = p, p._mapToAdd = this, p.beforeAdd && p.beforeAdd(this), this.whenReady(p._layerAdd, p), this);
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the map.
        removeLayer: function(p) {
          var A = O(p);
          return this._layers[A] ? (this._loaded && p.onRemove(this), delete this._layers[A], this._loaded && (this.fire("layerremove", { layer: p }), p.fire("remove")), p._map = p._mapToAdd = null, this) : this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the map
        hasLayer: function(p) {
          return O(p) in this._layers;
        },
        /* @method eachLayer(fn: Function, context?: Object): this
         * Iterates over the layers of the map, optionally specifying context of the iterator function.
         * ```
         * map.eachLayer(function(layer){
         *     layer.bindPopup('Hello');
         * });
         * ```
         */
        eachLayer: function(p, A) {
          for (var B in this._layers)
            p.call(A, this._layers[B]);
          return this;
        },
        _addLayers: function(p) {
          p = p ? Et(p) ? p : [p] : [];
          for (var A = 0, B = p.length; A < B; A++)
            this.addLayer(p[A]);
        },
        _addZoomLimit: function(p) {
          (!isNaN(p.options.maxZoom) || !isNaN(p.options.minZoom)) && (this._zoomBoundLayers[O(p)] = p, this._updateZoomLevels());
        },
        _removeZoomLimit: function(p) {
          var A = O(p);
          this._zoomBoundLayers[A] && (delete this._zoomBoundLayers[A], this._updateZoomLevels());
        },
        _updateZoomLevels: function() {
          var p = 1 / 0, A = -1 / 0, B = this._getZoomSpan();
          for (var X in this._zoomBoundLayers) {
            var ne = this._zoomBoundLayers[X].options;
            p = ne.minZoom === void 0 ? p : Math.min(p, ne.minZoom), A = ne.maxZoom === void 0 ? A : Math.max(A, ne.maxZoom);
          }
          this._layersMaxZoom = A === -1 / 0 ? void 0 : A, this._layersMinZoom = p === 1 / 0 ? void 0 : p, B !== this._getZoomSpan() && this.fire("zoomlevelschange"), this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
        }
      });
      var lr = ar.extend({
        initialize: function(p, A) {
          we(this, A), this._layers = {};
          var B, X;
          if (p)
            for (B = 0, X = p.length; B < X; B++)
              this.addLayer(p[B]);
        },
        // @method addLayer(layer: Layer): this
        // Adds the given layer to the group.
        addLayer: function(p) {
          var A = this.getLayerId(p);
          return this._layers[A] = p, this._map && this._map.addLayer(p), this;
        },
        // @method removeLayer(layer: Layer): this
        // Removes the given layer from the group.
        // @alternative
        // @method removeLayer(id: Number): this
        // Removes the layer with the given internal ID from the group.
        removeLayer: function(p) {
          var A = p in this._layers ? p : this.getLayerId(p);
          return this._map && this._layers[A] && this._map.removeLayer(this._layers[A]), delete this._layers[A], this;
        },
        // @method hasLayer(layer: Layer): Boolean
        // Returns `true` if the given layer is currently added to the group.
        // @alternative
        // @method hasLayer(id: Number): Boolean
        // Returns `true` if the given internal ID is currently added to the group.
        hasLayer: function(p) {
          var A = typeof p == "number" ? p : this.getLayerId(p);
          return A in this._layers;
        },
        // @method clearLayers(): this
        // Removes all the layers from the group.
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        // @method invoke(methodName: String, …): this
        // Calls `methodName` on every layer contained in this group, passing any
        // additional parameters. Has no effect if the layers contained do not
        // implement `methodName`.
        invoke: function(p) {
          var A = Array.prototype.slice.call(arguments, 1), B, X;
          for (B in this._layers)
            X = this._layers[B], X[p] && X[p].apply(X, A);
          return this;
        },
        onAdd: function(p) {
          this.eachLayer(p.addLayer, p);
        },
        onRemove: function(p) {
          this.eachLayer(p.removeLayer, p);
        },
        // @method eachLayer(fn: Function, context?: Object): this
        // Iterates over the layers of the group, optionally specifying context of the iterator function.
        // ```js
        // group.eachLayer(function (layer) {
        // 	layer.bindPopup('Hello');
        // });
        // ```
        eachLayer: function(p, A) {
          for (var B in this._layers)
            p.call(A, this._layers[B]);
          return this;
        },
        // @method getLayer(id: Number): Layer
        // Returns the layer with the given internal ID.
        getLayer: function(p) {
          return this._layers[p];
        },
        // @method getLayers(): Layer[]
        // Returns an array of all the layers added to the group.
        getLayers: function() {
          var p = [];
          return this.eachLayer(p.push, p), p;
        },
        // @method setZIndex(zIndex: Number): this
        // Calls `setZIndex` on every layer contained in this group, passing the z-index.
        setZIndex: function(p) {
          return this.invoke("setZIndex", p);
        },
        // @method getLayerId(layer: Layer): Number
        // Returns the internal ID for a layer
        getLayerId: function(p) {
          return O(p);
        }
      }), ti = function(p, A) {
        return new lr(p, A);
      }, Xr = lr.extend({
        addLayer: function(p) {
          return this.hasLayer(p) ? this : (p.addEventParent(this), lr.prototype.addLayer.call(this, p), this.fire("layeradd", { layer: p }));
        },
        removeLayer: function(p) {
          return this.hasLayer(p) ? (p in this._layers && (p = this._layers[p]), p.removeEventParent(this), lr.prototype.removeLayer.call(this, p), this.fire("layerremove", { layer: p })) : this;
        },
        // @method setStyle(style: Path options): this
        // Sets the given path options to each layer of the group that has a `setStyle` method.
        setStyle: function(p) {
          return this.invoke("setStyle", p);
        },
        // @method bringToFront(): this
        // Brings the layer group to the top of all other layers
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        // @method bringToBack(): this
        // Brings the layer group to the back of all other layers
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        // @method getBounds(): LatLngBounds
        // Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
        getBounds: function() {
          var p = new qt();
          for (var A in this._layers) {
            var B = this._layers[A];
            p.extend(B.getBounds ? B.getBounds() : B.getLatLng());
          }
          return p;
        }
      }), Zl = function(p, A) {
        return new Xr(p, A);
      }, Yr = hn.extend({
        /* @section
         * @aka Icon options
         *
         * @option iconUrl: String = null
         * **(required)** The URL to the icon image (absolute or relative to your script path).
         *
         * @option iconRetinaUrl: String = null
         * The URL to a retina sized version of the icon image (absolute or relative to your
         * script path). Used for Retina screen devices.
         *
         * @option iconSize: Point = null
         * Size of the icon image in pixels.
         *
         * @option iconAnchor: Point = null
         * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
         * will be aligned so that this point is at the marker's geographical location. Centered
         * by default if size is specified, also can be set in CSS with negative margins.
         *
         * @option popupAnchor: Point = [0, 0]
         * The coordinates of the point from which popups will "open", relative to the icon anchor.
         *
         * @option tooltipAnchor: Point = [0, 0]
         * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
         *
         * @option shadowUrl: String = null
         * The URL to the icon shadow image. If not specified, no shadow image will be created.
         *
         * @option shadowRetinaUrl: String = null
         *
         * @option shadowSize: Point = null
         * Size of the shadow image in pixels.
         *
         * @option shadowAnchor: Point = null
         * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
         * as iconAnchor if not specified).
         *
         * @option className: String = ''
         * A custom class name to assign to both icon and shadow images. Empty by default.
         */
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1
        },
        initialize: function(p) {
          we(this, p);
        },
        // @method createIcon(oldIcon?: HTMLElement): HTMLElement
        // Called internally when the icon has to be shown, returns a `<img>` HTML element
        // styled according to the options.
        createIcon: function(p) {
          return this._createIcon("icon", p);
        },
        // @method createShadow(oldIcon?: HTMLElement): HTMLElement
        // As `createIcon`, but for the shadow beneath it.
        createShadow: function(p) {
          return this._createIcon("shadow", p);
        },
        _createIcon: function(p, A) {
          var B = this._getIconUrl(p);
          if (!B) {
            if (p === "icon")
              throw new Error("iconUrl not set in Icon options (see the docs).");
            return null;
          }
          var X = this._createImg(B, A && A.tagName === "IMG" ? A : null);
          return this._setIconStyles(X, p), (this.options.crossOrigin || this.options.crossOrigin === "") && (X.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), X;
        },
        _setIconStyles: function(p, A) {
          var B = this.options, X = B[A + "Size"];
          typeof X == "number" && (X = [X, X]);
          var ne = ni(X), ye = ni(A === "shadow" && B.shadowAnchor || B.iconAnchor || ne && ne.divideBy(2, !0));
          p.className = "leaflet-marker-" + A + " " + (B.className || ""), ye && (p.style.marginLeft = -ye.x + "px", p.style.marginTop = -ye.y + "px"), ne && (p.style.width = ne.x + "px", p.style.height = ne.y + "px");
        },
        _createImg: function(p, A) {
          return A = A || document.createElement("img"), A.src = p, A;
        },
        _getIconUrl: function(p) {
          return Ae.retina && this.options[p + "RetinaUrl"] || this.options[p + "Url"];
        }
      });
      function Ba(p) {
        return new Yr(p);
      }
      var wo = Yr.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(p) {
          return typeof wo.imagePath != "string" && (wo.imagePath = this._detectIconPath()), (this.options.imagePath || wo.imagePath) + Yr.prototype._getIconUrl.call(this, p);
        },
        _stripUrl: function(p) {
          var A = function(B, X, ne) {
            var ye = X.exec(B);
            return ye && ye[ne];
          };
          return p = A(p, /^url\((['"])?(.+)\1\)$/, 2), p && A(p, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var p = tn("div", "leaflet-default-icon-path", document.body), A = Uo(p, "background-image") || Uo(p, "backgroundImage");
          if (document.body.removeChild(p), A = this._stripUrl(A), A)
            return A;
          var B = document.querySelector('link[href$="leaflet.css"]');
          return B ? B.href.substring(0, B.href.length - 11 - 1) : "";
        }
      }), bs = Es.extend({
        initialize: function(p) {
          this._marker = p;
        },
        addHooks: function() {
          var p = this._marker._icon;
          this._draggable || (this._draggable = new qo(p, p, !0)), this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable(), Vi(p, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable(), this._marker._icon && Hn(this._marker._icon, "leaflet-marker-draggable");
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(p) {
          var A = this._marker, B = A._map, X = this._marker.options.autoPanSpeed, ne = this._marker.options.autoPanPadding, ye = $r(A._icon), We = B.getPixelBounds(), ot = B.getPixelOrigin(), ft = an(
            We.min._subtract(ot).add(ne),
            We.max._subtract(ot).subtract(ne)
          );
          if (!ft.contains(ye)) {
            var Rt = ni(
              (Math.max(ft.max.x, ye.x) - ft.max.x) / (We.max.x - ft.max.x) - (Math.min(ft.min.x, ye.x) - ft.min.x) / (We.min.x - ft.min.x),
              (Math.max(ft.max.y, ye.y) - ft.max.y) / (We.max.y - ft.max.y) - (Math.min(ft.min.y, ye.y) - ft.min.y) / (We.min.y - ft.min.y)
            ).multiplyBy(X);
            B.panBy(Rt, { animate: !1 }), this._draggable._newPos._add(Rt), this._draggable._startPos._add(Rt), Yn(A._icon, this._draggable._newPos), this._onDrag(p), this._panRequest = At(this._adjustPan.bind(this, p));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(p) {
          this._marker.options.autoPan && (Si(this._panRequest), this._panRequest = At(this._adjustPan.bind(this, p)));
        },
        _onDrag: function(p) {
          var A = this._marker, B = A._shadow, X = $r(A._icon), ne = A._map.layerPointToLatLng(X);
          B && Yn(B, X), A._latlng = ne, p.latlng = ne, p.oldLatLng = this._oldLatLng, A.fire("move", p).fire("drag", p);
        },
        _onDragEnd: function(p) {
          Si(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", p);
        }
      }), ks = ar.extend({
        // @section
        // @aka Marker options
        options: {
          // @option icon: Icon = *
          // Icon instance to use for rendering the marker.
          // See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
          // If not specified, a common instance of `L.Icon.Default` is used.
          icon: new wo(),
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option keyboard: Boolean = true
          // Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
          keyboard: !0,
          // @option title: String = ''
          // Text for the browser tooltip that appear on marker hover (no tooltip by default).
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          title: "",
          // @option alt: String = 'Marker'
          // Text for the `alt` attribute of the icon image.
          // [Useful for accessibility](https://leafletjs.com/examples/accessibility/#markers-must-be-labelled).
          alt: "Marker",
          // @option zIndexOffset: Number = 0
          // By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
          zIndexOffset: 0,
          // @option opacity: Number = 1.0
          // The opacity of the marker.
          opacity: 1,
          // @option riseOnHover: Boolean = false
          // If `true`, the marker will get on top of others when you hover the mouse over it.
          riseOnHover: !1,
          // @option riseOffset: Number = 250
          // The z-index offset used for the `riseOnHover` feature.
          riseOffset: 250,
          // @option pane: String = 'markerPane'
          // `Map pane` where the markers icon will be added.
          pane: "markerPane",
          // @option shadowPane: String = 'shadowPane'
          // `Map pane` where the markers shadow will be added.
          shadowPane: "shadowPane",
          // @option bubblingMouseEvents: Boolean = false
          // When `true`, a mouse event on this marker will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !1,
          // @option autoPanOnFocus: Boolean = true
          // When `true`, the map will pan whenever the marker is focused (via
          // e.g. pressing `tab` on the keyboard) to ensure the marker is
          // visible within the map's bounds
          autoPanOnFocus: !0,
          // @section Draggable marker options
          // @option draggable: Boolean = false
          // Whether the marker is draggable with mouse/touch or not.
          draggable: !1,
          // @option autoPan: Boolean = false
          // Whether to pan the map when dragging this marker near its edge or not.
          autoPan: !1,
          // @option autoPanPadding: Point = Point(50, 50)
          // Distance (in pixels to the left/right and to the top/bottom) of the
          // map edge to start panning the map.
          autoPanPadding: [50, 50],
          // @option autoPanSpeed: Number = 10
          // Number of pixels the map should pan by.
          autoPanSpeed: 10
        },
        /* @section
         *
         * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
         */
        initialize: function(p, A) {
          we(this, A), this._latlng = xi(p);
        },
        onAdd: function(p) {
          this._zoomAnimated = this._zoomAnimated && p.options.markerZoomAnimation, this._zoomAnimated && p.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update();
        },
        onRemove: function(p) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && p.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        // @method getLatLng: LatLng
        // Returns the current geographical position of the marker.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Changes the marker position to the given point.
        setLatLng: function(p) {
          var A = this._latlng;
          return this._latlng = xi(p), this.update(), this.fire("move", { oldLatLng: A, latlng: this._latlng });
        },
        // @method setZIndexOffset(offset: Number): this
        // Changes the [zIndex offset](#marker-zindexoffset) of the marker.
        setZIndexOffset: function(p) {
          return this.options.zIndexOffset = p, this.update();
        },
        // @method getIcon: Icon
        // Returns the current icon used by the marker
        getIcon: function() {
          return this.options.icon;
        },
        // @method setIcon(icon: Icon): this
        // Changes the marker icon.
        setIcon: function(p) {
          return this.options.icon = p, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var p = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(p);
          }
          return this;
        },
        _initIcon: function() {
          var p = this.options, A = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), B = p.icon.createIcon(this._icon), X = !1;
          B !== this._icon && (this._icon && this._removeIcon(), X = !0, p.title && (B.title = p.title), B.tagName === "IMG" && (B.alt = p.alt || "")), Vi(B, A), p.keyboard && (B.tabIndex = "0", B.setAttribute("role", "button")), this._icon = B, p.riseOnHover && this.on({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Bi(B, "focus", this._panOnFocus, this);
          var ne = p.icon.createShadow(this._shadow), ye = !1;
          ne !== this._shadow && (this._removeShadow(), ye = !0), ne && (Vi(ne, A), ne.alt = ""), this._shadow = ne, p.opacity < 1 && this._updateOpacity(), X && this.getPane().appendChild(this._icon), this._initInteraction(), ne && ye && this.getPane(p.shadowPane).appendChild(this._shadow);
        },
        _removeIcon: function() {
          this.options.riseOnHover && this.off({
            mouseover: this._bringToFront,
            mouseout: this._resetZIndex
          }), this.options.autoPanOnFocus && Cn(this._icon, "focus", this._panOnFocus, this), xn(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
        },
        _removeShadow: function() {
          this._shadow && xn(this._shadow), this._shadow = null;
        },
        _setPos: function(p) {
          this._icon && Yn(this._icon, p), this._shadow && Yn(this._shadow, p), this._zIndex = p.y + this.options.zIndexOffset, this._resetZIndex();
        },
        _updateZIndex: function(p) {
          this._icon && (this._icon.style.zIndex = this._zIndex + p);
        },
        _animateZoom: function(p) {
          var A = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center).round();
          this._setPos(A);
        },
        _initInteraction: function() {
          if (this.options.interactive && (Vi(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), bs)) {
            var p = this.options.draggable;
            this.dragging && (p = this.dragging.enabled(), this.dragging.disable()), this.dragging = new bs(this), p && this.dragging.enable();
          }
        },
        // @method setOpacity(opacity: Number): this
        // Changes the opacity of the marker.
        setOpacity: function(p) {
          return this.options.opacity = p, this._map && this._updateOpacity(), this;
        },
        _updateOpacity: function() {
          var p = this.options.opacity;
          this._icon && Qn(this._icon, p), this._shadow && Qn(this._shadow, p);
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var p = this._map;
          if (p) {
            var A = this.options.icon.options, B = A.iconSize ? ni(A.iconSize) : ni(0, 0), X = A.iconAnchor ? ni(A.iconAnchor) : ni(0, 0);
            p.panInside(this._latlng, {
              paddingTopLeft: X,
              paddingBottomRight: B.subtract(X)
            });
          }
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function Hl(p, A) {
        return new ks(p, A);
      }
      var wt = ar.extend({
        // @section
        // @aka Path options
        options: {
          // @option stroke: Boolean = true
          // Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
          stroke: !0,
          // @option color: String = '#3388ff'
          // Stroke color
          color: "#3388ff",
          // @option weight: Number = 3
          // Stroke width in pixels
          weight: 3,
          // @option opacity: Number = 1.0
          // Stroke opacity
          opacity: 1,
          // @option lineCap: String= 'round'
          // A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
          lineCap: "round",
          // @option lineJoin: String = 'round'
          // A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
          lineJoin: "round",
          // @option dashArray: String = null
          // A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashArray: null,
          // @option dashOffset: String = null
          // A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
          dashOffset: null,
          // @option fill: Boolean = depends
          // Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
          fill: !1,
          // @option fillColor: String = *
          // Fill color. Defaults to the value of the [`color`](#path-color) option
          fillColor: null,
          // @option fillOpacity: Number = 0.2
          // Fill opacity.
          fillOpacity: 0.2,
          // @option fillRule: String = 'evenodd'
          // A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
          fillRule: "evenodd",
          // className: '',
          // Option inherited from "Interactive layer" abstract class
          interactive: !0,
          // @option bubblingMouseEvents: Boolean = true
          // When `true`, a mouse event on this path will trigger the same event on the map
          // (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
          bubblingMouseEvents: !0
        },
        beforeAdd: function(p) {
          this._renderer = p.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        // @method redraw(): this
        // Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
        redraw: function() {
          return this._map && this._renderer._updatePath(this), this;
        },
        // @method setStyle(style: Path options): this
        // Changes the appearance of a Path based on the options in the `Path options` object.
        setStyle: function(p) {
          return we(this, p), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && p && Object.prototype.hasOwnProperty.call(p, "weight") && this._updateBounds()), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all path layers.
        bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all path layers.
        bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this), this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project(), this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      }), pa = wt.extend({
        // @section
        // @aka CircleMarker options
        options: {
          fill: !0,
          // @option radius: Number = 10
          // Radius of the circle marker, in pixels
          radius: 10
        },
        initialize: function(p, A) {
          we(this, A), this._latlng = xi(p), this._radius = this.options.radius;
        },
        // @method setLatLng(latLng: LatLng): this
        // Sets the position of a circle marker to a new location.
        setLatLng: function(p) {
          var A = this._latlng;
          return this._latlng = xi(p), this.redraw(), this.fire("move", { oldLatLng: A, latlng: this._latlng });
        },
        // @method getLatLng(): LatLng
        // Returns the current geographical position of the circle marker
        getLatLng: function() {
          return this._latlng;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle marker. Units are in pixels.
        setRadius: function(p) {
          return this.options.radius = this._radius = p, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of the circle
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(p) {
          var A = p && p.radius || this._radius;
          return wt.prototype.setStyle.call(this, p), this.setRadius(A), this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
        },
        _updateBounds: function() {
          var p = this._radius, A = this._radiusY || p, B = this._clickTolerance(), X = [p + B, A + B];
          this._pxBounds = new Gi(this._point.subtract(X), this._point.add(X));
        },
        _update: function() {
          this._map && this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function To(p, A) {
        return new pa(p, A);
      }
      var gs = pa.extend({
        initialize: function(p, A, B) {
          if (typeof A == "number" && (A = w({}, B, { radius: A })), we(this, A), this._latlng = xi(p), isNaN(this.options.radius))
            throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius;
        },
        // @method setRadius(radius: Number): this
        // Sets the radius of a circle. Units are in meters.
        setRadius: function(p) {
          return this._mRadius = p, this.redraw();
        },
        // @method getRadius(): Number
        // Returns the current radius of a circle. Units are in meters.
        getRadius: function() {
          return this._mRadius;
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          var p = [this._radius, this._radiusY || this._radius];
          return new qt(
            this._map.layerPointToLatLng(this._point.subtract(p)),
            this._map.layerPointToLatLng(this._point.add(p))
          );
        },
        setStyle: wt.prototype.setStyle,
        _project: function() {
          var p = this._latlng.lng, A = this._latlng.lat, B = this._map, X = B.options.crs;
          if (X.distance === xs.distance) {
            var ne = Math.PI / 180, ye = this._mRadius / xs.R / ne, We = B.project([A + ye, p]), ot = B.project([A - ye, p]), ft = We.add(ot).divideBy(2), Rt = B.unproject(ft).lat, ii = Math.acos((Math.cos(ye * ne) - Math.sin(A * ne) * Math.sin(Rt * ne)) / (Math.cos(A * ne) * Math.cos(Rt * ne))) / ne;
            (isNaN(ii) || ii === 0) && (ii = ye / Math.cos(Math.PI / 180 * A)), this._point = ft.subtract(B.getPixelOrigin()), this._radius = isNaN(ii) ? 0 : ft.x - B.project([Rt, p - ii]).x, this._radiusY = ft.y - We.y;
          } else {
            var Ci = X.unproject(X.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = B.latLngToLayerPoint(this._latlng), this._radius = this._point.x - B.latLngToLayerPoint(Ci).x;
          }
          this._updateBounds();
        }
      });
      function Uh(p, A, B) {
        return new gs(p, A, B);
      }
      var Dr = wt.extend({
        // @section
        // @aka Polyline options
        options: {
          // @option smoothFactor: Number = 1.0
          // How much to simplify the polyline on each zoom level. More means
          // better performance and smoother look, and less means more accurate representation.
          smoothFactor: 1,
          // @option noClip: Boolean = false
          // Disable polyline clipping.
          noClip: !1
        },
        initialize: function(p, A) {
          we(this, A), this._setLatLngs(p);
        },
        // @method getLatLngs(): LatLng[]
        // Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
        getLatLngs: function() {
          return this._latlngs;
        },
        // @method setLatLngs(latlngs: LatLng[]): this
        // Replaces all the points in the polyline with the given array of geographical points.
        setLatLngs: function(p) {
          return this._setLatLngs(p), this.redraw();
        },
        // @method isEmpty(): Boolean
        // Returns `true` if the Polyline has no LatLngs.
        isEmpty: function() {
          return !this._latlngs.length;
        },
        // @method closestLayerPoint(p: Point): Point
        // Returns the point closest to `p` on the Polyline.
        closestLayerPoint: function(p) {
          for (var A = 1 / 0, B = null, X = Wo, ne, ye, We = 0, ot = this._parts.length; We < ot; We++)
            for (var ft = this._parts[We], Rt = 1, ii = ft.length; Rt < ii; Rt++) {
              ne = ft[Rt - 1], ye = ft[Rt];
              var Ci = X(p, ne, ye, !0);
              Ci < A && (A = Ci, B = X(p, ne, ye));
            }
          return B && (B.distance = Math.sqrt(A)), B;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](https://en.wikipedia.org/wiki/Centroid)) of the polyline.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Vh(this._defaultShape(), this._map.options.crs);
        },
        // @method getBounds(): LatLngBounds
        // Returns the `LatLngBounds` of the path.
        getBounds: function() {
          return this._bounds;
        },
        // @method addLatLng(latlng: LatLng, latlngs?: LatLng[]): this
        // Adds a given point to the polyline. By default, adds to the first ring of
        // the polyline in case of a multi-polyline, but can be overridden by passing
        // a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
        addLatLng: function(p, A) {
          return A = A || this._defaultShape(), p = xi(p), A.push(p), this._bounds.extend(p), this.redraw();
        },
        _setLatLngs: function(p) {
          this._bounds = new qt(), this._latlngs = this._convertLatLngs(p);
        },
        _defaultShape: function() {
          return rs(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        // recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
        _convertLatLngs: function(p) {
          for (var A = [], B = rs(p), X = 0, ne = p.length; X < ne; X++)
            B ? (A[X] = xi(p[X]), this._bounds.extend(A[X])) : A[X] = this._convertLatLngs(p[X]);
          return A;
        },
        _project: function() {
          var p = new Gi();
          this._rings = [], this._projectLatlngs(this._latlngs, this._rings, p), this._bounds.isValid() && p.isValid() && (this._rawPxBounds = p, this._updateBounds());
        },
        _updateBounds: function() {
          var p = this._clickTolerance(), A = new fi(p, p);
          this._rawPxBounds && (this._pxBounds = new Gi([
            this._rawPxBounds.min.subtract(A),
            this._rawPxBounds.max.add(A)
          ]));
        },
        // recursively turns latlngs into a set of rings with projected coordinates
        _projectLatlngs: function(p, A, B) {
          var X = p[0] instanceof Di, ne = p.length, ye, We;
          if (X) {
            for (We = [], ye = 0; ye < ne; ye++)
              We[ye] = this._map.latLngToLayerPoint(p[ye]), B.extend(We[ye]);
            A.push(We);
          } else
            for (ye = 0; ye < ne; ye++)
              this._projectLatlngs(p[ye], A, B);
        },
        // clip polyline by renderer bounds so that we have less to render for performance
        _clipPoints: function() {
          var p = this._renderer._bounds;
          if (this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(p))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            var A = this._parts, B, X, ne, ye, We, ot, ft;
            for (B = 0, ne = 0, ye = this._rings.length; B < ye; B++)
              for (ft = this._rings[B], X = 0, We = ft.length; X < We - 1; X++)
                ot = Fa(ft[X], ft[X + 1], p, X, !0), ot && (A[ne] = A[ne] || [], A[ne].push(ot[0]), (ot[1] !== ft[X + 1] || X === We - 2) && (A[ne].push(ot[1]), ne++));
          }
        },
        // simplify each clipped part of the polyline for performance
        _simplifyPoints: function() {
          for (var p = this._parts, A = this.options.smoothFactor, B = 0, X = p.length; B < X; B++)
            p[B] = ul(p[B], A);
        },
        _update: function() {
          this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p, A) {
          var B, X, ne, ye, We, ot, ft = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p))
            return !1;
          for (B = 0, ye = this._parts.length; B < ye; B++)
            for (ot = this._parts[B], X = 0, We = ot.length, ne = We - 1; X < We; ne = X++)
              if (!(!A && X === 0) && dl(p, ot[ne], ot[X]) <= ft)
                return !0;
          return !1;
        }
      });
      function So(p, A) {
        return new Dr(p, A);
      }
      Dr._flat = Nh;
      var Kr = Dr.extend({
        options: {
          fill: !0
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        // @method getCenter(): LatLng
        // Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the Polygon.
        getCenter: function() {
          if (!this._map)
            throw new Error("Must add layer to map before using getCenter()");
          return Oc(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(p) {
          var A = Dr.prototype._convertLatLngs.call(this, p), B = A.length;
          return B >= 2 && A[0] instanceof Di && A[0].equals(A[B - 1]) && A.pop(), A;
        },
        _setLatLngs: function(p) {
          Dr.prototype._setLatLngs.call(this, p), rs(this._latlngs) && (this._latlngs = [this._latlngs]);
        },
        _defaultShape: function() {
          return rs(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var p = this._renderer._bounds, A = this.options.weight, B = new fi(A, A);
          if (p = new Gi(p.min.subtract(B), p.max.add(B)), this._parts = [], !(!this._pxBounds || !this._pxBounds.intersects(p))) {
            if (this.options.noClip) {
              this._parts = this._rings;
              return;
            }
            for (var X = 0, ne = this._rings.length, ye; X < ne; X++)
              ye = so(this._rings[X], p, !0), ye.length && this._parts.push(ye);
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, !0);
        },
        // Needed by the `Canvas` renderer for interactivity
        _containsPoint: function(p) {
          var A = !1, B, X, ne, ye, We, ot, ft, Rt;
          if (!this._pxBounds || !this._pxBounds.contains(p))
            return !1;
          for (ye = 0, ft = this._parts.length; ye < ft; ye++)
            for (B = this._parts[ye], We = 0, Rt = B.length, ot = Rt - 1; We < Rt; ot = We++)
              X = B[We], ne = B[ot], X.y > p.y != ne.y > p.y && p.x < (ne.x - X.x) * (p.y - X.y) / (ne.y - X.y) + X.x && (A = !A);
          return A || Dr.prototype._containsPoint.call(this, p, !0);
        }
      });
      function Xo(p, A) {
        return new Kr(p, A);
      }
      var cr = Xr.extend({
        /* @section
         * @aka GeoJSON options
         *
         * @option pointToLayer: Function = *
         * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
         * called when data is added, passing the GeoJSON point feature and its `LatLng`.
         * The default is to spawn a default `Marker`:
         * ```js
         * function(geoJsonPoint, latlng) {
         * 	return L.marker(latlng);
         * }
         * ```
         *
         * @option style: Function = *
         * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
         * called internally when data is added.
         * The default value is to not override any defaults:
         * ```js
         * function (geoJsonFeature) {
         * 	return {}
         * }
         * ```
         *
         * @option onEachFeature: Function = *
         * A `Function` that will be called once for each created `Feature`, after it has
         * been created and styled. Useful for attaching events and popups to features.
         * The default is to do nothing with the newly created layers:
         * ```js
         * function (feature, layer) {}
         * ```
         *
         * @option filter: Function = *
         * A `Function` that will be used to decide whether to include a feature or not.
         * The default is to include all features:
         * ```js
         * function (geoJsonFeature) {
         * 	return true;
         * }
         * ```
         * Note: dynamically changing the `filter` option will have effect only on newly
         * added data. It will _not_ re-evaluate already included features.
         *
         * @option coordsToLatLng: Function = *
         * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
         * The default is the `coordsToLatLng` static method.
         *
         * @option markersInheritOptions: Boolean = false
         * Whether default Markers for "Point" type Features inherit from group options.
         */
        initialize: function(p, A) {
          we(this, A), this._layers = {}, p && this.addData(p);
        },
        // @method addData( <GeoJSON> data ): this
        // Adds a GeoJSON object to the layer.
        addData: function(p) {
          var A = Et(p) ? p : p.features, B, X, ne;
          if (A) {
            for (B = 0, X = A.length; B < X; B++)
              ne = A[B], (ne.geometries || ne.geometry || ne.features || ne.coordinates) && this.addData(ne);
            return this;
          }
          var ye = this.options;
          if (ye.filter && !ye.filter(p))
            return this;
          var We = Mo(p, ye);
          return We ? (We.feature = _a(p), We.defaultOptions = We.options, this.resetStyle(We), ye.onEachFeature && ye.onEachFeature(p, We), this.addLayer(We)) : this;
        },
        // @method resetStyle( <Path> layer? ): this
        // Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
        // If `layer` is omitted, the style of all features in the current layer is reset.
        resetStyle: function(p) {
          return p === void 0 ? this.eachLayer(this.resetStyle, this) : (p.options = w({}, p.defaultOptions), this._setLayerStyle(p, this.options.style), this);
        },
        // @method setStyle( <Function> style ): this
        // Changes styles of GeoJSON vector layers with the given style function.
        setStyle: function(p) {
          return this.eachLayer(function(A) {
            this._setLayerStyle(A, p);
          }, this);
        },
        _setLayerStyle: function(p, A) {
          p.setStyle && (typeof A == "function" && (A = A(p.feature)), p.setStyle(A));
        }
      });
      function Mo(p, A) {
        var B = p.type === "Feature" ? p.geometry : p, X = B ? B.coordinates : null, ne = [], ye = A && A.pointToLayer, We = A && A.coordsToLatLng || Bc, ot, ft, Rt, ii;
        if (!X && !B)
          return null;
        switch (B.type) {
          case "Point":
            return ot = We(X), jh(ye, p, ot, A);
          case "MultiPoint":
            for (Rt = 0, ii = X.length; Rt < ii; Rt++)
              ot = We(X[Rt]), ne.push(jh(ye, p, ot, A));
            return new Xr(ne);
          case "LineString":
          case "MultiLineString":
            return ft = Na(X, B.type === "LineString" ? 0 : 1, We), new Dr(ft, A);
          case "Polygon":
          case "MultiPolygon":
            return ft = Na(X, B.type === "Polygon" ? 1 : 2, We), new Kr(ft, A);
          case "GeometryCollection":
            for (Rt = 0, ii = B.geometries.length; Rt < ii; Rt++) {
              var Ci = Mo({
                geometry: B.geometries[Rt],
                type: "Feature",
                properties: p.properties
              }, A);
              Ci && ne.push(Ci);
            }
            return new Xr(ne);
          case "FeatureCollection":
            for (Rt = 0, ii = B.features.length; Rt < ii; Rt++) {
              var Wi = Mo(B.features[Rt], A);
              Wi && ne.push(Wi);
            }
            return new Xr(ne);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function jh(p, A, B, X) {
        return p ? p(A, B) : new ks(B, X && X.markersInheritOptions && X);
      }
      function Bc(p) {
        return new Di(p[1], p[0], p[2]);
      }
      function Na(p, A, B) {
        for (var X = [], ne = 0, ye = p.length, We; ne < ye; ne++)
          We = A ? Na(p[ne], A - 1, B) : (B || Bc)(p[ne]), X.push(We);
        return X;
      }
      function ql(p, A) {
        return p = xi(p), p.alt !== void 0 ? [ae(p.lng, A), ae(p.lat, A), ae(p.alt, A)] : [ae(p.lng, A), ae(p.lat, A)];
      }
      function _l(p, A, B, X) {
        for (var ne = [], ye = 0, We = p.length; ye < We; ye++)
          ne.push(A ? _l(p[ye], rs(p[ye]) ? 0 : A - 1, B, X) : ql(p[ye], X));
        return !A && B && ne.length > 0 && ne.push(ne[0].slice()), ne;
      }
      function ma(p, A) {
        return p.feature ? w({}, p.feature, { geometry: A }) : _a(A);
      }
      function _a(p) {
        return p.type === "Feature" || p.type === "FeatureCollection" ? p : {
          type: "Feature",
          properties: {},
          geometry: p
        };
      }
      var Eo = {
        toGeoJSON: function(p) {
          return ma(this, {
            type: "Point",
            coordinates: ql(this.getLatLng(), p)
          });
        }
      };
      ks.include(Eo), gs.include(Eo), pa.include(Eo), Dr.include({
        toGeoJSON: function(p) {
          var A = !rs(this._latlngs), B = _l(this._latlngs, A ? 1 : 0, !1, p);
          return ma(this, {
            type: (A ? "Multi" : "") + "LineString",
            coordinates: B
          });
        }
      }), Kr.include({
        toGeoJSON: function(p) {
          var A = !rs(this._latlngs), B = A && !rs(this._latlngs[0]), X = _l(this._latlngs, B ? 2 : A ? 1 : 0, !0, p);
          return A || (X = [X]), ma(this, {
            type: (B ? "Multi" : "") + "Polygon",
            coordinates: X
          });
        }
      }), lr.include({
        toMultiPoint: function(p) {
          var A = [];
          return this.eachLayer(function(B) {
            A.push(B.toGeoJSON(p).geometry.coordinates);
          }), ma(this, {
            type: "MultiPoint",
            coordinates: A
          });
        },
        // @method toGeoJSON(precision?: Number|false): Object
        // Coordinates values are rounded with [`formatNum`](#util-formatnum) function with given `precision`.
        // Returns a [`GeoJSON`](https://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
        toGeoJSON: function(p) {
          var A = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (A === "MultiPoint")
            return this.toMultiPoint(p);
          var B = A === "GeometryCollection", X = [];
          return this.eachLayer(function(ne) {
            if (ne.toGeoJSON) {
              var ye = ne.toGeoJSON(p);
              if (B)
                X.push(ye.geometry);
              else {
                var We = _a(ye);
                We.type === "FeatureCollection" ? X.push.apply(X, We.features) : X.push(We);
              }
            }
          }), B ? ma(this, {
            geometries: X,
            type: "GeometryCollection"
          }) : {
            type: "FeatureCollection",
            features: X
          };
        }
      });
      function Gh(p, A) {
        return new cr(p, A);
      }
      var Ju = Gh, Va = ar.extend({
        // @section
        // @aka ImageOverlay options
        options: {
          // @option opacity: Number = 1.0
          // The opacity of the image overlay.
          opacity: 1,
          // @option alt: String = ''
          // Text for the `alt` attribute of the image (useful for accessibility).
          alt: "",
          // @option interactive: Boolean = false
          // If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
          interactive: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the image.
          // If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option errorOverlayUrl: String = ''
          // URL to the overlay image to show in place of the overlay that failed to load.
          errorOverlayUrl: "",
          // @option zIndex: Number = 1
          // The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
          zIndex: 1,
          // @option className: String = ''
          // A custom class name to assign to the image. Empty by default.
          className: ""
        },
        initialize: function(p, A, B) {
          this._url = p, this._bounds = ln(A), we(this, B);
        },
        onAdd: function() {
          this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (Vi(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();
        },
        onRemove: function() {
          xn(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
        },
        // @method setOpacity(opacity: Number): this
        // Sets the opacity of the overlay.
        setOpacity: function(p) {
          return this.options.opacity = p, this._image && this._updateOpacity(), this;
        },
        setStyle: function(p) {
          return p.opacity && this.setOpacity(p.opacity), this;
        },
        // @method bringToFront(): this
        // Brings the layer to the top of all overlays.
        bringToFront: function() {
          return this._map && jo(this._image), this;
        },
        // @method bringToBack(): this
        // Brings the layer to the bottom of all overlays.
        bringToBack: function() {
          return this._map && oa(this._image), this;
        },
        // @method setUrl(url: String): this
        // Changes the URL of the image.
        setUrl: function(p) {
          return this._url = p, this._image && (this._image.src = p), this;
        },
        // @method setBounds(bounds: LatLngBounds): this
        // Update the bounds that this ImageOverlay covers
        setBounds: function(p) {
          return this._bounds = ln(p), this._map && this._reset(), this;
        },
        getEvents: function() {
          var p = {
            zoom: this._reset,
            viewreset: this._reset
          };
          return this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @method setZIndex(value: Number): this
        // Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
        setZIndex: function(p) {
          return this.options.zIndex = p, this._updateZIndex(), this;
        },
        // @method getBounds(): LatLngBounds
        // Get the bounds that this ImageOverlay covers
        getBounds: function() {
          return this._bounds;
        },
        // @method getElement(): HTMLElement
        // Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
        // used by this overlay.
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var p = this._url.tagName === "IMG", A = this._image = p ? this._url : tn("img");
          if (Vi(A, "leaflet-image-layer"), this._zoomAnimated && Vi(A, "leaflet-zoom-animated"), this.options.className && Vi(A, this.options.className), A.onselectstart = J, A.onmousemove = J, A.onload = P(this.fire, this, "load"), A.onerror = P(this._overlayOnError, this, "error"), (this.options.crossOrigin || this.options.crossOrigin === "") && (A.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), p) {
            this._url = A.src;
            return;
          }
          A.src = this._url, A.alt = this.options.alt;
        },
        _animateZoom: function(p) {
          var A = this._map.getZoomScale(p.zoom), B = this._map._latLngBoundsToNewLayerBounds(this._bounds, p.zoom, p.center).min;
          Ys(this._image, B, A);
        },
        _reset: function() {
          var p = this._image, A = new Gi(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), B = A.getSize();
          Yn(p, A.min), p.style.width = B.x + "px", p.style.height = B.y + "px";
        },
        _updateOpacity: function() {
          Qn(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex);
        },
        _overlayOnError: function() {
          this.fire("error");
          var p = this.options.errorOverlayUrl;
          p && this._url !== p && (this._url = p, this._image.src = p);
        },
        // @method getCenter(): LatLng
        // Returns the center of the ImageOverlay.
        getCenter: function() {
          return this._bounds.getCenter();
        }
      }), Nc = function(p, A, B) {
        return new Va(p, A, B);
      }, Vc = Va.extend({
        // @section
        // @aka VideoOverlay options
        options: {
          // @option autoplay: Boolean = true
          // Whether the video starts playing automatically when loaded.
          // On some browsers autoplay will only work with `muted: true`
          autoplay: !0,
          // @option loop: Boolean = true
          // Whether the video will loop back to the beginning when played.
          loop: !0,
          // @option keepAspectRatio: Boolean = true
          // Whether the video will save aspect ratio after the projection.
          // Relevant for supported browsers. See [browser compatibility](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit)
          keepAspectRatio: !0,
          // @option muted: Boolean = false
          // Whether the video starts on mute when loaded.
          muted: !1,
          // @option playsInline: Boolean = true
          // Mobile browsers will play the video right where it is instead of open it up in fullscreen mode.
          playsInline: !0
        },
        _initImage: function() {
          var p = this._url.tagName === "VIDEO", A = this._image = p ? this._url : tn("video");
          if (Vi(A, "leaflet-image-layer"), this._zoomAnimated && Vi(A, "leaflet-zoom-animated"), this.options.className && Vi(A, this.options.className), A.onselectstart = J, A.onmousemove = J, A.onloadeddata = P(this.fire, this, "load"), p) {
            for (var B = A.getElementsByTagName("source"), X = [], ne = 0; ne < B.length; ne++)
              X.push(B[ne].src);
            this._url = B.length > 0 ? X : [A.src];
            return;
          }
          Et(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(A.style, "objectFit") && (A.style.objectFit = "fill"), A.autoplay = !!this.options.autoplay, A.loop = !!this.options.loop, A.muted = !!this.options.muted, A.playsInline = !!this.options.playsInline;
          for (var ye = 0; ye < this._url.length; ye++) {
            var We = tn("source");
            We.src = this._url[ye], A.appendChild(We);
          }
        }
        // @method getElement(): HTMLVideoElement
        // Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
        // used by this overlay.
      });
      function hr(p, A, B) {
        return new Vc(p, A, B);
      }
      var Uc = Va.extend({
        _initImage: function() {
          var p = this._image = this._url;
          Vi(p, "leaflet-image-layer"), this._zoomAnimated && Vi(p, "leaflet-zoom-animated"), this.options.className && Vi(p, this.options.className), p.onselectstart = J, p.onmousemove = J;
        }
        // @method getElement(): SVGElement
        // Returns the instance of [`SVGElement`](https://developer.mozilla.org/docs/Web/API/SVGElement)
        // used by this overlay.
      });
      function jc(p, A, B) {
        return new Uc(p, A, B);
      }
      var xr = ar.extend({
        // @section
        // @aka DivOverlay options
        options: {
          // @option interactive: Boolean = false
          // If true, the popup/tooltip will listen to the mouse events.
          interactive: !1,
          // @option offset: Point = Point(0, 0)
          // The offset of the overlay position.
          offset: [0, 0],
          // @option className: String = ''
          // A custom CSS class name to assign to the overlay.
          className: "",
          // @option pane: String = undefined
          // `Map pane` where the overlay will be added.
          pane: void 0,
          // @option content: String|HTMLElement|Function = ''
          // Sets the HTML content of the overlay while initializing. If a function is passed the source layer will be
          // passed to the function. The function should return a `String` or `HTMLElement` to be used in the overlay.
          content: ""
        },
        initialize: function(p, A) {
          p && (p instanceof Di || Et(p)) ? (this._latlng = xi(p), we(this, A)) : (we(this, p), this._source = A), this.options.content && (this._content = this.options.content);
        },
        // @method openOn(map: Map): this
        // Adds the overlay to the map.
        // Alternative to `map.openPopup(popup)`/`.openTooltip(tooltip)`.
        openOn: function(p) {
          return p = arguments.length ? p : this._source._map, p.hasLayer(this) || p.addLayer(this), this;
        },
        // @method close(): this
        // Closes the overlay.
        // Alternative to `map.closePopup(popup)`/`.closeTooltip(tooltip)`
        // and `layer.closePopup()`/`.closeTooltip()`.
        close: function() {
          return this._map && this._map.removeLayer(this), this;
        },
        // @method toggle(layer?: Layer): this
        // Opens or closes the overlay bound to layer depending on its current state.
        // Argument may be omitted only for overlay bound to layer.
        // Alternative to `layer.togglePopup()`/`.toggleTooltip()`.
        toggle: function(p) {
          return this._map ? this.close() : (arguments.length ? this._source = p : p = this._source, this._prepareOpen(), this.openOn(p._map)), this;
        },
        onAdd: function(p) {
          this._zoomAnimated = p._zoomAnimated, this._container || this._initLayout(), p._fadeAnimated && Qn(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), p._fadeAnimated && Qn(this._container, 1), this.bringToFront(), this.options.interactive && (Vi(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
        },
        onRemove: function(p) {
          p._fadeAnimated ? (Qn(this._container, 0), this._removeTimeout = setTimeout(P(xn, void 0, this._container), 200)) : xn(this._container), this.options.interactive && (Hn(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container));
        },
        // @namespace DivOverlay
        // @method getLatLng: LatLng
        // Returns the geographical point of the overlay.
        getLatLng: function() {
          return this._latlng;
        },
        // @method setLatLng(latlng: LatLng): this
        // Sets the geographical point where the overlay will open.
        setLatLng: function(p) {
          return this._latlng = xi(p), this._map && (this._updatePosition(), this._adjustPan()), this;
        },
        // @method getContent: String|HTMLElement
        // Returns the content of the overlay.
        getContent: function() {
          return this._content;
        },
        // @method setContent(htmlContent: String|HTMLElement|Function): this
        // Sets the HTML content of the overlay. If a function is passed the source layer will be passed to the function.
        // The function should return a `String` or `HTMLElement` to be used in the overlay.
        setContent: function(p) {
          return this._content = p, this.update(), this;
        },
        // @method getElement: String|HTMLElement
        // Returns the HTML container of the overlay.
        getElement: function() {
          return this._container;
        },
        // @method update: null
        // Updates the overlay content, layout and position. Useful for updating the overlay after something inside changed, e.g. image loaded.
        update: function() {
          this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan());
        },
        getEvents: function() {
          var p = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          return this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @method isOpen: Boolean
        // Returns `true` when the overlay is visible on the map.
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        // @method bringToFront: this
        // Brings this overlay in front of other overlays (in the same map pane).
        bringToFront: function() {
          return this._map && jo(this._container), this;
        },
        // @method bringToBack: this
        // Brings this overlay to the back of other overlays (in the same map pane).
        bringToBack: function() {
          return this._map && oa(this._container), this;
        },
        // prepare bound overlay to open: update latlng pos / content source (for FeatureGroup)
        _prepareOpen: function(p) {
          var A = this._source;
          if (!A._map)
            return !1;
          if (A instanceof Xr) {
            A = null;
            var B = this._source._layers;
            for (var X in B)
              if (B[X]._map) {
                A = B[X];
                break;
              }
            if (!A)
              return !1;
            this._source = A;
          }
          if (!p)
            if (A.getCenter)
              p = A.getCenter();
            else if (A.getLatLng)
              p = A.getLatLng();
            else if (A.getBounds)
              p = A.getBounds().getCenter();
            else
              throw new Error("Unable to get source layer LatLng.");
          return this.setLatLng(p), this._map && this.update(), !0;
        },
        _updateContent: function() {
          if (this._content) {
            var p = this._contentNode, A = typeof this._content == "function" ? this._content(this._source || this) : this._content;
            if (typeof A == "string")
              p.innerHTML = A;
            else {
              for (; p.hasChildNodes(); )
                p.removeChild(p.firstChild);
              p.appendChild(A);
            }
            this.fire("contentupdate");
          }
        },
        _updatePosition: function() {
          if (this._map) {
            var p = this._map.latLngToLayerPoint(this._latlng), A = ni(this.options.offset), B = this._getAnchor();
            this._zoomAnimated ? Yn(this._container, p.add(B)) : A = A.add(p).add(B);
            var X = this._containerBottom = -A.y, ne = this._containerLeft = -Math.round(this._containerWidth / 2) + A.x;
            this._container.style.bottom = X + "px", this._container.style.left = ne + "px";
          }
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      nn.include({
        _initOverlay: function(p, A, B, X) {
          var ne = A;
          return ne instanceof p || (ne = new p(X).setContent(A)), B && ne.setLatLng(B), ne;
        }
      }), ar.include({
        _initOverlay: function(p, A, B, X) {
          var ne = B;
          return ne instanceof p ? (we(ne, X), ne._source = this) : (ne = A && !X ? A : new p(X, this), ne.setContent(B)), ne;
        }
      });
      var Yo = xr.extend({
        // @section
        // @aka Popup options
        options: {
          // @option pane: String = 'popupPane'
          // `Map pane` where the popup will be added.
          pane: "popupPane",
          // @option offset: Point = Point(0, 7)
          // The offset of the popup position.
          offset: [0, 7],
          // @option maxWidth: Number = 300
          // Max width of the popup, in pixels.
          maxWidth: 300,
          // @option minWidth: Number = 50
          // Min width of the popup, in pixels.
          minWidth: 50,
          // @option maxHeight: Number = null
          // If set, creates a scrollable container of the given height
          // inside a popup if its content exceeds it.
          // The scrollable container can be styled using the
          // `leaflet-popup-scrolled` CSS class selector.
          maxHeight: null,
          // @option autoPan: Boolean = true
          // Set it to `false` if you don't want the map to do panning animation
          // to fit the opened popup.
          autoPan: !0,
          // @option autoPanPaddingTopLeft: Point = null
          // The margin between the popup and the top left corner of the map
          // view after autopanning was performed.
          autoPanPaddingTopLeft: null,
          // @option autoPanPaddingBottomRight: Point = null
          // The margin between the popup and the bottom right corner of the map
          // view after autopanning was performed.
          autoPanPaddingBottomRight: null,
          // @option autoPanPadding: Point = Point(5, 5)
          // Equivalent of setting both top left and bottom right autopan padding to the same value.
          autoPanPadding: [5, 5],
          // @option keepInView: Boolean = false
          // Set it to `true` if you want to prevent users from panning the popup
          // off of the screen while it is open.
          keepInView: !1,
          // @option closeButton: Boolean = true
          // Controls the presence of a close button in the popup.
          closeButton: !0,
          // @option autoClose: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the popup closing when another popup is opened.
          autoClose: !0,
          // @option closeOnEscapeKey: Boolean = true
          // Set it to `false` if you want to override the default behavior of
          // the ESC key for closing of the popup.
          closeOnEscapeKey: !0,
          // @option closeOnClick: Boolean = *
          // Set it if you want to override the default behavior of the popup closing when user clicks
          // on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.
          // @option className: String = ''
          // A custom CSS class name to assign to the popup.
          className: ""
        },
        // @namespace Popup
        // @method openOn(map: Map): this
        // Alternative to `map.openPopup(popup)`.
        // Adds the popup to the map and closes the previous one.
        openOn: function(p) {
          return p = arguments.length ? p : this._source._map, !p.hasLayer(this) && p._popup && p._popup.options.autoClose && p.removeLayer(p._popup), p._popup = this, xr.prototype.openOn.call(this, p);
        },
        onAdd: function(p) {
          xr.prototype.onAdd.call(this, p), p.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof wt || this._source.on("preclick", ms));
        },
        onRemove: function(p) {
          xr.prototype.onRemove.call(this, p), p.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof wt || this._source.off("preclick", ms));
        },
        getEvents: function() {
          var p = xr.prototype.getEvents.call(this);
          return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (p.preclick = this.close), this.options.keepInView && (p.moveend = this._adjustPan), p;
        },
        _initLayout: function() {
          var p = "leaflet-popup", A = this._container = tn(
            "div",
            p + " " + (this.options.className || "") + " leaflet-zoom-animated"
          ), B = this._wrapper = tn("div", p + "-content-wrapper", A);
          if (this._contentNode = tn("div", p + "-content", B), Ai(A), vo(this._contentNode), Bi(A, "contextmenu", ms), this._tipContainer = tn("div", p + "-tip-container", A), this._tip = tn("div", p + "-tip", this._tipContainer), this.options.closeButton) {
            var X = this._closeButton = tn("a", p + "-close-button", A);
            X.setAttribute("role", "button"), X.setAttribute("aria-label", "Close popup"), X.href = "#close", X.innerHTML = '<span aria-hidden="true">&#215;</span>', Bi(X, "click", function(ne) {
              _s(ne), this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var p = this._contentNode, A = p.style;
          A.width = "", A.whiteSpace = "nowrap";
          var B = p.offsetWidth;
          B = Math.min(B, this.options.maxWidth), B = Math.max(B, this.options.minWidth), A.width = B + 1 + "px", A.whiteSpace = "", A.height = "";
          var X = p.offsetHeight, ne = this.options.maxHeight, ye = "leaflet-popup-scrolled";
          ne && X > ne ? (A.height = ne + "px", Vi(p, ye)) : Hn(p, ye), this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(p) {
          var A = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center), B = this._getAnchor();
          Yn(this._container, A.add(B));
        },
        _adjustPan: function() {
          if (this.options.autoPan) {
            if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) {
              this._autopanning = !1;
              return;
            }
            var p = this._map, A = parseInt(Uo(this._container, "marginBottom"), 10) || 0, B = this._container.offsetHeight + A, X = this._containerWidth, ne = new fi(this._containerLeft, -B - this._containerBottom);
            ne._add($r(this._container));
            var ye = p.layerPointToContainerPoint(ne), We = ni(this.options.autoPanPadding), ot = ni(this.options.autoPanPaddingTopLeft || We), ft = ni(this.options.autoPanPaddingBottomRight || We), Rt = p.getSize(), ii = 0, Ci = 0;
            ye.x + X + ft.x > Rt.x && (ii = ye.x + X - Rt.x + ft.x), ye.x - ii - ot.x < 0 && (ii = ye.x - ot.x), ye.y + B + ft.y > Rt.y && (Ci = ye.y + B - Rt.y + ft.y), ye.y - Ci - ot.y < 0 && (Ci = ye.y - ot.y), (ii || Ci) && (this.options.keepInView && (this._autopanning = !0), p.fire("autopanstart").panBy([ii, Ci]));
          }
        },
        _getAnchor: function() {
          return ni(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      }), Wl = function(p, A) {
        return new Yo(p, A);
      };
      nn.mergeOptions({
        closePopupOnClick: !0
      }), nn.include({
        // @method openPopup(popup: Popup): this
        // Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
        // @alternative
        // @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
        // Creates a popup with the specified content and options and opens it in the given point on a map.
        openPopup: function(p, A, B) {
          return this._initOverlay(Yo, p, A, B).openOn(this), this;
        },
        // @method closePopup(popup?: Popup): this
        // Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
        closePopup: function(p) {
          return p = arguments.length ? p : this._popup, p && p.close(), this;
        }
      }), ar.include({
        // @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
        // Binds a popup to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindPopup: function(p, A) {
          return this._popup = this._initOverlay(Yo, this._popup, p, A), this._popupHandlersAdded || (this.on({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !0), this;
        },
        // @method unbindPopup(): this
        // Removes the popup previously bound with `bindPopup`.
        unbindPopup: function() {
          return this._popup && (this.off({
            click: this._openPopup,
            keypress: this._onKeyPress,
            remove: this.closePopup,
            move: this._movePopup
          }), this._popupHandlersAdded = !1, this._popup = null), this;
        },
        // @method openPopup(latlng?: LatLng): this
        // Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
        openPopup: function(p) {
          return this._popup && (this instanceof Xr || (this._popup._source = this), this._popup._prepareOpen(p || this._latlng) && this._popup.openOn(this._map)), this;
        },
        // @method closePopup(): this
        // Closes the popup bound to this layer if it is open.
        closePopup: function() {
          return this._popup && this._popup.close(), this;
        },
        // @method togglePopup(): this
        // Opens or closes the popup bound to this layer depending on its current state.
        togglePopup: function() {
          return this._popup && this._popup.toggle(this), this;
        },
        // @method isPopupOpen(): boolean
        // Returns `true` if the popup bound to this layer is currently open.
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : !1;
        },
        // @method setPopupContent(content: String|HTMLElement|Popup): this
        // Sets the content of the popup bound to this layer.
        setPopupContent: function(p) {
          return this._popup && this._popup.setContent(p), this;
        },
        // @method getPopup(): Popup
        // Returns the popup bound to this layer.
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(p) {
          if (!(!this._popup || !this._map)) {
            Ks(p);
            var A = p.layer || p.target;
            if (this._popup._source === A && !(A instanceof wt)) {
              this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(p.latlng);
              return;
            }
            this._popup._source = A, this.openPopup(p.latlng);
          }
        },
        _movePopup: function(p) {
          this._popup.setLatLng(p.latlng);
        },
        _onKeyPress: function(p) {
          p.originalEvent.keyCode === 13 && this._openPopup(p);
        }
      });
      var Jr = xr.extend({
        // @section
        // @aka Tooltip options
        options: {
          // @option pane: String = 'tooltipPane'
          // `Map pane` where the tooltip will be added.
          pane: "tooltipPane",
          // @option offset: Point = Point(0, 0)
          // Optional offset of the tooltip position.
          offset: [0, 0],
          // @option direction: String = 'auto'
          // Direction where to open the tooltip. Possible values are: `right`, `left`,
          // `top`, `bottom`, `center`, `auto`.
          // `auto` will dynamically switch between `right` and `left` according to the tooltip
          // position on the map.
          direction: "auto",
          // @option permanent: Boolean = false
          // Whether to open the tooltip permanently or only on mouseover.
          permanent: !1,
          // @option sticky: Boolean = false
          // If true, the tooltip will follow the mouse instead of being fixed at the feature center.
          sticky: !1,
          // @option opacity: Number = 0.9
          // Tooltip container opacity.
          opacity: 0.9
        },
        onAdd: function(p) {
          xr.prototype.onAdd.call(this, p), this.setOpacity(this.options.opacity), p.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0));
        },
        onRemove: function(p) {
          xr.prototype.onRemove.call(this, p), p.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0));
        },
        getEvents: function() {
          var p = xr.prototype.getEvents.call(this);
          return this.options.permanent || (p.preclick = this.close), p;
        },
        _initLayout: function() {
          var p = "leaflet-tooltip", A = p + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = tn("div", A), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + O(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(p) {
          var A, B, X = this._map, ne = this._container, ye = X.latLngToContainerPoint(X.getCenter()), We = X.layerPointToContainerPoint(p), ot = this.options.direction, ft = ne.offsetWidth, Rt = ne.offsetHeight, ii = ni(this.options.offset), Ci = this._getAnchor();
          ot === "top" ? (A = ft / 2, B = Rt) : ot === "bottom" ? (A = ft / 2, B = 0) : ot === "center" ? (A = ft / 2, B = Rt / 2) : ot === "right" ? (A = 0, B = Rt / 2) : ot === "left" ? (A = ft, B = Rt / 2) : We.x < ye.x ? (ot = "right", A = 0, B = Rt / 2) : (ot = "left", A = ft + (ii.x + Ci.x) * 2, B = Rt / 2), p = p.subtract(ni(A, B, !0)).add(ii).add(Ci), Hn(ne, "leaflet-tooltip-right"), Hn(ne, "leaflet-tooltip-left"), Hn(ne, "leaflet-tooltip-top"), Hn(ne, "leaflet-tooltip-bottom"), Vi(ne, "leaflet-tooltip-" + ot), Yn(ne, p);
        },
        _updatePosition: function() {
          var p = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(p);
        },
        setOpacity: function(p) {
          this.options.opacity = p, this._container && Qn(this._container, p);
        },
        _animateZoom: function(p) {
          var A = this._map._latLngToNewLayerPoint(this._latlng, p.zoom, p.center);
          this._setPosition(A);
        },
        _getAnchor: function() {
          return ni(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      }), $l = function(p, A) {
        return new Jr(p, A);
      };
      nn.include({
        // @method openTooltip(tooltip: Tooltip): this
        // Opens the specified tooltip.
        // @alternative
        // @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
        // Creates a tooltip with the specified content and options and open it.
        openTooltip: function(p, A, B) {
          return this._initOverlay(Jr, p, A, B).openOn(this), this;
        },
        // @method closeTooltip(tooltip: Tooltip): this
        // Closes the tooltip given as parameter.
        closeTooltip: function(p) {
          return p.close(), this;
        }
      }), ar.include({
        // @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
        // Binds a tooltip to the layer with the passed `content` and sets up the
        // necessary event listeners. If a `Function` is passed it will receive
        // the layer as the first argument and should return a `String` or `HTMLElement`.
        bindTooltip: function(p, A) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Jr, this._tooltip, p, A), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;
        },
        // @method unbindTooltip(): this
        // Removes the tooltip previously bound with `bindTooltip`.
        unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;
        },
        _initTooltipInteractions: function(p) {
          if (!(!p && this._tooltipHandlersAdded)) {
            var A = p ? "off" : "on", B = {
              remove: this.closeTooltip,
              move: this._moveTooltip
            };
            this._tooltip.options.permanent ? B.add = this._openTooltip : (B.mouseover = this._openTooltip, B.mouseout = this.closeTooltip, B.click = this._openTooltip, this._map ? this._addFocusListeners() : B.add = this._addFocusListeners), this._tooltip.options.sticky && (B.mousemove = this._moveTooltip), this[A](B), this._tooltipHandlersAdded = !p;
          }
        },
        // @method openTooltip(latlng?: LatLng): this
        // Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
        openTooltip: function(p) {
          return this._tooltip && (this instanceof Xr || (this._tooltip._source = this), this._tooltip._prepareOpen(p) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this;
        },
        // @method closeTooltip(): this
        // Closes the tooltip bound to this layer if it is open.
        closeTooltip: function() {
          if (this._tooltip)
            return this._tooltip.close();
        },
        // @method toggleTooltip(): this
        // Opens or closes the tooltip bound to this layer depending on its current state.
        toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this), this;
        },
        // @method isTooltipOpen(): boolean
        // Returns `true` if the tooltip bound to this layer is currently open.
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        // @method setTooltipContent(content: String|HTMLElement|Tooltip): this
        // Sets the content of the tooltip bound to this layer.
        setTooltipContent: function(p) {
          return this._tooltip && this._tooltip.setContent(p), this;
        },
        // @method getTooltip(): Tooltip
        // Returns the tooltip bound to this layer.
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
        },
        _addFocusListenersOnLayer: function(p) {
          var A = typeof p.getElement == "function" && p.getElement();
          A && (Bi(A, "focus", function() {
            this._tooltip._source = p, this.openTooltip();
          }, this), Bi(A, "blur", this.closeTooltip, this));
        },
        _setAriaDescribedByOnLayer: function(p) {
          var A = typeof p.getElement == "function" && p.getElement();
          A && A.setAttribute("aria-describedby", this._tooltip._container.id);
        },
        _openTooltip: function(p) {
          if (!(!this._tooltip || !this._map)) {
            if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
              this._openOnceFlag = !0;
              var A = this;
              this._map.once("moveend", function() {
                A._openOnceFlag = !1, A._openTooltip(p);
              });
              return;
            }
            this._tooltip._source = p.layer || p.target, this.openTooltip(this._tooltip.options.sticky ? p.latlng : void 0);
          }
        },
        _moveTooltip: function(p) {
          var A = p.latlng, B, X;
          this._tooltip.options.sticky && p.originalEvent && (B = this._map.mouseEventToContainerPoint(p.originalEvent), X = this._map.containerPointToLayerPoint(B), A = this._map.layerPointToLatLng(X)), this._tooltip.setLatLng(A);
        }
      });
      var Xl = Yr.extend({
        options: {
          // @section
          // @aka DivIcon options
          iconSize: [12, 12],
          // also can be set through CSS
          // iconAnchor: (Point),
          // popupAnchor: (Point),
          // @option html: String|HTMLElement = ''
          // Custom HTML code to put inside the div element, empty by default. Alternatively,
          // an instance of `HTMLElement`.
          html: !1,
          // @option bgPos: Point = [0, 0]
          // Optional relative position of the background, in pixels
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(p) {
          var A = p && p.tagName === "DIV" ? p : document.createElement("div"), B = this.options;
          if (B.html instanceof Element ? (no(A), A.appendChild(B.html)) : A.innerHTML = B.html !== !1 ? B.html : "", B.bgPos) {
            var X = ni(B.bgPos);
            A.style.backgroundPosition = -X.x + "px " + -X.y + "px";
          }
          return this._setIconStyles(A, "icon"), A;
        },
        createShadow: function() {
          return null;
        }
      });
      function ga(p) {
        return new Xl(p);
      }
      Yr.Default = wo;
      var ro = ar.extend({
        // @section
        // @aka GridLayer options
        options: {
          // @option tileSize: Number|Point = 256
          // Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
          tileSize: 256,
          // @option opacity: Number = 1.0
          // Opacity of the tiles. Can be used in the `createTile()` function.
          opacity: 1,
          // @option updateWhenIdle: Boolean = (depends)
          // Load new tiles only when panning ends.
          // `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
          // `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
          // [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
          updateWhenIdle: Ae.mobile,
          // @option updateWhenZooming: Boolean = true
          // By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
          updateWhenZooming: !0,
          // @option updateInterval: Number = 200
          // Tiles will not update more than once every `updateInterval` milliseconds when panning.
          updateInterval: 200,
          // @option zIndex: Number = 1
          // The explicit zIndex of the tile layer.
          zIndex: 1,
          // @option bounds: LatLngBounds = undefined
          // If set, tiles will only be loaded inside the set `LatLngBounds`.
          bounds: null,
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = undefined
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: void 0,
          // @option maxNativeZoom: Number = undefined
          // Maximum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
          // from `maxNativeZoom` level and auto-scaled.
          maxNativeZoom: void 0,
          // @option minNativeZoom: Number = undefined
          // Minimum zoom number the tile source has available. If it is specified,
          // the tiles on all zoom levels lower than `minNativeZoom` will be loaded
          // from `minNativeZoom` level and auto-scaled.
          minNativeZoom: void 0,
          // @option noWrap: Boolean = false
          // Whether the layer is wrapped around the antimeridian. If `true`, the
          // GridLayer will only be displayed once at low zoom levels. Has no
          // effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
          // in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
          // tiles outside the CRS limits.
          noWrap: !1,
          // @option pane: String = 'tilePane'
          // `Map pane` where the grid layer will be added.
          pane: "tilePane",
          // @option className: String = ''
          // A custom class name to assign to the tile layer. Empty by default.
          className: "",
          // @option keepBuffer: Number = 2
          // When panning the map, keep this many rows and columns of tiles before unloading them.
          keepBuffer: 2
        },
        initialize: function(p) {
          we(this, p);
        },
        onAdd: function() {
          this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
        },
        beforeAdd: function(p) {
          p._addZoomLimit(this);
        },
        onRemove: function(p) {
          this._removeAllTiles(), xn(this._container), p._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;
        },
        // @method bringToFront: this
        // Brings the tile layer to the top of all tile layers.
        bringToFront: function() {
          return this._map && (jo(this._container), this._setAutoZIndex(Math.max)), this;
        },
        // @method bringToBack: this
        // Brings the tile layer to the bottom of all tile layers.
        bringToBack: function() {
          return this._map && (oa(this._container), this._setAutoZIndex(Math.min)), this;
        },
        // @method getContainer: HTMLElement
        // Returns the HTML element that contains the tiles for this layer.
        getContainer: function() {
          return this._container;
        },
        // @method setOpacity(opacity: Number): this
        // Changes the [opacity](#gridlayer-opacity) of the grid layer.
        setOpacity: function(p) {
          return this.options.opacity = p, this._updateOpacity(), this;
        },
        // @method setZIndex(zIndex: Number): this
        // Changes the [zIndex](#gridlayer-zindex) of the grid layer.
        setZIndex: function(p) {
          return this.options.zIndex = p, this._updateZIndex(), this;
        },
        // @method isLoading: Boolean
        // Returns `true` if any tile in the grid layer has not finished loading.
        isLoading: function() {
          return this._loading;
        },
        // @method redraw: this
        // Causes the layer to clear all the tiles and request them again.
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var p = this._clampZoom(this._map.getZoom());
            p !== this._tileZoom && (this._tileZoom = p, this._updateLevels()), this._update();
          }
          return this;
        },
        getEvents: function() {
          var p = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = Z(this._onMoveEnd, this.options.updateInterval, this)), p.move = this._onMove), this._zoomAnimated && (p.zoomanim = this._animateZoom), p;
        },
        // @section Extension methods
        // Layers extending `GridLayer` shall reimplement the following method.
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, must be overridden by classes extending `GridLayer`.
        // Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
        // is specified, it must be called when the tile has finished loading and drawing.
        createTile: function() {
          return document.createElement("div");
        },
        // @section
        // @method getTileSize: Point
        // Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
        getTileSize: function() {
          var p = this.options.tileSize;
          return p instanceof fi ? p : new fi(p, p);
        },
        _updateZIndex: function() {
          this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex);
        },
        _setAutoZIndex: function(p) {
          for (var A = this.getPane().children, B = -p(-1 / 0, 1 / 0), X = 0, ne = A.length, ye; X < ne; X++)
            ye = A[X].style.zIndex, A[X] !== this._container && ye && (B = p(B, +ye));
          isFinite(B) && (this.options.zIndex = B + p(-1, 1), this._updateZIndex());
        },
        _updateOpacity: function() {
          if (this._map && !Ae.ielt9) {
            Qn(this._container, this.options.opacity);
            var p = +/* @__PURE__ */ new Date(), A = !1, B = !1;
            for (var X in this._tiles) {
              var ne = this._tiles[X];
              if (!(!ne.current || !ne.loaded)) {
                var ye = Math.min(1, (p - ne.loaded) / 200);
                Qn(ne.el, ye), ye < 1 ? A = !0 : (ne.active ? B = !0 : this._onOpaqueTile(ne), ne.active = !0);
              }
            }
            B && !this._noPrune && this._pruneTiles(), A && (Si(this._fadeFrame), this._fadeFrame = At(this._updateOpacity, this));
          }
        },
        _onOpaqueTile: J,
        _initContainer: function() {
          this._container || (this._container = tn("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
        },
        _updateLevels: function() {
          var p = this._tileZoom, A = this.options.maxZoom;
          if (p !== void 0) {
            for (var B in this._levels)
              B = Number(B), this._levels[B].el.children.length || B === p ? (this._levels[B].el.style.zIndex = A - Math.abs(p - B), this._onUpdateLevel(B)) : (xn(this._levels[B].el), this._removeTilesAtZoom(B), this._onRemoveLevel(B), delete this._levels[B]);
            var X = this._levels[p], ne = this._map;
            return X || (X = this._levels[p] = {}, X.el = tn("div", "leaflet-tile-container leaflet-zoom-animated", this._container), X.el.style.zIndex = A, X.origin = ne.project(ne.unproject(ne.getPixelOrigin()), p).round(), X.zoom = p, this._setZoomTransform(X, ne.getCenter(), ne.getZoom()), J(X.el.offsetWidth), this._onCreateLevel(X)), this._level = X, X;
          }
        },
        _onUpdateLevel: J,
        _onRemoveLevel: J,
        _onCreateLevel: J,
        _pruneTiles: function() {
          if (this._map) {
            var p, A, B = this._map.getZoom();
            if (B > this.options.maxZoom || B < this.options.minZoom) {
              this._removeAllTiles();
              return;
            }
            for (p in this._tiles)
              A = this._tiles[p], A.retain = A.current;
            for (p in this._tiles)
              if (A = this._tiles[p], A.current && !A.active) {
                var X = A.coords;
                this._retainParent(X.x, X.y, X.z, X.z - 5) || this._retainChildren(X.x, X.y, X.z, X.z + 2);
              }
            for (p in this._tiles)
              this._tiles[p].retain || this._removeTile(p);
          }
        },
        _removeTilesAtZoom: function(p) {
          for (var A in this._tiles)
            this._tiles[A].coords.z === p && this._removeTile(A);
        },
        _removeAllTiles: function() {
          for (var p in this._tiles)
            this._removeTile(p);
        },
        _invalidateAll: function() {
          for (var p in this._levels)
            xn(this._levels[p].el), this._onRemoveLevel(Number(p)), delete this._levels[p];
          this._removeAllTiles(), this._tileZoom = void 0;
        },
        _retainParent: function(p, A, B, X) {
          var ne = Math.floor(p / 2), ye = Math.floor(A / 2), We = B - 1, ot = new fi(+ne, +ye);
          ot.z = +We;
          var ft = this._tileCoordsToKey(ot), Rt = this._tiles[ft];
          return Rt && Rt.active ? (Rt.retain = !0, !0) : (Rt && Rt.loaded && (Rt.retain = !0), We > X ? this._retainParent(ne, ye, We, X) : !1);
        },
        _retainChildren: function(p, A, B, X) {
          for (var ne = 2 * p; ne < 2 * p + 2; ne++)
            for (var ye = 2 * A; ye < 2 * A + 2; ye++) {
              var We = new fi(ne, ye);
              We.z = B + 1;
              var ot = this._tileCoordsToKey(We), ft = this._tiles[ot];
              if (ft && ft.active) {
                ft.retain = !0;
                continue;
              } else
                ft && ft.loaded && (ft.retain = !0);
              B + 1 < X && this._retainChildren(ne, ye, B + 1, X);
            }
        },
        _resetView: function(p) {
          var A = p && (p.pinch || p.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), A, A);
        },
        _animateZoom: function(p) {
          this._setView(p.center, p.zoom, !0, p.noUpdate);
        },
        _clampZoom: function(p) {
          var A = this.options;
          return A.minNativeZoom !== void 0 && p < A.minNativeZoom ? A.minNativeZoom : A.maxNativeZoom !== void 0 && A.maxNativeZoom < p ? A.maxNativeZoom : p;
        },
        _setView: function(p, A, B, X) {
          var ne = Math.round(A);
          this.options.maxZoom !== void 0 && ne > this.options.maxZoom || this.options.minZoom !== void 0 && ne < this.options.minZoom ? ne = void 0 : ne = this._clampZoom(ne);
          var ye = this.options.updateWhenZooming && ne !== this._tileZoom;
          (!X || ye) && (this._tileZoom = ne, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), ne !== void 0 && this._update(p), B || this._pruneTiles(), this._noPrune = !!B), this._setZoomTransforms(p, A);
        },
        _setZoomTransforms: function(p, A) {
          for (var B in this._levels)
            this._setZoomTransform(this._levels[B], p, A);
        },
        _setZoomTransform: function(p, A, B) {
          var X = this._map.getZoomScale(B, p.zoom), ne = p.origin.multiplyBy(X).subtract(this._map._getNewPixelOrigin(A, B)).round();
          Ae.any3d ? Ys(p.el, ne, X) : Yn(p.el, ne);
        },
        _resetGrid: function() {
          var p = this._map, A = p.options.crs, B = this._tileSize = this.getTileSize(), X = this._tileZoom, ne = this._map.getPixelWorldBounds(this._tileZoom);
          ne && (this._globalTileRange = this._pxBoundsToTileRange(ne)), this._wrapX = A.wrapLng && !this.options.noWrap && [
            Math.floor(p.project([0, A.wrapLng[0]], X).x / B.x),
            Math.ceil(p.project([0, A.wrapLng[1]], X).x / B.y)
          ], this._wrapY = A.wrapLat && !this.options.noWrap && [
            Math.floor(p.project([A.wrapLat[0], 0], X).y / B.x),
            Math.ceil(p.project([A.wrapLat[1], 0], X).y / B.y)
          ];
        },
        _onMoveEnd: function() {
          !this._map || this._map._animatingZoom || this._update();
        },
        _getTiledPixelBounds: function(p) {
          var A = this._map, B = A._animatingZoom ? Math.max(A._animateToZoom, A.getZoom()) : A.getZoom(), X = A.getZoomScale(B, this._tileZoom), ne = A.project(p, this._tileZoom).floor(), ye = A.getSize().divideBy(X * 2);
          return new Gi(ne.subtract(ye), ne.add(ye));
        },
        // Private method to load tiles in the grid's active zoom level according to map bounds
        _update: function(p) {
          var A = this._map;
          if (A) {
            var B = this._clampZoom(A.getZoom());
            if (p === void 0 && (p = A.getCenter()), this._tileZoom !== void 0) {
              var X = this._getTiledPixelBounds(p), ne = this._pxBoundsToTileRange(X), ye = ne.getCenter(), We = [], ot = this.options.keepBuffer, ft = new Gi(
                ne.getBottomLeft().subtract([ot, -ot]),
                ne.getTopRight().add([ot, -ot])
              );
              if (!(isFinite(ne.min.x) && isFinite(ne.min.y) && isFinite(ne.max.x) && isFinite(ne.max.y)))
                throw new Error("Attempted to load an infinite number of tiles");
              for (var Rt in this._tiles) {
                var ii = this._tiles[Rt].coords;
                (ii.z !== this._tileZoom || !ft.contains(new fi(ii.x, ii.y))) && (this._tiles[Rt].current = !1);
              }
              if (Math.abs(B - this._tileZoom) > 1) {
                this._setView(p, B);
                return;
              }
              for (var Ci = ne.min.y; Ci <= ne.max.y; Ci++)
                for (var Wi = ne.min.x; Wi <= ne.max.x; Wi++) {
                  var Hs = new fi(Wi, Ci);
                  if (Hs.z = this._tileZoom, !!this._isValidTile(Hs)) {
                    var ws = this._tiles[this._tileCoordsToKey(Hs)];
                    ws ? ws.current = !0 : We.push(Hs);
                  }
                }
              if (We.sort(function(ur, ja) {
                return ur.distanceTo(ye) - ja.distanceTo(ye);
              }), We.length !== 0) {
                this._loading || (this._loading = !0, this.fire("loading"));
                var Rs = document.createDocumentFragment();
                for (Wi = 0; Wi < We.length; Wi++)
                  this._addTile(We[Wi], Rs);
                this._level.el.appendChild(Rs);
              }
            }
          }
        },
        _isValidTile: function(p) {
          var A = this._map.options.crs;
          if (!A.infinite) {
            var B = this._globalTileRange;
            if (!A.wrapLng && (p.x < B.min.x || p.x > B.max.x) || !A.wrapLat && (p.y < B.min.y || p.y > B.max.y))
              return !1;
          }
          if (!this.options.bounds)
            return !0;
          var X = this._tileCoordsToBounds(p);
          return ln(this.options.bounds).overlaps(X);
        },
        _keyToBounds: function(p) {
          return this._tileCoordsToBounds(this._keyToTileCoords(p));
        },
        _tileCoordsToNwSe: function(p) {
          var A = this._map, B = this.getTileSize(), X = p.scaleBy(B), ne = X.add(B), ye = A.unproject(X, p.z), We = A.unproject(ne, p.z);
          return [ye, We];
        },
        // converts tile coordinates to its geographical bounds
        _tileCoordsToBounds: function(p) {
          var A = this._tileCoordsToNwSe(p), B = new qt(A[0], A[1]);
          return this.options.noWrap || (B = this._map.wrapLatLngBounds(B)), B;
        },
        // converts tile coordinates to key for the tile cache
        _tileCoordsToKey: function(p) {
          return p.x + ":" + p.y + ":" + p.z;
        },
        // converts tile cache key to coordinates
        _keyToTileCoords: function(p) {
          var A = p.split(":"), B = new fi(+A[0], +A[1]);
          return B.z = +A[2], B;
        },
        _removeTile: function(p) {
          var A = this._tiles[p];
          A && (xn(A.el), delete this._tiles[p], this.fire("tileunload", {
            tile: A.el,
            coords: this._keyToTileCoords(p)
          }));
        },
        _initTile: function(p) {
          Vi(p, "leaflet-tile");
          var A = this.getTileSize();
          p.style.width = A.x + "px", p.style.height = A.y + "px", p.onselectstart = J, p.onmousemove = J, Ae.ielt9 && this.options.opacity < 1 && Qn(p, this.options.opacity);
        },
        _addTile: function(p, A) {
          var B = this._getTilePos(p), X = this._tileCoordsToKey(p), ne = this.createTile(this._wrapCoords(p), P(this._tileReady, this, p));
          this._initTile(ne), this.createTile.length < 2 && At(P(this._tileReady, this, p, null, ne)), Yn(ne, B), this._tiles[X] = {
            el: ne,
            coords: p,
            current: !0
          }, A.appendChild(ne), this.fire("tileloadstart", {
            tile: ne,
            coords: p
          });
        },
        _tileReady: function(p, A, B) {
          A && this.fire("tileerror", {
            error: A,
            tile: B,
            coords: p
          });
          var X = this._tileCoordsToKey(p);
          B = this._tiles[X], B && (B.loaded = +/* @__PURE__ */ new Date(), this._map._fadeAnimated ? (Qn(B.el, 0), Si(this._fadeFrame), this._fadeFrame = At(this._updateOpacity, this)) : (B.active = !0, this._pruneTiles()), A || (Vi(B.el, "leaflet-tile-loaded"), this.fire("tileload", {
            tile: B.el,
            coords: p
          })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Ae.ielt9 || !this._map._fadeAnimated ? At(this._pruneTiles, this) : setTimeout(P(this._pruneTiles, this), 250)));
        },
        _getTilePos: function(p) {
          return p.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(p) {
          var A = new fi(
            this._wrapX ? Y(p.x, this._wrapX) : p.x,
            this._wrapY ? Y(p.y, this._wrapY) : p.y
          );
          return A.z = p.z, A;
        },
        _pxBoundsToTileRange: function(p) {
          var A = this.getTileSize();
          return new Gi(
            p.min.unscaleBy(A).floor(),
            p.max.unscaleBy(A).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var p in this._tiles)
            if (!this._tiles[p].loaded)
              return !1;
          return !0;
        }
      });
      function gl(p) {
        return new ro(p);
      }
      var kr = ro.extend({
        // @section
        // @aka TileLayer options
        options: {
          // @option minZoom: Number = 0
          // The minimum zoom level down to which this layer will be displayed (inclusive).
          minZoom: 0,
          // @option maxZoom: Number = 18
          // The maximum zoom level up to which this layer will be displayed (inclusive).
          maxZoom: 18,
          // @option subdomains: String|String[] = 'abc'
          // Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
          subdomains: "abc",
          // @option errorTileUrl: String = ''
          // URL to the tile image to show in place of the tile that failed to load.
          errorTileUrl: "",
          // @option zoomOffset: Number = 0
          // The zoom number used in tile URLs will be offset with this value.
          zoomOffset: 0,
          // @option tms: Boolean = false
          // If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
          tms: !1,
          // @option zoomReverse: Boolean = false
          // If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
          zoomReverse: !1,
          // @option detectRetina: Boolean = false
          // If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
          detectRetina: !1,
          // @option crossOrigin: Boolean|String = false
          // Whether the crossOrigin attribute will be added to the tiles.
          // If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
          // Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
          crossOrigin: !1,
          // @option referrerPolicy: Boolean|String = false
          // Whether the referrerPolicy attribute will be added to the tiles.
          // If a String is provided, all tiles will have their referrerPolicy attribute set to the String provided.
          // This may be needed if your map's rendering context has a strict default but your tile provider expects a valid referrer
          // (e.g. to validate an API token).
          // Refer to [HTMLImageElement.referrerPolicy](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/referrerPolicy) for valid String values.
          referrerPolicy: !1
        },
        initialize: function(p, A) {
          this._url = p, A = we(this, A), A.detectRetina && Ae.retina && A.maxZoom > 0 ? (A.tileSize = Math.floor(A.tileSize / 2), A.zoomReverse ? (A.zoomOffset--, A.minZoom = Math.min(A.maxZoom, A.minZoom + 1)) : (A.zoomOffset++, A.maxZoom = Math.max(A.minZoom, A.maxZoom - 1)), A.minZoom = Math.max(0, A.minZoom)) : A.zoomReverse ? A.minZoom = Math.min(A.maxZoom, A.minZoom) : A.maxZoom = Math.max(A.minZoom, A.maxZoom), typeof A.subdomains == "string" && (A.subdomains = A.subdomains.split("")), this.on("tileunload", this._onTileRemove);
        },
        // @method setUrl(url: String, noRedraw?: Boolean): this
        // Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
        // If the URL does not change, the layer will not be redrawn unless
        // the noRedraw parameter is set to false.
        setUrl: function(p, A) {
          return this._url === p && A === void 0 && (A = !0), this._url = p, A || this.redraw(), this;
        },
        // @method createTile(coords: Object, done?: Function): HTMLElement
        // Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
        // to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
        // callback is called when the tile has been loaded.
        createTile: function(p, A) {
          var B = document.createElement("img");
          return Bi(B, "load", P(this._tileOnLoad, this, A, B)), Bi(B, "error", P(this._tileOnError, this, A, B)), (this.options.crossOrigin || this.options.crossOrigin === "") && (B.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin), typeof this.options.referrerPolicy == "string" && (B.referrerPolicy = this.options.referrerPolicy), B.alt = "", B.src = this.getTileUrl(p), B;
        },
        // @section Extension methods
        // @uninheritable
        // Layers extending `TileLayer` might reimplement the following method.
        // @method getTileUrl(coords: Object): String
        // Called only internally, returns the URL for a tile given its coordinates.
        // Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
        getTileUrl: function(p) {
          var A = {
            r: Ae.retina ? "@2x" : "",
            s: this._getSubdomain(p),
            x: p.x,
            y: p.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var B = this._globalTileRange.max.y - p.y;
            this.options.tms && (A.y = B), A["-y"] = B;
          }
          return lt(this._url, w(A, this.options));
        },
        _tileOnLoad: function(p, A) {
          Ae.ielt9 ? setTimeout(P(p, this, null, A), 0) : p(null, A);
        },
        _tileOnError: function(p, A, B) {
          var X = this.options.errorTileUrl;
          X && A.getAttribute("src") !== X && (A.src = X), p(B, A);
        },
        _onTileRemove: function(p) {
          p.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var p = this._tileZoom, A = this.options.maxZoom, B = this.options.zoomReverse, X = this.options.zoomOffset;
          return B && (p = A - p), p + X;
        },
        _getSubdomain: function(p) {
          var A = Math.abs(p.x + p.y) % this.options.subdomains.length;
          return this.options.subdomains[A];
        },
        // stops loading all tiles in the background layer
        _abortLoading: function() {
          var p, A;
          for (p in this._tiles)
            if (this._tiles[p].coords.z !== this._tileZoom && (A = this._tiles[p].el, A.onload = J, A.onerror = J, !A.complete)) {
              A.src = bt;
              var B = this._tiles[p].coords;
              xn(A), delete this._tiles[p], this.fire("tileabort", {
                tile: A,
                coords: B
              });
            }
        },
        _removeTile: function(p) {
          var A = this._tiles[p];
          if (A)
            return A.el.setAttribute("src", bt), ro.prototype._removeTile.call(this, p);
        },
        _tileReady: function(p, A, B) {
          if (!(!this._map || B && B.getAttribute("src") === bt))
            return ro.prototype._tileReady.call(this, p, A, B);
        }
      });
      function oo(p, A) {
        return new kr(p, A);
      }
      var Ko = kr.extend({
        // @section
        // @aka TileLayer.WMS options
        // If any custom options not documented here are used, they will be sent to the
        // WMS server as extra parameters in each request URL. This can be useful for
        // [non-standard vendor WMS parameters](https://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          // @option layers: String = ''
          // **(required)** Comma-separated list of WMS layers to show.
          layers: "",
          // @option styles: String = ''
          // Comma-separated list of WMS styles.
          styles: "",
          // @option format: String = 'image/jpeg'
          // WMS image format (use `'image/png'` for layers with transparency).
          format: "image/jpeg",
          // @option transparent: Boolean = false
          // If `true`, the WMS service will return images with transparency.
          transparent: !1,
          // @option version: String = '1.1.1'
          // Version of the WMS service to use
          version: "1.1.1"
        },
        options: {
          // @option crs: CRS = null
          // Coordinate Reference System to use for the WMS requests, defaults to
          // map CRS. Don't change this if you're not sure what it means.
          crs: null,
          // @option uppercase: Boolean = false
          // If `true`, WMS request parameter keys will be uppercase.
          uppercase: !1
        },
        initialize: function(p, A) {
          this._url = p;
          var B = w({}, this.defaultWmsParams);
          for (var X in A)
            X in this.options || (B[X] = A[X]);
          A = we(this, A);
          var ne = A.detectRetina && Ae.retina ? 2 : 1, ye = this.getTileSize();
          B.width = ye.x * ne, B.height = ye.y * ne, this.wmsParams = B;
        },
        onAdd: function(p) {
          this._crs = this.options.crs || p.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
          var A = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[A] = this._crs.code, kr.prototype.onAdd.call(this, p);
        },
        getTileUrl: function(p) {
          var A = this._tileCoordsToNwSe(p), B = this._crs, X = an(B.project(A[0]), B.project(A[1])), ne = X.min, ye = X.max, We = (this._wmsVersion >= 1.3 && this._crs === ml ? [ne.y, ne.x, ye.y, ye.x] : [ne.x, ne.y, ye.x, ye.y]).join(","), ot = kr.prototype.getTileUrl.call(this, p);
          return ot + qe(this.wmsParams, ot, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + We;
        },
        // @method setParams(params: Object, noRedraw?: Boolean): this
        // Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
        setParams: function(p, A) {
          return w(this.wmsParams, p), A || this.redraw(), this;
        }
      });
      function Yl(p, A) {
        return new Ko(p, A);
      }
      kr.WMS = Ko, oo.wms = Yl;
      var Qr = ar.extend({
        // @section
        // @aka Renderer options
        options: {
          // @option padding: Number = 0.1
          // How much to extend the clip area around the map view (relative to its size)
          // e.g. 0.1 would be 10% of map view in each direction
          padding: 0.1
        },
        initialize: function(p) {
          we(this, p), O(this), this._layers = this._layers || {};
        },
        onAdd: function() {
          this._container || (this._initContainer(), Vi(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this), this._destroyContainer();
        },
        getEvents: function() {
          var p = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (p.zoomanim = this._onAnimZoom), p;
        },
        _onAnimZoom: function(p) {
          this._updateTransform(p.center, p.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(p, A) {
          var B = this._map.getZoomScale(A, this._zoom), X = this._map.getSize().multiplyBy(0.5 + this.options.padding), ne = this._map.project(this._center, A), ye = X.multiplyBy(-B).add(ne).subtract(this._map._getNewPixelOrigin(p, A));
          Ae.any3d ? Ys(this._container, ye, B) : Yn(this._container, ye);
        },
        _reset: function() {
          this._update(), this._updateTransform(this._center, this._zoom);
          for (var p in this._layers)
            this._layers[p]._reset();
        },
        _onZoomEnd: function() {
          for (var p in this._layers)
            this._layers[p]._project();
        },
        _updatePaths: function() {
          for (var p in this._layers)
            this._layers[p]._update();
        },
        _update: function() {
          var p = this.options.padding, A = this._map.getSize(), B = this._map.containerPointToLayerPoint(A.multiplyBy(-p)).round();
          this._bounds = new Gi(B, B.add(A.multiplyBy(1 + p * 2)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();
        }
      }), yl = Qr.extend({
        // @section
        // @aka Canvas options
        options: {
          // @option tolerance: Number = 0
          // How much to extend the click tolerance around a path/object on the map.
          tolerance: 0
        },
        getEvents: function() {
          var p = Qr.prototype.getEvents.call(this);
          return p.viewprereset = this._onViewPreReset, p;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = !0;
        },
        onAdd: function() {
          Qr.prototype.onAdd.call(this), this._draw();
        },
        _initContainer: function() {
          var p = this._container = document.createElement("canvas");
          Bi(p, "mousemove", this._onMouseMove, this), Bi(p, "click dblclick mousedown mouseup contextmenu", this._onClick, this), Bi(p, "mouseout", this._handleMouseOut, this), p._leaflet_disable_events = !0, this._ctx = p.getContext("2d");
        },
        _destroyContainer: function() {
          Si(this._redrawRequest), delete this._ctx, xn(this._container), Cn(this._container), delete this._container;
        },
        _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
            var p;
            this._redrawBounds = null;
            for (var A in this._layers)
              p = this._layers[A], p._update();
            this._redraw();
          }
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Qr.prototype._update.call(this);
            var p = this._bounds, A = this._container, B = p.getSize(), X = Ae.retina ? 2 : 1;
            Yn(A, p.min), A.width = X * B.x, A.height = X * B.y, A.style.width = B.x + "px", A.style.height = B.y + "px", Ae.retina && this._ctx.scale(2, 2), this._ctx.translate(-p.min.x, -p.min.y), this.fire("update");
          }
        },
        _reset: function() {
          Qr.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());
        },
        _initPath: function(p) {
          this._updateDashArray(p), this._layers[O(p)] = p;
          var A = p._order = {
            layer: p,
            prev: this._drawLast,
            next: null
          };
          this._drawLast && (this._drawLast.next = A), this._drawLast = A, this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(p) {
          this._requestRedraw(p);
        },
        _removePath: function(p) {
          var A = p._order, B = A.next, X = A.prev;
          B ? B.prev = X : this._drawLast = X, X ? X.next = B : this._drawFirst = B, delete p._order, delete this._layers[O(p)], this._requestRedraw(p);
        },
        _updatePath: function(p) {
          this._extendRedrawBounds(p), p._project(), p._update(), this._requestRedraw(p);
        },
        _updateStyle: function(p) {
          this._updateDashArray(p), this._requestRedraw(p);
        },
        _updateDashArray: function(p) {
          if (typeof p.options.dashArray == "string") {
            var A = p.options.dashArray.split(/[, ]+/), B = [], X, ne;
            for (ne = 0; ne < A.length; ne++) {
              if (X = Number(A[ne]), isNaN(X))
                return;
              B.push(X);
            }
            p.options._dashArray = B;
          } else
            p.options._dashArray = p.options.dashArray;
        },
        _requestRedraw: function(p) {
          this._map && (this._extendRedrawBounds(p), this._redrawRequest = this._redrawRequest || At(this._redraw, this));
        },
        _extendRedrawBounds: function(p) {
          if (p._pxBounds) {
            var A = (p.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Gi(), this._redrawBounds.extend(p._pxBounds.min.subtract([A, A])), this._redrawBounds.extend(p._pxBounds.max.add([A, A]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
        },
        _clear: function() {
          var p = this._redrawBounds;
          if (p) {
            var A = p.getSize();
            this._ctx.clearRect(p.min.x, p.min.y, A.x, A.y);
          } else
            this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore();
        },
        _draw: function() {
          var p, A = this._redrawBounds;
          if (this._ctx.save(), A) {
            var B = A.getSize();
            this._ctx.beginPath(), this._ctx.rect(A.min.x, A.min.y, B.x, B.y), this._ctx.clip();
          }
          this._drawing = !0;
          for (var X = this._drawFirst; X; X = X.next)
            p = X.layer, (!A || p._pxBounds && p._pxBounds.intersects(A)) && p._updatePath();
          this._drawing = !1, this._ctx.restore();
        },
        _updatePoly: function(p, A) {
          if (this._drawing) {
            var B, X, ne, ye, We = p._parts, ot = We.length, ft = this._ctx;
            if (ot) {
              for (ft.beginPath(), B = 0; B < ot; B++) {
                for (X = 0, ne = We[B].length; X < ne; X++)
                  ye = We[B][X], ft[X ? "lineTo" : "moveTo"](ye.x, ye.y);
                A && ft.closePath();
              }
              this._fillStroke(ft, p);
            }
          }
        },
        _updateCircle: function(p) {
          if (!(!this._drawing || p._empty())) {
            var A = p._point, B = this._ctx, X = Math.max(Math.round(p._radius), 1), ne = (Math.max(Math.round(p._radiusY), 1) || X) / X;
            ne !== 1 && (B.save(), B.scale(1, ne)), B.beginPath(), B.arc(A.x, A.y / ne, X, 0, Math.PI * 2, !1), ne !== 1 && B.restore(), this._fillStroke(B, p);
          }
        },
        _fillStroke: function(p, A) {
          var B = A.options;
          B.fill && (p.globalAlpha = B.fillOpacity, p.fillStyle = B.fillColor || B.color, p.fill(B.fillRule || "evenodd")), B.stroke && B.weight !== 0 && (p.setLineDash && p.setLineDash(A.options && A.options._dashArray || []), p.globalAlpha = B.opacity, p.lineWidth = B.weight, p.strokeStyle = B.color, p.lineCap = B.lineCap, p.lineJoin = B.lineJoin, p.stroke());
        },
        // Canvas obviously doesn't have mouse events for individual drawn objects,
        // so we emulate that by calculating what's under the mouse on mousemove/click manually
        _onClick: function(p) {
          for (var A = this._map.mouseEventToLayerPoint(p), B, X, ne = this._drawFirst; ne; ne = ne.next)
            B = ne.layer, B.options.interactive && B._containsPoint(A) && (!(p.type === "click" || p.type === "preclick") || !this._map._draggableMoved(B)) && (X = B);
          this._fireEvent(X ? [X] : !1, p);
        },
        _onMouseMove: function(p) {
          if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
            var A = this._map.mouseEventToLayerPoint(p);
            this._handleMouseHover(p, A);
          }
        },
        _handleMouseOut: function(p) {
          var A = this._hoveredLayer;
          A && (Hn(this._container, "leaflet-interactive"), this._fireEvent([A], p, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1);
        },
        _handleMouseHover: function(p, A) {
          if (!this._mouseHoverThrottled) {
            for (var B, X, ne = this._drawFirst; ne; ne = ne.next)
              B = ne.layer, B.options.interactive && B._containsPoint(A) && (X = B);
            X !== this._hoveredLayer && (this._handleMouseOut(p), X && (Vi(this._container, "leaflet-interactive"), this._fireEvent([X], p, "mouseover"), this._hoveredLayer = X)), this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, p), this._mouseHoverThrottled = !0, setTimeout(P(function() {
              this._mouseHoverThrottled = !1;
            }, this), 32);
          }
        },
        _fireEvent: function(p, A, B) {
          this._map._fireDOMEvent(A, B || A.type, p);
        },
        _bringToFront: function(p) {
          var A = p._order;
          if (A) {
            var B = A.next, X = A.prev;
            if (B)
              B.prev = X;
            else
              return;
            X ? X.next = B : B && (this._drawFirst = B), A.prev = this._drawLast, this._drawLast.next = A, A.next = null, this._drawLast = A, this._requestRedraw(p);
          }
        },
        _bringToBack: function(p) {
          var A = p._order;
          if (A) {
            var B = A.next, X = A.prev;
            if (X)
              X.next = B;
            else
              return;
            B ? B.prev = X : X && (this._drawLast = X), A.prev = null, A.next = this._drawFirst, this._drawFirst.prev = A, this._drawFirst = A, this._requestRedraw(p);
          }
        }
      });
      function ao(p) {
        return Ae.canvas ? new yl(p) : null;
      }
      var Ti = function() {
        try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(p) {
            return document.createElement("<lvml:" + p + ' class="lvml">');
          };
        } catch {
        }
        return function(p) {
          return document.createElement("<" + p + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }(), Zh = {
        _initContainer: function() {
          this._container = tn("div", "leaflet-vml-container");
        },
        _update: function() {
          this._map._animatingZoom || (Qr.prototype._update.call(this), this.fire("update"));
        },
        _initPath: function(p) {
          var A = p._container = Ti("shape");
          Vi(A, "leaflet-vml-shape " + (this.options.className || "")), A.coordsize = "1 1", p._path = Ti("path"), A.appendChild(p._path), this._updateStyle(p), this._layers[O(p)] = p;
        },
        _addPath: function(p) {
          var A = p._container;
          this._container.appendChild(A), p.options.interactive && p.addInteractiveTarget(A);
        },
        _removePath: function(p) {
          var A = p._container;
          xn(A), p.removeInteractiveTarget(A), delete this._layers[O(p)];
        },
        _updateStyle: function(p) {
          var A = p._stroke, B = p._fill, X = p.options, ne = p._container;
          ne.stroked = !!X.stroke, ne.filled = !!X.fill, X.stroke ? (A || (A = p._stroke = Ti("stroke")), ne.appendChild(A), A.weight = X.weight + "px", A.color = X.color, A.opacity = X.opacity, X.dashArray ? A.dashStyle = Et(X.dashArray) ? X.dashArray.join(" ") : X.dashArray.replace(/( *, *)/g, " ") : A.dashStyle = "", A.endcap = X.lineCap.replace("butt", "flat"), A.joinstyle = X.lineJoin) : A && (ne.removeChild(A), p._stroke = null), X.fill ? (B || (B = p._fill = Ti("fill")), ne.appendChild(B), B.color = X.fillColor || X.color, B.opacity = X.fillOpacity) : B && (ne.removeChild(B), p._fill = null);
        },
        _updateCircle: function(p) {
          var A = p._point.round(), B = Math.round(p._radius), X = Math.round(p._radiusY || B);
          this._setPath(p, p._empty() ? "M0 0" : "AL " + A.x + "," + A.y + " " + B + "," + X + " 0," + 65535 * 360);
        },
        _setPath: function(p, A) {
          p._path.v = A;
        },
        _bringToFront: function(p) {
          jo(p._container);
        },
        _bringToBack: function(p) {
          oa(p._container);
        }
      }, xl = Ae.vml ? Ti : ir, Ua = Qr.extend({
        _initContainer: function() {
          this._container = xl("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = xl("g"), this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          xn(this._container), Cn(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;
        },
        _update: function() {
          if (!(this._map._animatingZoom && this._bounds)) {
            Qr.prototype._update.call(this);
            var p = this._bounds, A = p.getSize(), B = this._container;
            (!this._svgSize || !this._svgSize.equals(A)) && (this._svgSize = A, B.setAttribute("width", A.x), B.setAttribute("height", A.y)), Yn(B, p.min), B.setAttribute("viewBox", [p.min.x, p.min.y, A.x, A.y].join(" ")), this.fire("update");
          }
        },
        // methods below are called by vector layers implementations
        _initPath: function(p) {
          var A = p._path = xl("path");
          p.options.className && Vi(A, p.options.className), p.options.interactive && Vi(A, "leaflet-interactive"), this._updateStyle(p), this._layers[O(p)] = p;
        },
        _addPath: function(p) {
          this._rootGroup || this._initContainer(), this._rootGroup.appendChild(p._path), p.addInteractiveTarget(p._path);
        },
        _removePath: function(p) {
          xn(p._path), p.removeInteractiveTarget(p._path), delete this._layers[O(p)];
        },
        _updatePath: function(p) {
          p._project(), p._update();
        },
        _updateStyle: function(p) {
          var A = p._path, B = p.options;
          A && (B.stroke ? (A.setAttribute("stroke", B.color), A.setAttribute("stroke-opacity", B.opacity), A.setAttribute("stroke-width", B.weight), A.setAttribute("stroke-linecap", B.lineCap), A.setAttribute("stroke-linejoin", B.lineJoin), B.dashArray ? A.setAttribute("stroke-dasharray", B.dashArray) : A.removeAttribute("stroke-dasharray"), B.dashOffset ? A.setAttribute("stroke-dashoffset", B.dashOffset) : A.removeAttribute("stroke-dashoffset")) : A.setAttribute("stroke", "none"), B.fill ? (A.setAttribute("fill", B.fillColor || B.color), A.setAttribute("fill-opacity", B.fillOpacity), A.setAttribute("fill-rule", B.fillRule || "evenodd")) : A.setAttribute("fill", "none"));
        },
        _updatePoly: function(p, A) {
          this._setPath(p, $n(p._parts, A));
        },
        _updateCircle: function(p) {
          var A = p._point, B = Math.max(Math.round(p._radius), 1), X = Math.max(Math.round(p._radiusY), 1) || B, ne = "a" + B + "," + X + " 0 1,0 ", ye = p._empty() ? "M0 0" : "M" + (A.x - B) + "," + A.y + ne + B * 2 + ",0 " + ne + -B * 2 + ",0 ";
          this._setPath(p, ye);
        },
        _setPath: function(p, A) {
          p._path.setAttribute("d", A);
        },
        // SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
        _bringToFront: function(p) {
          jo(p._path);
        },
        _bringToBack: function(p) {
          oa(p._path);
        }
      });
      Ae.vml && Ua.include(Zh);
      function Jo(p) {
        return Ae.svg || Ae.vml ? new Ua(p) : null;
      }
      nn.include({
        // @namespace Map; @method getRenderer(layer: Path): Renderer
        // Returns the instance of `Renderer` that should be used to render the given
        // `Path`. It will ensure that the `renderer` options of the map and paths
        // are respected, and that the renderers do exist on the map.
        getRenderer: function(p) {
          var A = p.options.renderer || this._getPaneRenderer(p.options.pane) || this.options.renderer || this._renderer;
          return A || (A = this._renderer = this._createRenderer()), this.hasLayer(A) || this.addLayer(A), A;
        },
        _getPaneRenderer: function(p) {
          if (p === "overlayPane" || p === void 0)
            return !1;
          var A = this._paneRenderers[p];
          return A === void 0 && (A = this._createRenderer({ pane: p }), this._paneRenderers[p] = A), A;
        },
        _createRenderer: function(p) {
          return this.options.preferCanvas && ao(p) || Jo(p);
        }
      });
      var Gc = Kr.extend({
        initialize: function(p, A) {
          Kr.prototype.initialize.call(this, this._boundsToLatLngs(p), A);
        },
        // @method setBounds(latLngBounds: LatLngBounds): this
        // Redraws the rectangle with the passed bounds.
        setBounds: function(p) {
          return this.setLatLngs(this._boundsToLatLngs(p));
        },
        _boundsToLatLngs: function(p) {
          return p = ln(p), [
            p.getSouthWest(),
            p.getNorthWest(),
            p.getNorthEast(),
            p.getSouthEast()
          ];
        }
      });
      function gn(p, A) {
        return new Gc(p, A);
      }
      Ua.create = xl, Ua.pointsToPath = $n, cr.geometryToLayer = Mo, cr.coordsToLatLng = Bc, cr.coordsToLatLngs = Na, cr.latLngToCoords = ql, cr.latLngsToCoords = _l, cr.getFeature = ma, cr.asFeature = _a, nn.mergeOptions({
        // @option boxZoom: Boolean = true
        // Whether the map can be zoomed to a rectangular area specified by
        // dragging the mouse while pressing the shift key.
        boxZoom: !0
      });
      var Hh = Es.extend({
        initialize: function(p) {
          this._map = p, this._container = p._container, this._pane = p._panes.overlayPane, this._resetStateTimeout = 0, p.on("unload", this._destroy, this);
        },
        addHooks: function() {
          Bi(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          Cn(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          xn(this._pane), delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0, this._moved = !1;
        },
        _clearDeferredResetState: function() {
          this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
        },
        _onMouseDown: function(p) {
          if (!p.shiftKey || p.which !== 1 && p.button !== 1)
            return !1;
          this._clearDeferredResetState(), this._resetState(), Pr(), Go(), this._startPoint = this._map.mouseEventToContainerPoint(p), Bi(document, {
            contextmenu: Ks,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(p) {
          this._moved || (this._moved = !0, this._box = tn("div", "leaflet-zoom-box", this._container), Vi(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(p);
          var A = new Gi(this._point, this._startPoint), B = A.getSize();
          Yn(this._box, A.min), this._box.style.width = B.x + "px", this._box.style.height = B.y + "px";
        },
        _finish: function() {
          this._moved && (xn(this._box), Hn(this._container, "leaflet-crosshair")), Cr(), sr(), Cn(document, {
            contextmenu: Ks,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(p) {
          if (!(p.which !== 1 && p.button !== 1) && (this._finish(), !!this._moved)) {
            this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(P(this._resetState, this), 0);
            var A = new qt(
              this._map.containerPointToLatLng(this._startPoint),
              this._map.containerPointToLatLng(this._point)
            );
            this._map.fitBounds(A).fire("boxzoomend", { boxZoomBounds: A });
          }
        },
        _onKeyDown: function(p) {
          p.keyCode === 27 && (this._finish(), this._clearDeferredResetState(), this._resetState());
        }
      });
      nn.addInitHook("addHandler", "boxZoom", Hh), nn.mergeOptions({
        // @option doubleClickZoom: Boolean|String = true
        // Whether the map can be zoomed in by double clicking on it and
        // zoomed out by double clicking while holding shift. If passed
        // `'center'`, double-click zoom will zoom to the center of the
        //  view regardless of where the mouse was.
        doubleClickZoom: !0
      });
      var qh = Es.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(p) {
          var A = this._map, B = A.getZoom(), X = A.options.zoomDelta, ne = p.originalEvent.shiftKey ? B - X : B + X;
          A.options.doubleClickZoom === "center" ? A.setZoom(ne) : A.setZoomAround(p.containerPoint, ne);
        }
      });
      nn.addInitHook("addHandler", "doubleClickZoom", qh), nn.mergeOptions({
        // @option dragging: Boolean = true
        // Whether the map is draggable with mouse/touch or not.
        dragging: !0,
        // @section Panning Inertia Options
        // @option inertia: Boolean = *
        // If enabled, panning of the map will have an inertia effect where
        // the map builds momentum while dragging and continues moving in
        // the same direction for some time. Feels especially nice on touch
        // devices. Enabled by default.
        inertia: !0,
        // @option inertiaDeceleration: Number = 3000
        // The rate with which the inertial movement slows down, in pixels/second².
        inertiaDeceleration: 3400,
        // px/s^2
        // @option inertiaMaxSpeed: Number = Infinity
        // Max speed of the inertial movement, in pixels/second.
        inertiaMaxSpeed: 1 / 0,
        // px/s
        // @option easeLinearity: Number = 0.2
        easeLinearity: 0.2,
        // TODO refactor, move to CRS
        // @option worldCopyJump: Boolean = false
        // With this option enabled, the map tracks when you pan to another "copy"
        // of the world and seamlessly jumps to the original one so that all overlays
        // like markers and vector layers are still visible.
        worldCopyJump: !1,
        // @option maxBoundsViscosity: Number = 0.0
        // If `maxBounds` is set, this option will control how solid the bounds
        // are when dragging the map around. The default value of `0.0` allows the
        // user to drag outside the bounds at normal speed, higher values will
        // slow down map dragging outside bounds, and `1.0` makes the bounds fully
        // solid, preventing the user from dragging outside the bounds.
        maxBoundsViscosity: 0
      });
      var Kl = Es.extend({
        addHooks: function() {
          if (!this._draggable) {
            var p = this._map;
            this._draggable = new qo(p._mapPane, p._container), this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this), this._draggable.on("predrag", this._onPreDragLimit, this), p.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), p.on("zoomend", this._onZoomEnd, this), p.whenReady(this._onZoomEnd, this));
          }
          Vi(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [];
        },
        removeHooks: function() {
          Hn(this._map._container, "leaflet-grab"), Hn(this._map._container, "leaflet-touch-drag"), this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var p = this._map;
          if (p._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var A = ln(this._map.options.maxBounds);
            this._offsetLimit = an(
              this._map.latLngToContainerPoint(A.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(A.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            ), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else
            this._offsetLimit = null;
          p.fire("movestart").fire("dragstart"), p.options.inertia && (this._positions = [], this._times = []);
        },
        _onDrag: function(p) {
          if (this._map.options.inertia) {
            var A = this._lastTime = +/* @__PURE__ */ new Date(), B = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(B), this._times.push(A), this._prunePositions(A);
          }
          this._map.fire("move", p).fire("drag", p);
        },
        _prunePositions: function(p) {
          for (; this._positions.length > 1 && p - this._times[0] > 50; )
            this._positions.shift(), this._times.shift();
        },
        _onZoomEnd: function() {
          var p = this._map.getSize().divideBy(2), A = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = A.subtract(p).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(p, A) {
          return p - (p - A) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!(!this._viscosity || !this._offsetLimit)) {
            var p = this._draggable._newPos.subtract(this._draggable._startPos), A = this._offsetLimit;
            p.x < A.min.x && (p.x = this._viscousLimit(p.x, A.min.x)), p.y < A.min.y && (p.y = this._viscousLimit(p.y, A.min.y)), p.x > A.max.x && (p.x = this._viscousLimit(p.x, A.max.x)), p.y > A.max.y && (p.y = this._viscousLimit(p.y, A.max.y)), this._draggable._newPos = this._draggable._startPos.add(p);
          }
        },
        _onPreDragWrap: function() {
          var p = this._worldWidth, A = Math.round(p / 2), B = this._initialWorldOffset, X = this._draggable._newPos.x, ne = (X - A + B) % p + A - B, ye = (X + A + B) % p - A - B, We = Math.abs(ne + B) < Math.abs(ye + B) ? ne : ye;
          this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = We;
        },
        _onDragEnd: function(p) {
          var A = this._map, B = A.options, X = !B.inertia || p.noInertia || this._times.length < 2;
          if (A.fire("dragend", p), X)
            A.fire("moveend");
          else {
            this._prunePositions(+/* @__PURE__ */ new Date());
            var ne = this._lastPos.subtract(this._positions[0]), ye = (this._lastTime - this._times[0]) / 1e3, We = B.easeLinearity, ot = ne.multiplyBy(We / ye), ft = ot.distanceTo([0, 0]), Rt = Math.min(B.inertiaMaxSpeed, ft), ii = ot.multiplyBy(Rt / ft), Ci = Rt / (B.inertiaDeceleration * We), Wi = ii.multiplyBy(-Ci / 2).round();
            !Wi.x && !Wi.y ? A.fire("moveend") : (Wi = A._limitOffset(Wi, A.options.maxBounds), At(function() {
              A.panBy(Wi, {
                duration: Ci,
                easeLinearity: We,
                noMoveStart: !0,
                animate: !0
              });
            }));
          }
        }
      });
      nn.addInitHook("addHandler", "dragging", Kl), nn.mergeOptions({
        // @option keyboard: Boolean = true
        // Makes the map focusable and allows users to navigate the map with keyboard
        // arrows and `+`/`-` keys.
        keyboard: !0,
        // @option keyboardPanDelta: Number = 80
        // Amount of pixels to pan when pressing an arrow key.
        keyboardPanDelta: 80
      });
      var Jl = Es.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(p) {
          this._map = p, this._setPanDelta(p.options.keyboardPanDelta), this._setZoomDelta(p.options.zoomDelta);
        },
        addHooks: function() {
          var p = this._map._container;
          p.tabIndex <= 0 && (p.tabIndex = "0"), Bi(p, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks(), Cn(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this), this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (!this._focused) {
            var p = document.body, A = document.documentElement, B = p.scrollTop || A.scrollTop, X = p.scrollLeft || A.scrollLeft;
            this._map._container.focus(), window.scrollTo(X, B);
          }
        },
        _onFocus: function() {
          this._focused = !0, this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = !1, this._map.fire("blur");
        },
        _setPanDelta: function(p) {
          var A = this._panKeys = {}, B = this.keyCodes, X, ne;
          for (X = 0, ne = B.left.length; X < ne; X++)
            A[B.left[X]] = [-1 * p, 0];
          for (X = 0, ne = B.right.length; X < ne; X++)
            A[B.right[X]] = [p, 0];
          for (X = 0, ne = B.down.length; X < ne; X++)
            A[B.down[X]] = [0, p];
          for (X = 0, ne = B.up.length; X < ne; X++)
            A[B.up[X]] = [0, -1 * p];
        },
        _setZoomDelta: function(p) {
          var A = this._zoomKeys = {}, B = this.keyCodes, X, ne;
          for (X = 0, ne = B.zoomIn.length; X < ne; X++)
            A[B.zoomIn[X]] = p;
          for (X = 0, ne = B.zoomOut.length; X < ne; X++)
            A[B.zoomOut[X]] = -p;
        },
        _addHooks: function() {
          Bi(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          Cn(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(p) {
          if (!(p.altKey || p.ctrlKey || p.metaKey)) {
            var A = p.keyCode, B = this._map, X;
            if (A in this._panKeys) {
              if (!B._panAnim || !B._panAnim._inProgress)
                if (X = this._panKeys[A], p.shiftKey && (X = ni(X).multiplyBy(3)), B.options.maxBounds && (X = B._limitOffset(ni(X), B.options.maxBounds)), B.options.worldCopyJump) {
                  var ne = B.wrapLatLng(B.unproject(B.project(B.getCenter()).add(X)));
                  B.panTo(ne);
                } else
                  B.panBy(X);
            } else if (A in this._zoomKeys)
              B.setZoom(B.getZoom() + (p.shiftKey ? 3 : 1) * this._zoomKeys[A]);
            else if (A === 27 && B._popup && B._popup.options.closeOnEscapeKey)
              B.closePopup();
            else
              return;
            Ks(p);
          }
        }
      });
      nn.addInitHook("addHandler", "keyboard", Jl), nn.mergeOptions({
        // @section Mouse wheel options
        // @option scrollWheelZoom: Boolean|String = true
        // Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
        // it will zoom to the center of the view regardless of where the mouse was.
        scrollWheelZoom: !0,
        // @option wheelDebounceTime: Number = 40
        // Limits the rate at which a wheel can fire (in milliseconds). By default
        // user can't zoom via wheel more often than once per 40 ms.
        wheelDebounceTime: 40,
        // @option wheelPxPerZoomLevel: Number = 60
        // How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
        // mean a change of one full zoom level. Smaller values will make wheel-zooming
        // faster (and vice versa).
        wheelPxPerZoomLevel: 60
      });
      var Ql = Es.extend({
        addHooks: function() {
          Bi(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
        },
        removeHooks: function() {
          Cn(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(p) {
          var A = Rc(p), B = this._map.options.wheelDebounceTime;
          this._delta += A, this._lastMousePos = this._map.mouseEventToContainerPoint(p), this._startTime || (this._startTime = +/* @__PURE__ */ new Date());
          var X = Math.max(B - (+/* @__PURE__ */ new Date() - this._startTime), 0);
          clearTimeout(this._timer), this._timer = setTimeout(P(this._performZoom, this), X), Ks(p);
        },
        _performZoom: function() {
          var p = this._map, A = p.getZoom(), B = this._map.options.zoomSnap || 0;
          p._stop();
          var X = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), ne = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(X)))) / Math.LN2, ye = B ? Math.ceil(ne / B) * B : ne, We = p._limitZoom(A + (this._delta > 0 ? ye : -ye)) - A;
          this._delta = 0, this._startTime = null, We && (p.options.scrollWheelZoom === "center" ? p.setZoom(A + We) : p.setZoomAround(this._lastMousePos, A + We));
        }
      });
      nn.addInitHook("addHandler", "scrollWheelZoom", Ql);
      var Zc = 600;
      nn.mergeOptions({
        // @section Touch interaction options
        // @option tapHold: Boolean
        // Enables simulation of `contextmenu` event, default is `true` for mobile Safari.
        tapHold: Ae.touchNative && Ae.safari && Ae.mobile,
        // @option tapTolerance: Number = 15
        // The max number of pixels a user can shift his finger during touch
        // for it to be considered a valid tap.
        tapTolerance: 15
      });
      var Hc = Es.extend({
        addHooks: function() {
          Bi(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          Cn(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(p) {
          if (clearTimeout(this._holdTimeout), p.touches.length === 1) {
            var A = p.touches[0];
            this._startPos = this._newPos = new fi(A.clientX, A.clientY), this._holdTimeout = setTimeout(P(function() {
              this._cancel(), this._isTapValid() && (Bi(document, "touchend", _s), Bi(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", A));
            }, this), Zc), Bi(document, "touchend touchcancel contextmenu", this._cancel, this), Bi(document, "touchmove", this._onMove, this);
          }
        },
        _cancelClickPrevent: function p() {
          Cn(document, "touchend", _s), Cn(document, "touchend touchcancel", p);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout), Cn(document, "touchend touchcancel contextmenu", this._cancel, this), Cn(document, "touchmove", this._onMove, this);
        },
        _onMove: function(p) {
          var A = p.touches[0];
          this._newPos = new fi(A.clientX, A.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(p, A) {
          var B = new MouseEvent(p, {
            bubbles: !0,
            cancelable: !0,
            view: window,
            // detail: 1,
            screenX: A.screenX,
            screenY: A.screenY,
            clientX: A.clientX,
            clientY: A.clientY
            // button: 2,
            // buttons: 2
          });
          B._simulated = !0, A.target.dispatchEvent(B);
        }
      });
      nn.addInitHook("addHandler", "tapHold", Hc), nn.mergeOptions({
        // @section Touch interaction options
        // @option touchZoom: Boolean|String = *
        // Whether the map can be zoomed by touch-dragging with two fingers. If
        // passed `'center'`, it will zoom to the center of the view regardless of
        // where the touch events (fingers) were. Enabled for touch-capable web
        // browsers.
        touchZoom: Ae.touch,
        // @option bounceAtZoomLimits: Boolean = true
        // Set it to false if you don't want the map to zoom beyond min/max zoom
        // and then bounce back when pinch-zooming.
        bounceAtZoomLimits: !0
      });
      var qc = Es.extend({
        addHooks: function() {
          Vi(this._map._container, "leaflet-touch-zoom"), Bi(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          Hn(this._map._container, "leaflet-touch-zoom"), Cn(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(p) {
          var A = this._map;
          if (!(!p.touches || p.touches.length !== 2 || A._animatingZoom || this._zooming)) {
            var B = A.mouseEventToContainerPoint(p.touches[0]), X = A.mouseEventToContainerPoint(p.touches[1]);
            this._centerPoint = A.getSize()._divideBy(2), this._startLatLng = A.containerPointToLatLng(this._centerPoint), A.options.touchZoom !== "center" && (this._pinchStartLatLng = A.containerPointToLatLng(B.add(X)._divideBy(2))), this._startDist = B.distanceTo(X), this._startZoom = A.getZoom(), this._moved = !1, this._zooming = !0, A._stop(), Bi(document, "touchmove", this._onTouchMove, this), Bi(document, "touchend touchcancel", this._onTouchEnd, this), _s(p);
          }
        },
        _onTouchMove: function(p) {
          if (!(!p.touches || p.touches.length !== 2 || !this._zooming)) {
            var A = this._map, B = A.mouseEventToContainerPoint(p.touches[0]), X = A.mouseEventToContainerPoint(p.touches[1]), ne = B.distanceTo(X) / this._startDist;
            if (this._zoom = A.getScaleZoom(ne, this._startZoom), !A.options.bounceAtZoomLimits && (this._zoom < A.getMinZoom() && ne < 1 || this._zoom > A.getMaxZoom() && ne > 1) && (this._zoom = A._limitZoom(this._zoom)), A.options.touchZoom === "center") {
              if (this._center = this._startLatLng, ne === 1)
                return;
            } else {
              var ye = B._add(X)._divideBy(2)._subtract(this._centerPoint);
              if (ne === 1 && ye.x === 0 && ye.y === 0)
                return;
              this._center = A.unproject(A.project(this._pinchStartLatLng, this._zoom).subtract(ye), this._zoom);
            }
            this._moved || (A._moveStart(!0, !1), this._moved = !0), Si(this._animRequest);
            var We = P(A._move, A, this._center, this._zoom, { pinch: !0, round: !1 }, void 0);
            this._animRequest = At(We, this, !0), _s(p);
          }
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = !1;
            return;
          }
          this._zooming = !1, Si(this._animRequest), Cn(document, "touchmove", this._onTouchMove, this), Cn(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom));
        }
      });
      nn.addInitHook("addHandler", "touchZoom", qc), nn.BoxZoom = Hh, nn.DoubleClickZoom = qh, nn.Drag = Kl, nn.Keyboard = Jl, nn.ScrollWheelZoom = Ql, nn.TapHold = Hc, nn.TouchZoom = qc, f.Bounds = Gi, f.Browser = Ae, f.CRS = Cs, f.Canvas = yl, f.Circle = gs, f.CircleMarker = pa, f.Class = hn, f.Control = Dn, f.DivIcon = Xl, f.DivOverlay = xr, f.DomEvent = jl, f.DomUtil = Oi, f.Draggable = qo, f.Evented = Ji, f.FeatureGroup = Xr, f.GeoJSON = cr, f.GridLayer = ro, f.Handler = Es, f.Icon = Yr, f.ImageOverlay = Va, f.LatLng = Di, f.LatLngBounds = qt, f.Layer = ar, f.LayerGroup = lr, f.LineUtil = Ku, f.Map = nn, f.Marker = ks, f.Mixin = ka, f.Path = wt, f.Point = fi, f.PolyUtil = or, f.Polygon = Kr, f.Polyline = Dr, f.Popup = Yo, f.PosAnimation = ua, f.Projection = bi, f.Rectangle = Gc, f.Renderer = Qr, f.SVG = Ua, f.SVGOverlay = Uc, f.TileLayer = kr, f.Tooltip = Jr, f.Transformation = Vs, f.Util = An, f.VideoOverlay = Vc, f.bind = P, f.bounds = an, f.canvas = ao, f.circle = Uh, f.circleMarker = To, f.control = rr, f.divIcon = ga, f.extend = w, f.featureGroup = Zl, f.geoJSON = Gh, f.geoJson = Ju, f.gridLayer = gl, f.icon = Ba, f.imageOverlay = Nc, f.latLng = xi, f.latLngBounds = ln, f.layerGroup = ti, f.map = hl, f.marker = Hl, f.point = ni, f.polygon = Xo, f.polyline = So, f.popup = Wl, f.rectangle = gn, f.setOptions = we, f.stamp = O, f.svg = Jo, f.svgOverlay = jc, f.tileLayer = oo, f.tooltip = $l, f.transformation = Us, f.version = y, f.videoOverlay = hr;
      var Qu = window.L;
      f.noConflict = function() {
        return window.L = Qu, this;
      }, window.L = f;
    });
  }(vm, vm.exports)), vm.exports;
}
var uC = aw();
const wn = /* @__PURE__ */ ow(uC);
var dC = { exports: {} };
(function(_) {
  (function(a, f) {
    _.exports ? _.exports = f(aw()) : f(a.L);
  })(typeof self < "u" ? self : Hm, (a) => {
    if (typeof document > "u")
      return console.warn('"window.document" is undefined; leaflet.fullscreen requires this object to access the DOM'), !1;
    const f = (() => {
      const b = [
        // Standard
        [
          "requestFullscreen",
          "exitFullscreen",
          "fullscreenElement",
          "fullscreenEnabled",
          "fullscreenchange",
          "fullscreenerror"
        ],
        // New WebKit
        [
          "webkitRequestFullscreen",
          "webkitExitFullscreen",
          "webkitFullscreenElement",
          "webkitFullscreenEnabled",
          "webkitfullscreenchange",
          "webkitfullscreenerror"
        ]
      ], P = b[0], i = {};
      for (const O of b)
        if (O[1] in document) {
          for (let Z = 0; Z < O.length; Z++)
            i[P[Z]] = O[Z];
          return i;
        }
      return !1;
    })(), y = {
      change: f.fullscreenchange,
      error: f.fullscreenerror
    }, w = {
      request(b, P) {
        return new Promise((i, O) => {
          const Z = (function() {
            this.off("change", Z), i();
          }).bind(this);
          this.on("change", Z), b = b || document.documentElement;
          const Y = b[f.requestFullscreen](P);
          Y instanceof Promise && Y.then(Z).catch(O);
        });
      },
      exit() {
        return new Promise((b, P) => {
          if (!this.isFullscreen) {
            b();
            return;
          }
          const i = (function() {
            this.off("change", i), b();
          }).bind(this);
          this.on("change", i);
          const O = document[f.exitFullscreen]();
          O instanceof Promise && O.then(i).catch(P);
        });
      },
      on(b, P) {
        const i = y[b];
        i && document.addEventListener(i, P, !1);
      },
      off(b, P) {
        const i = y[b];
        i && document.removeEventListener(i, P, !1);
      },
      nativeAPI: f
    };
    return Object.defineProperties(w, {
      isFullscreen: {
        get() {
          return !!document[f.fullscreenElement];
        }
      },
      isEnabled: {
        enumerable: !0,
        get() {
          return !!document[f.fullscreenEnabled];
        }
      }
    }), a.Control.FullScreen = a.Control.extend({
      options: {
        position: "topleft",
        title: "Full Screen",
        titleCancel: "Exit Full Screen",
        forceSeparateButton: !1,
        forcePseudoFullscreen: !1,
        fullscreenElement: !1
      },
      _screenfull: w,
      onAdd(b) {
        let P = "leaflet-control-zoom-fullscreen", i, O = "";
        return b.zoomControl && !this.options.forceSeparateButton ? i = b.zoomControl._container : i = a.DomUtil.create("div", "leaflet-bar"), this.options.content ? O = this.options.content : P += " fullscreen-icon", this._createButton(this.options.title, P, O, i, this.toggleFullScreen, this), this._map.fullscreenControl = this, this._map.on("enterFullscreen exitFullscreen", this._toggleState, this), i;
      },
      onRemove() {
        a.DomEvent.off(this.link, "click", a.DomEvent.stop).off(this.link, "click", this.toggleFullScreen, this), this._screenfull.isEnabled && (a.DomEvent.off(this._container, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).off(this._container, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this), a.DomEvent.off(document, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).off(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this));
      },
      _createButton(b, P, i, O, Z, Y) {
        return this.link = a.DomUtil.create("a", P, O), this.link.href = "#", this.link.title = b, this.link.innerHTML = i, this.link.setAttribute("role", "button"), this.link.setAttribute("aria-label", b), L.DomEvent.disableClickPropagation(O), a.DomEvent.on(this.link, "click", a.DomEvent.stop).on(this.link, "click", Z, Y), this._screenfull.isEnabled && (a.DomEvent.on(O, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).on(O, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, Y), a.DomEvent.on(document, this._screenfull.nativeAPI.fullscreenchange, a.DomEvent.stop).on(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, Y)), this.link;
      },
      toggleFullScreen() {
        const b = this._map;
        b._exitFired = !1, b._isFullscreen ? (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.exit().then(() => b.invalidateSize()) : (a.DomUtil.removeClass(this.options.fullscreenElement ? this.options.fullscreenElement : b._container, "leaflet-pseudo-fullscreen"), b.invalidateSize()), b.fire("exitFullscreen"), b._exitFired = !0, b._isFullscreen = !1) : (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.request(this.options.fullscreenElement ? this.options.fullscreenElement : b._container).then(() => b.invalidateSize()) : (a.DomUtil.addClass(this.options.fullscreenElement ? this.options.fullscreenElement : b._container, "leaflet-pseudo-fullscreen"), b.invalidateSize()), b.fire("enterFullscreen"), b._isFullscreen = !0);
      },
      _toggleState() {
        this.link.title = this._map._isFullscreen ? this.options.title : this.options.titleCancel, this._map._isFullscreen ? L.DomUtil.removeClass(this.link, "leaflet-fullscreen-on") : L.DomUtil.addClass(this.link, "leaflet-fullscreen-on");
      },
      _handleFullscreenChange(b) {
        const P = this._map;
        b.target === P.getContainer() && !this._screenfull.isFullscreen && !P._exitFired && (this._screenfull.exit().then(() => P.invalidateSize()), P.fire("exitFullscreen"), P._exitFired = !0, P._isFullscreen = !1);
      }
    }), a.Map.include({
      toggleFullscreen() {
        this.fullscreenControl.toggleFullScreen();
      }
    }), a.Map.addInitHook(function() {
      this.options.fullscreenControl && this.addControl(a.control.fullscreen(this.options.fullscreenControlOptions));
    }), a.control.fullscreen = function(b) {
      return new a.Control.FullScreen(b);
    }, { leaflet: a };
  });
})(dC);
var cb = { exports: {} };
(function(_, a) {
  (function(f, y) {
    y(a);
  })(Hm, function(f) {
    var y = L.MarkerClusterGroup = L.FeatureGroup.extend({
      options: {
        maxClusterRadius: 80,
        //A cluster will cover at most this many pixels from its center
        iconCreateFunction: null,
        clusterPane: L.Marker.prototype.options.pane,
        spiderfyOnEveryZoom: !1,
        spiderfyOnMaxZoom: !0,
        showCoverageOnHover: !0,
        zoomToBoundsOnClick: !0,
        singleMarkerMode: !1,
        disableClusteringAtZoom: null,
        // Setting this to false prevents the removal of any clusters outside of the viewpoint, which
        // is the default behaviour for performance reasons.
        removeOutsideVisibleBounds: !0,
        // Set to false to disable all animations (zoom and spiderfy).
        // If false, option animateAddingMarkers below has no effect.
        // If L.DomUtil.TRANSITION is falsy, this option has no effect.
        animate: !0,
        //Whether to animate adding markers after adding the MarkerClusterGroup to the map
        // If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
        animateAddingMarkers: !1,
        // Make it possible to provide custom function to calculate spiderfy shape positions
        spiderfyShapePositions: null,
        //Increase to increase the distance away that spiderfied markers appear from the center
        spiderfyDistanceMultiplier: 1,
        // Make it possible to specify a polyline options on a spider leg
        spiderLegPolylineOptions: { weight: 1.5, color: "#222", opacity: 0.5 },
        // When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
        chunkedLoading: !1,
        chunkInterval: 200,
        // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
        chunkDelay: 50,
        // at the end of each interval, give n milliseconds back to system/browser
        chunkProgress: null,
        // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)
        //Options to pass to the L.Polygon constructor
        polygonOptions: {}
      },
      initialize: function(b) {
        L.Util.setOptions(this, b), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
          dragstart: this._childMarkerDragStart,
          move: this._childMarkerMoved,
          dragend: this._childMarkerDragEnd
        };
        var P = L.DomUtil.TRANSITION && this.options.animate;
        L.extend(this, P ? this._withAnimation : this._noAnimation), this._markerCluster = P ? L.MarkerCluster : L.MarkerClusterNonAnimated;
      },
      addLayer: function(b) {
        if (b instanceof L.LayerGroup)
          return this.addLayers([b]);
        if (!b.getLatLng)
          return this._nonPointGroup.addLayer(b), this.fire("layeradd", { layer: b }), this;
        if (!this._map)
          return this._needsClustering.push(b), this.fire("layeradd", { layer: b }), this;
        if (this.hasLayer(b))
          return this;
        this._unspiderfy && this._unspiderfy(), this._addLayer(b, this._maxZoom), this.fire("layeradd", { layer: b }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
        var P = b, i = this._zoom;
        if (b.__parent)
          for (; P.__parent._zoom >= i; )
            P = P.__parent;
        return this._currentShownBounds.contains(P.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(b, P) : this._animationAddLayerNonAnimated(b, P)), this;
      },
      removeLayer: function(b) {
        return b instanceof L.LayerGroup ? this.removeLayers([b]) : b.getLatLng ? this._map ? b.__parent ? (this._unspiderfy && (this._unspiderfy(), this._unspiderfyLayer(b)), this._removeLayer(b, !0), this.fire("layerremove", { layer: b }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), b.off(this._childMarkerEventHandlers, this), this._featureGroup.hasLayer(b) && (this._featureGroup.removeLayer(b), b.clusterShow && b.clusterShow()), this) : this : (!this._arraySplice(this._needsClustering, b) && this.hasLayer(b) && this._needsRemoving.push({ layer: b, latlng: b._latlng }), this.fire("layerremove", { layer: b }), this) : (this._nonPointGroup.removeLayer(b), this.fire("layerremove", { layer: b }), this);
      },
      //Takes an array of markers and adds them in bulk
      addLayers: function(b, P) {
        if (!L.Util.isArray(b))
          return this.addLayer(b);
        var i = this._featureGroup, O = this._nonPointGroup, Z = this.options.chunkedLoading, Y = this.options.chunkInterval, J = this.options.chunkProgress, ae = b.length, ue = 0, Se = !0, we;
        if (this._map) {
          var qe = (/* @__PURE__ */ new Date()).getTime(), Ge = L.bind(function() {
            var Et = (/* @__PURE__ */ new Date()).getTime();
            for (this._map && this._unspiderfy && this._unspiderfy(); ue < ae; ue++) {
              if (Z && ue % 200 === 0) {
                var ut = (/* @__PURE__ */ new Date()).getTime() - Et;
                if (ut > Y)
                  break;
              }
              if (we = b[ue], we instanceof L.LayerGroup) {
                Se && (b = b.slice(), Se = !1), this._extractNonGroupLayers(we, b), ae = b.length;
                continue;
              }
              if (!we.getLatLng) {
                O.addLayer(we), P || this.fire("layeradd", { layer: we });
                continue;
              }
              if (!this.hasLayer(we) && (this._addLayer(we, this._maxZoom), P || this.fire("layeradd", { layer: we }), we.__parent && we.__parent.getChildCount() === 2)) {
                var bt = we.__parent.getAllChildMarkers(), Vt = bt[0] === we ? bt[1] : bt[0];
                i.removeLayer(Vt);
              }
            }
            J && J(ue, ae, (/* @__PURE__ */ new Date()).getTime() - qe), ue === ae ? (this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(Ge, this.options.chunkDelay);
          }, this);
          Ge();
        } else
          for (var lt = this._needsClustering; ue < ae; ue++) {
            if (we = b[ue], we instanceof L.LayerGroup) {
              Se && (b = b.slice(), Se = !1), this._extractNonGroupLayers(we, b), ae = b.length;
              continue;
            }
            if (!we.getLatLng) {
              O.addLayer(we);
              continue;
            }
            this.hasLayer(we) || lt.push(we);
          }
        return this;
      },
      //Takes an array of markers and removes them in bulk
      removeLayers: function(b) {
        var P, i, O = b.length, Z = this._featureGroup, Y = this._nonPointGroup, J = !0;
        if (!this._map) {
          for (P = 0; P < O; P++) {
            if (i = b[P], i instanceof L.LayerGroup) {
              J && (b = b.slice(), J = !1), this._extractNonGroupLayers(i, b), O = b.length;
              continue;
            }
            this._arraySplice(this._needsClustering, i), Y.removeLayer(i), this.hasLayer(i) && this._needsRemoving.push({ layer: i, latlng: i._latlng }), this.fire("layerremove", { layer: i });
          }
          return this;
        }
        if (this._unspiderfy) {
          this._unspiderfy();
          var ae = b.slice(), ue = O;
          for (P = 0; P < ue; P++) {
            if (i = ae[P], i instanceof L.LayerGroup) {
              this._extractNonGroupLayers(i, ae), ue = ae.length;
              continue;
            }
            this._unspiderfyLayer(i);
          }
        }
        for (P = 0; P < O; P++) {
          if (i = b[P], i instanceof L.LayerGroup) {
            J && (b = b.slice(), J = !1), this._extractNonGroupLayers(i, b), O = b.length;
            continue;
          }
          if (!i.__parent) {
            Y.removeLayer(i), this.fire("layerremove", { layer: i });
            continue;
          }
          this._removeLayer(i, !0, !0), this.fire("layerremove", { layer: i }), Z.hasLayer(i) && (Z.removeLayer(i), i.clusterShow && i.clusterShow());
        }
        return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), this;
      },
      //Removes all layers from the MarkerClusterGroup
      clearLayers: function() {
        return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer(function(b) {
          b.off(this._childMarkerEventHandlers, this), delete b.__parent;
        }, this), this._map && this._generateInitialClusters(), this;
      },
      //Override FeatureGroup.getBounds as it doesn't work
      getBounds: function() {
        var b = new L.LatLngBounds();
        this._topClusterLevel && b.extend(this._topClusterLevel._bounds);
        for (var P = this._needsClustering.length - 1; P >= 0; P--)
          b.extend(this._needsClustering[P].getLatLng());
        return b.extend(this._nonPointGroup.getBounds()), b;
      },
      //Overrides LayerGroup.eachLayer
      eachLayer: function(b, P) {
        var i = this._needsClustering.slice(), O = this._needsRemoving, Z, Y, J;
        for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(i), Y = i.length - 1; Y >= 0; Y--) {
          for (Z = !0, J = O.length - 1; J >= 0; J--)
            if (O[J].layer === i[Y]) {
              Z = !1;
              break;
            }
          Z && b.call(P, i[Y]);
        }
        this._nonPointGroup.eachLayer(b, P);
      },
      //Overrides LayerGroup.getLayers
      getLayers: function() {
        var b = [];
        return this.eachLayer(function(P) {
          b.push(P);
        }), b;
      },
      //Overrides LayerGroup.getLayer, WARNING: Really bad performance
      getLayer: function(b) {
        var P = null;
        return b = parseInt(b, 10), this.eachLayer(function(i) {
          L.stamp(i) === b && (P = i);
        }), P;
      },
      //Returns true if the given layer is in this MarkerClusterGroup
      hasLayer: function(b) {
        if (!b)
          return !1;
        var P, i = this._needsClustering;
        for (P = i.length - 1; P >= 0; P--)
          if (i[P] === b)
            return !0;
        for (i = this._needsRemoving, P = i.length - 1; P >= 0; P--)
          if (i[P].layer === b)
            return !1;
        return !!(b.__parent && b.__parent._group === this) || this._nonPointGroup.hasLayer(b);
      },
      //Zoom down to show the given layer (spiderfying if necessary) then calls the callback
      zoomToShowLayer: function(b, P) {
        var i = this._map;
        typeof P != "function" && (P = function() {
        });
        var O = function() {
          (i.hasLayer(b) || i.hasLayer(b.__parent)) && !this._inZoomAnimation && (this._map.off("moveend", O, this), this.off("animationend", O, this), i.hasLayer(b) ? P() : b.__parent._icon && (this.once("spiderfied", P, this), b.__parent.spiderfy()));
        };
        b._icon && this._map.getBounds().contains(b.getLatLng()) ? P() : b.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", O, this), this._map.panTo(b.getLatLng())) : (this._map.on("moveend", O, this), this.on("animationend", O, this), b.__parent.zoomToBounds());
      },
      //Overrides FeatureGroup.onAdd
      onAdd: function(b) {
        this._map = b;
        var P, i, O;
        if (!isFinite(this._map.getMaxZoom()))
          throw "Map has no maxZoom specified";
        for (this._featureGroup.addTo(b), this._nonPointGroup.addTo(b), this._gridClusters || this._generateInitialClusters(), this._maxLat = b.options.crs.projection.MAX_LATITUDE, P = 0, i = this._needsRemoving.length; P < i; P++)
          O = this._needsRemoving[P], O.newlatlng = O.layer._latlng, O.layer._latlng = O.latlng;
        for (P = 0, i = this._needsRemoving.length; P < i; P++)
          O = this._needsRemoving[P], this._removeLayer(O.layer, !0), O.layer._latlng = O.newlatlng;
        this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), i = this._needsClustering, this._needsClustering = [], this.addLayers(i, !0);
      },
      //Overrides FeatureGroup.onRemove
      onRemove: function(b) {
        b.off("zoomend", this._zoomEnd, this), b.off("moveend", this._moveEnd, this), this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), this._map = null;
      },
      getVisibleParent: function(b) {
        for (var P = b; P && !P._icon; )
          P = P.__parent;
        return P || null;
      },
      //Remove the given object from the given array
      _arraySplice: function(b, P) {
        for (var i = b.length - 1; i >= 0; i--)
          if (b[i] === P)
            return b.splice(i, 1), !0;
      },
      /**
       * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
       * @param marker to be removed from _gridUnclustered.
       * @param z integer bottom start zoom level (included)
       * @private
       */
      _removeFromGridUnclustered: function(b, P) {
        for (var i = this._map, O = this._gridUnclustered, Z = Math.floor(this._map.getMinZoom()); P >= Z && O[P].removeObject(b, i.project(b.getLatLng(), P)); P--)
          ;
      },
      _childMarkerDragStart: function(b) {
        b.target.__dragStart = b.target._latlng;
      },
      _childMarkerMoved: function(b) {
        if (!this._ignoreMove && !b.target.__dragStart) {
          var P = b.target._popup && b.target._popup.isOpen();
          this._moveChild(b.target, b.oldLatLng, b.latlng), P && b.target.openPopup();
        }
      },
      _moveChild: function(b, P, i) {
        b._latlng = P, this.removeLayer(b), b._latlng = i, this.addLayer(b);
      },
      _childMarkerDragEnd: function(b) {
        var P = b.target.__dragStart;
        delete b.target.__dragStart, P && this._moveChild(b.target, P, b.target._latlng);
      },
      //Internal function for removing a marker from everything.
      //dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
      _removeLayer: function(b, P, i) {
        var O = this._gridClusters, Z = this._gridUnclustered, Y = this._featureGroup, J = this._map, ae = Math.floor(this._map.getMinZoom());
        P && this._removeFromGridUnclustered(b, this._maxZoom);
        var ue = b.__parent, Se = ue._markers, we;
        for (this._arraySplice(Se, b); ue && (ue._childCount--, ue._boundsNeedUpdate = !0, !(ue._zoom < ae)); )
          P && ue._childCount <= 1 ? (we = ue._markers[0] === b ? ue._markers[1] : ue._markers[0], O[ue._zoom].removeObject(ue, J.project(ue._cLatLng, ue._zoom)), Z[ue._zoom].addObject(we, J.project(we.getLatLng(), ue._zoom)), this._arraySplice(ue.__parent._childClusters, ue), ue.__parent._markers.push(we), we.__parent = ue.__parent, ue._icon && (Y.removeLayer(ue), i || Y.addLayer(we))) : ue._iconNeedsUpdate = !0, ue = ue.__parent;
        delete b.__parent;
      },
      _isOrIsParent: function(b, P) {
        for (; P; ) {
          if (b === P)
            return !0;
          P = P.parentNode;
        }
        return !1;
      },
      //Override L.Evented.fire
      fire: function(b, P, i) {
        if (P && P.layer instanceof L.MarkerCluster) {
          if (P.originalEvent && this._isOrIsParent(P.layer._icon, P.originalEvent.relatedTarget))
            return;
          b = "cluster" + b;
        }
        L.FeatureGroup.prototype.fire.call(this, b, P, i);
      },
      //Override L.Evented.listens
      listens: function(b, P) {
        return L.FeatureGroup.prototype.listens.call(this, b, P) || L.FeatureGroup.prototype.listens.call(this, "cluster" + b, P);
      },
      //Default functionality
      _defaultIconCreateFunction: function(b) {
        var P = b.getChildCount(), i = " marker-cluster-";
        return P < 10 ? i += "small" : P < 100 ? i += "medium" : i += "large", new L.DivIcon({ html: "<div><span>" + P + "</span></div>", className: "marker-cluster" + i, iconSize: new L.Point(40, 40) });
      },
      _bindEvents: function() {
        var b = this._map, P = this.options.spiderfyOnMaxZoom, i = this.options.showCoverageOnHover, O = this.options.zoomToBoundsOnClick, Z = this.options.spiderfyOnEveryZoom;
        (P || O || Z) && this.on("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), i && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), b.on("zoomend", this._hideCoverage, this));
      },
      _zoomOrSpiderfy: function(b) {
        var P = b.layer, i = P;
        if (!(b.type === "clusterkeypress" && b.originalEvent && b.originalEvent.keyCode !== 13)) {
          for (; i._childClusters.length === 1; )
            i = i._childClusters[0];
          i._zoom === this._maxZoom && i._childCount === P._childCount && this.options.spiderfyOnMaxZoom ? P.spiderfy() : this.options.zoomToBoundsOnClick && P.zoomToBounds(), this.options.spiderfyOnEveryZoom && P.spiderfy(), b.originalEvent && b.originalEvent.keyCode === 13 && this._map._container.focus();
        }
      },
      _showCoverage: function(b) {
        var P = this._map;
        this._inZoomAnimation || (this._shownPolygon && P.removeLayer(this._shownPolygon), b.layer.getChildCount() > 2 && b.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(b.layer.getConvexHull(), this.options.polygonOptions), P.addLayer(this._shownPolygon)));
      },
      _hideCoverage: function() {
        this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);
      },
      _unbindEvents: function() {
        var b = this.options.spiderfyOnMaxZoom, P = this.options.showCoverageOnHover, i = this.options.zoomToBoundsOnClick, O = this.options.spiderfyOnEveryZoom, Z = this._map;
        (b || i || O) && this.off("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), P && (this.off("clustermouseover", this._showCoverage, this), this.off("clustermouseout", this._hideCoverage, this), Z.off("zoomend", this._hideCoverage, this));
      },
      _zoomEnd: function() {
        this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds());
      },
      _moveEnd: function() {
        if (!this._inZoomAnimation) {
          var b = this._getExpandedVisibleBounds();
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, b), this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), b), this._currentShownBounds = b;
        }
      },
      _generateInitialClusters: function() {
        var b = Math.ceil(this._map.getMaxZoom()), P = Math.floor(this._map.getMinZoom()), i = this.options.maxClusterRadius, O = i;
        typeof i != "function" && (O = function() {
          return i;
        }), this.options.disableClusteringAtZoom !== null && (b = this.options.disableClusteringAtZoom - 1), this._maxZoom = b, this._gridClusters = {}, this._gridUnclustered = {};
        for (var Z = b; Z >= P; Z--)
          this._gridClusters[Z] = new L.DistanceGrid(O(Z)), this._gridUnclustered[Z] = new L.DistanceGrid(O(Z));
        this._topClusterLevel = new this._markerCluster(this, P - 1);
      },
      //Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
      _addLayer: function(b, P) {
        var i = this._gridClusters, O = this._gridUnclustered, Z = Math.floor(this._map.getMinZoom()), Y, J;
        for (this.options.singleMarkerMode && this._overrideMarkerIcon(b), b.on(this._childMarkerEventHandlers, this); P >= Z; P--) {
          Y = this._map.project(b.getLatLng(), P);
          var ae = i[P].getNearObject(Y);
          if (ae) {
            ae._addChild(b), b.__parent = ae;
            return;
          }
          if (ae = O[P].getNearObject(Y), ae) {
            var ue = ae.__parent;
            ue && this._removeLayer(ae, !1);
            var Se = new this._markerCluster(this, P, ae, b);
            i[P].addObject(Se, this._map.project(Se._cLatLng, P)), ae.__parent = Se, b.__parent = Se;
            var we = Se;
            for (J = P - 1; J > ue._zoom; J--)
              we = new this._markerCluster(this, J, we), i[J].addObject(we, this._map.project(ae.getLatLng(), J));
            ue._addChild(we), this._removeFromGridUnclustered(ae, P);
            return;
          }
          O[P].addObject(b, Y);
        }
        this._topClusterLevel._addChild(b), b.__parent = this._topClusterLevel;
      },
      /**
       * Refreshes the icon of all "dirty" visible clusters.
       * Non-visible "dirty" clusters will be updated when they are added to the map.
       * @private
       */
      _refreshClustersIcons: function() {
        this._featureGroup.eachLayer(function(b) {
          b instanceof L.MarkerCluster && b._iconNeedsUpdate && b._updateIcon();
        });
      },
      //Enqueue code to fire after the marker expand/contract has happened
      _enqueue: function(b) {
        this._queue.push(b), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));
      },
      _processQueue: function() {
        for (var b = 0; b < this._queue.length; b++)
          this._queue[b].call(this);
        this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;
      },
      //Merge and split any existing clusters that are too big or small
      _mergeSplitClusters: function() {
        var b = Math.round(this._map._zoom);
        this._processQueue(), this._zoom < b && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), this._animationZoomIn(this._zoom, b)) : this._zoom > b ? (this._animationStart(), this._animationZoomOut(this._zoom, b)) : this._moveEnd();
      },
      //Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
      _getExpandedVisibleBounds: function() {
        if (this.options.removeOutsideVisibleBounds) {
          if (L.Browser.mobile)
            return this._checkBoundsMaxLat(this._map.getBounds());
        } else
          return this._mapBoundsInfinite;
        return this._checkBoundsMaxLat(this._map.getBounds().pad(1));
      },
      /**
       * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
       * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
       * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
       * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
       * making the user think that MCG "eats" them and never displays them again.
       * @param bounds L.LatLngBounds
       * @returns {L.LatLngBounds}
       * @private
       */
      _checkBoundsMaxLat: function(b) {
        var P = this._maxLat;
        return P !== void 0 && (b.getNorth() >= P && (b._northEast.lat = 1 / 0), b.getSouth() <= -P && (b._southWest.lat = -1 / 0)), b;
      },
      //Shared animation code
      _animationAddLayerNonAnimated: function(b, P) {
        if (P === b)
          this._featureGroup.addLayer(b);
        else if (P._childCount === 2) {
          P._addToMap();
          var i = P.getAllChildMarkers();
          this._featureGroup.removeLayer(i[0]), this._featureGroup.removeLayer(i[1]);
        } else
          P._updateIcon();
      },
      /**
       * Extracts individual (i.e. non-group) layers from a Layer Group.
       * @param group to extract layers from.
       * @param output {Array} in which to store the extracted layers.
       * @returns {*|Array}
       * @private
       */
      _extractNonGroupLayers: function(b, P) {
        var i = b.getLayers(), O = 0, Z;
        for (P = P || []; O < i.length; O++) {
          if (Z = i[O], Z instanceof L.LayerGroup) {
            this._extractNonGroupLayers(Z, P);
            continue;
          }
          P.push(Z);
        }
        return P;
      },
      /**
       * Implements the singleMarkerMode option.
       * @param layer Marker to re-style using the Clusters iconCreateFunction.
       * @returns {L.Icon} The newly created icon.
       * @private
       */
      _overrideMarkerIcon: function(b) {
        var P = b.options.icon = this.options.iconCreateFunction({
          getChildCount: function() {
            return 1;
          },
          getAllChildMarkers: function() {
            return [b];
          }
        });
        return P;
      }
    });
    L.MarkerClusterGroup.include({
      _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
    }), L.MarkerClusterGroup.include({
      _noAnimation: {
        //Non Animated versions of everything
        _animationStart: function() {
        },
        _animationZoomIn: function(b, P) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b), this._topClusterLevel._recursivelyAddChildrenToMap(null, P, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationZoomOut: function(b, P) {
          this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b), this._topClusterLevel._recursivelyAddChildrenToMap(null, P, this._getExpandedVisibleBounds()), this.fire("animationend");
        },
        _animationAddLayer: function(b, P) {
          this._animationAddLayerNonAnimated(b, P);
        }
      },
      _withAnimation: {
        //Animated versions here
        _animationStart: function() {
          this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++;
        },
        _animationZoomIn: function(b, P) {
          var i = this._getExpandedVisibleBounds(), O = this._featureGroup, Z = Math.floor(this._map.getMinZoom()), Y;
          this._ignoreMove = !0, this._topClusterLevel._recursively(i, b, Z, function(J) {
            var ae = J._latlng, ue = J._markers, Se;
            for (i.contains(ae) || (ae = null), J._isSingleParent() && b + 1 === P ? (O.removeLayer(J), J._recursivelyAddChildrenToMap(null, P, i)) : (J.clusterHide(), J._recursivelyAddChildrenToMap(ae, P, i)), Y = ue.length - 1; Y >= 0; Y--)
              Se = ue[Y], i.contains(Se._latlng) || O.removeLayer(Se);
          }), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(i, P), O.eachLayer(function(J) {
            !(J instanceof L.MarkerCluster) && J._icon && J.clusterShow();
          }), this._topClusterLevel._recursively(i, b, P, function(J) {
            J._recursivelyRestoreChildPositions(P);
          }), this._ignoreMove = !1, this._enqueue(function() {
            this._topClusterLevel._recursively(i, b, Z, function(J) {
              O.removeLayer(J), J.clusterShow();
            }), this._animationEnd();
          });
        },
        _animationZoomOut: function(b, P) {
          this._animationZoomOutSingle(this._topClusterLevel, b - 1, P), this._topClusterLevel._recursivelyAddChildrenToMap(null, P, this._getExpandedVisibleBounds()), this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), b, this._getExpandedVisibleBounds());
        },
        _animationAddLayer: function(b, P) {
          var i = this, O = this._featureGroup;
          O.addLayer(b), P !== b && (P._childCount > 2 ? (P._updateIcon(), this._forceLayout(), this._animationStart(), b._setPos(this._map.latLngToLayerPoint(P.getLatLng())), b.clusterHide(), this._enqueue(function() {
            O.removeLayer(b), b.clusterShow(), i._animationEnd();
          })) : (this._forceLayout(), i._animationStart(), i._animationZoomOutSingle(P, this._map.getMaxZoom(), this._zoom)));
        }
      },
      // Private methods for animated versions.
      _animationZoomOutSingle: function(b, P, i) {
        var O = this._getExpandedVisibleBounds(), Z = Math.floor(this._map.getMinZoom());
        b._recursivelyAnimateChildrenInAndAddSelfToMap(O, Z, P + 1, i);
        var Y = this;
        this._forceLayout(), b._recursivelyBecomeVisible(O, i), this._enqueue(function() {
          if (b._childCount === 1) {
            var J = b._markers[0];
            this._ignoreMove = !0, J.setLatLng(J.getLatLng()), this._ignoreMove = !1, J.clusterShow && J.clusterShow();
          } else
            b._recursively(O, i, Z, function(ae) {
              ae._recursivelyRemoveChildrenFromMap(O, Z, P + 1);
            });
          Y._animationEnd();
        });
      },
      _animationEnd: function() {
        this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), this._inZoomAnimation--, this.fire("animationend");
      },
      //Force a browser layout of stuff in the map
      // Should apply the current opacity and location to all elements so we can update them again for an animation
      _forceLayout: function() {
        L.Util.falseFn(document.body.offsetWidth);
      }
    }), L.markerClusterGroup = function(b) {
      return new L.MarkerClusterGroup(b);
    };
    var w = L.MarkerCluster = L.Marker.extend({
      options: L.Icon.prototype.options,
      initialize: function(b, P, i, O) {
        L.Marker.prototype.initialize.call(
          this,
          i ? i._cLatLng || i.getLatLng() : new L.LatLng(0, 0),
          { icon: this, pane: b.options.clusterPane }
        ), this._group = b, this._zoom = P, this._markers = [], this._childClusters = [], this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds(), i && this._addChild(i), O && this._addChild(O);
      },
      //Recursively retrieve all child markers of this cluster
      getAllChildMarkers: function(b, P) {
        b = b || [];
        for (var i = this._childClusters.length - 1; i >= 0; i--)
          this._childClusters[i].getAllChildMarkers(b, P);
        for (var O = this._markers.length - 1; O >= 0; O--)
          P && this._markers[O].__dragStart || b.push(this._markers[O]);
        return b;
      },
      //Returns the count of how many child markers we have
      getChildCount: function() {
        return this._childCount;
      },
      //Zoom to the minimum of showing all of the child markers, or the extents of this cluster
      zoomToBounds: function(b) {
        for (var P = this._childClusters.slice(), i = this._group._map, O = i.getBoundsZoom(this._bounds), Z = this._zoom + 1, Y = i.getZoom(), J; P.length > 0 && O > Z; ) {
          Z++;
          var ae = [];
          for (J = 0; J < P.length; J++)
            ae = ae.concat(P[J]._childClusters);
          P = ae;
        }
        O > Z ? this._group._map.setView(this._latlng, Z) : O <= Y ? this._group._map.setView(this._latlng, Y + 1) : this._group._map.fitBounds(this._bounds, b);
      },
      getBounds: function() {
        var b = new L.LatLngBounds();
        return b.extend(this._bounds), b;
      },
      _updateIcon: function() {
        this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);
      },
      //Cludge for Icon, we pretend to be an icon for performance
      createIcon: function() {
        return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), this._iconNeedsUpdate = !1), this._iconObj.createIcon();
      },
      createShadow: function() {
        return this._iconObj.createShadow();
      },
      _addChild: function(b, P) {
        this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(b), b instanceof L.MarkerCluster ? (P || (this._childClusters.push(b), b.__parent = this), this._childCount += b._childCount) : (P || this._markers.push(b), this._childCount++), this.__parent && this.__parent._addChild(b, !0);
      },
      /**
       * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
       * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
       * @private
       */
      _setClusterCenter: function(b) {
        this._cLatLng || (this._cLatLng = b._cLatLng || b._latlng);
      },
      /**
       * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
       * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
       * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
       * @private
       */
      _resetBounds: function() {
        var b = this._bounds;
        b._southWest && (b._southWest.lat = 1 / 0, b._southWest.lng = 1 / 0), b._northEast && (b._northEast.lat = -1 / 0, b._northEast.lng = -1 / 0);
      },
      _recalculateBounds: function() {
        var b = this._markers, P = this._childClusters, i = 0, O = 0, Z = this._childCount, Y, J, ae, ue;
        if (Z !== 0) {
          for (this._resetBounds(), Y = 0; Y < b.length; Y++)
            ae = b[Y]._latlng, this._bounds.extend(ae), i += ae.lat, O += ae.lng;
          for (Y = 0; Y < P.length; Y++)
            J = P[Y], J._boundsNeedUpdate && J._recalculateBounds(), this._bounds.extend(J._bounds), ae = J._wLatLng, ue = J._childCount, i += ae.lat * ue, O += ae.lng * ue;
          this._latlng = this._wLatLng = new L.LatLng(i / Z, O / Z), this._boundsNeedUpdate = !1;
        }
      },
      //Set our markers position as given and add it to the map
      _addToMap: function(b) {
        b && (this._backupLatlng = this._latlng, this.setLatLng(b)), this._group._featureGroup.addLayer(this);
      },
      _recursivelyAnimateChildrenIn: function(b, P, i) {
        this._recursively(
          b,
          this._group._map.getMinZoom(),
          i - 1,
          function(O) {
            var Z = O._markers, Y, J;
            for (Y = Z.length - 1; Y >= 0; Y--)
              J = Z[Y], J._icon && (J._setPos(P), J.clusterHide());
          },
          function(O) {
            var Z = O._childClusters, Y, J;
            for (Y = Z.length - 1; Y >= 0; Y--)
              J = Z[Y], J._icon && (J._setPos(P), J.clusterHide());
          }
        );
      },
      _recursivelyAnimateChildrenInAndAddSelfToMap: function(b, P, i, O) {
        this._recursively(
          b,
          O,
          P,
          function(Z) {
            Z._recursivelyAnimateChildrenIn(b, Z._group._map.latLngToLayerPoint(Z.getLatLng()).round(), i), Z._isSingleParent() && i - 1 === O ? (Z.clusterShow(), Z._recursivelyRemoveChildrenFromMap(b, P, i)) : Z.clusterHide(), Z._addToMap();
          }
        );
      },
      _recursivelyBecomeVisible: function(b, P) {
        this._recursively(b, this._group._map.getMinZoom(), P, null, function(i) {
          i.clusterShow();
        });
      },
      _recursivelyAddChildrenToMap: function(b, P, i) {
        this._recursively(
          i,
          this._group._map.getMinZoom() - 1,
          P,
          function(O) {
            if (P !== O._zoom)
              for (var Z = O._markers.length - 1; Z >= 0; Z--) {
                var Y = O._markers[Z];
                i.contains(Y._latlng) && (b && (Y._backupLatlng = Y.getLatLng(), Y.setLatLng(b), Y.clusterHide && Y.clusterHide()), O._group._featureGroup.addLayer(Y));
              }
          },
          function(O) {
            O._addToMap(b);
          }
        );
      },
      _recursivelyRestoreChildPositions: function(b) {
        for (var P = this._markers.length - 1; P >= 0; P--) {
          var i = this._markers[P];
          i._backupLatlng && (i.setLatLng(i._backupLatlng), delete i._backupLatlng);
        }
        if (b - 1 === this._zoom)
          for (var O = this._childClusters.length - 1; O >= 0; O--)
            this._childClusters[O]._restorePosition();
        else
          for (var Z = this._childClusters.length - 1; Z >= 0; Z--)
            this._childClusters[Z]._recursivelyRestoreChildPositions(b);
      },
      _restorePosition: function() {
        this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
      },
      //exceptBounds: If set, don't remove any markers/clusters in it
      _recursivelyRemoveChildrenFromMap: function(b, P, i, O) {
        var Z, Y;
        this._recursively(
          b,
          P - 1,
          i - 1,
          function(J) {
            for (Y = J._markers.length - 1; Y >= 0; Y--)
              Z = J._markers[Y], (!O || !O.contains(Z._latlng)) && (J._group._featureGroup.removeLayer(Z), Z.clusterShow && Z.clusterShow());
          },
          function(J) {
            for (Y = J._childClusters.length - 1; Y >= 0; Y--)
              Z = J._childClusters[Y], (!O || !O.contains(Z._latlng)) && (J._group._featureGroup.removeLayer(Z), Z.clusterShow && Z.clusterShow());
          }
        );
      },
      //Run the given functions recursively to this and child clusters
      // boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
      // zoomLevelToStart: zoom level to start running functions (inclusive)
      // zoomLevelToStop: zoom level to stop running functions (inclusive)
      // runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
      // runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
      _recursively: function(b, P, i, O, Z) {
        var Y = this._childClusters, J = this._zoom, ae, ue;
        if (P <= J && (O && O(this), Z && J === i && Z(this)), J < P || J < i)
          for (ae = Y.length - 1; ae >= 0; ae--)
            ue = Y[ae], ue._boundsNeedUpdate && ue._recalculateBounds(), b.intersects(ue._bounds) && ue._recursively(b, P, i, O, Z);
      },
      //Returns true if we are the parent of only one cluster and that cluster is the same as us
      _isSingleParent: function() {
        return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
      }
    });
    L.Marker.include({
      clusterHide: function() {
        var b = this.options.opacity;
        return this.setOpacity(0), this.options.opacity = b, this;
      },
      clusterShow: function() {
        return this.setOpacity(this.options.opacity);
      }
    }), L.DistanceGrid = function(b) {
      this._cellSize = b, this._sqCellSize = b * b, this._grid = {}, this._objectPoint = {};
    }, L.DistanceGrid.prototype = {
      addObject: function(b, P) {
        var i = this._getCoord(P.x), O = this._getCoord(P.y), Z = this._grid, Y = Z[O] = Z[O] || {}, J = Y[i] = Y[i] || [], ae = L.Util.stamp(b);
        this._objectPoint[ae] = P, J.push(b);
      },
      updateObject: function(b, P) {
        this.removeObject(b), this.addObject(b, P);
      },
      //Returns true if the object was found
      removeObject: function(b, P) {
        var i = this._getCoord(P.x), O = this._getCoord(P.y), Z = this._grid, Y = Z[O] = Z[O] || {}, J = Y[i] = Y[i] || [], ae, ue;
        for (delete this._objectPoint[L.Util.stamp(b)], ae = 0, ue = J.length; ae < ue; ae++)
          if (J[ae] === b)
            return J.splice(ae, 1), ue === 1 && delete Y[i], !0;
      },
      eachObject: function(b, P) {
        var i, O, Z, Y, J, ae, ue, Se = this._grid;
        for (i in Se) {
          J = Se[i];
          for (O in J)
            for (ae = J[O], Z = 0, Y = ae.length; Z < Y; Z++)
              ue = b.call(P, ae[Z]), ue && (Z--, Y--);
        }
      },
      getNearObject: function(b) {
        var P = this._getCoord(b.x), i = this._getCoord(b.y), O, Z, Y, J, ae, ue, Se, we, qe = this._objectPoint, Ge = this._sqCellSize, lt = null;
        for (O = i - 1; O <= i + 1; O++)
          if (J = this._grid[O], J) {
            for (Z = P - 1; Z <= P + 1; Z++)
              if (ae = J[Z], ae)
                for (Y = 0, ue = ae.length; Y < ue; Y++)
                  Se = ae[Y], we = this._sqDist(qe[L.Util.stamp(Se)], b), (we < Ge || we <= Ge && lt === null) && (Ge = we, lt = Se);
          }
        return lt;
      },
      _getCoord: function(b) {
        var P = Math.floor(b / this._cellSize);
        return isFinite(P) ? P : b;
      },
      _sqDist: function(b, P) {
        var i = P.x - b.x, O = P.y - b.y;
        return i * i + O * O;
      }
    }, function() {
      L.QuickHull = {
        /*
         * @param {Object} cpt a point to be measured from the baseline
         * @param {Array} bl the baseline, as represented by a two-element
         *   array of latlng objects.
         * @returns {Number} an approximate distance measure
         */
        getDistant: function(b, P) {
          var i = P[1].lat - P[0].lat, O = P[0].lng - P[1].lng;
          return O * (b.lat - P[0].lat) + i * (b.lng - P[0].lng);
        },
        /*
         * @param {Array} baseLine a two-element array of latlng objects
         *   representing the baseline to project from
         * @param {Array} latLngs an array of latlng objects
         * @returns {Object} the maximum point and all new points to stay
         *   in consideration for the hull.
         */
        findMostDistantPointFromBaseLine: function(b, P) {
          var i = 0, O = null, Z = [], Y, J, ae;
          for (Y = P.length - 1; Y >= 0; Y--) {
            if (J = P[Y], ae = this.getDistant(J, b), ae > 0)
              Z.push(J);
            else
              continue;
            ae > i && (i = ae, O = J);
          }
          return { maxPoint: O, newPoints: Z };
        },
        /*
         * Given a baseline, compute the convex hull of latLngs as an array
         * of latLngs.
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        buildConvexHull: function(b, P) {
          var i = [], O = this.findMostDistantPointFromBaseLine(b, P);
          return O.maxPoint ? (i = i.concat(
            this.buildConvexHull([b[0], O.maxPoint], O.newPoints)
          ), i = i.concat(
            this.buildConvexHull([O.maxPoint, b[1]], O.newPoints)
          ), i) : [b[0]];
        },
        /*
         * Given an array of latlngs, compute a convex hull as an array
         * of latlngs
         *
         * @param {Array} latLngs
         * @returns {Array}
         */
        getConvexHull: function(b) {
          var P = !1, i = !1, O = !1, Z = !1, Y = null, J = null, ae = null, ue = null, Se = null, we = null, qe;
          for (qe = b.length - 1; qe >= 0; qe--) {
            var Ge = b[qe];
            (P === !1 || Ge.lat > P) && (Y = Ge, P = Ge.lat), (i === !1 || Ge.lat < i) && (J = Ge, i = Ge.lat), (O === !1 || Ge.lng > O) && (ae = Ge, O = Ge.lng), (Z === !1 || Ge.lng < Z) && (ue = Ge, Z = Ge.lng);
          }
          i !== P ? (we = J, Se = Y) : (we = ue, Se = ae);
          var lt = [].concat(
            this.buildConvexHull([we, Se], b),
            this.buildConvexHull([Se, we], b)
          );
          return lt;
        }
      };
    }(), L.MarkerCluster.include({
      getConvexHull: function() {
        var b = this.getAllChildMarkers(), P = [], i, O;
        for (O = b.length - 1; O >= 0; O--)
          i = b[O].getLatLng(), P.push(i);
        return L.QuickHull.getConvexHull(P);
      }
    }), L.MarkerCluster.include({
      _2PI: Math.PI * 2,
      _circleFootSeparation: 25,
      //related to circumference of circle
      _circleStartAngle: 0,
      _spiralFootSeparation: 28,
      //related to size of spiral (experiment!)
      _spiralLengthStart: 11,
      _spiralLengthFactor: 5,
      _circleSpiralSwitchover: 9,
      //show spiral instead of circle from this marker count upwards.
      // 0 -> always spiral; Infinity -> always circle
      spiderfy: function() {
        if (!(this._group._spiderfied === this || this._group._inZoomAnimation)) {
          var b = this.getAllChildMarkers(null, !0), P = this._group, i = P._map, O = i.latLngToLayerPoint(this._latlng), Z;
          this._group._unspiderfy(), this._group._spiderfied = this, this._group.options.spiderfyShapePositions ? Z = this._group.options.spiderfyShapePositions(b.length, O) : b.length >= this._circleSpiralSwitchover ? Z = this._generatePointsSpiral(b.length, O) : (O.y += 10, Z = this._generatePointsCircle(b.length, O)), this._animationSpiderfy(b, Z);
        }
      },
      unspiderfy: function(b) {
        this._group._inZoomAnimation || (this._animationUnspiderfy(b), this._group._spiderfied = null);
      },
      _generatePointsCircle: function(b, P) {
        var i = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + b), O = i / this._2PI, Z = this._2PI / b, Y = [], J, ae;
        for (O = Math.max(O, 35), Y.length = b, J = 0; J < b; J++)
          ae = this._circleStartAngle + J * Z, Y[J] = new L.Point(P.x + O * Math.cos(ae), P.y + O * Math.sin(ae))._round();
        return Y;
      },
      _generatePointsSpiral: function(b, P) {
        var i = this._group.options.spiderfyDistanceMultiplier, O = i * this._spiralLengthStart, Z = i * this._spiralFootSeparation, Y = i * this._spiralLengthFactor * this._2PI, J = 0, ae = [], ue;
        for (ae.length = b, ue = b; ue >= 0; ue--)
          ue < b && (ae[ue] = new L.Point(P.x + O * Math.cos(J), P.y + O * Math.sin(J))._round()), J += Z / O + ue * 5e-4, O += Y / J;
        return ae;
      },
      _noanimationUnspiderfy: function() {
        var b = this._group, P = b._map, i = b._featureGroup, O = this.getAllChildMarkers(null, !0), Z, Y;
        for (b._ignoreMove = !0, this.setOpacity(1), Y = O.length - 1; Y >= 0; Y--)
          Z = O[Y], i.removeLayer(Z), Z._preSpiderfyLatlng && (Z.setLatLng(Z._preSpiderfyLatlng), delete Z._preSpiderfyLatlng), Z.setZIndexOffset && Z.setZIndexOffset(0), Z._spiderLeg && (P.removeLayer(Z._spiderLeg), delete Z._spiderLeg);
        b.fire("unspiderfied", {
          cluster: this,
          markers: O
        }), b._ignoreMove = !1, b._spiderfied = null;
      }
    }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
      _animationSpiderfy: function(b, P) {
        var i = this._group, O = i._map, Z = i._featureGroup, Y = this._group.options.spiderLegPolylineOptions, J, ae, ue, Se;
        for (i._ignoreMove = !0, J = 0; J < b.length; J++)
          Se = O.layerPointToLatLng(P[J]), ae = b[J], ue = new L.Polyline([this._latlng, Se], Y), O.addLayer(ue), ae._spiderLeg = ue, ae._preSpiderfyLatlng = ae._latlng, ae.setLatLng(Se), ae.setZIndexOffset && ae.setZIndexOffset(1e6), Z.addLayer(ae);
        this.setOpacity(0.3), i._ignoreMove = !1, i.fire("spiderfied", {
          cluster: this,
          markers: b
        });
      },
      _animationUnspiderfy: function() {
        this._noanimationUnspiderfy();
      }
    }), L.MarkerCluster.include({
      _animationSpiderfy: function(b, P) {
        var i = this, O = this._group, Z = O._map, Y = O._featureGroup, J = this._latlng, ae = Z.latLngToLayerPoint(J), ue = L.Path.SVG, Se = L.extend({}, this._group.options.spiderLegPolylineOptions), we = Se.opacity, qe, Ge, lt, Et, ut, bt;
        for (we === void 0 && (we = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), ue ? (Se.opacity = 0, Se.className = (Se.className || "") + " leaflet-cluster-spider-leg") : Se.opacity = we, O._ignoreMove = !0, qe = 0; qe < b.length; qe++)
          Ge = b[qe], bt = Z.layerPointToLatLng(P[qe]), lt = new L.Polyline([J, bt], Se), Z.addLayer(lt), Ge._spiderLeg = lt, ue && (Et = lt._path, ut = Et.getTotalLength() + 0.1, Et.style.strokeDasharray = ut, Et.style.strokeDashoffset = ut), Ge.setZIndexOffset && Ge.setZIndexOffset(1e6), Ge.clusterHide && Ge.clusterHide(), Y.addLayer(Ge), Ge._setPos && Ge._setPos(ae);
        for (O._forceLayout(), O._animationStart(), qe = b.length - 1; qe >= 0; qe--)
          bt = Z.layerPointToLatLng(P[qe]), Ge = b[qe], Ge._preSpiderfyLatlng = Ge._latlng, Ge.setLatLng(bt), Ge.clusterShow && Ge.clusterShow(), ue && (lt = Ge._spiderLeg, Et = lt._path, Et.style.strokeDashoffset = 0, lt.setStyle({ opacity: we }));
        this.setOpacity(0.3), O._ignoreMove = !1, setTimeout(function() {
          O._animationEnd(), O.fire("spiderfied", {
            cluster: i,
            markers: b
          });
        }, 200);
      },
      _animationUnspiderfy: function(b) {
        var P = this, i = this._group, O = i._map, Z = i._featureGroup, Y = b ? O._latLngToNewLayerPoint(this._latlng, b.zoom, b.center) : O.latLngToLayerPoint(this._latlng), J = this.getAllChildMarkers(null, !0), ae = L.Path.SVG, ue, Se, we, qe, Ge, lt;
        for (i._ignoreMove = !0, i._animationStart(), this.setOpacity(1), Se = J.length - 1; Se >= 0; Se--)
          ue = J[Se], ue._preSpiderfyLatlng && (ue.closePopup(), ue.setLatLng(ue._preSpiderfyLatlng), delete ue._preSpiderfyLatlng, lt = !0, ue._setPos && (ue._setPos(Y), lt = !1), ue.clusterHide && (ue.clusterHide(), lt = !1), lt && Z.removeLayer(ue), ae && (we = ue._spiderLeg, qe = we._path, Ge = qe.getTotalLength() + 0.1, qe.style.strokeDashoffset = Ge, we.setStyle({ opacity: 0 })));
        i._ignoreMove = !1, setTimeout(function() {
          var Et = 0;
          for (Se = J.length - 1; Se >= 0; Se--)
            ue = J[Se], ue._spiderLeg && Et++;
          for (Se = J.length - 1; Se >= 0; Se--)
            ue = J[Se], ue._spiderLeg && (ue.clusterShow && ue.clusterShow(), ue.setZIndexOffset && ue.setZIndexOffset(0), Et > 1 && Z.removeLayer(ue), O.removeLayer(ue._spiderLeg), delete ue._spiderLeg);
          i._animationEnd(), i.fire("unspiderfied", {
            cluster: P,
            markers: J
          });
        }, 200);
      }
    }), L.MarkerClusterGroup.include({
      //The MarkerCluster currently spiderfied (if any)
      _spiderfied: null,
      unspiderfy: function() {
        this._unspiderfy.apply(this, arguments);
      },
      _spiderfierOnAdd: function() {
        this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this);
      },
      _spiderfierOnRemove: function() {
        this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), this._noanimationUnspiderfy();
      },
      //On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
      //This means we can define the animation they do rather than Markers doing an animation to their actual location
      _unspiderfyZoomStart: function() {
        this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
      },
      _unspiderfyZoomAnim: function(b) {
        L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._unspiderfy(b));
      },
      _unspiderfyWrapper: function() {
        this._unspiderfy();
      },
      _unspiderfy: function(b) {
        this._spiderfied && this._spiderfied.unspiderfy(b);
      },
      _noanimationUnspiderfy: function() {
        this._spiderfied && this._spiderfied._noanimationUnspiderfy();
      },
      //If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
      _unspiderfyLayer: function(b) {
        b._spiderLeg && (this._featureGroup.removeLayer(b), b.clusterShow && b.clusterShow(), b.setZIndexOffset && b.setZIndexOffset(0), this._map.removeLayer(b._spiderLeg), delete b._spiderLeg);
      }
    }), L.MarkerClusterGroup.include({
      /**
       * Updates the icon of all clusters which are parents of the given marker(s).
       * In singleMarkerMode, also updates the given marker(s) icon.
       * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
       * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
       * clusters need to be updated. If not provided, retrieves all child markers of this.
       * @returns {L.MarkerClusterGroup}
       */
      refreshClusters: function(b) {
        return b ? b instanceof L.MarkerClusterGroup ? b = b._topClusterLevel.getAllChildMarkers() : b instanceof L.LayerGroup ? b = b._layers : b instanceof L.MarkerCluster ? b = b.getAllChildMarkers() : b instanceof L.Marker && (b = [b]) : b = this._topClusterLevel.getAllChildMarkers(), this._flagParentsIconsNeedUpdate(b), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(b), this;
      },
      /**
       * Simply flags all parent clusters of the given markers as having a "dirty" icon.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _flagParentsIconsNeedUpdate: function(b) {
        var P, i;
        for (P in b)
          for (i = b[P].__parent; i; )
            i._iconNeedsUpdate = !0, i = i.__parent;
      },
      /**
       * Re-draws the icon of the supplied markers.
       * To be used in singleMarkerMode only.
       * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
       * @private
       */
      _refreshSingleMarkerModeMarkers: function(b) {
        var P, i;
        for (P in b)
          i = b[P], this.hasLayer(i) && i.setIcon(this._overrideMarkerIcon(i));
      }
    }), L.Marker.include({
      /**
       * Updates the given options in the marker's icon and refreshes the marker.
       * @param options map object of icon options.
       * @param directlyRefreshClusters boolean (optional) true to trigger
       * MCG.refreshClustersOf() right away with this single marker.
       * @returns {L.Marker}
       */
      refreshIconOptions: function(b, P) {
        var i = this.options.icon;
        return L.setOptions(i, b), this.setIcon(i), P && this.__parent && this.__parent._group.refreshClusters(this), this;
      }
    }), f.MarkerClusterGroup = y, f.MarkerCluster = w, Object.defineProperty(f, "__esModule", { value: !0 });
  });
})(cb, cb.exports);
class fC {
  constructor() {
    this.Bounds = [], this.lng = null, this.map = null, this.EventSelectChart = null, this.Polylines = [], this.CurrentPositionMarker = null, this.CurrentGPSPositionMarker = null;
  }
  init(a, f, y, w) {
    this.map = wn.map(
      a,
      {
        scrollWheelZoom: y
      }
    );
    var b = new wn.Control.FullScreen();
    this.map.addControl(b), wn.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      attribution: 'Data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(this.map);
    var P = (w + "").length > 0, i = {}, O = {};
    switch (P ? i["Thunderforest - Cycle"] = wn.tileLayer("https://a.tile.thunderforest.com/cycle/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }) : i["Open Cycle Map"] = wn.tileLayer("http://a.tile.opencyclemap.org/cycle/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Thunderforest - Outdoors"] = wn.tileLayer("https://a.tile.thunderforest.com/outddors/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Thunderforest - Transport"] = wn.tileLayer("https://a.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Thunderforest - Landscape"] = wn.tileLayer("https://a.tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=" + w, {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.thunderforest.com/">Thunderforest</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Open Street Map"] = wn.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Humanitarian Map Style"] = wn.tileLayer("https://a.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Hike & Bike"] = wn.tileLayer("http://toolserver.org/tiles/hikebike/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://hikebikemap.org/">Hike & Bike Map</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["Open Sea Map"] = wn.tileLayer("http://tiles.openseamap.org/seamark/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: 'Maps &copy; <a href="https://www.openseamap.org/">OpenSeaMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), i["GSI Map (Japan)"] = wn.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: '&copy; <a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">国土地理院</a>, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
    }), f) {
      case "OSM1": {
        i["Open Street Map"].addTo(this.map);
        break;
      }
      case "OSM2": {
        i["Thunderforest - Cycle"].addTo(this.map);
        break;
      }
      case "OSM3": {
        i["Thunderforest - Outdoors"].addTo(this.map);
        break;
      }
      case "OSM4": {
        i["Thunderforest - Transport"].addTo(this.map);
        break;
      }
      case "OSM5": {
        i["Thunderforest - Landscape"].addTo(this.map);
        break;
      }
      case "OSM7": {
        i["Humanitarian Map Style"].addTo(this.map);
        break;
      }
      case "OSM9": {
        i["Hike & Bike"].addTo(this.map);
        break;
      }
      case "OSM10": {
        i["Open Sea Map"].addTo(this.map);
        break;
      }
      case "OSM11": {
        i["GSI Map (Japan)"].addTo(this.map);
        break;
      }
      default:
        i["Open Street Map"].addTo(this.map);
    }
    wn.control.layers(i, O).addTo(this.map);
  }
  AppPolylines(a, f, y, w, b) {
    var Y;
    if (this.map != null) {
      var P = Nm.Utils.GetItemFromArray(a, 0);
      if (P != null) {
        (y == "" || y == null) && (y = "https://maps.google.com/mapfiles/kml/pal4/icon25.png");
        var i = wn.marker(wn.latLng(P), {
          icon: wn.icon({
            iconUrl: y,
            iconSize: [32, 32],
            // Size of the icon.
            iconAnchor: [16, 16]
            // Point of the icon which will correspond to marker's location.
          }),
          title: (Y = this.lng) == null ? void 0 : Y.currentPosition
        });
        i.addTo(this.map), this.CurrentPositionMarker = i;
        var O = Nm.Utils.DividePolylinesPoints(a);
        this.lng, this.EventSelectChart, this.Bounds = a.filter((J) => J != null), this.CenterMap();
        for (let J = 0; J < O.length; J++) {
          let ae = "";
          J < f.length ? ae = f[J] : ae = f[f.length - 1];
          try {
            let ue = wn.polyline(O[J], { color: ae }).addTo(this.map);
            this.Polylines.push(ue);
            let Se = this;
            this.Polylines[J].on("mousemove", function(we) {
              Se.MoveMarkerToPosition([we.latlng.lat, we.latlng.lng], !0);
            });
          } catch {
          }
        }
        if (w != "") {
          let J = a[0];
          J != null && wn.marker(wn.latLng(J), {
            icon: wn.icon({
              iconUrl: w + "",
              iconSize: [32, 32],
              // Size of the icon.
              iconAnchor: [16, 16]
              // Point of the icon which will correspond to marker's location.
            }),
            title: "Start"
          }).addTo(this.map);
        }
        if (b != "" && a[a.length - 1] != null) {
          let J = a[a.length - 1];
          if (J != null) {
            var Z = wn.marker(wn.latLng(J), {
              icon: wn.icon({
                iconUrl: b + "",
                iconSize: [32, 32],
                // size of the icon
                iconAnchor: [16, 16]
                // point of the icon which will correspond to marker's location
              }),
              title: "End"
            });
            Z.addTo(this.map);
          }
        }
      }
    }
  }
  SetCurrentGPSPosition(a, f, y) {
    this.CurrentGPSPositionMarker == null ? (f == "" && (f = "https://maps.google.com/mapfiles/kml/pal4/icon25.png"), this.map != null && (this.CurrentGPSPositionMarker = wn.marker(a, {
      icon: wn.icon({
        iconUrl: f,
        iconSize: [32, 32],
        // Size of the icon.
        iconAnchor: [16, 16]
        // Point of the icon which will correspond to marker's location.
      })
    }).addTo(this.map).bindPopup(y.currentPosition).openPopup())) : this.CurrentGPSPositionMarker.setLatLng(a), this.Bounds.push(a), this.CenterMap();
  }
  AddWaypoints(a, f) {
    var y = wn.icon({
      iconUrl: "https://maps.google.com/mapfiles/ms/micons/flag.png",
      iconSize: [32, 32],
      // Size of the icon.
      iconAnchor: [16, 16]
      // Point of the icon which will correspond to marker's location.
    });
    f != "" && (y = wn.icon({
      iconUrl: "waypointIcon",
      iconSize: [32, 32],
      // Size of the icon.
      iconAnchor: [16, 16]
      // Point of the icon which will correspond to marker's location.
    }));
    for (let Z = 0; Z < a.length; Z++) {
      var w = a[Z];
      this.Bounds.push([w.lat, w.lon]);
      var b = w.lat, P = w.lon;
      w.sym, w.type, w.img && (y.iconUrl = w.img + "");
      var i = wn.marker([b, P], { icon: y }), O = "";
      w.name == "" ? O = "<div>" + unescape(w.desc) + "</div>" : O = "<div><b>" + w.name + "</b><br />" + unescape(w.desc) + "</div>", O += "<br /><p><a href='https://maps.google.com?daddr=" + b + "," + P + "' target='_blank'>Itin&eacute;raire</a></p>", this.map != null && i.addTo(this.map).bindPopup(O);
    }
    this.CenterMap();
  }
  MoveMarkerToPosition(a, f) {
    this.CurrentPositionMarker != null && (this.CurrentPositionMarker.setLatLng(a), this.lng && this.CurrentPositionMarker.setTooltipContent(this.lng.currentPosition), f == !0 && this.EventSelectChart && this.EventSelectChart(a));
  }
  CenterMap() {
    var y;
    try {
      if (this.Bounds && this.Bounds.length > 0) {
        let w = {
          minLat: Number.POSITIVE_INFINITY,
          maxLat: Number.NEGATIVE_INFINITY,
          minLng: Number.POSITIVE_INFINITY,
          maxLng: Number.NEGATIVE_INFINITY
        };
        this.Bounds.forEach((b) => {
          if (!Array.isArray(b) || b.length !== 2)
            throw new Error("Each coordinate must be an array with [latitude, longitude].");
          const [P, i] = b;
          w.minLat = Math.min(w.minLat, P), w.maxLat = Math.max(w.maxLat, P), w.minLng = Math.min(w.minLng, i), w.maxLng = Math.max(w.maxLng, i);
        });
        var a = new wn.LatLng(w.minLat, w.minLng), f = new wn.LatLng(w.maxLat, w.maxLng);
        (y = this.map) == null || y.fitBounds(new wn.LatLngBounds(a, f));
      }
    } catch (w) {
      console.log(w);
    }
  }
  AddPhotos(a) {
    for (const f of a) {
      let y = wn.marker(f, {
        icon: wn.divIcon(
          wn.extend(
            {
              html: '<div style="background-image: url(' + f.thumbnail + ');"></div>',
              className: "leaflet-marker-photo"
            },
            f,
            {
              iconSize: [40, 40]
            }
          )
        ),
        title: f.caption || ""
      });
      y.bindPopup('<img src="' + f.url + '" /></a><p>' + f.name + "</p>", { minWidth: 500 }), y.addTo(this.map);
    }
  }
}
var lw = { exports: {} };
(function(_, a) {
  (function(f, y) {
    _.exports = y();
  })(Hm, function() {
    var f, y, w;
    function b(i, O) {
      if (!f)
        f = O;
      else if (!y)
        y = O;
      else {
        var Z = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + f + ")(sharedChunk); (" + y + ")(sharedChunk); self.onerror = null;", Y = {};
        f(Y), w = O(Y), typeof window < "u" && window && window.URL && window.URL.createObjectURL && (w.workerUrl = window.URL.createObjectURL(new Blob([Z], { type: "text/javascript" })));
      }
    }
    b(["exports"], function(i) {
      function O(r) {
        return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
      }
      var Z, Y = {}, J = {};
      function ae() {
        if (Z)
          return J;
        Z = 1, Object.defineProperty(J, "__esModule", { value: !0 }), J.setMatrixArrayType = function(u) {
          J.ARRAY_TYPE = e = u;
        }, J.toRadian = function(u) {
          return u * o;
        }, J.equals = function(u, l) {
          return Math.abs(u - l) <= r * Math.max(1, Math.abs(u), Math.abs(l));
        }, J.RANDOM = J.ARRAY_TYPE = J.EPSILON = void 0;
        var r = 1e-6;
        J.EPSILON = r;
        var e = typeof Float32Array < "u" ? Float32Array : Array;
        J.ARRAY_TYPE = e;
        var n = Math.random;
        J.RANDOM = n;
        var o = Math.PI / 180;
        return Math.hypot || (Math.hypot = function() {
          for (var u = 0, l = arguments.length; l--; )
            u += arguments[l] * arguments[l];
          return Math.sqrt(u);
        }), J;
      }
      var ue, Se = {};
      function we() {
        if (ue)
          return Se;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, r(l);
        }
        ue = 1, Object.defineProperty(Se, "__esModule", { value: !0 }), Se.create = function() {
          var l = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0), l[0] = 1, l[3] = 1, l;
        }, Se.clone = function(l) {
          var d = new e.ARRAY_TYPE(4);
          return d[0] = l[0], d[1] = l[1], d[2] = l[2], d[3] = l[3], d;
        }, Se.copy = function(l, d) {
          return l[0] = d[0], l[1] = d[1], l[2] = d[2], l[3] = d[3], l;
        }, Se.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l;
        }, Se.fromValues = function(l, d, v, M) {
          var D = new e.ARRAY_TYPE(4);
          return D[0] = l, D[1] = d, D[2] = v, D[3] = M, D;
        }, Se.set = function(l, d, v, M, D) {
          return l[0] = d, l[1] = v, l[2] = M, l[3] = D, l;
        }, Se.transpose = function(l, d) {
          if (l === d) {
            var v = d[1];
            l[1] = d[2], l[2] = v;
          } else
            l[0] = d[0], l[1] = d[2], l[2] = d[1], l[3] = d[3];
          return l;
        }, Se.invert = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = v * x - D * M;
          return E ? (l[0] = x * (E = 1 / E), l[1] = -M * E, l[2] = -D * E, l[3] = v * E, l) : null;
        }, Se.adjoint = function(l, d) {
          var v = d[0];
          return l[0] = d[3], l[1] = -d[1], l[2] = -d[2], l[3] = v, l;
        }, Se.determinant = function(l) {
          return l[0] * l[3] - l[2] * l[1];
        }, Se.multiply = o, Se.rotate = function(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = Math.sin(v), S = Math.cos(v);
          return l[0] = M * S + x * I, l[1] = D * S + E * I, l[2] = M * -I + x * S, l[3] = D * -I + E * S, l;
        }, Se.scale = function(l, d, v) {
          var M = d[1], D = d[2], x = d[3], E = v[0], I = v[1];
          return l[0] = d[0] * E, l[1] = M * E, l[2] = D * I, l[3] = x * I, l;
        }, Se.fromRotation = function(l, d) {
          var v = Math.sin(d), M = Math.cos(d);
          return l[0] = M, l[1] = v, l[2] = -v, l[3] = M, l;
        }, Se.fromScaling = function(l, d) {
          return l[0] = d[0], l[1] = 0, l[2] = 0, l[3] = d[1], l;
        }, Se.str = function(l) {
          return "mat2(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ")";
        }, Se.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3]);
        }, Se.LDU = function(l, d, v, M) {
          return l[2] = M[2] / M[0], v[0] = M[0], v[1] = M[1], v[3] = M[3] - l[2] * v[1], [l, d, v];
        }, Se.add = function(l, d, v) {
          return l[0] = d[0] + v[0], l[1] = d[1] + v[1], l[2] = d[2] + v[2], l[3] = d[3] + v[3], l;
        }, Se.subtract = u, Se.exactEquals = function(l, d) {
          return l[0] === d[0] && l[1] === d[1] && l[2] === d[2] && l[3] === d[3];
        }, Se.equals = function(l, d) {
          var v = l[0], M = l[1], D = l[2], x = l[3], E = d[0], I = d[1], S = d[2], C = d[3];
          return Math.abs(v - E) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(E)) && Math.abs(M - I) <= e.EPSILON * Math.max(1, Math.abs(M), Math.abs(I)) && Math.abs(D - S) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(S)) && Math.abs(x - C) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(C));
        }, Se.multiplyScalar = function(l, d, v) {
          return l[0] = d[0] * v, l[1] = d[1] * v, l[2] = d[2] * v, l[3] = d[3] * v, l;
        }, Se.multiplyScalarAndAdd = function(l, d, v, M) {
          return l[0] = d[0] + v[0] * M, l[1] = d[1] + v[1] * M, l[2] = d[2] + v[2] * M, l[3] = d[3] + v[3] * M, l;
        }, Se.sub = Se.mul = void 0;
        var e = function(l, d) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var M = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var E = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              E && (E.get || E.set) ? Object.defineProperty(M, x, E) : M[x] = l[x];
            }
          return M.default = l, v && v.set(l, M), M;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var d = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(M) {
            return M ? v : d;
          })(l);
        }
        function o(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = v[0], S = v[1], C = v[2], k = v[3];
          return l[0] = M * I + x * S, l[1] = D * I + E * S, l[2] = M * C + x * k, l[3] = D * C + E * k, l;
        }
        function u(l, d, v) {
          return l[0] = d[0] - v[0], l[1] = d[1] - v[1], l[2] = d[2] - v[2], l[3] = d[3] - v[3], l;
        }
        return Se.mul = o, Se.sub = u, Se;
      }
      var qe, Ge = {};
      function lt() {
        if (qe)
          return Ge;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, r(l);
        }
        qe = 1, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.create = function() {
          var l = new e.ARRAY_TYPE(6);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0, l[4] = 0, l[5] = 0), l[0] = 1, l[3] = 1, l;
        }, Ge.clone = function(l) {
          var d = new e.ARRAY_TYPE(6);
          return d[0] = l[0], d[1] = l[1], d[2] = l[2], d[3] = l[3], d[4] = l[4], d[5] = l[5], d;
        }, Ge.copy = function(l, d) {
          return l[0] = d[0], l[1] = d[1], l[2] = d[2], l[3] = d[3], l[4] = d[4], l[5] = d[5], l;
        }, Ge.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l[4] = 0, l[5] = 0, l;
        }, Ge.fromValues = function(l, d, v, M, D, x) {
          var E = new e.ARRAY_TYPE(6);
          return E[0] = l, E[1] = d, E[2] = v, E[3] = M, E[4] = D, E[5] = x, E;
        }, Ge.set = function(l, d, v, M, D, x, E) {
          return l[0] = d, l[1] = v, l[2] = M, l[3] = D, l[4] = x, l[5] = E, l;
        }, Ge.invert = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = d[4], I = d[5], S = v * x - M * D;
          return S ? (l[0] = x * (S = 1 / S), l[1] = -M * S, l[2] = -D * S, l[3] = v * S, l[4] = (D * I - x * E) * S, l[5] = (M * E - v * I) * S, l) : null;
        }, Ge.determinant = function(l) {
          return l[0] * l[3] - l[1] * l[2];
        }, Ge.multiply = o, Ge.rotate = function(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = Math.sin(v), k = Math.cos(v);
          return l[0] = M * k + x * C, l[1] = D * k + E * C, l[2] = M * -C + x * k, l[3] = D * -C + E * k, l[4] = I, l[5] = S, l;
        }, Ge.scale = function(l, d, v) {
          var M = d[1], D = d[2], x = d[3], E = d[4], I = d[5], S = v[0], C = v[1];
          return l[0] = d[0] * S, l[1] = M * S, l[2] = D * C, l[3] = x * C, l[4] = E, l[5] = I, l;
        }, Ge.translate = function(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = v[0], k = v[1];
          return l[0] = M, l[1] = D, l[2] = x, l[3] = E, l[4] = M * C + x * k + I, l[5] = D * C + E * k + S, l;
        }, Ge.fromRotation = function(l, d) {
          var v = Math.sin(d), M = Math.cos(d);
          return l[0] = M, l[1] = v, l[2] = -v, l[3] = M, l[4] = 0, l[5] = 0, l;
        }, Ge.fromScaling = function(l, d) {
          return l[0] = d[0], l[1] = 0, l[2] = 0, l[3] = d[1], l[4] = 0, l[5] = 0, l;
        }, Ge.fromTranslation = function(l, d) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 1, l[4] = d[0], l[5] = d[1], l;
        }, Ge.str = function(l) {
          return "mat2d(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ")";
        }, Ge.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1);
        }, Ge.add = function(l, d, v) {
          return l[0] = d[0] + v[0], l[1] = d[1] + v[1], l[2] = d[2] + v[2], l[3] = d[3] + v[3], l[4] = d[4] + v[4], l[5] = d[5] + v[5], l;
        }, Ge.subtract = u, Ge.multiplyScalar = function(l, d, v) {
          return l[0] = d[0] * v, l[1] = d[1] * v, l[2] = d[2] * v, l[3] = d[3] * v, l[4] = d[4] * v, l[5] = d[5] * v, l;
        }, Ge.multiplyScalarAndAdd = function(l, d, v, M) {
          return l[0] = d[0] + v[0] * M, l[1] = d[1] + v[1] * M, l[2] = d[2] + v[2] * M, l[3] = d[3] + v[3] * M, l[4] = d[4] + v[4] * M, l[5] = d[5] + v[5] * M, l;
        }, Ge.exactEquals = function(l, d) {
          return l[0] === d[0] && l[1] === d[1] && l[2] === d[2] && l[3] === d[3] && l[4] === d[4] && l[5] === d[5];
        }, Ge.equals = function(l, d) {
          var v = l[0], M = l[1], D = l[2], x = l[3], E = l[4], I = l[5], S = d[0], C = d[1], k = d[2], V = d[3], U = d[4], q = d[5];
          return Math.abs(v - S) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(S)) && Math.abs(M - C) <= e.EPSILON * Math.max(1, Math.abs(M), Math.abs(C)) && Math.abs(D - k) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(k)) && Math.abs(x - V) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(V)) && Math.abs(E - U) <= e.EPSILON * Math.max(1, Math.abs(E), Math.abs(U)) && Math.abs(I - q) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(q));
        }, Ge.sub = Ge.mul = void 0;
        var e = function(l, d) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var M = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var E = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              E && (E.get || E.set) ? Object.defineProperty(M, x, E) : M[x] = l[x];
            }
          return M.default = l, v && v.set(l, M), M;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var d = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(M) {
            return M ? v : d;
          })(l);
        }
        function o(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = v[0], k = v[1], V = v[2], U = v[3], q = v[4], $ = v[5];
          return l[0] = M * C + x * k, l[1] = D * C + E * k, l[2] = M * V + x * U, l[3] = D * V + E * U, l[4] = M * q + x * $ + I, l[5] = D * q + E * $ + S, l;
        }
        function u(l, d, v) {
          return l[0] = d[0] - v[0], l[1] = d[1] - v[1], l[2] = d[2] - v[2], l[3] = d[3] - v[3], l[4] = d[4] - v[4], l[5] = d[5] - v[5], l;
        }
        return Ge.mul = o, Ge.sub = u, Ge;
      }
      var Et, ut = {};
      function bt() {
        if (Et)
          return ut;
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, r(l);
        }
        Et = 1, Object.defineProperty(ut, "__esModule", { value: !0 }), ut.create = function() {
          var l = new e.ARRAY_TYPE(9);
          return e.ARRAY_TYPE != Float32Array && (l[1] = 0, l[2] = 0, l[3] = 0, l[5] = 0, l[6] = 0, l[7] = 0), l[0] = 1, l[4] = 1, l[8] = 1, l;
        }, ut.fromMat4 = function(l, d) {
          return l[0] = d[0], l[1] = d[1], l[2] = d[2], l[3] = d[4], l[4] = d[5], l[5] = d[6], l[6] = d[8], l[7] = d[9], l[8] = d[10], l;
        }, ut.clone = function(l) {
          var d = new e.ARRAY_TYPE(9);
          return d[0] = l[0], d[1] = l[1], d[2] = l[2], d[3] = l[3], d[4] = l[4], d[5] = l[5], d[6] = l[6], d[7] = l[7], d[8] = l[8], d;
        }, ut.copy = function(l, d) {
          return l[0] = d[0], l[1] = d[1], l[2] = d[2], l[3] = d[3], l[4] = d[4], l[5] = d[5], l[6] = d[6], l[7] = d[7], l[8] = d[8], l;
        }, ut.fromValues = function(l, d, v, M, D, x, E, I, S) {
          var C = new e.ARRAY_TYPE(9);
          return C[0] = l, C[1] = d, C[2] = v, C[3] = M, C[4] = D, C[5] = x, C[6] = E, C[7] = I, C[8] = S, C;
        }, ut.set = function(l, d, v, M, D, x, E, I, S, C) {
          return l[0] = d, l[1] = v, l[2] = M, l[3] = D, l[4] = x, l[5] = E, l[6] = I, l[7] = S, l[8] = C, l;
        }, ut.identity = function(l) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 1, l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ut.transpose = function(l, d) {
          if (l === d) {
            var v = d[1], M = d[2], D = d[5];
            l[1] = d[3], l[2] = d[6], l[3] = v, l[5] = d[7], l[6] = M, l[7] = D;
          } else
            l[0] = d[0], l[1] = d[3], l[2] = d[6], l[3] = d[1], l[4] = d[4], l[5] = d[7], l[6] = d[2], l[7] = d[5], l[8] = d[8];
          return l;
        }, ut.invert = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = d[4], I = d[5], S = d[6], C = d[7], k = d[8], V = k * E - I * C, U = -k * x + I * S, q = C * x - E * S, $ = v * V + M * U + D * q;
          return $ ? (l[0] = V * ($ = 1 / $), l[1] = (-k * M + D * C) * $, l[2] = (I * M - D * E) * $, l[3] = U * $, l[4] = (k * v - D * S) * $, l[5] = (-I * v + D * x) * $, l[6] = q * $, l[7] = (-C * v + M * S) * $, l[8] = (E * v - M * x) * $, l) : null;
        }, ut.adjoint = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = d[4], I = d[5], S = d[6], C = d[7], k = d[8];
          return l[0] = E * k - I * C, l[1] = D * C - M * k, l[2] = M * I - D * E, l[3] = I * S - x * k, l[4] = v * k - D * S, l[5] = D * x - v * I, l[6] = x * C - E * S, l[7] = M * S - v * C, l[8] = v * E - M * x, l;
        }, ut.determinant = function(l) {
          var d = l[3], v = l[4], M = l[5], D = l[6], x = l[7], E = l[8];
          return l[0] * (E * v - M * x) + l[1] * (-E * d + M * D) + l[2] * (x * d - v * D);
        }, ut.multiply = o, ut.translate = function(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = d[6], k = d[7], V = d[8], U = v[0], q = v[1];
          return l[0] = M, l[1] = D, l[2] = x, l[3] = E, l[4] = I, l[5] = S, l[6] = U * M + q * E + C, l[7] = U * D + q * I + k, l[8] = U * x + q * S + V, l;
        }, ut.rotate = function(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = d[6], k = d[7], V = d[8], U = Math.sin(v), q = Math.cos(v);
          return l[0] = q * M + U * E, l[1] = q * D + U * I, l[2] = q * x + U * S, l[3] = q * E - U * M, l[4] = q * I - U * D, l[5] = q * S - U * x, l[6] = C, l[7] = k, l[8] = V, l;
        }, ut.scale = function(l, d, v) {
          var M = v[0], D = v[1];
          return l[0] = M * d[0], l[1] = M * d[1], l[2] = M * d[2], l[3] = D * d[3], l[4] = D * d[4], l[5] = D * d[5], l[6] = d[6], l[7] = d[7], l[8] = d[8], l;
        }, ut.fromTranslation = function(l, d) {
          return l[0] = 1, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = 1, l[5] = 0, l[6] = d[0], l[7] = d[1], l[8] = 1, l;
        }, ut.fromRotation = function(l, d) {
          var v = Math.sin(d), M = Math.cos(d);
          return l[0] = M, l[1] = v, l[2] = 0, l[3] = -v, l[4] = M, l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ut.fromScaling = function(l, d) {
          return l[0] = d[0], l[1] = 0, l[2] = 0, l[3] = 0, l[4] = d[1], l[5] = 0, l[6] = 0, l[7] = 0, l[8] = 1, l;
        }, ut.fromMat2d = function(l, d) {
          return l[0] = d[0], l[1] = d[1], l[2] = 0, l[3] = d[2], l[4] = d[3], l[5] = 0, l[6] = d[4], l[7] = d[5], l[8] = 1, l;
        }, ut.fromQuat = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = v + v, I = M + M, S = D + D, C = v * E, k = M * E, V = M * I, U = D * E, q = D * I, $ = D * S, H = x * E, K = x * I, Q = x * S;
          return l[0] = 1 - V - $, l[3] = k - Q, l[6] = U + K, l[1] = k + Q, l[4] = 1 - C - $, l[7] = q - H, l[2] = U - K, l[5] = q + H, l[8] = 1 - C - V, l;
        }, ut.normalFromMat4 = function(l, d) {
          var v = d[0], M = d[1], D = d[2], x = d[3], E = d[4], I = d[5], S = d[6], C = d[7], k = d[8], V = d[9], U = d[10], q = d[11], $ = d[12], H = d[13], K = d[14], Q = d[15], ie = v * I - M * E, fe = v * S - D * E, de = v * C - x * E, he = M * S - D * I, Me = M * C - x * I, me = D * C - x * S, Ee = k * H - V * $, ze = k * K - U * $, Ie = k * Q - q * $, Re = V * K - U * H, Ve = V * Q - q * H, Ue = U * Q - q * K, Fe = ie * Ue - fe * Ve + de * Re + he * Ie - Me * ze + me * Ee;
          return Fe ? (l[0] = (I * Ue - S * Ve + C * Re) * (Fe = 1 / Fe), l[1] = (S * Ie - E * Ue - C * ze) * Fe, l[2] = (E * Ve - I * Ie + C * Ee) * Fe, l[3] = (D * Ve - M * Ue - x * Re) * Fe, l[4] = (v * Ue - D * Ie + x * ze) * Fe, l[5] = (M * Ie - v * Ve - x * Ee) * Fe, l[6] = (H * me - K * Me + Q * he) * Fe, l[7] = (K * de - $ * me - Q * fe) * Fe, l[8] = ($ * Me - H * de + Q * ie) * Fe, l) : null;
        }, ut.projection = function(l, d, v) {
          return l[0] = 2 / d, l[1] = 0, l[2] = 0, l[3] = 0, l[4] = -2 / v, l[5] = 0, l[6] = -1, l[7] = 1, l[8] = 1, l;
        }, ut.str = function(l) {
          return "mat3(" + l[0] + ", " + l[1] + ", " + l[2] + ", " + l[3] + ", " + l[4] + ", " + l[5] + ", " + l[6] + ", " + l[7] + ", " + l[8] + ")";
        }, ut.frob = function(l) {
          return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8]);
        }, ut.add = function(l, d, v) {
          return l[0] = d[0] + v[0], l[1] = d[1] + v[1], l[2] = d[2] + v[2], l[3] = d[3] + v[3], l[4] = d[4] + v[4], l[5] = d[5] + v[5], l[6] = d[6] + v[6], l[7] = d[7] + v[7], l[8] = d[8] + v[8], l;
        }, ut.subtract = u, ut.multiplyScalar = function(l, d, v) {
          return l[0] = d[0] * v, l[1] = d[1] * v, l[2] = d[2] * v, l[3] = d[3] * v, l[4] = d[4] * v, l[5] = d[5] * v, l[6] = d[6] * v, l[7] = d[7] * v, l[8] = d[8] * v, l;
        }, ut.multiplyScalarAndAdd = function(l, d, v, M) {
          return l[0] = d[0] + v[0] * M, l[1] = d[1] + v[1] * M, l[2] = d[2] + v[2] * M, l[3] = d[3] + v[3] * M, l[4] = d[4] + v[4] * M, l[5] = d[5] + v[5] * M, l[6] = d[6] + v[6] * M, l[7] = d[7] + v[7] * M, l[8] = d[8] + v[8] * M, l;
        }, ut.exactEquals = function(l, d) {
          return l[0] === d[0] && l[1] === d[1] && l[2] === d[2] && l[3] === d[3] && l[4] === d[4] && l[5] === d[5] && l[6] === d[6] && l[7] === d[7] && l[8] === d[8];
        }, ut.equals = function(l, d) {
          var v = l[0], M = l[1], D = l[2], x = l[3], E = l[4], I = l[5], S = l[6], C = l[7], k = l[8], V = d[0], U = d[1], q = d[2], $ = d[3], H = d[4], K = d[5], Q = d[6], ie = d[7], fe = d[8];
          return Math.abs(v - V) <= e.EPSILON * Math.max(1, Math.abs(v), Math.abs(V)) && Math.abs(M - U) <= e.EPSILON * Math.max(1, Math.abs(M), Math.abs(U)) && Math.abs(D - q) <= e.EPSILON * Math.max(1, Math.abs(D), Math.abs(q)) && Math.abs(x - $) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs($)) && Math.abs(E - H) <= e.EPSILON * Math.max(1, Math.abs(E), Math.abs(H)) && Math.abs(I - K) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(K)) && Math.abs(S - Q) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(Q)) && Math.abs(C - ie) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(ie)) && Math.abs(k - fe) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(fe));
        }, ut.sub = ut.mul = void 0;
        var e = function(l, d) {
          if (l && l.__esModule)
            return l;
          if (l === null || r(l) !== "object" && typeof l != "function")
            return { default: l };
          var v = n(void 0);
          if (v && v.has(l))
            return v.get(l);
          var M = {}, D = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var x in l)
            if (x !== "default" && Object.prototype.hasOwnProperty.call(l, x)) {
              var E = D ? Object.getOwnPropertyDescriptor(l, x) : null;
              E && (E.get || E.set) ? Object.defineProperty(M, x, E) : M[x] = l[x];
            }
          return M.default = l, v && v.set(l, M), M;
        }(ae());
        function n(l) {
          if (typeof WeakMap != "function")
            return null;
          var d = /* @__PURE__ */ new WeakMap(), v = /* @__PURE__ */ new WeakMap();
          return (n = function(M) {
            return M ? v : d;
          })(l);
        }
        function o(l, d, v) {
          var M = d[0], D = d[1], x = d[2], E = d[3], I = d[4], S = d[5], C = d[6], k = d[7], V = d[8], U = v[0], q = v[1], $ = v[2], H = v[3], K = v[4], Q = v[5], ie = v[6], fe = v[7], de = v[8];
          return l[0] = U * M + q * E + $ * C, l[1] = U * D + q * I + $ * k, l[2] = U * x + q * S + $ * V, l[3] = H * M + K * E + Q * C, l[4] = H * D + K * I + Q * k, l[5] = H * x + K * S + Q * V, l[6] = ie * M + fe * E + de * C, l[7] = ie * D + fe * I + de * k, l[8] = ie * x + fe * S + de * V, l;
        }
        function u(l, d, v) {
          return l[0] = d[0] - v[0], l[1] = d[1] - v[1], l[2] = d[2] - v[2], l[3] = d[3] - v[3], l[4] = d[4] - v[4], l[5] = d[5] - v[5], l[6] = d[6] - v[6], l[7] = d[7] - v[7], l[8] = d[8] - v[8], l;
        }
        return ut.mul = o, ut.sub = u, ut;
      }
      var Vt, pt = {};
      function Gt() {
        if (Vt)
          return pt;
        function r(x) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          }, r(x);
        }
        Vt = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.create = function() {
          var x = new e.ARRAY_TYPE(16);
          return e.ARRAY_TYPE != Float32Array && (x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0), x[0] = 1, x[5] = 1, x[10] = 1, x[15] = 1, x;
        }, pt.clone = function(x) {
          var E = new e.ARRAY_TYPE(16);
          return E[0] = x[0], E[1] = x[1], E[2] = x[2], E[3] = x[3], E[4] = x[4], E[5] = x[5], E[6] = x[6], E[7] = x[7], E[8] = x[8], E[9] = x[9], E[10] = x[10], E[11] = x[11], E[12] = x[12], E[13] = x[13], E[14] = x[14], E[15] = x[15], E;
        }, pt.copy = function(x, E) {
          return x[0] = E[0], x[1] = E[1], x[2] = E[2], x[3] = E[3], x[4] = E[4], x[5] = E[5], x[6] = E[6], x[7] = E[7], x[8] = E[8], x[9] = E[9], x[10] = E[10], x[11] = E[11], x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15], x;
        }, pt.fromValues = function(x, E, I, S, C, k, V, U, q, $, H, K, Q, ie, fe, de) {
          var he = new e.ARRAY_TYPE(16);
          return he[0] = x, he[1] = E, he[2] = I, he[3] = S, he[4] = C, he[5] = k, he[6] = V, he[7] = U, he[8] = q, he[9] = $, he[10] = H, he[11] = K, he[12] = Q, he[13] = ie, he[14] = fe, he[15] = de, he;
        }, pt.set = function(x, E, I, S, C, k, V, U, q, $, H, K, Q, ie, fe, de, he) {
          return x[0] = E, x[1] = I, x[2] = S, x[3] = C, x[4] = k, x[5] = V, x[6] = U, x[7] = q, x[8] = $, x[9] = H, x[10] = K, x[11] = Q, x[12] = ie, x[13] = fe, x[14] = de, x[15] = he, x;
        }, pt.identity = o, pt.transpose = function(x, E) {
          if (x === E) {
            var I = E[1], S = E[2], C = E[3], k = E[6], V = E[7], U = E[11];
            x[1] = E[4], x[2] = E[8], x[3] = E[12], x[4] = I, x[6] = E[9], x[7] = E[13], x[8] = S, x[9] = k, x[11] = E[14], x[12] = C, x[13] = V, x[14] = U;
          } else
            x[0] = E[0], x[1] = E[4], x[2] = E[8], x[3] = E[12], x[4] = E[1], x[5] = E[5], x[6] = E[9], x[7] = E[13], x[8] = E[2], x[9] = E[6], x[10] = E[10], x[11] = E[14], x[12] = E[3], x[13] = E[7], x[14] = E[11], x[15] = E[15];
          return x;
        }, pt.invert = function(x, E) {
          var I = E[0], S = E[1], C = E[2], k = E[3], V = E[4], U = E[5], q = E[6], $ = E[7], H = E[8], K = E[9], Q = E[10], ie = E[11], fe = E[12], de = E[13], he = E[14], Me = E[15], me = I * U - S * V, Ee = I * q - C * V, ze = I * $ - k * V, Ie = S * q - C * U, Re = S * $ - k * U, Ve = C * $ - k * q, Ue = H * de - K * fe, Fe = H * he - Q * fe, et = H * Me - ie * fe, dt = K * he - Q * de, tt = K * Me - ie * de, Tt = Q * Me - ie * he, vt = me * Tt - Ee * tt + ze * dt + Ie * et - Re * Fe + Ve * Ue;
          return vt ? (x[0] = (U * Tt - q * tt + $ * dt) * (vt = 1 / vt), x[1] = (C * tt - S * Tt - k * dt) * vt, x[2] = (de * Ve - he * Re + Me * Ie) * vt, x[3] = (Q * Re - K * Ve - ie * Ie) * vt, x[4] = (q * et - V * Tt - $ * Fe) * vt, x[5] = (I * Tt - C * et + k * Fe) * vt, x[6] = (he * ze - fe * Ve - Me * Ee) * vt, x[7] = (H * Ve - Q * ze + ie * Ee) * vt, x[8] = (V * tt - U * et + $ * Ue) * vt, x[9] = (S * et - I * tt - k * Ue) * vt, x[10] = (fe * Re - de * ze + Me * me) * vt, x[11] = (K * ze - H * Re - ie * me) * vt, x[12] = (U * Fe - V * dt - q * Ue) * vt, x[13] = (I * dt - S * Fe + C * Ue) * vt, x[14] = (de * Ee - fe * Ie - he * me) * vt, x[15] = (H * Ie - K * Ee + Q * me) * vt, x) : null;
        }, pt.adjoint = function(x, E) {
          var I = E[0], S = E[1], C = E[2], k = E[3], V = E[4], U = E[5], q = E[6], $ = E[7], H = E[8], K = E[9], Q = E[10], ie = E[11], fe = E[12], de = E[13], he = E[14], Me = E[15];
          return x[0] = U * (Q * Me - ie * he) - K * (q * Me - $ * he) + de * (q * ie - $ * Q), x[1] = -(S * (Q * Me - ie * he) - K * (C * Me - k * he) + de * (C * ie - k * Q)), x[2] = S * (q * Me - $ * he) - U * (C * Me - k * he) + de * (C * $ - k * q), x[3] = -(S * (q * ie - $ * Q) - U * (C * ie - k * Q) + K * (C * $ - k * q)), x[4] = -(V * (Q * Me - ie * he) - H * (q * Me - $ * he) + fe * (q * ie - $ * Q)), x[5] = I * (Q * Me - ie * he) - H * (C * Me - k * he) + fe * (C * ie - k * Q), x[6] = -(I * (q * Me - $ * he) - V * (C * Me - k * he) + fe * (C * $ - k * q)), x[7] = I * (q * ie - $ * Q) - V * (C * ie - k * Q) + H * (C * $ - k * q), x[8] = V * (K * Me - ie * de) - H * (U * Me - $ * de) + fe * (U * ie - $ * K), x[9] = -(I * (K * Me - ie * de) - H * (S * Me - k * de) + fe * (S * ie - k * K)), x[10] = I * (U * Me - $ * de) - V * (S * Me - k * de) + fe * (S * $ - k * U), x[11] = -(I * (U * ie - $ * K) - V * (S * ie - k * K) + H * (S * $ - k * U)), x[12] = -(V * (K * he - Q * de) - H * (U * he - q * de) + fe * (U * Q - q * K)), x[13] = I * (K * he - Q * de) - H * (S * he - C * de) + fe * (S * Q - C * K), x[14] = -(I * (U * he - q * de) - V * (S * he - C * de) + fe * (S * q - C * U)), x[15] = I * (U * Q - q * K) - V * (S * Q - C * K) + H * (S * q - C * U), x;
        }, pt.determinant = function(x) {
          var E = x[0], I = x[1], S = x[2], C = x[3], k = x[4], V = x[5], U = x[6], q = x[7], $ = x[8], H = x[9], K = x[10], Q = x[11], ie = x[12], fe = x[13], de = x[14], he = x[15];
          return (E * V - I * k) * (K * he - Q * de) - (E * U - S * k) * (H * he - Q * fe) + (E * q - C * k) * (H * de - K * fe) + (I * U - S * V) * ($ * he - Q * ie) - (I * q - C * V) * ($ * de - K * ie) + (S * q - C * U) * ($ * fe - H * ie);
        }, pt.multiply = u, pt.translate = function(x, E, I) {
          var S, C, k, V, U, q, $, H, K, Q, ie, fe, de = I[0], he = I[1], Me = I[2];
          return E === x ? (x[12] = E[0] * de + E[4] * he + E[8] * Me + E[12], x[13] = E[1] * de + E[5] * he + E[9] * Me + E[13], x[14] = E[2] * de + E[6] * he + E[10] * Me + E[14], x[15] = E[3] * de + E[7] * he + E[11] * Me + E[15]) : (C = E[1], k = E[2], V = E[3], U = E[4], q = E[5], $ = E[6], H = E[7], K = E[8], Q = E[9], ie = E[10], fe = E[11], x[0] = S = E[0], x[1] = C, x[2] = k, x[3] = V, x[4] = U, x[5] = q, x[6] = $, x[7] = H, x[8] = K, x[9] = Q, x[10] = ie, x[11] = fe, x[12] = S * de + U * he + K * Me + E[12], x[13] = C * de + q * he + Q * Me + E[13], x[14] = k * de + $ * he + ie * Me + E[14], x[15] = V * de + H * he + fe * Me + E[15]), x;
        }, pt.scale = function(x, E, I) {
          var S = I[0], C = I[1], k = I[2];
          return x[0] = E[0] * S, x[1] = E[1] * S, x[2] = E[2] * S, x[3] = E[3] * S, x[4] = E[4] * C, x[5] = E[5] * C, x[6] = E[6] * C, x[7] = E[7] * C, x[8] = E[8] * k, x[9] = E[9] * k, x[10] = E[10] * k, x[11] = E[11] * k, x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15], x;
        }, pt.rotate = function(x, E, I, S) {
          var C, k, V, U, q, $, H, K, Q, ie, fe, de, he, Me, me, Ee, ze, Ie, Re, Ve, Ue, Fe, et, dt, tt = S[0], Tt = S[1], vt = S[2], Pt = Math.hypot(tt, Tt, vt);
          return Pt < e.EPSILON ? null : (tt *= Pt = 1 / Pt, Tt *= Pt, vt *= Pt, C = Math.sin(I), k = Math.cos(I), q = E[1], $ = E[2], H = E[3], Q = E[5], ie = E[6], fe = E[7], he = E[9], Me = E[10], me = E[11], Ee = tt * tt * (V = 1 - k) + k, Re = tt * Tt * V - vt * C, Ve = Tt * Tt * V + k, Ue = vt * Tt * V + tt * C, Fe = tt * vt * V + Tt * C, et = Tt * vt * V - tt * C, dt = vt * vt * V + k, x[0] = (U = E[0]) * Ee + (K = E[4]) * (ze = Tt * tt * V + vt * C) + (de = E[8]) * (Ie = vt * tt * V - Tt * C), x[1] = q * Ee + Q * ze + he * Ie, x[2] = $ * Ee + ie * ze + Me * Ie, x[3] = H * Ee + fe * ze + me * Ie, x[4] = U * Re + K * Ve + de * Ue, x[5] = q * Re + Q * Ve + he * Ue, x[6] = $ * Re + ie * Ve + Me * Ue, x[7] = H * Re + fe * Ve + me * Ue, x[8] = U * Fe + K * et + de * dt, x[9] = q * Fe + Q * et + he * dt, x[10] = $ * Fe + ie * et + Me * dt, x[11] = H * Fe + fe * et + me * dt, E !== x && (x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15]), x);
        }, pt.rotateX = function(x, E, I) {
          var S = Math.sin(I), C = Math.cos(I), k = E[4], V = E[5], U = E[6], q = E[7], $ = E[8], H = E[9], K = E[10], Q = E[11];
          return E !== x && (x[0] = E[0], x[1] = E[1], x[2] = E[2], x[3] = E[3], x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15]), x[4] = k * C + $ * S, x[5] = V * C + H * S, x[6] = U * C + K * S, x[7] = q * C + Q * S, x[8] = $ * C - k * S, x[9] = H * C - V * S, x[10] = K * C - U * S, x[11] = Q * C - q * S, x;
        }, pt.rotateY = function(x, E, I) {
          var S = Math.sin(I), C = Math.cos(I), k = E[0], V = E[1], U = E[2], q = E[3], $ = E[8], H = E[9], K = E[10], Q = E[11];
          return E !== x && (x[4] = E[4], x[5] = E[5], x[6] = E[6], x[7] = E[7], x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15]), x[0] = k * C - $ * S, x[1] = V * C - H * S, x[2] = U * C - K * S, x[3] = q * C - Q * S, x[8] = k * S + $ * C, x[9] = V * S + H * C, x[10] = U * S + K * C, x[11] = q * S + Q * C, x;
        }, pt.rotateZ = function(x, E, I) {
          var S = Math.sin(I), C = Math.cos(I), k = E[0], V = E[1], U = E[2], q = E[3], $ = E[4], H = E[5], K = E[6], Q = E[7];
          return E !== x && (x[8] = E[8], x[9] = E[9], x[10] = E[10], x[11] = E[11], x[12] = E[12], x[13] = E[13], x[14] = E[14], x[15] = E[15]), x[0] = k * C + $ * S, x[1] = V * C + H * S, x[2] = U * C + K * S, x[3] = q * C + Q * S, x[4] = $ * C - k * S, x[5] = H * C - V * S, x[6] = K * C - U * S, x[7] = Q * C - q * S, x;
        }, pt.fromTranslation = function(x, E) {
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = E[0], x[13] = E[1], x[14] = E[2], x[15] = 1, x;
        }, pt.fromScaling = function(x, E) {
          return x[0] = E[0], x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = E[1], x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = E[2], x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromRotation = function(x, E, I) {
          var S, C, k, V = I[0], U = I[1], q = I[2], $ = Math.hypot(V, U, q);
          return $ < e.EPSILON ? null : (V *= $ = 1 / $, U *= $, q *= $, S = Math.sin(E), C = Math.cos(E), x[0] = V * V * (k = 1 - C) + C, x[1] = U * V * k + q * S, x[2] = q * V * k - U * S, x[3] = 0, x[4] = V * U * k - q * S, x[5] = U * U * k + C, x[6] = q * U * k + V * S, x[7] = 0, x[8] = V * q * k + U * S, x[9] = U * q * k - V * S, x[10] = q * q * k + C, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x);
        }, pt.fromXRotation = function(x, E) {
          var I = Math.sin(E), S = Math.cos(E);
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = S, x[6] = I, x[7] = 0, x[8] = 0, x[9] = -I, x[10] = S, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromYRotation = function(x, E) {
          var I = Math.sin(E), S = Math.cos(E);
          return x[0] = S, x[1] = 0, x[2] = -I, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = I, x[9] = 0, x[10] = S, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromZRotation = function(x, E) {
          var I = Math.sin(E), S = Math.cos(E);
          return x[0] = S, x[1] = I, x[2] = 0, x[3] = 0, x[4] = -I, x[5] = S, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.fromRotationTranslation = l, pt.fromQuat2 = function(x, E) {
          var I = new e.ARRAY_TYPE(3), S = -E[0], C = -E[1], k = -E[2], V = E[3], U = E[4], q = E[5], $ = E[6], H = E[7], K = S * S + C * C + k * k + V * V;
          return K > 0 ? (I[0] = 2 * (U * V + H * S + q * k - $ * C) / K, I[1] = 2 * (q * V + H * C + $ * S - U * k) / K, I[2] = 2 * ($ * V + H * k + U * C - q * S) / K) : (I[0] = 2 * (U * V + H * S + q * k - $ * C), I[1] = 2 * (q * V + H * C + $ * S - U * k), I[2] = 2 * ($ * V + H * k + U * C - q * S)), l(x, E, I), x;
        }, pt.getTranslation = function(x, E) {
          return x[0] = E[12], x[1] = E[13], x[2] = E[14], x;
        }, pt.getScaling = d, pt.getRotation = function(x, E) {
          var I = new e.ARRAY_TYPE(3);
          d(I, E);
          var S = 1 / I[0], C = 1 / I[1], k = 1 / I[2], V = E[0] * S, U = E[1] * C, q = E[2] * k, $ = E[4] * S, H = E[5] * C, K = E[6] * k, Q = E[8] * S, ie = E[9] * C, fe = E[10] * k, de = V + H + fe, he = 0;
          return de > 0 ? (he = 2 * Math.sqrt(de + 1), x[3] = 0.25 * he, x[0] = (K - ie) / he, x[1] = (Q - q) / he, x[2] = (U - $) / he) : V > H && V > fe ? (he = 2 * Math.sqrt(1 + V - H - fe), x[3] = (K - ie) / he, x[0] = 0.25 * he, x[1] = (U + $) / he, x[2] = (Q + q) / he) : H > fe ? (he = 2 * Math.sqrt(1 + H - V - fe), x[3] = (Q - q) / he, x[0] = (U + $) / he, x[1] = 0.25 * he, x[2] = (K + ie) / he) : (he = 2 * Math.sqrt(1 + fe - V - H), x[3] = (U - $) / he, x[0] = (Q + q) / he, x[1] = (K + ie) / he, x[2] = 0.25 * he), x;
        }, pt.fromRotationTranslationScale = function(x, E, I, S) {
          var C = E[0], k = E[1], V = E[2], U = E[3], q = C + C, $ = k + k, H = V + V, K = C * q, Q = C * $, ie = C * H, fe = k * $, de = k * H, he = V * H, Me = U * q, me = U * $, Ee = U * H, ze = S[0], Ie = S[1], Re = S[2];
          return x[0] = (1 - (fe + he)) * ze, x[1] = (Q + Ee) * ze, x[2] = (ie - me) * ze, x[3] = 0, x[4] = (Q - Ee) * Ie, x[5] = (1 - (K + he)) * Ie, x[6] = (de + Me) * Ie, x[7] = 0, x[8] = (ie + me) * Re, x[9] = (de - Me) * Re, x[10] = (1 - (K + fe)) * Re, x[11] = 0, x[12] = I[0], x[13] = I[1], x[14] = I[2], x[15] = 1, x;
        }, pt.fromRotationTranslationScaleOrigin = function(x, E, I, S, C) {
          var k = E[0], V = E[1], U = E[2], q = E[3], $ = k + k, H = V + V, K = U + U, Q = k * $, ie = k * H, fe = k * K, de = V * H, he = V * K, Me = U * K, me = q * $, Ee = q * H, ze = q * K, Ie = S[0], Re = S[1], Ve = S[2], Ue = C[0], Fe = C[1], et = C[2], dt = (1 - (de + Me)) * Ie, tt = (ie + ze) * Ie, Tt = (fe - Ee) * Ie, vt = (ie - ze) * Re, Pt = (1 - (Q + Me)) * Re, rt = (he + me) * Re, Ut = (fe + Ee) * Ve, St = (he - me) * Ve, Nt = (1 - (Q + de)) * Ve;
          return x[0] = dt, x[1] = tt, x[2] = Tt, x[3] = 0, x[4] = vt, x[5] = Pt, x[6] = rt, x[7] = 0, x[8] = Ut, x[9] = St, x[10] = Nt, x[11] = 0, x[12] = I[0] + Ue - (dt * Ue + vt * Fe + Ut * et), x[13] = I[1] + Fe - (tt * Ue + Pt * Fe + St * et), x[14] = I[2] + et - (Tt * Ue + rt * Fe + Nt * et), x[15] = 1, x;
        }, pt.fromQuat = function(x, E) {
          var I = E[0], S = E[1], C = E[2], k = E[3], V = I + I, U = S + S, q = C + C, $ = I * V, H = S * V, K = S * U, Q = C * V, ie = C * U, fe = C * q, de = k * V, he = k * U, Me = k * q;
          return x[0] = 1 - K - fe, x[1] = H + Me, x[2] = Q - he, x[3] = 0, x[4] = H - Me, x[5] = 1 - $ - fe, x[6] = ie + de, x[7] = 0, x[8] = Q + he, x[9] = ie - de, x[10] = 1 - $ - K, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }, pt.frustum = function(x, E, I, S, C, k, V) {
          var U = 1 / (I - E), q = 1 / (C - S), $ = 1 / (k - V);
          return x[0] = 2 * k * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 2 * k * q, x[6] = 0, x[7] = 0, x[8] = (I + E) * U, x[9] = (C + S) * q, x[10] = (V + k) * $, x[11] = -1, x[12] = 0, x[13] = 0, x[14] = V * k * 2 * $, x[15] = 0, x;
        }, pt.perspectiveNO = v, pt.perspectiveZO = function(x, E, I, S, C) {
          var k, V = 1 / Math.tan(E / 2);
          return x[0] = V / I, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = V, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = -1, x[12] = 0, x[13] = 0, x[15] = 0, C != null && C !== 1 / 0 ? (x[10] = C * (k = 1 / (S - C)), x[14] = C * S * k) : (x[10] = -1, x[14] = -S), x;
        }, pt.perspectiveFromFieldOfView = function(x, E, I, S) {
          var C = Math.tan(E.upDegrees * Math.PI / 180), k = Math.tan(E.downDegrees * Math.PI / 180), V = Math.tan(E.leftDegrees * Math.PI / 180), U = Math.tan(E.rightDegrees * Math.PI / 180), q = 2 / (V + U), $ = 2 / (C + k);
          return x[0] = q, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = $, x[6] = 0, x[7] = 0, x[8] = -(V - U) * q * 0.5, x[9] = (C - k) * $ * 0.5, x[10] = S / (I - S), x[11] = -1, x[12] = 0, x[13] = 0, x[14] = S * I / (I - S), x[15] = 0, x;
        }, pt.orthoNO = M, pt.orthoZO = function(x, E, I, S, C, k, V) {
          var U = 1 / (E - I), q = 1 / (S - C), $ = 1 / (k - V);
          return x[0] = -2 * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = -2 * q, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = $, x[11] = 0, x[12] = (E + I) * U, x[13] = (C + S) * q, x[14] = k * $, x[15] = 1, x;
        }, pt.lookAt = function(x, E, I, S) {
          var C, k, V, U, q, $, H, K, Q, ie, fe = E[0], de = E[1], he = E[2], Me = S[0], me = S[1], Ee = S[2], ze = I[0], Ie = I[1], Re = I[2];
          return Math.abs(fe - ze) < e.EPSILON && Math.abs(de - Ie) < e.EPSILON && Math.abs(he - Re) < e.EPSILON ? o(x) : (H = fe - ze, K = de - Ie, Q = he - Re, C = me * (Q *= ie = 1 / Math.hypot(H, K, Q)) - Ee * (K *= ie), k = Ee * (H *= ie) - Me * Q, V = Me * K - me * H, (ie = Math.hypot(C, k, V)) ? (C *= ie = 1 / ie, k *= ie, V *= ie) : (C = 0, k = 0, V = 0), U = K * V - Q * k, q = Q * C - H * V, $ = H * k - K * C, (ie = Math.hypot(U, q, $)) ? (U *= ie = 1 / ie, q *= ie, $ *= ie) : (U = 0, q = 0, $ = 0), x[0] = C, x[1] = U, x[2] = H, x[3] = 0, x[4] = k, x[5] = q, x[6] = K, x[7] = 0, x[8] = V, x[9] = $, x[10] = Q, x[11] = 0, x[12] = -(C * fe + k * de + V * he), x[13] = -(U * fe + q * de + $ * he), x[14] = -(H * fe + K * de + Q * he), x[15] = 1, x);
        }, pt.targetTo = function(x, E, I, S) {
          var C = E[0], k = E[1], V = E[2], U = S[0], q = S[1], $ = S[2], H = C - I[0], K = k - I[1], Q = V - I[2], ie = H * H + K * K + Q * Q;
          ie > 0 && (H *= ie = 1 / Math.sqrt(ie), K *= ie, Q *= ie);
          var fe = q * Q - $ * K, de = $ * H - U * Q, he = U * K - q * H;
          return (ie = fe * fe + de * de + he * he) > 0 && (fe *= ie = 1 / Math.sqrt(ie), de *= ie, he *= ie), x[0] = fe, x[1] = de, x[2] = he, x[3] = 0, x[4] = K * he - Q * de, x[5] = Q * fe - H * he, x[6] = H * de - K * fe, x[7] = 0, x[8] = H, x[9] = K, x[10] = Q, x[11] = 0, x[12] = C, x[13] = k, x[14] = V, x[15] = 1, x;
        }, pt.str = function(x) {
          return "mat4(" + x[0] + ", " + x[1] + ", " + x[2] + ", " + x[3] + ", " + x[4] + ", " + x[5] + ", " + x[6] + ", " + x[7] + ", " + x[8] + ", " + x[9] + ", " + x[10] + ", " + x[11] + ", " + x[12] + ", " + x[13] + ", " + x[14] + ", " + x[15] + ")";
        }, pt.frob = function(x) {
          return Math.hypot(x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10], x[11], x[12], x[13], x[14], x[15]);
        }, pt.add = function(x, E, I) {
          return x[0] = E[0] + I[0], x[1] = E[1] + I[1], x[2] = E[2] + I[2], x[3] = E[3] + I[3], x[4] = E[4] + I[4], x[5] = E[5] + I[5], x[6] = E[6] + I[6], x[7] = E[7] + I[7], x[8] = E[8] + I[8], x[9] = E[9] + I[9], x[10] = E[10] + I[10], x[11] = E[11] + I[11], x[12] = E[12] + I[12], x[13] = E[13] + I[13], x[14] = E[14] + I[14], x[15] = E[15] + I[15], x;
        }, pt.subtract = D, pt.multiplyScalar = function(x, E, I) {
          return x[0] = E[0] * I, x[1] = E[1] * I, x[2] = E[2] * I, x[3] = E[3] * I, x[4] = E[4] * I, x[5] = E[5] * I, x[6] = E[6] * I, x[7] = E[7] * I, x[8] = E[8] * I, x[9] = E[9] * I, x[10] = E[10] * I, x[11] = E[11] * I, x[12] = E[12] * I, x[13] = E[13] * I, x[14] = E[14] * I, x[15] = E[15] * I, x;
        }, pt.multiplyScalarAndAdd = function(x, E, I, S) {
          return x[0] = E[0] + I[0] * S, x[1] = E[1] + I[1] * S, x[2] = E[2] + I[2] * S, x[3] = E[3] + I[3] * S, x[4] = E[4] + I[4] * S, x[5] = E[5] + I[5] * S, x[6] = E[6] + I[6] * S, x[7] = E[7] + I[7] * S, x[8] = E[8] + I[8] * S, x[9] = E[9] + I[9] * S, x[10] = E[10] + I[10] * S, x[11] = E[11] + I[11] * S, x[12] = E[12] + I[12] * S, x[13] = E[13] + I[13] * S, x[14] = E[14] + I[14] * S, x[15] = E[15] + I[15] * S, x;
        }, pt.exactEquals = function(x, E) {
          return x[0] === E[0] && x[1] === E[1] && x[2] === E[2] && x[3] === E[3] && x[4] === E[4] && x[5] === E[5] && x[6] === E[6] && x[7] === E[7] && x[8] === E[8] && x[9] === E[9] && x[10] === E[10] && x[11] === E[11] && x[12] === E[12] && x[13] === E[13] && x[14] === E[14] && x[15] === E[15];
        }, pt.equals = function(x, E) {
          var I = x[0], S = x[1], C = x[2], k = x[3], V = x[4], U = x[5], q = x[6], $ = x[7], H = x[8], K = x[9], Q = x[10], ie = x[11], fe = x[12], de = x[13], he = x[14], Me = x[15], me = E[0], Ee = E[1], ze = E[2], Ie = E[3], Re = E[4], Ve = E[5], Ue = E[6], Fe = E[7], et = E[8], dt = E[9], tt = E[10], Tt = E[11], vt = E[12], Pt = E[13], rt = E[14], Ut = E[15];
          return Math.abs(I - me) <= e.EPSILON * Math.max(1, Math.abs(I), Math.abs(me)) && Math.abs(S - Ee) <= e.EPSILON * Math.max(1, Math.abs(S), Math.abs(Ee)) && Math.abs(C - ze) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(ze)) && Math.abs(k - Ie) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(Ie)) && Math.abs(V - Re) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(Re)) && Math.abs(U - Ve) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(Ve)) && Math.abs(q - Ue) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(Ue)) && Math.abs($ - Fe) <= e.EPSILON * Math.max(1, Math.abs($), Math.abs(Fe)) && Math.abs(H - et) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(et)) && Math.abs(K - dt) <= e.EPSILON * Math.max(1, Math.abs(K), Math.abs(dt)) && Math.abs(Q - tt) <= e.EPSILON * Math.max(1, Math.abs(Q), Math.abs(tt)) && Math.abs(ie - Tt) <= e.EPSILON * Math.max(1, Math.abs(ie), Math.abs(Tt)) && Math.abs(fe - vt) <= e.EPSILON * Math.max(1, Math.abs(fe), Math.abs(vt)) && Math.abs(de - Pt) <= e.EPSILON * Math.max(1, Math.abs(de), Math.abs(Pt)) && Math.abs(he - rt) <= e.EPSILON * Math.max(1, Math.abs(he), Math.abs(rt)) && Math.abs(Me - Ut) <= e.EPSILON * Math.max(1, Math.abs(Me), Math.abs(Ut));
        }, pt.sub = pt.mul = pt.ortho = pt.perspective = void 0;
        var e = function(x, E) {
          if (x && x.__esModule)
            return x;
          if (x === null || r(x) !== "object" && typeof x != "function")
            return { default: x };
          var I = n(void 0);
          if (I && I.has(x))
            return I.get(x);
          var S = {}, C = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var k in x)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(x, k)) {
              var V = C ? Object.getOwnPropertyDescriptor(x, k) : null;
              V && (V.get || V.set) ? Object.defineProperty(S, k, V) : S[k] = x[k];
            }
          return S.default = x, I && I.set(x, S), S;
        }(ae());
        function n(x) {
          if (typeof WeakMap != "function")
            return null;
          var E = /* @__PURE__ */ new WeakMap(), I = /* @__PURE__ */ new WeakMap();
          return (n = function(S) {
            return S ? I : E;
          })(x);
        }
        function o(x) {
          return x[0] = 1, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = 1, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 1, x[11] = 0, x[12] = 0, x[13] = 0, x[14] = 0, x[15] = 1, x;
        }
        function u(x, E, I) {
          var S = E[0], C = E[1], k = E[2], V = E[3], U = E[4], q = E[5], $ = E[6], H = E[7], K = E[8], Q = E[9], ie = E[10], fe = E[11], de = E[12], he = E[13], Me = E[14], me = E[15], Ee = I[0], ze = I[1], Ie = I[2], Re = I[3];
          return x[0] = Ee * S + ze * U + Ie * K + Re * de, x[1] = Ee * C + ze * q + Ie * Q + Re * he, x[2] = Ee * k + ze * $ + Ie * ie + Re * Me, x[3] = Ee * V + ze * H + Ie * fe + Re * me, x[4] = (Ee = I[4]) * S + (ze = I[5]) * U + (Ie = I[6]) * K + (Re = I[7]) * de, x[5] = Ee * C + ze * q + Ie * Q + Re * he, x[6] = Ee * k + ze * $ + Ie * ie + Re * Me, x[7] = Ee * V + ze * H + Ie * fe + Re * me, x[8] = (Ee = I[8]) * S + (ze = I[9]) * U + (Ie = I[10]) * K + (Re = I[11]) * de, x[9] = Ee * C + ze * q + Ie * Q + Re * he, x[10] = Ee * k + ze * $ + Ie * ie + Re * Me, x[11] = Ee * V + ze * H + Ie * fe + Re * me, x[12] = (Ee = I[12]) * S + (ze = I[13]) * U + (Ie = I[14]) * K + (Re = I[15]) * de, x[13] = Ee * C + ze * q + Ie * Q + Re * he, x[14] = Ee * k + ze * $ + Ie * ie + Re * Me, x[15] = Ee * V + ze * H + Ie * fe + Re * me, x;
        }
        function l(x, E, I) {
          var S = E[0], C = E[1], k = E[2], V = E[3], U = S + S, q = C + C, $ = k + k, H = S * U, K = S * q, Q = S * $, ie = C * q, fe = C * $, de = k * $, he = V * U, Me = V * q, me = V * $;
          return x[0] = 1 - (ie + de), x[1] = K + me, x[2] = Q - Me, x[3] = 0, x[4] = K - me, x[5] = 1 - (H + de), x[6] = fe + he, x[7] = 0, x[8] = Q + Me, x[9] = fe - he, x[10] = 1 - (H + ie), x[11] = 0, x[12] = I[0], x[13] = I[1], x[14] = I[2], x[15] = 1, x;
        }
        function d(x, E) {
          var I = E[4], S = E[5], C = E[6], k = E[8], V = E[9], U = E[10];
          return x[0] = Math.hypot(E[0], E[1], E[2]), x[1] = Math.hypot(I, S, C), x[2] = Math.hypot(k, V, U), x;
        }
        function v(x, E, I, S, C) {
          var k, V = 1 / Math.tan(E / 2);
          return x[0] = V / I, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = V, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[11] = -1, x[12] = 0, x[13] = 0, x[15] = 0, C != null && C !== 1 / 0 ? (x[10] = (C + S) * (k = 1 / (S - C)), x[14] = 2 * C * S * k) : (x[10] = -1, x[14] = -2 * S), x;
        }
        function M(x, E, I, S, C, k, V) {
          var U = 1 / (E - I), q = 1 / (S - C), $ = 1 / (k - V);
          return x[0] = -2 * U, x[1] = 0, x[2] = 0, x[3] = 0, x[4] = 0, x[5] = -2 * q, x[6] = 0, x[7] = 0, x[8] = 0, x[9] = 0, x[10] = 2 * $, x[11] = 0, x[12] = (E + I) * U, x[13] = (C + S) * q, x[14] = (V + k) * $, x[15] = 1, x;
        }
        function D(x, E, I) {
          return x[0] = E[0] - I[0], x[1] = E[1] - I[1], x[2] = E[2] - I[2], x[3] = E[3] - I[3], x[4] = E[4] - I[4], x[5] = E[5] - I[5], x[6] = E[6] - I[6], x[7] = E[7] - I[7], x[8] = E[8] - I[8], x[9] = E[9] - I[9], x[10] = E[10] - I[10], x[11] = E[11] - I[11], x[12] = E[12] - I[12], x[13] = E[13] - I[13], x[14] = E[14] - I[14], x[15] = E[15] - I[15], x;
        }
        return pt.perspective = v, pt.ortho = M, pt.mul = u, pt.sub = D, pt;
      }
      var ui, kt = {}, At = {};
      function Si() {
        if (ui)
          return At;
        function r(C) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, r(C);
        }
        ui = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.create = o, At.clone = function(C) {
          var k = new e.ARRAY_TYPE(3);
          return k[0] = C[0], k[1] = C[1], k[2] = C[2], k;
        }, At.length = u, At.fromValues = function(C, k, V) {
          var U = new e.ARRAY_TYPE(3);
          return U[0] = C, U[1] = k, U[2] = V, U;
        }, At.copy = function(C, k) {
          return C[0] = k[0], C[1] = k[1], C[2] = k[2], C;
        }, At.set = function(C, k, V, U) {
          return C[0] = k, C[1] = V, C[2] = U, C;
        }, At.add = function(C, k, V) {
          return C[0] = k[0] + V[0], C[1] = k[1] + V[1], C[2] = k[2] + V[2], C;
        }, At.subtract = l, At.multiply = d, At.divide = v, At.ceil = function(C, k) {
          return C[0] = Math.ceil(k[0]), C[1] = Math.ceil(k[1]), C[2] = Math.ceil(k[2]), C;
        }, At.floor = function(C, k) {
          return C[0] = Math.floor(k[0]), C[1] = Math.floor(k[1]), C[2] = Math.floor(k[2]), C;
        }, At.min = function(C, k, V) {
          return C[0] = Math.min(k[0], V[0]), C[1] = Math.min(k[1], V[1]), C[2] = Math.min(k[2], V[2]), C;
        }, At.max = function(C, k, V) {
          return C[0] = Math.max(k[0], V[0]), C[1] = Math.max(k[1], V[1]), C[2] = Math.max(k[2], V[2]), C;
        }, At.round = function(C, k) {
          return C[0] = Math.round(k[0]), C[1] = Math.round(k[1]), C[2] = Math.round(k[2]), C;
        }, At.scale = function(C, k, V) {
          return C[0] = k[0] * V, C[1] = k[1] * V, C[2] = k[2] * V, C;
        }, At.scaleAndAdd = function(C, k, V, U) {
          return C[0] = k[0] + V[0] * U, C[1] = k[1] + V[1] * U, C[2] = k[2] + V[2] * U, C;
        }, At.distance = M, At.squaredDistance = D, At.squaredLength = x, At.negate = function(C, k) {
          return C[0] = -k[0], C[1] = -k[1], C[2] = -k[2], C;
        }, At.inverse = function(C, k) {
          return C[0] = 1 / k[0], C[1] = 1 / k[1], C[2] = 1 / k[2], C;
        }, At.normalize = function(C, k) {
          var V = k[0], U = k[1], q = k[2], $ = V * V + U * U + q * q;
          return $ > 0 && ($ = 1 / Math.sqrt($)), C[0] = k[0] * $, C[1] = k[1] * $, C[2] = k[2] * $, C;
        }, At.dot = E, At.cross = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2], H = V[0], K = V[1], Q = V[2];
          return C[0] = q * Q - $ * K, C[1] = $ * H - U * Q, C[2] = U * K - q * H, C;
        }, At.lerp = function(C, k, V, U) {
          var q = k[0], $ = k[1], H = k[2];
          return C[0] = q + U * (V[0] - q), C[1] = $ + U * (V[1] - $), C[2] = H + U * (V[2] - H), C;
        }, At.hermite = function(C, k, V, U, q, $) {
          var H = $ * $, K = H * (2 * $ - 3) + 1, Q = H * ($ - 2) + $, ie = H * ($ - 1), fe = H * (3 - 2 * $);
          return C[0] = k[0] * K + V[0] * Q + U[0] * ie + q[0] * fe, C[1] = k[1] * K + V[1] * Q + U[1] * ie + q[1] * fe, C[2] = k[2] * K + V[2] * Q + U[2] * ie + q[2] * fe, C;
        }, At.bezier = function(C, k, V, U, q, $) {
          var H = 1 - $, K = H * H, Q = $ * $, ie = K * H, fe = 3 * $ * K, de = 3 * Q * H, he = Q * $;
          return C[0] = k[0] * ie + V[0] * fe + U[0] * de + q[0] * he, C[1] = k[1] * ie + V[1] * fe + U[1] * de + q[1] * he, C[2] = k[2] * ie + V[2] * fe + U[2] * de + q[2] * he, C;
        }, At.random = function(C, k) {
          k = k || 1;
          var V = 2 * e.RANDOM() * Math.PI, U = 2 * e.RANDOM() - 1, q = Math.sqrt(1 - U * U) * k;
          return C[0] = Math.cos(V) * q, C[1] = Math.sin(V) * q, C[2] = U * k, C;
        }, At.transformMat4 = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2], H = V[3] * U + V[7] * q + V[11] * $ + V[15];
          return C[0] = (V[0] * U + V[4] * q + V[8] * $ + V[12]) / (H = H || 1), C[1] = (V[1] * U + V[5] * q + V[9] * $ + V[13]) / H, C[2] = (V[2] * U + V[6] * q + V[10] * $ + V[14]) / H, C;
        }, At.transformMat3 = function(C, k, V) {
          var U = k[0], q = k[1], $ = k[2];
          return C[0] = U * V[0] + q * V[3] + $ * V[6], C[1] = U * V[1] + q * V[4] + $ * V[7], C[2] = U * V[2] + q * V[5] + $ * V[8], C;
        }, At.transformQuat = function(C, k, V) {
          var U = V[0], q = V[1], $ = V[2], H = k[0], K = k[1], Q = k[2], ie = q * Q - $ * K, fe = $ * H - U * Q, de = U * K - q * H, he = q * de - $ * fe, Me = $ * ie - U * de, me = U * fe - q * ie, Ee = 2 * V[3];
          return fe *= Ee, de *= Ee, Me *= 2, me *= 2, C[0] = H + (ie *= Ee) + (he *= 2), C[1] = K + fe + Me, C[2] = Q + de + me, C;
        }, At.rotateX = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[0], $[1] = q[1] * Math.cos(U) - q[2] * Math.sin(U), $[2] = q[1] * Math.sin(U) + q[2] * Math.cos(U), C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.rotateY = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[2] * Math.sin(U) + q[0] * Math.cos(U), $[1] = q[1], $[2] = q[2] * Math.cos(U) - q[0] * Math.sin(U), C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.rotateZ = function(C, k, V, U) {
          var q = [], $ = [];
          return q[0] = k[0] - V[0], q[1] = k[1] - V[1], q[2] = k[2] - V[2], $[0] = q[0] * Math.cos(U) - q[1] * Math.sin(U), $[1] = q[0] * Math.sin(U) + q[1] * Math.cos(U), $[2] = q[2], C[0] = $[0] + V[0], C[1] = $[1] + V[1], C[2] = $[2] + V[2], C;
        }, At.angle = function(C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2], Q = Math.sqrt(V * V + U * U + q * q) * Math.sqrt($ * $ + H * H + K * K), ie = Q && E(C, k) / Q;
          return Math.acos(Math.min(Math.max(ie, -1), 1));
        }, At.zero = function(C) {
          return C[0] = 0, C[1] = 0, C[2] = 0, C;
        }, At.str = function(C) {
          return "vec3(" + C[0] + ", " + C[1] + ", " + C[2] + ")";
        }, At.exactEquals = function(C, k) {
          return C[0] === k[0] && C[1] === k[1] && C[2] === k[2];
        }, At.equals = function(C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2];
          return Math.abs(V - $) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs($)) && Math.abs(U - H) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(H)) && Math.abs(q - K) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(K));
        }, At.forEach = At.sqrLen = At.len = At.sqrDist = At.dist = At.div = At.mul = At.sub = void 0;
        var e = function(C, k) {
          if (C && C.__esModule)
            return C;
          if (C === null || r(C) !== "object" && typeof C != "function")
            return { default: C };
          var V = n(void 0);
          if (V && V.has(C))
            return V.get(C);
          var U = {}, q = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var $ in C)
            if ($ !== "default" && Object.prototype.hasOwnProperty.call(C, $)) {
              var H = q ? Object.getOwnPropertyDescriptor(C, $) : null;
              H && (H.get || H.set) ? Object.defineProperty(U, $, H) : U[$] = C[$];
            }
          return U.default = C, V && V.set(C, U), U;
        }(ae());
        function n(C) {
          if (typeof WeakMap != "function")
            return null;
          var k = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakMap();
          return (n = function(U) {
            return U ? V : k;
          })(C);
        }
        function o() {
          var C = new e.ARRAY_TYPE(3);
          return e.ARRAY_TYPE != Float32Array && (C[0] = 0, C[1] = 0, C[2] = 0), C;
        }
        function u(C) {
          return Math.hypot(C[0], C[1], C[2]);
        }
        function l(C, k, V) {
          return C[0] = k[0] - V[0], C[1] = k[1] - V[1], C[2] = k[2] - V[2], C;
        }
        function d(C, k, V) {
          return C[0] = k[0] * V[0], C[1] = k[1] * V[1], C[2] = k[2] * V[2], C;
        }
        function v(C, k, V) {
          return C[0] = k[0] / V[0], C[1] = k[1] / V[1], C[2] = k[2] / V[2], C;
        }
        function M(C, k) {
          return Math.hypot(k[0] - C[0], k[1] - C[1], k[2] - C[2]);
        }
        function D(C, k) {
          var V = k[0] - C[0], U = k[1] - C[1], q = k[2] - C[2];
          return V * V + U * U + q * q;
        }
        function x(C) {
          var k = C[0], V = C[1], U = C[2];
          return k * k + V * V + U * U;
        }
        function E(C, k) {
          return C[0] * k[0] + C[1] * k[1] + C[2] * k[2];
        }
        At.sub = l, At.mul = d, At.div = v, At.dist = M, At.sqrDist = D, At.len = u, At.sqrLen = x;
        var I, S = (I = o(), function(C, k, V, U, q, $) {
          var H, K;
          for (k || (k = 3), V || (V = 0), K = U ? Math.min(U * k + V, C.length) : C.length, H = V; H < K; H += k)
            I[0] = C[H], I[1] = C[H + 1], I[2] = C[H + 2], q(I, I, $), C[H] = I[0], C[H + 1] = I[1], C[H + 2] = I[2];
          return C;
        });
        return At.forEach = S, At;
      }
      var An, hn, Ht = {};
      function Mi() {
        if (An)
          return Ht;
        function r(S) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(S);
        }
        An = 1, Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.create = o, Ht.clone = function(S) {
          var C = new e.ARRAY_TYPE(4);
          return C[0] = S[0], C[1] = S[1], C[2] = S[2], C[3] = S[3], C;
        }, Ht.fromValues = function(S, C, k, V) {
          var U = new e.ARRAY_TYPE(4);
          return U[0] = S, U[1] = C, U[2] = k, U[3] = V, U;
        }, Ht.copy = function(S, C) {
          return S[0] = C[0], S[1] = C[1], S[2] = C[2], S[3] = C[3], S;
        }, Ht.set = function(S, C, k, V, U) {
          return S[0] = C, S[1] = k, S[2] = V, S[3] = U, S;
        }, Ht.add = function(S, C, k) {
          return S[0] = C[0] + k[0], S[1] = C[1] + k[1], S[2] = C[2] + k[2], S[3] = C[3] + k[3], S;
        }, Ht.subtract = u, Ht.multiply = l, Ht.divide = d, Ht.ceil = function(S, C) {
          return S[0] = Math.ceil(C[0]), S[1] = Math.ceil(C[1]), S[2] = Math.ceil(C[2]), S[3] = Math.ceil(C[3]), S;
        }, Ht.floor = function(S, C) {
          return S[0] = Math.floor(C[0]), S[1] = Math.floor(C[1]), S[2] = Math.floor(C[2]), S[3] = Math.floor(C[3]), S;
        }, Ht.min = function(S, C, k) {
          return S[0] = Math.min(C[0], k[0]), S[1] = Math.min(C[1], k[1]), S[2] = Math.min(C[2], k[2]), S[3] = Math.min(C[3], k[3]), S;
        }, Ht.max = function(S, C, k) {
          return S[0] = Math.max(C[0], k[0]), S[1] = Math.max(C[1], k[1]), S[2] = Math.max(C[2], k[2]), S[3] = Math.max(C[3], k[3]), S;
        }, Ht.round = function(S, C) {
          return S[0] = Math.round(C[0]), S[1] = Math.round(C[1]), S[2] = Math.round(C[2]), S[3] = Math.round(C[3]), S;
        }, Ht.scale = function(S, C, k) {
          return S[0] = C[0] * k, S[1] = C[1] * k, S[2] = C[2] * k, S[3] = C[3] * k, S;
        }, Ht.scaleAndAdd = function(S, C, k, V) {
          return S[0] = C[0] + k[0] * V, S[1] = C[1] + k[1] * V, S[2] = C[2] + k[2] * V, S[3] = C[3] + k[3] * V, S;
        }, Ht.distance = v, Ht.squaredDistance = M, Ht.length = D, Ht.squaredLength = x, Ht.negate = function(S, C) {
          return S[0] = -C[0], S[1] = -C[1], S[2] = -C[2], S[3] = -C[3], S;
        }, Ht.inverse = function(S, C) {
          return S[0] = 1 / C[0], S[1] = 1 / C[1], S[2] = 1 / C[2], S[3] = 1 / C[3], S;
        }, Ht.normalize = function(S, C) {
          var k = C[0], V = C[1], U = C[2], q = C[3], $ = k * k + V * V + U * U + q * q;
          return $ > 0 && ($ = 1 / Math.sqrt($)), S[0] = k * $, S[1] = V * $, S[2] = U * $, S[3] = q * $, S;
        }, Ht.dot = function(S, C) {
          return S[0] * C[0] + S[1] * C[1] + S[2] * C[2] + S[3] * C[3];
        }, Ht.cross = function(S, C, k, V) {
          var U = k[0] * V[1] - k[1] * V[0], q = k[0] * V[2] - k[2] * V[0], $ = k[0] * V[3] - k[3] * V[0], H = k[1] * V[2] - k[2] * V[1], K = k[1] * V[3] - k[3] * V[1], Q = k[2] * V[3] - k[3] * V[2], ie = C[0], fe = C[1], de = C[2], he = C[3];
          return S[0] = fe * Q - de * K + he * H, S[1] = -ie * Q + de * $ - he * q, S[2] = ie * K - fe * $ + he * U, S[3] = -ie * H + fe * q - de * U, S;
        }, Ht.lerp = function(S, C, k, V) {
          var U = C[0], q = C[1], $ = C[2], H = C[3];
          return S[0] = U + V * (k[0] - U), S[1] = q + V * (k[1] - q), S[2] = $ + V * (k[2] - $), S[3] = H + V * (k[3] - H), S;
        }, Ht.random = function(S, C) {
          var k, V, U, q, $, H;
          C = C || 1;
          do
            $ = (k = 2 * e.RANDOM() - 1) * k + (V = 2 * e.RANDOM() - 1) * V;
          while ($ >= 1);
          do
            H = (U = 2 * e.RANDOM() - 1) * U + (q = 2 * e.RANDOM() - 1) * q;
          while (H >= 1);
          var K = Math.sqrt((1 - $) / H);
          return S[0] = C * k, S[1] = C * V, S[2] = C * U * K, S[3] = C * q * K, S;
        }, Ht.transformMat4 = function(S, C, k) {
          var V = C[0], U = C[1], q = C[2], $ = C[3];
          return S[0] = k[0] * V + k[4] * U + k[8] * q + k[12] * $, S[1] = k[1] * V + k[5] * U + k[9] * q + k[13] * $, S[2] = k[2] * V + k[6] * U + k[10] * q + k[14] * $, S[3] = k[3] * V + k[7] * U + k[11] * q + k[15] * $, S;
        }, Ht.transformQuat = function(S, C, k) {
          var V = C[0], U = C[1], q = C[2], $ = k[0], H = k[1], K = k[2], Q = k[3], ie = Q * V + H * q - K * U, fe = Q * U + K * V - $ * q, de = Q * q + $ * U - H * V, he = -$ * V - H * U - K * q;
          return S[0] = ie * Q + he * -$ + fe * -K - de * -H, S[1] = fe * Q + he * -H + de * -$ - ie * -K, S[2] = de * Q + he * -K + ie * -H - fe * -$, S[3] = C[3], S;
        }, Ht.zero = function(S) {
          return S[0] = 0, S[1] = 0, S[2] = 0, S[3] = 0, S;
        }, Ht.str = function(S) {
          return "vec4(" + S[0] + ", " + S[1] + ", " + S[2] + ", " + S[3] + ")";
        }, Ht.exactEquals = function(S, C) {
          return S[0] === C[0] && S[1] === C[1] && S[2] === C[2] && S[3] === C[3];
        }, Ht.equals = function(S, C) {
          var k = S[0], V = S[1], U = S[2], q = S[3], $ = C[0], H = C[1], K = C[2], Q = C[3];
          return Math.abs(k - $) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs($)) && Math.abs(V - H) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(H)) && Math.abs(U - K) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(K)) && Math.abs(q - Q) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(Q));
        }, Ht.forEach = Ht.sqrLen = Ht.len = Ht.sqrDist = Ht.dist = Ht.div = Ht.mul = Ht.sub = void 0;
        var e = function(S, C) {
          if (S && S.__esModule)
            return S;
          if (S === null || r(S) !== "object" && typeof S != "function")
            return { default: S };
          var k = n(void 0);
          if (k && k.has(S))
            return k.get(S);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in S)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(S, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(S, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = S[q];
            }
          return V.default = S, k && k.set(S, V), V;
        }(ae());
        function n(S) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (n = function(V) {
            return V ? k : C;
          })(S);
        }
        function o() {
          var S = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (S[0] = 0, S[1] = 0, S[2] = 0, S[3] = 0), S;
        }
        function u(S, C, k) {
          return S[0] = C[0] - k[0], S[1] = C[1] - k[1], S[2] = C[2] - k[2], S[3] = C[3] - k[3], S;
        }
        function l(S, C, k) {
          return S[0] = C[0] * k[0], S[1] = C[1] * k[1], S[2] = C[2] * k[2], S[3] = C[3] * k[3], S;
        }
        function d(S, C, k) {
          return S[0] = C[0] / k[0], S[1] = C[1] / k[1], S[2] = C[2] / k[2], S[3] = C[3] / k[3], S;
        }
        function v(S, C) {
          return Math.hypot(C[0] - S[0], C[1] - S[1], C[2] - S[2], C[3] - S[3]);
        }
        function M(S, C) {
          var k = C[0] - S[0], V = C[1] - S[1], U = C[2] - S[2], q = C[3] - S[3];
          return k * k + V * V + U * U + q * q;
        }
        function D(S) {
          return Math.hypot(S[0], S[1], S[2], S[3]);
        }
        function x(S) {
          var C = S[0], k = S[1], V = S[2], U = S[3];
          return C * C + k * k + V * V + U * U;
        }
        Ht.sub = u, Ht.mul = l, Ht.div = d, Ht.dist = v, Ht.sqrDist = M, Ht.len = D, Ht.sqrLen = x;
        var E, I = (E = o(), function(S, C, k, V, U, q) {
          var $, H;
          for (C || (C = 4), k || (k = 0), H = V ? Math.min(V * C + k, S.length) : S.length, $ = k; $ < H; $ += C)
            E[0] = S[$], E[1] = S[$ + 1], E[2] = S[$ + 2], E[3] = S[$ + 3], U(E, E, q), S[$] = E[0], S[$ + 1] = E[1], S[$ + 2] = E[2], S[$ + 3] = E[3];
          return S;
        });
        return Ht.forEach = I, Ht;
      }
      function Ji() {
        if (hn)
          return kt;
        function r(me) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ee) {
            return typeof Ee;
          } : function(Ee) {
            return Ee && typeof Symbol == "function" && Ee.constructor === Symbol && Ee !== Symbol.prototype ? "symbol" : typeof Ee;
          }, r(me);
        }
        hn = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.create = v, kt.identity = function(me) {
          return me[0] = 0, me[1] = 0, me[2] = 0, me[3] = 1, me;
        }, kt.setAxisAngle = M, kt.getAxisAngle = function(me, Ee) {
          var ze = 2 * Math.acos(Ee[3]), Ie = Math.sin(ze / 2);
          return Ie > e.EPSILON ? (me[0] = Ee[0] / Ie, me[1] = Ee[1] / Ie, me[2] = Ee[2] / Ie) : (me[0] = 1, me[1] = 0, me[2] = 0), ze;
        }, kt.getAngle = function(me, Ee) {
          var ze = k(me, Ee);
          return Math.acos(2 * ze * ze - 1);
        }, kt.multiply = D, kt.rotateX = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et + Ue * Fe, me[1] = Re * et + Ve * Fe, me[2] = Ve * et - Re * Fe, me[3] = Ue * et - Ie * Fe, me;
        }, kt.rotateY = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et - Ve * Fe, me[1] = Re * et + Ue * Fe, me[2] = Ve * et + Ie * Fe, me[3] = Ue * et - Re * Fe, me;
        }, kt.rotateZ = function(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = Math.sin(ze), et = Math.cos(ze);
          return me[0] = Ie * et + Re * Fe, me[1] = Re * et - Ie * Fe, me[2] = Ve * et + Ue * Fe, me[3] = Ue * et - Ve * Fe, me;
        }, kt.calculateW = function(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2];
          return me[0] = ze, me[1] = Ie, me[2] = Re, me[3] = Math.sqrt(Math.abs(1 - ze * ze - Ie * Ie - Re * Re)), me;
        }, kt.exp = x, kt.ln = E, kt.pow = function(me, Ee, ze) {
          return E(me, Ee), C(me, me, ze), x(me, me), me;
        }, kt.slerp = I, kt.random = function(me) {
          var Ee = e.RANDOM(), ze = e.RANDOM(), Ie = e.RANDOM(), Re = Math.sqrt(1 - Ee), Ve = Math.sqrt(Ee);
          return me[0] = Re * Math.sin(2 * Math.PI * ze), me[1] = Re * Math.cos(2 * Math.PI * ze), me[2] = Ve * Math.sin(2 * Math.PI * Ie), me[3] = Ve * Math.cos(2 * Math.PI * Ie), me;
        }, kt.invert = function(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = ze * ze + Ie * Ie + Re * Re + Ve * Ve, Fe = Ue ? 1 / Ue : 0;
          return me[0] = -ze * Fe, me[1] = -Ie * Fe, me[2] = -Re * Fe, me[3] = Ve * Fe, me;
        }, kt.conjugate = function(me, Ee) {
          return me[0] = -Ee[0], me[1] = -Ee[1], me[2] = -Ee[2], me[3] = Ee[3], me;
        }, kt.fromMat3 = S, kt.fromEuler = function(me, Ee, ze, Ie) {
          var Re = 0.5 * Math.PI / 180;
          Ee *= Re, ze *= Re, Ie *= Re;
          var Ve = Math.sin(Ee), Ue = Math.cos(Ee), Fe = Math.sin(ze), et = Math.cos(ze), dt = Math.sin(Ie), tt = Math.cos(Ie);
          return me[0] = Ve * et * tt - Ue * Fe * dt, me[1] = Ue * Fe * tt + Ve * et * dt, me[2] = Ue * et * dt - Ve * Fe * tt, me[3] = Ue * et * tt + Ve * Fe * dt, me;
        }, kt.str = function(me) {
          return "quat(" + me[0] + ", " + me[1] + ", " + me[2] + ", " + me[3] + ")";
        }, kt.setAxes = kt.sqlerp = kt.rotationTo = kt.equals = kt.exactEquals = kt.normalize = kt.sqrLen = kt.squaredLength = kt.len = kt.length = kt.lerp = kt.dot = kt.scale = kt.mul = kt.add = kt.set = kt.copy = kt.fromValues = kt.clone = void 0;
        var e = d(ae()), n = d(bt()), o = d(Si()), u = d(Mi());
        function l(me) {
          if (typeof WeakMap != "function")
            return null;
          var Ee = /* @__PURE__ */ new WeakMap(), ze = /* @__PURE__ */ new WeakMap();
          return (l = function(Ie) {
            return Ie ? ze : Ee;
          })(me);
        }
        function d(me, Ee) {
          if (me && me.__esModule)
            return me;
          if (me === null || r(me) !== "object" && typeof me != "function")
            return { default: me };
          var ze = l(Ee);
          if (ze && ze.has(me))
            return ze.get(me);
          var Ie = {}, Re = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var Ve in me)
            if (Ve !== "default" && Object.prototype.hasOwnProperty.call(me, Ve)) {
              var Ue = Re ? Object.getOwnPropertyDescriptor(me, Ve) : null;
              Ue && (Ue.get || Ue.set) ? Object.defineProperty(Ie, Ve, Ue) : Ie[Ve] = me[Ve];
            }
          return Ie.default = me, ze && ze.set(me, Ie), Ie;
        }
        function v() {
          var me = new e.ARRAY_TYPE(4);
          return e.ARRAY_TYPE != Float32Array && (me[0] = 0, me[1] = 0, me[2] = 0), me[3] = 1, me;
        }
        function M(me, Ee, ze) {
          ze *= 0.5;
          var Ie = Math.sin(ze);
          return me[0] = Ie * Ee[0], me[1] = Ie * Ee[1], me[2] = Ie * Ee[2], me[3] = Math.cos(ze), me;
        }
        function D(me, Ee, ze) {
          var Ie = Ee[0], Re = Ee[1], Ve = Ee[2], Ue = Ee[3], Fe = ze[0], et = ze[1], dt = ze[2], tt = ze[3];
          return me[0] = Ie * tt + Ue * Fe + Re * dt - Ve * et, me[1] = Re * tt + Ue * et + Ve * Fe - Ie * dt, me[2] = Ve * tt + Ue * dt + Ie * et - Re * Fe, me[3] = Ue * tt - Ie * Fe - Re * et - Ve * dt, me;
        }
        function x(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = Math.sqrt(ze * ze + Ie * Ie + Re * Re), Fe = Math.exp(Ve), et = Ue > 0 ? Fe * Math.sin(Ue) / Ue : 0;
          return me[0] = ze * et, me[1] = Ie * et, me[2] = Re * et, me[3] = Fe * Math.cos(Ue), me;
        }
        function E(me, Ee) {
          var ze = Ee[0], Ie = Ee[1], Re = Ee[2], Ve = Ee[3], Ue = Math.sqrt(ze * ze + Ie * Ie + Re * Re), Fe = Ue > 0 ? Math.atan2(Ue, Ve) / Ue : 0;
          return me[0] = ze * Fe, me[1] = Ie * Fe, me[2] = Re * Fe, me[3] = 0.5 * Math.log(ze * ze + Ie * Ie + Re * Re + Ve * Ve), me;
        }
        function I(me, Ee, ze, Ie) {
          var Re, Ve, Ue, Fe, et, dt = Ee[0], tt = Ee[1], Tt = Ee[2], vt = Ee[3], Pt = ze[0], rt = ze[1], Ut = ze[2], St = ze[3];
          return (Ve = dt * Pt + tt * rt + Tt * Ut + vt * St) < 0 && (Ve = -Ve, Pt = -Pt, rt = -rt, Ut = -Ut, St = -St), 1 - Ve > e.EPSILON ? (Re = Math.acos(Ve), Ue = Math.sin(Re), Fe = Math.sin((1 - Ie) * Re) / Ue, et = Math.sin(Ie * Re) / Ue) : (Fe = 1 - Ie, et = Ie), me[0] = Fe * dt + et * Pt, me[1] = Fe * tt + et * rt, me[2] = Fe * Tt + et * Ut, me[3] = Fe * vt + et * St, me;
        }
        function S(me, Ee) {
          var ze, Ie = Ee[0] + Ee[4] + Ee[8];
          if (Ie > 0)
            ze = Math.sqrt(Ie + 1), me[3] = 0.5 * ze, me[0] = (Ee[5] - Ee[7]) * (ze = 0.5 / ze), me[1] = (Ee[6] - Ee[2]) * ze, me[2] = (Ee[1] - Ee[3]) * ze;
          else {
            var Re = 0;
            Ee[4] > Ee[0] && (Re = 1), Ee[8] > Ee[3 * Re + Re] && (Re = 2);
            var Ve = (Re + 1) % 3, Ue = (Re + 2) % 3;
            ze = Math.sqrt(Ee[3 * Re + Re] - Ee[3 * Ve + Ve] - Ee[3 * Ue + Ue] + 1), me[Re] = 0.5 * ze, me[3] = (Ee[3 * Ve + Ue] - Ee[3 * Ue + Ve]) * (ze = 0.5 / ze), me[Ve] = (Ee[3 * Ve + Re] + Ee[3 * Re + Ve]) * ze, me[Ue] = (Ee[3 * Ue + Re] + Ee[3 * Re + Ue]) * ze;
          }
          return me;
        }
        kt.clone = u.clone, kt.fromValues = u.fromValues, kt.copy = u.copy, kt.set = u.set, kt.add = u.add, kt.mul = D;
        var C = u.scale;
        kt.scale = C;
        var k = u.dot;
        kt.dot = k, kt.lerp = u.lerp;
        var V = u.length;
        kt.length = V, kt.len = V;
        var U = u.squaredLength;
        kt.squaredLength = U, kt.sqrLen = U;
        var q = u.normalize;
        kt.normalize = q, kt.exactEquals = u.exactEquals, kt.equals = u.equals;
        var $, H, K, Q = ($ = o.create(), H = o.fromValues(1, 0, 0), K = o.fromValues(0, 1, 0), function(me, Ee, ze) {
          var Ie = o.dot(Ee, ze);
          return Ie < -0.999999 ? (o.cross($, H, Ee), o.len($) < 1e-6 && o.cross($, K, Ee), o.normalize($, $), M(me, $, Math.PI), me) : Ie > 0.999999 ? (me[0] = 0, me[1] = 0, me[2] = 0, me[3] = 1, me) : (o.cross($, Ee, ze), me[0] = $[0], me[1] = $[1], me[2] = $[2], me[3] = 1 + Ie, q(me, me));
        });
        kt.rotationTo = Q;
        var ie, fe, de = (ie = v(), fe = v(), function(me, Ee, ze, Ie, Re, Ve) {
          return I(ie, Ee, Re, Ve), I(fe, ze, Ie, Ve), I(me, ie, fe, 2 * Ve * (1 - Ve)), me;
        });
        kt.sqlerp = de;
        var he, Me = (he = n.create(), function(me, Ee, ze, Ie) {
          return he[0] = ze[0], he[3] = ze[1], he[6] = ze[2], he[1] = Ie[0], he[4] = Ie[1], he[7] = Ie[2], he[2] = -Ee[0], he[5] = -Ee[1], he[8] = -Ee[2], q(me, S(me, he));
        });
        return kt.setAxes = Me, kt;
      }
      var fi, jt = {};
      function ni() {
        if (fi)
          return jt;
        function r(I) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
            return typeof S;
          } : function(S) {
            return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
          }, r(I);
        }
        fi = 1, Object.defineProperty(jt, "__esModule", { value: !0 }), jt.create = function() {
          var I = new e.ARRAY_TYPE(8);
          return e.ARRAY_TYPE != Float32Array && (I[0] = 0, I[1] = 0, I[2] = 0, I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0), I[3] = 1, I;
        }, jt.clone = function(I) {
          var S = new e.ARRAY_TYPE(8);
          return S[0] = I[0], S[1] = I[1], S[2] = I[2], S[3] = I[3], S[4] = I[4], S[5] = I[5], S[6] = I[6], S[7] = I[7], S;
        }, jt.fromValues = function(I, S, C, k, V, U, q, $) {
          var H = new e.ARRAY_TYPE(8);
          return H[0] = I, H[1] = S, H[2] = C, H[3] = k, H[4] = V, H[5] = U, H[6] = q, H[7] = $, H;
        }, jt.fromRotationTranslationValues = function(I, S, C, k, V, U, q) {
          var $ = new e.ARRAY_TYPE(8);
          $[0] = I, $[1] = S, $[2] = C, $[3] = k;
          var H = 0.5 * V, K = 0.5 * U, Q = 0.5 * q;
          return $[4] = H * k + K * C - Q * S, $[5] = K * k + Q * I - H * C, $[6] = Q * k + H * S - K * I, $[7] = -H * I - K * S - Q * C, $;
        }, jt.fromRotationTranslation = d, jt.fromTranslation = function(I, S) {
          return I[0] = 0, I[1] = 0, I[2] = 0, I[3] = 1, I[4] = 0.5 * S[0], I[5] = 0.5 * S[1], I[6] = 0.5 * S[2], I[7] = 0, I;
        }, jt.fromRotation = function(I, S) {
          return I[0] = S[0], I[1] = S[1], I[2] = S[2], I[3] = S[3], I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0, I;
        }, jt.fromMat4 = function(I, S) {
          var C = n.create();
          o.getRotation(C, S);
          var k = new e.ARRAY_TYPE(3);
          return o.getTranslation(k, S), d(I, C, k), I;
        }, jt.copy = v, jt.identity = function(I) {
          return I[0] = 0, I[1] = 0, I[2] = 0, I[3] = 1, I[4] = 0, I[5] = 0, I[6] = 0, I[7] = 0, I;
        }, jt.set = function(I, S, C, k, V, U, q, $, H) {
          return I[0] = S, I[1] = C, I[2] = k, I[3] = V, I[4] = U, I[5] = q, I[6] = $, I[7] = H, I;
        }, jt.getDual = function(I, S) {
          return I[0] = S[4], I[1] = S[5], I[2] = S[6], I[3] = S[7], I;
        }, jt.setDual = function(I, S) {
          return I[4] = S[0], I[5] = S[1], I[6] = S[2], I[7] = S[3], I;
        }, jt.getTranslation = function(I, S) {
          var C = S[4], k = S[5], V = S[6], U = S[7], q = -S[0], $ = -S[1], H = -S[2], K = S[3];
          return I[0] = 2 * (C * K + U * q + k * H - V * $), I[1] = 2 * (k * K + U * $ + V * q - C * H), I[2] = 2 * (V * K + U * H + C * $ - k * q), I;
        }, jt.translate = function(I, S, C) {
          var k = S[0], V = S[1], U = S[2], q = S[3], $ = 0.5 * C[0], H = 0.5 * C[1], K = 0.5 * C[2], Q = S[4], ie = S[5], fe = S[6], de = S[7];
          return I[0] = k, I[1] = V, I[2] = U, I[3] = q, I[4] = q * $ + V * K - U * H + Q, I[5] = q * H + U * $ - k * K + ie, I[6] = q * K + k * H - V * $ + fe, I[7] = -k * $ - V * H - U * K + de, I;
        }, jt.rotateX = function(I, S, C) {
          var k = -S[0], V = -S[1], U = -S[2], q = S[3], $ = S[4], H = S[5], K = S[6], Q = S[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, he = Q * q - $ * k - H * V - K * U;
          return n.rotateX(I, S, C), I[4] = ie * (q = I[3]) + he * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + he * V + de * k - ie * U, I[6] = de * q + he * U + ie * V - fe * k, I[7] = he * q - ie * k - fe * V - de * U, I;
        }, jt.rotateY = function(I, S, C) {
          var k = -S[0], V = -S[1], U = -S[2], q = S[3], $ = S[4], H = S[5], K = S[6], Q = S[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, he = Q * q - $ * k - H * V - K * U;
          return n.rotateY(I, S, C), I[4] = ie * (q = I[3]) + he * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + he * V + de * k - ie * U, I[6] = de * q + he * U + ie * V - fe * k, I[7] = he * q - ie * k - fe * V - de * U, I;
        }, jt.rotateZ = function(I, S, C) {
          var k = -S[0], V = -S[1], U = -S[2], q = S[3], $ = S[4], H = S[5], K = S[6], Q = S[7], ie = $ * q + Q * k + H * U - K * V, fe = H * q + Q * V + K * k - $ * U, de = K * q + Q * U + $ * V - H * k, he = Q * q - $ * k - H * V - K * U;
          return n.rotateZ(I, S, C), I[4] = ie * (q = I[3]) + he * (k = I[0]) + fe * (U = I[2]) - de * (V = I[1]), I[5] = fe * q + he * V + de * k - ie * U, I[6] = de * q + he * U + ie * V - fe * k, I[7] = he * q - ie * k - fe * V - de * U, I;
        }, jt.rotateByQuatAppend = function(I, S, C) {
          var k = C[0], V = C[1], U = C[2], q = C[3], $ = S[0], H = S[1], K = S[2], Q = S[3];
          return I[0] = $ * q + Q * k + H * U - K * V, I[1] = H * q + Q * V + K * k - $ * U, I[2] = K * q + Q * U + $ * V - H * k, I[3] = Q * q - $ * k - H * V - K * U, I[4] = ($ = S[4]) * q + (Q = S[7]) * k + (H = S[5]) * U - (K = S[6]) * V, I[5] = H * q + Q * V + K * k - $ * U, I[6] = K * q + Q * U + $ * V - H * k, I[7] = Q * q - $ * k - H * V - K * U, I;
        }, jt.rotateByQuatPrepend = function(I, S, C) {
          var k = S[0], V = S[1], U = S[2], q = S[3], $ = C[0], H = C[1], K = C[2], Q = C[3];
          return I[0] = k * Q + q * $ + V * K - U * H, I[1] = V * Q + q * H + U * $ - k * K, I[2] = U * Q + q * K + k * H - V * $, I[3] = q * Q - k * $ - V * H - U * K, I[4] = k * (Q = C[7]) + q * ($ = C[4]) + V * (K = C[6]) - U * (H = C[5]), I[5] = V * Q + q * H + U * $ - k * K, I[6] = U * Q + q * K + k * H - V * $, I[7] = q * Q - k * $ - V * H - U * K, I;
        }, jt.rotateAroundAxis = function(I, S, C, k) {
          if (Math.abs(k) < e.EPSILON)
            return v(I, S);
          var V = Math.hypot(C[0], C[1], C[2]);
          k *= 0.5;
          var U = Math.sin(k), q = U * C[0] / V, $ = U * C[1] / V, H = U * C[2] / V, K = Math.cos(k), Q = S[0], ie = S[1], fe = S[2], de = S[3];
          I[0] = Q * K + de * q + ie * H - fe * $, I[1] = ie * K + de * $ + fe * q - Q * H, I[2] = fe * K + de * H + Q * $ - ie * q, I[3] = de * K - Q * q - ie * $ - fe * H;
          var he = S[4], Me = S[5], me = S[6], Ee = S[7];
          return I[4] = he * K + Ee * q + Me * H - me * $, I[5] = Me * K + Ee * $ + me * q - he * H, I[6] = me * K + Ee * H + he * $ - Me * q, I[7] = Ee * K - he * q - Me * $ - me * H, I;
        }, jt.add = function(I, S, C) {
          return I[0] = S[0] + C[0], I[1] = S[1] + C[1], I[2] = S[2] + C[2], I[3] = S[3] + C[3], I[4] = S[4] + C[4], I[5] = S[5] + C[5], I[6] = S[6] + C[6], I[7] = S[7] + C[7], I;
        }, jt.multiply = M, jt.scale = function(I, S, C) {
          return I[0] = S[0] * C, I[1] = S[1] * C, I[2] = S[2] * C, I[3] = S[3] * C, I[4] = S[4] * C, I[5] = S[5] * C, I[6] = S[6] * C, I[7] = S[7] * C, I;
        }, jt.lerp = function(I, S, C, k) {
          var V = 1 - k;
          return D(S, C) < 0 && (k = -k), I[0] = S[0] * V + C[0] * k, I[1] = S[1] * V + C[1] * k, I[2] = S[2] * V + C[2] * k, I[3] = S[3] * V + C[3] * k, I[4] = S[4] * V + C[4] * k, I[5] = S[5] * V + C[5] * k, I[6] = S[6] * V + C[6] * k, I[7] = S[7] * V + C[7] * k, I;
        }, jt.invert = function(I, S) {
          var C = E(S);
          return I[0] = -S[0] / C, I[1] = -S[1] / C, I[2] = -S[2] / C, I[3] = S[3] / C, I[4] = -S[4] / C, I[5] = -S[5] / C, I[6] = -S[6] / C, I[7] = S[7] / C, I;
        }, jt.conjugate = function(I, S) {
          return I[0] = -S[0], I[1] = -S[1], I[2] = -S[2], I[3] = S[3], I[4] = -S[4], I[5] = -S[5], I[6] = -S[6], I[7] = S[7], I;
        }, jt.normalize = function(I, S) {
          var C = E(S);
          if (C > 0) {
            C = Math.sqrt(C);
            var k = S[0] / C, V = S[1] / C, U = S[2] / C, q = S[3] / C, $ = S[4], H = S[5], K = S[6], Q = S[7], ie = k * $ + V * H + U * K + q * Q;
            I[0] = k, I[1] = V, I[2] = U, I[3] = q, I[4] = ($ - k * ie) / C, I[5] = (H - V * ie) / C, I[6] = (K - U * ie) / C, I[7] = (Q - q * ie) / C;
          }
          return I;
        }, jt.str = function(I) {
          return "quat2(" + I[0] + ", " + I[1] + ", " + I[2] + ", " + I[3] + ", " + I[4] + ", " + I[5] + ", " + I[6] + ", " + I[7] + ")";
        }, jt.exactEquals = function(I, S) {
          return I[0] === S[0] && I[1] === S[1] && I[2] === S[2] && I[3] === S[3] && I[4] === S[4] && I[5] === S[5] && I[6] === S[6] && I[7] === S[7];
        }, jt.equals = function(I, S) {
          var C = I[0], k = I[1], V = I[2], U = I[3], q = I[4], $ = I[5], H = I[6], K = I[7], Q = S[0], ie = S[1], fe = S[2], de = S[3], he = S[4], Me = S[5], me = S[6], Ee = S[7];
          return Math.abs(C - Q) <= e.EPSILON * Math.max(1, Math.abs(C), Math.abs(Q)) && Math.abs(k - ie) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(ie)) && Math.abs(V - fe) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(fe)) && Math.abs(U - de) <= e.EPSILON * Math.max(1, Math.abs(U), Math.abs(de)) && Math.abs(q - he) <= e.EPSILON * Math.max(1, Math.abs(q), Math.abs(he)) && Math.abs($ - Me) <= e.EPSILON * Math.max(1, Math.abs($), Math.abs(Me)) && Math.abs(H - me) <= e.EPSILON * Math.max(1, Math.abs(H), Math.abs(me)) && Math.abs(K - Ee) <= e.EPSILON * Math.max(1, Math.abs(K), Math.abs(Ee));
        }, jt.sqrLen = jt.squaredLength = jt.len = jt.length = jt.dot = jt.mul = jt.setReal = jt.getReal = void 0;
        var e = l(ae()), n = l(Ji()), o = l(Gt());
        function u(I) {
          if (typeof WeakMap != "function")
            return null;
          var S = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap();
          return (u = function(k) {
            return k ? C : S;
          })(I);
        }
        function l(I, S) {
          if (I && I.__esModule)
            return I;
          if (I === null || r(I) !== "object" && typeof I != "function")
            return { default: I };
          var C = u(S);
          if (C && C.has(I))
            return C.get(I);
          var k = {}, V = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var U in I)
            if (U !== "default" && Object.prototype.hasOwnProperty.call(I, U)) {
              var q = V ? Object.getOwnPropertyDescriptor(I, U) : null;
              q && (q.get || q.set) ? Object.defineProperty(k, U, q) : k[U] = I[U];
            }
          return k.default = I, C && C.set(I, k), k;
        }
        function d(I, S, C) {
          var k = 0.5 * C[0], V = 0.5 * C[1], U = 0.5 * C[2], q = S[0], $ = S[1], H = S[2], K = S[3];
          return I[0] = q, I[1] = $, I[2] = H, I[3] = K, I[4] = k * K + V * H - U * $, I[5] = V * K + U * q - k * H, I[6] = U * K + k * $ - V * q, I[7] = -k * q - V * $ - U * H, I;
        }
        function v(I, S) {
          return I[0] = S[0], I[1] = S[1], I[2] = S[2], I[3] = S[3], I[4] = S[4], I[5] = S[5], I[6] = S[6], I[7] = S[7], I;
        }
        function M(I, S, C) {
          var k = S[0], V = S[1], U = S[2], q = S[3], $ = C[4], H = C[5], K = C[6], Q = C[7], ie = S[4], fe = S[5], de = S[6], he = S[7], Me = C[0], me = C[1], Ee = C[2], ze = C[3];
          return I[0] = k * ze + q * Me + V * Ee - U * me, I[1] = V * ze + q * me + U * Me - k * Ee, I[2] = U * ze + q * Ee + k * me - V * Me, I[3] = q * ze - k * Me - V * me - U * Ee, I[4] = k * Q + q * $ + V * K - U * H + ie * ze + he * Me + fe * Ee - de * me, I[5] = V * Q + q * H + U * $ - k * K + fe * ze + he * me + de * Me - ie * Ee, I[6] = U * Q + q * K + k * H - V * $ + de * ze + he * Ee + ie * me - fe * Me, I[7] = q * Q - k * $ - V * H - U * K + he * ze - ie * Me - fe * me - de * Ee, I;
        }
        jt.getReal = n.copy, jt.setReal = n.copy, jt.mul = M;
        var D = n.dot;
        jt.dot = D;
        var x = n.length;
        jt.length = x, jt.len = x;
        var E = n.squaredLength;
        return jt.squaredLength = E, jt.sqrLen = E, jt;
      }
      var Gi, an, qt = {};
      function ln() {
        if (Gi)
          return qt;
        function r(S) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(S);
        }
        Gi = 1, Object.defineProperty(qt, "__esModule", { value: !0 }), qt.create = o, qt.clone = function(S) {
          var C = new e.ARRAY_TYPE(2);
          return C[0] = S[0], C[1] = S[1], C;
        }, qt.fromValues = function(S, C) {
          var k = new e.ARRAY_TYPE(2);
          return k[0] = S, k[1] = C, k;
        }, qt.copy = function(S, C) {
          return S[0] = C[0], S[1] = C[1], S;
        }, qt.set = function(S, C, k) {
          return S[0] = C, S[1] = k, S;
        }, qt.add = function(S, C, k) {
          return S[0] = C[0] + k[0], S[1] = C[1] + k[1], S;
        }, qt.subtract = u, qt.multiply = l, qt.divide = d, qt.ceil = function(S, C) {
          return S[0] = Math.ceil(C[0]), S[1] = Math.ceil(C[1]), S;
        }, qt.floor = function(S, C) {
          return S[0] = Math.floor(C[0]), S[1] = Math.floor(C[1]), S;
        }, qt.min = function(S, C, k) {
          return S[0] = Math.min(C[0], k[0]), S[1] = Math.min(C[1], k[1]), S;
        }, qt.max = function(S, C, k) {
          return S[0] = Math.max(C[0], k[0]), S[1] = Math.max(C[1], k[1]), S;
        }, qt.round = function(S, C) {
          return S[0] = Math.round(C[0]), S[1] = Math.round(C[1]), S;
        }, qt.scale = function(S, C, k) {
          return S[0] = C[0] * k, S[1] = C[1] * k, S;
        }, qt.scaleAndAdd = function(S, C, k, V) {
          return S[0] = C[0] + k[0] * V, S[1] = C[1] + k[1] * V, S;
        }, qt.distance = v, qt.squaredDistance = M, qt.length = D, qt.squaredLength = x, qt.negate = function(S, C) {
          return S[0] = -C[0], S[1] = -C[1], S;
        }, qt.inverse = function(S, C) {
          return S[0] = 1 / C[0], S[1] = 1 / C[1], S;
        }, qt.normalize = function(S, C) {
          var k = C[0], V = C[1], U = k * k + V * V;
          return U > 0 && (U = 1 / Math.sqrt(U)), S[0] = C[0] * U, S[1] = C[1] * U, S;
        }, qt.dot = function(S, C) {
          return S[0] * C[0] + S[1] * C[1];
        }, qt.cross = function(S, C, k) {
          var V = C[0] * k[1] - C[1] * k[0];
          return S[0] = S[1] = 0, S[2] = V, S;
        }, qt.lerp = function(S, C, k, V) {
          var U = C[0], q = C[1];
          return S[0] = U + V * (k[0] - U), S[1] = q + V * (k[1] - q), S;
        }, qt.random = function(S, C) {
          C = C || 1;
          var k = 2 * e.RANDOM() * Math.PI;
          return S[0] = Math.cos(k) * C, S[1] = Math.sin(k) * C, S;
        }, qt.transformMat2 = function(S, C, k) {
          var V = C[0], U = C[1];
          return S[0] = k[0] * V + k[2] * U, S[1] = k[1] * V + k[3] * U, S;
        }, qt.transformMat2d = function(S, C, k) {
          var V = C[0], U = C[1];
          return S[0] = k[0] * V + k[2] * U + k[4], S[1] = k[1] * V + k[3] * U + k[5], S;
        }, qt.transformMat3 = function(S, C, k) {
          var V = C[0], U = C[1];
          return S[0] = k[0] * V + k[3] * U + k[6], S[1] = k[1] * V + k[4] * U + k[7], S;
        }, qt.transformMat4 = function(S, C, k) {
          var V = C[0], U = C[1];
          return S[0] = k[0] * V + k[4] * U + k[12], S[1] = k[1] * V + k[5] * U + k[13], S;
        }, qt.rotate = function(S, C, k, V) {
          var U = C[0] - k[0], q = C[1] - k[1], $ = Math.sin(V), H = Math.cos(V);
          return S[0] = U * H - q * $ + k[0], S[1] = U * $ + q * H + k[1], S;
        }, qt.angle = function(S, C) {
          var k = S[0], V = S[1], U = C[0], q = C[1], $ = Math.sqrt(k * k + V * V) * Math.sqrt(U * U + q * q);
          return Math.acos(Math.min(Math.max($ && (k * U + V * q) / $, -1), 1));
        }, qt.zero = function(S) {
          return S[0] = 0, S[1] = 0, S;
        }, qt.str = function(S) {
          return "vec2(" + S[0] + ", " + S[1] + ")";
        }, qt.exactEquals = function(S, C) {
          return S[0] === C[0] && S[1] === C[1];
        }, qt.equals = function(S, C) {
          var k = S[0], V = S[1], U = C[0], q = C[1];
          return Math.abs(k - U) <= e.EPSILON * Math.max(1, Math.abs(k), Math.abs(U)) && Math.abs(V - q) <= e.EPSILON * Math.max(1, Math.abs(V), Math.abs(q));
        }, qt.forEach = qt.sqrLen = qt.sqrDist = qt.dist = qt.div = qt.mul = qt.sub = qt.len = void 0;
        var e = function(S, C) {
          if (S && S.__esModule)
            return S;
          if (S === null || r(S) !== "object" && typeof S != "function")
            return { default: S };
          var k = n(void 0);
          if (k && k.has(S))
            return k.get(S);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in S)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(S, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(S, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = S[q];
            }
          return V.default = S, k && k.set(S, V), V;
        }(ae());
        function n(S) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (n = function(V) {
            return V ? k : C;
          })(S);
        }
        function o() {
          var S = new e.ARRAY_TYPE(2);
          return e.ARRAY_TYPE != Float32Array && (S[0] = 0, S[1] = 0), S;
        }
        function u(S, C, k) {
          return S[0] = C[0] - k[0], S[1] = C[1] - k[1], S;
        }
        function l(S, C, k) {
          return S[0] = C[0] * k[0], S[1] = C[1] * k[1], S;
        }
        function d(S, C, k) {
          return S[0] = C[0] / k[0], S[1] = C[1] / k[1], S;
        }
        function v(S, C) {
          return Math.hypot(C[0] - S[0], C[1] - S[1]);
        }
        function M(S, C) {
          var k = C[0] - S[0], V = C[1] - S[1];
          return k * k + V * V;
        }
        function D(S) {
          return Math.hypot(S[0], S[1]);
        }
        function x(S) {
          var C = S[0], k = S[1];
          return C * C + k * k;
        }
        qt.len = D, qt.sub = u, qt.mul = l, qt.div = d, qt.dist = v, qt.sqrDist = M, qt.sqrLen = x;
        var E, I = (E = o(), function(S, C, k, V, U, q) {
          var $, H;
          for (C || (C = 2), k || (k = 0), H = V ? Math.min(V * C + k, S.length) : S.length, $ = k; $ < H; $ += C)
            E[0] = S[$], E[1] = S[$ + 1], U(E, E, q), S[$] = E[0], S[$ + 1] = E[1];
          return S;
        });
        return qt.forEach = I, qt;
      }
      function Di() {
        if (an)
          return Y;
        function r(S) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
            return typeof C;
          } : function(C) {
            return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
          }, r(S);
        }
        an = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.vec4 = Y.vec3 = Y.vec2 = Y.quat2 = Y.quat = Y.mat4 = Y.mat3 = Y.mat2d = Y.mat2 = Y.glMatrix = void 0;
        var e = I(ae());
        Y.glMatrix = e;
        var n = I(we());
        Y.mat2 = n;
        var o = I(lt());
        Y.mat2d = o;
        var u = I(bt());
        Y.mat3 = u;
        var l = I(Gt());
        Y.mat4 = l;
        var d = I(Ji());
        Y.quat = d;
        var v = I(ni());
        Y.quat2 = v;
        var M = I(ln());
        Y.vec2 = M;
        var D = I(Si());
        Y.vec3 = D;
        var x = I(Mi());
        function E(S) {
          if (typeof WeakMap != "function")
            return null;
          var C = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
          return (E = function(V) {
            return V ? k : C;
          })(S);
        }
        function I(S, C) {
          if (S && S.__esModule)
            return S;
          if (S === null || r(S) !== "object" && typeof S != "function")
            return { default: S };
          var k = E(C);
          if (k && k.has(S))
            return k.get(S);
          var V = {}, U = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var q in S)
            if (q !== "default" && Object.prototype.hasOwnProperty.call(S, q)) {
              var $ = U ? Object.getOwnPropertyDescriptor(S, q) : null;
              $ && ($.get || $.set) ? Object.defineProperty(V, q, $) : V[q] = S[q];
            }
          return V.default = S, k && k.set(S, V), V;
        }
        return Y.vec4 = x, Y;
      }
      var xi, Cs, xs, Is, De = Di(), Vs = function() {
        if (Cs)
          return xi;
        function r(e, n, o, u) {
          this.cx = 3 * e, this.bx = 3 * (o - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * n, this.by = 3 * (u - n) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = n, this.p2x = o, this.p2y = u;
        }
        return Cs = 1, xi = r, r.prototype = { sampleCurveX: function(e) {
          return ((this.ax * e + this.bx) * e + this.cx) * e;
        }, sampleCurveY: function(e) {
          return ((this.ay * e + this.by) * e + this.cy) * e;
        }, sampleCurveDerivativeX: function(e) {
          return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
        }, solveCurveX: function(e, n) {
          if (n === void 0 && (n = 1e-6), e < 0)
            return 0;
          if (e > 1)
            return 1;
          for (var o = e, u = 0; u < 8; u++) {
            var l = this.sampleCurveX(o) - e;
            if (Math.abs(l) < n)
              return o;
            var d = this.sampleCurveDerivativeX(o);
            if (Math.abs(d) < 1e-6)
              break;
            o -= l / d;
          }
          var v = 0, M = 1;
          for (o = e, u = 0; u < 20 && (l = this.sampleCurveX(o), !(Math.abs(l - e) < n)); u++)
            e > l ? v = o : M = o, o = 0.5 * (M - v) + v;
          return o;
        }, solve: function(e, n) {
          return this.sampleCurveY(this.solveCurveX(e, n));
        } }, xi;
      }(), Us = O(Vs);
      function Zr() {
        if (Is)
          return xs;
        function r(e, n) {
          this.x = e, this.y = n;
        }
        return Is = 1, xs = r, r.prototype = { clone: function() {
          return new r(this.x, this.y);
        }, add: function(e) {
          return this.clone()._add(e);
        }, sub: function(e) {
          return this.clone()._sub(e);
        }, multByPoint: function(e) {
          return this.clone()._multByPoint(e);
        }, divByPoint: function(e) {
          return this.clone()._divByPoint(e);
        }, mult: function(e) {
          return this.clone()._mult(e);
        }, div: function(e) {
          return this.clone()._div(e);
        }, rotate: function(e) {
          return this.clone()._rotate(e);
        }, rotateAround: function(e, n) {
          return this.clone()._rotateAround(e, n);
        }, matMult: function(e) {
          return this.clone()._matMult(e);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(e) {
          return this.x === e.x && this.y === e.y;
        }, dist: function(e) {
          return Math.sqrt(this.distSqr(e));
        }, distSqr: function(e) {
          var n = e.x - this.x, o = e.y - this.y;
          return n * n + o * o;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(e) {
          return Math.atan2(this.y - e.y, this.x - e.x);
        }, angleWith: function(e) {
          return this.angleWithSep(e.x, e.y);
        }, angleWithSep: function(e, n) {
          return Math.atan2(this.x * n - this.y * e, this.x * e + this.y * n);
        }, _matMult: function(e) {
          var n = e[2] * this.x + e[3] * this.y;
          return this.x = e[0] * this.x + e[1] * this.y, this.y = n, this;
        }, _add: function(e) {
          return this.x += e.x, this.y += e.y, this;
        }, _sub: function(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }, _mult: function(e) {
          return this.x *= e, this.y *= e, this;
        }, _div: function(e) {
          return this.x /= e, this.y /= e, this;
        }, _multByPoint: function(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }, _divByPoint: function(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var e = this.y;
          return this.y = this.x, this.x = -e, this;
        }, _rotate: function(e) {
          var n = Math.cos(e), o = Math.sin(e), u = o * this.x + n * this.y;
          return this.x = n * this.x - o * this.y, this.y = u, this;
        }, _rotateAround: function(e, n) {
          var o = Math.cos(e), u = Math.sin(e), l = n.y + u * (this.x - n.x) + o * (this.y - n.y);
          return this.x = n.x + o * (this.x - n.x) - u * (this.y - n.y), this.y = l, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, r.convert = function(e) {
          return e instanceof r ? e : Array.isArray(e) ? new r(e[0], e[1]) : e;
        }, xs;
      }
      var Mt = O(Zr());
      function ir(r, e) {
        if (Array.isArray(r)) {
          if (!Array.isArray(e) || r.length !== e.length)
            return !1;
          for (let n = 0; n < r.length; n++)
            if (!ir(r[n], e[n]))
              return !1;
          return !0;
        }
        if (typeof r == "object" && r !== null && e !== null) {
          if (typeof e != "object" || Object.keys(r).length !== Object.keys(e).length)
            return !1;
          for (const n in r)
            if (!ir(r[n], e[n]))
              return !1;
          return !0;
        }
        return r === e;
      }
      const $n = Math.PI / 180, Ws = 180 / Math.PI;
      function vi(r) {
        return r * $n;
      }
      function kn(r) {
        return r * Ws;
      }
      const $s = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function Hr(r) {
        if (r <= 0)
          return 0;
        if (r >= 1)
          return 1;
        const e = r * r, n = e * r;
        return 4 * (r < 0.5 ? n : 3 * (r - e) + n - 0.75);
      }
      function qr(r, e, n, o) {
        const u = new Us(r, e, n, o);
        return function(l) {
          return u.solve(l);
        };
      }
      const Wr = qr(0.25, 0.1, 0.25, 1);
      function si(r, e, n) {
        return Math.min(n, Math.max(e, r));
      }
      function fs(r, e, n) {
        return (n = si((n - r) / (e - r), 0, 1)) * n * (3 - 2 * n);
      }
      function zn(r, e, n) {
        const o = n - e, u = ((r - e) % o + o) % o + e;
        return u === e ? n : u;
      }
      function Rn(r, e, n) {
        if (!r.length)
          return n(null, []);
        let o = r.length;
        const u = new Array(r.length);
        let l = null;
        r.forEach((d, v) => {
          e(d, (M, D) => {
            M && (l = M), u[v] = D, --o == 0 && n(l, u);
          });
        });
      }
      function Pn(r, ...e) {
        for (const n of e)
          for (const o in n)
            r[o] = n[o];
        return r;
      }
      let js = 1;
      function go() {
        return js++;
      }
      function yo(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
      }
      function xo(r, e) {
        r.forEach((n) => {
          e[n] && (e[n] = e[n].bind(e));
        });
      }
      function yr(r, e) {
        return r.indexOf(e, r.length - e.length) !== -1;
      }
      function Sr(r, e, n) {
        const o = {};
        for (const u in r)
          o[u] = e.call(this, r[u], u, r);
        return o;
      }
      function io(r, e, n) {
        const o = {};
        for (const u in r)
          e.call(this, r[u], u, r) && (o[u] = r[u]);
        return o;
      }
      function Xs(r) {
        return Array.isArray(r) ? r.map(Xs) : typeof r == "object" && r ? Sr(r, Xs) : r;
      }
      const Mr = {};
      function mi(r) {
        Mr[r] || (typeof console < "u" && console.warn(r), Mr[r] = !0);
      }
      function On(r, e, n) {
        return (n.y - r.y) * (e.x - r.x) > (e.y - r.y) * (n.x - r.x);
      }
      function Vn(r) {
        let e = 0;
        for (let n, o, u = 0, l = r.length, d = l - 1; u < l; d = u++)
          n = r[u], o = r[d], e += (o.x - n.x) * (n.y + o.y);
        return e;
      }
      function Zi([r, e, n]) {
        const o = vi(e + 90), u = vi(n);
        return { x: r * Math.cos(o) * Math.sin(u), y: r * Math.sin(o) * Math.sin(u), z: r * Math.cos(u), azimuthal: e, polar: n };
      }
      function Jn() {
        return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope;
      }
      function Fn(r) {
        const e = {};
        if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, o, u, l) => {
          const d = u || l;
          return e[o] = !d || d.toLowerCase(), "";
        }), e["max-age"]) {
          const n = parseInt(e["max-age"], 10);
          isNaN(n) ? delete e["max-age"] : e["max-age"] = n;
        }
        return e;
      }
      let Ls = null;
      function zs(r, e) {
        return [r[4 * e], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]];
      }
      function No(r, e, n, o) {
        for (; e < n; ) {
          const u = e + n >> 1;
          r[u] < o ? e = u + 1 : n = u;
        }
        return e;
      }
      function Ke(r, e, n, o) {
        for (; e < n; ) {
          const u = e + n >> 1;
          r[u] <= o ? e = u + 1 : n = u;
        }
        return e;
      }
      function re(r) {
        return r > 0 ? 1 / (1.001 - r) : 1 + r;
      }
      function le(r) {
        return r > 0 ? 1 - 1 / (1.001 - r) : -r;
      }
      const ge = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
      }, get API_TILEJSON_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
      }, get API_SPRITE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
      }, get API_FONTS_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
      }, get API_STYLE_REGEX() {
        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
      }, get API_CDN_URL_REGEX() {
        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
      }, get EVENTS_URL() {
        if (!ge.API_URL)
          return null;
        try {
          const r = new URL(ge.API_URL);
          return r.hostname === "api.mapbox.cn" ? "https://events.mapbox.cn/events/v2" : r.hostname === "api.mapbox.com" ? "https://events.mapbox.com/events/v2" : null;
        } catch {
          return null;
        }
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: !0, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
      function Le(r) {
        return ge.API_URL_REGEX.test(r);
      }
      function Ce(r) {
        return ge.API_SPRITE_REGEX.test(r);
      }
      let Be, He, Ae, Ye, Qe, it;
      function mt() {
        return Be == null && (Be = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && typeof self.createImageBitmap == "function"), Be;
      }
      const Ct = { now: () => Ye !== void 0 ? Ye : performance.now(), setNow(r) {
        Ye = r;
      }, restoreNow() {
        Ye = void 0;
      }, frame(r) {
        const e = requestAnimationFrame(r);
        return { cancel: () => cancelAnimationFrame(e) };
      }, getImageData(r, e = 0) {
        const { width: n, height: o } = r;
        Qe || (Qe = document.createElement("canvas"));
        const u = Qe.getContext("2d", { willReadFrequently: !0 });
        if (!u)
          throw new Error("failed to create canvas 2d context");
        return (n > Qe.width || o > Qe.height) && (Qe.width = n, Qe.height = o), u.clearRect(-e, -e, n + 2 * e, o + 2 * e), u.drawImage(r, 0, 0, n, o), u.getImageData(-e, -e, n + 2 * e, o + 2 * e);
      }, resolveURL: (r) => (He || (He = document.createElement("a")), He.href = r, He.href), get devicePixelRatio() {
        return window.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!window.matchMedia && (Ae == null && (Ae = window.matchMedia("(prefers-reduced-motion: reduce)")), Ae.matches);
      }, hasCanvasFingerprintNoise() {
        if (it !== void 0)
          return it;
        if (!mt())
          return it = !1, !1;
        const r = new OffscreenCanvas(85, 1), e = r.getContext("2d", { willReadFrequently: !0 });
        let n = 0;
        for (let u = 0; u < r.width; ++u)
          e.fillStyle = `rgba(${n++},${n++},${n++}, 255)`, e.fillRect(u, 0, 1, 1);
        const o = e.getImageData(0, 0, r.width, r.height);
        n = 0;
        for (let u = 0; u < o.data.length; ++u)
          if (u % 4 != 3 && n++ !== o.data[u])
            return it = !0, !0;
        return it = !1, !1;
      } };
      function It(r, e) {
        const n = r.indexOf("?");
        if (n < 0)
          return `${r}?${new URLSearchParams(e).toString()}`;
        const o = new URLSearchParams(r.slice(n));
        for (const u in e)
          o.set(u, e[u]);
        return `${r.slice(0, n)}?${o.toString()}`;
      }
      function Kt(r, e = { persistentParams: [] }) {
        const n = r.indexOf("?");
        if (n < 0)
          return r;
        const o = new URLSearchParams(), u = new URLSearchParams(r.slice(n));
        for (const d of e.persistentParams) {
          const v = u.get(d);
          v && o.set(d, v);
        }
        const l = o.toString();
        return `${r.slice(0, n)}${l.length > 0 ? `?${l}` : ""}`;
      }
      const di = "mapbox-tiles";
      let li = 500, ri = 50;
      const Ki = ["language", "worldview", "jobid"];
      let Ni, Ei;
      function $i() {
        try {
          return caches;
        } catch {
        }
      }
      function Hi() {
        const r = $i();
        r && Ni == null && (Ni = r.open(di));
      }
      let Xn = 1 / 0;
      const Gs = { supported: !1, testSupport: function(r) {
        !sa && vs && (Er ? al(r) : ps = r);
      } };
      let ps, vs, sa = !1, Er = !1;
      const ra = typeof self < "u" ? self : {};
      function al(r) {
        const e = r.createTexture();
        r.bindTexture(r.TEXTURE_2D, e);
        try {
          if (r.texImage2D(r.TEXTURE_2D, 0, r.RGBA, r.RGBA, r.UNSIGNED_BYTE, vs), r.isContextLost())
            return;
          Gs.supported = !0;
        } catch {
        }
        r.deleteTexture(e), sa = !0;
      }
      ra.document && (vs = ra.document.createElement("img"), vs.onload = function() {
        ps && al(ps), ps = null, Er = !0;
      }, vs.onerror = function() {
        sa = !0, ps = null;
      }, vs.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const Vo = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
      typeof Object.freeze == "function" && Object.freeze(Vo);
      class Uo extends Error {
        constructor(e, n, o) {
          n === 401 && Le(o) && (e += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(e), this.status = n, this.url = o;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const tn = Jn() ? () => self.worker && self.worker.referrer : () => (location.protocol === "blob:" ? parent : self).location.href, xn = function(r, e) {
        if (!(/^file:/.test(n = r.url) || /^file:/.test(tn()) && !/^\w+:/.test(n))) {
          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal"))
            return function(o, u) {
              const l = new AbortController(), d = new Request(o.url, { method: o.method || "GET", body: o.body, credentials: o.credentials, headers: o.headers, referrer: tn(), referrerPolicy: o.referrerPolicy, signal: l.signal });
              let v = !1, M = !1;
              const D = (x = d.url).indexOf("sku=") > 0 && Le(x);
              var x;
              o.type === "json" && d.headers.set("Accept", "application/json");
              const E = (S, C, k) => {
                if (M)
                  return;
                if (S && S.message !== "SecurityError" && mi(S.toString()), C && k)
                  return I(C);
                const V = Date.now();
                fetch(d).then((U) => {
                  if (U.ok) {
                    const q = D ? U.clone() : null;
                    return I(U, q, V);
                  }
                  return u(new Uo(U.statusText, U.status, o.url));
                }).catch((U) => {
                  U.name !== "AbortError" && u(new Error(`${U.message} ${o.url}`));
                });
              }, I = (S, C, k) => {
                (o.type === "arrayBuffer" ? S.arrayBuffer() : o.type === "json" ? S.json() : S.text()).then((V) => {
                  M || (C && k && function(U, q, $) {
                    if (Hi(), Ni == null)
                      return;
                    const H = Fn(q.headers.get("Cache-Control") || "");
                    if (H["no-store"])
                      return;
                    const K = { status: q.status, statusText: q.statusText, headers: new Headers() };
                    q.headers.forEach((fe, de) => K.headers.set(de, fe)), H["max-age"] && K.headers.set("Expires", new Date($ + 1e3 * H["max-age"]).toUTCString());
                    const Q = K.headers.get("Expires");
                    if (!Q || new Date(Q).getTime() - $ < 42e4)
                      return;
                    let ie = Kt(U.url, { persistentParams: Ki });
                    if (q.status === 206) {
                      const fe = U.headers.get("Range");
                      if (!fe)
                        return;
                      K.status = 200, ie = It(ie, { range: fe });
                    }
                    (function(fe, de) {
                      if (Ei === void 0)
                        try {
                          new Response(new ReadableStream()), Ei = !0;
                        } catch {
                          Ei = !1;
                        }
                      Ei ? de(fe.body) : fe.blob().then(de);
                    })(q, (fe) => {
                      const de = new Response((he = q.status) !== 200 && he !== 404 && [101, 103, 204, 205, 304].includes(he) ? null : fe, K);
                      var he;
                      Hi(), Ni != null && Ni.then((Me) => Me.put(ie, de)).catch((Me) => mi(Me.message));
                    });
                  }(d, C, k), v = !0, u(null, V, S.headers.get("Cache-Control"), S.headers.get("Expires")));
                }).catch((V) => {
                  M || u(new Error(V.message));
                });
              };
              return D ? function(S, C) {
                if (Hi(), Ni == null)
                  return C(null);
                Ni.then((k) => {
                  let V = Kt(S.url, { persistentParams: Ki });
                  const U = S.headers.get("Range");
                  U && (V = It(V, { range: U })), k.match(V).then((q) => {
                    const $ = function(H) {
                      if (!H)
                        return !1;
                      const K = new Date(H.headers.get("Expires") || 0), Q = Fn(H.headers.get("Cache-Control") || "");
                      return K > Date.now() && !Q["no-cache"];
                    }(q);
                    k.delete(V), $ && k.put(V, q.clone()), C(null, q, $);
                  }).catch(C);
                }).catch(C);
              }(d, E) : E(null, null), { cancel: () => {
                M = !0, v || l.abort();
              } };
            }(r, e);
          if (Jn() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", r, e, void 0, !0);
        }
        var n;
        return function(o, u) {
          const l = new XMLHttpRequest();
          l.open(o.method || "GET", o.url, !0), o.type === "arrayBuffer" && (l.responseType = "arraybuffer");
          for (const d in o.headers)
            l.setRequestHeader(d, o.headers[d]);
          return o.type === "json" && (l.responseType = "text", l.setRequestHeader("Accept", "application/json")), l.withCredentials = o.credentials === "include", l.onerror = () => {
            u(new Error(l.statusText));
          }, l.onload = () => {
            if ((l.status >= 200 && l.status < 300 || l.status === 0) && l.response !== null) {
              let d = l.response;
              if (o.type === "json")
                try {
                  d = JSON.parse(l.response);
                } catch (v) {
                  return u(v);
                }
              u(null, d, l.getResponseHeader("Cache-Control"), l.getResponseHeader("Expires"));
            } else
              u(new Uo(l.statusText, l.status, o.url));
          }, l.send(o.body), { cancel: () => l.abort() };
        }(r, e);
      }, no = function(r, e) {
        return xn(Pn(r, { type: "arrayBuffer" }), e);
      };
      function jo(r) {
        const e = document.createElement("a");
        return e.href = r, e.protocol === location.protocol && e.host === location.host;
      }
      const oa = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let La, Vi;
      La = [], Vi = 0;
      const Hn = function(r, e) {
        if (Gs.supported && (r.headers || (r.headers = {}), r.headers.accept = "image/webp,*/*"), Vi >= ge.MAX_PARALLEL_IMAGE_REQUESTS) {
          const l = { requestParameters: r, callback: e, cancelled: !1, cancel() {
            this.cancelled = !0;
          } };
          return La.push(l), l;
        }
        Vi++;
        let n = !1;
        const o = () => {
          if (!n)
            for (n = !0, Vi--; La.length && Vi < ge.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const l = La.shift(), { requestParameters: d, callback: v, cancelled: M } = l;
              M || (l.cancel = Hn(d, v).cancel);
            }
        }, u = no(r, (l, d, v, M) => {
          o(), l ? e(l) : d && (self.createImageBitmap ? function(D, x) {
            const E = new Blob([new Uint8Array(D)], { type: "image/png" });
            createImageBitmap(E).then((I) => {
              x(null, I);
            }).catch((I) => {
              x(new Error(`Could not load image because of ${I.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(d, (D, x) => e(D, x, v, M)) : function(D, x) {
            const E = new Image();
            E.onload = () => {
              x(null, E), URL.revokeObjectURL(E.src), E.onload = null, requestAnimationFrame(() => {
                E.src = oa;
              });
            }, E.onerror = () => x(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const I = new Blob([new Uint8Array(D)], { type: "image/png" });
            E.src = D.byteLength ? URL.createObjectURL(I) : oa;
          }(d, (D, x) => e(D, x, v, M)));
        });
        return { cancel: () => {
          u.cancel(), o();
        } };
      };
      var ll, Zs, Qn, Ar = { exports: {} }, nr = { exports: {} }, Ys = { exports: {} }, Yn = function() {
        if (Qn)
          return Ar.exports;
        Qn = 1;
        var r = (ll || (ll = 1, nr.exports = function(n, o) {
          var u, l, d, v, M, D, x, E;
          for (l = n.length - (u = 3 & n.length), d = o, M = 3432918353, D = 461845907, E = 0; E < l; )
            x = 255 & n.charCodeAt(E) | (255 & n.charCodeAt(++E)) << 8 | (255 & n.charCodeAt(++E)) << 16 | (255 & n.charCodeAt(++E)) << 24, ++E, d = 27492 + (65535 & (v = 5 * (65535 & (d = (d ^= x = (65535 & (x = (x = (65535 & x) * M + (((x >>> 16) * M & 65535) << 16) & 4294967295) << 15 | x >>> 17)) * D + (((x >>> 16) * D & 65535) << 16) & 4294967295) << 13 | d >>> 19)) + ((5 * (d >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (v >>> 16) & 65535) << 16);
          switch (x = 0, u) {
            case 3:
              x ^= (255 & n.charCodeAt(E + 2)) << 16;
            case 2:
              x ^= (255 & n.charCodeAt(E + 1)) << 8;
            case 1:
              d ^= x = (65535 & (x = (x = (65535 & (x ^= 255 & n.charCodeAt(E))) * M + (((x >>> 16) * M & 65535) << 16) & 4294967295) << 15 | x >>> 17)) * D + (((x >>> 16) * D & 65535) << 16) & 4294967295;
          }
          return d ^= n.length, d = 2246822507 * (65535 & (d ^= d >>> 16)) + ((2246822507 * (d >>> 16) & 65535) << 16) & 4294967295, d = 3266489909 * (65535 & (d ^= d >>> 13)) + ((3266489909 * (d >>> 16) & 65535) << 16) & 4294967295, (d ^= d >>> 16) >>> 0;
        }), nr.exports), e = (Zs || (Zs = 1, Ys.exports = function(n, o) {
          for (var u, l = n.length, d = o ^ l, v = 0; l >= 4; )
            u = 1540483477 * (65535 & (u = 255 & n.charCodeAt(v) | (255 & n.charCodeAt(++v)) << 8 | (255 & n.charCodeAt(++v)) << 16 | (255 & n.charCodeAt(++v)) << 24)) + ((1540483477 * (u >>> 16) & 65535) << 16), d = 1540483477 * (65535 & d) + ((1540483477 * (d >>> 16) & 65535) << 16) ^ (u = 1540483477 * (65535 & (u ^= u >>> 24)) + ((1540483477 * (u >>> 16) & 65535) << 16)), l -= 4, ++v;
          switch (l) {
            case 3:
              d ^= (255 & n.charCodeAt(v + 2)) << 16;
            case 2:
              d ^= (255 & n.charCodeAt(v + 1)) << 8;
            case 1:
              d = 1540483477 * (65535 & (d ^= 255 & n.charCodeAt(v))) + ((1540483477 * (d >>> 16) & 65535) << 16);
          }
          return d = 1540483477 * (65535 & (d ^= d >>> 13)) + ((1540483477 * (d >>> 16) & 65535) << 16), (d ^= d >>> 15) >>> 0;
        }), Ys.exports);
        return Ar.exports = r, Ar.exports.murmur3 = r, Ar.exports.murmur2 = e, Ar.exports;
      }(), $r = O(Yn);
      class Pr {
        constructor(e, ...n) {
          Pn(this, n[0] || {}), this.type = e;
        }
      }
      class Cr extends Pr {
        constructor(e, n = {}) {
          super("error", Pn({ error: e }, n));
        }
      }
      function za(r, e, n) {
        n[r] && n[r].indexOf(e) !== -1 || (n[r] = n[r] || [], n[r].push(e));
      }
      function aa(r, e, n) {
        if (n && n[r]) {
          const o = n[r].indexOf(e);
          o !== -1 && n[r].splice(o, 1);
        }
      }
      class Go {
        on(e, n) {
          return this._listeners = this._listeners || {}, za(e, n, this._listeners), this;
        }
        off(e, n) {
          return aa(e, n, this._listeners), aa(e, n, this._oneTimeListeners), this;
        }
        once(e, n) {
          return n ? (this._oneTimeListeners = this._oneTimeListeners || {}, za(e, n, this._oneTimeListeners), this) : new Promise((o) => this.once(e, o));
        }
        fire(e, n) {
          const o = typeof e == "string" ? new Pr(e, n) : e, u = o.type;
          if (this.listens(u)) {
            o.target = this;
            const l = this._listeners && this._listeners[u] ? this._listeners[u].slice() : [];
            for (const M of l)
              M.call(this, o);
            const d = this._oneTimeListeners && this._oneTimeListeners[u] ? this._oneTimeListeners[u].slice() : [];
            for (const M of d)
              aa(u, M, this._oneTimeListeners), M.call(this, o);
            const v = this._eventedParent;
            v && (Pn(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), v.fire(o));
          } else
            o instanceof Cr && console.error(o.error);
          return this;
        }
        listens(e) {
          return !!(this._listeners && this._listeners[e] && this._listeners[e].length > 0 || this._oneTimeListeners && this._oneTimeListeners[e] && this._oneTimeListeners[e].length > 0 || this._eventedParent && this._eventedParent.listens(e));
        }
        setEventedParent(e, n) {
          return this._eventedParent = e, this._eventedParentData = n, this;
        }
      }
      var sr, la = {}, Da = function() {
        if (sr)
          return la;
        sr = 1;
        var r = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function e(l) {
          return (l = Math.round(l)) < 0 ? 0 : l > 255 ? 255 : l;
        }
        function n(l) {
          return e(l[l.length - 1] === "%" ? parseFloat(l) / 100 * 255 : parseInt(l));
        }
        function o(l) {
          return (d = l[l.length - 1] === "%" ? parseFloat(l) / 100 : parseFloat(l)) < 0 ? 0 : d > 1 ? 1 : d;
          var d;
        }
        function u(l, d, v) {
          return v < 0 ? v += 1 : v > 1 && (v -= 1), 6 * v < 1 ? l + (d - l) * v * 6 : 2 * v < 1 ? d : 3 * v < 2 ? l + (d - l) * (2 / 3 - v) * 6 : l;
        }
        try {
          la.parseCSSColor = function(l) {
            var d, v = l.replace(/ /g, "").toLowerCase();
            if (v in r)
              return r[v].slice();
            if (v[0] === "#")
              return v.length === 4 ? (d = parseInt(v.substr(1), 16)) >= 0 && d <= 4095 ? [(3840 & d) >> 4 | (3840 & d) >> 8, 240 & d | (240 & d) >> 4, 15 & d | (15 & d) << 4, 1] : null : v.length === 7 && (d = parseInt(v.substr(1), 16)) >= 0 && d <= 16777215 ? [(16711680 & d) >> 16, (65280 & d) >> 8, 255 & d, 1] : null;
            var M = v.indexOf("("), D = v.indexOf(")");
            if (M !== -1 && D + 1 === v.length) {
              var x = v.substr(0, M), E = v.substr(M + 1, D - (M + 1)).split(","), I = 1;
              switch (x) {
                case "rgba":
                  if (E.length !== 4)
                    return null;
                  I = o(E.pop());
                case "rgb":
                  return E.length !== 3 ? null : [n(E[0]), n(E[1]), n(E[2]), I];
                case "hsla":
                  if (E.length !== 4)
                    return null;
                  I = o(E.pop());
                case "hsl":
                  if (E.length !== 3)
                    return null;
                  var S = (parseFloat(E[0]) % 360 + 360) % 360 / 360, C = o(E[1]), k = o(E[2]), V = k <= 0.5 ? k * (C + 1) : k + C - k * C, U = 2 * k - V;
                  return [e(255 * u(U, V, S + 1 / 3)), e(255 * u(U, V, S)), e(255 * u(U, V, S - 1 / 3)), I];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch {
        }
        return la;
      }();
      class ki {
        constructor(e, n, o, u = 1) {
          this.r = e, this.g = n, this.b = o, this.a = u;
        }
        static parse(e) {
          if (!e)
            return;
          if (e instanceof ki)
            return e;
          if (typeof e != "string")
            return;
          const n = Da.parseCSSColor(e);
          return n ? new ki(n[0] / 255 * n[3], n[1] / 255 * n[3], n[2] / 255 * n[3], n[3]) : void 0;
        }
        toStringPremultipliedAlpha() {
          const [e, n, o, u] = this.a === 0 ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
          return `rgba(${Math.round(e)},${Math.round(n)},${Math.round(o)},${u})`;
        }
        toString() {
          const [e, n, o, u] = [this.r, this.g, this.b, this.a];
          return `rgba(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(255 * o)},${u})`;
        }
        toRenderColor(e) {
          const { r: n, g: o, b: u, a: l } = this;
          return new Ul(e, n, o, u, l);
        }
        clone() {
          return new ki(this.r, this.g, this.b, this.a);
        }
      }
      class Ul {
        constructor(e, n, o, u, l) {
          if (e) {
            const d = e.image.height, v = d * d;
            n = l === 0 ? 0 : n / l * (d - 1), o = l === 0 ? 0 : o / l * (d - 1), u = l === 0 ? 0 : u / l * (d - 1);
            const M = Math.floor(n), D = Math.floor(o), x = Math.floor(u), E = Math.ceil(n), I = Math.ceil(o), S = Math.ceil(u), C = n - M, k = o - D, V = u - x, U = e.image.data, q = 4 * (M + D * v + x * d), $ = 4 * (M + D * v + S * d), H = 4 * (M + I * v + x * d), K = 4 * (M + I * v + S * d), Q = 4 * (E + D * v + x * d), ie = 4 * (E + D * v + S * d), fe = 4 * (E + I * v + x * d), de = 4 * (E + I * v + S * d);
            if (q < 0 || de >= U.length)
              throw new Error("out of range");
            this.r = ei(ei(ei(U[q], U[$], V), ei(U[H], U[K], V), k), ei(ei(U[Q], U[ie], V), ei(U[fe], U[de], V), k), C) / 255 * l, this.g = ei(ei(ei(U[q + 1], U[$ + 1], V), ei(U[H + 1], U[K + 1], V), k), ei(ei(U[Q + 1], U[ie + 1], V), ei(U[fe + 1], U[de + 1], V), k), C) / 255 * l, this.b = ei(ei(ei(U[q + 2], U[$ + 2], V), ei(U[H + 2], U[K + 2], V), k), ei(ei(U[Q + 2], U[ie + 2], V), ei(U[fe + 2], U[de + 2], V), k), C) / 255 * l, this.a = l;
          } else
            this.r = n, this.g = o, this.b = u, this.a = l;
        }
        toArray() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [255 * e / u, 255 * n / u, 255 * o / u, u];
        }
        toHslaArray() {
          if (this.a === 0)
            return [0, 0, 0, 0];
          const { r: e, g: n, b: o, a: u } = this, l = Math.min(Math.max(e / u, 0), 1), d = Math.min(Math.max(n / u, 0), 1), v = Math.min(Math.max(o / u, 0), 1), M = Math.min(l, d, v), D = Math.max(l, d, v), x = (M + D) / 2;
          if (M === D)
            return [0, 0, 100 * x, u];
          const E = D - M, I = x > 0.5 ? E / (2 - D - M) : E / (D + M);
          let S = 0;
          return D === l ? S = (d - v) / E + (d < v ? 6 : 0) : D === d ? S = (v - l) / E + 2 : D === v && (S = (l - d) / E + 4), S *= 60, [Math.min(Math.max(S, 0), 360), Math.min(Math.max(100 * I, 0), 100), Math.min(Math.max(100 * x, 0), 100), u];
        }
        toArray01() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [e / u, n / u, o / u, u];
        }
        toArray01Scaled(e) {
          const { r: n, g: o, b: u, a: l } = this;
          return l === 0 ? [0, 0, 0] : [n / l * e, o / l * e, u / l * e];
        }
        toArray01PremultipliedAlpha() {
          const { r: e, g: n, b: o, a: u } = this;
          return [e, n, o, u];
        }
        toArray01Linear() {
          const { r: e, g: n, b: o, a: u } = this;
          return u === 0 ? [0, 0, 0, 0] : [Math.pow(e / u, 2.2), Math.pow(n / u, 2.2), Math.pow(o / u, 2.2), u];
        }
      }
      function ei(r, e, n) {
        return r * (1 - n) + e * n;
      }
      function cl(r, e, n) {
        return r.map((o, u) => ei(o, e[u], n));
      }
      ki.black = new ki(0, 0, 0, 1), ki.white = new ki(1, 1, 1, 1), ki.transparent = new ki(0, 0, 0, 0), ki.red = new ki(1, 0, 0, 1), ki.blue = new ki(0, 0, 1, 1);
      var Oi = Object.freeze({ __proto__: null, array: cl, color: function(r, e, n) {
        return new ki(ei(r.r, e.r, n), ei(r.g, e.g, n), ei(r.b, e.b, n), ei(r.a, e.a, n));
      }, number: ei });
      function Bi(r, ...e) {
        for (const n of e)
          for (const o in n)
            r[o] = n[o];
        return r;
      }
      class ns extends Error {
        constructor(e, n) {
          super(n), this.message = n, this.key = e;
        }
      }
      class Cn {
        constructor(e, n = []) {
          this.parent = e, this.bindings = {};
          for (const [o, u] of n)
            this.bindings[o] = u;
        }
        concat(e) {
          return new Cn(this, e);
        }
        get(e) {
          if (this.bindings[e])
            return this.bindings[e];
          if (this.parent)
            return this.parent.get(e);
          throw new Error(`${e} not found in scope.`);
        }
        has(e) {
          return !!this.bindings[e] || !!this.parent && this.parent.has(e);
        }
      }
      const ca = { kind: "null" }, Ot = { kind: "number" }, Fi = { kind: "string" }, Li = { kind: "boolean" }, ms = { kind: "color" }, vo = { kind: "object" }, Ai = { kind: "value" }, _s = { kind: "collator" }, Ks = { kind: "formatted" }, Zo = { kind: "resolvedImage" };
      function Ms(r, e) {
        return { kind: "array", itemType: r, N: e };
      }
      function un(r) {
        if (r.kind === "array") {
          const e = un(r.itemType);
          return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
        }
        return r.kind;
      }
      const Rc = [ca, Ot, Fi, Li, ms, Ks, vo, Ms(Ai), Zo];
      function ha(r, e) {
        if (e.kind === "error")
          return null;
        if (r.kind === "array") {
          if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !ha(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
            return null;
        } else {
          if (r.kind === e.kind)
            return null;
          if (r.kind === "value") {
            for (const n of Rc)
              if (!ha(n, e))
                return null;
          }
        }
        return `Expected ${un(r)} but found ${un(e)} instead.`;
      }
      function jl(r, e) {
        return e.some((n) => n.kind === r.kind);
      }
      function ua(r, e) {
        return e.some((n) => n === "null" ? r === null : n === "array" ? Array.isArray(r) : n === "object" ? r && !Array.isArray(r) && typeof r == "object" : n === typeof r);
      }
      class nn {
        constructor(e, n, o) {
          this.sensitivity = e ? n ? "variant" : "case" : n ? "accent" : "base", this.locale = o, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(e, n) {
          return this.collator.compare(e, n);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class hl {
        constructor(e, n, o, u, l) {
          this.text = e.normalize ? e.normalize() : e, this.image = n, this.scale = o, this.fontStack = u, this.textColor = l;
        }
      }
      class Dn {
        constructor(e) {
          this.sections = e;
        }
        static fromString(e) {
          return new Dn([new hl(e, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.namePrimary);
        }
        static factory(e) {
          return e instanceof Dn ? e : Dn.fromString(e);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
        }
        serialize() {
          const e = ["format"];
          for (const n of this.sections) {
            if (n.image) {
              e.push(["image", n.image.namePrimary]);
              continue;
            }
            e.push(n.text);
            const o = {};
            n.fontStack && (o["text-font"] = ["literal", n.fontStack.split(",")]), n.scale && (o["font-scale"] = n.scale), n.textColor && (o["text-color"] = ["rgba"].concat(n.textColor.toRenderColor(null).toArray())), e.push(o);
          }
          return e;
        }
      }
      class rr {
        constructor(e, n) {
          if (this.id = e, this.options = n || { params: {} }, this.options.transform) {
            const { a: o, b: u, c: l, d, e: v, f: M } = this.options.transform;
            this.options.transform = new DOMMatrix([o, u, l, d, v, M]);
          } else
            this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
        }
        static deserializeId(e) {
          return JSON.parse(e).id;
        }
        static deserializeFromString(e) {
          const n = JSON.parse(e), { a: o, b: u, c: l, d, e: v, f: M } = n.options.transform;
          return new DOMMatrix([o, u, l, d, v, M]), new rr(n.id, n.options);
        }
        scaleSelf(e) {
          return this.options.transform = this.options.transform.scale(e), this;
        }
        serialize() {
          const e = { id: this.id };
          this.options && (e.options = this.options);
          const { a: n, b: o, c: u, d: l, e: d, f: v } = this.options.transform;
          return e.options.transform = { a: n, b: o, c: u, d: l, e: d, f: v }, JSON.stringify(e);
        }
      }
      class ss {
        constructor(e) {
          this.namePrimary = e.namePrimary, e.nameSecondary && (this.nameSecondary = e.nameSecondary), e.optionsPrimary && (this.optionsPrimary = e.optionsPrimary), e.optionsSecondary && (this.optionsSecondary = e.optionsSecondary), this.available = e.available;
        }
        toString() {
          return this.namePrimary && this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
        }
        getPrimary() {
          return new rr(this.namePrimary, { params: this.optionsPrimary && this.optionsPrimary.params || {} });
        }
        getSerializedPrimary() {
          return this.getPrimary().serialize();
        }
        getSecondary() {
          return this.nameSecondary ? new rr(this.nameSecondary, { params: this.optionsSecondary && this.optionsSecondary.params || {} }) : null;
        }
        static from(e) {
          return typeof e == "string" ? ss.build(e) : e;
        }
        static build(e, n, o, u) {
          return e ? new ss({ namePrimary: e, nameSecondary: n, optionsPrimary: o, optionsSecondary: u, available: !1 }) : null;
        }
      }
      function da(r, e, n, o) {
        return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? o === void 0 || typeof o == "number" && o >= 0 && o <= 1 ? null : `Invalid rgba value [${[r, e, n, o].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof o == "number" ? [r, e, n, o] : [r, e, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function bo(r) {
        if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof ki || r instanceof nn || r instanceof Dn || r instanceof ss)
          return !0;
        if (Array.isArray(r)) {
          for (const e of r)
            if (!bo(e))
              return !1;
          return !0;
        }
        if (typeof r == "object") {
          for (const e in r)
            if (!bo(r[e]))
              return !1;
          return !0;
        }
        return !1;
      }
      function vn(r) {
        if (r === null)
          return ca;
        if (typeof r == "string")
          return Fi;
        if (typeof r == "boolean")
          return Li;
        if (typeof r == "number")
          return Ot;
        if (r instanceof ki)
          return ms;
        if (r instanceof nn)
          return _s;
        if (r instanceof Dn)
          return Ks;
        if (r instanceof ss)
          return Zo;
        if (Array.isArray(r)) {
          const e = r.length;
          let n;
          for (const o of r) {
            const u = vn(o);
            if (n) {
              if (n === u)
                continue;
              n = Ai;
              break;
            }
            n = u;
          }
          return Ms(n || Ai, e);
        }
        return vo;
      }
      function Ir(r) {
        const e = typeof r;
        return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof ki ? r.toStringPremultipliedAlpha() : r instanceof Dn || r instanceof ss ? r.toString() : JSON.stringify(r);
      }
      class Lr {
        constructor(e, n) {
          this.type = e, this.value = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (!bo(e[1]))
            return n.error("invalid value");
          const o = e[1];
          let u = vn(o);
          const l = n.expectedType;
          return u.kind !== "array" || u.N !== 0 || !l || l.kind !== "array" || typeof l.N == "number" && l.N !== 0 || (u = l), new Lr(u, o);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return this.type.kind === "array" || this.type.kind === "object" ? ["literal", this.value] : this.value instanceof ki ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Dn ? this.value.serialize() : this.value;
        }
      }
      class qn {
        constructor(e) {
          this.name = "ExpressionEvaluationError", this.message = e;
        }
        toJSON() {
          return this.message;
        }
      }
      const fa = { string: Fi, number: Ot, boolean: Li, object: vo };
      class zr {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          let o, u = 1;
          const l = e[0];
          if (l === "array") {
            let v, M;
            if (e.length > 2) {
              const D = e[1];
              if (typeof D != "string" || !(D in fa) || D === "object")
                return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
              v = fa[D], u++;
            } else
              v = Ai;
            if (e.length > 3) {
              if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
                return n.error('The length argument to "array" must be a positive integer literal', 2);
              M = e[2], u++;
            }
            o = Ms(v, M);
          } else
            o = fa[l];
          const d = [];
          for (; u < e.length; u++) {
            const v = n.parse(e[u], u, Ai);
            if (!v)
              return null;
            d.push(v);
          }
          return new zr(o, d);
        }
        evaluate(e) {
          for (let n = 0; n < this.args.length; n++) {
            const o = this.args[n].evaluate(e);
            if (!ha(this.type, vn(o)))
              return o;
            if (n === this.args.length - 1)
              throw new qn(`The expression ${JSON.stringify(this.args[n].serialize())} evaluated to ${un(vn(o))} but was expected to be of type ${un(this.type)}.`);
          }
          return null;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = this.type, n = [e.kind];
          if (e.kind === "array") {
            const o = e.itemType;
            if (o.kind === "string" || o.kind === "number" || o.kind === "boolean") {
              n.push(o.kind);
              const u = e.N;
              (typeof u == "number" || this.args.length > 1) && n.push(u);
            }
          }
          return n.concat(this.args.map((o) => o.serialize()));
        }
      }
      class Es {
        constructor(e) {
          this.type = Ks, this.sections = e;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          const o = e[1];
          if (!Array.isArray(o) && typeof o == "object")
            return n.error("First argument must be an image or text section.");
          const u = [];
          let l = !1;
          for (let d = 1; d <= e.length - 1; ++d) {
            const v = e[d];
            if (l && typeof v == "object" && !Array.isArray(v)) {
              l = !1;
              let M = null;
              if (v["font-scale"] && (M = n.parseObjectValue(v["font-scale"], d, "font-scale", Ot), !M))
                return null;
              let D = null;
              if (v["text-font"] && (D = n.parseObjectValue(v["text-font"], d, "text-font", Ms(Fi)), !D))
                return null;
              let x = null;
              if (v["text-color"] && (x = n.parseObjectValue(v["text-color"], d, "text-color", ms), !x))
                return null;
              const E = u[u.length - 1];
              E.scale = M, E.font = D, E.textColor = x;
            } else {
              const M = n.parse(e[d], d, Ai);
              if (!M)
                return null;
              const D = M.type.kind;
              if (D !== "string" && D !== "value" && D !== "null" && D !== "resolvedImage")
                return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              l = !0, u.push({ content: M, scale: null, font: null, textColor: null });
            }
          }
          return new Es(u);
        }
        evaluate(e) {
          return new Dn(this.sections.map((n) => {
            const o = n.content.evaluate(e);
            return vn(o) === Zo ? new hl("", o, null, null, null) : new hl(Ir(o), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null);
          }));
        }
        eachChild(e) {
          for (const n of this.sections)
            e(n.content), n.scale && e(n.scale), n.font && e(n.font), n.textColor && e(n.textColor);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["format"];
          for (const n of this.sections) {
            e.push(n.content.serialize());
            const o = {};
            n.scale && (o["font-scale"] = n.scale.serialize()), n.font && (o["text-font"] = n.font.serialize()), n.textColor && (o["text-color"] = n.textColor.serialize()), e.push(o);
          }
          return e;
        }
      }
      class ka {
        constructor(e, n, o, u) {
          this._imageWarnHistory = {}, this.type = Zo, this.inputPrimary = e, this.inputSecondary = n, this.inputPrimaryParams = o, this.inputSecondaryParams = u;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected two or more arguments.");
          let o = 1;
          const u = [];
          function l() {
            if (o < e.length) {
              const v = n.parse(e[o], o++, Fi);
              return v ? (u.push({ image: v, options: void 0 }), !0) : (n.error(u.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
            }
            return !0;
          }
          function d() {
            if (o < e.length) {
              if ((v = e[o]) === null || typeof v != "object" || Array.isArray(v))
                return !0;
              const M = e[o].params, D = n.concat(o);
              if (!M)
                return o++, !0;
              if (typeof M != "object" || M.constructor !== Object)
                return D.error('Image options "params" should be an object'), !1;
              const x = {}, E = D.concat(void 0, "params");
              for (const I in M) {
                if (!I)
                  return E.error("Image parameter name should be non-empty"), !1;
                const S = E.concat(void 0, I).parse(M[I], void 0, ms, void 0, { typeAnnotation: "coerce" });
                if (!S)
                  return !1;
                x[I] = S;
              }
              return u[u.length - 1].options = x, o++, !0;
            }
            var v;
            return !0;
          }
          for (let v = 0; v < 2; v++)
            if (!l() || !d())
              return;
          return new ka(u[0].image, u[1] ? u[1].image : void 0, u[0].options, u[1] ? u[1].options : void 0);
        }
        evaluateParams(e, n) {
          const o = {};
          if (n) {
            for (const u in n)
              if (n[u])
                try {
                  const l = n[u].evaluate(e), d = `Ignoring image parameter "${u}" with semi-transparent color ${l.toString()}`;
                  if (l.a !== 1) {
                    this._imageWarnHistory[d] || (console.warn(d), this._imageWarnHistory[d] = !0);
                    continue;
                  }
                  o[u] = l;
                } catch {
                  continue;
                }
            if (Object.keys(o).length !== 0)
              return { params: o };
          }
        }
        evaluate(e) {
          const n = ss.build(this.inputPrimary.evaluate(e), this.inputSecondary ? this.inputSecondary.evaluate(e) : void 0, this.inputPrimaryParams ? this.evaluateParams(e, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(e, this.inputSecondaryParams) : void 0);
          return n && e.availableImages && (n.available = e.availableImages.indexOf(n.namePrimary) > -1, n.nameSecondary && n.available && e.availableImages && (n.available = e.availableImages.indexOf(n.nameSecondary) > -1)), n;
        }
        eachChild(e) {
          if (e(this.inputPrimary), this.inputPrimaryParams)
            for (const n in this.inputPrimaryParams)
              this.inputPrimaryParams[n] && e(this.inputPrimaryParams[n]);
          if (this.inputSecondary && (e(this.inputSecondary), this.inputSecondaryParams))
            for (const n in this.inputSecondaryParams)
              this.inputSecondaryParams[n] && e(this.inputSecondaryParams[n]);
        }
        outputDefined() {
          return !1;
        }
        serializeParams(e) {
          const n = {};
          if (e) {
            for (const o in e)
              e[o] && (n[o] = e[o].serialize());
            return { params: n };
          }
        }
        serialize() {
          const e = ["image", this.inputPrimary.serialize()];
          return this.inputPrimaryParams && e.push(this.serializeParams(this.inputPrimaryParams)), this.inputSecondary && (e.push(this.inputSecondary.serialize()), this.inputSecondaryParams && e.push(this.serializeParams(this.inputSecondaryParams))), e;
        }
      }
      function Ho(r) {
        return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
      }
      const qo = { "to-boolean": Li, "to-color": ms, "to-number": Ot, "to-string": Fi };
      class so {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expected at least one argument.");
          const o = e[0], u = [];
          let l = ca;
          if (o === "to-array") {
            if (!Array.isArray(e[1]))
              return null;
            const d = e[1].length;
            if (n.expectedType) {
              if (n.expectedType.kind !== "array")
                return n.error(`Expected ${n.expectedType.kind} but found array.`);
              l = Ms(n.expectedType.itemType, d);
            } else {
              if (!(d > 0 && bo(e[1][0])))
                return null;
              l = Ms(vn(e[1][0]), d);
            }
            for (let v = 0; v < d; v++) {
              const M = e[1][v];
              let D;
              if (Ho(M) === "array")
                D = n.parse(M, void 0, l.itemType);
              else {
                const x = Ho(M);
                if (x !== l.itemType.kind)
                  return n.error(`Expected ${l.itemType.kind} but found ${x}.`);
                D = n.registry.literal.parse(["literal", M === void 0 ? null : M], n);
              }
              if (!D)
                return null;
              u.push(D);
            }
          } else {
            if ((o === "to-boolean" || o === "to-string") && e.length !== 2)
              return n.error("Expected one argument.");
            l = qo[o];
            for (let d = 1; d < e.length; d++) {
              const v = n.parse(e[d], d, Ai);
              if (!v)
                return null;
              u.push(v);
            }
          }
          return new so(l, u);
        }
        evaluate(e) {
          if (this.type.kind === "boolean")
            return !!this.args[0].evaluate(e);
          if (this.type.kind === "color") {
            let n, o;
            for (const u of this.args) {
              if (n = u.evaluate(e), o = null, n instanceof ki)
                return n;
              if (typeof n == "string") {
                const l = e.parseColor(n);
                if (l)
                  return l;
              } else if (Array.isArray(n) && (o = n.length < 3 || n.length > 4 ? `Invalid rbga value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : da(n[0], n[1], n[2], n[3]), !o))
                return new ki(n[0] / 255, n[1] / 255, n[2] / 255, n[3]);
            }
            throw new qn(o || `Could not parse color from value '${typeof n == "string" ? n : String(JSON.stringify(n))}'`);
          }
          if (this.type.kind === "number") {
            let n = null;
            for (const o of this.args) {
              if (n = o.evaluate(e), n === null)
                return 0;
              const u = Number(n);
              if (!isNaN(u))
                return u;
            }
            throw new qn(`Could not convert ${JSON.stringify(n)} to number.`);
          }
          return this.type.kind === "formatted" ? Dn.fromString(Ir(this.args[0].evaluate(e))) : this.type.kind === "resolvedImage" ? ss.build(Ir(this.args[0].evaluate(e))) : this.type.kind === "array" ? this.args.map((n) => n.evaluate(e)) : Ir(this.args[0].evaluate(e));
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          if (this.type.kind === "formatted")
            return new Es([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === "resolvedImage")
            return new ka(this.args[0]).serialize();
          const e = this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      const Oc = ["Unknown", "Point", "LineString", "Polygon"];
      class Ra {
        constructor(e, n) {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = e, this.options = n;
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Oc[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        measureLight(e) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const e = this.featureDistanceData.center, n = this.featureDistanceData.scale, { x: o, y: u } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (o * n - e[0]) + this.featureDistanceData.bearing[1] * (u * n - e[1]);
          }
          return 0;
        }
        parseColor(e) {
          let n = this._parseColorCache[e];
          return n || (n = this._parseColorCache[e] = ki.parse(e)), n;
        }
        getConfig(e) {
          return this.options ? this.options.get(e) : null;
        }
      }
      class or {
        constructor(e, n, o, u, l) {
          this.name = e, this.type = n, this._evaluate = o, this.args = u, this._overloadIndex = l;
        }
        evaluate(e) {
          if (!this._evaluate) {
            const n = or.definitions[this.name];
            this._evaluate = Array.isArray(n) ? n[2] : n.overloads[this._overloadIndex][1];
          }
          return this._evaluate(e, this.args);
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return [this.name].concat(this.args.map((e) => e.serialize()));
        }
        static parse(e, n) {
          const o = e[0], u = or.definitions[o];
          if (!u)
            return n.error(`Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const l = Array.isArray(u) ? u[0] : u.type, d = Array.isArray(u) ? [[u[1], u[2]]] : u.overloads, v = [];
          let M = null, D = -1;
          for (const [x, E] of d) {
            if (Array.isArray(x) && x.length !== e.length - 1)
              continue;
            v.push(x), D++, M = new Qr(n.registry, n.path, null, n.scope, void 0, n._scope, n.options);
            const I = [];
            let S = !1;
            for (let C = 1; C < e.length; C++) {
              const k = e[C], V = Array.isArray(x) ? x[C - 1] : x.type, U = M.parse(k, 1 + I.length, V);
              if (!U) {
                S = !0;
                break;
              }
              I.push(U);
            }
            if (!S)
              if (Array.isArray(x) && x.length !== I.length)
                M.error(`Expected ${x.length} arguments, but found ${I.length} instead.`);
              else {
                for (let C = 0; C < I.length; C++) {
                  const k = Array.isArray(x) ? x[C] : x.type, V = I[C];
                  M.concat(C + 1).checkSubtype(k, V.type);
                }
                if (M.errors.length === 0)
                  return new or(o, l, E, I, D);
              }
          }
          if (v.length === 1)
            n.errors.push(...M.errors);
          else {
            const x = (v.length ? v : d.map(([I]) => I)).map(ul).join(" | "), E = [];
            for (let I = 1; I < e.length; I++) {
              const S = n.parse(e[I], 1 + E.length);
              if (!S)
                return null;
              E.push(un(S.type));
            }
            n.error(`Expected arguments of type ${x}, but found (${E.join(", ")}) instead.`);
          }
          return null;
        }
        static register(e, n) {
          or.definitions = n;
          for (const o in n)
            e[o] = or;
        }
      }
      function ul(r) {
        return Array.isArray(r) ? `(${r.map(un).join(", ")})` : `(${un(r.type)}...)`;
      }
      class dl {
        constructor(e, n, o) {
          this.type = _s, this.locale = o, this.caseSensitive = e, this.diacriticSensitive = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error("Expected one argument.");
          const o = e[1];
          if (typeof o != "object" || Array.isArray(o))
            return n.error("Collator options argument must be an object.");
          const u = o["case-sensitive"] === void 0 ? n.parse(!1, 1, Li) : n.parseObjectValue(o["case-sensitive"], 1, "case-sensitive", Li);
          if (!u)
            return null;
          const l = o["diacritic-sensitive"] === void 0 ? n.parse(!1, 1, Li) : n.parseObjectValue(o["diacritic-sensitive"], 1, "diacritic-sensitive", Li);
          if (!l)
            return null;
          let d = null;
          return o.locale && (d = n.parseObjectValue(o.locale, 1, "locale", Fi), !d) ? null : new dl(u, l, d);
        }
        evaluate(e) {
          return new nn(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
        }
        eachChild(e) {
          e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return e["case-sensitive"] = this.caseSensitive.serialize(), e["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (e.locale = this.locale.serialize()), ["collator", e];
        }
      }
      function Fh(r, e, n = 0, o = r.length - 1, u = Fc) {
        for (; o > n; ) {
          if (o - n > 600) {
            const M = o - n + 1, D = e - n + 1, x = Math.log(M), E = 0.5 * Math.exp(2 * x / 3), I = 0.5 * Math.sqrt(x * E * (M - E) / M) * (D - M / 2 < 0 ? -1 : 1);
            Fh(r, e, Math.max(n, Math.floor(e - D * E / M + I)), Math.min(o, Math.floor(e + (M - D) * E / M + I)), u);
          }
          const l = r[e];
          let d = n, v = o;
          for (fl(r, n, e), u(r[o], l) > 0 && fl(r, n, o); d < v; ) {
            for (fl(r, d, v), d++, v--; u(r[d], l) < 0; )
              d++;
            for (; u(r[v], l) > 0; )
              v--;
          }
          u(r[n], l) === 0 ? fl(r, n, v) : (v++, fl(r, v, o)), v <= e && (n = v + 1), e <= v && (o = v - 1);
        }
      }
      function fl(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      function Fc(r, e) {
        return r < e ? -1 : r > e ? 1 : 0;
      }
      function Yu(r) {
        let e = 0;
        for (let n, o, u = 0, l = r.length, d = l - 1; u < l; d = u++)
          n = r[u], o = r[d], e += (o.x - n.x) * (n.y + o.y);
        return e;
      }
      function Oa(r, e) {
        r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
      }
      function Fa(r, e) {
        return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
      }
      function pl(r, e, n) {
        const o = r[0] - e[0], u = r[1] - e[1], l = r[0] - n[0], d = r[1] - n[1];
        return o * d - l * u == 0 && o * l <= 0 && u * d <= 0;
      }
      function Ds(r, e, n = !1) {
        let o = !1;
        for (let v = 0, M = e.length; v < M; v++) {
          const D = e[v];
          for (let x = 0, E = D.length, I = E - 1; x < E; I = x++) {
            const S = D[I], C = D[x];
            if (pl(r, S, C))
              return n;
            (l = S)[1] > (u = r)[1] != (d = C)[1] > u[1] && u[0] < (d[0] - l[0]) * (u[1] - l[1]) / (d[1] - l[1]) + l[0] && (o = !o);
          }
        }
        var u, l, d;
        return o;
      }
      function Bh(r, e, n, o) {
        const u = o[0] - n[0], l = o[1] - n[1], d = (r[0] - n[0]) * l - u * (r[1] - n[1]), v = (e[0] - n[0]) * l - u * (e[1] - n[1]);
        return d > 0 && v < 0 || d < 0 && v > 0;
      }
      function Wo(r, e, n, o) {
        return (u = [o[0] - n[0], o[1] - n[1]])[0] * (l = [e[0] - r[0], e[1] - r[1]])[1] - u[1] * l[0] != 0 && !(!Bh(r, e, n, o) || !Bh(n, o, r, e));
        var u, l;
      }
      const rs = 8192;
      function Nh(r, e) {
        const n = (180 + r[0]) / 360, o = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360, u = Math.pow(2, e.z);
        return [Math.round(n * u * rs), Math.round(o * u * rs)];
      }
      function Vh(r, e) {
        for (let n = 0; n < e.length; n++)
          if (Ds(r, e[n]))
            return !0;
        return !1;
      }
      function Ku(r, e, n) {
        for (const o of n)
          for (let u = 0, l = o.length, d = l - 1; u < l; d = u++)
            if (Wo(r, e, o[d], o[u]))
              return !0;
        return !1;
      }
      function Gl(r, e) {
        for (let n = 0; n < r.length; ++n)
          if (!Ds(r[n], e))
            return !1;
        for (let n = 0; n < r.length - 1; ++n)
          if (Ku(r[n], r[n + 1], e))
            return !1;
        return !0;
      }
      function $o(r, e) {
        for (let n = 0; n < e.length; n++)
          if (Gl(r, e[n]))
            return !0;
        return !1;
      }
      function bi(r, e, n) {
        const o = [];
        for (let u = 0; u < r.length; u++) {
          const l = [];
          for (let d = 0; d < r[u].length; d++) {
            const v = Nh(r[u][d], n);
            Oa(e, v), l.push(v);
          }
          o.push(l);
        }
        return o;
      }
      function Wt(r, e, n) {
        const o = [];
        for (let u = 0; u < r.length; u++) {
          const l = bi(r[u], e, n);
          o.push(l);
        }
        return o;
      }
      function ml(r, e, n, o) {
        if (r[0] < n[0] || r[0] > n[2]) {
          const u = 0.5 * o;
          let l = r[0] - n[0] > u ? -o : n[0] - r[0] > u ? o : 0;
          l === 0 && (l = r[0] - n[2] > u ? -o : n[2] - r[0] > u ? o : 0), r[0] += l;
        }
        Oa(e, r);
      }
      function ci(r, e, n, o) {
        const u = Math.pow(2, o.z) * rs, l = [o.x * rs, o.y * rs], d = [];
        if (!r)
          return d;
        for (const v of r)
          for (const M of v) {
            const D = [M.x + l[0], M.y + l[1]];
            ml(D, e, n, u), d.push(D);
          }
        return d;
      }
      function ar(r, e, n, o) {
        const u = Math.pow(2, o.z) * rs, l = [o.x * rs, o.y * rs], d = [];
        if (!r)
          return d;
        for (const M of r) {
          const D = [];
          for (const x of M) {
            const E = [x.x + l[0], x.y + l[1]];
            Oa(e, E), D.push(E);
          }
          d.push(D);
        }
        if (e[2] - e[0] <= u / 2) {
          (v = e)[0] = v[1] = 1 / 0, v[2] = v[3] = -1 / 0;
          for (const M of d)
            for (const D of M)
              ml(D, e, n, u);
        }
        var v;
        return d;
      }
      class lr {
        constructor(e, n) {
          this.type = Li, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
          if (bo(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection")
              for (let u = 0; u < o.features.length; ++u) {
                const l = o.features[u].geometry.type;
                if (l === "Polygon" || l === "MultiPolygon")
                  return new lr(o, o.features[u].geometry);
              }
            else if (o.type === "Feature") {
              const u = o.geometry.type;
              if (u === "Polygon" || u === "MultiPolygon")
                return new lr(o, o.geometry);
            } else if (o.type === "Polygon" || o.type === "MultiPolygon")
              return new lr(o, o);
          }
          return n.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(e) {
          if (e.geometry() != null && e.canonicalID() != null) {
            if (e.geometryType() === "Point")
              return function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = n.canonicalID();
                if (!d)
                  return !1;
                if (o.type === "Polygon") {
                  const v = bi(o.coordinates, l, d), M = ci(n.geometry(), u, l, d);
                  if (!Fa(u, l))
                    return !1;
                  for (const D of M)
                    if (!Ds(D, v))
                      return !1;
                }
                if (o.type === "MultiPolygon") {
                  const v = Wt(o.coordinates, l, d), M = ci(n.geometry(), u, l, d);
                  if (!Fa(u, l))
                    return !1;
                  for (const D of M)
                    if (!Vh(D, v))
                      return !1;
                }
                return !0;
              }(e, this.geometries);
            if (e.geometryType() === "LineString")
              return function(n, o) {
                const u = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], d = n.canonicalID();
                if (!d)
                  return !1;
                if (o.type === "Polygon") {
                  const v = bi(o.coordinates, l, d), M = ar(n.geometry(), u, l, d);
                  if (!Fa(u, l))
                    return !1;
                  for (const D of M)
                    if (!Gl(D, v))
                      return !1;
                }
                if (o.type === "MultiPolygon") {
                  const v = Wt(o.coordinates, l, d), M = ar(n.geometry(), u, l, d);
                  if (!Fa(u, l))
                    return !1;
                  for (const D of M)
                    if (!$o(D, v))
                      return !1;
                }
                return !0;
              }(e, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      const ti = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, Xr = 1 / 298.257223563, Zl = Xr * (2 - Xr), Yr = Math.PI / 180;
      class Ba {
        static fromTile(e, n, o) {
          const u = Math.PI * (1 - 2 * (e + 0.5) / Math.pow(2, n)), l = Math.atan(0.5 * (Math.exp(u) - Math.exp(-u))) / Yr;
          return new Ba(l, o);
        }
        static get units() {
          return ti;
        }
        constructor(e, n) {
          if (e === void 0)
            throw new Error("No latitude given.");
          if (n && !ti[n])
            throw new Error(`Unknown unit ${n}. Use one of: ${Object.keys(ti).join(", ")}`);
          const o = 6378.137 * Yr * (n ? ti[n] : 1), u = Math.cos(e * Yr), l = 1 / (1 - Zl * (1 - u * u)), d = Math.sqrt(l);
          this.kx = o * d * u, this.ky = o * d * l * (1 - Zl);
        }
        distance(e, n) {
          const o = ks(e[0] - n[0]) * this.kx, u = (e[1] - n[1]) * this.ky;
          return Math.sqrt(o * o + u * u);
        }
        bearing(e, n) {
          const o = ks(n[0] - e[0]) * this.kx;
          return Math.atan2(o, (n[1] - e[1]) * this.ky) / Yr;
        }
        destination(e, n, o) {
          const u = o * Yr;
          return this.offset(e, Math.sin(u) * n, Math.cos(u) * n);
        }
        offset(e, n, o) {
          return [e[0] + n / this.kx, e[1] + o / this.ky];
        }
        lineDistance(e) {
          let n = 0;
          for (let o = 0; o < e.length - 1; o++)
            n += this.distance(e[o], e[o + 1]);
          return n;
        }
        area(e) {
          let n = 0;
          for (let o = 0; o < e.length; o++) {
            const u = e[o];
            for (let l = 0, d = u.length, v = d - 1; l < d; v = l++)
              n += ks(u[l][0] - u[v][0]) * (u[l][1] + u[v][1]) * (o ? -1 : 1);
          }
          return Math.abs(n) / 2 * this.kx * this.ky;
        }
        along(e, n) {
          let o = 0;
          if (n <= 0)
            return e[0];
          for (let u = 0; u < e.length - 1; u++) {
            const l = e[u], d = e[u + 1], v = this.distance(l, d);
            if (o += v, o > n)
              return bs(l, d, (n - (o - v)) / v);
          }
          return e[e.length - 1];
        }
        pointToSegmentDistance(e, n, o) {
          let [u, l] = n, d = ks(o[0] - u) * this.kx, v = (o[1] - l) * this.ky;
          if (d !== 0 || v !== 0) {
            const M = (ks(e[0] - u) * this.kx * d + (e[1] - l) * this.ky * v) / (d * d + v * v);
            M > 1 ? (u = o[0], l = o[1]) : M > 0 && (u += d / this.kx * M, l += v / this.ky * M);
          }
          return d = ks(e[0] - u) * this.kx, v = (e[1] - l) * this.ky, Math.sqrt(d * d + v * v);
        }
        pointOnLine(e, n) {
          let o = 1 / 0, u = e[0][0], l = e[0][1], d = 0, v = 0;
          for (let M = 0; M < e.length - 1; M++) {
            let D = e[M][0], x = e[M][1], E = ks(e[M + 1][0] - D) * this.kx, I = (e[M + 1][1] - x) * this.ky, S = 0;
            E === 0 && I === 0 || (S = (ks(n[0] - D) * this.kx * E + (n[1] - x) * this.ky * I) / (E * E + I * I), S > 1 ? (D = e[M + 1][0], x = e[M + 1][1]) : S > 0 && (D += E / this.kx * S, x += I / this.ky * S)), E = ks(n[0] - D) * this.kx, I = (n[1] - x) * this.ky;
            const C = E * E + I * I;
            C < o && (o = C, u = D, l = x, d = M, v = S);
          }
          return { point: [u, l], index: d, t: Math.max(0, Math.min(1, v)) };
        }
        lineSlice(e, n, o) {
          let u = this.pointOnLine(o, e), l = this.pointOnLine(o, n);
          if (u.index > l.index || u.index === l.index && u.t > l.t) {
            const D = u;
            u = l, l = D;
          }
          const d = [u.point], v = u.index + 1, M = l.index;
          !wo(o[v], d[0]) && v <= M && d.push(o[v]);
          for (let D = v + 1; D <= M; D++)
            d.push(o[D]);
          return wo(o[M], l.point) || d.push(l.point), d;
        }
        lineSliceAlong(e, n, o) {
          let u = 0;
          const l = [];
          for (let d = 0; d < o.length - 1; d++) {
            const v = o[d], M = o[d + 1], D = this.distance(v, M);
            if (u += D, u > e && l.length === 0 && l.push(bs(v, M, (e - (u - D)) / D)), u >= n)
              return l.push(bs(v, M, (n - (u - D)) / D)), l;
            u > e && l.push(M);
          }
          return l;
        }
        bufferPoint(e, n) {
          const o = n / this.ky, u = n / this.kx;
          return [e[0] - u, e[1] - o, e[0] + u, e[1] + o];
        }
        bufferBBox(e, n) {
          const o = n / this.ky, u = n / this.kx;
          return [e[0] - u, e[1] - o, e[2] + u, e[3] + o];
        }
        insideBBox(e, n) {
          return ks(e[0] - n[0]) >= 0 && ks(e[0] - n[2]) <= 0 && e[1] >= n[1] && e[1] <= n[3];
        }
      }
      function wo(r, e) {
        return r[0] === e[0] && r[1] === e[1];
      }
      function bs(r, e, n) {
        const o = ks(e[0] - r[0]);
        return [r[0] + o * n, r[1] + (e[1] - r[1]) * n];
      }
      function ks(r) {
        for (; r < -180; )
          r += 360;
        for (; r > 180; )
          r -= 360;
        return r;
      }
      class Hl {
        constructor(e = [], n = (o, u) => o < u ? -1 : o > u ? 1 : 0) {
          if (this.data = e, this.length = this.data.length, this.compare = n, this.length > 0)
            for (let o = (this.length >> 1) - 1; o >= 0; o--)
              this._down(o);
        }
        push(e) {
          this.data.push(e), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const e = this.data[0], n = this.data.pop();
          return --this.length > 0 && (this.data[0] = n, this._down(0)), e;
        }
        peek() {
          return this.data[0];
        }
        _up(e) {
          const { data: n, compare: o } = this, u = n[e];
          for (; e > 0; ) {
            const l = e - 1 >> 1, d = n[l];
            if (o(u, d) >= 0)
              break;
            n[e] = d, e = l;
          }
          n[e] = u;
        }
        _down(e) {
          const { data: n, compare: o } = this, u = this.length >> 1, l = n[e];
          for (; e < u; ) {
            let d = 1 + (e << 1);
            const v = d + 1;
            if (v < this.length && o(n[v], n[d]) < 0 && (d = v), o(n[d], l) >= 0)
              break;
            n[e] = n[d], e = d;
          }
          n[e] = l;
        }
      }
      var wt = 8192;
      function pa(r, e) {
        return e.dist - r.dist;
      }
      const To = 100, gs = 50;
      function Uh(r) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (e.length !== r.length)
          return !1;
        for (let n = 0; n < e.length; n++)
          if (e[n] !== r[n])
            return !1;
        return !0;
      }
      function Dr(r) {
        return r[1] - r[0] + 1;
      }
      function So(r, e) {
        const n = r[1] >= r[0] && r[1] < e;
        return n || console.warn("Distance Expression: Index is out of range"), n;
      }
      function Kr(r, e) {
        if (r[0] > r[1])
          return [null, null];
        const n = Dr(r);
        if (e) {
          if (n === 2)
            return [r, null];
          const o = Math.floor(n / 2);
          return [[r[0], r[0] + o], [r[0] + o, r[1]]];
        }
        {
          if (n === 1)
            return [r, null];
          const o = Math.floor(n / 2) - 1;
          return [[r[0], r[0] + o], [r[0] + o + 1, r[1]]];
        }
      }
      function Xo(r, e) {
        const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!So(e, r.length))
          return n;
        for (let o = e[0]; o <= e[1]; ++o)
          Oa(n, r[o]);
        return n;
      }
      function cr(r) {
        const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n = 0; n < r.length; ++n)
          for (let o = 0; o < r[n].length; ++o)
            Oa(e, r[n][o]);
        return e;
      }
      function Mo(r, e, n) {
        if (Uh(r) || Uh(e))
          return NaN;
        let o = 0, u = 0;
        return r[2] < e[0] && (o = e[0] - r[2]), r[0] > e[2] && (o = r[0] - e[2]), r[1] > e[3] && (u = r[1] - e[3]), r[3] < e[1] && (u = e[1] - r[3]), n.distance([0, 0], [o, u]);
      }
      function jh(r) {
        return 360 * r - 180;
      }
      function Bc(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      function Na(r, e) {
        const n = Math.pow(2, e.z), o = (r.y / wt + e.y) / n;
        return [jh((r.x / wt + e.x) / n), Bc(o)];
      }
      function ql(r, e) {
        const n = [];
        for (let o = 0; o < r.length; ++o)
          n.push(Na(r[o], e));
        return n;
      }
      function _l(r, e, n) {
        const o = n.pointOnLine(e, r).point;
        return n.distance(r, o);
      }
      function ma(r, e, n, o, u) {
        const l = n.slice(o[0], o[1] + 1);
        let d = 1 / 0;
        for (let v = e[0]; v <= e[1]; ++v)
          if ((d = Math.min(d, _l(r[v], l, u))) === 0)
            return 0;
        return d;
      }
      function _a(r, e, n, o, u) {
        const l = Math.min(u.pointToSegmentDistance(r, n, o), u.pointToSegmentDistance(e, n, o)), d = Math.min(u.pointToSegmentDistance(n, r, e), u.pointToSegmentDistance(o, r, e));
        return Math.min(l, d);
      }
      function Eo(r, e, n, o, u) {
        if (!So(e, r.length) || !So(o, n.length))
          return NaN;
        let l = 1 / 0;
        for (let d = e[0]; d < e[1]; ++d)
          for (let v = o[0]; v < o[1]; ++v) {
            if (Wo(r[d], r[d + 1], n[v], n[v + 1]))
              return 0;
            l = Math.min(l, _a(r[d], r[d + 1], n[v], n[v + 1], u));
          }
        return l;
      }
      function Gh(r, e, n, o, u) {
        if (!So(e, r.length) || !So(o, n.length))
          return NaN;
        let l = 1 / 0;
        for (let d = e[0]; d <= e[1]; ++d)
          for (let v = o[0]; v <= o[1]; ++v)
            if ((l = Math.min(l, u.distance(r[d], n[v]))) === 0)
              return l;
        return l;
      }
      function Ju(r, e, n) {
        if (Ds(r, e, !0))
          return 0;
        let o = 1 / 0;
        for (const u of e) {
          const l = u.length;
          if (l < 2)
            return console.warn("Distance Expression: Invalid polygon!"), NaN;
          if (u[0] !== u[l - 1] && (o = Math.min(o, n.pointToSegmentDistance(r, u[l - 1], u[0]))) === 0 || (o = Math.min(o, _l(r, u, n))) === 0)
            return o;
        }
        return o;
      }
      function Va(r, e, n, o) {
        if (!So(e, r.length))
          return NaN;
        for (let l = e[0]; l <= e[1]; ++l)
          if (Ds(r[l], n, !0))
            return 0;
        let u = 1 / 0;
        for (let l = e[0]; l < e[1]; ++l)
          for (const d of n)
            for (let v = 0, M = d.length, D = M - 1; v < M; D = v++) {
              if (Wo(r[l], r[l + 1], d[D], d[v]))
                return 0;
              u = Math.min(u, _a(r[l], r[l + 1], d[D], d[v], o));
            }
        return u;
      }
      function Nc(r, e) {
        for (const n of r)
          for (let o = 0; o <= n.length - 1; ++o)
            if (Ds(n[o], e, !0))
              return !0;
        return !1;
      }
      function Vc(r, e, n, o = 1 / 0) {
        const u = cr(r), l = cr(e);
        if (o !== 1 / 0 && Mo(u, l, n) >= o)
          return o;
        if (Fa(u, l)) {
          if (Nc(r, e))
            return 0;
        } else if (Nc(e, r))
          return 0;
        let d = o;
        for (const v of r)
          for (let M = 0, D = v.length, x = D - 1; M < D; x = M++)
            for (const E of e)
              for (let I = 0, S = E.length, C = S - 1; I < S; C = I++) {
                if (Wo(v[x], v[M], E[C], E[I]))
                  return 0;
                d = Math.min(d, _a(v[x], v[M], E[C], E[I], n));
              }
        return d;
      }
      function hr(r, e, n, o, u, l, d) {
        if (l === null || d === null)
          return;
        const v = Mo(Xo(o, l), Xo(u, d), n);
        v < e && r.push({ dist: v, range1: l, range2: d });
      }
      function Uc(r, e, n, o, u = 1 / 0) {
        let l = Math.min(o.distance(r[0], n[0][0]), u);
        if (l === 0)
          return l;
        const d = new Hl([{ dist: 0, range1: [0, r.length - 1], range2: [0, 0] }], pa), v = e ? gs : To, M = cr(n);
        for (; d.length; ) {
          const D = d.pop();
          if (D.dist >= l)
            continue;
          const x = D.range1;
          if (Dr(x) <= v) {
            if (!So(x, r.length))
              return NaN;
            if (e) {
              const E = Va(r, x, n, o);
              if ((l = Math.min(l, E)) === 0)
                return l;
            } else
              for (let E = x[0]; E <= x[1]; ++E) {
                const I = Ju(r[E], n, o);
                if ((l = Math.min(l, I)) === 0)
                  return l;
              }
          } else {
            const E = Kr(x, e);
            if (E[0] !== null) {
              const I = Mo(Xo(r, E[0]), M, o);
              I < l && d.push({ dist: I, range1: E[0], range2: [0, 0] });
            }
            if (E[1] !== null) {
              const I = Mo(Xo(r, E[1]), M, o);
              I < l && d.push({ dist: I, range1: E[1], range2: [0, 0] });
            }
          }
        }
        return l;
      }
      function jc(r, e, n, o, u, l = 1 / 0) {
        let d = Math.min(l, u.distance(r[0], n[0]));
        if (d === 0)
          return d;
        const v = new Hl([{ dist: 0, range1: [0, r.length - 1], range2: [0, n.length - 1] }], pa), M = e ? gs : To, D = o ? gs : To;
        for (; v.length; ) {
          const x = v.pop();
          if (x.dist >= d)
            continue;
          const E = x.range1, I = x.range2;
          if (Dr(E) <= M && Dr(I) <= D) {
            if (!So(E, r.length) || !So(I, n.length))
              return NaN;
            if (e && o ? d = Math.min(d, Eo(r, E, n, I, u)) : e || o ? e && !o ? d = Math.min(d, ma(n, I, r, E, u)) : !e && o && (d = Math.min(d, ma(r, E, n, I, u))) : d = Math.min(d, Gh(r, E, n, I, u)), d === 0)
              return d;
          } else {
            const S = Kr(E, e), C = Kr(I, o);
            hr(v, d, u, r, n, S[0], C[0]), hr(v, d, u, r, n, S[0], C[1]), hr(v, d, u, r, n, S[1], C[0]), hr(v, d, u, r, n, S[1], C[1]);
          }
        }
        return d;
      }
      function xr(r, e, n, o, u = 1 / 0) {
        let l = u;
        const d = Xo(r, [0, r.length - 1]);
        for (const v of n)
          if (!(l !== 1 / 0 && Mo(d, Xo(v, [0, v.length - 1]), o) >= l) && (l = Math.min(l, jc(r, e, v, !0, o, l)), l === 0))
            return l;
        return l;
      }
      function Yo(r, e, n, o, u = 1 / 0) {
        let l = u;
        const d = Xo(r, [0, r.length - 1]);
        for (const v of n) {
          if (l !== 1 / 0 && Mo(d, cr(v), o) >= l)
            continue;
          const M = Uc(r, e, v, o, l);
          if (isNaN(M))
            return M;
          if ((l = Math.min(l, M)) === 0)
            return l;
        }
        return l;
      }
      function Wl(r) {
        return r === "Point" || r === "MultiPoint" || r === "LineString" || r === "MultiLineString" || r === "Polygon" || r === "MultiPolygon";
      }
      class Jr {
        constructor(e, n) {
          this.type = Ot, this.geojson = e, this.geometries = n;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`);
          if (bo(e[1])) {
            const o = e[1];
            if (o.type === "FeatureCollection") {
              for (let u = 0; u < o.features.length; ++u)
                if (Wl(o.features[u].geometry.type))
                  return new Jr(o, o.features[u].geometry);
            } else if (o.type === "Feature") {
              if (Wl(o.geometry.type))
                return new Jr(o, o.geometry);
            } else if (Wl(o.type))
              return new Jr(o, o);
          }
          return n.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(e) {
          const n = e.geometry(), o = e.canonicalID();
          if (n != null && o != null) {
            if (e.geometryType() === "Point")
              return function(u, l, d) {
                const v = [];
                for (const D of u)
                  for (const x of D)
                    v.push(Na(x, l));
                const M = new Ba(v[0][1], "meters");
                return d.type === "Point" || d.type === "MultiPoint" || d.type === "LineString" ? jc(v, !1, d.type === "Point" ? [d.coordinates] : d.coordinates, d.type === "LineString", M) : d.type === "MultiLineString" ? xr(v, !1, d.coordinates, M) : d.type === "Polygon" || d.type === "MultiPolygon" ? Yo(v, !1, d.type === "Polygon" ? [d.coordinates] : d.coordinates, M) : null;
              }(n, o, this.geometries);
            if (e.geometryType() === "LineString")
              return function(u, l, d) {
                const v = [];
                for (const D of u) {
                  const x = [];
                  for (const E of D)
                    x.push(Na(E, l));
                  v.push(x);
                }
                const M = new Ba(v[0][0][1], "meters");
                if (d.type === "Point" || d.type === "MultiPoint" || d.type === "LineString")
                  return xr(d.type === "Point" ? [d.coordinates] : d.coordinates, d.type === "LineString", v, M);
                if (d.type === "MultiLineString") {
                  let D = 1 / 0;
                  for (let x = 0; x < d.coordinates.length; x++) {
                    const E = xr(d.coordinates[x], !0, v, M, D);
                    if (isNaN(E))
                      return E;
                    if ((D = Math.min(D, E)) === 0)
                      return D;
                  }
                  return D;
                }
                if (d.type === "Polygon" || d.type === "MultiPolygon") {
                  let D = 1 / 0;
                  for (let x = 0; x < v.length; x++) {
                    const E = Yo(v[x], !0, d.type === "Polygon" ? [d.coordinates] : d.coordinates, M, D);
                    if (isNaN(E))
                      return E;
                    if ((D = Math.min(D, E)) === 0)
                      return D;
                  }
                  return D;
                }
                return null;
              }(n, o, this.geometries);
            if (e.geometryType() === "Polygon")
              return function(u, l, d) {
                const v = [];
                for (const D of function(x, E) {
                  const I = x.length;
                  if (I <= 1)
                    return [x];
                  const S = [];
                  let C, k;
                  for (let V = 0; V < I; V++) {
                    const U = Yu(x[V]);
                    U !== 0 && (x[V].area = Math.abs(U), k === void 0 && (k = U < 0), k === U < 0 ? (C && S.push(C), C = [x[V]]) : C.push(x[V]));
                  }
                  return C && S.push(C), S;
                }(u)) {
                  const x = [];
                  for (let E = 0; E < D.length; ++E)
                    x.push(ql(D[E], l));
                  v.push(x);
                }
                const M = new Ba(v[0][0][0][1], "meters");
                if (d.type === "Point" || d.type === "MultiPoint" || d.type === "LineString")
                  return Yo(d.type === "Point" ? [d.coordinates] : d.coordinates, d.type === "LineString", v, M);
                if (d.type === "MultiLineString") {
                  let D = 1 / 0;
                  for (let x = 0; x < d.coordinates.length; x++) {
                    const E = Yo(d.coordinates[x], !0, v, M, D);
                    if (isNaN(E))
                      return E;
                    if ((D = Math.min(D, E)) === 0)
                      return D;
                  }
                  return D;
                }
                return d.type === "Polygon" || d.type === "MultiPolygon" ? function(D, x, E) {
                  let I = 1 / 0;
                  for (const S of D)
                    for (const C of x) {
                      const k = Vc(S, C, E, I);
                      if (isNaN(k))
                        return k;
                      if ((I = Math.min(I, k)) === 0)
                        return I;
                    }
                  return I;
                }(d.type === "Polygon" ? [d.coordinates] : d.coordinates, v, M) : null;
              }(n, o, this.geometries);
            console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
          } else
            console.warn("Distance Expression: requirs valid feature and canonical information.");
          return null;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["distance", this.geojson];
        }
      }
      function $l(r, e) {
        switch (r) {
          case "string":
            return Ir(e);
          case "number":
            return +e;
          case "boolean":
            return !!e;
          case "color":
            return ki.parse(e);
          case "formatted":
            return Dn.fromString(Ir(e));
          case "resolvedImage":
            return ss.build(Ir(e));
        }
        return e;
      }
      function Xl(r, e, n, o) {
        return o !== void 0 && (r = o * Math.round(r / o)), e !== void 0 && r < e && (r = e), n !== void 0 && r > n && (r = n), r;
      }
      class ga {
        constructor(e, n, o) {
          this.type = e, this.key = n, this.scope = o;
        }
        static parse(e, n) {
          let o = n.expectedType;
          if (o == null && (o = Ai), e.length < 2 || e.length > 3)
            return n.error("Invalid number of arguments for 'config' expression.");
          const u = n.parse(e[1], 1);
          if (!(u instanceof Lr))
            return n.error("Key name of 'config' expression must be a string literal.");
          if (e.length >= 3) {
            const l = n.parse(e[2], 2);
            return l instanceof Lr ? new ga(o, Ir(u.value), Ir(l.value)) : n.error("Scope of 'config' expression must be a string literal.");
          }
          return new ga(o, Ir(u.value));
        }
        evaluate(e) {
          const n = [this.key, this.scope, e.scope].filter(Boolean).join(""), o = e.getConfig(n);
          if (!o)
            return null;
          const { type: u, value: l, values: d, minValue: v, maxValue: M, stepValue: D } = o, x = o.default.evaluate(e);
          let E = x;
          if (l) {
            const I = e.scope;
            e.scope = (I || "").split("").slice(1).join(""), E = l.evaluate(e), e.scope = I;
          }
          return u && (E = $l(u, E)), E === void 0 || v === void 0 && M === void 0 && D === void 0 || (typeof E == "number" ? E = Xl(E, v, M, D) : Array.isArray(E) && (E = E.map((I) => typeof I == "number" ? Xl(I, v, M, D) : I))), l !== void 0 && E !== void 0 && d && !d.includes(E) && (E = x, u && (E = $l(u, E))), (u && u !== this.type || E !== void 0 && vn(E) !== this.type) && (E = $l(this.type.kind, E)), E;
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["config", this.key];
          return this.scope && e.concat(this.key), e;
        }
      }
      function ro(r) {
        if (r instanceof or && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof lr || r instanceof Jr)
          return !1;
        let e = !0;
        return r.eachChild((n) => {
          e && !ro(n) && (e = !1);
        }), e;
      }
      function gl(r) {
        if (r instanceof or && r.name === "feature-state")
          return !1;
        let e = !0;
        return r.eachChild((n) => {
          e && !gl(n) && (e = !1);
        }), e;
      }
      function kr(r) {
        if (r instanceof ga)
          return /* @__PURE__ */ new Set([r.key]);
        let e = /* @__PURE__ */ new Set();
        return r.eachChild((n) => {
          e = /* @__PURE__ */ new Set([...e, ...kr(n)]);
        }), e;
      }
      function oo(r, e) {
        if (r instanceof or && e.indexOf(r.name) >= 0)
          return !1;
        let n = !0;
        return r.eachChild((o) => {
          n && !oo(o, e) && (n = !1);
        }), n;
      }
      class Ko {
        constructor(e, n) {
          this.type = n.type, this.name = e, this.boundExpression = n;
        }
        static parse(e, n) {
          if (e.length !== 2 || typeof e[1] != "string")
            return n.error("'var' expression requires exactly one string literal argument.");
          const o = e[1];
          return n.scope.has(o) ? new Ko(o, n.scope.get(o)) : n.error(`Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(e) {
          return this.boundExpression.evaluate(e);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      class Yl {
        constructor(e, n = [], o, u = new Cn(), l = [], d, v) {
          this.registry = e, this.path = n, this.key = n.map((M) => typeof M == "string" ? `['${M}']` : `[${M}]`).join(""), this.scope = u, this.errors = l, this.expectedType = o, this._scope = d, this.options = v;
        }
        parse(e, n, o, u, l = {}) {
          return n || o ? this.concat(n, null, o, u)._parse(e, l) : this._parse(e, l);
        }
        parseObjectValue(e, n, o, u, l, d = {}) {
          return this.concat(n, o, u, l)._parse(e, d);
        }
        _parse(e, n) {
          function o(u, l, d) {
            return d === "assert" ? new zr(l, [u]) : d === "coerce" ? new so(l, [u]) : u;
          }
          if (e !== null && typeof e != "string" && typeof e != "boolean" && typeof e != "number" || (e = ["literal", e]), Array.isArray(e)) {
            if (e.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const u = typeof e[0] == "string" ? this.registry[e[0]] : void 0;
            if (u) {
              let l = u.parse(e, this);
              if (!l)
                return null;
              if (this.expectedType) {
                const d = this.expectedType, v = l.type;
                if (d.kind !== "string" && d.kind !== "number" && d.kind !== "boolean" && d.kind !== "object" && d.kind !== "array" || v.kind !== "value")
                  if (d.kind !== "color" && d.kind !== "formatted" && d.kind !== "resolvedImage" || v.kind !== "value" && v.kind !== "string") {
                    if (this.checkSubtype(d, v))
                      return null;
                  } else
                    l = o(l, d, n.typeAnnotation || "coerce");
                else
                  l = o(l, d, n.typeAnnotation || "assert");
              }
              if (!(l instanceof Lr) && l.type.kind !== "resolvedImage" && yl(l)) {
                const d = new Ra(this._scope, this.options);
                try {
                  l = new Lr(l.type, l.evaluate(d));
                } catch (v) {
                  return this.error(v.message), null;
                }
              }
              return l;
            }
            return so.parse(["to-array", e], this);
          }
          return this.error(e === void 0 ? "'undefined' value invalid. Use null instead." : typeof e == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof e} instead.`);
        }
        concat(e, n, o, u) {
          let l = typeof e == "number" ? this.path.concat(e) : this.path;
          l = typeof n == "string" ? l.concat(n) : l;
          const d = u ? this.scope.concat(u) : this.scope;
          return new Yl(this.registry, l, o || null, d, this.errors, this._scope, this.options);
        }
        error(e, ...n) {
          const o = `${this.key}${n.map((u) => `[${u}]`).join("")}`;
          this.errors.push(new ns(o, e));
        }
        checkSubtype(e, n) {
          const o = ha(e, n);
          return o && this.error(o), o;
        }
      }
      var Qr = Yl;
      function yl(r) {
        if (r instanceof Ko)
          return yl(r.boundExpression);
        if (r instanceof or && r.name === "error" || r instanceof dl || r instanceof lr || r instanceof Jr || r instanceof ga)
          return !1;
        const e = r instanceof so || r instanceof zr;
        let n = !0;
        return r.eachChild((o) => {
          n = e ? n && yl(o) : n && o instanceof Lr;
        }), !!n && ro(r) && oo(r, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
      }
      function ao(r, e) {
        const n = r.length - 1;
        let o, u, l = 0, d = n, v = 0;
        for (; l <= d; )
          if (v = Math.floor((l + d) / 2), o = r[v], u = r[v + 1], o <= e) {
            if (v === n || e < u)
              return v;
            l = v + 1;
          } else {
            if (!(o > e))
              throw new qn("Input is not a number.");
            d = v - 1;
          }
        return 0;
      }
      class Ti {
        constructor(e, n, o) {
          this.type = e, this.input = n, this.labels = [], this.outputs = [];
          for (const [u, l] of o)
            this.labels.push(u), this.outputs.push(l);
        }
        static parse(e, n) {
          if (e.length - 1 < 4)
            return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if ((e.length - 1) % 2 != 0)
            return n.error("Expected an even number of arguments.");
          const o = n.parse(e[1], 1, Ot);
          if (!o)
            return null;
          const u = [];
          let l = null;
          n.expectedType && n.expectedType.kind !== "value" && (l = n.expectedType);
          for (let d = 1; d < e.length; d += 2) {
            const v = d === 1 ? -1 / 0 : e[d], M = e[d + 1], D = d, x = d + 1;
            if (typeof v != "number")
              return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', D);
            if (u.length && u[u.length - 1][0] >= v)
              return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', D);
            const E = n.parse(M, x, l);
            if (!E)
              return null;
            l = l || E.type, u.push([v, E]);
          }
          return new Ti(l, o, u);
        }
        evaluate(e) {
          const n = this.labels, o = this.outputs;
          if (n.length === 1)
            return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0])
            return o[0].evaluate(e);
          const l = n.length;
          return u >= n[l - 1] ? o[l - 1].evaluate(e) : o[ao(n, u)].evaluate(e);
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs)
            e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["step", this.input.serialize()];
          for (let n = 0; n < this.labels.length; n++)
            n > 0 && e.push(this.labels[n]), e.push(this.outputs[n].serialize());
          return e;
        }
      }
      const Zh = 0.95047, xl = 1.08883, Ua = 4 / 29, Jo = 6 / 29, Gc = 3 * Jo * Jo, gn = Jo * Jo * Jo, Hh = Math.PI / 180, qh = 180 / Math.PI;
      function Kl(r) {
        return r > gn ? Math.pow(r, 1 / 3) : r / Gc + Ua;
      }
      function Jl(r) {
        return r > Jo ? r * r * r : Gc * (r - Ua);
      }
      function Ql(r) {
        return 255 * (r <= 31308e-7 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055);
      }
      function Zc(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
      }
      function Hc(r) {
        const e = Zc(r.r), n = Zc(r.g), o = Zc(r.b), u = Kl((0.4124564 * e + 0.3575761 * n + 0.1804375 * o) / Zh), l = Kl((0.2126729 * e + 0.7151522 * n + 0.072175 * o) / 1);
        return { l: 116 * l - 16, a: 500 * (u - l), b: 200 * (l - Kl((0.0193339 * e + 0.119192 * n + 0.9503041 * o) / xl)), alpha: r.a };
      }
      function qc(r) {
        let e = (r.l + 16) / 116, n = isNaN(r.a) ? e : e + r.a / 500, o = isNaN(r.b) ? e : e - r.b / 200;
        return e = 1 * Jl(e), n = Zh * Jl(n), o = xl * Jl(o), new ki(Ql(3.2404542 * n - 1.5371385 * e - 0.4985314 * o), Ql(-0.969266 * n + 1.8760108 * e + 0.041556 * o), Ql(0.0556434 * n - 0.2040259 * e + 1.0572252 * o), r.alpha);
      }
      function Qu(r, e, n) {
        const o = e - r;
        return r + n * (o > 180 || o < -180 ? o - 360 * Math.round(o / 360) : o);
      }
      const p = { forward: Hc, reverse: qc, interpolate: function(r, e, n) {
        return { l: ei(r.l, e.l, n), a: ei(r.a, e.a, n), b: ei(r.b, e.b, n), alpha: ei(r.alpha, e.alpha, n) };
      } }, A = { forward: function(r) {
        const { l: e, a: n, b: o } = Hc(r), u = Math.atan2(o, n) * qh;
        return { h: u < 0 ? u + 360 : u, c: Math.sqrt(n * n + o * o), l: e, alpha: r.a };
      }, reverse: function(r) {
        const e = r.h * Hh, n = r.c;
        return qc({ l: r.l, a: Math.cos(e) * n, b: Math.sin(e) * n, alpha: r.alpha });
      }, interpolate: function(r, e, n) {
        return { h: Qu(r.h, e.h, n), c: ei(r.c, e.c, n), l: ei(r.l, e.l, n), alpha: ei(r.alpha, e.alpha, n) };
      } };
      var B = Object.freeze({ __proto__: null, hcl: A, lab: p });
      class X {
        constructor(e, n, o, u, l, d) {
          this.type = e, this.operator = n, this.interpolation = o, this.input = u, this.dynamicStops = l, this.labels = [], this.outputs = [];
          for (const [v, M] of d)
            this.labels.push(v), this.outputs.push(M);
        }
        static interpolationFactor(e, n, o, u) {
          let l = 0;
          if (e.name === "exponential")
            l = ne(n, e.base, o, u);
          else if (e.name === "linear")
            l = ne(n, 1, o, u);
          else if (e.name === "cubic-bezier") {
            const d = e.controlPoints;
            l = new Us(d[0], d[1], d[2], d[3]).solve(ne(n, 1, o, u));
          }
          return l;
        }
        static parse(e, n) {
          let [o, u, l, ...d] = e;
          if (!Array.isArray(u) || u.length === 0)
            return n.error("Expected an interpolation type expression.", 1);
          if (u[0] === "linear")
            u = { name: "linear" };
          else if (u[0] === "exponential") {
            const D = u[1];
            if (typeof D != "number")
              return n.error("Exponential interpolation requires a numeric base.", 1, 1);
            u = { name: "exponential", base: D };
          } else {
            if (u[0] !== "cubic-bezier")
              return n.error(`Unknown interpolation type ${String(u[0])}`, 1, 0);
            {
              const D = u.slice(1);
              if (D.length !== 4 || D.some((x) => typeof x != "number" || x < 0 || x > 1))
                return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              u = { name: "cubic-bezier", controlPoints: D };
            }
          }
          if (e.length - 1 < 3)
            return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length - 1 > 3 && (e.length - 1) % 2 != 0)
            return n.error("Expected an even number of arguments.");
          if (l = n.parse(l, 2, Ot), !l)
            return null;
          const v = [];
          let M = null;
          if (o === "interpolate-hcl" || o === "interpolate-lab" ? M = ms : n.expectedType && n.expectedType.kind !== "value" && (M = n.expectedType), e.length - 1 == 3) {
            const D = n.parse(d[0], 3, Ai);
            return D ? new X(M, o, u, l, D, v) : null;
          }
          for (let D = 0; D < d.length; D += 2) {
            const x = d[D], E = d[D + 1], I = D + 3, S = D + 4;
            if (typeof x != "number")
              return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', I);
            if (v.length && v[v.length - 1][0] >= x)
              return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', I);
            const C = n.parse(E, S, M);
            if (!C)
              return null;
            M = M || C.type, v.push([x, C]);
          }
          return M.kind === "number" || M.kind === "color" || M.kind === "array" && M.itemType.kind === "number" && typeof M.N == "number" ? new X(M, o, u, l, null, v) : n.error(`Type ${un(M)} is not interpolatable.`);
        }
        evaluate(e) {
          let n = this.labels, o = this.outputs;
          if (this.dynamicStops) {
            const x = this.dynamicStops.evaluate(e);
            if (x.length % 2 != 0)
              throw new qn("Expected an even number of arguments.");
            n = [], o = [];
            for (let E = 0; E < x.length; E += 2) {
              const I = x[E], S = new Lr(Ot, x[E + 1]);
              if (typeof I != "number")
                throw new qn('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
              if (n.length && n[n.length - 1] >= I)
                throw new qn('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
              n.push(I), o.push(S);
            }
            if (n.length === 0)
              throw new qn("Expected at least one input/output pair.");
          }
          if (n.length === 1)
            return o[0].evaluate(e);
          const u = this.input.evaluate(e);
          if (u <= n[0])
            return o[0].evaluate(e);
          const l = n.length;
          if (u >= n[l - 1])
            return o[l - 1].evaluate(e);
          const d = ao(n, u), v = X.interpolationFactor(this.interpolation, u, n[d], n[d + 1]), M = o[d].evaluate(e), D = o[d + 1].evaluate(e);
          return this.operator === "interpolate" ? Oi[this.type.kind.toLowerCase()](M, D, v) : this.operator === "interpolate-hcl" ? A.reverse(A.interpolate(A.forward(M), A.forward(D), v)) : p.reverse(p.interpolate(p.forward(M), p.forward(D), v));
        }
        eachChild(e) {
          e(this.input);
          for (const n of this.outputs)
            e(n);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined());
        }
        serialize() {
          let e;
          e = this.interpolation.name === "linear" ? ["linear"] : this.interpolation.name === "exponential" ? this.interpolation.base === 1 ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const n = [this.operator, e, this.input.serialize()];
          if (this.dynamicStops)
            n.push(this.dynamicStops.serialize());
          else
            for (let o = 0; o < this.labels.length; o++)
              n.push(this.labels[o], this.outputs[o].serialize());
          return n;
        }
      }
      function ne(r, e, n, o) {
        const u = o - n, l = r - n;
        return u === 0 ? 0 : e === 1 ? l / u : (Math.pow(e, l) - 1) / (Math.pow(e, u) - 1);
      }
      class ye {
        constructor(e, n) {
          this.type = e, this.args = n;
        }
        static parse(e, n) {
          if (e.length < 2)
            return n.error("Expectected at least one argument.");
          let o = null;
          const u = n.expectedType;
          u && u.kind !== "value" && (o = u);
          const l = [];
          for (const v of e.slice(1)) {
            const M = n.parse(v, 1 + l.length, o, void 0, { typeAnnotation: "omit" });
            if (!M)
              return null;
            o = o || M.type, l.push(M);
          }
          const d = u && l.some((v) => ha(u, v.type));
          return new ye(d ? Ai : o, l);
        }
        evaluate(e) {
          let n, o = null, u = 0;
          for (const l of this.args) {
            if (u++, o = l.evaluate(e), o && o instanceof ss && !o.available && (n || (n = o), o = null, u === this.args.length))
              return n;
            if (o !== null)
              break;
          }
          return o;
        }
        eachChild(e) {
          this.args.forEach(e);
        }
        outputDefined() {
          return this.args.every((e) => e.outputDefined());
        }
        serialize() {
          const e = ["coalesce"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      class We {
        constructor(e, n) {
          this.type = n.type, this.bindings = [].concat(e), this.result = n;
        }
        evaluate(e) {
          return this.result.evaluate(e);
        }
        eachChild(e) {
          for (const n of this.bindings)
            e(n[1]);
          e(this.result);
        }
        static parse(e, n) {
          if (e.length < 4)
            return n.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
          const o = [];
          for (let l = 1; l < e.length - 1; l += 2) {
            const d = e[l];
            if (typeof d != "string")
              return n.error(`Expected string, but found ${typeof d} instead.`, l);
            if (/[^a-zA-Z0-9_]/.test(d))
              return n.error("Variable names must contain only alphanumeric characters or '_'.", l);
            const v = n.parse(e[l + 1], l + 1);
            if (!v)
              return null;
            o.push([d, v]);
          }
          const u = n.parse(e[e.length - 1], e.length - 1, n.expectedType, o);
          return u ? new We(o, u) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const e = ["let"];
          for (const [n, o] of this.bindings)
            e.push(n, o.serialize());
          return e.push(this.result.serialize()), e;
        }
      }
      class ot {
        constructor(e, n, o) {
          this.type = e, this.index = n, this.input = o;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ot), u = n.parse(e[2], 2, Ms(n.expectedType || Ai));
          return o && u ? new ot(u.type.itemType, o, u) : null;
        }
        evaluate(e) {
          const n = this.index.evaluate(e), o = this.input.evaluate(e);
          if (n < 0)
            throw new qn(`Array index out of bounds: ${n} < 0.`);
          if (n > o.length - 1)
            throw new qn(`Array index out of bounds: ${n} > ${o.length - 1}.`);
          if (n === Math.floor(n))
            return o[n];
          const u = Math.floor(n), l = Math.ceil(n), d = o[u], v = o[l];
          if (typeof d != "number" || typeof v != "number")
            throw new qn(`Cannot interpolate between non-number values at index ${n}.`);
          const M = n - u;
          return d * (1 - M) + v * M;
        }
        eachChild(e) {
          e(this.index), e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      class ft {
        constructor(e, n) {
          this.type = Li, this.needle = e, this.haystack = n;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ai);
          return o && u ? jl(o.type, [Li, Fi, Ot, ca, Ai]) ? new ft(o, u) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${un(o.type)} instead`) : null;
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (o == null)
            return !1;
          if (!ua(n, ["boolean", "string", "number", "null"]))
            throw new qn(`Expected first argument to be of type boolean, string, number or null, but found ${un(vn(n))} instead.`);
          if (!ua(o, ["string", "array"]))
            throw new qn(`Expected second argument to be of type array or string, but found ${un(vn(o))} instead.`);
          return o.indexOf(n) >= 0;
        }
        eachChild(e) {
          e(this.needle), e(this.haystack);
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class Rt {
        constructor(e, n, o) {
          this.type = Ot, this.needle = e, this.haystack = n, this.fromIndex = o;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5)
            return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ai);
          if (!o || !u)
            return null;
          if (!jl(o.type, [Li, Fi, Ot, ca, Ai]))
            return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${un(o.type)} instead`);
          if (e.length === 4) {
            const l = n.parse(e[3], 3, Ot);
            return l ? new Rt(o, u, l) : null;
          }
          return new Rt(o, u);
        }
        evaluate(e) {
          const n = this.needle.evaluate(e), o = this.haystack.evaluate(e);
          if (!ua(n, ["boolean", "string", "number", "null"]))
            throw new qn(`Expected first argument to be of type boolean, string, number or null, but found ${un(vn(n))} instead.`);
          if (!ua(o, ["string", "array"]))
            throw new qn(`Expected second argument to be of type array or string, but found ${un(vn(o))} instead.`);
          if (this.fromIndex) {
            const u = this.fromIndex.evaluate(e);
            return o.indexOf(n, u);
          }
          return o.indexOf(n);
        }
        eachChild(e) {
          e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const e = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), e];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class ii {
        constructor(e, n, o, u, l, d) {
          this.inputType = e, this.type = n, this.input = o, this.cases = u, this.outputs = l, this.otherwise = d;
        }
        static parse(e, n) {
          if (e.length < 5)
            return n.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 1)
            return n.error("Expected an even number of arguments.");
          let o, u;
          n.expectedType && n.expectedType.kind !== "value" && (u = n.expectedType);
          const l = {}, d = [];
          for (let D = 2; D < e.length - 1; D += 2) {
            let x = e[D];
            const E = e[D + 1];
            Array.isArray(x) || (x = [x]);
            const I = n.concat(D);
            if (x.length === 0)
              return I.error("Expected at least one branch label.");
            for (const C of x) {
              if (typeof C != "number" && typeof C != "string")
                return I.error("Branch labels must be numbers or strings.");
              if (typeof C == "number" && Math.abs(C) > Number.MAX_SAFE_INTEGER)
                return I.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof C == "number" && Math.floor(C) !== C)
                return I.error("Numeric branch labels must be integer values.");
              if (o) {
                if (I.checkSubtype(o, vn(C)))
                  return null;
              } else
                o = vn(C);
              if (l[String(C)] !== void 0)
                return I.error("Branch labels must be unique.");
              l[String(C)] = d.length;
            }
            const S = n.parse(E, D, u);
            if (!S)
              return null;
            u = u || S.type, d.push(S);
          }
          const v = n.parse(e[1], 1, Ai);
          if (!v)
            return null;
          const M = n.parse(e[e.length - 1], e.length - 1, u);
          return M ? v.type.kind !== "value" && n.concat(1).checkSubtype(o, v.type) ? null : new ii(o, u, v, l, d, M) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          return (vn(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(e);
        }
        eachChild(e) {
          e(this.input), this.outputs.forEach(e), e(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["match", this.input.serialize()], n = Object.keys(this.cases).sort(), o = [], u = {};
          for (const d of n) {
            const v = u[this.cases[d]];
            v === void 0 ? (u[this.cases[d]] = o.length, o.push([this.cases[d], [d]])) : o[v][1].push(d);
          }
          const l = (d) => this.inputType.kind === "number" ? Number(d) : d;
          for (const [d, v] of o)
            e.push(v.length === 1 ? l(v[0]) : v.map(l)), e.push(this.outputs[d].serialize());
          return e.push(this.otherwise.serialize()), e;
        }
      }
      class Ci {
        constructor(e, n, o) {
          this.type = e, this.branches = n, this.otherwise = o;
        }
        static parse(e, n) {
          if (e.length < 4)
            return n.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
          if (e.length % 2 != 0)
            return n.error("Expected an odd number of arguments.");
          let o;
          n.expectedType && n.expectedType.kind !== "value" && (o = n.expectedType);
          const u = [];
          for (let d = 1; d < e.length - 1; d += 2) {
            const v = n.parse(e[d], d, Li);
            if (!v)
              return null;
            const M = n.parse(e[d + 1], d + 1, o);
            if (!M)
              return null;
            u.push([v, M]), o = o || M.type;
          }
          const l = n.parse(e[e.length - 1], e.length - 1, o);
          return l ? new Ci(o, u, l) : null;
        }
        evaluate(e) {
          for (const [n, o] of this.branches)
            if (n.evaluate(e))
              return o.evaluate(e);
          return this.otherwise.evaluate(e);
        }
        eachChild(e) {
          for (const [n, o] of this.branches)
            e(n), e(o);
          e(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([e, n]) => n.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const e = ["case"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      class Wi {
        constructor(e, n, o, u) {
          this.type = e, this.input = n, this.beginIndex = o, this.endIndex = u;
        }
        static parse(e, n) {
          if (e.length <= 2 || e.length >= 5)
            return n.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1, Ai), u = n.parse(e[2], 2, Ot);
          if (!o || !u)
            return null;
          if (!jl(o.type, [Ms(Ai), Fi, Ai]))
            return n.error(`Expected first argument to be of type array or string, but found ${un(o.type)} instead`);
          if (e.length === 4) {
            const l = n.parse(e[3], 3, Ot);
            return l ? new Wi(o.type, o, u, l) : null;
          }
          return new Wi(o.type, o, u);
        }
        evaluate(e) {
          const n = this.input.evaluate(e), o = this.beginIndex.evaluate(e);
          if (!ua(n, ["string", "array"]))
            throw new qn(`Expected first argument to be of type array or string, but found ${un(vn(n))} instead.`);
          if (this.endIndex) {
            const u = this.endIndex.evaluate(e);
            return n.slice(o, u);
          }
          return n.slice(o);
        }
        eachChild(e) {
          e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const e = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), e];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      function Hs(r, e) {
        return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
      }
      function ws(r, e, n, o) {
        return o.compare(e, n) === 0;
      }
      function Rs(r, e, n) {
        const o = r !== "==" && r !== "!=";
        return class cw {
          constructor(l, d, v) {
            this.type = Li, this.lhs = l, this.rhs = d, this.collator = v, this.hasUntypedArgument = l.type.kind === "value" || d.type.kind === "value";
          }
          static parse(l, d) {
            if (l.length !== 3 && l.length !== 4)
              return d.error("Expected two or three arguments.");
            const v = l[0];
            let M = d.parse(l[1], 1, Ai);
            if (!M)
              return null;
            if (!Hs(v, M.type))
              return d.concat(1).error(`"${v}" comparisons are not supported for type '${un(M.type)}'.`);
            let D = d.parse(l[2], 2, Ai);
            if (!D)
              return null;
            if (!Hs(v, D.type))
              return d.concat(2).error(`"${v}" comparisons are not supported for type '${un(D.type)}'.`);
            if (M.type.kind !== D.type.kind && M.type.kind !== "value" && D.type.kind !== "value")
              return d.error(`Cannot compare types '${un(M.type)}' and '${un(D.type)}'.`);
            o && (M.type.kind === "value" && D.type.kind !== "value" ? M = new zr(D.type, [M]) : M.type.kind !== "value" && D.type.kind === "value" && (D = new zr(M.type, [D])));
            let x = null;
            if (l.length === 4) {
              if (M.type.kind !== "string" && D.type.kind !== "string" && M.type.kind !== "value" && D.type.kind !== "value")
                return d.error("Cannot use collator to compare non-string types.");
              if (x = d.parse(l[3], 3, _s), !x)
                return null;
            }
            return new cw(M, D, x);
          }
          evaluate(l) {
            const d = this.lhs.evaluate(l), v = this.rhs.evaluate(l);
            if (o && this.hasUntypedArgument) {
              const M = vn(d), D = vn(v);
              if (M.kind !== D.kind || M.kind !== "string" && M.kind !== "number")
                throw new qn(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${M.kind}, ${D.kind}) instead.`);
            }
            if (this.collator && !o && this.hasUntypedArgument) {
              const M = vn(d), D = vn(v);
              if (M.kind !== "string" || D.kind !== "string")
                return e(l, d, v);
            }
            return this.collator ? n(l, d, v, this.collator.evaluate(l)) : e(l, d, v);
          }
          eachChild(l) {
            l(this.lhs), l(this.rhs), this.collator && l(this.collator);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            const l = [r];
            return this.eachChild((d) => {
              l.push(d.serialize());
            }), l;
          }
        };
      }
      const ur = Rs("==", function(r, e, n) {
        return e === n;
      }, ws), ja = Rs("!=", function(r, e, n) {
        return e !== n;
      }, function(r, e, n, o) {
        return !ws(0, e, n, o);
      }), ed = Rs("<", function(r, e, n) {
        return e < n;
      }, function(r, e, n, o) {
        return o.compare(e, n) < 0;
      }), td = Rs(">", function(r, e, n) {
        return e > n;
      }, function(r, e, n, o) {
        return o.compare(e, n) > 0;
      }), id = Rs("<=", function(r, e, n) {
        return e <= n;
      }, function(r, e, n, o) {
        return o.compare(e, n) <= 0;
      }), Wh = Rs(">=", function(r, e, n) {
        return e >= n;
      }, function(r, e, n, o) {
        return o.compare(e, n) >= 0;
      });
      class vl {
        constructor(e, n, o, u, l, d) {
          this.type = Fi, this.number = e, this.locale = n, this.currency = o, this.unit = u, this.minFractionDigits = l, this.maxFractionDigits = d;
        }
        static parse(e, n) {
          if (e.length !== 3)
            return n.error("Expected two arguments.");
          const o = n.parse(e[1], 1, Ot);
          if (!o)
            return null;
          const u = e[2];
          if (typeof u != "object" || Array.isArray(u))
            return n.error("NumberFormat options argument must be an object.");
          let l = null;
          if (u.locale && (l = n.parseObjectValue(u.locale, 2, "locale", Fi), !l))
            return null;
          let d = null;
          if (u.currency && (d = n.parseObjectValue(u.currency, 2, "currency", Fi), !d))
            return null;
          let v = null;
          if (u.unit && (v = n.parseObjectValue(u.unit, 2, "unit", Fi), !v))
            return null;
          let M = null;
          if (u["min-fraction-digits"] && (M = n.parseObjectValue(u["min-fraction-digits"], 2, "min-fraction-digits", Ot), !M))
            return null;
          let D = null;
          return u["max-fraction-digits"] && (D = n.parseObjectValue(u["max-fraction-digits"], 2, "max-fraction-digits", Ot), !D) ? null : new vl(o, l, d, v, M, D);
        }
        evaluate(e) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(e) : void 0, unit: this.unit ? this.unit.evaluate(e) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0 }).format(this.number.evaluate(e));
        }
        eachChild(e) {
          e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.unit && e(this.unit), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = {};
          return this.locale && (e.locale = this.locale.serialize()), this.currency && (e.currency = this.currency.serialize()), this.unit && (e.unit = this.unit.serialize()), this.minFractionDigits && (e["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (e["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), e];
        }
      }
      class ec {
        constructor(e) {
          this.type = Ot, this.input = e;
        }
        static parse(e, n) {
          if (e.length !== 2)
            return n.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
          const o = n.parse(e[1], 1);
          return o ? o.type.kind !== "array" && o.type.kind !== "string" && o.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${un(o.type)} instead.`) : new ec(o) : null;
        }
        evaluate(e) {
          const n = this.input.evaluate(e);
          if (typeof n == "string" || Array.isArray(n))
            return n.length;
          throw new qn(`Expected value to be of type string or array, but found ${un(vn(n))} instead.`);
        }
        eachChild(e) {
          e(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const e = ["length"];
          return this.eachChild((n) => {
            e.push(n.serialize());
          }), e;
        }
      }
      function es(r) {
        return function() {
          r = 1831565813 + (r |= 0) | 0;
          let e = Math.imul(r ^ r >>> 15, 1 | r);
          return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
        };
      }
      const Ao = { "==": ur, "!=": ja, ">": td, "<": ed, ">=": Wh, "<=": id, array: zr, at: ot, boolean: zr, case: Ci, coalesce: ye, collator: dl, format: Es, image: ka, in: ft, "index-of": Rt, interpolate: X, "interpolate-hcl": X, "interpolate-lab": X, length: ec, let: We, literal: Lr, match: ii, number: zr, "number-format": vl, object: zr, slice: Wi, step: Ti, string: zr, "to-boolean": so, "to-color": so, "to-number": so, "to-string": so, var: Ko, within: lr, distance: Jr, config: ga };
      function $h(r, [e, n, o, u]) {
        e = e.evaluate(r), n = n.evaluate(r), o = o.evaluate(r);
        const l = u ? u.evaluate(r) : 1, d = da(e, n, o, l);
        if (d)
          throw new qn(d);
        return new ki(e / 255 * l, n / 255 * l, o / 255 * l, l);
      }
      function Xh(r, [e, n, o, u]) {
        e = e.evaluate(r), n = n.evaluate(r), o = o.evaluate(r);
        const l = u ? u.evaluate(r) : 1, d = function(D, x, E, I) {
          return typeof D == "number" && D >= 0 && D <= 360 ? typeof x == "number" && x >= 0 && x <= 100 && typeof E == "number" && E >= 0 && E <= 100 ? I === void 0 || typeof I == "number" && I >= 0 && I <= 1 ? null : `Invalid hsla value [${[D, x, E, I].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(typeof I == "number" ? [D, x, E, I] : [D, x, E]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(typeof I == "number" ? [D, x, E, I] : [D, x, E]).join(", ")}]: 'h' must be between 0 and 360.`;
        }(e, n, o, l);
        if (d)
          throw new qn(d);
        const v = `hsla(${e}, ${n}%, ${o}%, ${l})`, M = ki.parse(v);
        if (!M)
          throw new qn(`Failed to parse HSLA color: ${v}`);
        return M;
      }
      function Wc(r, e) {
        return r in e;
      }
      function Ga(r, e) {
        const n = e[r];
        return n === void 0 ? null : n;
      }
      function vr(r) {
        return { type: r };
      }
      function $c(r) {
        return { result: "success", value: r };
      }
      function ya(r) {
        return { result: "error", value: r };
      }
      function nd(r, e) {
        return !!r && !!r.parameters && r.parameters.indexOf(e) > -1;
      }
      function tc(r) {
        return r["property-type"] === "data-driven";
      }
      function Yh(r) {
        return nd(r.expression, "measure-light");
      }
      function Uf(r) {
        return nd(r.expression, "zoom");
      }
      function sd(r) {
        return !!r.expression && r.expression.interpolated;
      }
      function Kh(r) {
        return typeof r == "object" && r !== null && !Array.isArray(r);
      }
      function jf(r) {
        return r;
      }
      function Gf(r, e) {
        const n = e.type === "color", o = r.stops && typeof r.stops[0][0] == "object", u = o || !(o || r.property !== void 0), l = r.type || (sd(e) ? "exponential" : "interval");
        if (n && ((r = Bi({}, r)).stops && (r.stops = r.stops.map((D) => [D[0], ki.parse(D[1])])), r.default = ki.parse(r.default ? r.default : e.default)), r.colorSpace && r.colorSpace !== "rgb" && !B[r.colorSpace])
          throw new Error(`Unknown color space: ${r.colorSpace}`);
        let d, v, M;
        if (l === "exponential")
          d = rd;
        else if (l === "interval")
          d = Zf;
        else if (l === "categorical") {
          d = qm, v = /* @__PURE__ */ Object.create(null);
          for (const D of r.stops)
            v[D[0]] = D[1];
          M = typeof r.stops[0][0];
        } else {
          if (l !== "identity")
            throw new Error(`Unknown function type "${l}"`);
          d = Jh;
        }
        if (o) {
          const D = {}, x = [];
          for (let S = 0; S < r.stops.length; S++) {
            const C = r.stops[S], k = C[0].zoom;
            D[k] === void 0 && (D[k] = { zoom: k, type: r.type, property: r.property, default: r.default, stops: [] }, x.push(k)), D[k].stops.push([C[0].value, C[1]]);
          }
          const E = [];
          for (const S of x)
            E.push([D[S].zoom, Gf(D[S], e)]);
          const I = { name: "linear" };
          return { kind: "composite", interpolationType: I, interpolationFactor: X.interpolationFactor.bind(void 0, I), zoomStops: E.map((S) => S[0]), evaluate: ({ zoom: S }, C) => rd({ stops: E, base: r.base }, e, S).evaluate(S, C) };
        }
        if (u) {
          const D = l === "exponential" ? { name: "exponential", base: r.base !== void 0 ? r.base : 1 } : null;
          return { kind: "camera", interpolationType: D, interpolationFactor: X.interpolationFactor.bind(void 0, D), zoomStops: r.stops.map((x) => x[0]), evaluate: ({ zoom: x }) => d(r, e, x, v, M) };
        }
        return { kind: "source", evaluate(D, x) {
          const E = x && x.properties ? x.properties[r.property] : void 0;
          return E === void 0 ? Xc(r.default, e.default) : d(r, e, E, v, M);
        } };
      }
      function Xc(r, e, n) {
        return r !== void 0 ? r : e !== void 0 ? e : n !== void 0 ? n : void 0;
      }
      function qm(r, e, n, o, u) {
        return Xc(typeof n === u ? o[n] : void 0, r.default, e.default);
      }
      function Zf(r, e, n) {
        if (Ho(n) !== "number")
          return Xc(r.default, e.default);
        const o = r.stops.length;
        if (o === 1 || n <= r.stops[0][0])
          return r.stops[0][1];
        if (n >= r.stops[o - 1][0])
          return r.stops[o - 1][1];
        const u = ao(r.stops.map((l) => l[0]), n);
        return r.stops[u][1];
      }
      function rd(r, e, n) {
        const o = r.base !== void 0 ? r.base : 1;
        if (Ho(n) !== "number")
          return Xc(r.default, e.default);
        const u = r.stops.length;
        if (u === 1 || n <= r.stops[0][0])
          return r.stops[0][1];
        if (n >= r.stops[u - 1][0])
          return r.stops[u - 1][1];
        const l = ao(r.stops.map((x) => x[0]), n), d = function(x, E, I, S) {
          const C = S - I, k = x - I;
          return C === 0 ? 0 : E === 1 ? k / C : (Math.pow(E, k) - 1) / (Math.pow(E, C) - 1);
        }(n, o, r.stops[l][0], r.stops[l + 1][0]), v = r.stops[l][1], M = r.stops[l + 1][1];
        let D = Oi[e.type] || jf;
        if (r.colorSpace && r.colorSpace !== "rgb") {
          const x = B[r.colorSpace];
          D = (E, I) => x.reverse(x.interpolate(x.forward(E), x.forward(I), d));
        }
        return typeof v.evaluate == "function" ? { evaluate(...x) {
          const E = v.evaluate.apply(void 0, x), I = M.evaluate.apply(void 0, x);
          if (E !== void 0 && I !== void 0)
            return D(E, I, d);
        } } : D(v, M, d);
      }
      function Jh(r, e, n) {
        return e.type === "color" ? n = ki.parse(n) : e.type === "formatted" ? n = Dn.fromString(n.toString()) : e.type === "resolvedImage" ? n = ss.build(n.toString()) : Ho(n) === e.type || e.type === "enum" && e.values[n] || (n = void 0), Xc(n, r.default, e.default);
      }
      or.register(Ao, { error: [{ kind: "error" }, [Fi], (r, [e]) => {
        throw new qn(e.evaluate(r));
      }], typeof: [Fi, [Ai], (r, [e]) => un(vn(e.evaluate(r)))], "to-rgba": [Ms(Ot, 4), [ms], (r, [e]) => e.evaluate(r).toRenderColor(null).toArray()], "to-hsla": [Ms(Ot, 4), [ms], (r, [e]) => e.evaluate(r).toRenderColor(null).toHslaArray()], rgb: [ms, [Ot, Ot, Ot], $h], rgba: [ms, [Ot, Ot, Ot, Ot], $h], hsl: [ms, [Ot, Ot, Ot], Xh], hsla: [ms, [Ot, Ot, Ot, Ot], Xh], has: { type: Li, overloads: [[[Fi], (r, [e]) => Wc(e.evaluate(r), r.properties())], [[Fi, vo], (r, [e, n]) => Wc(e.evaluate(r), n.evaluate(r))]] }, get: { type: Ai, overloads: [[[Fi], (r, [e]) => Ga(e.evaluate(r), r.properties())], [[Fi, vo], (r, [e, n]) => Ga(e.evaluate(r), n.evaluate(r))]] }, "feature-state": [Ai, [Fi], (r, [e]) => Ga(e.evaluate(r), r.featureState || {})], properties: [vo, [], (r) => r.properties()], "geometry-type": [Fi, [], (r) => r.geometryType()], id: [Ai, [], (r) => r.id()], zoom: [Ot, [], (r) => r.globals.zoom], pitch: [Ot, [], (r) => r.globals.pitch || 0], "distance-from-center": [Ot, [], (r) => r.distanceFromCenter()], "measure-light": [Ot, [Fi], (r, [e]) => r.measureLight(e.evaluate(r))], "heatmap-density": [Ot, [], (r) => r.globals.heatmapDensity || 0], "line-progress": [Ot, [], (r) => r.globals.lineProgress || 0], "raster-value": [Ot, [], (r) => r.globals.rasterValue || 0], "raster-particle-speed": [Ot, [], (r) => r.globals.rasterParticleSpeed || 0], "sky-radial-progress": [Ot, [], (r) => r.globals.skyRadialProgress || 0], accumulated: [Ai, [], (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated], "+": [Ot, vr(Ot), (r, e) => {
        let n = 0;
        for (const o of e)
          n += o.evaluate(r);
        return n;
      }], "*": [Ot, vr(Ot), (r, e) => {
        let n = 1;
        for (const o of e)
          n *= o.evaluate(r);
        return n;
      }], "-": { type: Ot, overloads: [[[Ot, Ot], (r, [e, n]) => e.evaluate(r) - n.evaluate(r)], [[Ot], (r, [e]) => -e.evaluate(r)]] }, "/": [Ot, [Ot, Ot], (r, [e, n]) => e.evaluate(r) / n.evaluate(r)], "%": [Ot, [Ot, Ot], (r, [e, n]) => e.evaluate(r) % n.evaluate(r)], ln2: [Ot, [], () => Math.LN2], pi: [Ot, [], () => Math.PI], e: [Ot, [], () => Math.E], "^": [Ot, [Ot, Ot], (r, [e, n]) => Math.pow(e.evaluate(r), n.evaluate(r))], sqrt: [Ot, [Ot], (r, [e]) => Math.sqrt(e.evaluate(r))], log10: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10], ln: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r))], log2: [Ot, [Ot], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2], sin: [Ot, [Ot], (r, [e]) => Math.sin(e.evaluate(r))], cos: [Ot, [Ot], (r, [e]) => Math.cos(e.evaluate(r))], tan: [Ot, [Ot], (r, [e]) => Math.tan(e.evaluate(r))], asin: [Ot, [Ot], (r, [e]) => Math.asin(e.evaluate(r))], acos: [Ot, [Ot], (r, [e]) => Math.acos(e.evaluate(r))], atan: [Ot, [Ot], (r, [e]) => Math.atan(e.evaluate(r))], min: [Ot, vr(Ot), (r, e) => Math.min(...e.map((n) => n.evaluate(r)))], max: [Ot, vr(Ot), (r, e) => Math.max(...e.map((n) => n.evaluate(r)))], abs: [Ot, [Ot], (r, [e]) => Math.abs(e.evaluate(r))], round: [Ot, [Ot], (r, [e]) => {
        const n = e.evaluate(r);
        return n < 0 ? -Math.round(-n) : Math.round(n);
      }], floor: [Ot, [Ot], (r, [e]) => Math.floor(e.evaluate(r))], ceil: [Ot, [Ot], (r, [e]) => Math.ceil(e.evaluate(r))], "filter-==": [Li, [Fi, Ai], (r, [e, n]) => r.properties()[e.value] === n.value], "filter-id-==": [Li, [Ai], (r, [e]) => r.id() === e.value], "filter-type-==": [Li, [Fi], (r, [e]) => r.geometryType() === e.value], "filter-<": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o < u;
      }], "filter-id-<": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n < o;
      }], "filter->": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o > u;
      }], "filter-id->": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n > o;
      }], "filter-<=": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o <= u;
      }], "filter-id-<=": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n <= o;
      }], "filter->=": [Li, [Fi, Ai], (r, [e, n]) => {
        const o = r.properties()[e.value], u = n.value;
        return typeof o == typeof u && o >= u;
      }], "filter-id->=": [Li, [Ai], (r, [e]) => {
        const n = r.id(), o = e.value;
        return typeof n == typeof o && n >= o;
      }], "filter-has": [Li, [Ai], (r, [e]) => e.value in r.properties()], "filter-has-id": [Li, [], (r) => r.id() !== null && r.id() !== void 0], "filter-type-in": [Li, [Ms(Fi)], (r, [e]) => e.value.indexOf(r.geometryType()) >= 0], "filter-id-in": [Li, [Ms(Ai)], (r, [e]) => e.value.indexOf(r.id()) >= 0], "filter-in-small": [Li, [Fi, Ms(Ai)], (r, [e, n]) => n.value.indexOf(r.properties()[e.value]) >= 0], "filter-in-large": [Li, [Fi, Ms(Ai)], (r, [e, n]) => function(o, u, l, d) {
        for (; l <= d; ) {
          const v = l + d >> 1;
          if (u[v] === o)
            return !0;
          u[v] > o ? d = v - 1 : l = v + 1;
        }
        return !1;
      }(r.properties()[e.value], n.value, 0, n.value.length - 1)], all: { type: Li, overloads: [[[Li, Li], (r, [e, n]) => e.evaluate(r) && n.evaluate(r)], [vr(Li), (r, e) => {
        for (const n of e)
          if (!n.evaluate(r))
            return !1;
        return !0;
      }]] }, any: { type: Li, overloads: [[[Li, Li], (r, [e, n]) => e.evaluate(r) || n.evaluate(r)], [vr(Li), (r, e) => {
        for (const n of e)
          if (n.evaluate(r))
            return !0;
        return !1;
      }]] }, "!": [Li, [Li], (r, [e]) => !e.evaluate(r)], "is-supported-script": [Li, [Fi], (r, [e]) => {
        const n = r.globals && r.globals.isSupportedScript;
        return !n || n(e.evaluate(r));
      }], upcase: [Fi, [Fi], (r, [e]) => e.evaluate(r).toUpperCase()], downcase: [Fi, [Fi], (r, [e]) => e.evaluate(r).toLowerCase()], concat: [Fi, vr(Ai), (r, e) => e.map((n) => Ir(n.evaluate(r))).join("")], "resolved-locale": [Fi, [_s], (r, [e]) => e.evaluate(r).resolvedLocale()], random: [Ot, [Ot, Ot, Ai], (r, e) => {
        const [n, o, u] = e.map((d) => d.evaluate(r));
        if (n > o || n === o)
          return n;
        let l;
        if (typeof u == "string")
          l = function(d) {
            let v = 0;
            if (d.length === 0)
              return v;
            for (let M = 0; M < d.length; M++)
              v = (v << 5) - v + d.charCodeAt(M), v |= 0;
            return v;
          }(u);
        else {
          if (typeof u != "number")
            throw new qn(`Invalid seed input: ${u}`);
          l = u;
        }
        return n + es(l)() * (o - n);
      }] });
      class od {
        constructor(e, n, o, u) {
          this.expression = e, this._warningHistory = {}, this._evaluator = new Ra(o, u), this._defaultValue = n ? function(l) {
            return l.type === "color" && (Kh(l.default) || Array.isArray(l.default)) ? new ki(0, 0, 0, 0) : l.type === "color" ? ki.parse(l.default) || null : l.default === void 0 ? null : l.default;
          }(n) : null, this._enumValues = n && n.type === "enum" ? n.values : null, this.configDependencies = kr(e);
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, d, v, M) {
          return this._evaluator.globals = e, this._evaluator.feature = n, this._evaluator.featureState = o, this._evaluator.canonical = u || null, this._evaluator.availableImages = l || null, this._evaluator.formattedSection = d, this._evaluator.featureTileCoord = v || null, this._evaluator.featureDistanceData = M || null, this.expression.evaluate(this._evaluator);
        }
        evaluate(e, n, o, u, l, d, v, M) {
          this._evaluator.globals = e, this._evaluator.feature = n || null, this._evaluator.featureState = o || null, this._evaluator.canonical = u || null, this._evaluator.availableImages = l || null, this._evaluator.formattedSection = d || null, this._evaluator.featureTileCoord = v || null, this._evaluator.featureDistanceData = M || null;
          try {
            const D = this.expression.evaluate(this._evaluator);
            if (D == null || typeof D == "number" && D != D)
              return this._defaultValue;
            if (this._enumValues && !(D in this._enumValues))
              throw new qn(`Expected value to be one of ${Object.keys(this._enumValues).map((x) => JSON.stringify(x)).join(", ")}, but found ${JSON.stringify(D)} instead.`);
            return D;
          } catch (D) {
            return this._warningHistory[D.message] || (this._warningHistory[D.message] = !0, typeof console < "u" && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${D.message}`)), this._defaultValue;
          }
        }
      }
      function Qh(r) {
        return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in Ao;
      }
      function Yc(r, e, n, o) {
        const u = new Qr(Ao, [], e ? function(d) {
          const v = { color: ms, string: Fi, number: Ot, enum: Fi, boolean: Li, formatted: Ks, resolvedImage: Zo };
          return d.type === "array" ? Ms(v[d.value] || Ai, d.length) : v[d.type];
        }(e) : void 0, void 0, void 0, n, o), l = u.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return l ? $c(new od(l, e, n, o)) : ya(u.errors);
      }
      class ad {
        constructor(e, n, o, u) {
          this.kind = e, this._styleExpression = n, this.isLightConstant = o, this.isLineProgressConstant = u, this.isStateDependent = e !== "constant" && !gl(n.expression), this.configDependencies = kr(n.expression);
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, d) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, l, d);
        }
        evaluate(e, n, o, u, l, d) {
          return this._styleExpression.evaluate(e, n, o, u, l, d);
        }
      }
      class ic {
        constructor(e, n, o, u, l, d) {
          this.kind = e, this.zoomStops = o, this._styleExpression = n, this.isStateDependent = e !== "camera" && !gl(n.expression), this.isLightConstant = l, this.isLineProgressConstant = d, this.configDependencies = kr(n.expression), this.interpolationType = u;
        }
        evaluateWithoutErrorHandling(e, n, o, u, l, d) {
          return this._styleExpression.evaluateWithoutErrorHandling(e, n, o, u, l, d);
        }
        evaluate(e, n, o, u, l, d) {
          return this._styleExpression.evaluate(e, n, o, u, l, d);
        }
        interpolationFactor(e, n, o) {
          return this.interpolationType ? X.interpolationFactor(this.interpolationType, e, n, o) : 0;
        }
      }
      function ld(r, e, n, o) {
        if ((r = Yc(r, e, n, o)).result === "error")
          return r;
        const u = r.value.expression, l = ro(u);
        if (!l && !tc(e))
          return ya([new ns("", "data expressions not supported")]);
        const d = oo(u, ["zoom", "pitch", "distance-from-center"]);
        if (!d && !Uf(e))
          return ya([new ns("", "zoom expressions not supported")]);
        const v = oo(u, ["measure-light"]);
        if (!v && !Yh(e))
          return ya([new ns("", "measure-light expression not supported")]);
        const M = oo(u, ["line-progress"]);
        if (!M && !function(E) {
          return nd(E.expression, "line-progress");
        }(e))
          return ya([new ns("", "line-progress expression not supported")]);
        const D = e.expression && e.expression.relaxZoomRestriction, x = tu(u);
        return x || d || D ? x instanceof ns ? ya([x]) : x instanceof X && !sd(e) ? ya([new ns("", '"interpolate" expressions cannot be used with this property')]) : $c(x ? new ic(l && M ? "camera" : "composite", r.value, x.labels, x instanceof X ? x.interpolation : void 0, v, M) : new ad(l && M ? "constant" : "source", r.value, v, M)) : ya([new ns("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class eu {
        constructor(e, n) {
          this._parameters = e, this._specification = n, Bi(this, Gf(this._parameters, this._specification));
        }
        static deserialize(e) {
          return new eu(e._parameters, e._specification);
        }
        static serialize(e) {
          return { _parameters: e._parameters, _specification: e._specification };
        }
      }
      function tu(r) {
        let e = null;
        if (r instanceof We)
          e = tu(r.result);
        else if (r instanceof ye) {
          for (const n of r.args)
            if (e = tu(n), e)
              break;
        } else
          (r instanceof Ti || r instanceof X) && r.input instanceof or && r.input.name === "zoom" && (e = r);
        return e instanceof ns || r.eachChild((n) => {
          const o = tu(n);
          o instanceof ns ? e = o : e && o && e !== o && (e = new ns("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e;
      }
      var cd, hd, Wm = function() {
        if (hd)
          return cd;
        hd = 1, cd = e;
        var r = 3;
        function e(n, o, u) {
          var l = this.cells = [];
          if (n instanceof ArrayBuffer) {
            this.arrayBuffer = n;
            var d = new Int32Array(this.arrayBuffer);
            n = d[0], this.d = (o = d[1]) + 2 * (u = d[2]);
            for (var v = 0; v < this.d * this.d; v++) {
              var M = d[r + v], D = d[r + v + 1];
              l.push(M === D ? null : d.subarray(M, D));
            }
            var x = d[r + l.length + 1];
            this.keys = d.subarray(d[r + l.length], x), this.bboxes = d.subarray(x), this.insert = this._insertReadonly;
          } else {
            this.d = o + 2 * u;
            for (var E = 0; E < this.d * this.d; E++)
              l.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = o, this.extent = n, this.padding = u, this.scale = o / n, this.uid = 0;
          var I = u / o * n;
          this.min = -I, this.max = n + I;
        }
        return e.prototype.insert = function(n, o, u, l, d) {
          this._forEachCell(o, u, l, d, this._insertCell, this.uid++), this.keys.push(n), this.bboxes.push(o), this.bboxes.push(u), this.bboxes.push(l), this.bboxes.push(d);
        }, e.prototype._insertReadonly = function() {
          throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
        }, e.prototype._insertCell = function(n, o, u, l, d, v) {
          this.cells[d].push(v);
        }, e.prototype.query = function(n, o, u, l, d) {
          var v = this.min, M = this.max;
          if (n <= v && o <= v && M <= u && M <= l && !d)
            return Array.prototype.slice.call(this.keys);
          var D = [];
          return this._forEachCell(n, o, u, l, this._queryCell, D, {}, d), D;
        }, e.prototype._queryCell = function(n, o, u, l, d, v, M, D) {
          var x = this.cells[d];
          if (x !== null)
            for (var E = this.keys, I = this.bboxes, S = 0; S < x.length; S++) {
              var C = x[S];
              if (M[C] === void 0) {
                var k = 4 * C;
                (D ? D(I[k + 0], I[k + 1], I[k + 2], I[k + 3]) : n <= I[k + 2] && o <= I[k + 3] && u >= I[k + 0] && l >= I[k + 1]) ? (M[C] = !0, v.push(E[C])) : M[C] = !1;
              }
            }
        }, e.prototype._forEachCell = function(n, o, u, l, d, v, M, D) {
          for (var x = this._convertToCellCoord(n), E = this._convertToCellCoord(o), I = this._convertToCellCoord(u), S = this._convertToCellCoord(l), C = x; C <= I; C++)
            for (var k = E; k <= S; k++) {
              var V = this.d * k + C;
              if ((!D || D(this._convertFromCellCoord(C), this._convertFromCellCoord(k), this._convertFromCellCoord(C + 1), this._convertFromCellCoord(k + 1))) && d.call(this, n, o, u, l, V, v, M, D))
                return;
            }
        }, e.prototype._convertFromCellCoord = function(n) {
          return (n - this.padding) / this.scale;
        }, e.prototype._convertToCellCoord = function(n) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(n * this.scale) + this.padding));
        }, e.prototype.toArrayBuffer = function() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          for (var n = this.cells, o = r + this.cells.length + 1 + 1, u = 0, l = 0; l < this.cells.length; l++)
            u += this.cells[l].length;
          var d = new Int32Array(o + u + this.keys.length + this.bboxes.length);
          d[0] = this.extent, d[1] = this.n, d[2] = this.padding;
          for (var v = o, M = 0; M < n.length; M++) {
            var D = n[M];
            d[r + M] = v, d.set(D, v), v += D.length;
          }
          return d[r + n.length] = v, d.set(this.keys, v), d[r + n.length + 1] = v += this.keys.length, d.set(this.bboxes, v), v += this.bboxes.length, d.buffer;
        }, cd;
      }(), nc = O(Wm);
      const Kc = {};
      function Ft(r, e, n = {}) {
        Object.defineProperty(r, "_classRegistryKey", { value: e, writable: !1 }), Kc[e] = { klass: r, omit: n.omit || [] };
      }
      Ft(Object, "Object"), nc.serialize = function(r, e) {
        const n = r.toArrayBuffer();
        return e && e.add(n), { buffer: n };
      }, nc.deserialize = function(r) {
        return new nc(r.buffer);
      }, Object.defineProperty(nc, "name", { value: "Grid" }), Ft(nc, "Grid"), typeof DOMMatrix < "u" && Ft(DOMMatrix, "DOMMatrix"), Ft(ki, "Color"), Ft(Error, "Error"), Ft(Dn, "Formatted"), Ft(hl, "FormattedSection"), Ft(Uo, "AJAXError"), Ft(ss, "ResolvedImage"), Ft(eu, "StylePropertyFunction"), Ft(od, "StyleExpression", { omit: ["_evaluator"] }), Ft(rr, "ImageIdWithOptions"), Ft(ic, "ZoomDependentExpression"), Ft(ad, "ZoomConstantExpression"), Ft(or, "CompoundExpression", { omit: ["_evaluate"] });
      for (const r in Ao)
        Kc[Ao[r]._classRegistryKey] || Ft(Ao[r], `Expression${r}`);
      function ud(r) {
        return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer");
      }
      function Hf(r) {
        return self.ImageBitmap && r instanceof ImageBitmap;
      }
      function lo(r, e) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp)
          return r;
        if (ud(r) || Hf(r))
          return e && e.add(r), r;
        if (ArrayBuffer.isView(r))
          return e && e.add(r.buffer), r;
        if (r instanceof ImageData)
          return e && e.add(r.data.buffer), r;
        if (Array.isArray(r)) {
          const n = [];
          for (const o of r)
            n.push(lo(o, e));
          return n;
        }
        if (r instanceof Map) {
          const n = { $name: "Map" };
          for (const [o, u] of r.entries())
            n[o] = lo(u);
          return n;
        }
        if (r instanceof Set) {
          const n = { $name: "Set" };
          let o = 0;
          for (const u of r.values())
            n[++o] = lo(u);
          return n;
        }
        if (typeof r == "object") {
          const n = r.constructor, o = n._classRegistryKey;
          if (!o)
            throw new Error(`Can't serialize object of unregistered class "${o}".`);
          const u = n.serialize ? n.serialize(r, e) : {};
          if (!n.serialize) {
            for (const l in r)
              r.hasOwnProperty(l) && (Kc[o].omit.indexOf(l) >= 0 || (u[l] = lo(r[l], e)));
            r instanceof Error && (u.message = r.message);
          }
          if (u.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return o !== "Object" && (u.$name = o), u;
        }
        throw new Error("can't serialize object of type " + typeof r);
      }
      function bl(r) {
        if (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || ud(r) || Hf(r) || ArrayBuffer.isView(r) || r instanceof ImageData)
          return r;
        if (Array.isArray(r))
          return r.map(bl);
        if (typeof r == "object") {
          const e = r.$name || "Object";
          if (e === "Map") {
            const u = /* @__PURE__ */ new Map();
            for (const l of Object.keys(r))
              l !== "$name" && u.set(l, bl(r[l]));
            return u;
          }
          if (e === "Set") {
            const u = /* @__PURE__ */ new Set();
            for (const l of Object.keys(r))
              l !== "$name" && u.add(bl(r[l]));
            return u;
          }
          const { klass: n } = Kc[e];
          if (!n)
            throw new Error(`Can't deserialize unregistered class "${e}".`);
          if (n.deserialize)
            return n.deserialize(r);
          const o = Object.create(n.prototype);
          for (const u of Object.keys(r))
            u !== "$name" && (o[u] = bl(r[u]));
          return o;
        }
        throw new Error("can't deserialize object of type " + typeof r);
      }
      const Zt = { "Latin-1 Supplement": (r) => r >= 128 && r <= 255, Arabic: (r) => r >= 1536 && r <= 1791, "Arabic Supplement": (r) => r >= 1872 && r <= 1919, "Arabic Extended-A": (r) => r >= 2208 && r <= 2303, "Hangul Jamo": (r) => r >= 4352 && r <= 4607, "Unified Canadian Aboriginal Syllabics": (r) => r >= 5120 && r <= 5759, Khmer: (r) => r >= 6016 && r <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (r) => r >= 6320 && r <= 6399, "General Punctuation": (r) => r >= 8192 && r <= 8303, "Letterlike Symbols": (r) => r >= 8448 && r <= 8527, "Number Forms": (r) => r >= 8528 && r <= 8591, "Miscellaneous Technical": (r) => r >= 8960 && r <= 9215, "Control Pictures": (r) => r >= 9216 && r <= 9279, "Optical Character Recognition": (r) => r >= 9280 && r <= 9311, "Enclosed Alphanumerics": (r) => r >= 9312 && r <= 9471, "Geometric Shapes": (r) => r >= 9632 && r <= 9727, "Miscellaneous Symbols": (r) => r >= 9728 && r <= 9983, "Miscellaneous Symbols and Arrows": (r) => r >= 11008 && r <= 11263, "CJK Radicals Supplement": (r) => r >= 11904 && r <= 12031, "Kangxi Radicals": (r) => r >= 12032 && r <= 12255, "Ideographic Description Characters": (r) => r >= 12272 && r <= 12287, "CJK Symbols and Punctuation": (r) => r >= 12288 && r <= 12351, Hiragana: (r) => r >= 12352 && r <= 12447, Katakana: (r) => r >= 12448 && r <= 12543, Bopomofo: (r) => r >= 12544 && r <= 12591, "Hangul Compatibility Jamo": (r) => r >= 12592 && r <= 12687, Kanbun: (r) => r >= 12688 && r <= 12703, "Bopomofo Extended": (r) => r >= 12704 && r <= 12735, "CJK Strokes": (r) => r >= 12736 && r <= 12783, "Katakana Phonetic Extensions": (r) => r >= 12784 && r <= 12799, "Enclosed CJK Letters and Months": (r) => r >= 12800 && r <= 13055, "CJK Compatibility": (r) => r >= 13056 && r <= 13311, "CJK Unified Ideographs Extension A": (r) => r >= 13312 && r <= 19903, "Yijing Hexagram Symbols": (r) => r >= 19904 && r <= 19967, "CJK Unified Ideographs": (r) => r >= 19968 && r <= 40959, "Yi Syllables": (r) => r >= 40960 && r <= 42127, "Yi Radicals": (r) => r >= 42128 && r <= 42191, "Hangul Jamo Extended-A": (r) => r >= 43360 && r <= 43391, "Hangul Syllables": (r) => r >= 44032 && r <= 55215, "Hangul Jamo Extended-B": (r) => r >= 55216 && r <= 55295, "Private Use Area": (r) => r >= 57344 && r <= 63743, "CJK Compatibility Ideographs": (r) => r >= 63744 && r <= 64255, "Arabic Presentation Forms-A": (r) => r >= 64336 && r <= 65023, "Vertical Forms": (r) => r >= 65040 && r <= 65055, "CJK Compatibility Forms": (r) => r >= 65072 && r <= 65103, "Small Form Variants": (r) => r >= 65104 && r <= 65135, "Arabic Presentation Forms-B": (r) => r >= 65136 && r <= 65279, "Halfwidth and Fullwidth Forms": (r) => r >= 65280 && r <= 65519, Osage: (r) => r >= 66736 && r <= 66815, "CJK Unified Ideographs Extension B": (r) => r >= 131072 && r <= 173791 };
      function dd(r) {
        for (const e of r)
          if (iu(e.charCodeAt(0)))
            return !0;
        return !1;
      }
      function qf(r) {
        for (const e of r)
          if (!Wf(e.charCodeAt(0)))
            return !1;
        return !0;
      }
      function Wf(r) {
        return !(Zt.Arabic(r) || Zt["Arabic Supplement"](r) || Zt["Arabic Extended-A"](r) || Zt["Arabic Presentation Forms-A"](r) || Zt["Arabic Presentation Forms-B"](r));
      }
      function iu(r) {
        return !(r !== 746 && r !== 747 && (r < 4352 || !(Zt["Bopomofo Extended"](r) || Zt.Bopomofo(r) || Zt["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || Zt["CJK Compatibility Ideographs"](r) || Zt["CJK Compatibility"](r) || Zt["CJK Radicals Supplement"](r) || Zt["CJK Strokes"](r) || !(!Zt["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || Zt["CJK Unified Ideographs Extension A"](r) || Zt["CJK Unified Ideographs"](r) || Zt["Enclosed CJK Letters and Months"](r) || Zt["Hangul Compatibility Jamo"](r) || Zt["Hangul Jamo Extended-A"](r) || Zt["Hangul Jamo Extended-B"](r) || Zt["Hangul Jamo"](r) || Zt["Hangul Syllables"](r) || Zt.Hiragana(r) || Zt["Ideographic Description Characters"](r) || Zt.Kanbun(r) || Zt["Kangxi Radicals"](r) || Zt["Katakana Phonetic Extensions"](r) || Zt.Katakana(r) && r !== 12540 || !(!Zt["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!Zt["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || Zt["Unified Canadian Aboriginal Syllabics"](r) || Zt["Unified Canadian Aboriginal Syllabics Extended"](r) || Zt["Vertical Forms"](r) || Zt["Yijing Hexagram Symbols"](r) || Zt["Yi Syllables"](r) || Zt["Yi Radicals"](r))));
      }
      function fd(r) {
        return !(iu(r) || function(e) {
          return !!(Zt["Latin-1 Supplement"](e) && (e === 167 || e === 169 || e === 174 || e === 177 || e === 188 || e === 189 || e === 190 || e === 215 || e === 247) || Zt["General Punctuation"](e) && (e === 8214 || e === 8224 || e === 8225 || e === 8240 || e === 8241 || e === 8251 || e === 8252 || e === 8258 || e === 8263 || e === 8264 || e === 8265 || e === 8273) || Zt["Letterlike Symbols"](e) || Zt["Number Forms"](e) || Zt["Miscellaneous Technical"](e) && (e >= 8960 && e <= 8967 || e >= 8972 && e <= 8991 || e >= 8996 && e <= 9e3 || e === 9003 || e >= 9085 && e <= 9114 || e >= 9150 && e <= 9165 || e === 9167 || e >= 9169 && e <= 9179 || e >= 9186 && e <= 9215) || Zt["Control Pictures"](e) && e !== 9251 || Zt["Optical Character Recognition"](e) || Zt["Enclosed Alphanumerics"](e) || Zt["Geometric Shapes"](e) || Zt["Miscellaneous Symbols"](e) && !(e >= 9754 && e <= 9759) || Zt["Miscellaneous Symbols and Arrows"](e) && (e >= 11026 && e <= 11055 || e >= 11088 && e <= 11097 || e >= 11192 && e <= 11243) || Zt["CJK Symbols and Punctuation"](e) || Zt.Katakana(e) || Zt["Private Use Area"](e) || Zt["CJK Compatibility Forms"](e) || Zt["Small Form Variants"](e) || Zt["Halfwidth and Fullwidth Forms"](e) || e === 8734 || e === 8756 || e === 8757 || e >= 9984 && e <= 10087 || e >= 10102 && e <= 10131 || e === 65532 || e === 65533);
        }(r));
      }
      function nu(r) {
        return r >= 1424 && r <= 2303 || Zt["Arabic Presentation Forms-A"](r) || Zt["Arabic Presentation Forms-B"](r);
      }
      function pd(r, e) {
        return !(!e && nu(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || Zt.Khmer(r));
      }
      function $f(r) {
        for (const e of r)
          if (nu(e.charCodeAt(0)))
            return !0;
        return !1;
      }
      const md = "deferred", Qo = "loading", _d = "loaded";
      let gd = null, br = "unavailable", Za = null;
      const Jc = function(r) {
        r && typeof r == "string" && r.indexOf("NetworkError") > -1 && (br = "error"), gd && gd(r);
      };
      function su() {
        sc.fire(new Pr("pluginStateChange", { pluginStatus: br, pluginURL: Za }));
      }
      const sc = new Go(), ru = function() {
        return br;
      }, Xf = function() {
        if (br !== md || !Za)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        br = Qo, su(), Za && no({ url: Za }, (r) => {
          r ? Jc(r) : (br = _d, su());
        });
      }, co = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => br === _d || co.applyArabicShaping != null, isLoading: () => br === Qo, setState(r) {
        br = r.pluginStatus, Za = r.pluginURL;
      }, isParsed: () => co.applyArabicShaping != null && co.processBidirectionalText != null && co.processStyledBidirectionalText != null, getPluginURL: () => Za };
      class Tn {
        constructor(e, n) {
          this.zoom = e, n ? (this.now = n.now, this.fadeDuration = n.fadeDuration, this.transition = n.transition, this.pitch = n.pitch, this.brightness = n.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
        }
        isSupportedScript(e) {
          return function(n, o) {
            for (const u of n)
              if (!pd(u.charCodeAt(0), o))
                return !1;
            return !0;
          }(e, co.isLoaded());
        }
      }
      class rc {
        constructor(e, n, o, u) {
          this.property = e, this.value = n, this.expression = function(l, d, v, M) {
            if (Kh(l))
              return new eu(l, d);
            if (Qh(l) || Array.isArray(l) && l.length > 0) {
              const D = ld(l, d, v, M);
              if (D.result === "error")
                throw new Error(D.value.map((x) => `${x.key}: ${x.message}`).join(", "));
              return D.value;
            }
            {
              let D = l;
              return typeof l == "string" && d.type === "color" && (D = ki.parse(l)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => D };
            }
          }(n === void 0 ? e.specification.default : n, e.specification, o, u);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(e, n, o) {
          return this.property.possiblyEvaluate(this, e, n, o);
        }
      }
      class ou {
        constructor(e, n, o) {
          this.property = e, this.value = new rc(e, void 0, n, o);
        }
        transitioned(e, n) {
          return new wl(this.property, this.value, n, Pn({}, e.transition, this.transition), e.now);
        }
        untransitioned() {
          return new wl(this.property, this.value, null, {}, 0);
        }
      }
      class Qc {
        constructor(e, n, o) {
          this._properties = e, this._values = Object.create(e.defaultTransitionablePropertyValues), this._scope = n, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(e) {
          return Xs(this._values[e].value.value);
        }
        setValue(e, n) {
          this._values.hasOwnProperty(e) || (this._values[e] = new ou(this._values[e].property, this._scope, this._options)), this._values[e].value = new rc(this._values[e].property, n === null ? void 0 : Xs(n), this._scope, this._options), this._values[e].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].value.expression.configDependencies]));
        }
        setTransitionOrValue(e, n) {
          n && (this._options = n);
          const o = this._properties.properties;
          if (e)
            for (const u in e) {
              const l = e[u];
              if (yr(u, "-transition")) {
                const d = u.slice(0, -11);
                o[d] && this.setTransition(d, l);
              } else
                o.hasOwnProperty(u) && this.setValue(u, l);
            }
        }
        getTransition(e) {
          return Xs(this._values[e].transition);
        }
        setTransition(e, n) {
          this._values.hasOwnProperty(e) || (this._values[e] = new ou(this._values[e].property)), this._values[e].transition = Xs(n) || void 0;
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
            const u = this.getTransition(n);
            u !== void 0 && (e[`${n}-transition`] = u);
          }
          return e;
        }
        transitioned(e, n) {
          const o = new Yf(this._properties);
          for (const u of Object.keys(this._values))
            o._values[u] = this._values[u].transitioned(e, n._values[u]);
          return o;
        }
        untransitioned() {
          const e = new Yf(this._properties);
          for (const n of Object.keys(this._values))
            e._values[n] = this._values[n].untransitioned();
          return e;
        }
      }
      class wl {
        constructor(e, n, o, u, l) {
          const d = u.delay || 0, v = u.duration || 0;
          l = l || 0, this.property = e, this.value = n, this.begin = l + d, this.end = this.begin + v, e.specification.transition && (u.delay || u.duration) && (this.prior = o);
        }
        possiblyEvaluate(e, n, o) {
          const u = e.now || 0, l = this.value.possiblyEvaluate(e, n, o), d = this.prior;
          if (d) {
            if (u > this.end)
              return this.prior = null, l;
            if (this.value.isDataDriven())
              return this.prior = null, l;
            if (u < this.begin)
              return d.possiblyEvaluate(e, n, o);
            {
              const v = (u - this.begin) / (this.end - this.begin);
              return this.property.interpolate(d.possiblyEvaluate(e, n, o), l, Hr(v));
            }
          }
          return l;
        }
      }
      class Yf {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(e, n, o) {
          const u = new ac(this._properties);
          for (const l of Object.keys(this._values))
            u._values[l] = this._values[l].possiblyEvaluate(e, n, o);
          return u;
        }
        hasTransition() {
          for (const e of Object.keys(this._values))
            if (this._values[e].prior)
              return !0;
          return !1;
        }
      }
      class $m {
        constructor(e, n, o) {
          this._properties = e, this._values = Object.create(e.defaultPropertyValues), this._scope = n, this._options = o, this.configDependencies = /* @__PURE__ */ new Set();
        }
        getValue(e) {
          return Xs(this._values[e].value);
        }
        setValue(e, n) {
          this._values[e] = new rc(this._values[e].property, n === null ? void 0 : Xs(n), this._scope, this._options), this._values[e].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[e].expression.configDependencies]));
        }
        serialize() {
          const e = {};
          for (const n of Object.keys(this._values)) {
            const o = this.getValue(n);
            o !== void 0 && (e[n] = o);
          }
          return e;
        }
        possiblyEvaluate(e, n, o) {
          const u = new ac(this._properties);
          for (const l of Object.keys(this._values))
            u._values[l] = this._values[l].possiblyEvaluate(e, n, o);
          return u;
        }
      }
      class oc {
        constructor(e, n, o) {
          this.property = e, this.value = n, this.parameters = o;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(e) {
          return this.value.kind === "constant" ? this.value.value : e;
        }
        evaluate(e, n, o, u) {
          return this.property.evaluate(this.value, this.parameters, e, n, o, u);
        }
      }
      class ac {
        constructor(e) {
          this._properties = e, this._values = Object.create(e.defaultPossiblyEvaluatedValues);
        }
        get(e) {
          return this._values[e];
        }
      }
      class gt {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n) {
          return e.expression.evaluate(n);
        }
        interpolate(e, n, o) {
          const u = Oi[this.specification.type];
          return u ? u(e, n, o) : e;
        }
      }
      class Dt {
        constructor(e, n) {
          this.specification = e, this.overrides = n;
        }
        possiblyEvaluate(e, n, o, u) {
          return new oc(this, e.expression.kind === "constant" || e.expression.kind === "camera" ? { kind: "constant", value: e.expression.evaluate(n, null, {}, o, u) } : e.expression, n);
        }
        interpolate(e, n, o) {
          if (e.value.kind !== "constant" || n.value.kind !== "constant")
            return e;
          if (e.value.value === void 0 || n.value.value === void 0)
            return new oc(this, { kind: "constant", value: void 0 }, e.parameters);
          const u = Oi[this.specification.type];
          return u ? new oc(this, { kind: "constant", value: u(e.value.value, n.value.value, o) }, e.parameters) : e;
        }
        evaluate(e, n, o, u, l, d) {
          return e.kind === "constant" ? e.value : e.evaluate(n, o, u, l, d);
        }
      }
      class Ha {
        constructor(e) {
          this.specification = e;
        }
        possiblyEvaluate(e, n, o, u) {
          return !!e.expression.evaluate(n, null, {}, o, u);
        }
        interpolate() {
          return !1;
        }
      }
      class Bn {
        constructor(e) {
          this.properties = e, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          const n = new Tn(0, {});
          for (const o in e) {
            const u = e[o];
            u.specification.overridable && this.overridableProperties.push(o);
            const l = this.defaultPropertyValues[o] = new rc(u, void 0), d = this.defaultTransitionablePropertyValues[o] = new ou(u);
            this.defaultTransitioningPropertyValues[o] = d.untransitioned(), this.defaultPossiblyEvaluatedValues[o] = l.possiblyEvaluate(n);
          }
        }
      }
      Ft(Dt, "DataDrivenProperty"), Ft(gt, "DataConstantProperty"), Ft(Ha, "ColorRampProperty");
      var $e = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
      function Kf(r) {
        return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
      }
      function au(r) {
        if (Array.isArray(r))
          return r.map(au);
        if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
          const e = {};
          for (const n in r)
            e[n] = au(r[n]);
          return e;
        }
        return Kf(r);
      }
      function yd(r) {
        if (r === !0 || r === !1)
          return !0;
        if (!Array.isArray(r) || r.length === 0)
          return !1;
        switch (r[0]) {
          case "has":
            return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
          case "in":
            return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
          case "any":
          case "all":
            for (const e of r.slice(1))
              if (!yd(e) && typeof e != "boolean")
                return !1;
            return !0;
          default:
            return !0;
        }
      }
      function Jf(r, e = "", n = null, o = "fill") {
        if (r == null)
          return { filter: () => !0, needGeometry: !1, needFeature: !1 };
        yd(r) || (r = eh(r));
        const u = r;
        let l = !0;
        try {
          l = function(x) {
            if (!lc(x))
              return x;
            let E = au(x);
            return ep(E), E = Qf(E), E;
          }(u);
        } catch {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(u, null, 2)}
        `);
        }
        let d = null, v = null;
        if (o !== "background" && o !== "sky" && o !== "slot") {
          v = $e[`filter_${o}`];
          const x = Yc(l, v, e, n);
          if (x.result === "error")
            throw new Error(x.value.map((E) => `${E.key}: ${E.message}`).join(", "));
          d = (E, I, S) => x.value.evaluate(E, I, {}, S);
        }
        let M = null, D = null;
        if (l !== u) {
          const x = Yc(u, v, e, n);
          if (x.result === "error")
            throw new Error(x.value.map((E) => `${E.key}: ${E.message}`).join(", "));
          M = (E, I, S, C, k) => x.value.evaluate(E, I, {}, S, void 0, void 0, C, k), D = !ro(x.value.expression);
        }
        return { filter: d, dynamicFilter: M || void 0, needGeometry: Tl(l), needFeature: !!D };
      }
      function Qf(r) {
        if (!Array.isArray(r))
          return r;
        const e = function(n) {
          if (Xm.has(n[0])) {
            for (let o = 1; o < n.length; o++)
              if (lc(n[o]))
                return !0;
          }
          return n;
        }(r);
        return e === !0 ? e : e.map((n) => Qf(n));
      }
      function ep(r) {
        let e = !1;
        const n = [];
        if (r[0] === "case") {
          for (let o = 1; o < r.length - 1; o += 2)
            e = e || lc(r[o]), n.push(r[o + 1]);
          n.push(r[r.length - 1]);
        } else if (r[0] === "match") {
          e = e || lc(r[1]);
          for (let o = 2; o < r.length - 1; o += 2)
            n.push(r[o + 1]);
          n.push(r[r.length - 1]);
        } else if (r[0] === "step") {
          e = e || lc(r[1]);
          for (let o = 1; o < r.length - 1; o += 2)
            n.push(r[o + 1]);
        }
        e && (r.length = 0, r.push("any", ...n));
        for (let o = 1; o < r.length; o++)
          ep(r[o]);
      }
      function lc(r) {
        if (!Array.isArray(r))
          return !1;
        if ((e = r[0]) === "pitch" || e === "distance-from-center")
          return !0;
        var e;
        for (let n = 1; n < r.length; n++)
          if (lc(r[n]))
            return !0;
        return !1;
      }
      const Xm = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
      function Ym(r, e) {
        return r < e ? -1 : r > e ? 1 : 0;
      }
      function Tl(r) {
        if (!Array.isArray(r))
          return !1;
        if (r[0] === "within" || r[0] === "distance")
          return !0;
        for (let e = 1; e < r.length; e++)
          if (Tl(r[e]))
            return !0;
        return !1;
      }
      function eh(r) {
        if (!r)
          return !0;
        const e = r[0];
        return r.length <= 1 ? e !== "any" : e === "==" ? lu(r[1], r[2], "==") : e === "!=" ? cu(lu(r[1], r[2], "==")) : e === "<" || e === ">" || e === "<=" || e === ">=" ? lu(r[1], r[2], e) : e === "any" ? (n = r.slice(1), ["any"].concat(n.map(eh))) : e === "all" ? ["all"].concat(r.slice(1).map(eh)) : e === "none" ? ["all"].concat(r.slice(1).map(eh).map(cu)) : e === "in" ? th(r[1], r.slice(2)) : e === "!in" ? cu(th(r[1], r.slice(2))) : e === "has" ? tp(r[1]) : e !== "!has" || cu(tp(r[1]));
        var n;
      }
      function lu(r, e, n) {
        switch (r) {
          case "$type":
            return [`filter-type-${n}`, e];
          case "$id":
            return [`filter-id-${n}`, e];
          default:
            return [`filter-${n}`, r, e];
        }
      }
      function th(r, e) {
        if (e.length === 0)
          return !1;
        switch (r) {
          case "$type":
            return ["filter-type-in", ["literal", e]];
          case "$id":
            return ["filter-id-in", ["literal", e]];
          default:
            return e.length > 200 && !e.some((n) => typeof n != typeof e[0]) ? ["filter-in-large", r, ["literal", e.sort(Ym)]] : ["filter-in-small", r, ["literal", e]];
        }
      }
      function tp(r) {
        switch (r) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", r];
        }
      }
      function cu(r) {
        return ["!", r];
      }
      const Po = "";
      function Co(r, e) {
        return e ? `${r}${Po}${e}` : r;
      }
      const Sl = "-transition", Km = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
      class wr extends Go {
        constructor(e, n, o, u, l) {
          if (super(), this.id = e.id, this.fqid = Co(this.id, o), this.type = e.type, this.scope = o, this.lut = u, this.options = l, this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }, this._filterCompiled = !1, this.configDependencies = /* @__PURE__ */ new Set(), e.type !== "custom") {
            if (this.metadata = e.metadata, this.minzoom = e.minzoom, this.maxzoom = e.maxzoom, e.type && e.type !== "background" && e.type !== "sky" && e.type !== "slot") {
              this.source = e.source, this.sourceLayer = e["source-layer"], this.filter = e.filter;
              const d = Yc(this.filter, $e[`filter_${e.type}`]);
              d.result !== "error" && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...d.value.configDependencies]));
            }
            if (e.slot && (this.slot = e.slot), n.layout && (this._unevaluatedLayout = new $m(n.layout, this.scope, l), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), n.paint) {
              this._transitionablePaint = new Qc(n.paint, this.scope, l);
              for (const d in e.paint)
                this.setPaintProperty(d, e.paint[d]);
              for (const d in e.layout)
                this.setLayoutProperty(d, e.layout[d]);
              this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ac(n.paint);
            }
          }
        }
        onAdd(e) {
        }
        onRemove(e) {
        }
        isDraped(e) {
          return !this.is3D() && Km.has(this.type);
        }
        getLayoutProperty(e) {
          return e === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(e);
        }
        setLayoutProperty(e, n) {
          if (this.type === "custom" && e === "visibility")
            return void (this.visibility = n);
          const o = this._unevaluatedLayout;
          o._properties.properties[e] && (o.setValue(e, n), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), e === "visibility" && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
        }
        getPaintProperty(e) {
          return yr(e, Sl) ? this._transitionablePaint.getTransition(e.slice(0, -11)) : this._transitionablePaint.getValue(e);
        }
        setPaintProperty(e, n) {
          const o = this._transitionablePaint, u = o._properties.properties;
          if (yr(e, Sl)) {
            const E = e.slice(0, -11);
            return u[E] && o.setTransition(E, n || void 0), !1;
          }
          if (!u[e])
            return !1;
          const l = o._values[e], d = l.value.isDataDriven(), v = l.value;
          o.setValue(e, n), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...o.configDependencies]), this._handleSpecialPaintPropertyUpdate(e);
          const M = o._values[e].value, D = M.isDataDriven(), x = yr(e, "pattern") || e === "line-dasharray";
          return D || d || x || this._handleOverridablePaintPropertyUpdate(e, v, M);
        }
        _handleSpecialPaintPropertyUpdate(e) {
        }
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(e, n, o) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !1;
        }
        isHidden(e) {
          return !!(this.minzoom && e < this.minzoom) || !!(this.maxzoom && e >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(e) {
          this._transitioningPaint = this._transitionablePaint.transitioned(e, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(e, n) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(e, void 0, n)), this.paint = this._transitioningPaint.possiblyEvaluate(e, void 0, n);
        }
        serialize() {
          return io({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (e, n) => !(e === void 0 || n === "layout" && !Object.keys(e).length || n === "paint" && !Object.keys(e).length));
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        hasShadowPass() {
          return !1;
        }
        canCastShadows() {
          return !1;
        }
        hasLightBeamPass() {
          return !1;
        }
        cutoffRange() {
          return 0;
        }
        tileCoverLift() {
          return 0;
        }
        resize() {
        }
        isStateDependent() {
          for (const e in this.paint._values) {
            const n = this.paint.get(e);
            if (n instanceof oc && tc(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent)
              return !0;
          }
          return !1;
        }
        compileFilter(e) {
          this._filterCompiled || (this._featureFilter = Jf(this.filter, this.scope, e), this._filterCompiled = !0);
        }
        invalidateCompiledFilter() {
          this._filterCompiled = !1;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats(e) {
          this._stats && (e.renderPass === "shadow" ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
        }
        queryRadius(e) {
        }
        queryIntersectsFeature(e, n, o, u, l, d, v, M, D) {
        }
      }
      const Jm = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class ih {
        constructor(e, n) {
          this._structArray = e, this._pos1 = n * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class bn {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(e, n) {
          return e._trim(), n && (e.isTransferred = !0, n.add(e.arrayBuffer)), { length: e.length, arrayBuffer: e.arrayBuffer };
        }
        static deserialize(e) {
          const n = Object.create(this.prototype);
          return n.arrayBuffer = e.arrayBuffer, n.length = e.length, n.capacity = e.arrayBuffer.byteLength / n.bytesPerElement, n._refreshViews(), n;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(e) {
          this.reserve(e), this.length = e;
        }
        reserve(e) {
          if (e > this.capacity) {
            this.capacity = Math.max(e, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const n = this.uint8;
            this._refreshViews(), n && this.uint8.set(n);
          }
        }
        _refreshViews() {
          throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
        }
        emplace(...e) {
          throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
        }
        emplaceBack(...e) {
          throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
        }
        destroy() {
          this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
        }
      }
      function qi(r, e = 1) {
        let n = 0, o = 0;
        return { members: r.map((u) => {
          const l = Jm[u.type].BYTES_PER_ELEMENT, d = n = hu(n, Math.max(e, l)), v = u.components || 1;
          return o = Math.max(o, l), n += l * v, { name: u.name, type: u.type, components: v, offset: d };
        }), size: hu(n, Math.max(o, e)), alignment: e };
      }
      function hu(r, e) {
        return Math.ceil(r / e) * e;
      }
      class Io extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.int16[u + 0] = n, this.int16[u + 1] = o, e;
        }
      }
      Io.prototype.bytesPerElement = 4, Ft(Io, "StructArrayLayout2i4");
      class nh extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.int16[l + 0] = n, this.int16[l + 1] = o, this.int16[l + 2] = u, e;
        }
      }
      nh.prototype.bytesPerElement = 6, Ft(nh, "StructArrayLayout3i6");
      class qa extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const d = 4 * e;
          return this.int16[d + 0] = n, this.int16[d + 1] = o, this.int16[d + 2] = u, this.int16[d + 3] = l, e;
        }
      }
      qa.prototype.bytesPerElement = 8, Ft(qa, "StructArrayLayout4i8");
      class xd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, d) {
          const v = 5 * e;
          return this.int16[v + 0] = n, this.int16[v + 1] = o, this.int16[v + 2] = u, this.int16[v + 3] = l, this.int16[v + 4] = d, e;
        }
      }
      xd.prototype.bytesPerElement = 10, Ft(xd, "StructArrayLayout5i10");
      class ho extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v) {
          const M = this.length;
          return this.resize(M + 1), this.emplace(M, e, n, o, u, l, d, v);
        }
        emplace(e, n, o, u, l, d, v, M) {
          const D = 6 * e, x = 12 * e, E = 3 * e;
          return this.int16[D + 0] = n, this.int16[D + 1] = o, this.uint8[x + 4] = u, this.uint8[x + 5] = l, this.uint8[x + 6] = d, this.uint8[x + 7] = v, this.float32[E + 2] = M, e;
        }
      }
      ho.prototype.bytesPerElement = 12, Ft(ho, "StructArrayLayout2i4ub1f12");
      class Wa extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const d = 4 * e;
          return this.float32[d + 0] = n, this.float32[d + 1] = o, this.float32[d + 2] = u, this.float32[d + 3] = l, e;
        }
      }
      Wa.prototype.bytesPerElement = 16, Ft(Wa, "StructArrayLayout4f16");
      class xa extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.float32[l + 0] = n, this.float32[l + 1] = o, this.float32[l + 2] = u, e;
        }
      }
      xa.prototype.bytesPerElement = 12, Ft(xa, "StructArrayLayout3f12");
      class $a extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, d) {
          const v = 6 * e, M = 3 * e;
          return this.uint16[v + 0] = n, this.uint16[v + 1] = o, this.uint16[v + 2] = u, this.uint16[v + 3] = l, this.float32[M + 2] = d, e;
        }
      }
      $a.prototype.bytesPerElement = 12, Ft($a, "StructArrayLayout4ui1f12");
      class uu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const d = 4 * e;
          return this.uint16[d + 0] = n, this.uint16[d + 1] = o, this.uint16[d + 2] = u, this.uint16[d + 3] = l, e;
        }
      }
      uu.prototype.bytesPerElement = 8, Ft(uu, "StructArrayLayout4ui8");
      class du extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, d);
        }
        emplace(e, n, o, u, l, d, v) {
          const M = 6 * e;
          return this.int16[M + 0] = n, this.int16[M + 1] = o, this.int16[M + 2] = u, this.int16[M + 3] = l, this.int16[M + 4] = d, this.int16[M + 5] = v, e;
        }
      }
      du.prototype.bytesPerElement = 12, Ft(du, "StructArrayLayout6i12");
      class vd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E, I) {
          const S = this.length;
          return this.resize(S + 1), this.emplace(S, e, n, o, u, l, d, v, M, D, x, E, I);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I, S) {
          const C = 12 * e;
          return this.int16[C + 0] = n, this.int16[C + 1] = o, this.int16[C + 2] = u, this.int16[C + 3] = l, this.uint16[C + 4] = d, this.uint16[C + 5] = v, this.uint16[C + 6] = M, this.uint16[C + 7] = D, this.int16[C + 8] = x, this.int16[C + 9] = E, this.int16[C + 10] = I, this.int16[C + 11] = S, e;
        }
      }
      vd.prototype.bytesPerElement = 24, Ft(vd, "StructArrayLayout4i4ui4i24");
      class bd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, d);
        }
        emplace(e, n, o, u, l, d, v) {
          const M = 10 * e, D = 5 * e;
          return this.int16[M + 0] = n, this.int16[M + 1] = o, this.int16[M + 2] = u, this.float32[D + 2] = l, this.float32[D + 3] = d, this.float32[D + 4] = v, e;
        }
      }
      bd.prototype.bytesPerElement = 20, Ft(bd, "StructArrayLayout3i3f20");
      class wd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint32[1 * e + 0] = n, e;
        }
      }
      wd.prototype.bytesPerElement = 4, Ft(wd, "StructArrayLayout1ul4");
      class Xa extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.uint16[u + 0] = n, this.uint16[u + 1] = o, e;
        }
      }
      Xa.prototype.bytesPerElement = 4, Ft(Xa, "StructArrayLayout2ui4");
      class Td extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E, I, S) {
          const C = this.length;
          return this.resize(C + 1), this.emplace(C, e, n, o, u, l, d, v, M, D, x, E, I, S);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I, S, C) {
          const k = 20 * e, V = 10 * e;
          return this.int16[k + 0] = n, this.int16[k + 1] = o, this.int16[k + 2] = u, this.int16[k + 3] = l, this.int16[k + 4] = d, this.float32[V + 3] = v, this.float32[V + 4] = M, this.float32[V + 5] = D, this.float32[V + 6] = x, this.int16[k + 14] = E, this.uint32[V + 8] = I, this.uint16[k + 18] = S, this.uint16[k + 19] = C, e;
        }
      }
      Td.prototype.bytesPerElement = 40, Ft(Td, "StructArrayLayout5i4f1i1ul2ui40");
      class fu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v) {
          const M = this.length;
          return this.resize(M + 1), this.emplace(M, e, n, o, u, l, d, v);
        }
        emplace(e, n, o, u, l, d, v, M) {
          const D = 8 * e;
          return this.int16[D + 0] = n, this.int16[D + 1] = o, this.int16[D + 2] = u, this.int16[D + 4] = l, this.int16[D + 5] = d, this.int16[D + 6] = v, this.int16[D + 7] = M, e;
        }
      }
      fu.prototype.bytesPerElement = 16, Ft(fu, "StructArrayLayout3i2i2i16");
      class pu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, d) {
          const v = 4 * e, M = 8 * e;
          return this.float32[v + 0] = n, this.float32[v + 1] = o, this.float32[v + 2] = u, this.int16[M + 6] = l, this.int16[M + 7] = d, e;
        }
      }
      pu.prototype.bytesPerElement = 16, Ft(pu, "StructArrayLayout2f1f2i16");
      class Sd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, e, n, o, u, l, d);
        }
        emplace(e, n, o, u, l, d, v) {
          const M = 20 * e, D = 5 * e;
          return this.uint8[M + 0] = n, this.uint8[M + 1] = o, this.float32[D + 1] = u, this.float32[D + 2] = l, this.float32[D + 3] = d, this.float32[D + 4] = v, e;
        }
      }
      Sd.prototype.bytesPerElement = 20, Ft(Sd, "StructArrayLayout2ub4f20");
      class qs extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o) {
          const u = this.length;
          return this.resize(u + 1), this.emplace(u, e, n, o);
        }
        emplace(e, n, o, u) {
          const l = 3 * e;
          return this.uint16[l + 0] = n, this.uint16[l + 1] = o, this.uint16[l + 2] = u, e;
        }
      }
      qs.prototype.bytesPerElement = 6, Ft(qs, "StructArrayLayout3ui6");
      class Md extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K) {
          const Q = this.length;
          return this.resize(Q + 1), this.emplace(Q, e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K, Q) {
          const ie = 30 * e, fe = 15 * e, de = 60 * e;
          return this.int16[ie + 0] = n, this.int16[ie + 1] = o, this.int16[ie + 2] = u, this.float32[fe + 2] = l, this.float32[fe + 3] = d, this.uint16[ie + 8] = v, this.uint16[ie + 9] = M, this.uint32[fe + 5] = D, this.uint32[fe + 6] = x, this.uint32[fe + 7] = E, this.uint16[ie + 16] = I, this.uint16[ie + 17] = S, this.uint16[ie + 18] = C, this.float32[fe + 10] = k, this.float32[fe + 11] = V, this.uint8[de + 48] = U, this.uint8[de + 49] = q, this.uint8[de + 50] = $, this.uint32[fe + 13] = H, this.int16[ie + 28] = K, this.uint8[de + 58] = Q, e;
        }
      }
      Md.prototype.bytesPerElement = 60, Ft(Md, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
      class mu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K, Q, ie, fe, de, he, Me, me, Ee, ze, Ie, Re) {
          const Ve = this.length;
          return this.resize(Ve + 1), this.emplace(Ve, e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K, Q, ie, fe, de, he, Me, me, Ee, ze, Ie, Re);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U, q, $, H, K, Q, ie, fe, de, he, Me, me, Ee, ze, Ie, Re, Ve) {
          const Ue = 20 * e, Fe = 40 * e, et = 80 * e;
          return this.float32[Ue + 0] = n, this.float32[Ue + 1] = o, this.int16[Fe + 4] = u, this.int16[Fe + 5] = l, this.int16[Fe + 6] = d, this.int16[Fe + 7] = v, this.int16[Fe + 8] = M, this.int16[Fe + 9] = D, this.int16[Fe + 10] = x, this.int16[Fe + 11] = E, this.int16[Fe + 12] = I, this.uint16[Fe + 13] = S, this.uint16[Fe + 14] = C, this.uint16[Fe + 15] = k, this.uint16[Fe + 16] = V, this.uint16[Fe + 17] = U, this.uint16[Fe + 18] = q, this.uint16[Fe + 19] = $, this.uint16[Fe + 20] = H, this.uint16[Fe + 21] = K, this.uint16[Fe + 22] = Q, this.uint16[Fe + 23] = ie, this.uint16[Fe + 24] = fe, this.uint16[Fe + 25] = de, this.uint16[Fe + 26] = he, this.uint16[Fe + 27] = Me, this.uint32[Ue + 14] = me, this.float32[Ue + 15] = Ee, this.float32[Ue + 16] = ze, this.float32[Ue + 17] = Ie, this.float32[Ue + 18] = Re, this.uint8[et + 76] = Ve, e;
        }
      }
      mu.prototype.bytesPerElement = 80, Ft(mu, "StructArrayLayout2f9i15ui1ul4f1ub80");
      class cc extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.float32[1 * e + 0] = n, e;
        }
      }
      cc.prototype.bytesPerElement = 4, Ft(cc, "StructArrayLayout1f4");
      class Rr extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l) {
          const d = this.length;
          return this.resize(d + 1), this.emplace(d, e, n, o, u, l);
        }
        emplace(e, n, o, u, l, d) {
          const v = 5 * e;
          return this.float32[v + 0] = n, this.float32[v + 1] = o, this.float32[v + 2] = u, this.float32[v + 3] = l, this.float32[v + 4] = d, e;
        }
      }
      Rr.prototype.bytesPerElement = 20, Ft(Rr, "StructArrayLayout5f20");
      class _u extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v) {
          const M = this.length;
          return this.resize(M + 1), this.emplace(M, e, n, o, u, l, d, v);
        }
        emplace(e, n, o, u, l, d, v, M) {
          const D = 7 * e;
          return this.float32[D + 0] = n, this.float32[D + 1] = o, this.float32[D + 2] = u, this.float32[D + 3] = l, this.float32[D + 4] = d, this.float32[D + 5] = v, this.float32[D + 6] = M, e;
        }
      }
      _u.prototype.bytesPerElement = 28, Ft(_u, "StructArrayLayout7f28");
      class Ed extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E) {
          const I = this.length;
          return this.resize(I + 1), this.emplace(I, e, n, o, u, l, d, v, M, D, x, E);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I) {
          const S = 11 * e;
          return this.float32[S + 0] = n, this.float32[S + 1] = o, this.float32[S + 2] = u, this.float32[S + 3] = l, this.float32[S + 4] = d, this.float32[S + 5] = v, this.float32[S + 6] = M, this.float32[S + 7] = D, this.float32[S + 8] = x, this.float32[S + 9] = E, this.float32[S + 10] = I, e;
        }
      }
      Ed.prototype.bytesPerElement = 44, Ft(Ed, "StructArrayLayout11f44");
      class Ad extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D) {
          const x = this.length;
          return this.resize(x + 1), this.emplace(x, e, n, o, u, l, d, v, M, D);
        }
        emplace(e, n, o, u, l, d, v, M, D, x) {
          const E = 9 * e;
          return this.float32[E + 0] = n, this.float32[E + 1] = o, this.float32[E + 2] = u, this.float32[E + 3] = l, this.float32[E + 4] = d, this.float32[E + 5] = v, this.float32[E + 6] = M, this.float32[E + 7] = D, this.float32[E + 8] = x, e;
        }
      }
      Ad.prototype.bytesPerElement = 36, Ft(Ad, "StructArrayLayout9f36");
      class Ml extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, e, n);
        }
        emplace(e, n, o) {
          const u = 2 * e;
          return this.float32[u + 0] = n, this.float32[u + 1] = o, e;
        }
      }
      Ml.prototype.bytesPerElement = 8, Ft(Ml, "StructArrayLayout2f8");
      class sh extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, e, n, o, u);
        }
        emplace(e, n, o, u, l) {
          const d = 6 * e;
          return this.uint32[3 * e + 0] = n, this.uint16[d + 2] = o, this.uint16[d + 3] = u, this.uint16[d + 4] = l, e;
        }
      }
      sh.prototype.bytesPerElement = 12, Ft(sh, "StructArrayLayout1ul3ui12");
      class gu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint16[1 * e + 0] = n, e;
        }
      }
      gu.prototype.bytesPerElement = 2, Ft(gu, "StructArrayLayout1ui2");
      class Pd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V) {
          const U = this.length;
          return this.resize(U + 1), this.emplace(U, e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V);
        }
        emplace(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U) {
          const q = 16 * e;
          return this.float32[q + 0] = n, this.float32[q + 1] = o, this.float32[q + 2] = u, this.float32[q + 3] = l, this.float32[q + 4] = d, this.float32[q + 5] = v, this.float32[q + 6] = M, this.float32[q + 7] = D, this.float32[q + 8] = x, this.float32[q + 9] = E, this.float32[q + 10] = I, this.float32[q + 11] = S, this.float32[q + 12] = C, this.float32[q + 13] = k, this.float32[q + 14] = V, this.float32[q + 15] = U, e;
        }
      }
      Pd.prototype.bytesPerElement = 64, Ft(Pd, "StructArrayLayout16f64");
      class rh extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(e, n, o, u, l, d, v) {
          const M = this.length;
          return this.resize(M + 1), this.emplace(M, e, n, o, u, l, d, v);
        }
        emplace(e, n, o, u, l, d, v, M) {
          const D = 10 * e, x = 5 * e;
          return this.uint16[D + 0] = n, this.uint16[D + 1] = o, this.uint16[D + 2] = u, this.uint16[D + 3] = l, this.float32[x + 2] = d, this.float32[x + 3] = v, this.float32[x + 4] = M, e;
        }
      }
      rh.prototype.bytesPerElement = 20, Ft(rh, "StructArrayLayout4ui3f20");
      class Cd extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.int16[1 * e + 0] = n, e;
        }
      }
      Cd.prototype.bytesPerElement = 2, Ft(Cd, "StructArrayLayout1i2");
      class yu extends bn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(e) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, e);
        }
        emplace(e, n) {
          return this.uint8[1 * e + 0] = n, e;
        }
      }
      yu.prototype.bytesPerElement = 1, Ft(yu, "StructArrayLayout1ub1");
      class oh extends ih {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      oh.prototype.size = 40;
      class ip extends Td {
        get(e) {
          return new oh(this, e);
        }
      }
      Ft(ip, "CollisionBoxArray");
      class np extends ih {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(e) {
          this._structArray.uint8[this._pos1 + 49] = e;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(e) {
          this._structArray.uint8[this._pos1 + 50] = e;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 13] = e;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(e) {
          this._structArray.uint8[this._pos1 + 58] = e;
        }
      }
      np.prototype.size = 60;
      class sp extends Md {
        get(e) {
          return new np(this, e);
        }
      }
      Ft(sp, "PlacedSymbolArray");
      class rp extends ih {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(e) {
          this._structArray.uint32[this._pos4 + 14] = e;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(e) {
          this._structArray.float32[this._pos4 + 18] = e;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      rp.prototype.size = 80;
      class op extends mu {
        get(e) {
          return new rp(this, e);
        }
      }
      Ft(op, "SymbolInstanceArray");
      class ah extends cc {
        getoffsetX(e) {
          return this.float32[1 * e + 0];
        }
      }
      Ft(ah, "GlyphOffsetArray");
      class lh extends Io {
        getx(e) {
          return this.int16[2 * e + 0];
        }
        gety(e) {
          return this.int16[2 * e + 1];
        }
      }
      Ft(lh, "SymbolLineVertexArray");
      class Or extends ih {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      Or.prototype.size = 12;
      class ch extends sh {
        get(e) {
          return new Or(this, e);
        }
      }
      Ft(ch, "FeatureIndexArray");
      class ap extends Xa {
        geta_centroid_pos0(e) {
          return this.uint16[2 * e + 0];
        }
        geta_centroid_pos1(e) {
          return this.uint16[2 * e + 1];
        }
      }
      Ft(ap, "FillExtrusionCentroidArray");
      class lp extends ih {
        get a_join_normal_inside0() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get a_join_normal_inside1() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get a_join_normal_inside2() {
          return this._structArray.int16[this._pos2 + 2];
        }
      }
      lp.prototype.size = 6;
      class cp extends nh {
        get(e) {
          return new lp(this, e);
        }
      }
      Ft(cp, "FillExtrusionWallArray");
      const Qm = qi([{ name: "a_pos", components: 2, type: "Int16" }], 4), Id = qi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
      class Wn {
        constructor(e = []) {
          this.segments = e;
        }
        _prepareSegment(e, n, o, u) {
          let l = this.segments[this.segments.length - 1];
          return e > Wn.MAX_VERTEX_ARRAY_LENGTH && mi(`Max vertices per segment is ${Wn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`), (!l || l.vertexLength + e > Wn.MAX_VERTEX_ARRAY_LENGTH || l.sortKey !== u) && (l = { vertexOffset: n, primitiveOffset: o, vertexLength: 0, primitiveLength: 0 }, u !== void 0 && (l.sortKey = u), this.segments.push(l)), l;
        }
        prepareSegment(e, n, o, u) {
          return this._prepareSegment(e, n.length, o.length, u);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const e of this.segments)
            for (const n in e.vaos)
              e.vaos[n].destroy();
        }
        static simpleSegment(e, n, o, u) {
          return new Wn([{ vertexOffset: e, primitiveOffset: n, vertexLength: o, primitiveLength: u, vaos: {}, sortKey: 0 }]);
        }
      }
      function xu(r, e) {
        return 256 * (r = si(Math.floor(r), 0, 255)) + si(Math.floor(e), 0, 255);
      }
      Wn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ft(Wn, "SegmentVector");
      const e_ = qi([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), t_ = qi([{ name: "a_dash", components: 4, type: "Uint16" }]);
      class El {
        constructor() {
          this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
        }
        add(e, n, o, u) {
          this.ids.push(hp(e)), this.positions.push(n, o, u);
        }
        eachPosition(e, n) {
          const o = hp(e);
          let u = 0, l = this.ids.length - 1;
          for (; u < l; ) {
            const d = u + l >> 1;
            this.ids[d] >= o ? l = d : u = d + 1;
          }
          for (; this.ids[u] === o; )
            n(this.positions[3 * u], this.positions[3 * u + 1], this.positions[3 * u + 2]), u++;
        }
        static serialize(e, n) {
          const o = new Float64Array(e.ids), u = new Uint32Array(e.positions);
          return vu(o, u, 0, o.length - 1), n && (n.add(o.buffer), n.add(u.buffer)), { ids: o, positions: u };
        }
        static deserialize(e) {
          const n = new El();
          let o;
          n.ids = e.ids, n.positions = e.positions;
          for (const u of n.ids)
            u !== o && n.uniqueIds.push(u), o = u;
          return n.indexed = !0, n;
        }
      }
      function hp(r) {
        const e = +r;
        return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : $r(String(r));
      }
      function vu(r, e, n, o) {
        for (; n < o; ) {
          const u = r[n + o >> 1];
          let l = n - 1, d = o + 1;
          for (; ; ) {
            do
              l++;
            while (r[l] < u);
            do
              d--;
            while (r[d] > u);
            if (l >= d)
              break;
            hh(r, l, d), hh(e, 3 * l, 3 * d), hh(e, 3 * l + 1, 3 * d + 1), hh(e, 3 * l + 2, 3 * d + 2);
          }
          d - n < o - d ? (vu(r, e, n, d), n = d + 1) : (vu(r, e, d + 1, o), o = d);
        }
      }
      function hh(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      Ft(El, "FeaturePositionMap");
      class va {
        constructor(e) {
          this.gl = e.gl, this.initialized = !1;
        }
        fetchUniformLocation(e, n) {
          return this.location || this.initialized || (this.location = this.gl.getUniformLocation(e, n), this.initialized = !0), !!this.location;
        }
        set(e, n, o) {
          throw new Error("Uniform#set() must be implemented by each concrete Uniform");
        }
      }
      class hc extends va {
        constructor(e) {
          super(e), this.current = 0;
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && this.current !== o && (this.current = o, this.gl.uniform1i(this.location, o));
        }
      }
      class Nn extends va {
        constructor(e) {
          super(e), this.current = 0;
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
        }
      }
      class Lo extends va {
        constructor(e) {
          super(e), this.current = [0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] || (this.current = o, this.gl.uniform2f(this.location, o[0], o[1])));
        }
      }
      class Ld extends va {
        constructor(e) {
          super(e), this.current = [0, 0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] || (this.current = o, this.gl.uniform3f(this.location, o[0], o[1], o[2])));
        }
      }
      class uh extends va {
        constructor(e) {
          super(e), this.current = [0, 0, 0, 0];
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3])));
        }
      }
      class up extends va {
        constructor(e) {
          super(e), this.current = ki.transparent.toRenderColor(null);
        }
        set(e, n, o) {
          this.fetchUniformLocation(e, n) && (o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a)));
        }
      }
      const zd = new Float32Array(16);
      class dh extends va {
        constructor(e) {
          super(e), this.current = zd;
        }
        set(e, n, o) {
          if (this.fetchUniformLocation(e, n)) {
            if (o[12] !== this.current[12] || o[0] !== this.current[0])
              return this.current = o, void this.gl.uniformMatrix4fv(this.location, !1, o);
            for (let u = 1; u < 16; u++)
              if (o[u] !== this.current[u]) {
                this.current = o, this.gl.uniformMatrix4fv(this.location, !1, o);
                break;
              }
          }
        }
      }
      const i_ = new Float32Array(9), n_ = new Float32Array(4);
      class Dd extends va {
        constructor(e) {
          super(e), this.current = n_;
        }
        set(e, n, o) {
          if (this.fetchUniformLocation(e, n)) {
            for (let u = 0; u < 4; u++)
              if (o[u] !== this.current[u]) {
                this.current = o, this.gl.uniformMatrix2fv(this.location, !1, o);
                break;
              }
          }
        }
      }
      function bu(r) {
        return [xu(255 * r.r, 255 * r.g), xu(255 * r.b, 255 * r.a)];
      }
      class uc {
        constructor(e, n, o, u) {
          this.value = e, this.uniformNames = n.map((l) => `u_${l}`), this.type = o, this.context = u;
        }
        setUniform(e, n, o, u, l) {
          const d = u.constantOr(this.value);
          n.set(e, l, d instanceof ki ? d.toRenderColor(this.ignoreLut ? null : this.context.lut) : d);
        }
        getBinding(e, n) {
          return this.type === "color" ? new up(e) : new Nn(e);
        }
      }
      class dc {
        constructor(e, n) {
          this.uniformNames = n.map((o) => `u_${o}`), this.pattern = null, this.pixelRatio = 1;
        }
        setConstantPatternPositions(e) {
          this.pixelRatio = e.pixelRatio || 1, this.pattern = e.tl.concat(e.br);
        }
        setUniform(e, n, o, u, l) {
          const d = l === "u_pattern" || l === "u_dash" ? this.pattern : l === "u_pixel_ratio" ? this.pixelRatio : null;
          d && n.set(e, l, d);
        }
        getBinding(e, n) {
          return n === "u_pattern" || n === "u_dash" ? new uh(e) : new Nn(e);
        }
      }
      class ba {
        constructor(e, n, o, u) {
          this.expression = e, this.type = o, this.maxValue = 0, this.paintVertexAttributes = n.map((l) => ({ name: `a_${l}`, type: "Float32", components: o === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, o, u, l, d, v) {
          const M = this.paintVertexArray.length, D = this.expression.evaluate(new Tn(0, { brightness: d }), n, {}, l, u, v);
          this.paintVertexArray.resize(e), this._setPaintValue(M, e, D, this.context);
        }
        updatePaintArray(e, n, o, u, l, d, v) {
          const M = this.expression.evaluate({ zoom: 0, brightness: v }, o, u, void 0, l);
          this._setPaintValue(e, n, M, this.context);
        }
        _setPaintValue(e, n, o, u) {
          if (this.type === "color") {
            const l = bu(o.toRenderColor(this.ignoreLut ? null : u.lut));
            for (let d = e; d < n; d++)
              this.paintVertexArray.emplace(d, l[0], l[1]);
          } else {
            for (let l = e; l < n; l++)
              this.paintVertexArray.emplace(l, o);
            this.maxValue = Math.max(this.maxValue, Math.abs(o));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class zo {
        constructor(e, n, o, u, l, d) {
          this.expression = e, this.uniformNames = n.map((v) => `u_${v}_t`), this.type = o, this.useIntegerZoom = u, this.context = l, this.maxValue = 0, this.paintVertexAttributes = n.map((v) => ({ name: `a_${v}`, type: "Float32", components: o === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new d();
        }
        populatePaintArray(e, n, o, u, l, d, v) {
          const M = this.expression.evaluate(new Tn(this.context.zoom, { brightness: d }), n, {}, l, u, v), D = this.expression.evaluate(new Tn(this.context.zoom + 1, { brightness: d }), n, {}, l, u, v), x = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValue(x, e, M, D, this.context);
        }
        updatePaintArray(e, n, o, u, l, d, v) {
          const M = this.expression.evaluate({ zoom: this.context.zoom, brightness: v }, o, u, void 0, l), D = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: v }, o, u, void 0, l);
          this._setPaintValue(e, n, M, D, this.context);
        }
        _setPaintValue(e, n, o, u, l) {
          if (this.type === "color") {
            const d = bu(o.toRenderColor(this.ignoreLut ? null : l.lut)), v = bu(o.toRenderColor(this.ignoreLut ? null : l.lut));
            for (let M = e; M < n; M++)
              this.paintVertexArray.emplace(M, d[0], d[1], v[0], v[1]);
          } else {
            for (let d = e; d < n; d++)
              this.paintVertexArray.emplace(d, o, u);
            this.maxValue = Math.max(this.maxValue, Math.abs(o), Math.abs(u));
          }
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(e, n, o, u, l) {
          const d = this.useIntegerZoom ? Math.floor(o.zoom) : o.zoom, v = si(this.expression.interpolationFactor(d, this.context.zoom, this.context.zoom + 1), 0, 1);
          n.set(e, l, v);
        }
        getBinding(e, n) {
          return new Nn(e);
        }
      }
      class Ya {
        constructor(e, n, o, u, l) {
          this.expression = e, this.layerId = l, this.paintVertexAttributes = (o === "array" ? t_ : e_).members;
          for (let d = 0; d < n.length; ++d)
            ;
          this.paintVertexArray = new u();
        }
        populatePaintArray(e, n, o, u) {
          const l = this.paintVertexArray.length;
          this.paintVertexArray.resize(e), this._setPaintValues(l, e, n.patterns && n.patterns[this.layerId], o);
        }
        updatePaintArray(e, n, o, u, l, d, v) {
          this._setPaintValues(e, n, o.patterns && o.patterns[this.layerId], d);
        }
        _setPaintValues(e, n, o, u) {
          if (!u || !o)
            return;
          const l = u[o];
          if (!l)
            return;
          const { tl: d, br: v, pixelRatio: M } = l;
          for (let D = e; D < n; D++)
            this.paintVertexArray.emplace(D, d[0], d[1], v[0], v[1], M);
        }
        upload(e) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = e.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Al {
        constructor(e, n, o = () => !0) {
          this.binders = {}, this._buffers = [], this.context = n;
          const u = [];
          for (const l in e.paint._values) {
            const d = e.paint.get(l), v = e.paint.get(`${l}-use-theme`);
            if (l.endsWith("-use-theme") || !o(l) || !(d instanceof oc && tc(d.property.specification)))
              continue;
            const M = wu(l, e.type), D = d.value, x = d.property.specification.type, E = !!d.property.useIntegerZoom, I = l === "line-dasharray" || l.endsWith("pattern"), S = l === "line-dasharray" && e.layout.get("line-cap").value.kind !== "constant";
            if (D.kind !== "constant" || S)
              if (D.kind === "source" || S || I) {
                const C = fh(l, x, "source");
                this.binders[l] = I ? new Ya(D, M, x, C, e.id) : new ba(D, M, x, C), u.push(`/a_${l}`);
              } else {
                const C = fh(l, x, "composite");
                this.binders[l] = new zo(D, M, x, E, n, C), u.push(`/z_${l}`);
              }
            else
              this.binders[l] = I ? new dc(D.value, M) : new uc(D.value, M, x, n), u.push(`/u_${l}`);
            v && (this.binders[l].ignoreLut = v.constantOr("default") === "none", this.binders[l].checkUseTheme = !0);
          }
          this.cacheKey = u.sort().join("");
        }
        getMaxValue(e) {
          const n = this.binders[e];
          return n instanceof ba || n instanceof zo ? n.maxValue : 0;
        }
        populatePaintArrays(e, n, o, u, l, d, v) {
          for (const M in this.binders) {
            const D = this.binders[M];
            D.context = this.context, (D instanceof ba || D instanceof zo || D instanceof Ya) && D.populatePaintArray(e, n, o, u, l, d, v);
          }
        }
        setConstantPatternPositions(e) {
          for (const n in this.binders) {
            const o = this.binders[n];
            o instanceof dc && o.setConstantPatternPositions(e);
          }
        }
        updatePaintArrays(e, n, o, u, l, d, v, M, D) {
          let x = !1;
          const E = Object.keys(e), I = E.length !== 0 && !M, S = I ? E : n.uniqueIds;
          this.context.lut = l.lut;
          for (const C in this.binders) {
            const k = this.binders[C];
            if (k.context = this.context, (k instanceof ba || k instanceof zo || k instanceof Ya) && (k.expression.isStateDependent === !0 || k.expression.isLightConstant === !1)) {
              const V = l.paint.get(C);
              k.expression = V.value;
              for (const U of S) {
                const q = e[U.toString()];
                n.eachPosition(U, ($, H, K) => {
                  const Q = u.feature($);
                  k.updatePaintArray(H, K, Q, q, d, v, D);
                });
              }
              if (!I)
                for (const U of o.uniqueIds) {
                  const q = e[U.toString()];
                  o.eachPosition(U, ($, H, K) => {
                    const Q = u.feature($);
                    k.updatePaintArray(H, K, Q, q, d, v, D);
                  });
                }
              x = !0;
            }
          }
          return x;
        }
        defines() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof uc || o instanceof dc) && e.push(...o.uniformNames.map((u) => `#define HAS_UNIFORM_${u}`));
          }
          return e;
        }
        getBinderAttributes() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof ba || o instanceof zo || o instanceof Ya)
              for (let u = 0; u < o.paintVertexAttributes.length; u++)
                e.push(o.paintVertexAttributes[u].name);
          }
          return e;
        }
        getBinderUniforms() {
          const e = [];
          for (const n in this.binders) {
            const o = this.binders[n];
            if (o instanceof uc || o instanceof dc || o instanceof zo)
              for (const u of o.uniformNames)
                e.push(u);
          }
          return e;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(e) {
          const n = [];
          for (const o in this.binders) {
            const u = this.binders[o];
            if (u instanceof uc || u instanceof dc || u instanceof zo)
              for (const l of u.uniformNames)
                n.push({ name: l, property: o, binding: u.getBinding(e, l) });
          }
          return n;
        }
        setUniforms(e, n, o, u, l) {
          for (const { name: d, property: v, binding: M } of o) {
            if (this.binders[v].checkUseTheme && this.binders[v] instanceof uc) {
              const D = u.get(`${v}-use-theme`);
              D.isConstant() && (this.binders[v].ignoreLut = D.constantOr("default") === "none");
            }
            this.binders[v].setUniform(e, M, l, u.get(v), d);
          }
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof ba || n instanceof zo || n instanceof Ya) && n.paintVertexBuffer && this._buffers.push(n.paintVertexBuffer);
          }
        }
        upload(e) {
          for (const n in this.binders) {
            const o = this.binders[n];
            (o instanceof ba || o instanceof zo || o instanceof Ya) && o.upload(e);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const e in this.binders) {
            const n = this.binders[e];
            (n instanceof ba || n instanceof zo || n instanceof Ya) && n.destroy();
          }
        }
      }
      class Ka {
        constructor(e, n, o = () => !0) {
          this.programConfigurations = {};
          for (const u of e)
            this.programConfigurations[u.id] = new Al(u, n, o);
          this.needsUpload = !1, this._featureMap = new El(), this._featureMapWithoutIds = new El(), this._bufferOffset = 0, this._idlessCounter = 0;
        }
        populatePaintArrays(e, n, o, u, l, d, v, M) {
          for (const D in this.programConfigurations)
            this.programConfigurations[D].populatePaintArrays(e, n, u, l, d, v, M);
          n.id !== void 0 ? this._featureMap.add(n.id, o, this._bufferOffset, e) : (this._featureMapWithoutIds.add(this._idlessCounter, o, this._bufferOffset, e), this._idlessCounter += 1), this._bufferOffset = e, this.needsUpload = !0;
        }
        updatePaintArrays(e, n, o, u, l, d, v) {
          for (const M of o)
            this.needsUpload = this.programConfigurations[M.id].updatePaintArrays(e, this._featureMap, this._featureMapWithoutIds, n, M, u, l, d, v || 0) || this.needsUpload;
        }
        get(e) {
          return this.programConfigurations[e];
        }
        upload(e) {
          if (this.needsUpload) {
            for (const n in this.programConfigurations)
              this.programConfigurations[n].upload(e);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const e in this.programConfigurations)
            this.programConfigurations[e].destroy();
        }
      }
      const s_ = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio"], "fill-pattern": ["pattern", "pixel_ratio"], "fill-extrusion-pattern": ["pattern", "pixel_ratio"], "line-dasharray": ["dash"] };
      function wu(r, e) {
        return s_[r] || [r.replace(`${e}-`, "").replace(/-/g, "_")];
      }
      const r_ = { "line-pattern": { source: $a, composite: $a }, "fill-pattern": { source: $a, composite: $a }, "fill-extrusion-pattern": { source: $a, composite: $a }, "line-dasharray": { source: uu, composite: uu } }, o_ = { color: { source: Ml, composite: Wa }, number: { source: cc, composite: Ml } };
      function fh(r, e, n) {
        const o = r_[r];
        return o && o[n] || o_[e][n];
      }
      Ft(uc, "ConstantBinder"), Ft(dc, "PatternConstantBinder"), Ft(ba, "SourceExpressionBinder"), Ft(Ya, "PatternCompositeBinder"), Ft(zo, "CompositeExpressionBinder"), Ft(Al, "ProgramConfiguration", { omit: ["_buffers"] }), Ft(Ka, "ProgramConfigurationSet");
      const dr = wt / Math.PI / 2, Tu = 5, dp = 6, fp = 16383, Pl = 64, Su = [Pl, 32, 16], uo = -dr, fo = dr;
      function fc(r, e, n, o = dr) {
        return n = vi(n), [r * Math.sin(n) * o, -e * o, r * Math.cos(n) * o];
      }
      function Ja(r, e, n) {
        return fc(Math.cos(vi(r)), Math.sin(vi(r)), e, n);
      }
      const pc = 63710088e-1, kd = 2 * Math.PI * pc;
      class Ui {
        constructor(e, n) {
          if (isNaN(e) || isNaN(n))
            throw new Error(`Invalid LngLat object: (${e}, ${n})`);
          if (this.lng = +e, this.lat = +n, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Ui(zn(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(e) {
          const n = Math.PI / 180, o = this.lat * n, u = e.lat * n, l = Math.sin(o) * Math.sin(u) + Math.cos(o) * Math.cos(u) * Math.cos((e.lng - this.lng) * n);
          return pc * Math.acos(Math.min(l, 1));
        }
        toBounds(e = 0) {
          const n = 360 * e / 40075017, o = n / Math.cos(Math.PI / 180 * this.lat);
          return new Qa({ lng: this.lng - o, lat: this.lat - n }, { lng: this.lng + o, lat: this.lat + n });
        }
        toEcef(e) {
          return Ja(this.lat, this.lng, dr + e * dr / pc);
        }
        static convert(e) {
          if (e instanceof Ui)
            return e;
          if (Array.isArray(e) && (e.length === 2 || e.length === 3))
            return new Ui(Number(e[0]), Number(e[1]));
          if (!Array.isArray(e) && typeof e == "object" && e !== null)
            return new Ui(Number("lng" in e ? e.lng : e.lon), Number(e.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      class Qa {
        constructor(e, n) {
          if (e)
            if (n)
              this.setSouthWest(e).setNorthEast(n);
            else if (e.length === 4) {
              const o = e;
              this.setSouthWest([o[0], o[1]]).setNorthEast([o[2], o[3]]);
            } else {
              const o = e;
              this.setSouthWest(o[0]).setNorthEast(o[1]);
            }
        }
        setNorthEast(e) {
          return this._ne = e instanceof Ui ? new Ui(e.lng, e.lat) : Ui.convert(e), this;
        }
        setSouthWest(e) {
          return this._sw = e instanceof Ui ? new Ui(e.lng, e.lat) : Ui.convert(e), this;
        }
        extend(e) {
          const n = this._sw, o = this._ne;
          let u, l;
          if (e instanceof Ui)
            u = e, l = e;
          else {
            if (!(e instanceof Qa))
              return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(Qa.convert(e)) : this.extend(Ui.convert(e)) : typeof e == "object" && e !== null && e.hasOwnProperty("lat") && (e.hasOwnProperty("lon") || e.hasOwnProperty("lng")) ? this.extend(Ui.convert(e)) : this;
            if (u = e._sw, l = e._ne, !u || !l)
              return this;
          }
          return n || o ? (n.lng = Math.min(u.lng, n.lng), n.lat = Math.min(u.lat, n.lat), o.lng = Math.max(l.lng, o.lng), o.lat = Math.max(l.lat, o.lat)) : (this._sw = new Ui(u.lng, u.lat), this._ne = new Ui(l.lng, l.lat)), this;
        }
        getCenter() {
          return new Ui((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Ui(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Ui(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(e) {
          const { lng: n, lat: o } = Ui.convert(e);
          let u = this._sw.lng <= n && n <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (u = this._sw.lng >= n && n >= this._ne.lng), this._sw.lat <= o && o <= this._ne.lat && u;
        }
        static convert(e) {
          if (e)
            return e instanceof Qa ? e : new Qa(e);
        }
      }
      const a_ = 0, pp = 25.5;
      function ph(r) {
        return kd * Math.cos(r * Math.PI / 180);
      }
      function ea(r) {
        return (180 + r) / 360;
      }
      function wa(r) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
      }
      function fr(r, e) {
        return r / ph(e);
      }
      function Fr(r) {
        return 360 * r - 180;
      }
      function Os(r) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90;
      }
      function mp(r, e) {
        return r * ph(Os(e));
      }
      const Un = 85.051129;
      function l_(r) {
        return Math.cos(vi(si(r, -Un, Un)));
      }
      function c(r, e) {
        const n = si(e, a_, pp), o = Math.pow(2, n);
        return l_(r) * kd / (512 * o);
      }
      function t(r) {
        return 1 / Math.cos(r * Math.PI / 180);
      }
      function s(r, e = 0) {
        const n = Math.exp(Math.PI * (1 - (r.y + e / wt) / (1 << r.z) * 2));
        return 80150034 * n / (n * n + 1) / wt / (1 << r.z);
      }
      class h {
        constructor(e, n, o = 0) {
          this.x = +e, this.y = +n, this.z = +o;
        }
        static fromLngLat(e, n = 0) {
          const o = Ui.convert(e);
          return new h(ea(o.lng), wa(o.lat), fr(n, o.lat));
        }
        toLngLat() {
          return new Ui(Fr(this.x), Os(this.y));
        }
        toAltitude() {
          return mp(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / kd * t(Os(this.y));
        }
      }
      function m(r, e, n, o, u, l, d, v, M) {
        const D = (e + o) / 2, x = (n + u) / 2, E = new Mt(D, x);
        v(E), function(I, S, C, k, V, U) {
          const q = C - V, $ = k - U;
          return Math.abs((k - S) * q - (C - I) * $) / Math.hypot(q, $);
        }(E.x, E.y, l.x, l.y, d.x, d.y) >= M ? (m(r, e, n, D, x, l, E, v, M), m(r, D, x, o, u, E, d, v, M)) : r.push(d);
      }
      function g(r, e, n) {
        let o = r[0], u = o.x, l = o.y;
        e(o);
        const d = [o];
        for (let v = 1; v < r.length; v++) {
          const M = r[v], { x: D, y: x } = M;
          e(M), m(d, u, l, D, x, o, M, e, n), u = D, l = x, o = M;
        }
        return d;
      }
      function T(r, e, n, o) {
        if (o(e, n)) {
          const u = e.add(n)._mult(0.5);
          T(r, e, u, o), T(r, u, n, o);
        } else
          r.push(n);
      }
      function z(r, e) {
        let n = r[0];
        const o = [n];
        for (let u = 1; u < r.length; u++) {
          const l = r[u];
          T(o, n, l, e), n = l;
        }
        return o;
      }
      const R = Math.pow(2, 14) - 1, F = -R - 1;
      function N(r, e) {
        const n = Math.round(r.x * e), o = Math.round(r.y * e);
        return r.x = si(n, F, R), r.y = si(o, F, R), (n < r.x || n > r.x + 1 || o < r.y || o > r.y + 1) && mi("Geometry exceeds allowed extent, reduce your vector tile buffer size"), r;
      }
      function j(r, e, n) {
        const o = r.loadGeometry(), u = r.extent, l = wt / u;
        if (e && n && n.projection.isReprojectedInTileSpace) {
          const d = 1 << e.z, { scale: v, x: M, y: D, projection: x } = n, E = (I) => {
            const S = Fr((e.x + I.x / u) / d), C = Os((e.y + I.y / u) / d), k = x.project(S, C);
            I.x = (k.x * v - M) * u, I.y = (k.y * v - D) * u;
          };
          for (let I = 0; I < o.length; I++)
            if (r.type !== 1)
              o[I] = g(o[I], E, 1);
            else {
              const S = [];
              for (const C of o[I])
                C.x < 0 || C.x >= u || C.y < 0 || C.y >= u || (E(C), S.push(C));
              o[I] = S;
            }
        }
        for (const d of o)
          for (const v of d)
            N(v, l);
        return o;
      }
      function G(r, e) {
        return { type: r.type, id: r.id, properties: r.properties, geometry: e ? j(r) : [] };
      }
      function W(r, e, n, o, u) {
        r.emplaceBack(2 * e + (o + 1) / 2, 2 * n + (u + 1) / 2);
      }
      function te(r, e, n) {
        r.emplaceBack(e.x, e.y, e.z, n[0] * 16384, n[1] * 16384, n[2] * 16384);
      }
      class ee {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.projection = e.projection, this.layoutVertexArray = new Io(), this.indexArray = new qs(), this.segments = new Wn(), this.programConfigurations = new Ka(e.layers, { zoom: e.zoom, lut: e.lut }), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id);
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          const l = this.layers[0], d = [];
          let v = null;
          l.type === "circle" && (v = l.layout.get("circle-sort-key"));
          for (const { feature: D, id: x, index: E, sourceLayerIndex: I } of e) {
            const S = this.layers[0]._featureFilter.needGeometry, C = G(D, S);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), C, o))
              continue;
            const k = v ? v.evaluate(C, {}, o) : void 0, V = { id: x, properties: D.properties, type: D.type, sourceLayerIndex: I, index: E, geometry: S ? C.geometry : j(D, o, u), patterns: {}, sortKey: k };
            d.push(V);
          }
          v && d.sort((D, x) => D.sortKey - x.sortKey);
          let M = null;
          u.projection.name === "globe" && (this.globeExtVertexArray = new du(), M = u.projection);
          for (const D of d) {
            const { geometry: x, index: E, sourceLayerIndex: I } = D, S = e[E].feature;
            this.addFeature(D, x, E, n.availableImages, o, M, n.brightness), n.featureIndex.insert(S, x, E, I, this.index);
          }
        }
        update(e, n, o, u, l, d, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Qm.members), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Id.members))), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(e, n, o, u, l, d, v) {
          for (const M of n)
            for (const D of M) {
              const x = D.x, E = D.y;
              if (x < 0 || x >= wt || E < 0 || E >= wt)
                continue;
              if (d) {
                const C = d.projectTilePoint(x, E, l), k = d.upVector(l, x, E), V = this.globeExtVertexArray;
                te(V, C, k), te(V, C, k), te(V, C, k), te(V, C, k);
              }
              const I = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, e.sortKey), S = I.vertexLength;
              W(this.layoutVertexArray, x, E, -1, -1), W(this.layoutVertexArray, x, E, 1, -1), W(this.layoutVertexArray, x, E, 1, 1), W(this.layoutVertexArray, x, E, -1, 1), this.indexArray.emplaceBack(S, S + 1, S + 2), this.indexArray.emplaceBack(S, S + 2, S + 3), I.vertexLength += 4, I.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, {}, u, l, v);
        }
      }
      function se(r, e) {
        for (let n = 0; n < r.length; n++)
          if (Pe(e, r[n]))
            return !0;
        for (let n = 0; n < e.length; n++)
          if (Pe(r, e[n]))
            return !0;
        return !!pe(r, e);
      }
      function oe(r, e, n) {
        return !!Pe(r, e) || !!xe(e, r, n);
      }
      function ce(r, e) {
        if (r.length === 1)
          return ve(e, r[0]);
        for (let n = 0; n < e.length; n++) {
          const o = e[n];
          for (let u = 0; u < o.length; u++)
            if (Pe(r, o[u]))
              return !0;
        }
        for (let n = 0; n < r.length; n++)
          if (ve(e, r[n]))
            return !0;
        for (let n = 0; n < e.length; n++)
          if (pe(r, e[n]))
            return !0;
        return !1;
      }
      function _e(r, e, n) {
        if (r.length > 1) {
          if (pe(r, e))
            return !0;
          for (let o = 0; o < e.length; o++)
            if (xe(e[o], r, n))
              return !0;
        }
        for (let o = 0; o < r.length; o++)
          if (xe(r[o], e, n))
            return !0;
        return !1;
      }
      function pe(r, e) {
        if (r.length === 0 || e.length === 0)
          return !1;
        for (let n = 0; n < r.length - 1; n++) {
          const o = r[n], u = r[n + 1];
          for (let l = 0; l < e.length - 1; l++)
            if (Te(o, u, e[l], e[l + 1]))
              return !0;
        }
        return !1;
      }
      function Te(r, e, n, o) {
        return On(r, n, o) !== On(e, n, o) && On(r, e, n) !== On(r, e, o);
      }
      function xe(r, e, n) {
        const o = n * n;
        if (e.length === 1)
          return r.distSqr(e[0]) < o;
        for (let u = 1; u < e.length; u++)
          if (be(r, e[u - 1], e[u]) < o)
            return !0;
        return !1;
      }
      function be(r, e, n) {
        const o = e.distSqr(n);
        if (o === 0)
          return r.distSqr(e);
        const u = ((r.x - e.x) * (n.x - e.x) + (r.y - e.y) * (n.y - e.y)) / o;
        return r.distSqr(u < 0 ? e : u > 1 ? n : n.sub(e)._mult(u)._add(e));
      }
      function ve(r, e) {
        let n, o, u, l = !1;
        for (let d = 0; d < r.length; d++) {
          n = r[d];
          for (let v = 0, M = n.length - 1; v < n.length; M = v++)
            o = n[v], u = n[M], o.y > e.y != u.y > e.y && e.x < (u.x - o.x) * (e.y - o.y) / (u.y - o.y) + o.x && (l = !l);
        }
        return l;
      }
      function Pe(r, e) {
        let n = !1;
        for (let o = 0, u = r.length - 1; o < r.length; u = o++) {
          const l = r[o], d = r[u];
          l.y > e.y != d.y > e.y && e.x < (d.x - l.x) * (e.y - l.y) / (d.y - l.y) + l.x && (n = !n);
        }
        return n;
      }
      function Oe(r, e, n, o, u) {
        for (const d of r)
          if (e <= d.x && n <= d.y && o >= d.x && u >= d.y)
            return !0;
        const l = [new Mt(e, n), new Mt(e, u), new Mt(o, u), new Mt(o, n)];
        if (r.length > 2) {
          for (const d of l)
            if (Pe(r, d))
              return !0;
        }
        for (let d = 0; d < r.length - 1; d++)
          if (Xe(r[d], r[d + 1], l))
            return !0;
        return !1;
      }
      function Xe(r, e, n) {
        const o = n[0], u = n[2];
        if (r.x < o.x && e.x < o.x || r.x > u.x && e.x > u.x || r.y < o.y && e.y < o.y || r.y > u.y && e.y > u.y)
          return !1;
        const l = On(r, e, n[0]);
        return l !== On(r, e, n[1]) || l !== On(r, e, n[2]) || l !== On(r, e, n[3]);
      }
      function Ze(r, e, n, o, u, l) {
        let d = e.y - r.y, v = r.x - e.x;
        if (l = l || 0) {
          const M = d * d + v * v;
          if (M === 0)
            return !0;
          const D = Math.sqrt(M);
          d /= D, v /= D;
        }
        return !((n.x - r.x) * d + (n.y - r.y) * v - l < 0 || (o.x - r.x) * d + (o.y - r.y) * v - l < 0 || (u.x - r.x) * d + (u.y - r.y) * v - l < 0);
      }
      function ke(r, e, n, o, u, l, d) {
        return !(Ze(r, e, o, u, l, d) || Ze(e, n, o, u, l, d) || Ze(n, r, o, u, l, d) || Ze(o, u, r, e, n, d) || Ze(u, l, r, e, n, d) || Ze(l, o, r, e, n, d));
      }
      function Ne(r, e, n) {
        const o = e.paint.get(r).value;
        return o.kind === "constant" ? o.value : n.programConfigurations.get(e.id).getMaxValue(r);
      }
      function st(r) {
        return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
      }
      function ht(r, e, n, o, u) {
        if (!e[0] && !e[1])
          return r;
        const l = Mt.convert(e)._mult(u);
        n === "viewport" && l._rotate(-o);
        const d = [];
        for (let v = 0; v < r.length; v++)
          d.push(r[v].sub(l));
        return d;
      }
      function yt(r, e, n, o) {
        const u = Mt.convert(r)._mult(o);
        return e === "viewport" && u._rotate(-n), u;
      }
      let je, at;
      Ft(ee, "CircleBucket", { omit: ["layers"] });
      var Je, _t = { exports: {} }, ct = (Je || (Je = 1, function(r, e) {
        (function(n) {
          function o(l, d, v) {
            var M = u(256 * l, 256 * (d = Math.pow(2, v) - d - 1), v), D = u(256 * (l + 1), 256 * (d + 1), v);
            return M[0] + "," + M[1] + "," + D[0] + "," + D[1];
          }
          function u(l, d, v) {
            var M = 2 * Math.PI * 6378137 / 256 / Math.pow(2, v);
            return [l * M - 2 * Math.PI * 6378137 / 2, d * M - 2 * Math.PI * 6378137 / 2];
          }
          n.getURL = function(l, d, v, M, D, x) {
            return x = x || {}, l + "?" + ["bbox=" + o(v, M, D), "format=" + (x.format || "image/png"), "service=" + (x.service || "WMS"), "version=" + (x.version || "1.1.1"), "request=" + (x.request || "GetMap"), "srs=" + (x.srs || "EPSG:3857"), "width=" + (x.width || 256), "height=" + (x.height || 256), "layers=" + d].join("&");
          }, n.getTileBBox = o, n.getMercCoords = u, Object.defineProperty(n, "__esModule", { value: !0 });
        })(e);
      }(0, _t.exports)), _t.exports);
      class nt {
        constructor(e, n, o) {
          this.z = e, this.x = n, this.y = o, this.key = zt(0, e, e, n, o);
        }
        equals(e) {
          return this.z === e.z && this.x === e.x && this.y === e.y;
        }
        url(e, n) {
          const o = ct.getTileBBox(this.x, this.y, this.z), u = function(l, d, v) {
            let M, D = "";
            for (let x = l; x > 0; x--)
              M = 1 << x - 1, D += (d & M ? 1 : 0) + (v & M ? 2 : 0);
            return D;
          }(this.z, this.x, this.y);
          return e[(this.x + this.y) % e.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(n === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u).replace("{bbox-epsg-3857}", o);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Lt {
        constructor(e, n) {
          this.wrap = e, this.canonical = n, this.key = zt(e, n.z, n.z, n.x, n.y);
        }
      }
      class xt {
        constructor(e, n, o, u, l) {
          this.overscaledZ = e, this.wrap = n, this.canonical = new nt(o, +u, +l), this.key = n === 0 && e === o ? this.canonical.key : zt(n, e, o, u, l);
        }
        equals(e) {
          return this.overscaledZ === e.overscaledZ && this.wrap === e.wrap && this.canonical.equals(e.canonical);
        }
        scaledTo(e) {
          const n = this.canonical.z - e;
          return e > this.canonical.z ? new xt(e, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new xt(e, this.wrap, e, this.canonical.x >> n, this.canonical.y >> n);
        }
        calculateScaledKey(e, n = !0) {
          if (this.overscaledZ === e && n)
            return this.key;
          if (e > this.canonical.z)
            return zt(this.wrap * +n, e, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const o = this.canonical.z - e;
            return zt(this.wrap * +n, e, e, this.canonical.x >> o, this.canonical.y >> o);
          }
        }
        isChildOf(e) {
          if (e.wrap !== this.wrap)
            return !1;
          const n = this.canonical.z - e.canonical.z;
          return e.overscaledZ === 0 || e.overscaledZ < this.overscaledZ && e.canonical.z < this.canonical.z && e.canonical.x === this.canonical.x >> n && e.canonical.y === this.canonical.y >> n;
        }
        children(e) {
          if (this.overscaledZ >= e)
            return [new xt(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const n = this.canonical.z + 1, o = 2 * this.canonical.x, u = 2 * this.canonical.y;
          return [new xt(n, this.wrap, n, o, u), new xt(n, this.wrap, n, o + 1, u), new xt(n, this.wrap, n, o, u + 1), new xt(n, this.wrap, n, o + 1, u + 1)];
        }
        isLessThan(e) {
          return this.wrap < e.wrap || !(this.wrap > e.wrap) && (this.overscaledZ < e.overscaledZ || !(this.overscaledZ > e.overscaledZ) && (this.canonical.x < e.canonical.x || !(this.canonical.x > e.canonical.x) && this.canonical.y < e.canonical.y));
        }
        wrapped() {
          return new xt(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(e) {
          return new xt(this.overscaledZ, e, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Lt(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function zt(r, e, n, o, u) {
        const l = 1 << Math.min(n, 22);
        let d = l * (u % l) + o % l;
        return r && n < 22 && (d += l * l * ((r < 0 ? -2 * r - 1 : 2 * r) % (1 << 2 * (22 - n)))), 16 * (32 * d + n) + (e - n);
      }
      const Bt = [(r) => {
        let e = r.canonical.x - 1, n = r.wrap;
        return e < 0 && (e = (1 << r.canonical.z) - 1, n--), new xt(r.overscaledZ, n, r.canonical.z, e, r.canonical.y);
      }, (r) => {
        let e = r.canonical.x + 1, n = r.wrap;
        return e === 1 << r.canonical.z && (e = 0, n++), new xt(r.overscaledZ, n, r.canonical.z, e, r.canonical.y);
      }, (r) => new xt(r.overscaledZ, r.wrap, r.canonical.z, r.canonical.x, (r.canonical.y === 0 ? 1 << r.canonical.z : r.canonical.y) - 1), (r) => new xt(r.overscaledZ, r.wrap, r.canonical.z, r.canonical.x, r.canonical.y === (1 << r.canonical.z) - 1 ? 0 : r.canonical.y + 1)];
      Ft(nt, "CanonicalTileID"), Ft(xt, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
      const oi = qi([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: $t } = oi, Xt = qi([{ name: "a_pos_3", components: 3, type: "Int16" }]);
      var ai = qi([{ name: "a_pos", type: "Int16", components: 2 }]);
      class zi {
        constructor(e, n) {
          this.pos = e, this.dir = n;
        }
        intersectsPlane(e, n, o) {
          const u = De.vec3.dot(n, this.dir);
          if (Math.abs(u) < 1e-6)
            return !1;
          const l = ((e[0] - this.pos[0]) * n[0] + (e[1] - this.pos[1]) * n[1] + (e[2] - this.pos[2]) * n[2]) / u;
          return o[0] = this.pos[0] + this.dir[0] * l, o[1] = this.pos[1] + this.dir[1] * l, o[2] = this.pos[2] + this.dir[2] * l, !0;
        }
        closestPointOnSphere(e, n, o) {
          if (De.vec3.equals(this.pos, e) || n === 0)
            return o[0] = o[1] = o[2] = 0, !1;
          const [u, l, d] = this.dir, v = this.pos[0] - e[0], M = this.pos[1] - e[1], D = this.pos[2] - e[2], x = u * u + l * l + d * d, E = 2 * (v * u + M * l + D * d), I = E * E - 4 * x * (v * v + M * M + D * D - n * n);
          if (I < 0) {
            const S = Math.max(-E / 2, 0), C = v + u * S, k = M + l * S, V = D + d * S, U = Math.hypot(C, k, V);
            return o[0] = C * n / U, o[1] = k * n / U, o[2] = V * n / U, !1;
          }
          {
            const S = (-E - Math.sqrt(I)) / (2 * x);
            if (S < 0) {
              const C = Math.hypot(v, M, D);
              return o[0] = v * n / C, o[1] = M * n / C, o[2] = D * n / C, !1;
            }
            return o[0] = v + u * S, o[1] = M + l * S, o[2] = D + d * S, !0;
          }
        }
      }
      class wi {
        constructor(e, n, o, u, l) {
          this.TL = e, this.TR = n, this.BR = o, this.BL = u, this.horizon = l;
        }
        static fromInvProjectionMatrix(e, n, o) {
          const u = [-1, 1, 1], l = [1, 1, 1], d = [1, -1, 1], v = [-1, -1, 1], M = De.vec3.transformMat4(u, u, e), D = De.vec3.transformMat4(l, l, e), x = De.vec3.transformMat4(d, d, e), E = De.vec3.transformMat4(v, v, e);
          return new wi(M, D, x, E, n / o);
        }
      }
      function mn(r, e, n) {
        let o = 1 / 0, u = -1 / 0;
        const l = [];
        for (const d of r) {
          De.vec3.sub(l, d, e);
          const v = De.vec3.dot(l, n);
          o = Math.min(o, v), u = Math.max(u, v);
        }
        return [o, u];
      }
      function Sn(r, e) {
        let n = !0;
        for (let o = 0; o < r.planes.length; o++) {
          const u = r.planes[o];
          let l = 0;
          for (let d = 0; d < e.length; d++)
            l += De.vec3.dot(u, e[d]) + u[3] >= 0;
          if (l === 0)
            return 0;
          l !== e.length && (n = !1);
        }
        return n ? 2 : 1;
      }
      function Xi(r, e) {
        for (const n of r.projections) {
          const o = mn(e, r.points[0], n.axis);
          if (n.projection[1] < o[0] || n.projection[0] > o[1])
            return 0;
        }
        return 1;
      }
      function sn(r, e) {
        let n = 0;
        const o = [0, 0, 0, 0];
        for (let u = 0; u < r.length; u++)
          o[0] = r[u][0], o[1] = r[u][1], o[2] = r[u][2], o[3] = 1, De.vec4.dot(o, e) >= 0 && n++;
        return n;
      }
      class _i {
        constructor(e, n) {
          this.points = e || new Array(8).fill([0, 0, 0]), this.planes = n || new Array(6).fill([0, 0, 0, 0]), this.bounds = Jt.fromPoints(this.points), this.projections = [], this.frustumEdges = [De.vec3.sub([], this.points[2], this.points[3]), De.vec3.sub([], this.points[0], this.points[3]), De.vec3.sub([], this.points[4], this.points[0]), De.vec3.sub([], this.points[5], this.points[1]), De.vec3.sub([], this.points[6], this.points[2]), De.vec3.sub([], this.points[7], this.points[3])];
          for (const o of this.frustumEdges) {
            const u = [0, -o[2], o[1]], l = [o[2], 0, -o[0]];
            this.projections.push({ axis: u, projection: mn(this.points, this.points[0], u) }), this.projections.push({ axis: l, projection: mn(this.points, this.points[0], l) });
          }
        }
        static fromInvProjectionMatrix(e, n, o, u) {
          const l = Math.pow(2, o), d = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((D) => {
            const x = De.vec4.transformMat4([], D, e), E = 1 / x[3] / n * l;
            return De.vec4.mul(x, x, [E, E, u ? 1 / x[3] : E, E]);
          }), v = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((D) => {
            const x = De.vec3.sub([], d[D[0]], d[D[1]]), E = De.vec3.sub([], d[D[2]], d[D[1]]), I = De.vec3.normalize([], De.vec3.cross([], x, E)), S = -De.vec3.dot(I, d[D[1]]);
            return I.concat(S);
          }), M = [];
          for (let D = 0; D < d.length; D++)
            M.push([d[D][0], d[D][1], d[D][2]]);
          return new _i(M, v);
        }
        intersectsPrecise(e, n, o) {
          for (let u = 0; u < n.length; u++)
            if (!sn(e, n[u]))
              return 0;
          for (let u = 0; u < this.planes.length; u++)
            if (!sn(e, this.planes[u]))
              return 0;
          for (const u of o)
            for (const l of this.frustumEdges) {
              const d = De.vec3.cross([], u, l), v = De.vec3.length(d);
              if (v === 0)
                continue;
              De.vec3.scale(d, d, 1 / v);
              const M = mn(this.points, this.points[0], d), D = mn(e, this.points[0], d);
              if (M[0] > D[1] || D[0] > M[1])
                return 0;
            }
          return 1;
        }
        containsPoint(e) {
          for (const n of this.planes) {
            const o = n[3];
            if (De.vec3.dot([n[0], n[1], n[2]], e) + o < 0)
              return !1;
          }
          return !0;
        }
      }
      class Jt {
        static fromPoints(e) {
          const n = [1 / 0, 1 / 0, 1 / 0], o = [-1 / 0, -1 / 0, -1 / 0];
          for (const u of e)
            De.vec3.min(n, n, u), De.vec3.max(o, o, u);
          return new Jt(n, o);
        }
        static fromTileIdAndHeight(e, n, o) {
          const u = 1 << e.canonical.z, l = e.canonical.x, d = e.canonical.y;
          return new Jt([l / u, d / u, n], [(l + 1) / u, (d + 1) / u, o]);
        }
        static applyTransform(e, n) {
          const o = e.getCorners();
          for (let u = 0; u < o.length; ++u)
            De.vec3.transformMat4(o[u], o[u], n);
          return Jt.fromPoints(o);
        }
        static applyTransformFast(e, n) {
          const o = [n[12], n[13], n[14]], u = [...o];
          for (let l = 0; l < 3; l++)
            for (let d = 0; d < 3; d++) {
              const v = n[4 * d + l], M = v * e.min[d], D = v * e.max[d];
              o[l] += Math.min(M, D), u[l] += Math.max(M, D);
            }
          return new Jt(o, u);
        }
        static projectAabbCorners(e, n) {
          const o = e.getCorners();
          for (let u = 0; u < o.length; ++u)
            De.vec3.transformMat4(o[u], o[u], n);
          return o;
        }
        constructor(e, n) {
          this.min = e, this.max = n, this.center = De.vec3.scale([], De.vec3.add([], this.min, this.max), 0.5);
        }
        quadrant(e) {
          const n = [e % 2 == 0, e < 2], o = De.vec3.clone(this.min), u = De.vec3.clone(this.max);
          for (let l = 0; l < n.length; l++)
            o[l] = n[l] ? this.min[l] : this.center[l], u[l] = n[l] ? this.center[l] : this.max[l];
          return u[2] = this.max[2], new Jt(o, u);
        }
        distanceX(e) {
          return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0];
        }
        distanceY(e) {
          return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1];
        }
        distanceZ(e) {
          return Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2];
        }
        getCorners() {
          const e = this.min, n = this.max;
          return [[e[0], e[1], e[2]], [n[0], e[1], e[2]], [n[0], n[1], e[2]], [e[0], n[1], e[2]], [e[0], e[1], n[2]], [n[0], e[1], n[2]], [n[0], n[1], n[2]], [e[0], n[1], n[2]]];
        }
        intersects(e) {
          return this.intersectsAabb(e.bounds) ? Sn(e, this.getCorners()) : 0;
        }
        intersectsFlat(e) {
          return this.intersectsAabb(e.bounds) ? Sn(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsPrecise(e, n) {
          return n || this.intersects(e) ? Xi(e, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(e, n) {
          return n || this.intersectsFlat(e) ? Xi(e, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
        }
        intersectsAabb(e) {
          for (let n = 0; n < 3; ++n)
            if (this.min[n] > e.max[n] || e.min[n] > this.max[n])
              return !1;
          return !0;
        }
        intersectsAabbXY(e) {
          return !(this.min[0] > e.max[0] || e.min[0] > this.max[0] || this.min[1] > e.max[1] || e.min[1] > this.max[1]);
        }
        encapsulate(e) {
          for (let n = 0; n < 3; n++)
            this.min[n] = Math.min(this.min[n], e.min[n]), this.max[n] = Math.max(this.max[n], e.max[n]);
        }
        encapsulatePoint(e) {
          for (let n = 0; n < 3; n++)
            this.min[n] = Math.min(this.min[n], e[n]), this.max[n] = Math.max(this.max[n], e[n]);
        }
        closestPoint(e) {
          return [Math.max(Math.min(this.max[0], e[0]), this.min[0]), Math.max(Math.min(this.max[1], e[1]), this.min[1]), Math.max(Math.min(this.max[2], e[2]), this.min[2])];
        }
      }
      function ji(r) {
        return r * dr / pc;
      }
      Ft(Jt, "Aabb");
      const Yi = [new Jt([uo, uo, uo], [fo, fo, fo]), new Jt([uo, uo, uo], [0, 0, fo]), new Jt([0, uo, uo], [fo, 0, fo]), new Jt([uo, 0, uo], [0, fo, fo]), new Jt([0, 0, uo], [fo, fo, fo])];
      function In(r, e, n, o = !0) {
        const u = De.vec3.scale([], r._camera.position, r.worldSize), l = [e, n, 1, 1];
        De.vec4.transformMat4(l, l, r.pixelMatrixInverse), De.vec4.scale(l, l, 1 / l[3]);
        const d = De.vec3.sub([], l, u), v = De.vec3.normalize([], d), M = r.globeMatrix, D = [M[12], M[13], M[14]], x = De.vec3.sub([], D, u), E = De.vec3.length(x), I = De.vec3.normalize([], x), S = r.worldSize / (2 * Math.PI), C = De.vec3.dot(I, v), k = Math.asin(S / E);
        if (k < Math.acos(C)) {
          if (!o)
            return null;
          const Me = [], me = [];
          De.vec3.scale(Me, v, E / C), De.vec3.normalize(me, De.vec3.sub(me, Me, x)), De.vec3.normalize(v, De.vec3.add(v, x, De.vec3.scale(v, me, Math.tan(k) * E)));
        }
        const V = [];
        new zi(u, v).closestPointOnSphere(D, S, V);
        const U = De.vec3.normalize([], zs(M, 0)), q = De.vec3.normalize([], zs(M, 1)), $ = De.vec3.normalize([], zs(M, 2)), H = De.vec3.dot(U, V), K = De.vec3.dot(q, V), Q = De.vec3.dot($, V), ie = kn(Math.asin(-K / S));
        let fe = kn(Math.atan2(H, Q));
        fe = r.center.lng + function(Me, me) {
          const Ee = (me - Me + 180) % 360 - 180;
          return Ee < -180 ? Ee + 360 : Ee;
        }(r.center.lng, fe);
        const de = ea(fe), he = si(wa(ie), 0, 1);
        return new h(de, he);
      }
      class Fs {
        constructor(e, n, o) {
          this.a = De.vec3.sub([], e, o), this.b = De.vec3.sub([], n, o), this.center = o;
          const u = De.vec3.normalize([], this.a), l = De.vec3.normalize([], this.b);
          this.angle = Math.acos(De.vec3.dot(u, l));
        }
      }
      function pr(r, e) {
        if (r.angle === 0)
          return null;
        let n;
        return n = r.a[e] === 0 ? 1 / r.angle * 0.5 * Math.PI : 1 / r.angle * Math.atan(r.b[e] / r.a[e] / Math.sin(r.angle) - 1 / Math.tan(r.angle)), n < 0 || n > 1 ? null : function(o, u, l, d) {
          const v = Math.sin(l);
          return o * (Math.sin((1 - d) * l) / v) + u * (Math.sin(d * l) / v);
        }(r.a[e], r.b[e], r.angle, si(n, 0, 1)) + r.center[e];
      }
      function ts(r) {
        if (r.z <= 1)
          return Yi[r.z + 2 * r.y + r.x];
        const e = _n(dn(r));
        return Jt.fromPoints(e);
      }
      function As(r, e, n) {
        return De.vec3.scale(r, r, 1 - n), De.vec3.scaleAndAdd(r, r, e, n);
      }
      function Js(r, e, n) {
        for (const o of r)
          De.vec3.transformMat4(o, o, e), De.vec3.scale(o, o, n);
      }
      function jn(r, e, n, o) {
        const u = e / r.worldSize, l = r.globeMatrix;
        if (n.z <= 1) {
          const de = ts(n).getCorners();
          return Js(de, l, u), Jt.fromPoints(de);
        }
        const d = dn(n, o), v = _n(d, dr + ji(r._tileCoverLift));
        Js(v, l, u);
        const M = Number.MAX_VALUE, D = [-M, -M, -M], x = [M, M, M];
        if (d.contains(r.center)) {
          for (const Me of v)
            De.vec3.min(x, x, Me), De.vec3.max(D, D, Me);
          D[2] = 0;
          const de = r.point, he = [de.x * u, de.y * u, 0];
          return De.vec3.min(x, x, he), De.vec3.max(D, D, he), new Jt(x, D);
        }
        if (r._tileCoverLift > 0) {
          for (const de of v)
            De.vec3.min(x, x, de), De.vec3.max(D, D, de);
          return new Jt(x, D);
        }
        const E = [l[12] * u, l[13] * u, l[14] * u], I = d.getCenter(), S = si(r.center.lat, -Un, Un), C = si(I.lat, -Un, Un), k = ea(r.center.lng), V = wa(S);
        let U = k - ea(I.lng);
        const q = V - wa(C);
        U > 0.5 ? U -= 1 : U < -0.5 && (U += 1);
        let $ = 0;
        if (Math.abs(U) > Math.abs(q))
          $ = U >= 0 ? 1 : 3;
        else {
          $ = q >= 0 ? 0 : 2;
          const de = [l[4] * u, l[5] * u, l[6] * u], he = -Math.sin(vi(q >= 0 ? d.getSouth() : d.getNorth())) * dr;
          De.vec3.scaleAndAdd(E, E, de, he);
        }
        const H = v[$], K = v[($ + 1) % 4], Q = new Fs(H, K, E), ie = [pr(Q, 0) || H[0], pr(Q, 1) || H[1], pr(Q, 2) || H[2]], fe = mr(r.zoom);
        if (fe > 0) {
          const de = function({ x: Me, y: me, z: Ee }, ze, Ie, Re, Ve) {
            const Ue = 1 / (1 << Ee);
            let Fe = Me * Ue, et = Fe + Ue, dt = me * Ue, tt = dt + Ue, Tt = 0;
            const vt = (Fe + et) / 2 - Re;
            return vt > 0.5 ? Tt = -1 : vt < -0.5 && (Tt = 1), Fe = ((Fe + Tt) * ze - (Re *= ze)) * Ie + Re, et = ((et + Tt) * ze - Re) * Ie + Re, dt = (dt * ze - (Ve *= ze)) * Ie + Ve, tt = (tt * ze - Ve) * Ie + Ve, [[Fe, tt, 0], [et, tt, 0], [et, dt, 0], [Fe, dt, 0]];
          }(n, e, r._pixelsPerMercatorPixel, k, V);
          for (let Me = 0; Me < v.length; Me++)
            As(v[Me], de[Me], fe);
          const he = De.vec3.add([], de[$], de[($ + 1) % 4]);
          De.vec3.scale(he, he, 0.5), As(ie, he, fe);
        }
        for (const de of v)
          De.vec3.min(x, x, de), De.vec3.max(D, D, de);
        return x[2] = Math.min(H[2], K[2]), De.vec3.min(x, x, ie), De.vec3.max(D, D, ie), new Jt(x, D);
      }
      function dn({ x: r, y: e, z: n }, o = !1) {
        const u = 1 / (1 << n), l = new Ui(Fr(r * u), e === (1 << n) - 1 && o ? -90 : Os((e + 1) * u)), d = new Ui(Fr((r + 1) * u), e === 0 && o ? 90 : Os(e * u));
        return new Qa(l, d);
      }
      function _n(r, e = dr) {
        const n = vi(r.getNorth()), o = vi(r.getSouth()), u = Math.cos(n), l = Math.cos(o), d = Math.sin(n), v = Math.sin(o), M = r.getWest(), D = r.getEast();
        return [fc(l, v, M, e), fc(l, v, D, e), fc(u, d, D, e), fc(u, d, M, e)];
      }
      function Ri(r, e, n, o) {
        const u = 1 << n.z, l = (r / wt + n.x) / u;
        return Ja(Os((e / wt + n.y) / u), Fr(l), o);
      }
      function Gn({ min: r, max: e }) {
        return fp / Math.max(e[0] - r[0], e[1] - r[1], e[2] - r[2]);
      }
      const Bs = new Float64Array(16);
      function cn(r) {
        const e = Gn(r), n = De.mat4.fromScaling(Bs, [e, e, e]);
        return De.mat4.translate(n, n, De.vec3.negate([], r.min));
      }
      function Qs(r) {
        const e = De.mat4.fromTranslation(Bs, r.min), n = 1 / Gn(r);
        return De.mat4.scale(e, e, [n, n, n]);
      }
      function eo(r) {
        const e = wt / (2 * Math.PI);
        return r / (2 * Math.PI) / e;
      }
      function Br(r, e) {
        return wt / (512 * Math.pow(2, r)) * Gn(ts(e));
      }
      function Ta(r, e, n, o, u) {
        const l = eo(n), d = [r, e, -n / (2 * Math.PI)], v = De.mat4.identity(new Float64Array(16));
        return De.mat4.translate(v, v, d), De.mat4.scale(v, v, [l, l, l]), De.mat4.rotateX(v, v, vi(-u)), De.mat4.rotateY(v, v, vi(-o)), v;
      }
      function mr(r) {
        return fs(Tu, dp, r);
      }
      function Do(r, e) {
        const n = Ja(e.lat, e.lng), o = function(l) {
          const d = Ja(l._center.lat, l._center.lng), v = De.vec3.fromValues(0, 1, 0);
          let M = De.vec3.cross([], v, d);
          const D = De.mat4.fromRotation([], -l.angle, d);
          M = De.vec3.transformMat4(M, M, D), De.mat4.fromRotation(D, -l._pitch, M);
          const x = De.vec3.normalize([], d);
          return De.vec3.scale(x, x, ji(l.cameraToCenterDistance / l.pixelsPerMeter)), De.vec3.transformMat4(x, x, D), De.vec3.add([], d, x);
        }(r), u = De.vec3.subtract([], o, n);
        return De.vec3.angle(u, n);
      }
      function Nr(r, e) {
        return Do(r, e) > Math.PI / 2 * 1.01;
      }
      const el = vi(85), ta = Math.cos(el), Cl = Math.sin(el), mh = De.mat4.create(), Mu = (r) => {
        const e = [];
        return r.paint.get("circle-pitch-alignment") === "map" && e.push("PITCH_WITH_MAP"), r.paint.get("circle-pitch-scale") === "map" && e.push("SCALE_WITH_MAP"), e;
      };
      function Eu(r, e, n, o, u, l, d, v, M) {
        if (l && r.queryGeometry.isAboveHorizon)
          return !1;
        l && (M *= r.pixelToTileUnitsFactor);
        const D = r.tileID.canonical, x = n.projection.upVectorScale(D, n.center.lat, n.worldSize).metersToTile;
        for (const E of e)
          for (const I of E) {
            const S = I.add(v), C = u && n.elevation ? n.elevation.exaggeration() * u.getElevationAt(S.x, S.y, !0) : 0, k = n.projection.projectTilePoint(S.x, S.y, D);
            if (C > 0) {
              const $ = n.projection.upVector(D, S.x, S.y);
              k.x += $[0] * x * C, k.y += $[1] * x * C, k.z += $[2] * x * C;
            }
            const V = l ? S : hw(k.x, k.y, k.z, o), U = l ? r.tilespaceRays.map(($) => dw($, C)) : r.queryGeometry.screenGeometry, q = De.vec4.transformMat4([], [k.x, k.y, k.z, 1], o);
            if (!d && l ? M *= q[3] / n.cameraToCenterDistance : d && !l && (M *= n.cameraToCenterDistance / q[3]), l) {
              const $ = Os((I.y / wt + D.y) / (1 << D.z));
              M /= n.projection.pixelsPerMeter($, 1) / fr(1, $);
            }
            if (oe(U, V, M))
              return !0;
          }
        return !1;
      }
      function hw(r, e, n, o) {
        const u = De.vec4.transformMat4([], [r, e, n, 1], o);
        return new Mt(u[0] / u[3], u[1] / u[3]);
      }
      const _y = De.vec3.fromValues(0, 0, 0), uw = De.vec3.fromValues(0, 0, 1);
      function dw(r, e) {
        const n = De.vec3.create();
        return _y[2] = e, r.intersectsPlane(_y, uw, n), new Mt(n[0], n[1]);
      }
      class gy extends ee {
      }
      let yy, xy, vy, by;
      function wy(r, { width: e, height: n }, o, u) {
        if (u) {
          if (u instanceof Uint8ClampedArray)
            u = new Uint8Array(u.buffer);
          else if (u.length !== e * n * o)
            throw new RangeError("mismatched image size");
        } else
          u = new Uint8Array(e * n * o);
        return r.width = e, r.height = n, r.data = u, r;
      }
      function Ty(r, e, n) {
        const { width: o, height: u } = e;
        o === r.width && u === r.height || (c_(r, e, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(r.width, o), height: Math.min(r.height, u) }, n, null), r.width = o, r.height = u, r.data = e.data);
      }
      function c_(r, e, n, o, u, l, d, v) {
        if (u.width === 0 || u.height === 0)
          return e;
        if (u.width > r.width || u.height > r.height || n.x > r.width - u.width || n.y > r.height - u.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (u.width > e.width || u.height > e.height || o.x > e.width - u.width || o.y > e.height - u.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const M = r.data, D = e.data, x = l === 4 && v;
        for (let E = 0; E < u.height; E++) {
          const I = ((n.y + E) * r.width + n.x) * l, S = ((o.y + E) * e.width + o.x) * l;
          if (x)
            for (let C = 0; C < u.width; C++) {
              const k = I + C * l + 3, V = S + C * l;
              D[V + 0] = 255, D[V + 1] = 255, D[V + 2] = 255, D[V + 3] = M[k];
            }
          else if (d)
            for (let C = 0; C < u.width; C++) {
              const k = I + C * l, V = S + C * l, U = M[k + 3], q = new ki(M[k + 0] / 255 * U, M[k + 1] / 255 * U, M[k + 2] / 255 * U, U).toRenderColor(d).toArray();
              D[V + 0] = q[0], D[V + 1] = q[1], D[V + 2] = q[2], D[V + 3] = q[3];
            }
          else
            for (let C = 0; C < u.width * l; C++)
              D[S + C] = M[I + C];
        }
        return e;
      }
      Ft(gy, "HeatmapBucket", { omit: ["layers"] });
      class mc {
        constructor(e, n) {
          wy(this, e, 1, n);
        }
        resize(e) {
          Ty(this, new mc(e), 1);
        }
        clone() {
          return new mc({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, l) {
          c_(e, n, o, u, l, 1, null);
        }
      }
      class _r {
        constructor(e, n) {
          wy(this, e, 4, n);
        }
        resize(e) {
          Ty(this, new _r(e), 4);
        }
        replace(e, n) {
          n ? this.data.set(e) : this.data = e instanceof Uint8ClampedArray ? new Uint8Array(e.buffer) : e;
        }
        clone() {
          return new _r({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(e, n, o, u, l, d, v) {
          c_(e, n, o, u, l, 4, d, v);
        }
      }
      class Sy {
        constructor(e, n) {
          this.width = e.width, this.height = e.height, this.data = n instanceof Uint8Array ? new Float32Array(n.buffer) : n;
        }
      }
      function Rd(r) {
        const e = {}, n = r.resolution || 256, o = r.clips ? r.clips.length : 1, u = r.image || new _r({ width: n, height: o }), l = (d, v, M) => {
          e[r.evaluationKey] = M;
          const D = r.expression.evaluate(e);
          D && (u.data[d + v + 0] = Math.floor(255 * D.r / D.a), u.data[d + v + 1] = Math.floor(255 * D.g / D.a), u.data[d + v + 2] = Math.floor(255 * D.b / D.a), u.data[d + v + 3] = Math.floor(255 * D.a));
        };
        if (r.clips)
          for (let d = 0, v = 0; d < o; ++d, v += 4 * n)
            for (let M = 0, D = 0; M < n; M++, D += 4) {
              const x = M / (n - 1), { start: E, end: I } = r.clips[d];
              l(v, D, E * (1 - x) + I * x);
            }
        else
          for (let d = 0, v = 0; d < n; d++, v += 4)
            l(0, v, d / (n - 1));
        return u;
      }
      Ft(mc, "AlphaImage"), Ft(_r, "RGBAImage");
      const fw = qi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: pw } = fw;
      function Od(r, e, n = 2) {
        const o = e && e.length, u = o ? e[0] * n : r.length;
        let l = My(r, 0, u, n, !0);
        const d = [];
        if (!l || l.next === l.prev)
          return d;
        let v, M, D;
        if (o && (l = function(x, E, I, S) {
          const C = [];
          for (let k = 0, V = E.length; k < V; k++) {
            const U = My(x, E[k] * S, k < V - 1 ? E[k + 1] * S : x.length, S, !1);
            U === U.next && (U.steiner = !0), C.push(ww(U));
          }
          C.sort(xw);
          for (let k = 0; k < C.length; k++)
            I = vw(C[k], I);
          return I;
        }(r, e, l, n)), r.length > 80 * n) {
          v = 1 / 0, M = 1 / 0;
          let x = -1 / 0, E = -1 / 0;
          for (let I = n; I < u; I += n) {
            const S = r[I], C = r[I + 1];
            S < v && (v = S), C < M && (M = C), S > x && (x = S), C > E && (E = C);
          }
          D = Math.max(x - v, E - M), D = D !== 0 ? 32767 / D : 0;
        }
        return Fd(l, d, n, v, M, D, 0), d;
      }
      function My(r, e, n, o, u) {
        let l;
        if (u === function(d, v, M, D) {
          let x = 0;
          for (let E = v, I = M - D; E < M; E += D)
            x += (d[I] - d[E]) * (d[E + 1] + d[I + 1]), I = E;
          return x;
        }(r, e, n, o) > 0)
          for (let d = e; d < n; d += o)
            l = Py(d / o | 0, r[d], r[d + 1], l);
        else
          for (let d = n - o; d >= e; d -= o)
            l = Py(d / o | 0, r[d], r[d + 1], l);
        return l && _p(l, l.next) && (Nd(l), l = l.next), l;
      }
      function _h(r, e) {
        if (!r)
          return r;
        e || (e = r);
        let n, o = r;
        do
          if (n = !1, o.steiner || !_p(o, o.next) && Ts(o.prev, o, o.next) !== 0)
            o = o.next;
          else {
            if (Nd(o), o = e = o.prev, o === o.next)
              break;
            n = !0;
          }
        while (n || o !== e);
        return e;
      }
      function Fd(r, e, n, o, u, l, d) {
        if (!r)
          return;
        !d && l && function(M, D, x, E) {
          let I = M;
          do
            I.z === 0 && (I.z = h_(I.x, I.y, D, x, E)), I.prevZ = I.prev, I.nextZ = I.next, I = I.next;
          while (I !== M);
          I.prevZ.nextZ = null, I.prevZ = null, function(S) {
            let C, k = 1;
            do {
              let V, U = S;
              S = null;
              let q = null;
              for (C = 0; U; ) {
                C++;
                let $ = U, H = 0;
                for (let Q = 0; Q < k && (H++, $ = $.nextZ, $); Q++)
                  ;
                let K = k;
                for (; H > 0 || K > 0 && $; )
                  H !== 0 && (K === 0 || !$ || U.z <= $.z) ? (V = U, U = U.nextZ, H--) : (V = $, $ = $.nextZ, K--), q ? q.nextZ = V : S = V, V.prevZ = q, q = V;
                U = $;
              }
              q.nextZ = null, k *= 2;
            } while (C > 1);
          }(I);
        }(r, o, u, l);
        let v = r;
        for (; r.prev !== r.next; ) {
          const M = r.prev, D = r.next;
          if (l ? _w(r, o, u, l) : mw(r))
            e.push(M.i, r.i, D.i), Nd(r), r = D.next, v = D.next;
          else if ((r = D) === v) {
            d ? d === 1 ? Fd(r = gw(_h(r), e), e, n, o, u, l, 2) : d === 2 && yw(r, e, n, o, u, l) : Fd(_h(r), e, n, o, u, l, 1);
            break;
          }
        }
      }
      function mw(r) {
        const e = r.prev, n = r, o = r.next;
        if (Ts(e, n, o) >= 0)
          return !1;
        const u = e.x, l = n.x, d = o.x, v = e.y, M = n.y, D = o.y, x = u < l ? u < d ? u : d : l < d ? l : d, E = v < M ? v < D ? v : D : M < D ? M : D, I = u > l ? u > d ? u : d : l > d ? l : d, S = v > M ? v > D ? v : D : M > D ? M : D;
        let C = o.next;
        for (; C !== e; ) {
          if (C.x >= x && C.x <= I && C.y >= E && C.y <= S && Au(u, v, l, M, d, D, C.x, C.y) && Ts(C.prev, C, C.next) >= 0)
            return !1;
          C = C.next;
        }
        return !0;
      }
      function _w(r, e, n, o) {
        const u = r.prev, l = r, d = r.next;
        if (Ts(u, l, d) >= 0)
          return !1;
        const v = u.x, M = l.x, D = d.x, x = u.y, E = l.y, I = d.y, S = v < M ? v < D ? v : D : M < D ? M : D, C = x < E ? x < I ? x : I : E < I ? E : I, k = v > M ? v > D ? v : D : M > D ? M : D, V = x > E ? x > I ? x : I : E > I ? E : I, U = h_(S, C, e, n, o), q = h_(k, V, e, n, o);
        let $ = r.prevZ, H = r.nextZ;
        for (; $ && $.z >= U && H && H.z <= q; ) {
          if ($.x >= S && $.x <= k && $.y >= C && $.y <= V && $ !== u && $ !== d && Au(v, x, M, E, D, I, $.x, $.y) && Ts($.prev, $, $.next) >= 0 || ($ = $.prevZ, H.x >= S && H.x <= k && H.y >= C && H.y <= V && H !== u && H !== d && Au(v, x, M, E, D, I, H.x, H.y) && Ts(H.prev, H, H.next) >= 0))
            return !1;
          H = H.nextZ;
        }
        for (; $ && $.z >= U; ) {
          if ($.x >= S && $.x <= k && $.y >= C && $.y <= V && $ !== u && $ !== d && Au(v, x, M, E, D, I, $.x, $.y) && Ts($.prev, $, $.next) >= 0)
            return !1;
          $ = $.prevZ;
        }
        for (; H && H.z <= q; ) {
          if (H.x >= S && H.x <= k && H.y >= C && H.y <= V && H !== u && H !== d && Au(v, x, M, E, D, I, H.x, H.y) && Ts(H.prev, H, H.next) >= 0)
            return !1;
          H = H.nextZ;
        }
        return !0;
      }
      function gw(r, e) {
        let n = r;
        do {
          const o = n.prev, u = n.next.next;
          !_p(o, u) && Ey(o, n, n.next, u) && Bd(o, u) && Bd(u, o) && (e.push(o.i, n.i, u.i), Nd(n), Nd(n.next), n = r = u), n = n.next;
        } while (n !== r);
        return _h(n);
      }
      function yw(r, e, n, o, u, l) {
        let d = r;
        do {
          let v = d.next.next;
          for (; v !== d.prev; ) {
            if (d.i !== v.i && Tw(d, v)) {
              let M = Ay(d, v);
              return d = _h(d, d.next), M = _h(M, M.next), Fd(d, e, n, o, u, l, 0), void Fd(M, e, n, o, u, l, 0);
            }
            v = v.next;
          }
          d = d.next;
        } while (d !== r);
      }
      function xw(r, e) {
        return r.x - e.x;
      }
      function vw(r, e) {
        const n = function(u, l) {
          let d = l;
          const v = u.x, M = u.y;
          let D, x = -1 / 0;
          do {
            if (M <= d.y && M >= d.next.y && d.next.y !== d.y) {
              const k = d.x + (M - d.y) * (d.next.x - d.x) / (d.next.y - d.y);
              if (k <= v && k > x && (x = k, D = d.x < d.next.x ? d : d.next, k === v))
                return D;
            }
            d = d.next;
          } while (d !== l);
          if (!D)
            return null;
          const E = D, I = D.x, S = D.y;
          let C = 1 / 0;
          d = D;
          do {
            if (v >= d.x && d.x >= I && v !== d.x && Au(M < S ? v : x, M, I, S, M < S ? x : v, M, d.x, d.y)) {
              const k = Math.abs(M - d.y) / (v - d.x);
              Bd(d, u) && (k < C || k === C && (d.x > D.x || d.x === D.x && bw(D, d))) && (D = d, C = k);
            }
            d = d.next;
          } while (d !== E);
          return D;
        }(r, e);
        if (!n)
          return e;
        const o = Ay(n, r);
        return _h(o, o.next), _h(n, n.next);
      }
      function bw(r, e) {
        return Ts(r.prev, r, e.prev) < 0 && Ts(e.next, r, r.next) < 0;
      }
      function h_(r, e, n, o, u) {
        return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - n) * u | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - o) * u | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
      }
      function ww(r) {
        let e = r, n = r;
        do
          (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
        while (e !== r);
        return n;
      }
      function Au(r, e, n, o, u, l, d, v) {
        return (u - d) * (e - v) >= (r - d) * (l - v) && (r - d) * (o - v) >= (n - d) * (e - v) && (n - d) * (l - v) >= (u - d) * (o - v);
      }
      function Tw(r, e) {
        return r.next.i !== e.i && r.prev.i !== e.i && !function(n, o) {
          let u = n;
          do {
            if (u.i !== n.i && u.next.i !== n.i && u.i !== o.i && u.next.i !== o.i && Ey(u, u.next, n, o))
              return !0;
            u = u.next;
          } while (u !== n);
          return !1;
        }(r, e) && (Bd(r, e) && Bd(e, r) && function(n, o) {
          let u = n, l = !1;
          const d = (n.x + o.x) / 2, v = (n.y + o.y) / 2;
          do
            u.y > v != u.next.y > v && u.next.y !== u.y && d < (u.next.x - u.x) * (v - u.y) / (u.next.y - u.y) + u.x && (l = !l), u = u.next;
          while (u !== n);
          return l;
        }(r, e) && (Ts(r.prev, r, e.prev) || Ts(r, e.prev, e)) || _p(r, e) && Ts(r.prev, r, r.next) > 0 && Ts(e.prev, e, e.next) > 0);
      }
      function Ts(r, e, n) {
        return (e.y - r.y) * (n.x - e.x) - (e.x - r.x) * (n.y - e.y);
      }
      function _p(r, e) {
        return r.x === e.x && r.y === e.y;
      }
      function Ey(r, e, n, o) {
        const u = yp(Ts(r, e, n)), l = yp(Ts(r, e, o)), d = yp(Ts(n, o, r)), v = yp(Ts(n, o, e));
        return u !== l && d !== v || !(u !== 0 || !gp(r, n, e)) || !(l !== 0 || !gp(r, o, e)) || !(d !== 0 || !gp(n, r, o)) || !(v !== 0 || !gp(n, e, o));
      }
      function gp(r, e, n) {
        return e.x <= Math.max(r.x, n.x) && e.x >= Math.min(r.x, n.x) && e.y <= Math.max(r.y, n.y) && e.y >= Math.min(r.y, n.y);
      }
      function yp(r) {
        return r > 0 ? 1 : r < 0 ? -1 : 0;
      }
      function Bd(r, e) {
        return Ts(r.prev, r, r.next) < 0 ? Ts(r, e, r.next) >= 0 && Ts(r, r.prev, e) >= 0 : Ts(r, e, r.prev) < 0 || Ts(r, r.next, e) < 0;
      }
      function Ay(r, e) {
        const n = u_(r.i, r.x, r.y), o = u_(e.i, e.x, e.y), u = r.next, l = e.prev;
        return r.next = e, e.prev = r, n.next = u, u.prev = n, o.next = n, n.prev = o, l.next = o, o.prev = l, o;
      }
      function Py(r, e, n, o) {
        const u = u_(r, e, n);
        return o ? (u.next = o.next, u.prev = o, o.next.prev = u, o.next = u) : (u.prev = u, u.next = u), u;
      }
      function Nd(r) {
        r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
      }
      function u_(r, e, n) {
        return { i: r, x: e, y: n, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      function xp(r, e) {
        const n = r.length;
        if (n <= 1)
          return [r];
        const o = [];
        let u, l;
        for (let d = 0; d < n; d++) {
          const v = Vn(r[d]);
          v !== 0 && (r[d].area = Math.abs(v), l === void 0 && (l = v < 0), l === v < 0 ? (u && o.push(u), u = [r[d]]) : u.push(r[d]));
        }
        if (u && o.push(u), e > 1)
          for (let d = 0; d < o.length; d++)
            o[d].length <= e || (Fh(o[d], e, 1, o[d].length - 1, Sw), o[d] = o[d].slice(0, e));
        return o;
      }
      function Sw(r, e) {
        return e.area - r.area;
      }
      function Cy(r, e) {
        if (!r)
          return null;
        const n = typeof r == "string" ? r : r.getPrimary().id;
        e[n] || (e[n] = []);
        const o = ss.from(r).getPrimary();
        return e[n].push(o), o.serialize();
      }
      function d_(r, e, n) {
        const o = n.patternDependencies;
        let u = !1;
        for (const l of e) {
          const d = l.paint.get(`${r}-pattern`);
          d.isConstant() || (u = !0), Cy(d.constantOr(null), o) && (u = !0);
        }
        return u;
      }
      function f_(r, e, n, o, u) {
        const l = u.patternDependencies;
        for (const d of e) {
          const v = d.paint.get(`${r}-pattern`).value;
          if (v.kind !== "constant") {
            let M = v.evaluate({ zoom: o }, n, {}, u.availableImages);
            M = M && M.name ? M.name : M;
            const D = Cy(M, l);
            D && (n.patterns[d.id] = D);
          }
        }
        return n;
      }
      class p_ {
        constructor(e) {
          this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Io(), this.indexArray = new qs(), this.indexArray2 = new Xa(), this.programConfigurations = new Ka(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Wn(), this.segments2 = new Wn(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.projection = e.projection;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.hasPattern = d_("fill", this.layers, n);
          const l = this.layers[0].layout.get("fill-sort-key"), d = [];
          for (const { feature: v, id: M, index: D, sourceLayerIndex: x } of e) {
            const E = this.layers[0]._featureFilter.needGeometry, I = G(v, E);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), I, o))
              continue;
            const S = l ? l.evaluate(I, {}, o, n.availableImages) : void 0, C = { id: M, properties: v.properties, type: v.type, sourceLayerIndex: x, index: D, geometry: E ? I.geometry : j(v, o, u), patterns: {}, sortKey: S };
            d.push(C);
          }
          l && d.sort((v, M) => v.sortKey - M.sortKey);
          for (const v of d) {
            const { geometry: M, index: D, sourceLayerIndex: x } = v;
            if (this.hasPattern) {
              const E = f_("fill", this.layers, v, this.zoom, n);
              this.patternFeatures.push(E);
            } else
              this.addFeature(v, M, D, o, {}, n.availableImages, n.brightness);
            n.featureIndex.insert(e[D].feature, M, D, x, this.index);
          }
        }
        update(e, n, o, u, l, d, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v);
        }
        addFeatures(e, n, o, u, l, d) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, n, o, u, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, pw), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.indexBuffer2 = e.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(e, n, o, u, l, d = [], v) {
          for (const M of xp(n, 500)) {
            let D = 0;
            for (const k of M)
              D += k.length;
            const x = this.segments.prepareSegment(D, this.layoutVertexArray, this.indexArray), E = x.vertexLength, I = [], S = [];
            for (const k of M) {
              if (k.length === 0)
                continue;
              k !== M[0] && S.push(I.length / 2);
              const V = this.segments2.prepareSegment(k.length, this.layoutVertexArray, this.indexArray2), U = V.vertexLength;
              this.layoutVertexArray.emplaceBack(k[0].x, k[0].y), this.indexArray2.emplaceBack(U + k.length - 1, U), I.push(k[0].x), I.push(k[0].y);
              for (let q = 1; q < k.length; q++)
                this.layoutVertexArray.emplaceBack(k[q].x, k[q].y), this.indexArray2.emplaceBack(U + q - 1, U + q), I.push(k[q].x), I.push(k[q].y);
              V.vertexLength += k.length, V.primitiveLength += k.length;
            }
            const C = Od(I, S);
            for (let k = 0; k < C.length; k += 3)
              this.indexArray.emplaceBack(E + C[k], E + C[k + 1], E + C[k + 2]);
            x.vertexLength += D, x.primitiveLength += C.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, d, u, v);
        }
      }
      let Iy, Ly, zy, Dy;
      Ft(p_, "FillBucket", { omit: ["layers", "patternFeatures"] });
      class m_ {
        constructor(e, n, o, u) {
          if (this.triangleCount = n.length / 3, this.min = new Mt(0, 0), this.max = new Mt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], this.triangleCount === 0 || e.length === 0)
            return;
          const [l, d] = [e[0].clone(), e[0].clone()];
          for (let E = 1; E < e.length; ++E) {
            const I = e[E];
            l.x = Math.min(l.x, I.x), l.y = Math.min(l.y, I.y), d.x = Math.max(d.x, I.x), d.y = Math.max(d.y, I.y);
          }
          if (u) {
            const E = Math.ceil(Math.max(d.x - l.x, d.y - l.y) / u);
            o = Math.max(o, E);
          }
          if (o === 0)
            return;
          this.min = l, this.max = d;
          const v = this.max.sub(this.min);
          v.x = Math.max(v.x, 1), v.y = Math.max(v.y, 1);
          const M = Math.max(v.x, v.y) / o;
          this.cellsX = Math.max(1, Math.ceil(v.x / M)), this.cellsY = Math.max(1, Math.ceil(v.y / M)), this.xScale = 1 / M, this.yScale = 1 / M;
          const D = [];
          for (let E = 0; E < this.triangleCount; E++) {
            const I = e[n[3 * E + 0]].sub(this.min), S = e[n[3 * E + 1]].sub(this.min), C = e[n[3 * E + 2]].sub(this.min), k = tl(Math.floor(Math.min(I.x, S.x, C.x)), this.xScale, this.cellsX), V = tl(Math.floor(Math.max(I.x, S.x, C.x)), this.xScale, this.cellsX), U = tl(Math.floor(Math.min(I.y, S.y, C.y)), this.yScale, this.cellsY), q = tl(Math.floor(Math.max(I.y, S.y, C.y)), this.yScale, this.cellsY), $ = new Mt(0, 0), H = new Mt(0, 0), K = new Mt(0, 0), Q = new Mt(0, 0);
            for (let ie = U; ie <= q; ++ie) {
              $.y = H.y = ie * M, K.y = Q.y = (ie + 1) * M;
              for (let fe = k; fe <= V; ++fe)
                $.x = K.x = fe * M, H.x = Q.x = (fe + 1) * M, (ke(I, S, C, $, H, Q) || ke(I, S, C, $, Q, K)) && D.push({ cellIdx: ie * this.cellsX + fe, triIdx: E });
            }
          }
          if (D.length === 0)
            return;
          D.sort((E, I) => E.cellIdx - I.cellIdx || E.triIdx - I.triIdx);
          let x = 0;
          for (; x < D.length; ) {
            const E = D[x].cellIdx, I = { start: this.payload.length, len: 0 };
            for (; x < D.length && D[x].cellIdx === E; )
              ++I.len, this.payload.push(D[x++].triIdx);
            this.cells[E] = I;
          }
        }
        _lazyInitLookup() {
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
        }
        queryPoint(e, n) {
          if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > e.x || e.y > this.max.y || this.min.y > e.y)
            return;
          const o = tl(e.x - this.min.x, this.xScale, this.cellsX), u = tl(e.y - this.min.y, this.yScale, this.cellsY), l = this.cells[u * this.cellsX + o];
          if (l) {
            this._lazyInitLookup();
            for (let d = 0; d < l.len; d++) {
              const v = this.payload[l.start + d], M = Math.floor(v / 8), D = 1 << v % 8;
              if (!(this.lookup[M] & D) && (this.lookup[M] |= D, n.push(v), n.length === this.triangleCount))
                return;
            }
          }
        }
        query(e, n, o) {
          if (this.triangleCount === 0 || this.cells.length === 0 || e.x > this.max.x || this.min.x > n.x || e.y > this.max.y || this.min.y > n.y)
            return;
          this._lazyInitLookup();
          const u = tl(e.x - this.min.x, this.xScale, this.cellsX), l = tl(n.x - this.min.x, this.xScale, this.cellsX), d = tl(e.y - this.min.y, this.yScale, this.cellsY), v = tl(n.y - this.min.y, this.yScale, this.cellsY);
          for (let M = d; M <= v; M++)
            for (let D = u; D <= l; D++) {
              const x = this.cells[M * this.cellsX + D];
              if (x)
                for (let E = 0; E < x.len; E++) {
                  const I = this.payload[x.start + E], S = Math.floor(I / 8), C = 1 << I % 8;
                  if (!(this.lookup[S] & C) && (this.lookup[S] |= C, o.push(I), o.length === this.triangleCount))
                    return;
                }
            }
        }
      }
      function tl(r, e, n) {
        return Math.max(0, Math.min(n - 1, Math.floor(r * e)));
      }
      Ft(m_, "TriangleGridIndex");
      class ky {
        constructor(e) {
          this.zoom = e.zoom, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.footprints = [];
        }
        updateFootprints(e, n) {
          for (const o of this.footprints)
            n.push({ footprint: o, id: e });
        }
        populate(e, n, o, u) {
          const l = [];
          for (const { feature: d, id: v, index: M, sourceLayerIndex: D } of e) {
            const x = this.layers[0]._featureFilter.needGeometry, E = G(d, x);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), E, o))
              continue;
            const I = { id: v, properties: d.properties, type: d.type, sourceLayerIndex: D, index: M, geometry: x ? E.geometry : j(d, o, u), patterns: {} };
            l.push(I);
          }
          for (const d of l) {
            const { geometry: v, index: M, sourceLayerIndex: D } = d;
            this.addFeature(d, v, M, o, {}, n.availableImages, n.brightness), n.featureIndex.insert(e[M].feature, v, M, D, this.index);
          }
        }
        isEmpty() {
          return this.footprints.length === 0;
        }
        uploadPending() {
          return !1;
        }
        upload(e) {
        }
        update(e, n, o, u, l, d, v) {
        }
        destroy() {
        }
        addFeature(e, n, o, u, l, d = [], v) {
          for (const M of xp(n, 2)) {
            const D = [], x = [], E = [], I = new Mt(1 / 0, 1 / 0), S = new Mt(-1 / 0, -1 / 0);
            for (const V of M)
              if (V.length !== 0) {
                V !== M[0] && E.push(x.length / 2);
                for (let U = 0; U < V.length; U++)
                  x.push(V[U].x), x.push(V[U].y), D.push(V[U]), I.x = Math.min(I.x, V[U].x), I.y = Math.min(I.y, V[U].y), S.x = Math.max(S.x, V[U].x), S.y = Math.max(S.y, V[U].y);
              }
            const C = Od(x, E), k = new m_(D, C, 8, 256);
            this.footprints.push({ vertices: D, indices: C, grid: k, min: I, max: S });
          }
        }
      }
      Ft(ky, "ClipBucket", { omit: ["layers"] });
      const Mw = qi([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Ew = qi([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), Aw = qi([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Pw = qi([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Cw = qi([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Iw = qi([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Lw } = Mw;
      var __, Ry, g_, Oy, y_, Fy, By, vp = {};
      function Ny() {
        if (Ry)
          return __;
        Ry = 1;
        var r = Zr();
        function e(u, l, d, v, M) {
          this.properties = {}, this.extent = d, this.type = 0, this._pbf = u, this._geometry = -1, this._keys = v, this._values = M, u.readFields(n, this, l);
        }
        function n(u, l, d) {
          u == 1 ? l.id = d.readVarint() : u == 2 ? function(v, M) {
            for (var D = v.readVarint() + v.pos; v.pos < D; ) {
              var x = M._keys[v.readVarint()], E = M._values[v.readVarint()];
              M.properties[x] = E;
            }
          }(d, l) : u == 3 ? l.type = d.readVarint() : u == 4 && (l._geometry = d.pos);
        }
        function o(u) {
          for (var l, d, v = 0, M = 0, D = u.length, x = D - 1; M < D; x = M++)
            v += ((d = u[x]).x - (l = u[M]).x) * (l.y + d.y);
          return v;
        }
        return __ = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function() {
          var u = this._pbf;
          u.pos = this._geometry;
          for (var l, d = u.readVarint() + u.pos, v = 1, M = 0, D = 0, x = 0, E = []; u.pos < d; ) {
            if (M <= 0) {
              var I = u.readVarint();
              v = 7 & I, M = I >> 3;
            }
            if (M--, v === 1 || v === 2)
              D += u.readSVarint(), x += u.readSVarint(), v === 1 && (l && E.push(l), l = []), l.push(new r(D, x));
            else {
              if (v !== 7)
                throw new Error("unknown command " + v);
              l && l.push(l[0].clone());
            }
          }
          return l && E.push(l), E;
        }, e.prototype.bbox = function() {
          var u = this._pbf;
          u.pos = this._geometry;
          for (var l = u.readVarint() + u.pos, d = 1, v = 0, M = 0, D = 0, x = 1 / 0, E = -1 / 0, I = 1 / 0, S = -1 / 0; u.pos < l; ) {
            if (v <= 0) {
              var C = u.readVarint();
              d = 7 & C, v = C >> 3;
            }
            if (v--, d === 1 || d === 2)
              (M += u.readSVarint()) < x && (x = M), M > E && (E = M), (D += u.readSVarint()) < I && (I = D), D > S && (S = D);
            else if (d !== 7)
              throw new Error("unknown command " + d);
          }
          return [x, I, E, S];
        }, e.prototype.toGeoJSON = function(u, l, d) {
          var v, M, D = this.extent * Math.pow(2, d), x = this.extent * u, E = this.extent * l, I = this.loadGeometry(), S = e.types[this.type];
          function C(U) {
            for (var q = 0; q < U.length; q++) {
              var $ = U[q];
              U[q] = [360 * ($.x + x) / D - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * ($.y + E) / D) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var k = [];
              for (v = 0; v < I.length; v++)
                k[v] = I[v][0];
              C(I = k);
              break;
            case 2:
              for (v = 0; v < I.length; v++)
                C(I[v]);
              break;
            case 3:
              for (I = function(U) {
                var q = U.length;
                if (q <= 1)
                  return [U];
                for (var $, H, K = [], Q = 0; Q < q; Q++) {
                  var ie = o(U[Q]);
                  ie !== 0 && (H === void 0 && (H = ie < 0), H === ie < 0 ? ($ && K.push($), $ = [U[Q]]) : $.push(U[Q]));
                }
                return $ && K.push($), K;
              }(I), v = 0; v < I.length; v++)
                for (M = 0; M < I[v].length; M++)
                  C(I[v][M]);
          }
          I.length === 1 ? I = I[0] : S = "Multi" + S;
          var V = { type: "Feature", geometry: { type: S, coordinates: I }, properties: this.properties };
          return "id" in this && (V.id = this.id), V;
        }, __;
      }
      function Vy() {
        if (Oy)
          return g_;
        Oy = 1;
        var r = Ny();
        function e(o, u) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = o, this._keys = [], this._values = [], this._features = [], o.readFields(n, this, u), this.length = this._features.length;
        }
        function n(o, u, l) {
          o === 15 ? u.version = l.readVarint() : o === 1 ? u.name = l.readString() : o === 5 ? u.extent = l.readVarint() : o === 2 ? u._features.push(l.pos) : o === 3 ? u._keys.push(l.readString()) : o === 4 && u._values.push(function(d) {
            for (var v = null, M = d.readVarint() + d.pos; d.pos < M; ) {
              var D = d.readVarint() >> 3;
              v = D === 1 ? d.readString() : D === 2 ? d.readFloat() : D === 3 ? d.readDouble() : D === 4 ? d.readVarint64() : D === 5 ? d.readVarint() : D === 6 ? d.readSVarint() : D === 7 ? d.readBoolean() : null;
            }
            return v;
          }(l));
        }
        return g_ = e, e.prototype.feature = function(o) {
          if (o < 0 || o >= this._features.length)
            throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[o];
          var u = this._pbf.readVarint() + this._pbf.pos;
          return new r(this._pbf, u, this.extent, this._keys, this._values);
        }, g_;
      }
      function Uy() {
        return By || (By = 1, vp.VectorTile = function() {
          if (Fy)
            return y_;
          Fy = 1;
          var r = Vy();
          function e(n, o, u) {
            if (n === 3) {
              var l = new r(u, u.readVarint() + u.pos);
              l.length && (o[l.name] = l);
            }
          }
          return y_ = function(n, o) {
            this.layers = n.readFields(e, {}, o);
          }, y_;
        }(), vp.VectorTileFeature = Ny(), vp.VectorTileLayer = Vy()), vp;
      }
      var Pu = Uy();
      class gh extends Mt {
        constructor(e, n, o) {
          super(e, n), this.z = o;
        }
      }
      class jy extends gh {
        constructor(e, n, o, u) {
          super(e, n, o), this.w = u;
        }
      }
      function bp(r, e, n, o) {
        const u = [], l = o === 0 ? (d, v, M, D, x, E) => {
          d.push(new Mt(E, M + (E - v) / (D - v) * (x - M)));
        } : (d, v, M, D, x, E) => {
          d.push(new Mt(v + (E - M) / (x - M) * (D - v), E));
        };
        for (const d of r) {
          const v = [];
          for (const M of d) {
            if (M.length <= 2)
              continue;
            const D = [];
            for (let I = 0; I < M.length - 1; I++) {
              const S = M[I].x, C = M[I].y, k = M[I + 1].x, V = M[I + 1].y, U = o === 0 ? S : C, q = o === 0 ? k : V;
              U < e ? q > e && l(D, S, C, k, V, e) : U > n ? q < n && l(D, S, C, k, V, n) : D.push(M[I]), q < e && U >= e && l(D, S, C, k, V, e), q > n && U <= n && l(D, S, C, k, V, n);
            }
            let x = M[M.length - 1];
            const E = o === 0 ? x.x : x.y;
            E >= e && E <= n && D.push(x), D.length && (x = D[D.length - 1], D[0].x === x.x && D[0].y === x.y || D.push(D[0]), v.push(D));
          }
          v.length && u.push(v);
        }
        return u;
      }
      function Gy(r, e, n, o) {
        const u = n === "x" ? "y" : "x", l = (o - r[n]) / (e[n] - r[n]);
        r[u] = r[u] + (e[u] - r[u]) * l, r[n] = o, r.hasOwnProperty("z") && (r.z = ei(r.z, e.z, l)), r.hasOwnProperty("w") && (r.w = ei(r.w, e.w, l));
      }
      function Zy(r, e, n, o) {
        const u = n, l = o;
        for (const d of ["x", "y"]) {
          let v = r, M = e;
          v[d] >= M[d] && (v = e, M = r), v[d] < u && M[d] > u && Gy(v, M, d, u), v[d] < l && M[d] > l && Gy(M, v, d, l);
        }
      }
      const wp = Number.MAX_SAFE_INTEGER;
      function Hy(r, e, n, o) {
        return r.order < e || r.order === wp || !(r.clipMask & n) || function(u, l) {
          return l.length !== 0 && l.find((d) => d === u) === void 0;
        }(o, r.clipScope);
      }
      function Tp(r, e) {
        return r.x - e.x || r.y - e.y;
      }
      function qy(r, e) {
        return Tp(r.min, e.min) === 0 && Tp(r.max, e.max) === 0;
      }
      function x_(r, e) {
        return !(r.min.x > e.max.x || r.max.x < e.min.x || r.min.y > e.max.y || r.max.y < e.min.y);
      }
      function v_(r, e) {
        if (r.length !== e.length)
          return !1;
        for (let n = 0; n < r.length; n++)
          if (r[n].sourceId !== e[n].sourceId || !qy(r[n], e[n]) || r[n].order !== e[n].order || r[n].clipMask !== e[n].clipMask || !ir(r[n].clipScope, e[n].clipScope))
            return !1;
        return !0;
      }
      function Wy(r, e, n) {
        const o = 1 / wt, u = 1 / (1 << n.canonical.z), l = (e.x * o + n.canonical.x) * u + n.wrap, d = (e.y * o + n.canonical.y) * u;
        return { min: new Mt((r.x * o + n.canonical.x) * u + n.wrap, (r.y * o + n.canonical.y) * u), max: new Mt(l, d) };
      }
      function zw(r, e, n) {
        const o = 1 << n.canonical.z, u = ((e.x - n.wrap) * o - n.canonical.x) * wt, l = (e.y * o - n.canonical.y) * wt;
        return { min: new Mt(((r.x - n.wrap) * o - n.canonical.x) * wt, (r.y * o - n.canonical.y) * wt), max: new Mt(u, l) };
      }
      function $y(r, e, n, o, u, l, d) {
        const v = r.indices, M = r.vertices, D = [];
        for (let x = o; x < o + u; x += 3) {
          const E = e[n[x + 0] + l], I = e[n[x + 1] + l], S = e[n[x + 2] + l], C = Math.min(E.x, I.x, S.x), k = Math.max(E.x, I.x, S.x), V = Math.min(E.y, I.y, S.y), U = Math.max(E.y, I.y, S.y);
          D.length = 0, r.grid.query(new Mt(C, V), new Mt(k, U), D);
          for (let q = 0; q < D.length; q++) {
            const $ = D[q];
            if (ke(M[v[3 * $ + 0]], M[v[3 * $ + 1]], M[v[3 * $ + 2]], E, I, S, d))
              return !0;
          }
        }
        return !1;
      }
      function Xy(r, e, n, o) {
        if (!r || !n)
          return !1;
        let u = r.vertices;
        if (!e.canonical.equals(o.canonical) || e.wrap !== o.wrap) {
          if (n.vertices.length < r.vertices.length)
            return Xy(n, o, r, e);
          const l = e.canonical, d = o.canonical, v = Math.pow(2, d.z - l.z);
          u = r.vertices.map((M) => new Mt((M.x + l.x * wt) * v - d.x * wt, (M.y + l.y * wt) * v - d.y * wt));
        }
        return $y(n, u, r.indices, 0, r.indices.length, 0, 0);
      }
      function Yy(r, e, n, o) {
        const u = Math.pow(2, o.z - n.z);
        return new Mt((r + n.x * wt) * u - o.x * wt, (e + n.y * wt) * u - o.y * wt);
      }
      function Ky(r, e) {
        const n = [];
        e.grid.queryPoint(r, n);
        const o = e.indices, u = e.vertices;
        for (let l = 0; l < n.length; l++) {
          const d = n[l];
          if (Pe([u[o[3 * d + 0]], u[o[3 * d + 1]], u[o[3 * d + 2]]], r))
            return !0;
        }
        return !1;
      }
      const b_ = [new Mt(0, 0), new Mt(wt, 0), new Mt(wt, wt), new Mt(0, wt)];
      function Jy(r, e) {
        const n = [];
        let o = [];
        if (!e || r.length < 2)
          return [r];
        if (r.length === 2)
          return Xe(r[0], r[1], b_) ? [r] : [];
        for (let u = 0; u < r.length + 2; u++) {
          const l = r[u % r.length], d = r[(u + 1) % r.length], v = Xe(u === 0 ? r[r.length - 1] : r[(u - 1) % r.length], l, b_), M = Xe(l, d, b_), D = v || M;
          D && o.push(l), D && M || o.length > 0 && (o.length > 1 && n.push(o), o = []);
        }
        return o.length > 1 && n.push(o), n;
      }
      const w_ = Pu.VectorTileFeature.types, Dw = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], kw = ["fill-extrusion-flood-light-ground-radius"], Rw = Math.pow(2, 13), Ow = Math.pow(2, 15) - 1, Qy = new Mt(0, 1), _c = 2147483648;
      function Vd(r, e, n, o, u, l, d, v) {
        r.emplaceBack((e << 1) + d, (n << 1) + l, (Math.floor(o * Rw) << 1) + u, Math.round(v));
      }
      function Ud(r, e, n) {
        r.emplaceBack(e.x * wt, e.y * wt, n ? 1 : 0);
      }
      function Sp(r, e, n, o, u, l) {
        r.emplaceBack(e.x, e.y, (n.x << 1) + o, (n.y << 1) + u, l);
      }
      function jd(r, e, n) {
        r.emplaceBack(e.x, e.y, e.z, n[0] * 16384, n[1] * 16384, n[2] * 16384);
      }
      class e0 {
        constructor() {
          this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
        }
      }
      class t0 {
        constructor() {
          this.centroidXY = new Mt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new Mt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new Mt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
        }
        span() {
          return new Mt(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class i0 {
        constructor() {
          this.acc = new Mt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
        }
        startRing(e, n) {
          e.min.x === Number.MAX_VALUE && (e.min.x = e.max.x = n.x, e.min.y = e.max.y = n.y);
        }
        appendEdge(e, n, o) {
          this.accCount++, this.acc._add(n);
          let u = !!this.borders;
          n.x < e.min.x ? (e.min.x = n.x, u = !0) : n.x > e.max.x && (e.max.x = n.x, u = !0), n.y < e.min.y ? (e.min.y = n.y, u = !0) : n.y > e.max.y && (e.max.y = n.y, u = !0), ((n.x === 0 || n.x === wt) && n.x === o.x) != ((n.y === 0 || n.y === wt) && n.y === o.y) && this.processBorderOverlap(n, o), u && this.checkBorderIntersection(n, o);
        }
        checkBorderIntersection(e, n) {
          n.x < 0 != e.x < 0 && this.addBorderIntersection(0, ei(n.y, e.y, (0 - n.x) / (e.x - n.x))), n.x > wt != e.x > wt && this.addBorderIntersection(1, ei(n.y, e.y, (wt - n.x) / (e.x - n.x))), n.y < 0 != e.y < 0 && this.addBorderIntersection(2, ei(n.x, e.x, (0 - n.y) / (e.y - n.y))), n.y > wt != e.y > wt && this.addBorderIntersection(3, ei(n.x, e.x, (wt - n.y) / (e.y - n.y)));
        }
        addBorderIntersection(e, n) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const o = this.borders[e];
          n < o[0] && (o[0] = n), n > o[1] && (o[1] = n);
        }
        processBorderOverlap(e, n) {
          if (e.x === n.x) {
            if (e.y === n.y)
              return;
            const o = e.x === 0 ? 0 : 1;
            this.addBorderIntersection(o, n.y), this.addBorderIntersection(o, e.y);
          } else {
            const o = e.y === 0 ? 2 : 3;
            this.addBorderIntersection(o, n.x), this.addBorderIntersection(o, e.x);
          }
        }
        centroid() {
          return this.accCount === 0 ? new Mt(0, 0) : new Mt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((e, n) => e + +(n[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function n0(r, e) {
        const n = r.add(e)._unit(), o = si(r.x * n.x + r.y * n.y, -1, 1);
        var u, l, d;
        return d = Math.acos(o), Math.min(4, Math.max(-4, Math.tan(d))) / 4 * Ow * ((u = r).x * (l = e).y - u.y * l.x < 0 ? -1 : 1);
      }
      const Fw = [(r) => r.x < 0, (r) => r.x > wt, (r) => r.y < 0, (r) => r.y > wt];
      function Bw(r, e, n, o) {
        const u = [4];
        if (o === 0)
          return u;
        n._mult(o);
        const l = r.sub(n), d = e.sub(n), v = [r, e, l, d];
        for (let M = 0; M < 4; M++)
          for (const D of v)
            if (Fw[M](D)) {
              u.push(M);
              break;
            }
        return u;
      }
      class s0 {
        constructor(e) {
          this.vertexArray = new xd(), this.indexArray = new qs(), this.programConfigurations = new Ka(e.layers, { zoom: e.zoom, lut: e.lut }, (n) => kw.includes(n)), this._segments = new Wn(), this.hiddenByLandmarkVertexArray = new yu(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Wn();
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return this.vertexArray.length !== 0;
        }
        addData(e, n, o, u = !1) {
          const l = e.length;
          if (l > 2) {
            let d = Math.max(0, this._segments.get().length - 1);
            const v = this._segments._prepareSegment(4 * l, this.vertexArray.length, 2 * this._segmentToGroundQuads[d].length);
            let M;
            d !== this._segments.get().length - 1 && (d++, this._segmentToGroundQuads[d] = [], this._segmentToRegionTriCounts[d] = [0, 0, 0, 0, 0]);
            {
              const D = e[0], x = e[1];
              M = n0(D.sub(e[l - 1])._perp()._unit(), x.sub(D)._perp()._unit());
            }
            for (let D = 0; D < l; D++) {
              const x = D === l - 1 ? 0 : D + 1, E = e[D], I = e[x], S = e[x === l - 1 ? 0 : x + 1], C = I.sub(E)._perp()._unit(), k = n0(C, S.sub(I)._perp()._unit()), V = M, U = k;
              if (T_(E, I, n) || u && a0(E, n) && a0(I, n)) {
                M = k;
                continue;
              }
              const q = v.vertexLength;
              Sp(this.vertexArray, E, I, 1, 1, V), Sp(this.vertexArray, E, I, 1, 0, V), Sp(this.vertexArray, E, I, 0, 1, U), Sp(this.vertexArray, E, I, 0, 0, U), v.vertexLength += 4;
              const $ = Bw(E, I, C, o);
              for (const H of $)
                this._segmentToGroundQuads[d].push({ id: q, region: H }), this._segmentToRegionTriCounts[d][H] += 2, v.primitiveLength += 2;
              M = k;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData())
            return;
          const e = this._segments.get(), n = e.length;
          for (let o = 0; o < n; o++)
            this._segmentToGroundQuads[o].sort((u, l) => u.region - l.region);
          for (let o = 0; o < n; o++) {
            const u = this._segmentToGroundQuads[o], l = e[o], d = this._segmentToRegionTriCounts[o];
            d.reduce((M, D) => M + D, 0);
            let v = 0;
            for (let M = 0; M <= 4; M++) {
              const D = d[M];
              if (D !== 0) {
                let x = this.regionSegments[M];
                x || (x = this.regionSegments[M] = new Wn());
                const E = { vertexOffset: l.vertexOffset, primitiveOffset: l.primitiveOffset + v, vertexLength: l.vertexLength, primitiveLength: D };
                x.get().push(E);
              }
              v += D;
            }
            for (let M = 0; M < u.length; M++) {
              const D = u[M].id;
              this.indexArray.emplaceBack(D, D + 1, D + 3), this.indexArray.emplaceBack(D, D + 3, D + 2);
            }
          }
          this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
        }
        addPaintPropertiesData(e, n, o, u, l, d) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, e, n, o, u, l, d);
        }
        upload(e) {
          this.hasData() && (this.vertexBuffer = e.createVertexBuffer(this.vertexArray, Ew.members), this.indexBuffer = e.createIndexBuffer(this.indexArray));
        }
        uploadPaintProperties(e) {
          this.hasData() && this.programConfigurations.upload(e);
        }
        update(e, n, o, u, l, d, v) {
          this.hasData() && this.programConfigurations.updatePaintArrays(e, n, o, u, l, d, v);
        }
        updateHiddenByLandmark(e) {
          if (!this.hasData())
            return;
          const n = e.groundVertexCount + e.groundVertexArrayOffset;
          if (e.groundVertexCount === 0)
            return;
          const o = e.flags & _c ? 1 : 0;
          for (let u = e.groundVertexArrayOffset; u < n; ++u)
            this.hiddenByLandmarkVertexArray.emplace(u, o);
          this._needsHiddenByLandmarkUpdate = !0;
        }
        uploadHiddenByLandmark(e) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(this.hiddenByLandmarkVertexArray, Cw.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let e = 0; e <= 4; e++) {
              const n = this.regionSegments[e];
              n && n.destroy();
            }
          }
        }
      }
      class Mp {
        constructor(e) {
          this.zoom = e.zoom, this.canonical = e.canonical, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = e.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new qs(), this.footprintVertices = new Io(), this.footprintSegments = [], this.layoutVertexArray = new qa(), this.centroidVertexArray = new ap(), this.wallVertexArray = new cp(), this.indexArray = new qs(), this.programConfigurations = new Ka(e.layers, { zoom: e.zoom, lut: e.lut }, (n) => Dw.includes(n)), this.segments = new Wn(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.groundEffect = new s0(e), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.features = [], this.hasPattern = d_("fill-extrusion", this.layers, n), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = s(o), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1) !== 0;
          for (const { feature: l, id: d, index: v, sourceLayerIndex: M } of e) {
            const D = this.layers[0]._featureFilter.needGeometry, x = G(l, D);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), x, o))
              continue;
            const E = { id: d, sourceLayerIndex: M, index: v, geometry: D ? x.geometry : j(l, o, u), properties: l.properties, type: l.type, patterns: {} }, I = this.layoutVertexArray.length, S = w_[E.type] === "Polygon";
            if (this.hasPattern)
              this.features.push(f_("fill-extrusion", this.layers, E, this.zoom, n));
            else if (this.wallMode)
              for (const C of E.geometry)
                for (const k of Jy(C, S))
                  this.addFeature(E, [k], v, o, {}, n.availableImages, u, n.brightness);
            else
              this.addFeature(E, E.geometry, v, o, {}, n.availableImages, u, n.brightness);
            n.featureIndex.insert(l, E.geometry, v, M, this.index, I);
          }
          this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
        }
        addFeatures(e, n, o, u, l, d) {
          for (const v of this.features) {
            const M = w_[v.type] === "Polygon", { geometry: D } = v;
            if (this.wallMode)
              for (const x of D)
                for (const E of Jy(x, M))
                  this.addFeature(v, [E], v.index, n, o, u, l, d);
            else
              this.addFeature(v, D, v.index, n, o, u, l, d);
          }
          this.sortBorders(), this.projection.name === "mercator" && this.splitToSubtiles();
        }
        update(e, n, o, u, l, d, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v), this.groundEffect.update(e, n, l, o, u, d, v);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Lw), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.wallVertexBuffer = e.createVertexBuffer(this.wallVertexArray, Pw.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = e.createVertexBuffer(this.layoutVertexExtArray, Iw.members, !0)), this.groundEffect.upload(e)), this.groundEffect.uploadPaintProperties(e), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        uploadCentroid(e) {
          this.groundEffect.uploadHiddenByLandmark(e), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = e.createVertexBuffer(this.centroidVertexArray, Aw.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(e, n, o, u, l, d, v, M) {
          const D = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(e, {}) / this.tileToMeter, x = [new Mt(0, 0), new Mt(wt, wt)], E = v.projection, I = E.name === "globe", S = this.wallMode || w_[e.type] === "Polygon", C = new i0();
          C.centroidDataIndex = this.centroidData.length;
          const k = new t0(), V = this.layers[0].paint.get("fill-extrusion-base").evaluate(e, {}, u) <= 0, U = this.layers[0].paint.get("fill-extrusion-height").evaluate(e, {}, u);
          let q;
          if (k.height = U, k.vertexArrayOffset = this.layoutVertexArray.length, k.groundVertexArrayOffset = this.groundEffect.vertexArray.length, I && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new du()), this.wallMode) {
            if (I)
              return void mi("Non zero fill-extrusion-line-width is not yet supported on globe.");
            if (n.length !== 1)
              return;
            q = function(he) {
              const Me = he[0].x === he[he.length - 1].x && he[0].y === he[he.length - 1].y;
              (function(Pt) {
                let rt = 0;
                const Ut = Pt.length;
                for (let St = 0; St < Ut; St++)
                  rt += (Pt[(St + 1) % Ut].x - Pt[St].x) * (Pt[(St + 1) % Ut].y + Pt[St].y);
                return rt >= 0;
              })(he) || (he = he.reverse());
              const Ee = { geometry: [], joinNormals: [], indices: [] }, ze = [], Ie = [], Re = [];
              let Ve = he.length;
              for (; Ve >= 2 && he[Ve - 1].equals(he[Ve - 2]); )
                Ve--;
              if (Ve < (Me ? 3 : 2))
                return Ee;
              let Ue, Fe, et, dt, tt, Tt = 0;
              for (; Tt < Ve - 1 && he[Tt].equals(he[Tt + 1]); )
                Tt++;
              Me && (Ue = he[Ve - 2], tt = he[Tt].sub(Ue)._unit()._perp());
              for (let Pt = Tt; Pt < Ve; Pt++) {
                if (et = Pt === Ve - 1 ? Me ? he[Tt + 1] : void 0 : he[Pt + 1], et && he[Pt].equals(et))
                  continue;
                tt && (dt = tt), Ue && (Fe = Ue), Ue = he[Pt], tt = et ? et.sub(Ue)._unit()._perp() : dt, dt = dt || tt;
                let rt = dt.add(tt);
                rt.x === 0 && rt.y === 0 || rt._unit();
                const Ut = rt.x * tt.x + rt.y * tt.y, St = Ut !== 0 ? 1 / Ut : 1 / 0, Nt = dt.x * tt.y - dt.y * tt.x > 0;
                let Qt = "miter";
                const pi = 2;
                Qt === "miter" && St > pi && (Qt = "bevel"), Qt === "bevel" && (St > 100 && (Qt = "flipbevel"), St < pi && (Qt = "miter"));
                const gi = (Pi, yi, Ii, fn) => {
                  const rn = new Mt(Pi.x, Pi.y), hi = new Mt(Pi.x, Pi.y);
                  rn.x += yi.x * fn, rn.y += yi.y * fn, hi.x -= yi.x * Math.max(Ii, 1), hi.y -= yi.y * Math.max(Ii, 1), Re.push(yi), ze.push(rn), Ie.push(hi);
                };
                if (Qt === "miter")
                  rt._mult(St), gi(Ue, rt, 0, 0);
                else if (Qt === "flipbevel")
                  rt = tt.mult(-1), gi(Ue, rt, 0, 0), gi(Ue, rt.mult(-1), 0, 0);
                else {
                  const Pi = -Math.sqrt(St * St - 1), yi = Nt ? Pi : 0, Ii = Nt ? 0 : Pi;
                  Fe && gi(Ue, dt, yi, Ii), et && gi(Ue, tt, yi, Ii);
                }
              }
              Ee.geometry = [...ze, ...Ie.reverse(), ze[0]], Ee.joinNormals = [...Re, ...Re.reverse(), Re[Re.length - 1]];
              const vt = Ee.geometry.length - 1;
              for (let Pt = 0; Pt < vt / 2; Pt++)
                if (Pt + 1 < vt / 2) {
                  let rt = Pt, Ut = Pt + 1, St = vt - 1 - Pt, Nt = vt - 2 - Pt;
                  rt = rt === 0 ? vt - 1 : rt - 1, Ut = Ut === 0 ? vt - 1 : Ut - 1, St = St === 0 ? vt - 1 : St - 1, Nt = Nt === 0 ? vt - 1 : Nt - 1, Ee.indices.push(St), Ee.indices.push(Ut), Ee.indices.push(rt), Ee.indices.push(St), Ee.indices.push(Nt), Ee.indices.push(Ut);
                }
              return Ee;
            }(n[0]), n = [q.geometry];
          }
          const $ = (he, Me) => he < (Me.length - 1) / 2 || he === Me.length - 1, H = this.wallMode ? [n] : xp(n, 500);
          for (let he = H.length - 1; he >= 0; he--) {
            const Me = H[he];
            (Me.length === 0 || (K = Me[0]).every((me) => me.x <= 0) || K.every((me) => me.x >= wt) || K.every((me) => me.y <= 0) || K.every((me) => me.y >= wt)) && H.splice(he, 1);
          }
          var K;
          let Q;
          if (I)
            Q = u0(H, x, u);
          else {
            Q = [];
            for (const he of H)
              Q.push({ polygon: he, bounds: x });
          }
          const ie = S ? this.edgeRadius : 0, fe = ie > 0 && this.zoom < 17, de = (he, Me) => {
            if (he.length === 0)
              return !1;
            const me = he[he.length - 1];
            return Me.x === me.x && Me.y === me.y;
          };
          for (const { polygon: he, bounds: Me } of Q) {
            let me = 0, Ee = 0;
            for (const Ve of he)
              S && !Ve[0].equals(Ve[Ve.length - 1]) && Ve.push(Ve[0]), Ee += S ? Ve.length - 1 : Ve.length;
            const ze = this.segments.prepareSegment((S ? 5 : 4) * Ee, this.layoutVertexArray, this.indexArray);
            k.footprintSegIdx < 0 && (k.footprintSegIdx = this.footprintSegments.length), k.polygonSegIdx < 0 && (k.polygonSegIdx = this.polygonSegments.length);
            const Ie = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, Re = new e0();
            if (Re.vertexOffset = this.footprintVertices.length, Re.indexOffset = 3 * this.footprintIndices.length, Re.ringIndices = [], S) {
              const Ve = [], Ue = [];
              me = ze.vertexLength;
              for (let et = 0; et < he.length; et++) {
                const dt = he[et];
                dt.length && et !== 0 && Ue.push(Ve.length / 2);
                const tt = [];
                let Tt, vt;
                Tt = dt[1].sub(dt[0])._perp()._unit(), Re.ringIndices.push(dt.length - 1);
                for (let Pt = 1; Pt < dt.length; Pt++) {
                  const rt = dt[Pt], Ut = dt[Pt === dt.length - 1 ? 1 : Pt + 1], St = rt.clone();
                  if (ie) {
                    vt = Ut.sub(rt)._perp()._unit();
                    const Nt = Tt.add(vt)._unit(), Qt = ie * Math.min(4, 1 / (Tt.x * Nt.x + Tt.y * Nt.y));
                    St.x += Qt * Nt.x, St.y += Qt * Nt.y, St.x = Math.round(St.x), St.y = Math.round(St.y), Tt = vt;
                  }
                  if (!V || ie !== 0 && !fe || de(tt, St) || tt.push(St), Vd(this.layoutVertexArray, St.x, St.y, 0, 0, 1, 1, 0), this.wallMode) {
                    const Nt = $(Pt, dt);
                    Ud(this.wallVertexArray, q.joinNormals[Pt], !Nt);
                  }
                  ze.vertexLength++, this.footprintVertices.emplaceBack(rt.x, rt.y), Ve.push(rt.x, rt.y), I && jd(this.layoutVertexExtArray, E.projectTilePoint(St.x, St.y, u), E.upVector(u, St.x, St.y));
                }
                V && (ie === 0 || fe) && (tt.length !== 0 && de(tt, tt[0]) && tt.pop(), this.groundEffect.addData(tt, Me, D));
              }
              const Fe = this.wallMode ? q.indices : Od(Ve, Ue);
              for (let et = 0; et < Fe.length; et += 3)
                this.footprintIndices.emplaceBack(Re.vertexOffset + Fe[et + 0], Re.vertexOffset + Fe[et + 1], Re.vertexOffset + Fe[et + 2]), this.indexArray.emplaceBack(me + Fe[et], me + Fe[et + 2], me + Fe[et + 1]), ze.primitiveLength++;
              Re.indexCount += Fe.length, Re.vertexCount += this.footprintVertices.length - Re.vertexOffset;
            }
            for (let Ve = 0; Ve < he.length; Ve++) {
              const Ue = he[Ve];
              C.startRing(k, Ue[0]);
              let Fe = Ue.length > 4 && l0(Ue[Ue.length - 2], Ue[0], Ue[1]), et = ie ? Nw(Ue[Ue.length - 2], Ue[0], Ue[1], ie) : 0;
              const dt = [];
              let tt, Tt, vt;
              Tt = Ue[1].sub(Ue[0])._perp()._unit();
              let Pt = !0;
              for (let rt = 1, Ut = 0; rt < Ue.length; rt++) {
                let St = Ue[rt - 1], Nt = Ue[rt];
                const Qt = Ue[rt === Ue.length - 1 ? 1 : rt + 1];
                if (C.appendEdge(k, Nt, St), T_(Nt, St, Me)) {
                  ie && (Tt = Qt.sub(Nt)._perp()._unit(), Pt = !Pt);
                  continue;
                }
                const pi = Nt.sub(St)._perp(), gi = pi.x / (Math.abs(pi.x) + Math.abs(pi.y)), Pi = pi.y > 0 ? 1 : 0, yi = St.dist(Nt);
                if (Ut + yi > 32768 && (Ut = 0), ie) {
                  vt = Qt.sub(Nt)._perp()._unit();
                  let hi = o0(St, Nt, Qt, r0(Tt, vt), ie);
                  isNaN(hi) && (hi = 0);
                  const on = Nt.sub(St)._unit();
                  St = St.add(on.mult(et))._round(), Nt = Nt.add(on.mult(-hi))._round(), et = hi, Tt = vt, V && this.zoom >= 17 && (de(dt, St) || dt.push(St), de(dt, Nt) || dt.push(Nt));
                }
                const Ii = ze.vertexLength, fn = Ue.length > 4 && l0(St, Nt, Qt);
                let rn = c0(Ut, Fe, Pt);
                if (Vd(this.layoutVertexArray, St.x, St.y, gi, Pi, 0, 0, rn), Vd(this.layoutVertexArray, St.x, St.y, gi, Pi, 0, 1, rn), this.wallMode) {
                  const hi = $(rt - 1, Ue), on = q.joinNormals[rt - 1];
                  Ud(this.wallVertexArray, on, hi), Ud(this.wallVertexArray, on, hi);
                }
                if (Ut += yi, rn = c0(Ut, fn, !Pt), Fe = fn, Vd(this.layoutVertexArray, Nt.x, Nt.y, gi, Pi, 0, 0, rn), Vd(this.layoutVertexArray, Nt.x, Nt.y, gi, Pi, 0, 1, rn), this.wallMode) {
                  const hi = $(rt, Ue), on = q.joinNormals[rt];
                  Ud(this.wallVertexArray, on, hi), Ud(this.wallVertexArray, on, hi);
                }
                if (ze.vertexLength += 4, this.indexArray.emplaceBack(Ii + 0, Ii + 1, Ii + 2), this.indexArray.emplaceBack(Ii + 1, Ii + 3, Ii + 2), ze.primitiveLength += 2, ie) {
                  const hi = me + (rt === 1 ? Ue.length - 2 : rt - 2), on = rt === 1 ? me : hi + 1;
                  if (this.indexArray.emplaceBack(Ii + 1, hi, Ii + 3), this.indexArray.emplaceBack(hi, on, Ii + 3), ze.primitiveLength += 2, tt === void 0 && (tt = Ii), !T_(Qt, Ue[rt], Me)) {
                    const Qi = rt === Ue.length - 1 ? tt : ze.vertexLength;
                    this.indexArray.emplaceBack(Ii + 2, Ii + 3, Qi), this.indexArray.emplaceBack(Ii + 3, Qi + 1, Qi), this.indexArray.emplaceBack(Ii + 3, on, Qi + 1), ze.primitiveLength += 3;
                  }
                  Pt = !Pt;
                }
                if (I) {
                  const hi = this.layoutVertexExtArray, on = E.projectTilePoint(St.x, St.y, u), Qi = E.projectTilePoint(Nt.x, Nt.y, u), pn = E.upVector(u, St.x, St.y), as = E.upVector(u, Nt.x, Nt.y);
                  jd(hi, on, pn), jd(hi, on, pn), jd(hi, Qi, as), jd(hi, Qi, as);
                }
              }
              S && (me += Ue.length - 1), V && ie && this.zoom >= 17 && (dt.length !== 0 && de(dt, dt[0]) && dt.pop(), this.groundEffect.addData(dt, Me, D, ie > 0));
            }
            this.footprintSegments.push(Re), Ie.triangleCount = this.indexArray.length - Ie.triangleArrayOffset, this.polygonSegments.push(Ie), ++k.footprintSegLen, ++k.polygonSegLen;
          }
          if (k.vertexCount = this.layoutVertexArray.length - k.vertexArrayOffset, k.groundVertexCount = this.groundEffect.vertexArray.length - k.groundVertexArrayOffset, k.vertexCount !== 0) {
            if (k.centroidXY = C.borders ? Qy : this.encodeCentroid(C, k), this.centroidData.push(k), C.borders) {
              this.featuresOnBorder.push(C);
              const he = this.featuresOnBorder.length - 1;
              for (let Me = 0; Me < C.borders.length; Me++)
                C.borders[Me][0] !== Number.MAX_VALUE && this.borderFeatureIndices[Me].push(he);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, d, u, M), this.groundEffect.addPaintPropertiesData(e, o, l, d, u, M), this.maxHeight = Math.max(this.maxHeight, U);
          }
        }
        sortBorders() {
          for (let e = 0; e < this.borderFeatureIndices.length; e++)
            this.borderFeatureIndices[e].sort((n, o) => this.featuresOnBorder[n].borders[e][0] - this.featuresOnBorder[o].borders[e][0]);
        }
        splitToSubtiles() {
          const e = [];
          for (let v = 0; v < this.centroidData.length; v++) {
            const M = this.centroidData[v], D = +(M.min.y + M.max.y > wt), x = 2 * D + (+(M.min.x + M.max.x > wt) ^ D);
            for (let E = 0; E < M.polygonSegLen; E++) {
              const I = M.polygonSegIdx + E;
              e.push({ centroidIdx: v, subtile: x, polygonSegmentIdx: I, triangleSegmentIdx: this.polygonSegments[I].triangleSegIdx });
            }
          }
          const n = new qs();
          e.sort((v, M) => v.triangleSegmentIdx === M.triangleSegmentIdx ? v.subtile - M.subtile : v.triangleSegmentIdx - M.triangleSegmentIdx);
          let o = 0, u = 0, l = 0;
          for (const v of e) {
            if (v.triangleSegmentIdx !== o)
              break;
            l++;
          }
          const d = e.length;
          for (; u !== e.length; ) {
            o = e[u].triangleSegmentIdx;
            let v = 0, M = u, D = u;
            for (let x = M; x < l && e[x].subtile === v; x++)
              D++;
            for (; M !== l; ) {
              const x = e[M];
              v = x.subtile;
              const E = this.centroidData[x.centroidIdx].min.clone(), I = this.centroidData[x.centroidIdx].max.clone(), S = { vertexOffset: this.segments.segments[o].vertexOffset, primitiveOffset: n.length, vertexLength: this.segments.segments[o].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let C = M; C < D; C++) {
                const k = e[C], V = this.polygonSegments[k.polygonSegmentIdx], U = this.centroidData[k.centroidIdx].min, q = this.centroidData[k.centroidIdx].max, $ = this.indexArray.uint16;
                for (let H = V.triangleArrayOffset; H < V.triangleArrayOffset + V.triangleCount; H++)
                  n.emplaceBack($[3 * H], $[3 * H + 1], $[3 * H + 2]);
                S.primitiveLength += V.triangleCount, E.x = Math.min(E.x, U.x), E.y = Math.min(E.y, U.y), I.x = Math.max(I.x, q.x), I.y = Math.max(I.y, q.y);
              }
              S.primitiveLength > 0 && this.triangleSubSegments.push({ segment: S, min: E, max: I }), M = D;
              for (let C = M; C < l && e[C].subtile === e[M].subtile; C++)
                D++;
            }
            u = l;
            for (let x = u; x < d && e[x].triangleSegmentIdx === e[u].triangleSegmentIdx; x++)
              l++;
          }
          n._trim(), this.indexArray = n;
        }
        getVisibleSegments(e, n, o) {
          const u = new Wn();
          if (this.wallMode) {
            for (const k of this.triangleSubSegments)
              u.segments.push(k.segment);
            return u;
          }
          let l = 0, d = 0;
          const v = 1 << e.canonical.z;
          if (n) {
            const k = n.getMinMaxForTile(e);
            k && (l = k.min, d = k.max);
          }
          d += this.maxHeight;
          const M = e.toUnwrapped();
          let D;
          const x = [M.canonical.x / v + M.wrap, M.canonical.y / v], E = [(M.canonical.x + 1) / v + M.wrap, (M.canonical.y + 1) / v], I = (k, V, U) => [k[0] * (1 - U[0]) + V[0] * U[0], k[1] * (1 - U[1]) + V[1] * U[1]], S = [], C = [];
          for (const k of this.triangleSubSegments) {
            S[0] = k.min.x / wt, S[1] = k.min.y / wt, C[0] = k.max.x / wt, C[1] = k.max.y / wt;
            const V = I(x, E, S), U = I(x, E, C);
            if (new Jt([V[0], V[1], l], [U[0], U[1], d]).intersectsPrecise(o) === 0) {
              D && (u.segments.push(D), D = void 0);
              continue;
            }
            const q = k.segment;
            D && D.vertexOffset !== q.vertexOffset && (u.segments.push(D), D = void 0), D ? (D.vertexLength += q.vertexLength, D.primitiveLength += q.primitiveLength) : D = { vertexOffset: q.vertexOffset, primitiveLength: q.primitiveLength, vertexLength: q.vertexLength, primitiveOffset: q.primitiveOffset, sortKey: void 0, vaos: {} };
          }
          return D && u.segments.push(D), u;
        }
        encodeCentroid(e, n) {
          const o = e.centroid(), u = n.span(), l = Math.min(7, Math.round(u.x * this.tileToMeter / 10)), d = Math.min(7, Math.round(u.y * this.tileToMeter / 10));
          return new Mt(si(o.x, 1, wt - 1) << 3 | l, si(o.y, 1, wt - 1) << 3 | d);
        }
        encodeBorderCentroid(e) {
          if (!e.borders)
            return new Mt(0, 0);
          const n = e.borders, o = Number.MAX_VALUE;
          if (n[0][0] !== o || n[1][0] !== o) {
            const u = n[0][0] !== o ? 0 : 1;
            return new Mt(6 | (n[0][0] !== o ? 0 : 65528), (n[u][0] + n[u][1]) / 2 << 3 | 6);
          }
          {
            const u = n[2][0] !== o ? 2 : 3;
            return new Mt((n[u][0] + n[u][1]) / 2 << 3 | 6, 6 | (n[2][0] !== o ? 0 : 65528));
          }
        }
        showCentroid(e) {
          const n = this.centroidData[e.centroidDataIndex];
          n.flags &= _c, n.centroidXY.x = 0, n.centroidXY.y = 0, this.writeCentroidToBuffer(n);
        }
        writeCentroidToBuffer(e) {
          this.groundEffect.updateHiddenByLandmark(e);
          const n = e.vertexArrayOffset, o = e.vertexCount + e.vertexArrayOffset, u = e.flags & _c ? Qy : e.centroidXY, l = this.centroidVertexArray.geta_centroid_pos0(n);
          if (this.centroidVertexArray.geta_centroid_pos1(n) !== u.y || l !== u.x) {
            for (let d = n; d < o; ++d)
              this.centroidVertexArray.emplace(d, u.x, u.y);
            this.needsCentroidUpdate = !0;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const e of this.centroidData)
            this.writeCentroidToBuffer(e);
        }
        updateReplacement(e, n, o) {
          if (n.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = n.updateTime;
          const u = n.getReplacementRegionsForTile(e.toUnwrapped());
          if (v_(this.activeReplacements, u))
            return;
          if (this.activeReplacements = u, this.centroidVertexArray.length === 0)
            this.createCentroidsBuffer();
          else
            for (const d of this.centroidData)
              d.flags &= 2147483647;
          const l = [];
          for (const d of this.activeReplacements) {
            if (d.order < o)
              continue;
            const v = Math.max(1, Math.pow(2, d.footprintTileId.canonical.z - e.canonical.z));
            for (const M of this.centroidData)
              if (!(M.flags & _c || d.min.x > M.max.x || M.min.x > d.max.x || d.min.y > M.max.y || M.min.y > d.max.y))
                for (let D = 0; D < M.footprintSegLen; D++) {
                  const x = this.footprintSegments[M.footprintSegIdx + D];
                  if (l.length = 0, Vw(this.footprintVertices, x.vertexOffset, x.vertexCount, d.footprintTileId.canonical, e.canonical, l), $y(d.footprint, l, this.footprintIndices.uint16, x.indexOffset, x.indexCount, -x.vertexOffset, -v)) {
                    M.flags |= _c;
                    break;
                  }
                }
          }
          for (const d of this.centroidData)
            this.writeCentroidToBuffer(d);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(e, n, o) {
          let u = !1;
          for (let l = 0; l < o.footprintSegLen; l++) {
            const d = this.footprintSegments[o.footprintSegIdx + l];
            let v = 0;
            for (const M of d.ringIndices) {
              for (let D = v, x = M + v - 1; D < M + v; x = D++) {
                const E = this.footprintVertices.int16[2 * (D + d.vertexOffset) + 0], I = this.footprintVertices.int16[2 * (D + d.vertexOffset) + 1], S = this.footprintVertices.int16[2 * (x + d.vertexOffset) + 1];
                I > n != S > n && e < (this.footprintVertices.int16[2 * (x + d.vertexOffset) + 0] - E) * (n - I) / (S - I) + E && (u = !u);
              }
              v = M;
            }
          }
          return u;
        }
        getHeightAtTileCoord(e, n) {
          let o = Number.NEGATIVE_INFINITY, u = !0;
          const l = 4 * (e + wt) * wt + (n + wt);
          if (this.partLookup.hasOwnProperty(l)) {
            const d = this.partLookup[l];
            return d ? { height: d.height, hidden: !!(d.flags & _c) } : void 0;
          }
          for (const d of this.centroidData)
            e > d.max.x || d.min.x > e || n > d.max.y || d.min.y > n || this.footprintContainsPoint(e, n, d) && d && d.height > o && (o = d.height, this.partLookup[l] = d, u = !!(d.flags & _c));
          if (o !== Number.NEGATIVE_INFINITY)
            return { height: o, hidden: u };
          this.partLookup[l] = void 0;
        }
      }
      function r0(r, e) {
        const n = r.add(e)._unit();
        return r.x * n.x + r.y * n.y;
      }
      function Nw(r, e, n, o) {
        const u = e.sub(r)._perp()._unit(), l = n.sub(e)._perp()._unit();
        return o0(r, e, n, r0(u, l), o);
      }
      function o0(r, e, n, o, u) {
        const l = Math.sqrt(1 - o * o);
        return Math.min(r.dist(e) / 3, e.dist(n) / 3, u * l / o);
      }
      function T_(r, e, n) {
        return r.x < n[0].x && e.x < n[0].x || r.x > n[1].x && e.x > n[1].x || r.y < n[0].y && e.y < n[0].y || r.y > n[1].y && e.y > n[1].y;
      }
      function a0(r, e) {
        return r.x < e[0].x || r.x > e[1].x || r.y < e[0].y || r.y > e[1].y;
      }
      function l0(r, e, n) {
        if (r.x < 0 || r.x >= wt || e.x < 0 || e.x >= wt || n.x < 0 || n.x >= wt)
          return !1;
        const o = n.sub(e), u = o.perp(), l = r.sub(e);
        return (o.x * l.x + o.y * l.y) / Math.sqrt((o.x * o.x + o.y * o.y) * (l.x * l.x + l.y * l.y)) > -0.866 && u.x * l.x + u.y * l.y < 0;
      }
      function c0(r, e, n) {
        const o = e ? 2 | r : -3 & r;
        return n ? 1 | o : -2 & o;
      }
      function h0() {
        const r = Math.PI / 32, e = Math.tan(r), n = pc;
        return n * Math.sqrt(1 + 2 * e * e) - n;
      }
      function u0(r, e, n) {
        const o = 1 << n.z, u = Fr(n.x / o), l = Fr((n.x + 1) / o), d = Os(n.y / o), v = Os((n.y + 1) / o);
        return function(M, D, x, E, I = 0, S) {
          const C = [];
          if (!M.length || !x || !E)
            return C;
          const k = (Q, ie) => {
            for (const fe of Q)
              C.push({ polygon: fe, bounds: ie });
          }, V = Math.ceil(Math.log2(x)), U = Math.ceil(Math.log2(E)), q = V - U, $ = [];
          for (let Q = 0; Q < Math.abs(q); Q++)
            $.push(q > 0 ? 0 : 1);
          for (let Q = 0; Q < Math.min(V, U); Q++)
            $.push(0), $.push(1);
          let H = M;
          if (H = bp(H, D[0].y - I, D[1].y + I, 1), H = bp(H, D[0].x - I, D[1].x + I, 0), !H.length)
            return C;
          const K = [];
          for ($.length ? K.push({ polygons: H, bounds: D, depth: 0 }) : k(H, D); K.length; ) {
            const Q = K.pop(), ie = Q.depth, fe = $[ie], de = Q.bounds[0], he = Q.bounds[1], Me = fe === 0 ? de.x : de.y, me = fe === 0 ? he.x : he.y, Ee = S ? S(fe, Me, me) : 0.5 * (Me + me), ze = bp(Q.polygons, Me - I, Ee + I, fe), Ie = bp(Q.polygons, Ee - I, me + I, fe);
            if (ze.length) {
              const Re = [de, new Mt(fe === 0 ? Ee : he.x, fe === 1 ? Ee : he.y)];
              $.length > ie + 1 ? K.push({ polygons: ze, bounds: Re, depth: ie + 1 }) : k(ze, Re);
            }
            if (Ie.length) {
              const Re = [new Mt(fe === 0 ? Ee : de.x, fe === 1 ? Ee : de.y), he];
              $.length > ie + 1 ? K.push({ polygons: Ie, bounds: Re, depth: ie + 1 }) : k(Ie, Re);
            }
          }
          return C;
        }(r, e, Math.ceil((l - u) / 11.25), Math.ceil((d - v) / 11.25), 1, (M, D, x) => {
          if (M === 0)
            return 0.5 * (D + x);
          {
            const E = Os((n.y + D / wt) / o);
            return (wa(0.5 * (Os((n.y + x / wt) / o) + E)) * o - n.y) * wt;
          }
        });
      }
      function Vw(r, e, n, o, u, l) {
        const d = Math.pow(2, o.z - u.z);
        for (let v = 0; v < n; v++) {
          let M = r.int16[2 * (v + e) + 0], D = r.int16[2 * (v + e) + 1];
          M = (M + u.x * wt) * d - o.x * wt, D = (D + u.y * wt) * d - o.y * wt, l.push(new Mt(M, D));
        }
      }
      let d0, f0;
      function Gd(r, e) {
        return r.x * e.x + r.y * e.y;
      }
      function p0(r, e) {
        if (r.length === 1) {
          let n = 0;
          const o = e[n++];
          let u;
          for (; !u || o.equals(u); )
            if (u = e[n++], !u)
              return 1 / 0;
          for (; n < e.length; n++) {
            const l = e[n], d = r[0], v = u.sub(o), M = l.sub(o), D = d.sub(o), x = Gd(v, v), E = Gd(v, M), I = Gd(M, M), S = Gd(D, v), C = Gd(D, M), k = x * I - E * E, V = (I * S - E * C) / k, U = (x * C - E * S) / k, q = o.z * (1 - V - U) + u.z * V + l.z * U;
            if (isFinite(q))
              return q;
          }
          return 1 / 0;
        }
        {
          let n = 1 / 0;
          for (const o of e)
            n = Math.min(n, o.z);
          return n;
        }
      }
      function m0(r, e, n, o, u, l, d, v) {
        const M = d * u.getElevationAt(r, e, !0, !0), D = l[0] !== 0, x = D ? l[1] === 0 ? d * (l[0] / 7 - 450) : d * function(E, I, S) {
          const C = Math.floor(I[0] / 8), k = Math.floor(I[1] / 8), V = 10 * (I[0] - 8 * C), U = 10 * (I[1] - 8 * k), q = E.getElevationAt(C, k, !0, !0), $ = E.getMeterToDEM(S), H = Math.floor(0.5 * (V * $ - 1)), K = Math.floor(0.5 * (U * $ - 1)), Q = E.tileCoordToPixel(C, k), ie = 2 * H + 1, fe = 2 * K + 1, de = function(Ie, Re, Ve, Ue, Fe) {
            return [Ie.getElevationAtPixel(Re, Ve, !0), Ie.getElevationAtPixel(Re + Fe, Ve, !0), Ie.getElevationAtPixel(Re, Ve + Fe, !0), Ie.getElevationAtPixel(Re + Ue, Ve + Fe, !0)];
          }(E, Q.x - H, Q.y - K, ie, fe), he = Math.abs(de[0] - de[1]), Me = Math.abs(de[2] - de[3]), me = Math.abs(de[0] - de[2]) + Math.abs(de[1] - de[3]), Ee = Math.min(0.25, 0.5 * $ * (he + Me) / ie), ze = Math.min(0.25, 0.5 * $ * me / fe);
          return q + Math.max(Ee * V, ze * U);
        }(u, l, v) : M;
        return { base: M + (n === 0 ? -1 : n), top: D ? Math.max(x + o, M + n + 2) : M + o };
      }
      Ft(Mp, "FillExtrusionBucket", { omit: ["layers", "features"] }), Ft(t0, "PartData"), Ft(e0, "FootprintSegment"), Ft(i0, "BorderCentroidData"), Ft(s0, "GroundEffect");
      const Uw = qi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), jw = qi([{ name: "a_z_offset_width", components: 2, type: "Float32" }], 4), { members: Gw } = Uw, Zw = qi([{ name: "a_packed", components: 4, type: "Float32" }]), { members: Hw } = Zw, qw = qi([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Ww } = qw;
      class _0 {
        constructor(e, n) {
          this.width = e, this.height = n, this.nextRow = 0, this.image = new mc({ width: e, height: n }), this.positions = {}, this.uploaded = !1;
        }
        getDash(e, n) {
          const o = this.getKey(e, n);
          return this.positions[o];
        }
        trim() {
          const e = this.width, n = this.height = yo(this.nextRow);
          this.image.resize({ width: e, height: n });
        }
        getKey(e, n) {
          return e.join(",") + n;
        }
        getDashRanges(e, n, o) {
          const u = [];
          let l = e.length % 2 == 1 ? -e[e.length - 1] * o : 0, d = e[0] * o, v = !0;
          u.push({ left: l, right: d, isDash: v, zeroLength: e[0] === 0 });
          let M = e[0];
          for (let D = 1; D < e.length; D++) {
            v = !v;
            const x = e[D];
            l = M * o, M += x, d = M * o, u.push({ left: l, right: d, isDash: v, zeroLength: x === 0 });
          }
          return u;
        }
        addRoundDash(e, n, o) {
          const u = n / 2;
          for (let l = -o; l <= o; l++) {
            const d = this.width * (this.nextRow + o + l);
            let v = 0, M = e[v];
            for (let D = 0; D < this.width; D++) {
              D / M.right > 1 && (M = e[++v]);
              const x = Math.abs(D - M.left), E = Math.abs(D - M.right), I = Math.min(x, E);
              let S;
              const C = l / o * (u + 1);
              if (M.isDash) {
                const k = u - Math.abs(C);
                S = Math.sqrt(I * I + k * k);
              } else
                S = u - Math.sqrt(I * I + C * C);
              this.image.data[d + D] = Math.max(0, Math.min(255, S + 128));
            }
          }
        }
        addRegularDash(e, n) {
          for (let M = e.length - 1; M >= 0; --M) {
            const D = e[M], x = e[M + 1];
            D.zeroLength ? e.splice(M, 1) : x && x.isDash === D.isDash && (x.left = D.left, e.splice(M, 1));
          }
          const o = e[0], u = e[e.length - 1];
          o.isDash === u.isDash && (o.left = u.left - this.width, u.right = o.right + this.width);
          const l = this.width * this.nextRow;
          let d = 0, v = e[d];
          for (let M = 0; M < this.width; M++) {
            M / v.right > 1 && (v = e[++d]);
            const D = Math.abs(M - v.left), x = Math.abs(M - v.right), E = Math.min(D, x);
            this.image.data[l + M] = Math.max(0, Math.min(255, (v.isDash ? E : -E) + n + 128));
          }
        }
        addDash(e, n) {
          const o = this.getKey(e, n);
          if (this.positions[o])
            return this.positions[o];
          const u = n === "round", l = u ? 7 : 0, d = 2 * l + 1;
          if (this.nextRow + d > this.height)
            return mi("LineAtlas out of space"), null;
          e.length === 0 && e.push(1);
          let v = 0;
          for (let x = 0; x < e.length; x++)
            e[x] < 0 && (mi("Negative value is found in line dasharray, replacing values with 0"), e[x] = 0), v += e[x];
          if (v !== 0) {
            const x = this.width / v, E = this.getDashRanges(e, this.width, x);
            u ? this.addRoundDash(E, x, l) : this.addRegularDash(E, n === "square" ? 0.5 * x : 0);
          }
          const M = this.nextRow + l;
          this.nextRow += d;
          const D = { tl: [M, l], br: [v, 0] };
          return this.positions[o] = D, D;
        }
      }
      Ft(_0, "LineAtlas");
      const $w = Pu.VectorTileFeature.types, Xw = Math.cos(Math.PI / 180 * 37.5), Yw = Math.cos(Math.PI / 180 * 5);
      class S_ {
        constructor(e) {
          this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.zoom = e.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.index = e.index, this.projection = e.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((n) => {
            this.gradients[n.id] = {};
          }), this.layoutVertexArray = new ho(), this.layoutVertexArray2 = new Wa(), this.patternVertexArray = new xa(), this.indexArray = new qs(), this.programConfigurations = new Ka(e.layers, { zoom: e.zoom, lut: e.lut }), this.segments = new Wn(), this.maxLineLength = 0, this.zOffsetVertexArray = new Ml(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.tessellationStep = e.tessellationStep ? e.tessellationStep : wt / 64;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.hasPattern = d_("line", this.layers, n);
          const l = this.layers[0].layout.get("line-sort-key");
          this.tileToMeter = s(o), this.hasZOffset = !this.layers[0].isDraped();
          const d = this.layers[0].layout.get("line-elevation-reference");
          this.hasZOffset && d === "none" && mi(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
          const v = this.layers[0].layout.get("line-cross-slope");
          this.hasCrossSlope = this.hasZOffset && v !== void 0;
          const M = [];
          for (const { feature: I, id: S, index: C, sourceLayerIndex: k } of e) {
            const V = this.layers[0]._featureFilter.needGeometry, U = G(I, V);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), U, o))
              continue;
            const q = l ? l.evaluate(U, {}, o) : void 0, $ = { id: S, properties: I.properties, type: I.type, sourceLayerIndex: k, index: C, geometry: V ? U.geometry : j(I, o, u), patterns: {}, sortKey: q };
            M.push($);
          }
          l && M.sort((I, S) => I.sortKey - S.sortKey);
          const { lineAtlas: D, featureIndex: x } = n, E = this.addConstantDashes(D);
          for (const I of M) {
            const { geometry: S, index: C, sourceLayerIndex: k } = I;
            if (E && this.addFeatureDashes(I, D), this.hasPattern) {
              const V = f_("line", this.layers, I, this.zoom, n);
              this.patternFeatures.push(V);
            } else
              this.addFeature(I, S, C, o, D.positions, n.availableImages, n.brightness);
            x.insert(e[C].feature, S, C, k, this.index);
          }
        }
        addConstantDashes(e) {
          let n = !1;
          for (const o of this.layers) {
            const u = o.paint.get("line-dasharray").value, l = o.layout.get("line-cap").value;
            if (u.kind !== "constant" || l.kind !== "constant")
              n = !0;
            else {
              const d = l.value, v = u.value;
              if (!v)
                continue;
              e.addDash(v, d);
            }
          }
          return n;
        }
        addFeatureDashes(e, n) {
          const o = this.zoom;
          for (const u of this.layers) {
            const l = u.paint.get("line-dasharray").value, d = u.layout.get("line-cap").value;
            if (l.kind === "constant" && d.kind === "constant")
              continue;
            let v, M;
            if (l.kind === "constant") {
              if (v = l.value, !v)
                continue;
            } else
              v = l.evaluate({ zoom: o }, e);
            M = d.kind === "constant" ? d.value : d.evaluate({ zoom: o }, e), n.addDash(v, M), e.patterns[u.id] = n.getKey(v, M);
          }
        }
        update(e, n, o, u, l, d, v) {
          this.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v);
        }
        addFeatures(e, n, o, u, l, d) {
          for (const v of this.patternFeatures)
            this.addFeature(v, v.geometry, v.index, n, o, u, d);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(e) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = e.createVertexBuffer(this.layoutVertexArray2, Hw)), this.patternVertexArray.length !== 0 && (this.patternVertexBuffer = e.createVertexBuffer(this.patternVertexArray, Ww)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, jw.members, !0)), this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Gw), this.indexBuffer = e.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(e), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(e) {
          if (e.properties && e.properties.hasOwnProperty("mapbox_clip_start") && e.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +e.properties.mapbox_clip_start, end: +e.properties.mapbox_clip_end };
        }
        addFeature(e, n, o, u, l, d, v) {
          const M = this.layers[0].layout, D = M.get("line-join").evaluate(e, {}), x = M.get("line-cap").evaluate(e, {}), E = M.get("line-miter-limit"), I = M.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(e), this.lineFeature = e, this.zOffsetValue = M.get("line-z-offset").value;
          const S = this.layers[0].paint.get("line-width").value;
          S.kind !== "constant" && S.isLineProgressConstant === !1 && (this.variableWidthValue = S);
          for (const C of n)
            this.addLine(C, e, u, D, x, E, I);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, e, o, l, d, u, v);
        }
        addLine(e, n, o, u, l, d, v) {
          this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
          const M = u === "none";
          if (this.patternJoinNone = this.hasPattern && M, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let $ = 0; $ < e.length - 1; $++)
              this.totalDistance += e[$].dist(e[$ + 1]);
            this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const D = $w[n.type] === "Polygon";
          let x = e.length;
          for (; x >= 2 && e[x - 1].equals(e[x - 2]); )
            x--;
          let E = 0;
          for (; E < x - 1 && e[E].equals(e[E + 1]); )
            E++;
          if (x < (D ? 3 : 2))
            return;
          u === "bevel" && (d = 1.05);
          const I = this.segments.prepareSegment(10 * x, this.layoutVertexArray, this.indexArray);
          let S, C, k, V, U, q;
          this.e1 = this.e2 = -1, D && (S = e[x - 2], U = e[E].sub(S)._unit()._perp());
          for (let $ = E; $ < x; $++) {
            if (k = $ === x - 1 ? D ? e[E + 1] : void 0 : e[$ + 1], k && e[$].equals(k))
              continue;
            U && (V = U), S && (C = S), S = e[$], q = this.evaluateLineProgressFeatures(C ? C.dist(S) : 0), U = k ? k.sub(S)._unit()._perp() : V, V = V || U;
            const H = C && k;
            let K = H ? u : D || M ? "butt" : l;
            const Q = V.x * U.x + V.y * U.y;
            if (M) {
              const ze = function(Ie) {
                if (Ie.patternJoinNone) {
                  const Re = Ie.segmentPoints.length / 2, Ve = Ie.lineSoFar - Ie.segmentStart;
                  for (let Ue = 0; Ue < Re; ++Ue) {
                    const Fe = Ie.segmentPoints[2 * Ue + 1], et = Math.round(Ie.segmentPoints[2 * Ue]) + 0.5 + 0.25 * Fe;
                    Ie.patternVertexArray.emplaceBack(et, Ve, Ie.segmentStart), Ie.patternVertexArray.emplaceBack(et, Ve, Ie.segmentStart);
                  }
                  Ie.segmentPoints.length = 0;
                }
                Ie.e1 = Ie.e2 = -1;
              };
              if (H && Q < Yw) {
                this.updateDistance(C, S), this.addCurrentVertex(S, V, 1, 1, I, q), ze(this), this.addCurrentVertex(S, U, -1, -1, I, q);
                continue;
              }
              if (C) {
                if (!k) {
                  this.updateDistance(C, S), this.addCurrentVertex(S, V, 1, 1, I, q), ze(this);
                  continue;
                }
                K = "miter";
              }
            }
            let ie = V.add(U);
            ie.x === 0 && ie.y === 0 || ie._unit();
            const fe = ie.x * U.x + ie.y * U.y, de = fe !== 0 ? 1 / fe : 1 / 0, he = 2 * Math.sqrt(2 - 2 * fe), Me = fe < Xw && C && k, me = V.x * U.y - V.y * U.x > 0, Ee = this.overscaling <= 16 ? 15 * wt / (512 * this.overscaling) : 0;
            if (H && K === "round") {
              if (de < v)
                K = "miter";
              else if (de <= 2) {
                const ze = M_(S, -10, wt + 10);
                K = this.hasZOffset && (ze || this.hasCrossSlope) ? "miter" : "fakeround";
              }
            }
            if (K === "miter" && de > d && (K = "bevel"), K === "bevel" && (de > 2 && (K = "flipbevel"), de < d && (K = "miter")), C && !(K === "miter" && Me) && this.updateDistance(C, S), K === "miter")
              if (Me) {
                const ze = S.dist(C);
                if (ze > 2 * Ee) {
                  const Re = S.sub(S.sub(C)._mult(Ee / ze)._round());
                  this.updateDistance(C, Re), this.addCurrentVertex(Re, V, 0, 0, I, q), C = Re;
                }
                this.updateDistance(C, S), ie._mult(de), this.addCurrentVertex(S, ie, 0, 0, I, q);
                const Ie = S.dist(k);
                if (Ie > 2 * Ee) {
                  const Re = S.add(k.sub(S)._mult(Ee / Ie)._round());
                  this.updateDistance(S, Re), this.addCurrentVertex(Re, U, 0, 0, I, q), S = Re;
                }
              } else
                ie._mult(de), this.addCurrentVertex(S, ie, 0, 0, I, q);
            else if (K === "flipbevel") {
              if (de > 100)
                ie = U.mult(-1);
              else {
                const ze = de * V.add(U).mag() / V.sub(U).mag();
                ie._perp()._mult(ze * (me ? -1 : 1));
              }
              this.addCurrentVertex(S, ie, 0, 0, I, q), this.addCurrentVertex(S, ie.mult(-1), 0, 0, I, q);
            } else if (K === "bevel" || K === "fakeround") {
              q != null && C && this.addCurrentVertex(S, V, -1, -1, I, q);
              const ze = S.dist(C) <= 2 * Ee && K !== "bevel", Ie = ie.mult(me ? 1 : -1);
              Ie._mult(de);
              const Re = U.mult(me ? -1 : 1), Ve = V.mult(me ? -1 : 1), Ue = this.evaluateLineProgressFeatures(this.distance);
              if (q == null && (this.addHalfVertex(S, Ie.x, Ie.y, !1, !me, 0, I, Ue), ze || this.addHalfVertex(S, Ie.x + 2 * Ve.x, Ie.y + 2 * Ve.y, !1, me, 0, I, Ue)), K === "fakeround") {
                const Fe = Math.round(180 * he / Math.PI / 20);
                this.addHalfVertex(S, Ve.x, Ve.y, !1, me, 0, I, Ue);
                for (let et = 0; et < Fe; et++) {
                  let dt = et / Fe;
                  if (dt !== 0.5) {
                    const Tt = dt - 0.5;
                    dt += dt * Tt * (dt - 1) * ((1.0904 + Q * (Q * (3.55645 - 1.43519 * Q) - 3.2452)) * Tt * Tt + (0.848013 + Q * (0.215638 * Q - 1.06021)));
                  }
                  const tt = Re.sub(Ve)._mult(dt)._add(Ve)._unit();
                  this.addHalfVertex(S, tt.x, tt.y, !1, me, 0, I, Ue);
                }
                this.addHalfVertex(S, Re.x, Re.y, !1, me, 0, I, Ue);
              }
              ze || q != null || this.addHalfVertex(S, Ie.x + 2 * Re.x, Ie.y + 2 * Re.y, !1, me, 0, I, Ue), q != null && k && this.addCurrentVertex(S, U, 1, 1, I, q);
            } else
              K === "butt" ? this.addCurrentVertex(S, ie, 0, 0, I, q) : K === "square" ? (C || this.addCurrentVertex(S, ie, -1, -1, I, q), this.addCurrentVertex(S, ie, 0, 0, I, q), C && this.addCurrentVertex(S, ie, 1, 1, I, q)) : K === "round" && (C && (this.addCurrentVertex(S, V, 0, 0, I, q), this.addCurrentVertex(S, V, 1, 1, I, q, !0)), k && (this.addCurrentVertex(S, U, -1, -1, I, q, !0), this.addCurrentVertex(S, U, 0, 0, I, q)));
          }
        }
        addVerticesTo(e, n, o, u, l, d, v, M, D, x) {
          const E = (n.w - e.w) / this.tessellationStep | 0;
          let I = 0;
          const S = this.scaledDistance;
          if (E > 1) {
            this.lineSoFar = e.w;
            const k = (n.x - e.x) / E, V = (n.y - e.y) / E, U = (n.z - e.z) / E, q = (n.w - e.w) / E;
            for (let $ = 1; $ < E; ++$) {
              e.x += k, e.y += V, e.z += U, this.lineSoFar += q, I += q;
              const H = this.evaluateLineProgressFeatures(this.prevDistance + I);
              this.scaledDistance = (this.prevDistance + I) / this.totalDistance, this.addHalfVertex(e, o, u, x, !1, v, D, H), this.addHalfVertex(e, l, d, x, !0, -M, D, H);
            }
          }
          this.lineSoFar = n.w, this.scaledDistance = S;
          const C = this.evaluateLineProgressFeatures(this.distance);
          this.addHalfVertex(n, o, u, x, !1, v, D, C), this.addHalfVertex(n, l, d, x, !0, -M, D, C);
        }
        evaluateLineProgressFeatures(e) {
          if (!this.variableWidthValue && !this.hasZOffset)
            return null;
          this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + e) / this.totalFeatureLength) : mi(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
          let n = 0;
          return this.variableWidthValue && this.variableWidthValue.kind !== "constant" && (n = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? this.zOffsetValue.kind === "constant" ? { zOffset: this.zOffsetValue.value, variableWidth: n } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: n } : { zOffset: 0, variableWidth: n };
        }
        addCurrentVertex(e, n, o, u, l, d, v = !1) {
          const M = n.x + n.y * o, D = n.y - n.x * o, x = n.y * u - n.x, E = -n.y - n.x * u;
          if (d != null) {
            const I = this.hasZOffset, S = -10, C = wt + 10, k = d.zOffset, V = new jy(e.x, e.y, k, this.lineSoFar), U = !!I && M_(e, S, C), q = this.lineSoFar, $ = this.distance;
            if (this.currentVertex)
              if (U) {
                const H = this.currentVertexIsOutside, K = this.currentVertex, Q = new jy(e.x, e.y, k, this.lineSoFar);
                if (Zy(K, Q, S, C), !M_(Q, S, C)) {
                  if (H) {
                    this.e1 = this.e2 = -1, this.distance -= K.dist(V), this.lineSoFar = K.w;
                    const ie = this.evaluateLineProgressFeatures(K.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(K, M, D, v, !1, o, l, ie), this.addHalfVertex(K, x, E, v, !0, -u, l, ie), this.prevDistance = this.distance;
                  }
                  this.distance = this.prevDistance + K.dist(Q), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(K, Q, M, D, x, E, o, u, l, v), this.distance = $, this.scaledDistance = this.distance / this.totalDistance;
                }
              } else {
                const H = this.currentVertex;
                if (this.currentVertexIsOutside) {
                  Zy(H, V, S, C), this.e1 = this.e2 = -1, this.distance -= H.dist(V), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = H.w;
                  const K = this.evaluateLineProgressFeatures(H.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                  this.addHalfVertex(H, M, D, v, !1, o, l, K), this.addHalfVertex(H, x, E, v, !0, -u, l, K), this.prevDistance = this.distance, this.distance = $, this.scaledDistance = this.distance / this.totalDistance;
                }
                this.addVerticesTo(H, V, M, D, x, E, o, u, l, v);
              }
            else
              U || (this.addHalfVertex(e, M, D, v, !1, o, l, d), this.addHalfVertex(e, x, E, v, !0, -u, l, d));
            this.currentVertex = V, this.currentVertexIsOutside = U, this.lineSoFar = q;
          } else
            this.addHalfVertex(e, M, D, v, !1, o, l, d), this.addHalfVertex(e, x, E, v, !0, -u, l, d);
        }
        addHalfVertex({ x: e, y: n }, o, u, l, d, v, M, D) {
          this.patternJoinNone && (this.segmentPoints.length === 0 && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), d || this.segmentPoints.push(this.lineSoFar - this.segmentStart, v)), this.layoutVertexArray.emplaceBack((e << 1) + (l ? 1 : 0), (n << 1) + (d ? 1 : 0), Math.round(63 * o) + 128, Math.round(63 * u) + 128, 1 + (v === 0 ? 0 : v < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const x = M.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, x), M.primitiveLength++), d ? this.e2 = x : this.e1 = x, D != null && this.zOffsetVertexArray.emplaceBack(D.zOffset, D.variableWidth);
        }
        updateScaledDistance() {
          this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
        }
        updateDistance(e, n) {
          this.prevDistance = this.distance, this.distance += e.dist(n), this.updateScaledDistance();
        }
      }
      function M_(r, e, n) {
        return r.x < e || r.x > n || r.y < e || r.y > n;
      }
      let g0, y0;
      function x0(r, e, n) {
        return e * (wt / (r.tileSize * Math.pow(2, n - r.tileID.overscaledZ)));
      }
      Ft(S_, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
      const v0 = (r, e, n) => (1 - n) * r + n * e;
      function b0(r, e) {
        return 1 / x0(r, 1, e.tileZoom);
      }
      function w0(r, e, n, o) {
        return r.translatePosMatrix(o || e.tileID.projMatrix, e, n.paint.get("line-translate"), n.paint.get("line-translate-anchor"));
      }
      const T0 = (r) => {
        const e = [];
        S0(r) && e.push("RENDER_LINE_DASH"), r.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
        const n = r.paint.get("line-trim-offset");
        n[0] === 0 && n[1] === 0 || e.push("RENDER_LINE_TRIM_OFFSET"), r.paint.get("line-border-width").constantOr(1) !== 0 && e.push("RENDER_LINE_BORDER");
        const o = r.layout.get("line-join").constantOr("miter") === "none", u = !!r.paint.get("line-pattern").constantOr(1);
        return o && u && e.push("LINE_JOIN_NONE"), e;
      };
      function S0(r) {
        const e = r.paint.get("line-dasharray").value;
        return e.value || e.kind !== "constant";
      }
      let E_;
      const M0 = () => E_ || (E_ = { layout: g0 || (g0 = new Bn({ "line-cap": new Dt($e.layout_line["line-cap"]), "line-join": new Dt($e.layout_line["line-join"]), "line-miter-limit": new gt($e.layout_line["line-miter-limit"]), "line-round-limit": new gt($e.layout_line["line-round-limit"]), "line-sort-key": new Dt($e.layout_line["line-sort-key"]), "line-z-offset": new Dt($e.layout_line["line-z-offset"]), "line-elevation-reference": new gt($e.layout_line["line-elevation-reference"]), "line-cross-slope": new gt($e.layout_line["line-cross-slope"]), visibility: new gt($e.layout_line.visibility), "line-width-unit": new gt($e.layout_line["line-width-unit"]) })), paint: y0 || (y0 = new Bn({ "line-opacity": new Dt($e.paint_line["line-opacity"]), "line-color": new Dt($e.paint_line["line-color"]), "line-translate": new gt($e.paint_line["line-translate"]), "line-translate-anchor": new gt($e.paint_line["line-translate-anchor"]), "line-width": new Dt($e.paint_line["line-width"]), "line-gap-width": new Dt($e.paint_line["line-gap-width"]), "line-offset": new Dt($e.paint_line["line-offset"]), "line-blur": new Dt($e.paint_line["line-blur"]), "line-dasharray": new Dt($e.paint_line["line-dasharray"]), "line-pattern": new Dt($e.paint_line["line-pattern"]), "line-gradient": new Ha($e.paint_line["line-gradient"]), "line-trim-offset": new gt($e.paint_line["line-trim-offset"]), "line-trim-fade-range": new gt($e.paint_line["line-trim-fade-range"]), "line-trim-color": new gt($e.paint_line["line-trim-color"]), "line-emissive-strength": new gt($e.paint_line["line-emissive-strength"]), "line-border-width": new Dt($e.paint_line["line-border-width"]), "line-border-color": new Dt($e.paint_line["line-border-color"]), "line-occlusion-opacity": new gt($e.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, E_);
      class Kw extends Dt {
        possiblyEvaluate(e, n) {
          return n = new Tn(Math.floor(n.zoom), { now: n.now, fadeDuration: n.fadeDuration, transition: n.transition }), super.possiblyEvaluate(e, n);
        }
        evaluate(e, n, o, u) {
          return n = Pn({}, n, { zoom: Math.floor(n.zoom) }), super.evaluate(e, n, o, u);
        }
      }
      let Zd;
      function E0(r, e) {
        return e > 0 ? e + 2 * r : r;
      }
      const Jw = qi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Qw = qi([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), eT = qi([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
      qi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const tT = qi([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), iT = qi([{ name: "a_texb", components: 2, type: "Uint16" }]), nT = qi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), sT = qi([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
      qi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const A0 = qi([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), rT = qi([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      qi([{ name: "triangle", components: 3, type: "Uint16" }]), qi([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), qi([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }]), qi([{ type: "Float32", name: "offsetX" }]), qi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
      var er = 24;
      const Sa = 128;
      function Ep(r, e, n, o, u) {
        if (r.kind === "camera")
          return r.maxSize;
        if (r.kind === "composite") {
          const l = e.possiblyEvaluate(new Tn(r.maxZoom), n).evaluate(u, {}, n), d = e.possiblyEvaluate(new Tn(r.minZoom), n).evaluate(u, {}, n);
          return Math.max(l, d);
        }
        return e.possiblyEvaluate(new Tn(o)).evaluate(u, {}, n);
      }
      function A_(r, e) {
        const { expression: n } = e;
        if (n.kind === "constant")
          return { kind: "constant", layoutSize: n.evaluate(new Tn(r + 1)) };
        if (n.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: o, interpolationType: u } = n;
          let l = 0;
          for (; l < o.length && o[l] <= r; )
            l++;
          l = Math.max(0, l - 1);
          let d = l;
          for (; d < o.length && o[d] < r + 1; )
            d++;
          d = Math.min(o.length - 1, d);
          const v = o[l], M = o[d];
          return n.kind === "composite" ? { kind: "composite", minZoom: v, maxZoom: M, interpolationType: u } : { kind: "camera", minZoom: v, maxZoom: M, minSize: n.evaluate(new Tn(v)), maxSize: n.evaluate(new Tn(M)), interpolationType: u };
        }
      }
      function Ap(r, { uSize: e, uSizeT: n }, { lowerSize: o, upperSize: u }) {
        return r.kind === "source" ? o / Sa : r.kind === "composite" ? ei(o / Sa, u / Sa, n) : e;
      }
      function Cu(r, e, n = 1) {
        let o = 0, u = 0;
        if (r.kind === "constant")
          u = r.layoutSize * n;
        else if (r.kind !== "source") {
          const { interpolationType: l, minZoom: d, maxZoom: v } = r, M = l ? si(X.interpolationFactor(l, e, d, v), 0, 1) : 0;
          r.kind === "camera" ? u = ei(r.minSize, r.maxSize, M) * n : o = M * n;
        }
        return { uSizeT: o, uSize: u };
      }
      var oT = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: Sa, evaluateSizeForFeature: Ap, evaluateSizeForZoom: Cu, getRasterizedIconSize: Ep, getSizeData: A_ });
      function aT(r, e, n) {
        return r.sections.forEach((o) => {
          o.text = function(u, l, d) {
            const v = l.layout.get("text-transform").evaluate(d, {});
            return v === "uppercase" ? u = u.toLocaleUpperCase() : v === "lowercase" && (u = u.toLocaleLowerCase()), co.applyArabicShaping && (u = co.applyArabicShaping(u)), u;
          }(o.text, e, n);
        }), r;
      }
      const Hd = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂", "←": "↑", "→": "↓" };
      function lT(r) {
        return r === "︶" || r === "﹈" || r === "︸" || r === "﹄" || r === "﹂" || r === "︾" || r === "︼" || r === "︺" || r === "︘" || r === "﹀" || r === "︐" || r === "︓" || r === "︔" || r === "｀" || r === "￣" || r === "︑" || r === "︒";
      }
      function cT(r) {
        return r === "︵" || r === "﹇" || r === "︷" || r === "﹃" || r === "﹁" || r === "︽" || r === "︻" || r === "︹" || r === "︗" || r === "︿";
      }
      var P0, P_, C0, C_ = {};
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      function hT() {
        return P0 || (P0 = 1, C_.read = function(r, e, n, o, u) {
          var l, d, v = 8 * u - o - 1, M = (1 << v) - 1, D = M >> 1, x = -7, E = n ? u - 1 : 0, I = n ? -1 : 1, S = r[e + E];
          for (E += I, l = S & (1 << -x) - 1, S >>= -x, x += v; x > 0; l = 256 * l + r[e + E], E += I, x -= 8)
            ;
          for (d = l & (1 << -x) - 1, l >>= -x, x += o; x > 0; d = 256 * d + r[e + E], E += I, x -= 8)
            ;
          if (l === 0)
            l = 1 - D;
          else {
            if (l === M)
              return d ? NaN : 1 / 0 * (S ? -1 : 1);
            d += Math.pow(2, o), l -= D;
          }
          return (S ? -1 : 1) * d * Math.pow(2, l - o);
        }, C_.write = function(r, e, n, o, u, l) {
          var d, v, M, D = 8 * l - u - 1, x = (1 << D) - 1, E = x >> 1, I = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = o ? 0 : l - 1, C = o ? 1 : -1, k = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
          for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (v = isNaN(e) ? 1 : 0, d = x) : (d = Math.floor(Math.log(e) / Math.LN2), e * (M = Math.pow(2, -d)) < 1 && (d--, M *= 2), (e += d + E >= 1 ? I / M : I * Math.pow(2, 1 - E)) * M >= 2 && (d++, M /= 2), d + E >= x ? (v = 0, d = x) : d + E >= 1 ? (v = (e * M - 1) * Math.pow(2, u), d += E) : (v = e * Math.pow(2, E - 1) * Math.pow(2, u), d = 0)); u >= 8; r[n + S] = 255 & v, S += C, v /= 256, u -= 8)
            ;
          for (d = d << u | v, D += u; D > 0; r[n + S] = 255 & d, S += C, d /= 256, D -= 8)
            ;
          r[n + S - C] |= 128 * k;
        }), C_;
      }
      function I0() {
        if (C0)
          return P_;
        C0 = 1, P_ = e;
        var r = hT();
        function e(H) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(H) ? H : new Uint8Array(H || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
        var n = 4294967296, o = 1 / n, u = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
        function l(H) {
          return H.type === e.Bytes ? H.readVarint() + H.pos : H.pos + 1;
        }
        function d(H, K, Q) {
          return Q ? 4294967296 * K + (H >>> 0) : 4294967296 * (K >>> 0) + (H >>> 0);
        }
        function v(H, K, Q) {
          var ie = K <= 16383 ? 1 : K <= 2097151 ? 2 : K <= 268435455 ? 3 : Math.floor(Math.log(K) / (7 * Math.LN2));
          Q.realloc(ie);
          for (var fe = Q.pos - 1; fe >= H; fe--)
            Q.buf[fe + ie] = Q.buf[fe];
        }
        function M(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeVarint(H[Q]);
        }
        function D(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSVarint(H[Q]);
        }
        function x(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFloat(H[Q]);
        }
        function E(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeDouble(H[Q]);
        }
        function I(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeBoolean(H[Q]);
        }
        function S(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFixed32(H[Q]);
        }
        function C(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSFixed32(H[Q]);
        }
        function k(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeFixed64(H[Q]);
        }
        function V(H, K) {
          for (var Q = 0; Q < H.length; Q++)
            K.writeSFixed64(H[Q]);
        }
        function U(H, K) {
          return (H[K] | H[K + 1] << 8 | H[K + 2] << 16) + 16777216 * H[K + 3];
        }
        function q(H, K, Q) {
          H[Q] = K, H[Q + 1] = K >>> 8, H[Q + 2] = K >>> 16, H[Q + 3] = K >>> 24;
        }
        function $(H, K) {
          return (H[K] | H[K + 1] << 8 | H[K + 2] << 16) + (H[K + 3] << 24);
        }
        return e.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(H, K, Q) {
          for (Q = Q || this.length; this.pos < Q; ) {
            var ie = this.readVarint(), fe = ie >> 3, de = this.pos;
            this.type = 7 & ie, H(fe, K, this), this.pos === de && this.skip(ie);
          }
          return K;
        }, readMessage: function(H, K) {
          return this.readFields(H, K, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var H = U(this.buf, this.pos);
          return this.pos += 4, H;
        }, readSFixed32: function() {
          var H = $(this.buf, this.pos);
          return this.pos += 4, H;
        }, readFixed64: function() {
          var H = U(this.buf, this.pos) + U(this.buf, this.pos + 4) * n;
          return this.pos += 8, H;
        }, readSFixed64: function() {
          var H = U(this.buf, this.pos) + $(this.buf, this.pos + 4) * n;
          return this.pos += 8, H;
        }, readFloat: function() {
          var H = r.read(this.buf, this.pos, !0, 23, 4);
          return this.pos += 4, H;
        }, readDouble: function() {
          var H = r.read(this.buf, this.pos, !0, 52, 8);
          return this.pos += 8, H;
        }, readVarint: function(H) {
          var K, Q, ie = this.buf;
          return K = 127 & (Q = ie[this.pos++]), Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 7, Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 14, Q < 128 ? K : (K |= (127 & (Q = ie[this.pos++])) << 21, Q < 128 ? K : function(fe, de, he) {
            var Me, me, Ee = he.buf;
            if (Me = (112 & (me = Ee[he.pos++])) >> 4, me < 128 || (Me |= (127 & (me = Ee[he.pos++])) << 3, me < 128) || (Me |= (127 & (me = Ee[he.pos++])) << 10, me < 128) || (Me |= (127 & (me = Ee[he.pos++])) << 17, me < 128) || (Me |= (127 & (me = Ee[he.pos++])) << 24, me < 128) || (Me |= (1 & (me = Ee[he.pos++])) << 31, me < 128))
              return d(fe, Me, de);
            throw new Error("Expected varint not more than 10 bytes");
          }(K |= (15 & (Q = ie[this.pos])) << 28, H, this))));
        }, readVarint64: function() {
          return this.readVarint(!0);
        }, readSVarint: function() {
          var H = this.readVarint();
          return H % 2 == 1 ? (H + 1) / -2 : H / 2;
        }, readBoolean: function() {
          return !!this.readVarint();
        }, readString: function() {
          var H = this.readVarint() + this.pos, K = this.pos;
          return this.pos = H, H - K >= 12 && u ? function(Q, ie, fe) {
            return u.decode(Q.subarray(ie, fe));
          }(this.buf, K, H) : function(Q, ie, fe) {
            for (var de = "", he = ie; he < fe; ) {
              var Me, me, Ee, ze = Q[he], Ie = null, Re = ze > 239 ? 4 : ze > 223 ? 3 : ze > 191 ? 2 : 1;
              if (he + Re > fe)
                break;
              Re === 1 ? ze < 128 && (Ie = ze) : Re === 2 ? (192 & (Me = Q[he + 1])) == 128 && (Ie = (31 & ze) << 6 | 63 & Me) <= 127 && (Ie = null) : Re === 3 ? (me = Q[he + 2], (192 & (Me = Q[he + 1])) == 128 && (192 & me) == 128 && ((Ie = (15 & ze) << 12 | (63 & Me) << 6 | 63 & me) <= 2047 || Ie >= 55296 && Ie <= 57343) && (Ie = null)) : Re === 4 && (me = Q[he + 2], Ee = Q[he + 3], (192 & (Me = Q[he + 1])) == 128 && (192 & me) == 128 && (192 & Ee) == 128 && ((Ie = (15 & ze) << 18 | (63 & Me) << 12 | (63 & me) << 6 | 63 & Ee) <= 65535 || Ie >= 1114112) && (Ie = null)), Ie === null ? (Ie = 65533, Re = 1) : Ie > 65535 && (Ie -= 65536, de += String.fromCharCode(Ie >>> 10 & 1023 | 55296), Ie = 56320 | 1023 & Ie), de += String.fromCharCode(Ie), he += Re;
            }
            return de;
          }(this.buf, K, H);
        }, readBytes: function() {
          var H = this.readVarint() + this.pos, K = this.buf.subarray(this.pos, H);
          return this.pos = H, K;
        }, readPackedVarint: function(H, K) {
          if (this.type !== e.Bytes)
            return H.push(this.readVarint(K));
          var Q = l(this);
          for (H = H || []; this.pos < Q; )
            H.push(this.readVarint(K));
          return H;
        }, readPackedSVarint: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSVarint());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSVarint());
          return H;
        }, readPackedBoolean: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readBoolean());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readBoolean());
          return H;
        }, readPackedFloat: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFloat());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFloat());
          return H;
        }, readPackedDouble: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readDouble());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readDouble());
          return H;
        }, readPackedFixed32: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFixed32());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFixed32());
          return H;
        }, readPackedSFixed32: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSFixed32());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSFixed32());
          return H;
        }, readPackedFixed64: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readFixed64());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readFixed64());
          return H;
        }, readPackedSFixed64: function(H) {
          if (this.type !== e.Bytes)
            return H.push(this.readSFixed64());
          var K = l(this);
          for (H = H || []; this.pos < K; )
            H.push(this.readSFixed64());
          return H;
        }, skip: function(H) {
          var K = 7 & H;
          if (K === e.Varint)
            for (; this.buf[this.pos++] > 127; )
              ;
          else if (K === e.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (K === e.Fixed32)
            this.pos += 4;
          else {
            if (K !== e.Fixed64)
              throw new Error("Unimplemented type: " + K);
            this.pos += 8;
          }
        }, writeTag: function(H, K) {
          this.writeVarint(H << 3 | K);
        }, realloc: function(H) {
          for (var K = this.length || 16; K < this.pos + H; )
            K *= 2;
          if (K !== this.length) {
            var Q = new Uint8Array(K);
            Q.set(this.buf), this.buf = Q, this.length = K;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(H) {
          this.realloc(4), q(this.buf, H, this.pos), this.pos += 4;
        }, writeSFixed32: function(H) {
          this.realloc(4), q(this.buf, H, this.pos), this.pos += 4;
        }, writeFixed64: function(H) {
          this.realloc(8), q(this.buf, -1 & H, this.pos), q(this.buf, Math.floor(H * o), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(H) {
          this.realloc(8), q(this.buf, -1 & H, this.pos), q(this.buf, Math.floor(H * o), this.pos + 4), this.pos += 8;
        }, writeVarint: function(H) {
          (H = +H || 0) > 268435455 || H < 0 ? function(K, Q) {
            var ie, fe;
            if (K >= 0 ? (ie = K % 4294967296 | 0, fe = K / 4294967296 | 0) : (fe = ~(-K / 4294967296), 4294967295 ^ (ie = ~(-K % 4294967296)) ? ie = ie + 1 | 0 : (ie = 0, fe = fe + 1 | 0)), K >= 18446744073709552e3 || K < -18446744073709552e3)
              throw new Error("Given varint doesn't fit into 10 bytes");
            Q.realloc(10), function(de, he, Me) {
              Me.buf[Me.pos++] = 127 & de | 128, de >>>= 7, Me.buf[Me.pos++] = 127 & de | 128, de >>>= 7, Me.buf[Me.pos++] = 127 & de | 128, de >>>= 7, Me.buf[Me.pos++] = 127 & de | 128, Me.buf[Me.pos] = 127 & (de >>>= 7);
            }(ie, 0, Q), function(de, he) {
              var Me = (7 & de) << 4;
              he.buf[he.pos++] |= Me | ((de >>>= 3) ? 128 : 0), de && (he.buf[he.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (he.buf[he.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (he.buf[he.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (he.buf[he.pos++] = 127 & de | ((de >>>= 7) ? 128 : 0), de && (he.buf[he.pos++] = 127 & de)))));
            }(fe, Q);
          }(H, this) : (this.realloc(4), this.buf[this.pos++] = 127 & H | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = 127 & (H >>>= 7) | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = 127 & (H >>>= 7) | (H > 127 ? 128 : 0), H <= 127 || (this.buf[this.pos++] = H >>> 7 & 127))));
        }, writeSVarint: function(H) {
          this.writeVarint(H < 0 ? 2 * -H - 1 : 2 * H);
        }, writeBoolean: function(H) {
          this.writeVarint(!!H);
        }, writeString: function(H) {
          H = String(H), this.realloc(4 * H.length), this.pos++;
          var K = this.pos;
          this.pos = function(ie, fe, de) {
            for (var he, Me, me = 0; me < fe.length; me++) {
              if ((he = fe.charCodeAt(me)) > 55295 && he < 57344) {
                if (!Me) {
                  he > 56319 || me + 1 === fe.length ? (ie[de++] = 239, ie[de++] = 191, ie[de++] = 189) : Me = he;
                  continue;
                }
                if (he < 56320) {
                  ie[de++] = 239, ie[de++] = 191, ie[de++] = 189, Me = he;
                  continue;
                }
                he = Me - 55296 << 10 | he - 56320 | 65536, Me = null;
              } else
                Me && (ie[de++] = 239, ie[de++] = 191, ie[de++] = 189, Me = null);
              he < 128 ? ie[de++] = he : (he < 2048 ? ie[de++] = he >> 6 | 192 : (he < 65536 ? ie[de++] = he >> 12 | 224 : (ie[de++] = he >> 18 | 240, ie[de++] = he >> 12 & 63 | 128), ie[de++] = he >> 6 & 63 | 128), ie[de++] = 63 & he | 128);
            }
            return de;
          }(this.buf, H, this.pos);
          var Q = this.pos - K;
          Q >= 128 && v(K, Q, this), this.pos = K - 1, this.writeVarint(Q), this.pos += Q;
        }, writeFloat: function(H) {
          this.realloc(4), r.write(this.buf, H, this.pos, !0, 23, 4), this.pos += 4;
        }, writeDouble: function(H) {
          this.realloc(8), r.write(this.buf, H, this.pos, !0, 52, 8), this.pos += 8;
        }, writeBytes: function(H) {
          var K = H.length;
          this.writeVarint(K), this.realloc(K);
          for (var Q = 0; Q < K; Q++)
            this.buf[this.pos++] = H[Q];
        }, writeRawMessage: function(H, K) {
          this.pos++;
          var Q = this.pos;
          H(K, this);
          var ie = this.pos - Q;
          ie >= 128 && v(Q, ie, this), this.pos = Q - 1, this.writeVarint(ie), this.pos += ie;
        }, writeMessage: function(H, K, Q) {
          this.writeTag(H, e.Bytes), this.writeRawMessage(K, Q);
        }, writePackedVarint: function(H, K) {
          K.length && this.writeMessage(H, M, K);
        }, writePackedSVarint: function(H, K) {
          K.length && this.writeMessage(H, D, K);
        }, writePackedBoolean: function(H, K) {
          K.length && this.writeMessage(H, I, K);
        }, writePackedFloat: function(H, K) {
          K.length && this.writeMessage(H, x, K);
        }, writePackedDouble: function(H, K) {
          K.length && this.writeMessage(H, E, K);
        }, writePackedFixed32: function(H, K) {
          K.length && this.writeMessage(H, S, K);
        }, writePackedSFixed32: function(H, K) {
          K.length && this.writeMessage(H, C, K);
        }, writePackedFixed64: function(H, K) {
          K.length && this.writeMessage(H, k, K);
        }, writePackedSFixed64: function(H, K) {
          K.length && this.writeMessage(H, V, K);
        }, writeBytesField: function(H, K) {
          this.writeTag(H, e.Bytes), this.writeBytes(K);
        }, writeFixed32Field: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeFixed32(K);
        }, writeSFixed32Field: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeSFixed32(K);
        }, writeFixed64Field: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeFixed64(K);
        }, writeSFixed64Field: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeSFixed64(K);
        }, writeVarintField: function(H, K) {
          this.writeTag(H, e.Varint), this.writeVarint(K);
        }, writeSVarintField: function(H, K) {
          this.writeTag(H, e.Varint), this.writeSVarint(K);
        }, writeStringField: function(H, K) {
          this.writeTag(H, e.Bytes), this.writeString(K);
        }, writeFloatField: function(H, K) {
          this.writeTag(H, e.Fixed32), this.writeFloat(K);
        }, writeDoubleField: function(H, K) {
          this.writeTag(H, e.Fixed64), this.writeDouble(K);
        }, writeBooleanField: function(H, K) {
          this.writeVarintField(H, !!K);
        } }, P_;
      }
      var Pp = O(I0());
      const I_ = 3;
      function uT(r, e, n) {
        e.glyphs = [], r === 1 && n.readMessage(dT, e);
      }
      function dT(r, e, n) {
        if (r === 3) {
          const { id: o, bitmap: u, width: l, height: d, left: v, top: M, advance: D } = n.readMessage(fT, {});
          e.glyphs.push({ id: o, bitmap: new mc({ width: l + 2 * I_, height: d + 2 * I_ }, u), metrics: { width: l, height: d, left: v, top: M, advance: D } });
        } else
          r === 4 ? e.ascender = n.readSVarint() : r === 5 && (e.descender = n.readSVarint());
      }
      function fT(r, e, n) {
        r === 1 ? e.id = n.readVarint() : r === 2 ? e.bitmap = n.readBytes() : r === 3 ? e.width = n.readVarint() : r === 4 ? e.height = n.readVarint() : r === 5 ? e.left = n.readSVarint() : r === 6 ? e.top = n.readSVarint() : r === 7 && (e.advance = n.readVarint());
      }
      const L0 = I_, ko = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class qd {
        constructor() {
          this.scale = 1, this.fontStack = "", this.image = null;
        }
        static forText(e, n) {
          const o = new qd();
          return o.scale = e || 1, o.fontStack = n, o;
        }
        static forImage(e) {
          const n = new qd();
          return n.image = e, n;
        }
      }
      class Iu {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(e, n) {
          const o = new Iu();
          for (let u = 0; u < e.sections.length; u++) {
            const l = e.sections[u];
            l.image ? o.addImageSection(l) : o.addTextSection(l, n);
          }
          return o;
        }
        length() {
          return this.text.length;
        }
        getSection(e) {
          return this.sections[this.sectionIndex[e]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(e) {
          return this.sectionIndex[e];
        }
        getCodePoint(e) {
          return this.text.codePointAt(e);
        }
        verticalizePunctuation(e) {
          this.text = function(n, o) {
            let u = "";
            for (let l = 0; l < n.length; l++) {
              const d = n.charCodeAt(l + 1) || null, v = n.charCodeAt(l - 1) || null;
              u += !o && (d && fd(d) && !Hd[n[l + 1]] || v && fd(v) && !Hd[n[l - 1]]) || !Hd[n[l]] ? n[l] : Hd[n[l]];
            }
            return u;
          }(this.text, e);
        }
        trim() {
          let e = 0;
          for (let o = 0; o < this.text.length && Cp[this.text.charCodeAt(o)]; o++)
            e++;
          let n = this.text.length;
          for (let o = this.text.length - 1; o >= 0 && o >= e && Cp[this.text.charCodeAt(o)]; o--)
            n--;
          this.text = this.text.substring(e, n), this.sectionIndex = this.sectionIndex.slice(e, n);
        }
        substring(e, n) {
          const o = new Iu();
          return o.text = this.text.substring(e, n), o.sectionIndex = this.sectionIndex.slice(e, n), o.sections = this.sections, o;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((e, n) => Math.max(e, this.sections[n].scale), 0);
        }
        addTextSection(e, n) {
          this.text += e.text, this.sections.push(qd.forText(e.scale, e.fontStack || n));
          const o = this.sections.length - 1;
          for (let u = 0; u < e.text.length; ++u)
            this.sectionIndex.push(o);
        }
        addImageSection(e) {
          const n = e.image && e.image.namePrimary ? e.image.getPrimary() : null;
          if (!n)
            return void mi("Can't add FormattedSection with an empty image.");
          const o = this.getNextImageSectionCharCode();
          o ? (this.text += String.fromCodePoint(o), this.sections.push(qd.forImage(n)), this.sectionIndex.push(this.sections.length - 1)) : mi("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function L_(r, e, n, o, u, l, d, v, M, D, x, E, I, S, C) {
        const k = Iu.fromFeature(r, u);
        E === ko.vertical && k.verticalizePunctuation(I);
        let V = [];
        const U = function(Q, ie, fe, de, he, Me) {
          if (!Q)
            return [];
          const me = [], Ee = function(Ve, Ue, Fe, et, dt, tt) {
            let Tt = 0;
            for (let vt = 0; vt < Ve.length(); vt++) {
              const Pt = Ve.getSection(vt);
              Tt += z0(Ve.getCodePoint(vt), Pt, et, dt, Ue, tt);
            }
            return Tt / Math.max(1, Math.ceil(Tt / Fe));
          }(Q, ie, fe, de, he, Me), ze = Q.text.indexOf("​") >= 0;
          let Ie = 0;
          for (let Ve = 0; Ve < Q.length(); Ve++) {
            const Ue = Q.getSection(Ve), Fe = Q.getCodePoint(Ve);
            if (Cp[Fe] || (Ie += z0(Fe, Ue, de, he, ie, Me)), Ve < Q.length() - 1) {
              const et = !((Re = Fe) < 11904 || !(Zt["Bopomofo Extended"](Re) || Zt.Bopomofo(Re) || Zt["CJK Compatibility Forms"](Re) || Zt["CJK Compatibility Ideographs"](Re) || Zt["CJK Compatibility"](Re) || Zt["CJK Radicals Supplement"](Re) || Zt["CJK Strokes"](Re) || Zt["CJK Symbols and Punctuation"](Re) || Zt["CJK Unified Ideographs Extension A"](Re) || Zt["CJK Unified Ideographs"](Re) || Zt["Enclosed CJK Letters and Months"](Re) || Zt["Halfwidth and Fullwidth Forms"](Re) || Zt.Hiragana(Re) || Zt["Ideographic Description Characters"](Re) || Zt["Kangxi Radicals"](Re) || Zt["Katakana Phonetic Extensions"](Re) || Zt.Katakana(Re) || Zt["Vertical Forms"](Re) || Zt["Yi Radicals"](Re) || Zt["Yi Syllables"](Re)));
              (pT[Fe] || et || Ue.image) && me.push(k0(Ve + 1, Ie, Ee, me, mT(Fe, Q.getCodePoint(Ve + 1), et && ze), !1));
            }
          }
          var Re;
          return R0(k0(Q.length(), Ie, Ee, me, 0, !0));
        }(k, D, l, e, o, S), { processBidirectionalText: q, processStyledBidirectionalText: $ } = co;
        if (q && k.sections.length === 1) {
          const Q = q(k.toString(), U);
          for (const ie of Q) {
            const fe = new Iu();
            fe.text = ie, fe.sections = k.sections;
            for (let de = 0; de < ie.length; de++)
              fe.sectionIndex.push(0);
            V.push(fe);
          }
        } else if ($) {
          const Q = $(k.text, k.sectionIndex, U);
          for (const ie of Q) {
            const fe = new Iu();
            fe.text = ie[0], fe.sectionIndex = ie[1], fe.sections = k.sections, V.push(fe);
          }
        } else
          V = function(Q, ie) {
            const fe = [], de = Q.text;
            let he = 0;
            for (const Me of ie)
              fe.push(Q.substring(he, Me)), he = Me;
            return he < de.length && fe.push(Q.substring(he, de.length)), fe;
          }(k, U);
        const H = [], K = { positionedLines: H, text: k.toString(), top: x[1], bottom: x[1], left: x[0], right: x[0], writingMode: E, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
        return function(Q, ie, fe, de, he, Me, me, Ee, ze, Ie, Re, Ve) {
          let Ue = 0, Fe = 0, et = 0;
          const dt = Ee === "right" ? 1 : Ee === "left" ? 0 : 0.5;
          let tt = !1;
          for (const St of he) {
            const Nt = St.getSections();
            for (const Qt of Nt) {
              if (Qt.image)
                continue;
              const pi = ie[Qt.fontStack];
              if (pi && (tt = pi.ascender !== void 0 && pi.descender !== void 0, !tt))
                break;
            }
            if (!tt)
              break;
          }
          let Tt = 0;
          for (const St of he) {
            St.trim();
            const Nt = St.getMaxScale(), Qt = (Nt - 1) * er, pi = { positionedGlyphs: [], lineOffset: 0 };
            Q.positionedLines[Tt] = pi;
            const gi = pi.positionedGlyphs;
            let Pi = 0;
            if (!St.length()) {
              Fe += Me, ++Tt;
              continue;
            }
            let yi = 0, Ii = 0;
            for (let rn = 0; rn < St.length(); rn++) {
              const hi = St.getSection(rn), on = St.getSectionIndex(rn), Qi = St.getCodePoint(rn);
              let pn = hi.scale, as = null, ls = null, Kn = null, Vr = er, Mn = 0;
              const Ln = !(ze === ko.horizontal || !Re && !iu(Qi) || Re && (Cp[Qi] || (vt = Qi, Zt.Arabic(vt) || Zt["Arabic Supplement"](vt) || Zt["Arabic Extended-A"](vt) || Zt["Arabic Presentation Forms-A"](vt) || Zt["Arabic Presentation Forms-B"](vt))));
              if (hi.image) {
                const Tr = de[hi.image.serialize()];
                if (!Tr)
                  continue;
                Kn = hi.image.id, Q.iconsInText = Q.iconsInText || !0, ls = Tr.paddedRect;
                const cs = Tr.displaySize;
                pn = pn * er / Ve, as = { width: cs[0], height: cs[1], left: 0, top: -L0, advance: Ln ? cs[1] : cs[0], localGlyph: !1 }, Mn = tt ? -as.height * pn : Nt * er - 17 - cs[1] * pn, Vr = as.advance;
                const to = (Ln ? cs[0] : cs[1]) * pn - er * Nt;
                to > 0 && to > Pi && (Pi = to);
              } else {
                const Tr = fe[hi.fontStack];
                if (!Tr)
                  continue;
                Tr[Qi] && (ls = Tr[Qi]);
                const cs = ie[hi.fontStack];
                if (!cs)
                  continue;
                const to = cs.glyphs[Qi];
                if (!to)
                  continue;
                if (as = to.metrics, Vr = Qi !== 8203 ? er : 0, tt) {
                  const Ss = cs.ascender !== void 0 ? Math.abs(cs.ascender) : 0, il = cs.descender !== void 0 ? Math.abs(cs.descender) : 0, wc = (Ss + il) * pn;
                  yi < wc && (yi = wc, Ii = (Ss - il) / 2 * pn), Mn = -Ss * pn;
                } else
                  Mn = (Nt - pn) * er - 17;
              }
              Ln ? (Q.verticalizable = !0, gi.push({ glyph: Qi, imageName: Kn, x: Ue, y: Fe + Mn, vertical: Ln, scale: pn, localGlyph: as.localGlyph, fontStack: hi.fontStack, sectionIndex: on, metrics: as, rect: ls }), Ue += Vr * pn + Ie) : (gi.push({ glyph: Qi, imageName: Kn, x: Ue, y: Fe + Mn, vertical: Ln, scale: pn, localGlyph: as.localGlyph, fontStack: hi.fontStack, sectionIndex: on, metrics: as, rect: ls }), Ue += as.advance * pn + Ie);
            }
            gi.length !== 0 && (et = Math.max(Ue - Ie, et), tt ? O0(gi, dt, Pi, Ii, Me * Nt / 2) : O0(gi, dt, Pi, 0, Me / 2)), Ue = 0;
            const fn = Me * Nt + Pi;
            pi.lineOffset = Math.max(Pi, Qt), Fe += fn, ++Tt;
          }
          var vt;
          const Pt = Fe, { horizontalAlign: rt, verticalAlign: Ut } = z_(me);
          (function(St, Nt, Qt, pi, gi, Pi) {
            const yi = (Nt - Qt) * gi, Ii = -Pi * pi;
            for (const fn of St)
              for (const rn of fn.positionedGlyphs)
                rn.x += yi, rn.y += Ii;
          })(Q.positionedLines, dt, rt, Ut, et, Pt), Q.top += -Ut * Pt, Q.bottom = Q.top + Pt, Q.left += -rt * et, Q.right = Q.left + et, Q.hasBaseline = tt;
        }(K, e, n, o, V, d, v, M, E, D, I, C), !function(Q) {
          for (const ie of Q)
            if (ie.positionedGlyphs.length !== 0)
              return !1;
          return !0;
        }(H) && K;
      }
      const Cp = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, pT = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
      function z0(r, e, n, o, u, l) {
        if (e.image) {
          const d = o[e.image.serialize()];
          return d ? d.displaySize[0] * e.scale * er / l + u : 0;
        }
        {
          const d = n[e.fontStack], v = d && d.glyphs[r];
          return v ? v.metrics.advance * e.scale + u : 0;
        }
      }
      function D0(r, e, n, o) {
        const u = Math.pow(r - e, 2);
        return o ? r < e ? u / 2 : 2 * u : u + Math.abs(n) * n;
      }
      function mT(r, e, n) {
        let o = 0;
        return r === 10 && (o -= 1e4), n && (o += 150), r !== 40 && r !== 65288 || (o += 50), e !== 41 && e !== 65289 || (o += 50), o;
      }
      function k0(r, e, n, o, u, l) {
        let d = null, v = D0(e, n, u, l);
        for (const M of o) {
          const D = D0(e - M.x, n, u, l) + M.badness;
          D <= v && (d = M, v = D);
        }
        return { index: r, x: e, priorBreak: d, badness: v };
      }
      function R0(r) {
        return r ? R0(r.priorBreak).concat(r.index) : [];
      }
      function z_(r) {
        let e = 0.5, n = 0.5;
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            e = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e = 0;
        }
        switch (r) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            n = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            n = 0;
        }
        return { horizontalAlign: e, verticalAlign: n };
      }
      function O0(r, e, n, o, u) {
        if (!(e || n || o || u))
          return;
        const l = r.length - 1, d = r[l], v = (d.x + d.metrics.advance * d.scale) * e;
        for (let M = 0; M <= l; M++)
          r[M].x -= v, r[M].y += n + o + u;
      }
      function _T(r, e, n, o) {
        const { horizontalAlign: u, verticalAlign: l } = z_(o), d = n[0] - r.displaySize[0] * u, v = n[1] - r.displaySize[1] * l;
        return { imagePrimary: r, imageSecondary: e, top: v, bottom: v + r.displaySize[1], left: d, right: d + r.displaySize[0] };
      }
      function F0(r, e, n, o, u, l) {
        const d = r.imagePrimary;
        let v;
        if (d.content) {
          const V = d.content, U = d.pixelRatio || 1;
          v = [V[0] / U, V[1] / U, d.displaySize[0] - V[2] / U, d.displaySize[1] - V[3] / U];
        }
        const M = e.left * l, D = e.right * l;
        let x, E, I, S;
        n === "width" || n === "both" ? (S = u[0] + M - o[3], E = u[0] + D + o[1]) : (S = u[0] + (M + D - d.displaySize[0]) / 2, E = S + d.displaySize[0]);
        const C = e.top * l, k = e.bottom * l;
        return n === "height" || n === "both" ? (x = u[1] + C - o[0], I = u[1] + k + o[2]) : (x = u[1] + (C + k - d.displaySize[1]) / 2, I = x + d.displaySize[1]), { imagePrimary: d, imageSecondary: void 0, top: x, right: E, bottom: I, left: S, collisionPadding: v };
      }
      class Il extends Mt {
        constructor(e, n, o, u, l) {
          super(e, n), this.angle = u, this.z = o, l !== void 0 && (this.segment = l);
        }
        clone() {
          return new Il(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function B0(r, e, n, o, u) {
        if (e.segment === void 0)
          return !0;
        let l = e, d = e.segment + 1, v = 0;
        for (; v > -n / 2; ) {
          if (d--, d < 0)
            return !1;
          v -= r[d].dist(l), l = r[d];
        }
        v += r[d].dist(r[d + 1]), d++;
        const M = [];
        let D = 0;
        for (; v < n / 2; ) {
          const x = r[d], E = r[d + 1];
          if (!E)
            return !1;
          let I = r[d - 1].angleTo(x) - x.angleTo(E);
          for (I = Math.abs((I + 3 * Math.PI) % (2 * Math.PI) - Math.PI), M.push({ distance: v, angleDelta: I }), D += I; v - M[0].distance > o; )
            D -= M.shift().angleDelta;
          if (D > u)
            return !1;
          d++, v += x.dist(E);
        }
        return !0;
      }
      function N0(r) {
        let e = 0;
        for (let n = 0; n < r.length - 1; n++)
          e += r[n].dist(r[n + 1]);
        return e;
      }
      function V0(r, e, n) {
        return r ? 0.6 * e * n : 0;
      }
      function U0(r, e) {
        return Math.max(r ? r.right - r.left : 0, e ? e.right - e.left : 0);
      }
      function gT(r, e, n, o, u, l) {
        const d = V0(n, u, l), v = U0(n, o) * l;
        let M = 0;
        const D = N0(r) / 2;
        for (let x = 0; x < r.length - 1; x++) {
          const E = r[x], I = r[x + 1], S = E.dist(I);
          if (M + S > D) {
            const C = (D - M) / S, k = ei(E.x, I.x, C), V = ei(E.y, I.y, C), U = new Il(k, V, 0, I.angleTo(E), x);
            return !d || B0(r, U, v, d, e) ? U : void 0;
          }
          M += S;
        }
      }
      function yT(r, e, n, o, u, l, d, v, M) {
        const D = V0(o, l, d), x = U0(o, u), E = x * d, I = r[0].x === 0 || r[0].x === M || r[0].y === 0 || r[0].y === M;
        return e - E < e / 4 && (e = E + e / 4), j0(r, I ? e / 2 * v % e : (x / 2 + 2 * l) * d * v % e, e, D, n, E, I, !1, M);
      }
      function j0(r, e, n, o, u, l, d, v, M) {
        const D = l / 2, x = N0(r);
        let E = 0, I = e - n, S = [];
        for (let C = 0; C < r.length - 1; C++) {
          const k = r[C], V = r[C + 1], U = k.dist(V), q = V.angleTo(k);
          for (; I + n < E + U; ) {
            I += n;
            const $ = (I - E) / U, H = ei(k.x, V.x, $), K = ei(k.y, V.y, $);
            if (H >= 0 && H < M && K >= 0 && K < M && I - D >= 0 && I + D <= x) {
              const Q = new Il(H, K, 0, q, C);
              o && !B0(r, Q, l, o, u) || S.push(Q);
            }
          }
          E += U;
        }
        return v || S.length || d || (S = j0(r, E / 2, n, o, u, l, d, !0, M)), S;
      }
      function G0(r, e, n, o, u) {
        const l = [];
        for (let d = 0; d < r.length; d++) {
          const v = r[d];
          let M;
          for (let D = 0; D < v.length - 1; D++) {
            let x = v[D], E = v[D + 1];
            x.x < e && E.x < e || (x.x < e ? x = new Mt(e, x.y + (e - x.x) / (E.x - x.x) * (E.y - x.y))._round() : E.x < e && (E = new Mt(e, x.y + (e - x.x) / (E.x - x.x) * (E.y - x.y))._round()), x.y < n && E.y < n || (x.y < n ? x = new Mt(x.x + (n - x.y) / (E.y - x.y) * (E.x - x.x), n)._round() : E.y < n && (E = new Mt(x.x + (n - x.y) / (E.y - x.y) * (E.x - x.x), n)._round()), x.x >= o && E.x >= o || (x.x >= o ? x = new Mt(o, x.y + (o - x.x) / (E.x - x.x) * (E.y - x.y))._round() : E.x >= o && (E = new Mt(o, x.y + (o - x.x) / (E.x - x.x) * (E.y - x.y))._round()), x.y >= u && E.y >= u || (x.y >= u ? x = new Mt(x.x + (u - x.y) / (E.y - x.y) * (E.x - x.x), u)._round() : E.y >= u && (E = new Mt(x.x + (u - x.y) / (E.y - x.y) * (E.x - x.x), u)._round()), M && x.equals(M[M.length - 1]) || (M = [x], l.push(M)), M.push(E)))));
          }
        }
        return l;
      }
      function Z0(r) {
        let e = 0, n = 0;
        for (const d of r)
          e += d.w * d.h, n = Math.max(n, d.w);
        r.sort((d, v) => v.h - d.h);
        const o = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), n), h: 1 / 0 }];
        let u = 0, l = 0;
        for (const d of r)
          for (let v = o.length - 1; v >= 0; v--) {
            const M = o[v];
            if (!(d.w > M.w || d.h > M.h)) {
              if (d.x = M.x, d.y = M.y, l = Math.max(l, d.y + d.h), u = Math.max(u, d.x + d.w), d.w === M.w && d.h === M.h) {
                const D = o.pop();
                v < o.length && (o[v] = D);
              } else
                d.h === M.h ? (M.x += d.w, M.w -= d.w) : d.w === M.w ? (M.y += d.h, M.h -= d.h) : (o.push({ x: M.x + d.w, y: M.y, w: M.w - d.w, h: d.h }), M.y += d.h, M.h -= d.h);
              break;
            }
          }
        return { w: u, h: l, fill: e / (u * l) || 0 };
      }
      Ft(Il, "Anchor");
      const Wd = 1;
      class D_ {
        constructor(e, { pixelRatio: n, version: o, stretchX: u, stretchY: l, content: d }, v) {
          this.paddedRect = e, this.pixelRatio = n, this.stretchX = u, this.stretchY = l, this.content = d, this.version = o, this.padding = v;
        }
        get tl() {
          return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * this.padding) / this.pixelRatio, (this.paddedRect.h - 2 * this.padding) / this.pixelRatio];
        }
      }
      class H0 {
        constructor(e, n, o) {
          const u = {}, l = {};
          this.haveRenderCallbacks = [];
          const d = [];
          this.addImages(e, u, Wd, d), this.addImages(n, l, 2, d);
          const { w: v, h: M } = Z0(d), D = new _r({ width: v || 1, height: M || 1 });
          for (const x in e) {
            const E = e[x], I = u[x].paddedRect;
            _r.copy(E.data, D, { x: 0, y: 0 }, { x: I.x + Wd, y: I.y + Wd }, E.data, o, E.sdf);
          }
          for (const x in n) {
            const E = n[x], I = l[x].paddedRect;
            let S = l[x].padding;
            const C = I.x + S, k = I.y + S, V = E.data.width, U = E.data.height;
            S = S > 1 ? S - 1 : S, _r.copy(E.data, D, { x: 0, y: 0 }, { x: C, y: k }, E.data, o), _r.copy(E.data, D, { x: 0, y: U - S }, { x: C, y: k - S }, { width: V, height: S }, o), _r.copy(E.data, D, { x: 0, y: 0 }, { x: C, y: k + U }, { width: V, height: S }, o), _r.copy(E.data, D, { x: V - S, y: 0 }, { x: C - S, y: k }, { width: S, height: U }, o), _r.copy(E.data, D, { x: 0, y: 0 }, { x: C + V, y: k }, { width: S, height: U }, o), _r.copy(E.data, D, { x: V - S, y: U - S }, { x: C - S, y: k - S }, { width: S, height: S }, o), _r.copy(E.data, D, { x: 0, y: U - S }, { x: C + V, y: k - S }, { width: S, height: S }, o), _r.copy(E.data, D, { x: 0, y: 0 }, { x: C + V, y: k + U }, { width: S, height: S }, o), _r.copy(E.data, D, { x: V - S, y: 0 }, { x: C - S, y: k + U }, { width: S, height: S }, o);
          }
          this.image = D, this.iconPositions = u, this.patternPositions = l;
        }
        addImages(e, n, o, u) {
          for (const l in e) {
            const d = e[l], v = { x: 0, y: 0, w: d.data.width + 2 * o, h: d.data.height + 2 * o };
            u.push(v), n[l] = new D_(v, d, o), d.hasRenderCallback && this.haveRenderCallbacks.push(rr.deserializeId(l));
          }
        }
        patchUpdatedImages(e, n, o) {
          this.haveRenderCallbacks = this.haveRenderCallbacks.filter((u) => e.hasImage(u, o)), e.dispatchRenderCallbacks(this.haveRenderCallbacks, o);
          for (const u in e.getUpdatedImages(o)) {
            for (const l of Object.keys(this.iconPositions))
              rr.deserializeId(l) === u && this.patchUpdatedImage(this.iconPositions[l], e.getImage(u, o), n);
            for (const l of Object.keys(this.patternPositions))
              rr.deserializeId(l) === u && this.patchUpdatedImage(this.patternPositions[l], e.getImage(u, o), n);
          }
        }
        patchUpdatedImage(e, n, o) {
          if (!e || !n || e.version === n.version)
            return;
          e.version = n.version;
          const [u, l] = e.tl;
          o.update(n.data, { position: { x: u, y: l } });
        }
      }
      Ft(D_, "ImagePosition"), Ft(H0, "ImageAtlas");
      const $d = 1e20;
      function q0(r, e, n, o, u, l, d, v, M) {
        for (let D = e; D < e + o; D++)
          W0(r, n * l + D, l, u, d, v, M);
        for (let D = n; D < n + u; D++)
          W0(r, D * l + e, 1, o, d, v, M);
      }
      function W0(r, e, n, o, u, l, d) {
        l[0] = 0, d[0] = -$d, d[1] = $d, u[0] = r[e];
        for (let v = 1, M = 0, D = 0; v < o; v++) {
          u[v] = r[e + v * n];
          const x = v * v;
          do {
            const E = l[M];
            D = (u[v] - u[E] + x - E * E) / (v - E) / 2;
          } while (D <= d[M] && --M > -1);
          M++, l[M] = v, d[M] = D, d[M + 1] = $d;
        }
        for (let v = 0, M = 0; v < o; v++) {
          for (; d[M + 1] < v; )
            M++;
          const D = l[M], x = v - D;
          r[e + v * n] = u[D] + x * x;
        }
      }
      const Ma = 2, k_ = { none: 0, ideographs: 1, all: 2 };
      class Lu {
        constructor(e, n, o) {
          this.requestManager = e, this.localGlyphMode = n, this.localFontFamily = o, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(e, n) {
          this.urls[n] = e;
        }
        getGlyphs(e, n, o) {
          const u = [], l = this.urls[n] || ge.GLYPHS_URL;
          for (const d in e)
            for (const v of e[d])
              u.push({ stack: d, id: v });
          Rn(u, ({ stack: d, id: v }, M) => {
            let D = this.entries[d];
            D || (D = this.entries[d] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let x = D.glyphs[v];
            if (x !== void 0)
              return void M(null, { stack: d, id: v, glyph: x });
            if (x = this._tinySDF(D, d, v), x)
              return D.glyphs[v] = x, void M(null, { stack: d, id: v, glyph: x });
            const E = Math.floor(v / 256);
            if (256 * E > 65535)
              return mi("glyphs > 65535 not supported"), void M(null, { stack: d, id: v, glyph: x });
            if (D.ranges[E])
              return void M(null, { stack: d, id: v, glyph: x });
            let I = D.requests[E];
            I || (I = D.requests[E] = [], Lu.loadGlyphRange(d, E, l, this.requestManager, (S, C) => {
              if (C) {
                D.ascender = C.ascender, D.descender = C.descender;
                for (const k in C.glyphs)
                  this._doesCharSupportLocalGlyph(+k) || (D.glyphs[+k] = C.glyphs[+k]);
                D.ranges[E] = !0;
              }
              for (const k of I)
                k(S, C);
              delete D.requests[E];
            })), I.push((S, C) => {
              S ? M(S) : C && M(null, { stack: d, id: v, glyph: C.glyphs[v] || null });
            });
          }, (d, v) => {
            if (d)
              o(d);
            else if (v) {
              const M = {};
              for (const { stack: D, id: x, glyph: E } of v)
                M[D] === void 0 && (M[D] = {}), M[D].glyphs === void 0 && (M[D].glyphs = {}), M[D].glyphs[x] = E && { id: E.id, bitmap: E.bitmap.clone(), metrics: E.metrics }, M[D].ascender = this.entries[D].ascender, M[D].descender = this.entries[D].descender;
              o(null, M);
            }
          });
        }
        _doesCharSupportLocalGlyph(e) {
          return this.localGlyphMode !== k_.none && (this.localGlyphMode === k_.all ? !!this.localFontFamily : !!this.localFontFamily && (Zt["CJK Unified Ideographs"](e) || Zt["Hangul Syllables"](e) || Zt.Hiragana(e) || Zt.Katakana(e) || Zt["CJK Symbols and Punctuation"](e) || Zt["CJK Unified Ideographs Extension A"](e) || Zt["CJK Unified Ideographs Extension B"](e) || Zt.Osage(e)));
        }
        _tinySDF(e, n, o) {
          const u = this.localFontFamily;
          if (!u || !this._doesCharSupportLocalGlyph(o))
            return;
          let l = e.tinySDF;
          if (!l) {
            let k = "400";
            /bold/i.test(n) ? k = "900" : /medium/i.test(n) ? k = "500" : /light/i.test(n) && (k = "200"), l = e.tinySDF = new Lu.TinySDF({ fontFamily: u, fontWeight: k, fontSize: 24 * Ma, buffer: 3 * Ma, radius: 8 * Ma }), l.fontWeight = k;
          }
          if (this.localGlyphs[l.fontWeight][o])
            return this.localGlyphs[l.fontWeight][o];
          const d = String.fromCodePoint(o), { data: v, width: M, height: D, glyphWidth: x, glyphHeight: E, glyphLeft: I, glyphTop: S, glyphAdvance: C } = l.draw(d);
          return this.localGlyphs[l.fontWeight][o] = { id: o, bitmap: new mc({ width: M, height: D }, v), metrics: { width: x / Ma, height: E / Ma, left: I / Ma, top: S / Ma - 27, advance: C / Ma, localGlyph: !0 } };
        }
      }
      Lu.loadGlyphRange = function(r, e, n, o, u) {
        const l = 256 * e, d = l + 255, v = o.transformRequest(o.normalizeGlyphsURL(n).replace("{fontstack}", r).replace("{range}", `${l}-${d}`), Vo.Glyphs);
        no(v, (M, D) => {
          if (M)
            u(M);
          else if (D) {
            const x = {}, E = function(I) {
              return new Pp(I).readFields(uT, {});
            }(D);
            for (const I of E.glyphs)
              x[I.id] = I;
            u(null, { glyphs: x, ascender: E.ascender, descender: E.descender });
          }
        });
      }, Lu.TinySDF = class {
        constructor({ fontSize: r = 24, buffer: e = 3, radius: n = 8, cutoff: o = 0.25, fontFamily: u = "sans-serif", fontWeight: l = "normal", fontStyle: d = "normal" } = {}) {
          this.buffer = e, this.cutoff = o, this.radius = n;
          const v = this.size = r + 4 * e, M = this._createCanvas(v), D = this.ctx = M.getContext("2d", { willReadFrequently: !0 });
          D.font = `${d} ${l} ${r}px ${u}`, D.textBaseline = "alphabetic", D.textAlign = "left", D.fillStyle = "black", this.gridOuter = new Float64Array(v * v), this.gridInner = new Float64Array(v * v), this.f = new Float64Array(v), this.z = new Float64Array(v + 1), this.v = new Uint16Array(v);
        }
        _createCanvas(r) {
          const e = document.createElement("canvas");
          return e.width = e.height = r, e;
        }
        draw(r) {
          const { width: e, actualBoundingBoxAscent: n, actualBoundingBoxDescent: o, actualBoundingBoxLeft: u, actualBoundingBoxRight: l } = this.ctx.measureText(r), d = Math.ceil(n), v = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(l - u))), M = Math.min(this.size - this.buffer, d + Math.ceil(o)), D = v + 2 * this.buffer, x = M + 2 * this.buffer, E = Math.max(D * x, 0), I = new Uint8ClampedArray(E), S = { data: I, width: D, height: x, glyphWidth: v, glyphHeight: M, glyphTop: d, glyphLeft: 0, glyphAdvance: e };
          if (v === 0 || M === 0)
            return S;
          const { ctx: C, buffer: k, gridInner: V, gridOuter: U } = this;
          C.clearRect(k, k, v, M), C.fillText(r, k, k + d);
          const q = C.getImageData(k, k, v, M);
          U.fill($d, 0, E), V.fill(0, 0, E);
          for (let $ = 0; $ < M; $++)
            for (let H = 0; H < v; H++) {
              const K = q.data[4 * ($ * v + H) + 3] / 255;
              if (K === 0)
                continue;
              const Q = ($ + k) * D + H + k;
              if (K === 1)
                U[Q] = 0, V[Q] = $d;
              else {
                const ie = 0.5 - K;
                U[Q] = ie > 0 ? ie * ie : 0, V[Q] = ie < 0 ? ie * ie : 0;
              }
            }
          q0(U, 0, 0, D, x, D, this.f, this.v, this.z), q0(V, k, k, v, M, D, this.f, this.v, this.z);
          for (let $ = 0; $ < E; $++) {
            const H = Math.sqrt(U[$]) - Math.sqrt(V[$]);
            I[$] = Math.round(255 - 255 * (H / this.radius + this.cutoff));
          }
          return S;
        }
      };
      const gc = Wd;
      function $0(r, e) {
        return r + e[1] - e[0];
      }
      function X0(r, e, n, o, u = 1) {
        const l = [], d = r.imagePrimary, v = d.pixelRatio, M = d.paddedRect.w - 2 * gc, D = d.paddedRect.h - 2 * gc, x = (r.right - r.left) * u, E = (r.bottom - r.top) * u, I = d.stretchX || [[0, M]], S = d.stretchY || [[0, D]], C = I.reduce($0, 0), k = S.reduce($0, 0), V = M - C, U = D - k;
        let q = 0, $ = C, H = 0, K = k, Q = 0, ie = V, fe = 0, de = U;
        if (d.content && o) {
          const Me = d.content;
          q = Ip(I, 0, Me[0]), H = Ip(S, 0, Me[1]), $ = Ip(I, Me[0], Me[2]), K = Ip(S, Me[1], Me[3]), Q = Me[0] - q, fe = Me[1] - H, ie = Me[2] - Me[0] - $, de = Me[3] - Me[1] - K;
        }
        const he = (Me, me, Ee, ze) => {
          const Ie = Lp(Me.stretch - q, $, x, r.left * u), Re = zp(Me.fixed - Q, ie, Me.stretch, C), Ve = Lp(me.stretch - H, K, E, r.top * u), Ue = zp(me.fixed - fe, de, me.stretch, k), Fe = Lp(Ee.stretch - q, $, x, r.left * u), et = zp(Ee.fixed - Q, ie, Ee.stretch, C), dt = Lp(ze.stretch - H, K, E, r.top * u), tt = zp(ze.fixed - fe, de, ze.stretch, k), Tt = new Mt(Ie, Ve), vt = new Mt(Fe, Ve), Pt = new Mt(Fe, dt), rt = new Mt(Ie, dt), Ut = new Mt(Re / v, Ue / v), St = new Mt(et / v, tt / v), Nt = e * Math.PI / 180;
          if (Nt) {
            const Ii = Math.sin(Nt), fn = Math.cos(Nt), rn = [fn, -Ii, Ii, fn];
            Tt._matMult(rn), vt._matMult(rn), rt._matMult(rn), Pt._matMult(rn);
          }
          const Qt = Me.stretch + Me.fixed, pi = Ee.stretch + Ee.fixed, gi = me.stretch + me.fixed, Pi = ze.stretch + ze.fixed, yi = r.imageSecondary;
          return { tl: Tt, tr: vt, bl: rt, br: Pt, texPrimary: { x: d.paddedRect.x + gc + Qt, y: d.paddedRect.y + gc + gi, w: pi - Qt, h: Pi - gi }, texSecondary: yi ? { x: yi.paddedRect.x + gc + Qt, y: yi.paddedRect.y + gc + gi, w: pi - Qt, h: Pi - gi } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Ut, pixelOffsetBR: St, minFontScaleX: ie / v / x, minFontScaleY: de / v / E, isSDF: n };
        };
        if (o && (d.stretchX || d.stretchY)) {
          const Me = Y0(I, V, C), me = Y0(S, U, k);
          for (let Ee = 0; Ee < Me.length - 1; Ee++) {
            const ze = Me[Ee], Ie = Me[Ee + 1];
            for (let Re = 0; Re < me.length - 1; Re++)
              l.push(he(ze, me[Re], Ie, me[Re + 1]));
          }
        } else
          l.push(he({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: M + 1 }, { fixed: 0, stretch: D + 1 }));
        return l;
      }
      function Ip(r, e, n) {
        let o = 0;
        for (const u of r)
          o += Math.max(e, Math.min(n, u[1])) - Math.max(e, Math.min(n, u[0]));
        return o;
      }
      function Y0(r, e, n) {
        const o = [{ fixed: -gc, stretch: 0 }];
        for (const [u, l] of r) {
          const d = o[o.length - 1];
          o.push({ fixed: u - d.stretch, stretch: d.stretch }), o.push({ fixed: u - d.stretch, stretch: d.stretch + (l - u) });
        }
        return o.push({ fixed: e + gc, stretch: n }), o;
      }
      function Lp(r, e, n, o) {
        return r / e * n + o;
      }
      function zp(r, e, n, o) {
        return r - e * n / o;
      }
      function xT(r, e, n, o) {
        const u = e + r.positionedLines[o].lineOffset;
        return o === 0 ? n + u / 2 : n + (u + (e + r.positionedLines[o - 1].lineOffset)) / 2;
      }
      function vT(r, e = 1, n = !1) {
        let o = 1 / 0, u = 1 / 0, l = -1 / 0, d = -1 / 0;
        const v = r[0];
        for (let S = 0; S < v.length; S++) {
          const C = v[S];
          (!S || C.x < o) && (o = C.x), (!S || C.y < u) && (u = C.y), (!S || C.x > l) && (l = C.x), (!S || C.y > d) && (d = C.y);
        }
        const M = Math.min(l - o, d - u);
        let D = M / 2;
        const x = new Hl([], bT);
        if (M === 0)
          return new Mt(o, u);
        for (let S = o; S < l; S += M)
          for (let C = u; C < d; C += M)
            x.push(new zu(S + D, C + D, D, r));
        let E = function(S) {
          let C = 0, k = 0, V = 0;
          const U = S[0];
          for (let q = 0, $ = U.length, H = $ - 1; q < $; H = q++) {
            const K = U[q], Q = U[H], ie = K.x * Q.y - Q.x * K.y;
            k += (K.x + Q.x) * ie, V += (K.y + Q.y) * ie, C += 3 * ie;
          }
          return new zu(k / C, V / C, 0, S);
        }(r), I = x.length;
        for (; x.length; ) {
          const S = x.pop();
          (S.d > E.d || !E.d) && (E = S, n && console.log("found best %d after %d probes", Math.round(1e4 * S.d) / 1e4, I)), S.max - E.d <= e || (D = S.h / 2, x.push(new zu(S.p.x - D, S.p.y - D, D, r)), x.push(new zu(S.p.x + D, S.p.y - D, D, r)), x.push(new zu(S.p.x - D, S.p.y + D, D, r)), x.push(new zu(S.p.x + D, S.p.y + D, D, r)), I += 4);
        }
        return n && (console.log(`num probes: ${I}`), console.log(`best distance: ${E.d}`)), E.p;
      }
      function bT(r, e) {
        return e.max - r.max;
      }
      class zu {
        constructor(e, n, o, u) {
          this.p = new Mt(e, n), this.h = o, this.d = function(l, d) {
            let v = !1, M = 1 / 0;
            for (let D = 0; D < d.length; D++) {
              const x = d[D];
              for (let E = 0, I = x.length, S = I - 1; E < I; S = E++) {
                const C = x[E], k = x[S];
                C.y > l.y != k.y > l.y && l.x < (k.x - C.x) * (l.y - C.y) / (k.y - C.y) + C.x && (v = !v), M = Math.min(M, be(l, C, k));
              }
            }
            return (v ? 1 : -1) * Math.sqrt(M);
          }(this.p, u), this.max = this.d + this.h * Math.SQRT2;
        }
      }
      const R_ = Number.POSITIVE_INFINITY, wT = Math.sqrt(2);
      function K0(r, [e, n]) {
        let o = 0, u = 0;
        if (n === R_) {
          e < 0 && (e = 0);
          const l = e / wT;
          switch (r) {
            case "top-right":
            case "top-left":
              u = l - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              u = 7 - l;
              break;
            case "bottom":
              u = 7 - e;
              break;
            case "top":
              u = e - 7;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
              o = -l;
              break;
            case "top-left":
            case "bottom-left":
              o = l;
              break;
            case "left":
              o = e;
              break;
            case "right":
              o = -e;
          }
        } else {
          switch (e = Math.abs(e), n = Math.abs(n), r) {
            case "top-right":
            case "top-left":
            case "top":
              u = n - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              u = 7 - n;
          }
          switch (r) {
            case "top-right":
            case "bottom-right":
            case "right":
              o = -e;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              o = e;
          }
        }
        return [o, u];
      }
      function O_(r) {
        switch (r) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function TT(r, e, n, o, u, l, d, v, M, D, x, E, I, S, C, k) {
        let V = l.textMaxSize.evaluate(e, {}, I);
        V === void 0 ? V = d * l.textScaleFactor : V *= l.textScaleFactor;
        const U = r.layers[0].layout, q = U.get("icon-offset").evaluate(e, {}, I), $ = Q0(n.horizontal) || n.vertical, H = S.name === "globe", K = er, Q = d * l.textScaleFactor / K, ie = r.tilePixelRatio * V / K, fe = (Re = r.overscaling, r.zoom > 18 && Re > 2 && (Re >>= 1), Math.max(wt / (512 * Re), 1) * U.get("symbol-spacing")), de = U.get("text-padding") * r.tilePixelRatio, he = U.get("icon-padding") * r.tilePixelRatio, Me = vi(U.get("text-max-angle")), me = U.get("text-rotation-alignment") === "map" && U.get("symbol-placement") !== "point", Ee = U.get("icon-rotation-alignment") === "map" && U.get("symbol-placement") !== "point", ze = U.get("symbol-placement"), Ie = fe / 2;
        var Re;
        const Ve = U.get("icon-text-fit").evaluate(e, {}, I), Ue = U.get("icon-text-fit-padding").evaluate(e, {}, I), Fe = Ve !== "none";
        let et;
        r.hasAnyIconTextFit === !1 && Fe && (r.hasAnyIconTextFit = !0), o && Fe && (r.allowVerticalPlacement && n.vertical && (et = F0(o, n.vertical, Ve, Ue, q, Q)), $ && (o = F0(o, $, Ve, Ue, q, Q)));
        const dt = (tt, Tt, vt) => {
          if (Tt.x < 0 || Tt.x >= wt || Tt.y < 0 || Tt.y >= wt)
            return;
          let Pt = null;
          if (H) {
            const { x: rt, y: Ut, z: St } = S.projectTilePoint(Tt.x, Tt.y, vt);
            Pt = { anchor: new Il(rt, Ut, St, 0, void 0), up: S.upVector(vt, Tt.x, Tt.y) };
          }
          (function(rt, Ut, St, Nt, Qt, pi, gi, Pi, yi, Ii, fn, rn, hi, on, Qi, pn, as, ls, Kn, Vr, Mn, Ln, Tr, cs, to, Ss, il, wc) {
            const Tc = rt.addToLineVertexArray(Ut, Nt);
            let Ll, Sc, Mc, rm, Lv, zv, Dv, kv = 0, Rv = 0, Ov = 0, Fv = 0, gg = -1, yg = -1;
            const nl = {};
            let Bv = $r("");
            const wh = St ? St.anchor : Ut, xg = yi.layout.get("icon-text-fit").evaluate(Mn, {}, Ss) !== "none";
            let vg = 0, bg = 0;
            if (yi._unevaluatedLayout.getValue("text-radial-offset") === void 0 ? [vg, bg] = yi.layout.get("text-offset").evaluate(Mn, {}, Ss).map((Oo) => Oo * er) : (vg = yi.layout.get("text-radial-offset").evaluate(Mn, {}, Ss) * er, bg = R_), rt.allowVerticalPlacement && Qt.vertical) {
              const Oo = Qt.vertical;
              if (Qi)
                zv = F_(Oo), Pi && (Dv = F_(Pi));
              else {
                const po = yi.layout.get("text-rotate").evaluate(Mn, {}, Ss) + 90;
                Mc = Dp(Ii, wh, Ut, fn, rn, hi, Oo, on, po, pn), Pi && (rm = Dp(Ii, wh, Ut, fn, rn, hi, Pi, ls, po));
              }
            }
            if (pi) {
              const Oo = rt.iconSizeData, po = cs ? Ep(rt.iconSizeData, rt.layers[0]._unevaluatedLayout._values["icon-size"], Ss, rt.zoom, Mn) : 1, Gu = yi.layout.get("icon-rotate").evaluate(Mn, {}, Ss), Nv = X0(pi, Gu, Tr, xg, cs ? 1 / po : Ln.iconScaleFactor), Tg = Pi ? X0(Pi, Gu, Tr, xg, Ln.iconScaleFactor) : void 0;
              Sc = Dp(Ii, wh, Ut, fn, rn, hi, pi, ls, Gu, null, cs ? Ln.iconScaleFactor * po : 1), kv = 4 * Nv.length;
              let Th = null;
              Oo.kind === "source" ? (Th = [Sa * yi.layout.get("icon-size").evaluate(Mn, {}, Ss) * Ln.iconScaleFactor], Th[0] > yc && mi(`${rt.layerIds[0]}: Value for "icon-size" is >= ${Xd}. Reduce your "icon-size".`)) : Oo.kind === "composite" && (Th = [Sa * Ln.compositeIconSizes[0].evaluate(Mn, {}, Ss) * Ln.iconScaleFactor, Sa * Ln.compositeIconSizes[1].evaluate(Mn, {}, Ss) * Ln.iconScaleFactor], (Th[0] > yc || Th[1] > yc) && mi(`${rt.layerIds[0]}: Value for "icon-size" is >= ${Xd}. Reduce your "icon-size".`)), rt.addSymbols(rt.icon, Nv, Th, Vr, Kn, Mn, !1, St, Ut, Tc.lineStartIndex, Tc.lineLength, -1, to, Ss, il, wc), gg = rt.icon.placedSymbolArray.length - 1, Tg && (Rv = 4 * Tg.length, rt.addSymbols(rt.icon, Tg, Th, Vr, Kn, Mn, ko.vertical, St, Ut, Tc.lineStartIndex, Tc.lineLength, -1, to, Ss, il, wc), yg = rt.icon.placedSymbolArray.length - 1);
            }
            for (const Oo in Qt.horizontal) {
              const po = Qt.horizontal[Oo];
              Ll || (Bv = $r(po.text), Qi ? Lv = F_(po) : Ll = Dp(Ii, wh, Ut, fn, rn, hi, po, on, yi.layout.get("text-rotate").evaluate(Mn, {}, Ss), pn));
              const Gu = po.positionedLines.length === 1;
              if (Ov += J0(rt, St, Ut, po, gi, yi, Qi, Mn, pn, Tc, Qt.vertical ? ko.horizontal : ko.horizontalOnly, Gu ? Object.keys(Qt.horizontal) : [Oo], nl, gg, Ln, to, Ss, il), Gu)
                break;
            }
            Qt.vertical && (Fv += J0(rt, St, Ut, Qt.vertical, gi, yi, Qi, Mn, pn, Tc, ko.vertical, ["vertical"], nl, yg, Ln, to, Ss, il));
            let Ec = -1;
            const wg = (Oo, po) => Oo ? Math.max(Oo, po) : po;
            Ec = wg(Lv, Ec), Ec = wg(zv, Ec), Ec = wg(Dv, Ec);
            const iS = Ec > -1 ? 1 : 0;
            rt.glyphOffsetArray.length >= 65535 && mi("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), Mn.sortKey !== void 0 && rt.addToSortKeyRanges(rt.symbolInstances.length, Mn.sortKey), rt.symbolInstances.emplaceBack(Ut.x, Ut.y, wh.x, wh.y, wh.z, nl.right >= 0 ? nl.right : -1, nl.center >= 0 ? nl.center : -1, nl.left >= 0 ? nl.left : -1, nl.vertical >= 0 ? nl.vertical : -1, gg, yg, Bv, Ll !== void 0 ? Ll : rt.collisionBoxArray.length, Ll !== void 0 ? Ll + 1 : rt.collisionBoxArray.length, Mc !== void 0 ? Mc : rt.collisionBoxArray.length, Mc !== void 0 ? Mc + 1 : rt.collisionBoxArray.length, Sc !== void 0 ? Sc : rt.collisionBoxArray.length, Sc !== void 0 ? Sc + 1 : rt.collisionBoxArray.length, rm || rt.collisionBoxArray.length, rm ? rm + 1 : rt.collisionBoxArray.length, fn, Ov, Fv, kv, Rv, iS, 0, vg, bg, Ec, 0, xg ? 1 : 0);
          })(r, Tt, Pt, tt, n, o, u, et, r.layers[0], r.collisionBoxArray, e.index, e.sourceLayerIndex, r.index, de, me, M, 0, he, Ee, q, e, l, D, x, E, I, C, k);
        };
        if (ze === "line")
          for (const tt of G0(e.geometry, 0, 0, wt, wt)) {
            const Tt = yT(tt, fe, Me, n.vertical || $, o, K, ie, r.overscaling, wt);
            for (const vt of Tt)
              $ && ST(r, $.text, Ie, vt) || dt(tt, vt, I);
          }
        else if (ze === "line-center") {
          for (const tt of e.geometry)
            if (tt.length > 1) {
              const Tt = gT(tt, Me, n.vertical || $, o, K, ie);
              Tt && dt(tt, Tt, I);
            }
        } else if (e.type === "Polygon")
          for (const tt of xp(e.geometry, 0)) {
            const Tt = vT(tt, 16);
            dt(tt[0], new Il(Tt.x, Tt.y, 0, 0, void 0), I);
          }
        else if (e.type === "LineString")
          for (const tt of e.geometry)
            dt(tt, new Il(tt[0].x, tt[0].y, 0, 0, void 0), I);
        else if (e.type === "Point")
          for (const tt of e.geometry)
            for (const Tt of tt)
              dt([Tt], new Il(Tt.x, Tt.y, 0, 0, void 0), I);
      }
      const Xd = 255, yc = Xd * Sa;
      function J0(r, e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V, U) {
        const q = function(K, Q, ie, fe, de, he, Me, me) {
          const Ee = [];
          if (Q.positionedLines.length === 0)
            return Ee;
          const ze = fe.layout.get("text-rotate").evaluate(he, {}) * Math.PI / 180, Ie = function(et) {
            const dt = et[0], tt = et[1], Tt = dt * tt;
            return Tt > 0 ? [dt, -tt] : Tt < 0 ? [-dt, tt] : dt === 0 ? [tt, dt] : [tt, -dt];
          }(ie);
          let Re = Math.abs(Q.top - Q.bottom);
          for (const et of Q.positionedLines)
            Re -= et.lineOffset;
          const Ve = Q.positionedLines.length, Ue = Re / Ve;
          let Fe = Q.top - ie[1];
          for (let et = 0; et < Ve; ++et) {
            const dt = Q.positionedLines[et];
            Fe = xT(Q, Ue, Fe, et);
            for (const tt of dt.positionedGlyphs) {
              if (!tt.rect)
                continue;
              const Tt = tt.rect || {};
              let vt = L0 + 1, Pt = !0, rt = 1, Ut = 0;
              if (tt.imageName) {
                const Kn = Me[ss.build(tt.imageName).getSerializedPrimary()];
                if (!Kn)
                  continue;
                if (Kn.sdf) {
                  mi("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                Pt = !1, rt = Kn.pixelRatio, vt = Wd / rt;
              }
              const St = (de || me) && tt.vertical, Nt = tt.metrics.advance * tt.scale / 2, Qt = tt.metrics, pi = tt.rect;
              if (pi === null)
                continue;
              me && Q.verticalizable && (Ut = tt.imageName ? Nt - tt.metrics.width * tt.scale / 2 : 0);
              const gi = de ? [tt.x + Nt, tt.y] : [0, 0];
              let Pi = [0, 0], yi = [0, 0], Ii = !1;
              de || (St ? (yi = [tt.x + Nt + Ie[0], tt.y + Ie[1] - Ut], Ii = !0) : Pi = [tt.x + Nt + ie[0], tt.y + ie[1] - Ut]);
              const fn = pi.w * tt.scale / (rt * (tt.localGlyph ? Ma : 1)), rn = pi.h * tt.scale / (rt * (tt.localGlyph ? Ma : 1));
              let hi, on, Qi, pn;
              if (St) {
                const Kn = tt.y - Fe, Vr = new Mt(-Nt, Nt - Kn), Mn = -Math.PI / 2, Ln = new Mt(...yi);
                hi = new Mt(-Nt + Pi[0], Pi[1]), hi._rotateAround(Mn, Vr)._add(Ln), hi.x += -Kn + Nt, hi.y -= (Qt.left - vt) * tt.scale;
                const Tr = tt.imageName ? Qt.advance * tt.scale : er * tt.scale, cs = String.fromCodePoint(tt.glyph);
                lT(cs) ? hi.x += (1 - vt) * tt.scale : cT(cs) ? hi.x += Tr - Qt.height * tt.scale + (-vt - 1) * tt.scale : hi.x += tt.imageName || Qt.width + 2 * vt === pi.w && Qt.height + 2 * vt === pi.h ? (Tr - rn) / 2 : (Tr - (Qt.height + 2 * vt) * tt.scale) / 2, on = new Mt(hi.x, hi.y - fn), Qi = new Mt(hi.x + rn, hi.y), pn = new Mt(hi.x + rn, hi.y - fn);
              } else {
                const Kn = (Qt.left - vt) * tt.scale - Nt + Pi[0], Vr = (-Qt.top - vt) * tt.scale + Pi[1], Mn = Kn + fn, Ln = Vr + rn;
                hi = new Mt(Kn, Vr), on = new Mt(Mn, Vr), Qi = new Mt(Kn, Ln), pn = new Mt(Mn, Ln);
              }
              if (ze) {
                let Kn;
                Kn = de ? new Mt(0, 0) : Ii ? new Mt(Ie[0], Ie[1]) : new Mt(ie[0], ie[1]), hi._rotateAround(ze, Kn), on._rotateAround(ze, Kn), Qi._rotateAround(ze, Kn), pn._rotateAround(ze, Kn);
              }
              const as = new Mt(0, 0), ls = new Mt(0, 0);
              Ee.push({ tl: hi, tr: on, bl: Qi, br: pn, texPrimary: Tt, texSecondary: void 0, writingMode: Q.writingMode, glyphOffset: gi, sectionIndex: tt.sectionIndex, isSDF: Pt, pixelOffsetTL: as, pixelOffsetBR: ls, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return Ee;
        }(0, o, M, l, d, v, u, r.allowVerticalPlacement), $ = r.textSizeData;
        let H = null;
        $.kind === "source" ? (H = [Sa * l.layout.get("text-size").evaluate(v, {}, V) * C.textScaleFactor], H[0] > yc && mi(`${r.layerIds[0]}: Value for "text-size" is >= ${Xd}. Reduce your "text-size".`)) : $.kind === "composite" && (H = [Sa * C.compositeTextSizes[0].evaluate(v, {}, V) * C.textScaleFactor, Sa * C.compositeTextSizes[1].evaluate(v, {}, V) * C.textScaleFactor], (H[0] > yc || H[1] > yc) && mi(`${r.layerIds[0]}: Value for "text-size" is >= ${Xd}. Reduce your "text-size".`)), r.addSymbols(r.text, q, H, M, d, v, x, e, n, D.lineStartIndex, D.lineLength, S, k, V, U, !1);
        for (const K of E)
          I[K] = r.text.placedSymbolArray.length - 1;
        return 4 * q.length;
      }
      function Q0(r) {
        for (const e in r)
          return r[e];
        return null;
      }
      function Dp(r, e, n, o, u, l, d, v, M, D, x = 1) {
        let E = d.top / x, I = d.bottom / x, S = d.left / x, C = d.right / x;
        const k = d.collisionPadding;
        if (k && (S -= k[0], E -= k[1], C += k[2], I += k[3]), M) {
          const V = new Mt(S, E), U = new Mt(C, E), q = new Mt(S, I), $ = new Mt(C, I), H = vi(M);
          let K = new Mt(0, 0);
          D && (K = new Mt(D[0], D[1])), V._rotateAround(H, K), U._rotateAround(H, K), q._rotateAround(H, K), $._rotateAround(H, K), S = Math.min(V.x, U.x, q.x, $.x), C = Math.max(V.x, U.x, q.x, $.x), E = Math.min(V.y, U.y, q.y, $.y), I = Math.max(V.y, U.y, q.y, $.y);
        }
        return r.emplaceBack(e.x, e.y, e.z, n.x, n.y, S, E, C, I, v, o, u, l), r.length - 1;
      }
      function F_(r) {
        r.collisionPadding && (r.top -= r.collisionPadding[1], r.bottom += r.collisionPadding[3]);
        const e = r.bottom - r.top;
        return e > 0 ? Math.max(10, e) : null;
      }
      function ST(r, e, n, o) {
        const u = r.compareText;
        if (e in u) {
          const l = u[e];
          for (let d = l.length - 1; d >= 0; d--)
            if (o.dist(l[d]) < n)
              return !0;
        } else
          u[e] = [];
        return u[e].push(o), !1;
      }
      function ex(r, e) {
        const n = r.fovAboveCenter, o = r.elevation ? r.elevation.getMinElevationBelowMSL() * e : 0, u = (r._camera.position[2] * r.worldSize - o) / Math.cos(r._pitch), l = Math.sin(n) * u / Math.sin(Math.max(Math.PI / 2 - r._pitch - n, 0.01));
        let d = Math.sin(r._pitch) * l + u;
        const v = u * (1 / r._horizonShift);
        return r.elevation && r.elevation.exaggeration() !== 0 || (d *= 1 + Math.max(r.zoom - 17, 0)), Math.min(1.01 * d, v);
      }
      function Yd(r, e) {
        if (!e.isReprojectedInTileSpace)
          return { scale: 1 << r.z, x: r.x, y: r.y, x2: r.x + 1, y2: r.y + 1, projection: e };
        const n = Math.pow(2, -r.z), o = r.x * n, u = (r.x + 1) * n, l = r.y * n, d = (r.y + 1) * n, v = Fr(o), M = Fr(u), D = Os(l), x = Os(d), E = e.project(v, D), I = e.project(M, D), S = e.project(M, x), C = e.project(v, x);
        let k = Math.min(E.x, I.x, S.x, C.x), V = Math.min(E.y, I.y, S.y, C.y), U = Math.max(E.x, I.x, S.x, C.x), q = Math.max(E.y, I.y, S.y, C.y);
        const $ = n / 16;
        function H(Q, ie, fe, de, he, Me) {
          const me = (fe + he) / 2, Ee = (de + Me) / 2, ze = e.project(Fr(me), Os(Ee)), Ie = Math.max(0, k - ze.x, V - ze.y, ze.x - U, ze.y - q);
          k = Math.min(k, ze.x), U = Math.max(U, ze.x), V = Math.min(V, ze.y), q = Math.max(q, ze.y), Ie > $ && (H(Q, ze, fe, de, me, Ee), H(ze, ie, me, Ee, he, Me));
        }
        H(E, I, o, l, u, l), H(I, S, u, l, u, d), H(S, C, u, d, o, d), H(C, E, o, d, o, l), k -= $, V -= $, U += $, q += $;
        const K = 1 / Math.max(U - k, q - V);
        return { scale: K, x: k * K, y: V * K, x2: U * K, y2: q * K, projection: e };
      }
      function tx(r, { x: e, y: n }, o = 0) {
        return new Mt(((e - o) * r.scale - r.x) * wt, (n * r.scale - r.y) * wt);
      }
      const MT = De.mat4.identity(new Float32Array(16));
      class xc {
        constructor(e) {
          this.spec = e, this.name = e.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
        }
        project(e, n) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(e, n) {
          return new Ui(0, 0);
        }
        projectTilePoint(e, n, o) {
          return { x: e, y: n, z: 0 };
        }
        locationPoint(e, n, o = !0) {
          return e._coordinatePoint(e.locationCoordinate(n), o);
        }
        pixelsPerMeter(e, n) {
          return fr(1, e) * n;
        }
        pixelSpaceConversion(e, n, o) {
          return 1;
        }
        farthestPixelDistance(e) {
          return ex(e, e.pixelsPerMeter);
        }
        pointCoordinate(e, n, o, u) {
          const l = e.horizonLineFromTop(!1), d = new Mt(n, Math.max(l, o));
          return e.rayIntersectionCoordinate(e.pointRayIntersection(d, u));
        }
        pointCoordinate3D(e, n, o) {
          const u = new Mt(n, o);
          if (e.elevation)
            return e.elevation.pointCoordinate(u);
          {
            const l = this.pointCoordinate(e, u.x, u.y, 0);
            return [l.x, l.y, l.z];
          }
        }
        isPointAboveHorizon(e, n) {
          if (e.elevation && e.elevation.visibleDemTiles.length)
            return !this.pointCoordinate3D(e, n.x, n.y);
          const o = e.horizonLineFromTop();
          return n.y < o;
        }
        createInversionMatrix(e, n) {
          return MT;
        }
        createTileMatrix(e, n, o) {
          let u, l, d;
          const v = o.canonical, M = De.mat4.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const D = Yd(v, this);
            u = 1, l = D.x + o.wrap * D.scale, d = D.y, De.mat4.scale(M, M, [u / D.scale, u / D.scale, e.pixelsPerMeter / n]);
          } else
            u = n / e.zoomScale(v.z), l = (v.x + Math.pow(2, v.z) * o.wrap) * u, d = v.y * u;
          return De.mat4.translate(M, M, [l, d, 0]), De.mat4.scale(M, M, [u / wt, u / wt, 1]), M;
        }
        upVector(e, n, o) {
          return [0, 0, 1];
        }
        upVectorScale(e, n, o) {
          return { metersToTile: 1 };
        }
      }
      class ET extends xc {
        constructor(e) {
          super(e), this.range = [4, 7], this.center = e.center || [-96, 37.5];
          const [n, o] = this.parallels = e.parallels || [29.5, 45.5], u = Math.sin(vi(n));
          this.n = (u + Math.sin(vi(o))) / 2, this.c = 1 + u * (2 * this.n - u), this.r0 = Math.sqrt(this.c) / this.n;
        }
        project(e, n) {
          const { n: o, c: u, r0: l } = this, d = vi(e - this.center[0]), v = vi(n), M = Math.sqrt(u - 2 * o * Math.sin(v)) / o;
          return { x: M * Math.sin(d * o), y: M * Math.cos(d * o) - l, z: 0 };
        }
        unproject(e, n) {
          const { n: o, c: u, r0: l } = this, d = l + n;
          let v = Math.atan2(e, Math.abs(d)) * Math.sign(d);
          d * o < 0 && (v -= Math.PI * Math.sign(e) * Math.sign(d));
          const M = vi(this.center[0]) * o;
          v = zn(v, -Math.PI - M, Math.PI - M);
          const D = si(kn(v / o) + this.center[0], -180, 180), x = Math.asin(si((u - (e * e + d * d) * o * o) / (2 * o), -1, 1)), E = si(kn(x), -Un, Un);
          return new Ui(D, E);
        }
      }
      const Kd = 1.340264, Jd = -0.081106, Qd = 893e-6, ef = 3796e-6, kp = Math.sqrt(3) / 2;
      class AT extends xc {
        project(e, n) {
          n = n / 180 * Math.PI, e = e / 180 * Math.PI;
          const o = Math.asin(kp * Math.sin(n)), u = o * o, l = u * u * u;
          return { x: 0.5 * (e * Math.cos(o) / (kp * (Kd + 3 * Jd * u + l * (7 * Qd + 9 * ef * u))) / Math.PI + 0.5), y: 1 - 0.5 * (o * (Kd + Jd * u + l * (Qd + ef * u)) / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI;
          let o = n = (2 * (1 - n) - 1) * Math.PI, u = o * o, l = u * u * u;
          for (let x, E, I, S = 0; S < 12 && (E = o * (Kd + Jd * u + l * (Qd + ef * u)) - n, I = Kd + 3 * Jd * u + l * (7 * Qd + 9 * ef * u), x = E / I, o = si(o - x, -Math.PI / 3, Math.PI / 3), u = o * o, l = u * u * u, !(Math.abs(x) < 1e-12)); ++S)
            ;
          const d = kp * e * (Kd + 3 * Jd * u + l * (7 * Qd + 9 * ef * u)) / Math.cos(o), v = Math.asin(Math.sin(o) / kp), M = si(180 * d / Math.PI, -180, 180), D = si(180 * v / Math.PI, -Un, Un);
          return new Ui(M, D);
        }
      }
      class PT extends xc {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, n) {
          return { x: 0.5 + e / 360, y: 0.5 - n / 360, z: 0 };
        }
        unproject(e, n) {
          const o = 360 * (e - 0.5), u = si(360 * (0.5 - n), -Un, Un);
          return new Ui(o, u);
        }
      }
      const Du = Math.PI / 2;
      function Rp(r) {
        return Math.tan((Du + r) / 2);
      }
      class CT extends xc {
        constructor(e) {
          super(e), this.center = e.center || [0, 30];
          const [n, o] = this.parallels = e.parallels || [30, 30];
          let u = vi(n), l = vi(o);
          this.southernCenter = u + l < 0, this.southernCenter && (u = -u, l = -l);
          const d = Math.cos(u), v = Rp(u);
          this.n = u === l ? Math.sin(u) : Math.log(d / Math.cos(l)) / Math.log(Rp(l) / v), this.f = d * Math.pow(Rp(u), this.n) / this.n;
        }
        project(e, n) {
          n = vi(n), this.southernCenter && (n = -n), e = vi(e - this.center[0]);
          const o = 1e-6, { n: u, f: l } = this;
          l > 0 ? n < -Du + o && (n = -Du + o) : n > Du - o && (n = Du - o);
          const d = l / Math.pow(Rp(n), u);
          let v = d * Math.sin(u * e), M = l - d * Math.cos(u * e);
          return v = 0.5 * (v / Math.PI + 0.5), M = 0.5 * (M / Math.PI + 0.5), { x: v, y: this.southernCenter ? M : 1 - M, z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI, this.southernCenter && (n = 1 - n), n = (2 * (1 - n) - 0.5) * Math.PI;
          const { n: o, f: u } = this, l = u - n, d = Math.sign(l), v = Math.sign(o) * Math.sqrt(e * e + l * l);
          let M = Math.atan2(e, Math.abs(l)) * d;
          l * o < 0 && (M -= Math.PI * Math.sign(e) * d);
          const D = si(kn(M / o) + this.center[0], -180, 180), x = si(kn(2 * Math.atan(Math.pow(u / v, 1 / o)) - Du), -Un, Un);
          return new Ui(D, this.southernCenter ? -x : x);
        }
      }
      class ix extends xc {
        constructor(e) {
          super(e), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
        }
        project(e, n) {
          return { x: ea(e), y: wa(n), z: 0 };
        }
        unproject(e, n) {
          const o = Fr(e), u = Os(n);
          return new Ui(o, u);
        }
      }
      const nx = vi(Un);
      class IT extends xc {
        project(e, n) {
          const o = (n = vi(n)) * n, u = o * o;
          return { x: 0.5 * ((e = vi(e)) * (0.8707 - 0.131979 * o + u * (u * (3971e-6 * o - 1529e-6 * u) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (n * (1.007226 + o * (0.015085 + u * (0.028874 * o - 0.044475 - 5916e-6 * u))) / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          e = (2 * e - 0.5) * Math.PI;
          let o = n = (2 * (1 - n) - 1) * Math.PI, u = 25, l = 0, d = o * o;
          do {
            d = o * o;
            const D = d * d;
            l = (o * (1.007226 + d * (0.015085 + D * (0.028874 * d - 0.044475 - 5916e-6 * D))) - n) / (1.007226 + d * (0.045255 + D * (0.259866 * d - 0.311325 - 5916e-6 * 11 * D))), o = si(o - l, -nx, nx);
          } while (Math.abs(l) > 1e-6 && --u > 0);
          d = o * o;
          const v = si(kn(e / (0.8707 + d * (d * (d * d * d * (3971e-6 - 1529e-6 * d) - 0.013791) - 0.131979))), -180, 180), M = kn(o);
          return new Ui(v, M);
        }
      }
      const sx = vi(Un);
      class LT extends xc {
        project(e, n) {
          n = vi(n), e = vi(e);
          const o = Math.cos(n), u = 2 / Math.PI, l = Math.acos(o * Math.cos(e / 2)), d = Math.sin(l) / l, v = 0.5 * (e * u + 2 * o * Math.sin(e / 2) / d) || 0, M = 0.5 * (n + Math.sin(n) / d) || 0;
          return { x: 0.5 * (v / Math.PI + 0.5), y: 1 - 0.5 * (M / Math.PI + 1), z: 0 };
        }
        unproject(e, n) {
          let o = e = (2 * e - 0.5) * Math.PI, u = n = (2 * (1 - n) - 1) * Math.PI, l = 25;
          const d = 1e-6;
          let v = 0, M = 0;
          do {
            const D = Math.cos(u), x = Math.sin(u), E = 2 * x * D, I = x * x, S = D * D, C = Math.cos(o / 2), k = Math.sin(o / 2), V = 2 * C * k, U = k * k, q = 1 - S * C * C, $ = q ? 1 / q : 0, H = q ? Math.acos(D * C) * Math.sqrt(1 / q) : 0, K = 0.5 * (2 * H * D * k + 2 * o / Math.PI) - e, Q = 0.5 * (H * x + u) - n, ie = 0.5 * $ * (S * U + H * D * C * I) + 1 / Math.PI, fe = $ * (V * E / 4 - H * x * k), de = 0.125 * $ * (E * k - H * x * S * V), he = 0.5 * $ * (I * C + H * U * D) + 0.5, Me = fe * de - he * ie;
            v = (Q * fe - K * he) / Me, M = (K * de - Q * ie) / Me, o = si(o - v, -Math.PI, Math.PI), u = si(u - M, -sx, sx);
          } while ((Math.abs(v) > d || Math.abs(M) > d) && --l > 0);
          return new Ui(kn(o), kn(u));
        }
      }
      class rx extends xc {
        constructor(e) {
          super(e), this.center = e.center || [0, 0], this.parallels = e.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(vi(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
        }
        project(e, n) {
          const { scale: o, cosPhi: u } = this;
          return { x: vi(e) * u * o + 0.5, y: -Math.sin(vi(n)) / u * o + 0.5, z: 0 };
        }
        unproject(e, n) {
          const { scale: o, cosPhi: u } = this, l = -(n - 0.5) / o, d = si(kn((e - 0.5) / o) / u, -180, 180), v = Math.asin(si(l * u, -1, 1)), M = si(kn(v), -Un, Un);
          return new Ui(d, M);
        }
      }
      class zT extends ix {
        constructor(e) {
          super(e), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
        }
        projectTilePoint(e, n, o) {
          const u = Ri(e, n, o), l = cn(ts(o));
          return De.vec3.transformMat4(u, u, l), { x: u[0], y: u[1], z: u[2] };
        }
        locationPoint(e, n) {
          const o = Ja(n.lat, n.lng), u = De.vec3.normalize([], o), l = e.elevation ? e.elevation.getAtPointOrZero(e.locationCoordinate(n), e._centerAltitude) : e._centerAltitude, d = fr(1, 0) * wt * l;
          De.vec3.scaleAndAdd(o, o, u, d);
          const v = De.mat4.identity(new Float64Array(16));
          return De.mat4.multiply(v, e.pixelMatrix, e.globeMatrix), De.vec3.transformMat4(o, o, v), new Mt(o[0], o[1]);
        }
        pixelsPerMeter(e, n) {
          return fr(1, 0) * n;
        }
        pixelSpaceConversion(e, n, o) {
          const u = fr(1, e) * n, l = ei(fr(1, 45) * n, u, o);
          return this.pixelsPerMeter(e, n) / l;
        }
        createTileMatrix(e, n, o) {
          const u = Qs(ts(o.canonical));
          return De.mat4.multiply(new Float64Array(16), e.globeMatrix, u);
        }
        createInversionMatrix(e, n) {
          const { center: o } = e, u = cn(ts(n));
          return De.mat4.rotateY(u, u, vi(o.lng)), De.mat4.rotateX(u, u, vi(o.lat)), De.mat4.scale(u, u, [e._pixelsPerMercatorPixel, e._pixelsPerMercatorPixel, 1]), Float32Array.from(u);
        }
        pointCoordinate(e, n, o, u) {
          return In(e, n, o, !0) || new h(0, 0);
        }
        pointCoordinate3D(e, n, o) {
          const u = this.pointCoordinate(e, n, o, 0);
          return [u.x, u.y, u.z];
        }
        isPointAboveHorizon(e, n) {
          return !In(e, n.x, n.y, !1);
        }
        farthestPixelDistance(e) {
          const n = function(u, l) {
            const d = u.cameraToCenterDistance, v = u._centerAltitude * l, M = u._camera, D = u._camera.forward(), x = De.vec3.add([], De.vec3.scale([], D, -d), [0, 0, v]), E = u.worldSize / (2 * Math.PI), I = [0, 0, -E], S = u.width / u.height, C = Math.tan(u.fovAboveCenter), k = De.vec3.scale([], M.up(), C), V = De.vec3.scale([], M.right(), C * S), U = De.vec3.normalize([], De.vec3.add([], De.vec3.add([], D, k), V)), q = [];
            let $;
            if (new zi(x, U).closestPointOnSphere(I, E, q)) {
              const H = De.vec3.add([], q, I), K = De.vec3.sub([], H, x);
              $ = Math.cos(u.fovAboveCenter) * De.vec3.length(K);
            } else {
              const H = De.vec3.sub([], x, I), K = De.vec3.sub([], I, x);
              De.vec3.normalize(K, K);
              const Q = De.vec3.length(H) - E;
              $ = Math.sqrt(Q * (Q + 2 * E));
              const ie = Math.acos($ / (E + Q)) - Math.acos(De.vec3.dot(D, K));
              $ *= Math.cos(ie);
            }
            return 1.01 * $;
          }(e, this.pixelsPerMeter(e.center.lat, e.worldSize)), o = mr(e.zoom);
          if (o > 0) {
            const u = ex(e, fr(1, e.center.lat) * e.worldSize), l = e.worldSize / (2 * Math.PI), d = Math.max(e.width, e.height) / e.worldSize * Math.PI;
            return ei(n, u + l * (1 - Math.cos(d)), Math.pow(o, 10));
          }
          return n;
        }
        upVector(e, n, o) {
          return Ri(n, o, e, 1);
        }
        upVectorScale(e) {
          return { metersToTile: ji(Gn(ts(e))) };
        }
      }
      function ox(r) {
        const e = r.parallels, n = !!e && Math.abs(e[0] + e[1]) < 0.01;
        switch (r.name) {
          case "mercator":
            return new ix(r);
          case "equirectangular":
            return new PT(r);
          case "naturalEarth":
            return new IT(r);
          case "equalEarth":
            return new AT(r);
          case "winkelTripel":
            return new LT(r);
          case "albers":
            return n ? new rx(r) : new ET(r);
          case "lambertConformalConic":
            return n ? new rx(r) : new CT(r);
          case "globe":
            return new zT(r);
        }
        throw new Error(`Invalid projection name: ${r.name}`);
      }
      const DT = Pu.VectorTileFeature.types, kT = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function Op(r, e, n, o, u, l, d, v, M, D, x, E, I) {
        const S = v ? Math.min(yc, Math.round(v[0])) : 0, C = v ? Math.min(yc, Math.round(v[1])) : 0;
        r.emplaceBack(e, n, Math.round(32 * o), Math.round(32 * u), l, d, (S << 1) + (M ? 1 : 0), C, 16 * D, 16 * x, 256 * E, 256 * I);
      }
      function Fp(r, e, n) {
        r.emplaceBack(e, n);
      }
      function Bp(r, e, n, o, u, l, d) {
        r.emplaceBack(e, n, o, u, l, d);
      }
      function Np(r, e, n, o, u) {
        r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u), r.emplaceBack(e, n, o, u);
      }
      function RT(r) {
        for (const e of r.sections)
          if ($f(e.text))
            return !0;
        return !1;
      }
      class B_ {
        constructor(e) {
          this.layoutVertexArray = new vd(), this.indexArray = new qs(), this.programConfigurations = e, this.segments = new Wn(), this.dynamicLayoutVertexArray = new Wa(), this.opacityVertexArray = new wd(), this.placedSymbolArray = new sp(), this.iconTransitioningVertexArray = new Xa(), this.globeExtVertexArray = new bd(), this.zOffsetVertexArray = new cc();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0;
        }
        upload(e, n, o, u, l) {
          this.isEmpty() || (o && (this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, Jw.members), this.indexBuffer = e.createIndexBuffer(this.indexArray, n), this.dynamicLayoutVertexBuffer = e.createVertexBuffer(this.dynamicLayoutVertexArray, eT.members, !0), this.opacityVertexBuffer = e.createVertexBuffer(this.opacityVertexArray, kT, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = e.createVertexBuffer(this.iconTransitioningVertexArray, iT.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = e.createVertexBuffer(this.globeExtVertexArray, Qw.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || l) && (this.zOffsetVertexBuffer = e.createVertexBuffer(this.zOffsetVertexArray, tT.members, !0)), this.opacityVertexBuffer.itemSize = 1), (o || u) && this.programConfigurations.upload(e));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      Ft(B_, "SymbolBuffers");
      class N_ {
        constructor(e, n, o) {
          this.layoutVertexArray = new e(), this.layoutAttributes = n, this.indexArray = new o(), this.segments = new Wn(), this.collisionVertexArray = new Sd(), this.collisionVertexArrayExt = new Wa();
        }
        upload(e) {
          this.layoutVertexBuffer = e.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = e.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = e.createVertexBuffer(this.collisionVertexArray, nT.members, !0), this.collisionVertexBufferExt = e.createVertexBuffer(this.collisionVertexArrayExt, sT.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Ft(N_, "CollisionBuffers");
      class Vp {
        constructor(e) {
          this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.lut = e.lut, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((d) => d.fqid), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = De.mat4.identity([]), this.placementViewportMatrix = De.mat4.identity([]);
          const n = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = A_(this.zoom, n["text-size"]), this.iconSizeData = A_(this.zoom, n["icon-size"]);
          const o = this.layers[0].layout, u = o.get("symbol-sort-key"), l = o.get("symbol-z-order");
          this.canOverlap = o.get("text-allow-overlap") || o.get("icon-allow-overlap") || o.get("text-ignore-placement") || o.get("icon-ignore-placement"), this.sortFeaturesByKey = l !== "viewport-y" && u.constantOr(1) !== void 0, this.sortFeaturesByY = (l === "viewport-y" || l === "auto" && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = o.get("text-writing-mode").map((d) => ko[d]), this.stateDependentLayerIds = this.layers.filter((d) => d.isStateDependent()).map((d) => d.id), this.sourceID = e.sourceID, this.projection = e.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = o.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        createArrays() {
          this.text = new B_(new Ka(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("text") || e.startsWith("symbol"))), this.icon = new B_(new Ka(this.layers, { zoom: this.zoom, lut: this.lut }, (e) => e.startsWith("icon") || e.startsWith("symbol"))), this.glyphOffsetArray = new ah(), this.lineVertexArray = new lh(), this.symbolInstances = new op();
        }
        calculateGlyphDependencies(e, n, o, u, l) {
          for (const d of e) {
            const v = d.codePointAt(0);
            if (v === void 0)
              break;
            if (n[v] = !0, u && l && v <= 65535) {
              const M = Hd[d];
              M && (n[M.charCodeAt(0)] = !0);
            }
          }
        }
        updateFootprints(e, n) {
        }
        updateReplacement(e, n) {
          if (n.updateTime === this.replacementUpdateTime)
            return !1;
          this.replacementUpdateTime = n.updateTime;
          const o = n.getReplacementRegionsForTile(e.toUnwrapped(), !0);
          return !v_(this.activeReplacements, o) && (this.activeReplacements = o, !0);
        }
        populate(e, n, o, u) {
          const l = this.layers[0], d = l.layout, v = this.projection.name === "globe", M = d.get("text-font"), D = d.get("text-field"), x = d.get("icon-image"), [E, I] = d.get("icon-size-scale-range"), S = si(n.scaleFactor || 1, E, I), C = (D.value.kind !== "constant" || D.value.value instanceof Dn && !D.value.value.isEmpty() || D.value.value.toString().length > 0) && (M.value.kind !== "constant" || M.value.value.length > 0), k = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0, V = d.get("symbol-sort-key");
          if (this.features = [], !C && !k)
            return;
          const U = n.iconDependencies, q = n.glyphDependencies, $ = n.availableImages, H = new Tn(this.zoom);
          for (const { feature: K, id: Q, index: ie, sourceLayerIndex: fe } of e) {
            const de = l._featureFilter.needGeometry, he = G(K, de);
            if (!l._featureFilter.filter(H, he, o))
              continue;
            if (de || (he.geometry = j(K, o, u)), v && K.type !== 1 && o.z <= 5) {
              const Ie = he.geometry, Re = 0.98078528056, Ve = (Ue, Fe) => {
                const et = Ri(Ue.x, Ue.y, o, 1), dt = Ri(Fe.x, Fe.y, o, 1);
                return De.vec3.dot(et, dt) < Re;
              };
              for (let Ue = 0; Ue < Ie.length; Ue++)
                Ie[Ue] = z(Ie[Ue], Ve);
            }
            let Me, me;
            if (C) {
              const Ie = l.getValueAndResolveTokens("text-field", he, o, $), Re = Dn.factory(Ie);
              RT(Re) && (this.hasRTLText = !0), (!this.hasRTLText || ru() === "unavailable" || this.hasRTLText && co.isParsed()) && (Me = aT(Re, l, he));
            }
            if (k) {
              const Ie = l.getValueAndResolveTokens("icon-image", he, o, $);
              me = Ie instanceof ss ? Ie : ss.build(Ie);
            }
            if (!Me && !me)
              continue;
            const Ee = this.sortFeaturesByKey ? V.evaluate(he, {}, o) : void 0, ze = { id: Q, text: Me, icon: me, index: ie, sourceLayerIndex: fe, geometry: he.geometry, properties: K.properties, type: DT[K.type], sortKey: Ee };
            if (this.features.push(ze), me) {
              const Ie = Ep(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], o, this.zoom, ze) * S * this.pixelRatio, Re = me.getPrimary().scaleSelf(Ie);
              if (U[Re.id] = U[Re.id] || [], U[Re.id].push(Re), me.nameSecondary) {
                const Ve = me.getSecondary().scaleSelf(Ie);
                U[Ve.id] = U[Ve.id] || [], U[Ve.id].push(Ve);
              }
            }
            if (Me) {
              const Ie = M.evaluate(he, {}, o).join(","), Re = d.get("text-rotation-alignment") === "map" && d.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ko.vertical) >= 0;
              for (const Ve of Me.sections)
                if (Ve.image) {
                  const Ue = Ve.image.getPrimary().scaleSelf(this.pixelRatio);
                  U[Ue.id] = U[Ue.id] || [], U[Ue.id].push(Ue);
                } else {
                  const Ue = dd(Me.toString()), Fe = Ve.fontStack || Ie, et = q[Fe] = q[Fe] || {};
                  this.calculateGlyphDependencies(Ve.text, et, Re, this.allowVerticalPlacement, Ue);
                }
            }
          }
          d.get("symbol-placement") === "line" && (this.features = function(K) {
            const Q = {}, ie = {}, fe = [];
            let de = 0;
            function he(ze) {
              fe.push(K[ze]), de++;
            }
            function Me(ze, Ie, Re) {
              const Ve = ie[ze];
              return delete ie[ze], ie[Ie] = Ve, fe[Ve].geometry[0].pop(), fe[Ve].geometry[0] = fe[Ve].geometry[0].concat(Re[0]), Ve;
            }
            function me(ze, Ie, Re) {
              const Ve = Q[Ie];
              return delete Q[Ie], Q[ze] = Ve, fe[Ve].geometry[0].shift(), fe[Ve].geometry[0] = Re[0].concat(fe[Ve].geometry[0]), Ve;
            }
            function Ee(ze, Ie, Re) {
              const Ve = Re ? Ie[0][Ie[0].length - 1] : Ie[0][0];
              return `${ze}:${Ve.x}:${Ve.y}`;
            }
            for (let ze = 0; ze < K.length; ze++) {
              const Ie = K[ze], Re = Ie.geometry, Ve = Ie.text ? Ie.text.toString() : null;
              if (!Ve) {
                he(ze);
                continue;
              }
              const Ue = Ee(Ve, Re), Fe = Ee(Ve, Re, !0);
              if (Ue in ie && Fe in Q && ie[Ue] !== Q[Fe]) {
                const et = me(Ue, Fe, Re), dt = Me(Ue, Fe, fe[et].geometry);
                delete Q[Ue], delete ie[Fe], ie[Ee(Ve, fe[dt].geometry, !0)] = dt, fe[et].geometry = null;
              } else
                Ue in ie ? Me(Ue, Fe, Re) : Fe in Q ? me(Ue, Fe, Re) : (he(ze), Q[Ue] = de - 1, ie[Fe] = de - 1);
            }
            return fe.filter((ze) => ze.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((K, Q) => K.sortKey - Q.sortKey);
        }
        update(e, n, o, u, l, d, v) {
          this.text.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v), this.icon.programConfigurations.updatePaintArrays(e, n, l, o, u, d, v);
        }
        updateZOffset() {
          const e = (l, d, v) => {
            o += d, o > l.length && l.resize(o);
            for (let M = -d; M < 0; M++)
              l.emplace(M + o, v);
          }, n = (l, d, v) => {
            u += d, u > l.length && l.resize(u);
            for (let M = -d; M < 0; M++)
              l.emplace(M + u, v);
          };
          if (!this.zOffsetBuffersNeedUpload)
            return;
          this.zOffsetBuffersNeedUpload = !1;
          let o = 0, u = 0;
          for (let l = 0; l < this.symbolInstances.length; l++) {
            const d = this.symbolInstances.get(l), { numHorizontalGlyphVertices: v, numVerticalGlyphVertices: M, numIconVertices: D } = d, x = d.zOffset, E = D > 0;
            if ((v > 0 || M > 0) && (e(this.text.zOffsetVertexArray, v, x), e(this.text.zOffsetVertexArray, M, x)), E) {
              const { placedIconSymbolIndex: I, verticalPlacedIconSymbolIndex: S } = d;
              I >= 0 && n(this.icon.zOffsetVertexArray, D, x), S >= 0 && n(this.icon.zOffsetVertexArray, d.numVerticalIconVertices, x);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(e) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(e), this.iconCollisionBox.upload(e)), this.text.upload(e, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(e, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = ox(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(e, n) {
          const o = this.lineVertexArray.length;
          if (e.segment !== void 0)
            for (const { x: u, y: l } of n)
              this.lineVertexArray.emplaceBack(u, l);
          return { lineStartIndex: o, lineLength: this.lineVertexArray.length - o };
        }
        addSymbols(e, n, o, u, l, d, v, M, D, x, E, I, S, C, k, V) {
          const U = e.indexArray, q = e.layoutVertexArray, $ = e.globeExtVertexArray, H = e.segments.prepareSegment(4 * n.length, q, U, this.canOverlap ? d.sortKey : void 0), K = this.glyphOffsetArray.length, Q = H.vertexLength, ie = this.allowVerticalPlacement && v === ko.vertical ? Math.PI / 2 : 0, fe = d.text && d.text.sections;
          for (let he = 0; he < n.length; he++) {
            const { tl: Me, tr: me, bl: Ee, br: ze, texPrimary: Ie, texSecondary: Re, pixelOffsetTL: Ve, pixelOffsetBR: Ue, minFontScaleX: Fe, minFontScaleY: et, glyphOffset: dt, isSDF: tt, sectionIndex: Tt } = n[he], vt = H.vertexLength, Pt = dt[1];
            if (Op(q, D.x, D.y, Me.x, Pt + Me.y, Ie.x, Ie.y, o, tt, Ve.x, Ve.y, Fe, et), Op(q, D.x, D.y, me.x, Pt + me.y, Ie.x + Ie.w, Ie.y, o, tt, Ue.x, Ve.y, Fe, et), Op(q, D.x, D.y, Ee.x, Pt + Ee.y, Ie.x, Ie.y + Ie.h, o, tt, Ve.x, Ue.y, Fe, et), Op(q, D.x, D.y, ze.x, Pt + ze.y, Ie.x + Ie.w, Ie.y + Ie.h, o, tt, Ue.x, Ue.y, Fe, et), M) {
              const { x: rt, y: Ut, z: St } = M.anchor, [Nt, Qt, pi] = M.up;
              Bp($, rt, Ut, St, Nt, Qt, pi), Bp($, rt, Ut, St, Nt, Qt, pi), Bp($, rt, Ut, St, Nt, Qt, pi), Bp($, rt, Ut, St, Nt, Qt, pi), Np(e.dynamicLayoutVertexArray, rt, Ut, St, ie);
            } else
              Np(e.dynamicLayoutVertexArray, D.x, D.y, D.z, ie);
            if (V) {
              const rt = Re || Ie;
              Fp(e.iconTransitioningVertexArray, rt.x, rt.y), Fp(e.iconTransitioningVertexArray, rt.x + rt.w, rt.y), Fp(e.iconTransitioningVertexArray, rt.x, rt.y + rt.h), Fp(e.iconTransitioningVertexArray, rt.x + rt.w, rt.y + rt.h);
            }
            U.emplaceBack(vt, vt + 1, vt + 2), U.emplaceBack(vt + 1, vt + 2, vt + 3), H.vertexLength += 4, H.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(dt[0]), he !== n.length - 1 && Tt === n[he + 1].sectionIndex || e.programConfigurations.populatePaintArrays(q.length, d, d.index, {}, S, C, k, fe && fe[Tt]);
          }
          const de = M ? M.anchor : D;
          e.placedSymbolArray.emplaceBack(de.x, de.y, de.z, D.x, D.y, K, this.glyphOffsetArray.length - K, Q, x, E, D.segment, o ? o[0] : 0, o ? o[1] : 0, u[0], u[1], v, 0, !1, 0, I, 0);
        }
        _commitLayoutVertex(e, n, o, u, l, d, v) {
          e.emplaceBack(n, o, u, l, d, Math.round(v.x), Math.round(v.y));
        }
        _addCollisionDebugVertices(e, n, o, u, l, d, v) {
          const M = o.segments.prepareSegment(4, o.layoutVertexArray, o.indexArray), D = M.vertexLength, x = v.tileAnchorX, E = v.tileAnchorY;
          for (let S = 0; S < 4; S++)
            o.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(o.collisionVertexArrayExt, n, e.padding, v.zOffset), this._commitLayoutVertex(o.layoutVertexArray, u, l, d, x, E, new Mt(e.x1, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, u, l, d, x, E, new Mt(e.x2, e.y1)), this._commitLayoutVertex(o.layoutVertexArray, u, l, d, x, E, new Mt(e.x2, e.y2)), this._commitLayoutVertex(o.layoutVertexArray, u, l, d, x, E, new Mt(e.x1, e.y2)), M.vertexLength += 4;
          const I = o.indexArray;
          I.emplaceBack(D, D + 1), I.emplaceBack(D + 1, D + 2), I.emplaceBack(D + 2, D + 3), I.emplaceBack(D + 3, D), M.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(e, n, o, u, l, d) {
          for (let v = u; v < l; v++) {
            const M = o.get(v), D = this.getSymbolInstanceTextSize(e, d, n, v);
            this._addCollisionDebugVertices(M, D, this.textCollisionBox, M.projectedAnchorX, M.projectedAnchorY, M.projectedAnchorZ, d);
          }
        }
        _addIconDebugCollisionBoxes(e, n, o, u, l, d) {
          for (let v = u; v < l; v++) {
            const M = o.get(v), D = this.getSymbolInstanceIconSize(e, n, d.placedIconSymbolIndex);
            this._addCollisionDebugVertices(M, D, this.iconCollisionBox, M.projectedAnchorX, M.projectedAnchorY, M.projectedAnchorZ, d);
          }
        }
        generateCollisionDebugBuffers(e, n, o) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new N_(fu, A0.members, Xa), this.iconCollisionBox = new N_(fu, A0.members, Xa);
          const u = Cu(this.iconSizeData, e), l = Cu(this.textSizeData, e, o);
          for (let d = 0; d < this.symbolInstances.length; d++) {
            const v = this.symbolInstances.get(d);
            this._addTextDebugCollisionBoxes(l, e, n, v.textBoxStartIndex, v.textBoxEndIndex, v), this._addTextDebugCollisionBoxes(l, e, n, v.verticalTextBoxStartIndex, v.verticalTextBoxEndIndex, v), this._addIconDebugCollisionBoxes(u, e, n, v.iconBoxStartIndex, v.iconBoxEndIndex, v), this._addIconDebugCollisionBoxes(u, e, n, v.verticalIconBoxStartIndex, v.verticalIconBoxEndIndex, v);
          }
        }
        getSymbolInstanceTextSize(e, n, o, u) {
          const l = this.text.placedSymbolArray.get(n.rightJustifiedTextSymbolIndex >= 0 ? n.rightJustifiedTextSymbolIndex : n.centerJustifiedTextSymbolIndex >= 0 ? n.centerJustifiedTextSymbolIndex : n.leftJustifiedTextSymbolIndex >= 0 ? n.leftJustifiedTextSymbolIndex : n.verticalPlacedTextSymbolIndex >= 0 ? n.verticalPlacedTextSymbolIndex : u), d = Ap(this.textSizeData, e, l) / er;
          return this.tilePixelRatio * d;
        }
        getSymbolInstanceIconSize(e, n, o) {
          const u = this.icon.placedSymbolArray.get(o), l = Ap(this.iconSizeData, e, u);
          return this.tilePixelRatio * l;
        }
        _commitDebugCollisionVertexUpdate(e, n, o, u) {
          e.emplaceBack(n, -o, -o, u), e.emplaceBack(n, o, -o, u), e.emplaceBack(n, o, o, u), e.emplaceBack(n, -o, o, u);
        }
        _updateTextDebugCollisionBoxes(e, n, o, u, l, d, v) {
          for (let M = u; M < l; M++) {
            const D = o.get(M), x = this.getSymbolInstanceTextSize(e, d, n, M);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, x, D.padding, d.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(e, n, o, u, l, d, v) {
          for (let M = u; M < l; M++) {
            const D = o.get(M), x = this.getSymbolInstanceIconSize(e, n, d.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, x, D.padding, d.zOffset);
          }
        }
        updateCollisionDebugBuffers(e, n, o, u) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const l = Cu(this.iconSizeData, e, u), d = Cu(this.textSizeData, e, o);
          for (let v = 0; v < this.symbolInstances.length; v++) {
            const M = this.symbolInstances.get(v);
            this._updateTextDebugCollisionBoxes(d, e, n, M.textBoxStartIndex, M.textBoxEndIndex, M, o), this._updateTextDebugCollisionBoxes(d, e, n, M.verticalTextBoxStartIndex, M.verticalTextBoxEndIndex, M, o), this._updateIconDebugCollisionBoxes(l, e, n, M.iconBoxStartIndex, M.iconBoxEndIndex, M, u), this._updateIconDebugCollisionBoxes(l, e, n, M.verticalIconBoxStartIndex, M.verticalIconBoxEndIndex, M, u);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(e, n, o, u, l, d, v, M, D) {
          const x = {};
          if (n < o) {
            const { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(n);
            x.textBox = { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.textFeatureIndex = K;
          }
          if (u < l) {
            const { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(u);
            x.verticalTextBox = { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.verticalTextFeatureIndex = K;
          }
          if (d < v) {
            const { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(d);
            x.iconBox = { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.iconFeatureIndex = K;
          }
          if (M < D) {
            const { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H, featureIndex: K } = e.get(M);
            x.verticalIconBox = { x1: E, y1: I, x2: S, y2: C, padding: k, projectedAnchorX: V, projectedAnchorY: U, projectedAnchorZ: q, tileAnchorX: $, tileAnchorY: H }, x.verticalIconFeatureIndex = K;
          }
          return x;
        }
        deserializeCollisionBoxes(e) {
          this.collisionArrays = [];
          for (let n = 0; n < this.symbolInstances.length; n++) {
            const o = this.symbolInstances.get(n);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(e, o.textBoxStartIndex, o.textBoxEndIndex, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o.iconBoxStartIndex, o.iconBoxEndIndex, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(e, n) {
          const o = e.placedSymbolArray.get(n), u = o.vertexStartIndex + 4 * o.numGlyphs;
          for (let l = o.vertexStartIndex; l < u; l += 4)
            e.indexArray.emplaceBack(l, l + 1, l + 2), e.indexArray.emplaceBack(l + 1, l + 2, l + 3);
        }
        getSortedSymbolIndexes(e) {
          if (this.sortedAngle === e && this.symbolInstanceIndexes !== void 0)
            return this.symbolInstanceIndexes;
          const n = Math.sin(e), o = Math.cos(e), u = [], l = [], d = [];
          for (let v = 0; v < this.symbolInstances.length; ++v) {
            d.push(v);
            const M = this.symbolInstances.get(v);
            u.push(0 | Math.round(n * M.tileAnchorX + o * M.tileAnchorY)), l.push(M.featureIndex);
          }
          return d.sort((v, M) => u[v] - u[M] || l[M] - l[v]), d;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty)
            return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let e = 0; e < this.symbolInstances.length; ++e)
              this.symbolInstanceIndexesSortedZOffset.push(e);
          }
          return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((e, n) => this.symbolInstances.get(n).zOffset - this.symbolInstances.get(e).zOffset);
        }
        addToSortKeyRanges(e, n) {
          const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          o && o.sortKey === n ? o.symbolInstanceEnd = e + 1 : this.sortKeyRanges.push({ sortKey: n, symbolInstanceStart: e, symbolInstanceEnd: e + 1 });
        }
        sortFeatures(e) {
          if (this.sortFeaturesByY && this.sortedAngle !== e && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(e), this.sortedAngle = e, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const n of this.symbolInstanceIndexes) {
              const o = this.symbolInstances.get(n);
              this.featureSortOrder.push(o.featureIndex);
              const { rightJustifiedTextSymbolIndex: u, centerJustifiedTextSymbolIndex: l, leftJustifiedTextSymbolIndex: d, verticalPlacedTextSymbolIndex: v, placedIconSymbolIndex: M, verticalPlacedIconSymbolIndex: D } = o;
              u >= 0 && this.addIndicesForPlacedSymbol(this.text, u), l >= 0 && l !== u && this.addIndicesForPlacedSymbol(this.text, l), d >= 0 && d !== l && d !== u && this.addIndicesForPlacedSymbol(this.text, d), v >= 0 && this.addIndicesForPlacedSymbol(this.text, v), M >= 0 && this.addIndicesForPlacedSymbol(this.icon, M), D >= 0 && this.addIndicesForPlacedSymbol(this.icon, D);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let ax, lx, V_;
      Ft(Vp, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Vp.addDynamicAttributes = Np;
      class cx {
        constructor(e) {
          this.type = e.property.overrides ? e.property.overrides.runtimeType : ca, this.defaultValue = e;
        }
        evaluate(e) {
          if (e.formattedSection) {
            const n = this.defaultValue.property.overrides;
            if (n && n.hasOverride(e.formattedSection))
              return n.getOverride(e.formattedSection);
          }
          return e.feature && e.featureState ? this.defaultValue.evaluate(e.feature, e.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(e) {
          this.defaultValue.isConstant() || e(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Ft(cx, "FormatSectionOverride", { omit: ["defaultValue"] });
      const U_ = () => V_ || (V_ = { layout: ax || (ax = new Bn({ "symbol-placement": new gt($e.layout_symbol["symbol-placement"]), "symbol-spacing": new gt($e.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new gt($e.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Dt($e.layout_symbol["symbol-sort-key"]), "symbol-z-order": new gt($e.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new gt($e.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new gt($e.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new gt($e.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new gt($e.layout_symbol["icon-ignore-placement"]), "icon-optional": new gt($e.layout_symbol["icon-optional"]), "icon-rotation-alignment": new gt($e.layout_symbol["icon-rotation-alignment"]), "icon-size": new Dt($e.layout_symbol["icon-size"]), "icon-size-scale-range": new gt($e.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new Dt($e.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Dt($e.layout_symbol["icon-text-fit-padding"]), "icon-image": new Dt($e.layout_symbol["icon-image"]), "icon-rotate": new Dt($e.layout_symbol["icon-rotate"]), "icon-padding": new gt($e.layout_symbol["icon-padding"]), "icon-keep-upright": new gt($e.layout_symbol["icon-keep-upright"]), "icon-offset": new Dt($e.layout_symbol["icon-offset"]), "icon-anchor": new Dt($e.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new gt($e.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new gt($e.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new gt($e.layout_symbol["text-rotation-alignment"]), "text-field": new Dt($e.layout_symbol["text-field"]), "text-font": new Dt($e.layout_symbol["text-font"]), "text-size": new Dt($e.layout_symbol["text-size"]), "text-size-scale-range": new gt($e.layout_symbol["text-size-scale-range"]), "text-max-width": new Dt($e.layout_symbol["text-max-width"]), "text-line-height": new Dt($e.layout_symbol["text-line-height"]), "text-letter-spacing": new Dt($e.layout_symbol["text-letter-spacing"]), "text-justify": new Dt($e.layout_symbol["text-justify"]), "text-radial-offset": new Dt($e.layout_symbol["text-radial-offset"]), "text-variable-anchor": new gt($e.layout_symbol["text-variable-anchor"]), "text-anchor": new Dt($e.layout_symbol["text-anchor"]), "text-max-angle": new gt($e.layout_symbol["text-max-angle"]), "text-writing-mode": new gt($e.layout_symbol["text-writing-mode"]), "text-rotate": new Dt($e.layout_symbol["text-rotate"]), "text-padding": new gt($e.layout_symbol["text-padding"]), "text-keep-upright": new gt($e.layout_symbol["text-keep-upright"]), "text-transform": new Dt($e.layout_symbol["text-transform"]), "text-offset": new Dt($e.layout_symbol["text-offset"]), "text-allow-overlap": new gt($e.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new gt($e.layout_symbol["text-ignore-placement"]), "text-optional": new gt($e.layout_symbol["text-optional"]), visibility: new gt($e.layout_symbol.visibility) })), paint: lx || (lx = new Bn({ "icon-opacity": new Dt($e.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new Dt($e.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new Dt($e.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new Dt($e.paint_symbol["text-emissive-strength"]), "icon-color": new Dt($e.paint_symbol["icon-color"]), "icon-halo-color": new Dt($e.paint_symbol["icon-halo-color"]), "icon-halo-width": new Dt($e.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Dt($e.paint_symbol["icon-halo-blur"]), "icon-translate": new gt($e.paint_symbol["icon-translate"]), "icon-translate-anchor": new gt($e.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Dt($e.paint_symbol["icon-image-cross-fade"]), "text-opacity": new Dt($e.paint_symbol["text-opacity"]), "text-occlusion-opacity": new Dt($e.paint_symbol["text-occlusion-opacity"]), "text-color": new Dt($e.paint_symbol["text-color"], { runtimeType: ms, getOverride: (r) => r.textColor, hasOverride: (r) => !!r.textColor }), "text-halo-color": new Dt($e.paint_symbol["text-halo-color"]), "text-halo-width": new Dt($e.paint_symbol["text-halo-width"]), "text-halo-blur": new Dt($e.paint_symbol["text-halo-blur"]), "text-translate": new gt($e.paint_symbol["text-translate"]), "text-translate-anchor": new gt($e.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new gt($e.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new gt($e.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new gt($e.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new gt($e.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new Dt($e.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, V_);
      class Up extends wr {
        constructor(e, n, o, u) {
          super(e, U_(), n, o, u), this._colorAdjustmentMatrix = De.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = e.paint !== void 0 && ("icon-occlusion-opacity" in e.paint || "text-occlusion-opacity" in e.paint);
        }
        recalculate(e, n) {
          super.recalculate(e, n), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const o = this.layout.get("text-writing-mode");
          if (o) {
            const u = [];
            for (const l of o)
              u.indexOf(l) < 0 && u.push(l);
            this.layout._values["text-writing-mode"] = u;
          } else
            this.layout._values["text-writing-mode"] = this.layout.get("symbol-placement") === "point" ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getColorAdjustmentMatrix(e, n, o, u) {
          return this._saturation === e && this._contrast === n && this._brightnessMin === o && this._brightnessMax === u || (this._colorAdjustmentMatrix = function(l, d, v, M) {
            l = le(l), d = re(d);
            const D = De.mat4.create(), x = l / 3, E = 1 - 2 * x, I = [E, x, x, 0, x, E, x, 0, x, x, E, 0, 0, 0, 0, 1], S = 0.5 - 0.5 * d, C = M - v;
            return De.mat4.multiply(D, [C, 0, 0, 0, 0, C, 0, 0, 0, 0, C, 0, v, v, v, 1], [d, 0, 0, 0, 0, d, 0, 0, 0, 0, d, 0, S, S, S, 1]), De.mat4.multiply(D, D, I), D;
          }(e, n, o, u), this._saturation = e, this._contrast = n, this._brightnessMin = o, this._brightnessMax = u), this._colorAdjustmentMatrix;
        }
        getValueAndResolveTokens(e, n, o, u) {
          const l = this.layout.get(e).evaluate(n, {}, o, u), d = this._unevaluatedLayout._values[e];
          return d.isDataDriven() || Qh(d.value) || !l ? l : function(v, M) {
            return M.replace(/{([^{}]+)}/g, (D, x) => x in v ? String(v[x]) : "");
          }(n.properties, l);
        }
        createBucket(e) {
          return new Vp(e);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        _setPaintOverrides() {
          for (const e of U_().paint.overridableProperties) {
            if (!Up.hasPaintOverride(this.layout, e))
              continue;
            const n = this.paint.get(e), o = new cx(n), u = new od(o, n.property.specification, this.scope, this.options);
            let l = null;
            l = n.value.kind === "constant" || n.value.kind === "source" ? new ad("source", u) : new ic("composite", u, n.value.zoomStops, n.value._interpolationType), this.paint._values[e] = new oc(n.property, l, n.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(e, n, o) {
          return !(!this.layout || n.isDataDriven() || o.isDataDriven()) && Up.hasPaintOverride(this.layout, e);
        }
        static hasPaintOverride(e, n) {
          const o = e.get("text-field"), u = U_().paint.properties[n];
          let l = !1;
          const d = (v) => {
            for (const M of v)
              if (u.overrides && u.overrides.hasOverride(M))
                return void (l = !0);
          };
          if (o.value.kind === "constant" && o.value.value instanceof Dn)
            d(o.value.value.sections);
          else if (o.value.kind === "source") {
            const v = (D) => {
              l || (D instanceof Lr && vn(D.value) === Ks ? d(D.value.sections) : D instanceof Es ? d(D.sections) : D.eachChild(v));
            }, M = o.value;
            M._styleExpression && v(M._styleExpression.expression);
          }
          return l;
        }
        getProgramIds() {
          return ["symbol"];
        }
        getDefaultProgramParams(e, n, o) {
          return { config: new Al(this, { zoom: n, lut: o }), overrideFog: !1 };
        }
      }
      let hx, ux, dx, fx;
      var j_ = qi([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      function G_(r) {
        switch (r) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.RGBA;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.DEPTH_COMPONENT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.DEPTH_STENCIL;
          case WebGL2RenderingContext.R8:
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.RED;
        }
      }
      function Z_(r) {
        switch (r) {
          case WebGL2RenderingContext.RGBA8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.DEPTH_COMPONENT16:
            return WebGL2RenderingContext.UNSIGNED_SHORT;
          case WebGL2RenderingContext.DEPTH24_STENCIL8:
            return WebGL2RenderingContext.UNSIGNED_INT_24_8;
          case WebGL2RenderingContext.R8:
            return WebGL2RenderingContext.UNSIGNED_BYTE;
          case WebGL2RenderingContext.R32F:
            return WebGL2RenderingContext.FLOAT;
        }
      }
      class H_ {
        constructor(e, n, o, u) {
          this.context = e, this.format = o, this.useMipmap = u && u.useMipmap, this.texture = e.gl.createTexture(), this.update(n, { premultiply: u && u.premultiply });
        }
        update(e, n) {
          const o = e && e instanceof HTMLVideoElement && e.width === 0 ? e.videoWidth : e.width, u = e && e instanceof HTMLVideoElement && e.height === 0 ? e.videoHeight : e.height, { context: l } = this, { gl: d } = l, { x: v, y: M } = n && n.position ? n.position : { x: 0, y: 0 }, D = v + o, x = M + u;
          !this.size || this.size[0] === D && this.size[1] === x || (d.bindTexture(d.TEXTURE_2D, null), d.deleteTexture(this.texture), this.texture = d.createTexture(), this.size = null), d.bindTexture(d.TEXTURE_2D, this.texture), l.pixelStoreUnpackFlipY.set(!1), l.pixelStoreUnpack.set(1), l.pixelStoreUnpackPremultiplyAlpha.set(this.format === d.RGBA8 && (!n || n.premultiply !== !1));
          const E = e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || ImageBitmap && e instanceof ImageBitmap;
          if (!this.size && D > 0 && x > 0) {
            const I = this.useMipmap ? Math.floor(Math.log2(Math.max(D, x))) + 1 : 1;
            d.texStorage2D(d.TEXTURE_2D, I, this.format, D, x), this.size = [D, x];
          }
          if (this.size)
            if (E)
              d.texSubImage2D(d.TEXTURE_2D, 0, v, M, G_(this.format), Z_(this.format), e);
            else {
              const I = e.data;
              I && d.texSubImage2D(d.TEXTURE_2D, 0, v, M, o, u, G_(this.format), Z_(this.format), I);
            }
          this.useMipmap && d.generateMipmap(d.TEXTURE_2D);
        }
        bind(e, n, o = !1) {
          const { context: u } = this, { gl: l } = u;
          l.bindTexture(l.TEXTURE_2D, this.texture), e !== this.minFilter && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, e), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, this.useMipmap && !o ? e === l.NEAREST ? l.NEAREST_MIPMAP_NEAREST : l.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), n !== this.wrapS && (l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, n), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, n), this.wrapS = n);
        }
        bindExtraParam(e, n, o, u) {
          const { context: l } = this, { gl: d } = l;
          d.bindTexture(d.TEXTURE_2D, this.texture), n !== this.magFilter && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, n), this.magFilter = n), e !== this.minFilter && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER, this.useMipmap ? e === d.NEAREST ? d.NEAREST_MIPMAP_NEAREST : d.LINEAR_MIPMAP_LINEAR : e), this.minFilter = e), o !== this.wrapS && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, o), this.wrapS = o), u !== this.wrapT && (d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, u), this.wrapT = u);
        }
        destroy() {
          const { gl: e } = this.context;
          e.deleteTexture(this.texture), this.texture = null;
        }
      }
      class jp {
        constructor(e, n) {
          this.context = e, this.texture = n;
        }
        bind(e, n) {
          const { context: o } = this, { gl: u } = o;
          u.bindTexture(u.TEXTURE_2D, this.texture), e !== this.minFilter && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, e), this.minFilter = e), n !== this.wrapS && (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, n), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, n), this.wrapS = n);
        }
      }
      function Gp(r, e, n, o, u, l, d, v) {
        const M = [r, e, 1, n, o, 1, u, l, 1], D = [d, v, 1], x = De.mat3.adjoint([], M), [E, I, S] = De.vec3.transformMat3(D, D, x);
        return De.mat3.multiply(M, M, [E, 0, 0, 0, I, 0, 0, 0, S]);
      }
      function px(r, e, n, o, u, l, d, v) {
        const M = function(D, x, E, I, S, C, k, V) {
          const U = Gp(0, 0, 1, 0, 1, 1, 0, 1), q = Gp(D, x, E, I, S, C, k, V), $ = De.mat3.adjoint([], U);
          return De.mat3.multiply(q, q, $);
        }(r, e, n, o, u, l, d, v);
        return [M[2] / M[8] / wt, M[5] / M[8] / wt];
      }
      function Zp(r) {
        return [r[0], Math.min(Math.max(r[1], -Un), Un)];
      }
      class mx extends Go {
        constructor(e, n, o, u) {
          super(), this.id = e, this.dispatcher = o, this.coordinates = n.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(u), this.options = n, this._dirty = !1;
        }
        load(e, n) {
          if (this._loaded = n || !1, this.fire(new Pr("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url)
            return e && (this.coordinates = e), this._loaded = !0, void this._finishLoading();
          this._imageRequest = Hn(this.map._requestManager.transformRequest(this.url, Vo.Image), (o, u) => {
            this._imageRequest = null, this._loaded = !0, o ? this.fire(new Cr(o)) : u && (this.image = u instanceof HTMLImageElement ? Ct.getImageData(u) : u, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, e && (this.coordinates = e), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e) {
          return e.url ? (this._imageRequest && e.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = e.url, this.load(e.coordinates, this._loaded), this) : this;
        }
        setTexture(e) {
          if (!(e.handle instanceof WebGLTexture))
            throw new Error("The provided handle is not a WebGLTexture instance");
          return this.texture = new jp(this.map.painter.context, e.handle), this.width = e.dimensions[0], this.height = e.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new Pr("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e) {
          this.map = e, this.load();
        }
        onRemove(e) {
          this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof jp || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
        }
        setCoordinates(e) {
          if (this.coordinates = e, this._boundsArray = void 0, this._unsupportedCoords = !1, !e.length)
            return this;
          this.onNorthPole = !1, this.onSouthPole = !1;
          let n = e[0][1], o = e[0][1];
          for (const l of e)
            l[1] > o && (o = l[1]), l[1] < n && (n = l[1]);
          const u = (o + n) / 2;
          if (u > Un ? this.onNorthPole = !0 : u < -Un && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
            const l = e.map(h.fromLngLat);
            this.tileID = function(d) {
              let v = 1 / 0, M = 1 / 0, D = -1 / 0, x = -1 / 0;
              for (const k of d)
                v = Math.min(v, k.x), M = Math.min(M, k.y), D = Math.max(D, k.x), x = Math.max(x, k.y);
              const E = Math.max(D - v, x - M), I = Math.max(0, Math.floor(-Math.log(E) / Math.LN2)), S = Math.pow(2, I);
              let C = Math.floor((v + D) / 2 * S);
              return C > 1 && (C -= 1), new nt(I, C, Math.floor((M + x) / 2 * S));
            }(l), this.minzoom = this.maxzoom = this.tileID.z;
          }
          return this.fire(new Pr("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        _clear() {
          this._boundsArray = void 0, this._unsupportedCoords = !1;
        }
        _prepareData(e) {
          for (const U in this.tiles) {
            const q = this.tiles[U];
            q.state !== "loaded" && (q.state = "loaded", q.texture = this.texture);
          }
          if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords)
            return;
          const n = Yd(new nt(0, 0, 0), this.map.transform.projection), o = [n.projection.project(this.coordinates[0][0], this.coordinates[0][1]), n.projection.project(this.coordinates[1][0], this.coordinates[1][1]), n.projection.project(this.coordinates[2][0], this.coordinates[2][1]), n.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
          if (!function(U) {
            const q = U[1].x - U[0].x, $ = U[1].y - U[0].y, H = U[2].x - U[1].x, K = U[2].y - U[1].y, Q = U[3].x - U[2].x, ie = U[3].y - U[2].y, fe = U[0].x - U[3].x, de = U[0].y - U[3].y, he = q * K - H * $, Me = H * ie - Q * K, me = Q * de - fe * ie, Ee = fe * $ - q * de;
            return he > 0 && Me > 0 && me > 0 && Ee > 0 || he < 0 && Me < 0 && me < 0 && Ee < 0;
          }(o))
            return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
          const u = Yd(this.tileID, this.map.transform.projection), [l, d, v, M] = this.coordinates.map((U) => {
            const q = u.projection.project(U[0], U[1]);
            return tx(u, q)._round();
          });
          this.perspectiveTransform = px(l.x, l.y, d.x, d.y, v.x, v.y, M.x, M.y);
          const D = this._boundsArray = new qa();
          D.emplaceBack(l.x, l.y, 0, 0), D.emplaceBack(d.x, d.y, wt, 0), D.emplaceBack(M.x, M.y, 0, wt), D.emplaceBack(v.x, v.y, wt, wt), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = e.createVertexBuffer(D, j_.members), this.boundsSegments = Wn.simpleSegment(0, 0, 4, 2);
          const x = [], E = [Zp((I = this.coordinates)[0]), Zp(I[1]), Zp(I[2]), Zp(I[3])];
          var I;
          const [S, C, k, V] = function(U) {
            let q = U[0][0], $ = q, H = U[0][1], K = H;
            for (let Q = 1; Q < U.length; Q++)
              U[Q][0] < q ? q = U[Q][0] : U[Q][0] > $ && ($ = U[Q][0]), U[Q][1] < H ? H = U[Q][1] : U[Q][1] > K && (K = U[Q][1]);
            return [q, H, $ - q, K - H];
          }(E);
          {
            const U = new qa(), [q, $, H, K] = function(Ve) {
              let Ue = Ve[0].x, Fe = Ue, et = Ve[0].y, dt = et;
              for (let tt = 1; tt < Ve.length; tt++)
                Ve[tt].x < Ue ? Ue = Ve[tt].x : Ve[tt].x > Fe && (Fe = Ve[tt].x), Ve[tt].y < et ? et = Ve[tt].y : Ve[tt].y > dt && (dt = Ve[tt].y);
              return [Ue, et, Fe - Ue, dt - et];
            }(o), Q = (Ve) => [(Ve.x - q) / H, (Ve.y - $) / K], [ie, fe, de, he] = o.map(Q), Me = function(Ve, Ue, Fe, et, dt, tt, Tt, vt) {
              const Pt = Gp(0, 0, 1, 0, 1, 1, 0, 1), rt = Gp(Ve, Ue, Fe, et, dt, tt, Tt, vt), Ut = De.mat3.adjoint([], rt);
              return De.mat3.multiply(Pt, Pt, Ut);
            }(ie[0], ie[1], fe[0], fe[1], de[0], de[1], he[0], he[1]);
            this.elevatedGlobePerspectiveTransform = px(ie[0], ie[1], fe[0], fe[1], de[0], de[1], he[0], he[1]);
            const me = (Ve, Ue) => {
              x.push(Ve.lng);
              const Fe = Math.round((Ve.lng - S) / k * wt), et = Math.round((Ve.lat - C) / V * wt), dt = Q(Ue), tt = De.vec3.transformMat3([], [dt[0], dt[1], 1], Me), Tt = Math.round(tt[0] / tt[2] * wt), vt = Math.round(tt[1] / tt[2] * wt);
              U.emplaceBack(Fe, et, Tt, vt);
            }, Ee = o[3].x - o[0].x, ze = o[3].y - o[0].y, Ie = o[2].x - o[1].x, Re = o[2].y - o[1].y;
            for (let Ve = 0; Ve < 65; Ve++) {
              const Ue = Ve / 64, Fe = [o[0].x + Ue * Ee, o[0].y + Ue * ze], et = [o[1].x + Ue * Ie, o[1].y + Ue * Re], dt = et[0] - Fe[0], tt = et[1] - Fe[1];
              for (let Tt = 0; Tt < 65; Tt++) {
                const vt = Tt / 64, Pt = { x: Fe[0] + dt * vt, y: Fe[1] + tt * vt, z: 0 };
                me(n.projection.unproject(Pt.x, Pt.y), Pt);
              }
            }
            this.elevatedGlobeVertexBuffer = e.createVertexBuffer(U, j_.members);
          }
          {
            this.maxLongitudeTriangleSize = 0;
            let U = [], q = new qs();
            const $ = (H, K, Q) => {
              q.emplaceBack(H, K, Q);
              const ie = x[H], fe = x[K], de = x[Q], he = Math.min(Math.min(ie, fe), de), Me = Math.max(Math.max(ie, fe), de) - he;
              Me > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = Me), U.push(he + Me / 2);
            };
            for (let H = 0; H < 64; H++)
              for (let K = 0; K < 64; K++) {
                const Q = 65 * H + K, ie = Q + 1, fe = Q + 65, de = fe + 1;
                $(Q, fe, ie), $(ie, fe, de);
              }
            [U, q] = function(H, K) {
              const Q = Array.from({ length: H.length }, (de, he) => he);
              Q.sort((de, he) => H[de] - H[he]);
              const ie = [], fe = new qs();
              for (let de = 0; de < Q.length; de++) {
                const he = Q[de];
                ie.push(H[he]);
                const Me = 3 * he, me = Me + 1;
                fe.emplaceBack(K.uint16[Me], K.uint16[me], K.uint16[me + 1]);
              }
              return [ie, fe];
            }(U, q), this.elevatedGlobeTrianglesCenterLongitudes = U, this.elevatedGlobeIndexBuffer = e.createIndexBuffer(q);
          }
          this.elevatedGlobeSegments = Wn.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, k / wt, 0, V / wt, 0, 0, C, S, 0]);
        }
        prepare() {
          const e = Object.keys(this.tiles).length !== 0;
          if (this.tileID && !e)
            return;
          const n = this.map.painter.context, o = n.gl;
          !this._dirty || this.texture instanceof jp || (this.texture ? this.texture.update(this.image) : (this.texture = new H_(n, this.image, o.RGBA8), this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE)), this._dirty = !1), e && this._prepareData(n);
        }
        loadTile(e, n) {
          this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}, n(null)) : (e.state = "errored", n(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
        getSegmentsForLongitude(e) {
          const n = this.elevatedGlobeSegments;
          if (!this.elevatedGlobeTrianglesCenterLongitudes || !n)
            return null;
          const o = this.elevatedGlobeTrianglesCenterLongitudes;
          let u = (l = e + 180) + 360 * Math.round((o[0] - l) / 360);
          var l;
          const d = new Wn(), v = (E, I) => {
            d.segments.push({ vertexOffset: 0, primitiveOffset: E, vertexLength: n.segments[0].vertexLength, primitiveLength: I, sortKey: void 0, vaos: {} });
          }, M = 0.51 * this.maxLongitudeTriangleSize;
          if (Math.abs(o[0] - u) <= M) {
            const E = Ke(o, 0, o.length, u + M);
            return E === o.length || v(E, No(o, E + 1, o.length, u + 360 - M) - E), d;
          }
          u < o[0] && (u += 360);
          const D = No(o, 0, o.length, u - M);
          if (D === o.length)
            return v(0, o.length), d;
          v(0, D - 0);
          const x = Ke(o, D + 1, o.length, u + M);
          return x !== o.length && v(x, o.length - x), d;
        }
      }
      const OT = (Math.pow(256, 2) - 1) / 16907520;
      class _x extends wr {
        constructor(e, n, o, u) {
          super(e, { layout: dx || (dx = new Bn({ visibility: new gt($e.layout_raster.visibility) })), paint: fx || (fx = new Bn({ "raster-opacity": new gt($e.paint_raster["raster-opacity"]), "raster-color": new Ha($e.paint_raster["raster-color"]), "raster-color-mix": new gt($e.paint_raster["raster-color-mix"]), "raster-color-range": new gt($e.paint_raster["raster-color-range"]), "raster-hue-rotate": new gt($e.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new gt($e.paint_raster["raster-brightness-min"]), "raster-brightness-max": new gt($e.paint_raster["raster-brightness-max"]), "raster-saturation": new gt($e.paint_raster["raster-saturation"]), "raster-contrast": new gt($e.paint_raster["raster-contrast"]), "raster-resampling": new gt($e.paint_raster["raster-resampling"]), "raster-fade-duration": new gt($e.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new gt($e.paint_raster["raster-emissive-strength"]), "raster-array-band": new gt($e.paint_raster["raster-array-band"]), "raster-elevation": new gt($e.paint_raster["raster-elevation"]), "raster-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, n, o, u), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
        }
        getProgramIds() {
          return ["raster"];
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-color"].value.value;
        }
        tileCoverLift() {
          return this.paint.get("raster-elevation");
        }
        isDraped(e) {
          return !(e && e._source instanceof mx && (e._source.onNorthPole || e._source.onSouthPole)) && this.paint.get("raster-elevation") === 0;
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e !== "raster-color" && e !== "raster-color-range" || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
        }
        updateColorRamp(e) {
          if (!this.hasColorMap() || !this._curRampRange)
            return;
          const n = this._transitionablePaint._values["raster-color"].value.expression, [o, u] = e || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
          isNaN(o) && isNaN(u) || o === this._curRampRange[0] && u === this._curRampRange[1] || (this.colorRamp = Rd({ expression: n, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: o, end: u }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [o, u]);
        }
      }
      let gx, yx, xx, vx, bx;
      class wx extends wr {
        constructor(e, n, o, u) {
          super(e, { layout: gx || (gx = new Bn({ visibility: new gt($e["layout_raster-particle"].visibility) })), paint: yx || (yx = new Bn({ "raster-particle-array-band": new gt($e["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new gt($e["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new Ha($e["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new gt($e["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new gt($e["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new gt($e["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new gt($e["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new gt($e["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, n, o, u), this._updateColorRamp(), this.lastInvalidatedAt = Ct.now();
        }
        onRemove(e) {
          this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
        }
        hasColorMap() {
          return !!this._transitionablePaint._values["raster-particle-color"].value.value;
        }
        getProgramIds() {
          return ["rasterParticle"];
        }
        hasOffscreenPass() {
          return this.visibility !== "none";
        }
        isDraped(e) {
          return !1;
        }
        _handleSpecialPaintPropertyUpdate(e) {
          e !== "raster-particle-color" && e !== "raster-particle-max-speed" || (this._updateColorRamp(), this._invalidateAnimationState()), e === "raster-particle-count" && this._invalidateAnimationState();
        }
        _updateColorRamp() {
          if (!this.hasColorMap())
            return;
          const e = this._transitionablePaint._values["raster-particle-color"].value.expression, n = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
          this.colorRamp = Rd({ expression: e, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: n }], resolution: 256 }), this.colorRampTexture = null;
        }
        _invalidateAnimationState() {
          this.lastInvalidatedAt = Ct.now();
        }
        tileCoverLift() {
          return this.paint.get("raster-particle-elevation");
        }
      }
      class FT extends wr {
        constructor(e, n) {
          super(e, {}, n, null), this.implementation = e, e.slot && (this.slot = e.slot);
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        isDraped(e) {
          return this.implementation.renderToTile !== void 0;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
        }
        onAdd(e) {
          this.implementation.onAdd && this.implementation.onAdd(e, e.painter.context.gl);
        }
        onRemove(e) {
          this.implementation.onRemove && this.implementation.onRemove(e, e.painter.context.gl);
        }
      }
      function q_(r, e, n) {
        const o = [0, 0, 1], u = De.quat.identity([]);
        return De.quat.rotateY(u, u, n ? -vi(r) + Math.PI : vi(r)), De.quat.rotateX(u, u, -vi(e)), De.vec3.transformQuat(o, o, u), De.vec3.normalize(o, o);
      }
      function Tx(r, e) {
        const n = Hp(r.projection, r.zoom, r.width, r.height), o = function(l, d, v, M, D) {
          const x = new Ui(v.lng - 180 * vc, v.lat), E = new Ui(v.lng + 180 * vc, v.lat), I = l.project(x.lng, x.lat), S = l.project(E.lng, E.lat), C = -Math.atan2(S.y - I.y, S.x - I.x), k = h.fromLngLat(v);
          k.y = si(k.y, -1 + vc, 1 - vc);
          const V = k.toLngLat(), U = l.project(V.lng, V.lat), q = h.fromLngLat(V);
          q.x += vc;
          const $ = q.toLngLat(), H = l.project($.lng, $.lat), K = Mx(H.x - U.x, H.y - U.y, C), Q = h.fromLngLat(V);
          Q.y += vc;
          const ie = Q.toLngLat(), fe = l.project(ie.lng, ie.lat), de = Mx(fe.x - U.x, fe.y - U.y, C), he = Math.abs(K.x) / Math.abs(de.y), Me = De.mat4.identity([]);
          De.mat4.rotateZ(Me, Me, -C * (1 - (D ? 0 : M)));
          const me = De.mat4.identity([]);
          return De.mat4.scale(me, me, [1, 1 - (1 - he) * M, 1]), me[4] = -de.x / de.y * M, De.mat4.rotateZ(me, me, C), De.mat4.multiply(me, Me, me), me;
        }(r.projection, 0, r.center, n, e), u = Sx(r);
        return De.mat4.scale(o, o, [u, u, 1]), o;
      }
      function Sx(r) {
        const e = r.projection, n = Hp(r.projection, r.zoom, r.width, r.height), o = W_(e, r.center), u = W_(e, Ui.convert(e.center));
        return Math.pow(2, o * n + (1 - n) * u);
      }
      function Hp(r, e, n, o, u = 1 / 0) {
        const l = r.range;
        if (!l)
          return 0;
        const d = Math.min(u, Math.max(n, o)), v = Math.log(d / 1024) / Math.LN2;
        return fs(l[0] + v, l[1] + v, e);
      }
      const vc = 1 / 4e4;
      function W_(r, e) {
        const n = si(e.lat, -Un, Un), o = new Ui(e.lng - 180 * vc, n), u = new Ui(e.lng + 180 * vc, n), l = r.project(o.lng, n), d = r.project(u.lng, n), v = h.fromLngLat(o), M = h.fromLngLat(u), D = d.x - l.x, x = d.y - l.y, E = M.x - v.x, I = M.y - v.y, S = Math.sqrt((E * E + I * I) / (D * D + x * x));
        return Math.log(S) / Math.LN2;
      }
      function Mx(r, e, n) {
        const o = Math.cos(n), u = Math.sin(n);
        return { x: r * o - e * u, y: r * u + e * o };
      }
      function Ex(r, e, n) {
        De.mat4.identity(r), De.mat4.rotateZ(r, r, vi(e[2])), De.mat4.rotateX(r, r, vi(e[0])), De.mat4.rotateY(r, r, vi(e[1])), De.mat4.scale(r, r, n), De.mat4.multiply(r, r, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function qp(r, e, n, o, u, l, d, v) {
        const M = [n[0] - e[0], n[1] - e[1], 0], D = [o[0] - e[0], o[1] - e[1], 0];
        if (De.vec3.length(M) < 1e-12 || De.vec3.length(D) < 1e-12)
          return De.quat.identity(r);
        const x = De.vec3.cross([], M, D);
        De.vec3.normalize(x, x), De.vec3.subtract(D, o, e), M[2] = (l - u) * v, D[2] = (d - u) * v;
        const E = M;
        return De.vec3.cross(E, M, D), De.vec3.normalize(E, E), De.quat.rotationTo(r, x, E);
      }
      function $_(r, e, n = !1) {
        const o = mr(e.zoom), u = function(l, d, v) {
          const M = d.worldSize, D = [l[12], l[13], l[14]], x = Os(D[1] / M), E = Fr(D[0] / M), I = De.mat4.identity([]), S = fr(1, x) * M, C = fr(1, 0) * M * c(x, d.zoom), k = 1 / eo(M);
          let V = C * k;
          if (v) {
            const H = Hp(d.projection, d.zoom, d.width, d.height, 1024);
            V = k * d.projection.pixelSpaceConversion(d.center.lat, M, H);
          }
          const U = Ja(x, E);
          De.vec3.add(U, U, De.vec3.scale([], De.vec3.normalize([], U), S * V * D[2]));
          const q = function(H) {
            const K = [H[0], H[1], H[2]];
            let Q = [0, 1, 0];
            const ie = De.vec3.cross([], Q, K);
            return De.vec3.cross(Q, K, ie), De.vec3.squaredLength(Q) === 0 && (Q = [0, 1, 0], De.vec3.cross(ie, K, Q)), De.vec3.normalize(ie, ie), De.vec3.normalize(Q, Q), De.vec3.normalize(K, K), [ie[0], ie[1], ie[2], 0, Q[0], Q[1], Q[2], 0, K[0], K[1], K[2], 0, H[0], H[1], H[2], 1];
          }(U);
          De.mat4.scale(I, I, [V, V, V * S]), De.mat4.translate(I, I, [-D[0], -D[1], -D[2]]);
          const $ = De.mat4.multiply([], d.globeMatrix, q);
          return De.mat4.multiply($, $, I), De.mat4.multiply($, $, l), $;
        }(r, e, n);
        if (o > 0) {
          const l = function(d, v) {
            const M = v.worldSize, D = fr(1, 0) * M * c(v.center.lat, v.zoom) / eo(M), x = fr(1, v.center.lat) * M, E = De.mat4.identity([]);
            return De.mat4.rotateY(E, E, vi(v.center.lng)), De.mat4.rotateX(E, E, vi(v.center.lat)), De.mat4.translate(E, E, [0, 0, dr]), De.mat4.scale(E, E, [D, D, D * x]), De.mat4.translate(E, E, [v.point.x - 0.5 * M, v.point.y - 0.5 * M, 0]), De.mat4.multiply(E, E, d), De.mat4.multiply(E, v.globeMatrix, E);
          }(r, e);
          return function(d, v, M) {
            const D = (C, k, V) => {
              const U = De.vec3.length(C), q = De.vec3.length(k), $ = As(C, k, V);
              return De.vec3.scale($, $, 1 / De.vec3.length($) * ei(U, q, V));
            }, x = D([d[0], d[1], d[2]], [v[0], v[1], v[2]], M), E = D([d[4], d[5], d[6]], [v[4], v[5], v[6]], M), I = D([d[8], d[9], d[10]], [v[8], v[9], v[10]], M), S = As([d[12], d[13], d[14]], [v[12], v[13], v[14]], M);
            return [x[0], x[1], x[2], 0, E[0], E[1], E[2], 0, I[0], I[1], I[2], 0, S[0], S[1], S[2], 1];
          }(u, l, o);
        }
        return u;
      }
      function Ax(r, e, n, o) {
        const u = Jt.projectAabbCorners(o, n);
        let l = Number.MAX_VALUE, d = -1;
        for (let D = 0; D < u.length; ++D) {
          const x = u[D];
          x[0] = (0.5 * x[0] + 0.5) * e.width, x[1] = (0.5 - 0.5 * x[1]) * e.height, x[2] < l && (d = D, l = x[2]);
        }
        const v = (D) => new Mt(u[D][0], u[D][1]);
        let M;
        switch (d) {
          case 0:
          case 6:
            M = [v(1), v(5), v(4), v(7), v(3), v(2), v(1)];
            break;
          case 1:
          case 7:
            M = [v(0), v(4), v(5), v(6), v(2), v(3), v(0)];
            break;
          case 3:
          case 5:
            M = [v(1), v(0), v(4), v(7), v(6), v(2), v(1)];
            break;
          default:
            M = [v(1), v(5), v(6), v(7), v(3), v(0), v(1)];
        }
        if (se(r, M))
          return l;
      }
      const BT = qi([{ name: "a_pos_3f", components: 3, type: "Float32" }]), NT = qi([{ name: "a_color_3f", components: 3, type: "Float32" }]), VT = qi([{ name: "a_color_4f", components: 4, type: "Float32" }]), UT = qi([{ name: "a_uv_2f", components: 2, type: "Float32" }]), jT = qi([{ name: "a_normal_3f", components: 3, type: "Float32" }]), GT = qi([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), ZT = qi([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), Px = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
      class Wp {
        constructor(e, n, o, u) {
          this.message = (e ? `${e}: ` : "") + o, u && (this.identifier = u), n != null && n.__line__ && (this.line = n.__line__);
        }
      }
      function Cx(r, e) {
        const n = r.indexOf("://") === -1;
        try {
          return new URL(r, n && e ? "http://example.com" : void 0), !0;
        } catch {
          return !1;
        }
      }
      class Ix {
        constructor(e, n) {
          this.feature = e, this.instancedDataOffset = n, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
        }
      }
      class Lx {
        constructor() {
          this.instancedDataArray = new Pd(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
        }
      }
      class X_ {
        constructor(e) {
          this.zoom = e.zoom, this.canonical = e.canonical, this.layers = e.layers, this.layerIds = this.layers.map((n) => n.fqid), this.projection = e.projection, this.index = e.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((n) => n.isStateDependent()).map((n) => n.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
        }
        updateFootprints(e, n) {
        }
        populate(e, n, o, u) {
          this.tileToMeter = s(o);
          const l = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: d, id: v, index: M, sourceLayerIndex: D } of e) {
            const x = v ?? (d.properties && d.properties.hasOwnProperty("id") ? d.properties.id : void 0), E = G(d, l);
            if (!this.layers[0]._featureFilter.filter(new Tn(this.zoom), E, o))
              continue;
            const I = { id: x, sourceLayerIndex: D, index: M, geometry: l ? E.geometry : j(d, o, u), properties: d.properties, type: d.type, patterns: {} }, S = this.addFeature(I, I.geometry, E);
            S && n.featureIndex.insert(d, I.geometry, M, D, this.index, this.instancesPerModel[S].instancedDataArray.length, wt / 32);
          }
          this.lookup = null;
        }
        update(e, n, o, u) {
          for (const l in this.instancesPerModel) {
            const d = this.instancesPerModel[l];
            for (const v in e)
              d.idToFeaturesIndex.hasOwnProperty(v) && (this.evaluate(d.features[d.idToFeaturesIndex[v]], e[v], d, !0), this.uploaded = !1);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties)
            return !1;
          let e = !1;
          for (const n in this.instancesPerModel) {
            const o = this.instancesPerModel[n];
            for (const u of o.features) {
              const l = this.layers[0], d = u.feature, v = this.canonical, M = l.paint.get("model-rotation").evaluate(d, {}, v), D = l.paint.get("model-scale").evaluate(d, {}, v), x = l.paint.get("model-translation").evaluate(d, {}, v);
              De.vec3.exactEquals(u.rotation, M) && De.vec3.exactEquals(u.scale, D) && De.vec3.exactEquals(u.translation, x) || (this.evaluate(u, u.featureStates, o, !0), e = !0);
            }
          }
          return e;
        }
        updateReplacement(e, n, o, u) {
          if (n.updateTime === this.replacementUpdateTime)
            return !1;
          this.replacementUpdateTime = n.updateTime;
          const l = n.getReplacementRegionsForTile(e.toUnwrapped(), !0);
          if (v_(this.activeReplacements, l))
            return !1;
          this.activeReplacements = l;
          let d = !1;
          for (const v in this.instancesPerModel) {
            const M = this.instancesPerModel[v], D = M.instancedDataArray;
            for (const x of M.features) {
              const E = x.instancedDataOffset, I = x.instancedDataCount;
              for (let S = 0; S < I; S++) {
                const C = 16 * (S + E);
                let k = D.float32[C + 0];
                const V = k > wt;
                k = V ? k - wt : k;
                const U = Math.floor(k), q = D.float32[C + 1];
                let $ = !1;
                for (const H of this.activeReplacements)
                  if (!Hy(H, o, Px.Model, u) && !(H.min.x > U || U > H.max.x || H.min.y > q || q > H.max.y) && ($ = Ky(Yy(U, q, e.canonical, H.footprintTileId.canonical), H.footprint), $))
                    break;
                D.float32[C] = $ ? k + wt : k, d = d || $ !== V;
              }
            }
          }
          return d;
        }
        isEmpty() {
          for (const e in this.instancesPerModel)
            if (this.instancesPerModel[e].instancedDataArray.length !== 0)
              return !1;
          return !0;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(e) {
          if (!this.uploaded)
            for (const n in this.instancesPerModel) {
              const o = this.instancesPerModel[n];
              o.instancedDataArray.length < 0 || o.instancedDataArray.length === 0 || (o.instancedDataBuffer ? o.instancedDataBuffer.updateData(o.instancedDataArray) : o.instancedDataBuffer = e.createVertexBuffer(o.instancedDataArray, GT.members, !0, void 0, this.instanceCount));
            }
          this.uploaded = !0;
        }
        destroy() {
          for (const n in this.instancesPerModel) {
            const o = this.instancesPerModel[n];
            o.instancedDataArray.length !== 0 && o.instancedDataBuffer && o.instancedDataBuffer.destroy();
          }
          const e = this.layers[0].modelManager;
          if (e && this.modelUris)
            for (const n of this.modelUris)
              e.removeModel(n, "");
        }
        addFeature(e, n, o) {
          const u = this.layers[0], l = u.layout.get("model-id").evaluate(o, {}, this.canonical);
          if (!l)
            return mi(`modelId is not evaluated for layer ${u.id} and it is not going to get rendered.`), l;
          Cx(l, !1) && (this.modelUris.includes(l) || this.modelUris.push(l)), this.instancesPerModel[l] || (this.instancesPerModel[l] = new Lx());
          const d = this.instancesPerModel[l], v = d.instancedDataArray, M = new Ix(o, v.length);
          for (const D of n)
            for (const x of D) {
              if (x.x < 0 || x.x >= wt || x.y < 0 || x.y >= wt)
                continue;
              const E = (this.lookupDim - 1) / wt, I = this.lookupDim * (x.y * E | 0) + x.x * E | 0;
              if (this.lookup) {
                if (this.lookup[I] !== 0)
                  continue;
                this.lookup[I] = 1;
              }
              this.instanceCount++;
              const S = v.length;
              v.resize(S + 1), d.instancesEvaluatedElevation.push(0), v.float32[16 * S] = x.x, v.float32[16 * S + 1] = x.y;
            }
          return M.instancedDataCount = d.instancedDataArray.length - M.instancedDataOffset, M.instancedDataCount > 0 && (e.id && (d.idToFeaturesIndex[e.id] = d.features.length), d.features.push(M), this.evaluate(M, {}, d, !1)), l;
        }
        getModelUris() {
          return this.modelUris;
        }
        evaluate(e, n, o, u) {
          const l = this.layers[0], d = e.feature, v = this.canonical, M = e.rotation = l.paint.get("model-rotation").evaluate(d, n, v), D = e.scale = l.paint.get("model-scale").evaluate(d, n, v), x = e.translation = l.paint.get("model-translation").evaluate(d, n, v), E = l.paint.get("model-color").evaluate(d, n, v);
          E.a = l.paint.get("model-color-mix-intensity").evaluate(d, n, v);
          const I = [];
          this.maxVerticalOffset < x[2] && (this.maxVerticalOffset = x[2]), this.maxScale = Math.max(Math.max(this.maxScale, D[0]), Math.max(D[1], D[2])), Ex(I, M, D);
          const S = Math.round(100 * E.a) + E.b / 1.05;
          for (let C = 0; C < e.instancedDataCount; ++C) {
            const k = e.instancedDataOffset + C, V = 16 * k, U = o.instancedDataArray.float32;
            let q = 0;
            u && (q = U[V + 6] - o.instancesEvaluatedElevation[k]);
            const $ = 0 | U[V + 1];
            U[V] = (0 | U[V]) + E.r / 1.05, U[V + 1] = $ + E.g / 1.05, U[V + 2] = S, U[V + 3] = 1 / (v.z > 10 ? this.tileToMeter : s(v, $)), U[V + 4] = x[0], U[V + 5] = x[1], U[V + 6] = x[2] + q, U[V + 7] = I[0], U[V + 8] = I[1], U[V + 9] = I[2], U[V + 10] = I[4], U[V + 11] = I[5], U[V + 12] = I[6], U[V + 13] = I[8], U[V + 14] = I[9], U[V + 15] = I[10], o.instancesEvaluatedElevation[k] = x[2];
          }
        }
      }
      let zx, Dx;
      Ft(X_, "ModelBucket", { omit: ["layers"] }), Ft(Lx, "PerModelAttributes"), Ft(Ix, "ModelFeature");
      const yh = 64, ku = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
      function kx(r, e, n, o, u, l, d, v, M, D = !1) {
        const x = n.zoom, E = n.project(o), I = c(o.lat, x), S = 1 / I;
        De.mat4.identity(r), De.mat4.translate(r, r, [E.x + d[0] * S, E.y + d[1] * S, d[2]]);
        let C = 1, k = 1;
        const V = n.worldSize;
        if (D) {
          if (n.projection.name === "mercator") {
            let H = 0;
            n.elevation && (H = n.elevation.getAtPointOrZero(new h(E.x / V, E.y / V), 0));
            const K = De.vec4.transformMat4([], [E.x, E.y, H, 1], n.projMatrix)[3] / n.cameraToCenterDistance;
            C = K, k = K * c(n.center.lat, x);
          } else if (n.projection.name === "globe") {
            const H = $_(r, n), K = De.mat4.multiply([], n.projMatrix, H), Q = [0, 0, 0, 1];
            De.vec4.transformMat4(Q, Q, K);
            const ie = Q[3] / n.cameraToCenterDistance, fe = mr(x), de = n.projection.pixelsPerMeter(o.lat, V) * c(o.lat, x), he = n.projection.pixelsPerMeter(n.center.lat, V) * c(n.center.lat, x);
            C = ie / ei(de, l_(n.center.lat), fe), k = ie * I / de, C *= he, k *= he;
          }
        } else
          C = S;
        De.mat4.scale(r, r, [C, C, k]);
        const U = [...r], q = e.orientation, $ = [];
        if (Ex($, [q[0] + u[0], q[1] + u[1], q[2] + u[2]], l), De.mat4.multiply(r, U, $), v && n.elevation) {
          let H = 0;
          const K = [];
          if (M && n.elevation) {
            H = function(fe, de, he, Me, me) {
              const Ee = de.elevation;
              if (!Ee)
                return 0;
              const ze = Jt.projectAabbCorners(he, Me), Ie = fr(1, me.lat) * de.worldSize, Re = function(Ut, St) {
                const Nt = [0, 0, 1], Qt = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                for (const pi of Qt) {
                  const gi = Ut[pi.corners[0]], Pi = Ut[pi.corners[1]], yi = Ut[pi.corners[2]], Ii = [Pi[0] - gi[0], Pi[1] - gi[1], St * (Pi[2] - gi[2])], fn = De.vec3.cross(Ii, Ii, [yi[0] - gi[0], yi[1] - gi[1], St * (yi[2] - gi[2])]);
                  De.vec3.normalize(fn, fn), pi.dotProductWithUp = De.vec3.dot(fn, Nt);
                }
                return Qt.sort((pi, gi) => pi.dotProductWithUp - gi.dotProductWithUp), Qt[0].corners;
              }(ze, Ie), Ve = ze[Re[0]], Ue = ze[Re[1]], Fe = ze[Re[2]], et = ze[Re[3]], dt = Ee.getAtPointOrZero(new h(Ve[0] / de.worldSize, Ve[1] / de.worldSize), 0), tt = Ee.getAtPointOrZero(new h(Ue[0] / de.worldSize, Ue[1] / de.worldSize), 0), Tt = Ee.getAtPointOrZero(new h(Fe[0] / de.worldSize, Fe[1] / de.worldSize), 0), vt = Ee.getAtPointOrZero(new h(et[0] / de.worldSize, et[1] / de.worldSize), 0), Pt = (dt + vt) / 2, rt = (tt + Tt) / 2;
              return Pt > rt ? tt < Tt ? qp(fe, Ue, et, Ve, tt, vt, dt, Ie) : qp(fe, Fe, Ve, et, Tt, dt, vt, Ie) : dt < vt ? qp(fe, Ve, Ue, Fe, dt, tt, Tt, Ie) : qp(fe, et, Fe, Ue, vt, Tt, tt, Ie), Math.max(Pt, rt);
            }(K, n, e.aabb, r, o);
            const Q = De.mat4.fromQuat([], K), ie = De.mat4.multiply([], Q, $);
            De.mat4.multiply(r, U, ie);
          } else
            H = n.elevation.getAtPointOrZero(new h(E.x / V, E.y / V), 0);
          H !== 0 && (r[14] += H);
        }
      }
      function tf(r, e, n = !1) {
        r.uploaded || (r.gfxTexture = new H_(e, r.image, n ? e.gl.R8 : e.gl.RGBA8, { useMipmap: r.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST }), r.uploaded = !0, r.image = null);
      }
      function HT(r, e, n) {
        r.indexBuffer = e.createIndexBuffer(r.indexArray, !1, !0), r.vertexBuffer = e.createVertexBuffer(r.vertexArray, BT.members, !1, !0), r.normalArray && (r.normalBuffer = e.createVertexBuffer(r.normalArray, jT.members, !1, !0)), r.texcoordArray && (r.texcoordBuffer = e.createVertexBuffer(r.texcoordArray, UT.members, !1, !0)), r.colorArray && (r.colorBuffer = e.createVertexBuffer(r.colorArray, (r.colorArray.bytesPerElement === 12 ? NT : VT).members, !1, !0)), r.featureArray && (r.pbrBuffer = e.createVertexBuffer(r.featureArray, ZT.members, !0)), r.segments = Wn.simpleSegment(0, 0, r.vertexArray.length, r.indexArray.length);
        const o = r.material;
        o.pbrMetallicRoughness.baseColorTexture && tf(o.pbrMetallicRoughness.baseColorTexture, e), o.pbrMetallicRoughness.metallicRoughnessTexture && tf(o.pbrMetallicRoughness.metallicRoughnessTexture, e), o.normalTexture && tf(o.normalTexture, e), o.occlusionTexture && tf(o.occlusionTexture, e, n), o.emissionTexture && tf(o.emissionTexture, e);
      }
      function Y_(r, e, n) {
        if (r.meshes)
          for (const o of r.meshes)
            HT(o, e, n);
        if (r.children)
          for (const o of r.children)
            Y_(o, e, n);
      }
      function $p(r) {
        if (r.meshes)
          for (const e of r.meshes)
            e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
        if (r.children)
          for (const e of r.children)
            $p(e);
      }
      function K_(r) {
        if (r.meshes)
          for (const n of r.meshes)
            n.vertexBuffer && (n.vertexBuffer.destroy(), n.indexBuffer.destroy(), n.normalBuffer && n.normalBuffer.destroy(), n.texcoordBuffer && n.texcoordBuffer.destroy(), n.colorBuffer && n.colorBuffer.destroy(), n.pbrBuffer && n.pbrBuffer.destroy(), n.segments.destroy(), n.material && ((e = n.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
        var e;
        if (r.children)
          for (const n of r.children)
            K_(n);
      }
      class Ru {
        constructor(e, n, o) {
          this._demTile = e, this._dem = this._demTile.dem, this._scale = n, this._offset = o;
        }
        static create(e, n, o) {
          const u = o || e.findDEMTileFor(n);
          if (!u || !u.dem)
            return;
          const l = u.dem, d = u.tileID, v = 1 << n.canonical.z - d.canonical.z;
          return new Ru(u, l.dim / wt / v, [(n.canonical.x / v - d.canonical.x) * l.dim, (n.canonical.y / v - d.canonical.y) * l.dim]);
        }
        tileCoordToPixel(e, n) {
          const o = n * this._scale + this._offset[1], u = Math.floor(e * this._scale + this._offset[0]), l = Math.floor(o);
          return new Mt(u, l);
        }
        getElevationAt(e, n, o, u) {
          const l = e * this._scale + this._offset[0], d = n * this._scale + this._offset[1], v = Math.floor(l), M = Math.floor(d), D = this._dem;
          return u = !!u, o ? ei(ei(D.get(v, M, u), D.get(v, M + 1, u), d - M), ei(D.get(v + 1, M, u), D.get(v + 1, M + 1, u), d - M), l - v) : D.get(v, M, u);
        }
        getElevationAtPixel(e, n, o) {
          return this._dem.get(e, n, !!o);
        }
        getMeterToDEM(e) {
          return (1 << this._demTile.tileID.canonical.z) * fr(1, e) * this._dem.stride;
        }
      }
      const J_ = new Float32Array(262144), xh = new Uint8Array(262144);
      function Rx(r) {
        let e = 0;
        if (r.meshes)
          for (const n of r.meshes)
            e = Math.max(e, n.aabb.max[2]);
        if (r.children)
          for (const n of r.children)
            e = Math.max(e, Rx(n));
        return e;
      }
      function Ox(r, e, n) {
        if (r.meshes)
          for (const o of r.meshes) {
            if (o.aabb.min[0] === 1 / 0)
              continue;
            const u = Jt.applyTransform(o.aabb, r.matrix);
            n.insert(e, u.min[0], u.min[1], u.max[0], u.max[1]);
          }
        if (r.children)
          for (const o of r.children)
            Ox(o, e, n);
      }
      const Fx = ["", "wall", "door", "roof", "window", "lamp", "logo"];
      class Bx {
        constructor(e) {
          this.node = e, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: e.id, geometry: [], properties: { height: Rx(e) } }, this.aabb = this._getLocalBounds(), this.state = null;
        }
        _getLocalBounds() {
          if (!this.node.meshes)
            return new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
          if (!this.aabb) {
            let e = 0;
            const n = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
            for (const o of this.node.meshes)
              this.node.lightMeshIndex !== e && (o.transformedAabb = Jt.applyTransformFast(o.aabb, this.node.matrix), n.encapsulate(o.transformedAabb)), e++;
            this.aabb = n;
          }
          return this.aabb;
        }
      }
      class Xp {
        constructor(e, n, o, u, l, d, v) {
          this.id = o, this.layers = e, this.layerIds = this.layers.map((M) => M.fqid), this.stateDependentLayerIds = this.layers.filter((M) => M.isStateDependent()).map((M) => M.id), this.modelTraits |= ku.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, u && (this.modelTraits |= ku.HasMapboxMeshFeatures), l && (this.modelTraits |= ku.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = d, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
          for (const M of n)
            this.nodesInfo.push(new Bx(M)), Ox(M, v.featureIndexArray.length, v.grid), v.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, v.bucketLayerIDs.length - 1, 0);
          this.states = {};
        }
        updateFootprints(e, n) {
          for (const o of this.getNodesInfo()) {
            const u = o.node;
            u.footprint && n.push({ footprint: u.footprint, id: e });
          }
        }
        update(e) {
          const n = Object.keys(e).length !== 0;
          if (n && !this.stateDependentLayers.length)
            return;
          const o = n ? this.stateDependentLayers : this.layers;
          if (!ir(e, this.states))
            for (const u of o)
              this.evaluate(u, e);
          this.states = structuredClone(e);
        }
        populate() {
          console.log("populate 3D model bucket");
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(e) {
          if (!this.needsUpload)
            return;
          const n = this.getNodesInfo();
          for (const o of n) {
            const u = o.node;
            this.uploaded ? this.updatePbrBuffer(u) : Y_(u, e, !0);
          }
          for (const o of n)
            $p(o.node);
          this.uploaded = !0, this.needsUpload = !1;
        }
        updatePbrBuffer(e) {
          let n = !1;
          if (!e.meshes)
            return n;
          for (const o of e.meshes)
            o.pbrBuffer && (o.pbrBuffer.updateData(o.featureArray), n = !0);
          return n;
        }
        needsReEvaluation(e, n, o) {
          const u = e.transform.projectionOptions, l = e.style.getBrightness(), d = this.brightness !== l;
          if (!this.uploaded || this.dirty || u.name !== this.projection.name || nf(o.paint.get("model-color").value, d) || nf(o.paint.get("model-color-mix-intensity").value, d) || nf(o.paint.get("model-roughness").value, d) || nf(o.paint.get("model-emissive-strength").value, d) || nf(o.paint.get("model-height-based-emissive-strength-multiplier").value, d)) {
            this.projection = u, this.brightness = l;
            const v = this.getNodesInfo();
            for (const M of v)
              M.state = null;
            return !0;
          }
          return !1;
        }
        evaluateScale(e, n) {
          if (e.transform.zoom === this.zoom)
            return;
          this.zoom = e.transform.zoom;
          const o = this.getNodesInfo(), u = this.id.canonical;
          for (const l of o) {
            const d = l.feature;
            l.evaluatedScale = n.paint.get("model-scale").evaluate(d, {}, u);
          }
        }
        evaluate(e, n) {
          const o = this.getNodesInfo();
          for (const u of o) {
            if (!u.node.meshes)
              continue;
            const l = u.feature, d = n && n[l.id];
            if (ir(d, u.state))
              continue;
            u.state = structuredClone(d);
            const v = u.node.meshes && u.node.meshes[0].featureData, M = u.evaluatedColor[2], D = u.evaluatedRMEA[2], x = this.id.canonical;
            if (u.hasTranslucentParts = !1, v) {
              for (let E = 0; E < Fx.length; E++) {
                const I = Fx[E];
                I.length && (l.properties.part = I);
                const S = e.paint.get("model-color").evaluate(l, d, x).toRenderColor(null), C = e.paint.get("model-color-mix-intensity").evaluate(l, d, x);
                u.evaluatedColor[E] = [S.r, S.g, S.b, C], u.evaluatedRMEA[E][0] = e.paint.get("model-roughness").evaluate(l, d, x), u.evaluatedRMEA[E][2] = e.paint.get("model-emissive-strength").evaluate(l, d, x), u.evaluatedRMEA[E][3] = S.a, u.emissionHeightBasedParams[E] = e.paint.get("model-height-based-emissive-strength-multiplier").evaluate(l, d, x), !u.hasTranslucentParts && S.a < 1 && (u.hasTranslucentParts = !0);
              }
              delete l.properties.part, WT(u, M !== u.evaluatedColor[2] || D !== u.evaluatedRMEA[2], this.modelTraits);
            } else
              u.evaluatedRMEA[0][2] = e.paint.get("model-emissive-strength").evaluate(l, d, x);
            u.evaluatedScale = e.paint.get("model-scale").evaluate(l, d, x), this.updatePbrBuffer(u.node) || (this.needsUpload = !0);
          }
          this.dirty = !1;
        }
        elevationUpdate(e, n, o, u) {
          const l = e.findDEMTileFor(o);
          if (l && (l.tileID.canonical !== this.terrainTile || n !== this.terrainExaggeration)) {
            if (l.dem && l.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = l.tileID.overscaledZ;
              const d = Ru.create(e, o, l);
              if (!d)
                return;
              this.modelTraits & ku.HasMapboxMeshFeatures && this.updateDEM(e, d, o, u);
              for (const v of this.getNodesInfo()) {
                const M = v.node;
                if (!M.footprint || !M.footprint.vertices || !M.footprint.vertices.length)
                  continue;
                const D = M.footprint.vertices;
                let x = d.getElevationAt(D[0].x, D[0].y, !0, !0);
                for (let E = 1; E < D.length; E++)
                  x = Math.min(x, d.getElevationAt(D[E].x, D[E].y, !0, !0));
                M.elevation = x;
              }
            }
            this.terrainTile = l.tileID.canonical, this.terrainExaggeration = n;
          }
        }
        updateDEM(e, n, o, u) {
          let l = n._dem._modifiedForSources[u];
          if (l === void 0 && (n._dem._modifiedForSources[u] = [], l = n._dem._modifiedForSources[u]), l.includes(o.canonical))
            return;
          const d = n._dem.dim;
          l.push(o.canonical);
          let v = !1;
          for (const M of this.getNodesInfo()) {
            const D = M.node;
            if (!D.footprint || !D.footprint.grid)
              continue;
            const x = D.footprint.grid, E = n.tileCoordToPixel(x.min.x, x.min.y), I = n.tileCoordToPixel(x.max.x, x.max.y), S = Math.min(Math.min(d - I.y, E.x), Math.min(E.y, d - I.x));
            if (S < 0)
              continue;
            const C = si(S, 2, 5);
            let k = Math.max(0, E.x - C), V = Math.max(0, E.y - C), U = Math.min(I.x + C, d - 1), q = Math.min(I.y + C, d - 1);
            for (let Q = V; Q <= q; ++Q)
              for (let ie = k; ie <= U; ++ie)
                xh[Q * d + ie] = 255;
            let $ = 0, H = 0;
            for (let Q = 0; Q < x.cellsY; ++Q)
              for (let ie = 0; ie < x.cellsX; ++ie) {
                if (!x.cells[Q * x.cellsX + ie])
                  continue;
                const fe = n.tileCoordToPixel(x.min.x + ie / x.xScale, x.min.y + Q / x.yScale), de = n.tileCoordToPixel(x.min.x + (ie + 1) / x.xScale, x.min.y + (Q + 1) / x.yScale);
                for (let he = fe.y; he <= Math.min(de.y + 1, d - 1); ++he)
                  for (let Me = fe.x; Me <= Math.min(de.x + 1, d - 1); ++Me)
                    xh[he * d + Me] === 255 && (xh[he * d + Me] = 0, $ += n.getElevationAtPixel(Me, he), H++);
              }
            const K = $ / H;
            k = Math.max(1, E.x - C), V = Math.max(1, E.y - C), U = Math.min(I.x + C, d - 2), q = Math.min(I.y + C, d - 2), v = !0;
            for (let Q = V; Q <= q; ++Q)
              for (let ie = k; ie <= U; ++ie)
                xh[Q * d + ie] === 0 && (J_[Q * d + ie] = n._dem.set(ie, Q, K));
            for (let Q = 1; Q < C; ++Q) {
              k = Math.max(1, E.x - Q), V = Math.max(1, E.y - Q), U = Math.min(I.x + Q, d - 2), q = Math.min(I.y + Q, d - 2);
              for (let ie = V; ie <= q; ++ie)
                for (let fe = k; fe <= U; ++fe) {
                  const de = ie * d + fe;
                  if (xh[de] === 255) {
                    let he = 0, Me = 0, me = -1, Ee = -1;
                    for (let ze = -1; ze <= 1; ++ze)
                      for (let Ie = -1; Ie <= 1; ++Ie) {
                        const Re = (ie + ze) * d + fe + Ie;
                        if (xh[Re] >= Q)
                          continue;
                        const Ve = J_[Re], Ue = Math.abs(Ve);
                        Ue > Me && (he = Ve, Me = Ue, me = Ie, Ee = ze);
                      }
                    if (Me > 0.1) {
                      const ze = 1 - (Q + 0.5 * Math.abs(me * Ee)) / C;
                      let Ie = n._dem.get(fe, ie) + he * ze;
                      const Re = n._dem.get(fe + me, ie + Ee), Ve = n._dem.get(fe - me, ie - Ee, !0);
                      (Ie - Re) * (Ie - Ve) > 0 && (Ie = (Re + Ve) / 2), J_[de] = n._dem.set(fe, ie, Ie), xh[de] = Q;
                    }
                  }
                }
            }
          }
          v && (n._demTile.needsDEMTextureUpload = !0, n._dem._timestamp = Ct.now());
        }
        getNodesInfo() {
          return this.nodesInfo;
        }
        destroy() {
          const e = this.getNodesInfo();
          for (const n of e)
            $p(n.node), K_(n.node);
        }
        isEmpty() {
          return !this.nodesInfo.length;
        }
        updateReplacement(e, n) {
          if (n.updateTime === this.replacementUpdateTime)
            return;
          this.replacementUpdateTime = n.updateTime;
          const o = n.getReplacementRegionsForTile(e.toUnwrapped()), u = this.getNodesInfo();
          for (let l = 0; l < this.nodesInfo.length; l++) {
            const d = u[l].node;
            u[l].hiddenByReplacement = !!d.footprint && !o.find((v) => v.footprint === d.footprint);
          }
        }
        getHeightAtTileCoord(e, n) {
          const o = this.getNodesInfo(), u = [], l = [0, 0, 0], d = De.mat4.identity([]);
          for (let v = 0; v < this.nodesInfo.length; v++) {
            const M = o[v], D = M.node.meshes[0], x = D.transformedAabb;
            if (e < x.min[0] || n < x.min[1] || e > x.max[0] || n > x.max[1])
              continue;
            if (M.node.hidden === !0)
              return { height: 1 / 0, maxHeight: M.feature.properties.height, hidden: !1, verticalScale: M.evaluatedScale[2] };
            De.mat4.invert(d, M.node.matrix), l[0] = e, l[1] = n, De.vec3.transformMat4(l, l, d);
            const E = (l[0] - D.aabb.min[0]) / (D.aabb.max[0] - D.aabb.min[0]) * yh | 0, I = Math.min(63, (l[1] - D.aabb.min[1]) / (D.aabb.max[1] - D.aabb.min[1]) * yh | 0) * yh + Math.min(63, E), S = D.heightmap[I];
            if (!(S < 0 && M.node.footprint))
              return M.hiddenByReplacement ? void 0 : { height: S, maxHeight: M.feature.properties.height, hidden: !1, verticalScale: M.evaluatedScale[2] };
            if (M.node.footprint.grid.query(new Mt(e, n), new Mt(e, n), u), u.length > 0)
              return { height: void 0, maxHeight: M.feature.properties.height, hidden: M.hiddenByReplacement, verticalScale: M.evaluatedScale[2] };
          }
        }
      }
      function nf(r, e) {
        return !r.isLightConstant && e;
      }
      function qT(r, e, n, o, u, l, d, v) {
        let M = (61440 & e | (61440 & e) >> 4) >> 8, D = (3840 & e | (3840 & e) >> 4) >> 4, x = 240 & e | (240 & e) >> 4;
        n[3] > 0 && (M = ei(M, 255 * n[0], n[3]), D = ei(D, 255 * n[1], n[3]), x = ei(x, 255 * n[2], n[3]));
        const E = M << 8 | D, I = x << 8 | Math.floor(255 * o[3]), S = function(Q) {
          const ie = si(Q, 0, 2);
          return Math.min(Math.round(0.5 * ie * 255), 255);
        }(o[2]) << 8 | 15 * o[0] << 4 | 15 * o[1], C = si(u[0], 0, 1), k = si(u[1], 0, 1), V = si(u[2], 0, 1), U = si(u[3], 0, 1);
        let q, $, H, K;
        if (C !== k && d !== l && k !== C) {
          const Q = d - l;
          $ = 1 / (Q * (k - C)), H = -(l + Q * C) / (Q * (k - C));
          const ie = si(u[4], -1, 1);
          K = Math.pow(10, ie), q = 255 * V << 8 | 255 * U;
        } else
          q = 65535, $ = 0, H = 1, K = 1;
        if (r.emplaceBack(E, I, S, q, $, H, K), v) {
          const Q = v.length;
          v.clear();
          for (let ie = 0; ie < Q; ie++)
            v.emplaceBack(E, I, S, q, $, H, K);
        }
      }
      function WT(r, e, n) {
        const o = r.node;
        let u = 0;
        const l = n & ku.HasMeshoptCompression;
        for (const d of o.meshes) {
          if (o.lights && o.lightMeshIndex === u || !d.featureData)
            continue;
          d.featureArray = new rh(), d.featureArray.reserve(d.featureData.length);
          let v = e;
          for (const M of d.featureData) {
            const D = l ? 65535 & M : M >> 16 & 65535, x = l ? M >> 16 & 65535 : 65535 & M, E = (15 & x) < 8 ? 15 & x : 0, I = r.evaluatedRMEA[E], S = r.evaluatedColor[E], C = r.emissionHeightBasedParams[E];
            let k;
            if (v && E === 2 && o.lights && (k = new rh(), k.resize(10 * o.lights.length)), qT(d.featureArray, D, S, I, C, d.aabb.min[2], d.aabb.max[2], k), k && v) {
              v = !1;
              const V = o.meshes[o.lightMeshIndex];
              V.featureArray = k, V.featureArray._trim();
            }
          }
          d.featureArray._trim(), u++;
        }
      }
      function Nx(r, e, n, o) {
        const u = 1 << r.z;
        e.lat = Os((o / wt + r.y) / u), e.lng = Fr((n / wt + r.x) / u);
      }
      Ft(Xp, "Tiled3dModelBucket", { omit: ["layers"] }), Ft(Bx, "Tiled3dModelFeature");
      const $T = { circle: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: je || (je = new Bn({ "circle-sort-key": new Dt($e.layout_circle["circle-sort-key"]), visibility: new gt($e.layout_circle.visibility) })), paint: at || (at = new Bn({ "circle-radius": new Dt($e.paint_circle["circle-radius"]), "circle-color": new Dt($e.paint_circle["circle-color"]), "circle-blur": new Dt($e.paint_circle["circle-blur"]), "circle-opacity": new Dt($e.paint_circle["circle-opacity"]), "circle-translate": new gt($e.paint_circle["circle-translate"]), "circle-translate-anchor": new gt($e.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new gt($e.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new gt($e.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Dt($e.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Dt($e.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Dt($e.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new gt($e.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        createBucket(r) {
          return new ee(r);
        }
        queryRadius(r) {
          const e = r;
          return Ne("circle-radius", this, e) + Ne("circle-stroke-width", this, e) + st(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l, d, v) {
          const M = yt(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), D = this.paint.get("circle-radius").evaluate(e, n) + this.paint.get("circle-stroke-width").evaluate(e, n);
          return Eu(r, o, l, d, v, this.paint.get("circle-pitch-alignment") === "map", this.paint.get("circle-pitch-scale") === "map", M, D);
        }
        getProgramIds() {
          return ["circle"];
        }
        getDefaultProgramParams(r, e, n) {
          const o = Mu(this);
          return { config: new Al(this, { zoom: e, lut: n }), defines: o, overrideFog: !1 };
        }
      }, heatmap: class extends wr {
        createBucket(r) {
          return new gy(r);
        }
        constructor(r, e, n, o) {
          super(r, { layout: yy || (yy = new Bn({ visibility: new gt($e.layout_heatmap.visibility) })), paint: xy || (xy = new Bn({ "heatmap-radius": new Dt($e.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Dt($e.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new gt($e.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ha($e.paint_heatmap["heatmap-color"]), "heatmap-opacity": new gt($e.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(r) {
          r === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Rd({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(r) {
          return Ne("heatmap-radius", this, r);
        }
        queryIntersectsFeature(r, e, n, o, u, l, d, v) {
          const M = this.paint.get("heatmap-radius").evaluate(e, n);
          return Eu(r, o, l, d, v, !0, !0, new Mt(0, 0), M);
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getDefaultProgramParams(r, e, n) {
          return r === "heatmap" ? { config: new Al(this, { zoom: e, lut: n }), overrideFog: !1 } : {};
        }
      }, hillshade: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: vy || (vy = new Bn({ visibility: new gt($e.layout_hillshade.visibility) })), paint: by || (by = new Bn({ "hillshade-illumination-direction": new gt($e.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new gt($e.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new gt($e.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new gt($e.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new gt($e.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new gt($e.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new gt($e.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        shouldRedrape() {
          return this.hasOffscreenPass() && this.paint.get("hillshade-illumination-anchor") === "viewport";
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getDefaultProgramParams(r, e, n) {
          return { overrideFog: !1 };
        }
      }, fill: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: Iy || (Iy = new Bn({ "fill-sort-key": new Dt($e.layout_fill["fill-sort-key"]), visibility: new gt($e.layout_fill.visibility), "fill-elevation-reference": new gt($e.layout_fill["fill-elevation-reference"]) })), paint: Ly || (Ly = new Bn({ "fill-antialias": new gt($e.paint_fill["fill-antialias"]), "fill-opacity": new Dt($e.paint_fill["fill-opacity"]), "fill-color": new Dt($e.paint_fill["fill-color"]), "fill-outline-color": new Dt($e.paint_fill["fill-outline-color"]), "fill-translate": new gt($e.paint_fill["fill-translate"]), "fill-translate-anchor": new gt($e.paint_fill["fill-translate-anchor"]), "fill-pattern": new Dt($e.paint_fill["fill-pattern"]), "fill-emissive-strength": new gt($e.paint_fill["fill-emissive-strength"]), "fill-z-offset": new Dt($e.paint_fill["fill-z-offset"]), "fill-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        getProgramIds() {
          const r = this.paint.get("fill-pattern"), e = r && r.constantOr(1), n = [e ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && n.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), n;
        }
        getDefaultProgramParams(r, e, n) {
          return { config: new Al(this, { zoom: e, lut: n }), overrideFog: !1 };
        }
        recalculate(r, e) {
          super.recalculate(r, e);
          const n = this.paint._values["fill-outline-color"];
          n.value.kind === "constant" && n.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(r) {
          return new p_(r);
        }
        queryRadius() {
          return st(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          return !r.queryGeometry.isAboveHorizon && ce(ht(r.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), o);
        }
        isTileClipped() {
          return !0;
        }
        is3D() {
          return this.paint.get("fill-z-offset").constantOr(1) !== 0;
        }
      }, "fill-extrusion": class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: d0 || (d0 = new Bn({ visibility: new gt($e["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new gt($e["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: f0 || (f0 = new Bn({ "fill-extrusion-opacity": new gt($e["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Dt($e["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new gt($e["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new gt($e["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Dt($e["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Dt($e["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Dt($e["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new gt($e["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new gt($e["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new gt($e["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new gt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new gt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new gt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new gt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new gt($e["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new gt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new gt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new Dt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new Dt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new gt($e["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new gt($e["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new gt($e["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new gt($e["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new Dt($e["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new Dt($e["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new gt($e["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(r) {
          return new Mp(r);
        }
        queryRadius() {
          return st(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        hasShadowPass() {
          return this.paint.get("fill-extrusion-cast-shadows");
        }
        cutoffRange() {
          return this.paint.get("fill-extrusion-cutoff-fade-range");
        }
        canCastShadows() {
          return !0;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        queryIntersectsFeature(r, e, n, o, u, l, d, v, M) {
          const D = yt(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), x = this.paint.get("fill-extrusion-height").evaluate(e, n), E = this.paint.get("fill-extrusion-base").evaluate(e, n), I = [0, 0], S = v && l.elevation, C = l.elevation ? l.elevation.exaggeration() : 1, k = r.tile.getBucket(this);
          if (S && k instanceof Mp) {
            const H = k.centroidVertexArray, K = M + 1;
            K < H.length && (I[0] = H.geta_centroid_pos0(K), I[1] = H.geta_centroid_pos1(K));
          }
          if (I[0] === 0 && I[1] === 1)
            return !1;
          l.projection.name === "globe" && (o = u0([o], [new Mt(0, 0), new Mt(wt, wt)], r.tileID.canonical).map((H) => H.polygon).flat());
          const V = S ? v : null, [U, q] = function(H, K, Q, ie, fe, de, he, Me, me, Ee, ze) {
            return H.projection.name === "globe" ? function(Ie, Re, Ve, Ue, Fe, et, dt, tt, Tt, vt, Pt) {
              const rt = [], Ut = [], St = Ie.projection.upVectorScale(Pt, Ie.center.lat, Ie.worldSize).metersToTile, Nt = [0, 0, 0, 1], Qt = [0, 0, 0, 1], pi = (Pi, yi, Ii, fn) => {
                Pi[0] = yi, Pi[1] = Ii, Pi[2] = fn, Pi[3] = 1;
              }, gi = h0();
              Ve > 0 && (Ve += gi), Ue += gi;
              for (const Pi of Re) {
                const yi = [], Ii = [];
                for (const fn of Pi) {
                  const rn = fn.x + Fe.x, hi = fn.y + Fe.y, on = Ie.projection.projectTilePoint(rn, hi, Pt), Qi = Ie.projection.upVector(Pt, fn.x, fn.y);
                  let pn = Ve, as = Ue;
                  if (dt) {
                    const ls = m0(rn, hi, Ve, Ue, dt, tt, Tt, vt);
                    pn += ls.base, as += ls.top;
                  }
                  Ve !== 0 ? pi(Nt, on.x + Qi[0] * St * pn, on.y + Qi[1] * St * pn, on.z + Qi[2] * St * pn) : pi(Nt, on.x, on.y, on.z), pi(Qt, on.x + Qi[0] * St * as, on.y + Qi[1] * St * as, on.z + Qi[2] * St * as), De.vec3.transformMat4(Nt, Nt, et), De.vec3.transformMat4(Qt, Qt, et), yi.push(new gh(Nt[0], Nt[1], Nt[2])), Ii.push(new gh(Qt[0], Qt[1], Qt[2]));
                }
                rt.push(yi), Ut.push(Ii);
              }
              return [rt, Ut];
            }(H, K, Q, ie, fe, de, he, Me, me, Ee, ze) : he ? function(Ie, Re, Ve, Ue, Fe, et, dt, tt, Tt) {
              const vt = [], Pt = [], rt = [0, 0, 0, 1];
              for (const Ut of Ie) {
                const St = [], Nt = [];
                for (const Qt of Ut) {
                  const pi = Qt.x + Ue.x, gi = Qt.y + Ue.y, Pi = m0(pi, gi, Re, Ve, et, dt, tt, Tt);
                  rt[0] = pi, rt[1] = gi, rt[2] = Pi.base, rt[3] = 1, De.vec4.transformMat4(rt, rt, Fe), rt[3] = Math.max(rt[3], 1e-5);
                  const yi = new gh(rt[0] / rt[3], rt[1] / rt[3], rt[2] / rt[3]);
                  rt[0] = pi, rt[1] = gi, rt[2] = Pi.top, rt[3] = 1, De.vec4.transformMat4(rt, rt, Fe), rt[3] = Math.max(rt[3], 1e-5);
                  const Ii = new gh(rt[0] / rt[3], rt[1] / rt[3], rt[2] / rt[3]);
                  St.push(yi), Nt.push(Ii);
                }
                vt.push(St), Pt.push(Nt);
              }
              return [vt, Pt];
            }(K, Q, ie, fe, de, he, Me, me, Ee) : function(Ie, Re, Ve, Ue, Fe) {
              const et = [], dt = [], tt = Fe[8] * Re, Tt = Fe[9] * Re, vt = Fe[10] * Re, Pt = Fe[11] * Re, rt = Fe[8] * Ve, Ut = Fe[9] * Ve, St = Fe[10] * Ve, Nt = Fe[11] * Ve;
              for (const Qt of Ie) {
                const pi = [], gi = [];
                for (const Pi of Qt) {
                  const yi = Pi.x + Ue.x, Ii = Pi.y + Ue.y, fn = Fe[0] * yi + Fe[4] * Ii + Fe[12], rn = Fe[1] * yi + Fe[5] * Ii + Fe[13], hi = Fe[2] * yi + Fe[6] * Ii + Fe[14], on = Fe[3] * yi + Fe[7] * Ii + Fe[15], Qi = fn + tt, pn = rn + Tt, as = hi + vt, ls = Math.max(on + Pt, 1e-5), Kn = fn + rt, Vr = rn + Ut, Mn = hi + St, Ln = Math.max(on + Nt, 1e-5);
                  pi.push(new gh(Qi / ls, pn / ls, as / ls)), gi.push(new gh(Kn / Ln, Vr / Ln, Mn / Ln));
                }
                et.push(pi), dt.push(gi);
              }
              return [et, dt];
            }(K, Q, ie, fe, de);
          }(l, o, E, x, D, d, V, I, C, l.center.lat, r.tileID.canonical), $ = r.queryGeometry;
          return function(H, K, Q) {
            let ie = 1 / 0;
            ce(Q, K) && (ie = p0(Q, K[0]));
            for (let fe = 0; fe < K.length; fe++) {
              const de = K[fe], he = H[fe];
              for (let Me = 0; Me < de.length - 1; Me++) {
                const me = de[Me], Ee = [me, de[Me + 1], he[Me + 1], he[Me], me];
                se(Q, Ee) && (ie = Math.min(ie, p0(Q, Ee)));
              }
            }
            return ie !== 1 / 0 && ie;
          }(U, q, $.isPointQuery() ? $.screenBounds : $.screenGeometry);
        }
      }, line: class extends wr {
        constructor(r, e, n, o) {
          const u = M0();
          super(r, u, e, n, o), u.layout && (this.layout = new ac(u.layout)), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(r) {
          if (r === "line-gradient") {
            const e = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = e._styleExpression && e._styleExpression.expression instanceof Ti, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        widthExpression() {
          return this._transitionablePaint._values["line-width"].value.expression;
        }
        recalculate(r, e) {
          super.recalculate(r, e), this.paint._values["line-floorwidth"] = (() => {
            if (Zd)
              return Zd;
            const n = M0();
            return Zd = new Kw(n.paint.properties["line-width"].specification), Zd.useIntegerZoom = !0, Zd;
          })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, r);
        }
        createBucket(r) {
          return new S_(r);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getDefaultProgramParams(r, e, n) {
          const o = T0(this);
          return { config: new Al(this, { zoom: e, lut: n }), defines: o, overrideFog: !1 };
        }
        queryRadius(r) {
          const e = r, n = E0(Ne("line-width", this, e), Ne("line-gap-width", this, e)), o = Ne("line-offset", this, e);
          return n / 2 + Math.abs(o) + st(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          if (r.queryGeometry.isAboveHorizon)
            return !1;
          const d = ht(r.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), l.angle, r.pixelToTileUnitsFactor), v = r.pixelToTileUnitsFactor / 2 * E0(this.paint.get("line-width").evaluate(e, n), this.paint.get("line-gap-width").evaluate(e, n)), M = this.paint.get("line-offset").evaluate(e, n);
          return M && (o = function(D, x) {
            const E = [], I = new Mt(0, 0);
            for (let S = 0; S < D.length; S++) {
              const C = D[S], k = [];
              for (let V = 0; V < C.length; V++) {
                const U = C[V], q = C[V + 1], $ = V === 0 ? I : U.sub(C[V - 1])._unit()._perp(), H = V === C.length - 1 ? I : q.sub(U)._unit()._perp(), K = $._add(H)._unit();
                K._mult(1 / (K.x * H.x + K.y * H.y)), k.push(K._mult(x)._add(U));
              }
              E.push(k);
            }
            return E;
          }(o, M * r.pixelToTileUnitsFactor)), function(D, x, E) {
            for (let I = 0; I < x.length; I++) {
              const S = x[I];
              if (D.length >= 3) {
                for (let C = 0; C < S.length; C++)
                  if (Pe(D, S[C]))
                    return !0;
              }
              if (_e(D, S, E))
                return !0;
            }
            return !1;
          }(d, o, v);
        }
        isTileClipped() {
          return !0;
        }
        isDraped(r) {
          const e = this.layout.get("line-z-offset"), n = e.isConstant() && !e.constantOr(0), o = this.layout.get("line-elevation-reference");
          return !(o === "sea" || o === "ground") && (n || o !== "none");
        }
      }, symbol: Up, background: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: hx || (hx = new Bn({ visibility: new gt($e.layout_background.visibility) })), paint: ux || (ux = new Bn({ "background-pitch-alignment": new gt($e.paint_background["background-pitch-alignment"]), "background-color": new gt($e.paint_background["background-color"]), "background-pattern": new gt($e.paint_background["background-pattern"]), "background-opacity": new gt($e.paint_background["background-opacity"]), "background-emissive-strength": new gt($e.paint_background["background-emissive-strength"]), "background-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
        getDefaultProgramParams(r, e, n) {
          return { overrideFog: !1 };
        }
        is3D() {
          return this.paint.get("background-pitch-alignment") === "viewport";
        }
      }, raster: _x, "raster-particle": wx, sky: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: xx || (xx = new Bn({ visibility: new gt($e.layout_sky.visibility) })), paint: vx || (vx = new Bn({ "sky-type": new gt($e.paint_sky["sky-type"]), "sky-atmosphere-sun": new gt($e.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new gt($e.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new gt($e.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new gt($e.paint_sky["sky-gradient-radius"]), "sky-gradient": new Ha($e.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new gt($e.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new gt($e.paint_sky["sky-atmosphere-color"]), "sky-opacity": new gt($e.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(r) {
          r === "sky-gradient" ? this._updateColorRamp() : r !== "sky-atmosphere-sun" && r !== "sky-atmosphere-halo-color" && r !== "sky-atmosphere-color" && r !== "sky-atmosphere-sun-intensity" || (this._skyboxInvalidated = !0);
        }
        _updateColorRamp() {
          this.colorRamp = Rd({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(r) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return !0;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e = r.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
          }
          return !1;
        }
        getCenter(r, e) {
          if (this.paint.get("sky-type") === "atmosphere") {
            const o = this.paint.get("sky-atmosphere-sun"), u = !o, l = r.style.light, d = l.properties.get("position");
            return u && l.properties.get("anchor") === "viewport" && mi("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), u ? q_(d.azimuthal, 90 - d.polar, e) : q_(o[0], 90 - o[1], e);
          }
          const n = this.paint.get("sky-gradient-center");
          return q_(n[0], 90 - n[1], e);
        }
        isSky() {
          return !0;
        }
        markSkyboxValid(r) {
          this._skyboxInvalidated = !1, this._lightPosition = r.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return !0;
        }
        getProgramIds() {
          const r = this.paint.get("sky-type");
          return r === "atmosphere" ? ["skyboxCapture", "skybox"] : r === "gradient" ? ["skyboxGradient"] : null;
        }
      }, slot: class extends wr {
        constructor(r, e, n, o) {
          super(r, { paint: bx || (bx = new Bn({})) }, e, null);
        }
      }, model: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: zx || (zx = new Bn({ visibility: new gt($e.layout_model.visibility), "model-id": new Dt($e.layout_model["model-id"]) })), paint: Dx || (Dx = new Bn({ "model-opacity": new Dt($e.paint_model["model-opacity"]), "model-rotation": new Dt($e.paint_model["model-rotation"]), "model-scale": new Dt($e.paint_model["model-scale"]), "model-translation": new Dt($e.paint_model["model-translation"]), "model-color": new Dt($e.paint_model["model-color"]), "model-color-mix-intensity": new Dt($e.paint_model["model-color-mix-intensity"]), "model-type": new gt($e.paint_model["model-type"]), "model-cast-shadows": new gt($e.paint_model["model-cast-shadows"]), "model-receive-shadows": new gt($e.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new gt($e.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new Dt($e.paint_model["model-emissive-strength"]), "model-roughness": new Dt($e.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new Dt($e.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new gt($e.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new gt($e.paint_model["model-front-cutoff"]), "model-color-use-theme": new Dt({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e, n, o), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
        }
        createBucket(r) {
          return new X_(r);
        }
        getProgramIds() {
          return ["model"];
        }
        is3D() {
          return !0;
        }
        hasShadowPass() {
          return !0;
        }
        canCastShadows() {
          return !0;
        }
        hasLightBeamPass() {
          return !0;
        }
        cutoffRange() {
          return this.paint.get("model-cutoff-fade-range");
        }
        queryRadius(r) {
          return r instanceof Xp ? wt - 1 : 0;
        }
        queryIntersectsFeature(r, e, n, o, u, l) {
          if (!this.modelManager)
            return !1;
          const d = this.modelManager, v = r.tile.getBucket(this);
          if (!(v && v instanceof X_))
            return !1;
          for (const M in v.instancesPerModel) {
            const D = v.instancesPerModel[M], x = e.id !== void 0 ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
            if (D.idToFeaturesIndex.hasOwnProperty(x)) {
              const E = D.features[D.idToFeaturesIndex[x]], I = d.getModel(M, this.scope);
              if (!I)
                return !1;
              let S = De.mat4.create();
              const C = new Ui(0, 0), k = v.canonical;
              let V = Number.MAX_VALUE;
              for (let U = 0; U < E.instancedDataCount; ++U) {
                const q = 16 * (E.instancedDataOffset + U), $ = D.instancedDataArray.float32, H = [$[q + 4], $[q + 5], $[q + 6]];
                Nx(k, C, $[q], 0 | $[q + 1]), kx(S, I, l, C, E.rotation, E.scale, H, !1, !1, !1), l.projection.name === "globe" && (S = $_(S, l));
                const K = De.mat4.multiply([], l.projMatrix, S), Q = r.queryGeometry, ie = Ax(Q.isPointQuery() ? Q.screenBounds : Q.screenGeometry, l, K, I.aabb);
                ie != null && (V = Math.min(ie, V));
              }
              return V !== Number.MAX_VALUE && V;
            }
          }
          return !1;
        }
        _handleOverridablePaintPropertyUpdate(r, e, n) {
          return !(!this.layout || e.isDataDriven() || n.isDataDriven() || r !== "model-color" && r !== "model-color-mix-intensity" && r !== "model-rotation" && r !== "model-scale" && r !== "model-translation" && r !== "model-emissive-strength");
        }
        _isPropertyZoomDependent(r) {
          const e = this._transitionablePaint._values[r];
          return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof ic;
        }
        isZoomDependent() {
          return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
        }
      }, clip: class extends wr {
        constructor(r, e, n, o) {
          super(r, { layout: zy || (zy = new Bn({ "clip-layer-types": new gt($e.layout_clip["clip-layer-types"]), "clip-layer-scope": new gt($e.layout_clip["clip-layer-scope"]) })), paint: Dy || (Dy = new Bn({})) }, e, n, o);
        }
        recalculate(r, e) {
          super.recalculate(r, e);
        }
        createBucket(r) {
          return new ky(r);
        }
        isTileClipped() {
          return !0;
        }
        is3D() {
          return !0;
        }
      } };
      class XT {
        constructor(e) {
          this._callback = e, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._callback();
          }, 0));
        }
        remove() {
          this._channel = void 0, this._callback = () => {
          };
        }
      }
      class YT {
        constructor() {
          this.tasks = {}, this.taskQueue = [], xo(["process"], this), this.invoker = new XT(this.process), this.nextId = 0;
        }
        add(e, n) {
          const o = this.nextId++, u = function({ type: l, isSymbolTile: d, zoom: v }) {
            return v = v || 0, l === "message" ? 0 : l !== "maybePrepare" || d ? l !== "parseTile" || d ? l === "parseTile" && d ? 300 - v : l === "maybePrepare" && d ? 400 - v : 500 : 200 - v : 100 - v;
          }(n);
          if (u === 0) {
            try {
              e();
            } finally {
            }
            return null;
          }
          return this.tasks[o] = { fn: e, metadata: n, priority: u, id: o }, this.taskQueue.push(o), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[o];
          } };
        }
        process() {
          try {
            if (this.taskQueue = this.taskQueue.filter((o) => !!this.tasks[o]), !this.taskQueue.length)
              return;
            const e = this.pick();
            if (e === null)
              return;
            const n = this.tasks[e];
            if (delete this.tasks[e], this.taskQueue.length && this.invoker.trigger(), !n)
              return;
            n.fn();
          } finally {
          }
        }
        pick() {
          let e = null, n = 1 / 0;
          for (let u = 0; u < this.taskQueue.length; u++) {
            const l = this.tasks[this.taskQueue[u]];
            l.priority < n && (n = l.priority, e = u);
          }
          if (e === null)
            return null;
          const o = this.taskQueue[e];
          return this.taskQueue.splice(e, 1), o;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class Vx {
        constructor(e, n, o) {
          this.target = e, this.parent = n, this.mapId = o, this.callbacks = {}, this.cancelCallbacks = {}, xo(["receive"], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new YT();
        }
        send(e, n, o, u, l = !1, d) {
          const v = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          o && (o.metadata = d, this.callbacks[v] = o);
          const M = /* @__PURE__ */ new Set();
          return this.target.postMessage({ id: v, type: e, hasCallback: !!o, targetMapId: u, mustQueue: l, sourceMapId: this.mapId, data: lo(n, M) }, M), { cancel: () => {
            o && delete this.callbacks[v], this.target.postMessage({ id: v, type: "<cancel>", targetMapId: u, sourceMapId: this.mapId });
          } };
        }
        receive(e) {
          const n = e.data, o = n.id;
          if (o && (!n.targetMapId || this.mapId === n.targetMapId))
            if (n.type === "<cancel>") {
              const u = this.cancelCallbacks[o];
              delete this.cancelCallbacks[o], u && u.cancel();
            } else if (n.mustQueue || Jn()) {
              const u = this.callbacks[o], l = this.scheduler.add(() => this.processTask(o, n), u && u.metadata || { type: "message" });
              l && (this.cancelCallbacks[o] = l);
            } else
              this.processTask(o, n);
        }
        processTask(e, n) {
          if (delete this.cancelCallbacks[e], n.type === "<response>") {
            const o = this.callbacks[e];
            delete this.callbacks[e], o && (n.error ? o(bl(n.error)) : o(null, bl(n.data)));
          } else {
            const o = /* @__PURE__ */ new Set(), u = n.hasCallback ? (d, v) => {
              this.target.postMessage({ id: e, type: "<response>", sourceMapId: this.mapId, error: d ? lo(d) : null, data: lo(v, o) }, o);
            } : () => {
            }, l = bl(n.data);
            if (this.parent[n.type])
              this.parent[n.type](n.sourceMapId, l, u);
            else if (this.parent.getWorkerSource) {
              const d = n.type.split(".");
              this.parent.getWorkerSource(n.sourceMapId, d[0], l.source, l.scope)[d[1]](l, u);
            } else
              u(new Error(`Could not find function ${n.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
        }
      }
      var sf = { workerUrl: "", workerClass: null, workerParams: void 0 };
      const Q_ = "mapboxgl_preloaded_worker_pool";
      class vh {
        constructor() {
          this.active = {};
        }
        acquire(e, n = vh.workerCount) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < n; )
              this.workers.push(sf.workerClass != null ? new sf.workerClass() : new self.Worker(sf.workerUrl, sf.workerParams));
          return this.active[e] = !0, this.workers.slice();
        }
        release(e) {
          delete this.active[e], this.workers && this.numActive() === 0 && (this.workers.forEach((n) => {
            n.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Q_];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      vh.workerCount = 2;
      class Ou {
        constructor(e, n, o = "Worker", u = vh.workerCount) {
          this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = go();
          const l = this.workerPool.acquire(this.id, u);
          for (let d = 0; d < l.length; d++) {
            const v = new Ou.Actor(l[d], n, this.id);
            v.name = `${o} ${d}`, this.actors.push(v);
          }
          this.ready = !1, this.broadcast("checkIfReady", null, () => {
            this.ready = !0;
          });
        }
        broadcast(e, n, o) {
          Rn(this.actors, (u, l) => {
            u.send(e, n, l);
          }, o = o || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e) => {
            e.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      let rf, eg;
      function Yp() {
        return rf || (rf = new vh()), rf;
      }
      Ou.Actor = Vx;
      const tg = new ki(0, 0, 0);
      var Kp = ((r) => (r[r.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED", r[r.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO", r[r.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD", r))(Kp || {}), Jp = ((r) => (r[r.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED", r[r.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT", r[r.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND", r[r.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE", r))(Jp || {}), of = ((r) => (r[r.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED", r[r.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER", r[r.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP", r[r.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND", r[r.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL", r))(of || {}), Ux = ((r) => (r[r.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED", r[r.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE", r[r.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL", r))(Ux || {}), Fu = ((r) => (r[r.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED", r[r.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE", r[r.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE", r[r.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD", r[r.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC", r[r.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE", r))(Fu || {}), jx = ((r) => (r[r.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED", r[r.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE", r[r.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA", r))(jx || {});
      function KT(r, e, n) {
        r === 1 && e.icons.push(function(o, u) {
          return function(l) {
            if (l.usvg_tree.height || (l.usvg_tree.height = l.usvg_tree.width), !l.metadata)
              return l;
            const { metadata: d } = l;
            if (d.content_area) {
              const { content_area: v } = d;
              v.top == null && (v.top = v.left), v.width == null && (v.width = l.usvg_tree.width), v.height == null && (v.height = v.width);
            }
            return d.stretch_x && d.stretch_x.length && Gx(d, "x"), d.stretch_y && d.stretch_y.length && Gx(d, "y"), l;
          }(o.readFields(JT, { name: void 0 }, u));
        }(n, n.readVarint() + n.pos));
      }
      function Gx(r, e) {
        const n = [], o = r[`stretch_${e}`];
        let u = null;
        for (let l = 0; l < o.length; l++)
          u === null ? u = n.length === 0 ? o[0] : n[n.length - 1][1] + o[l] : (n.push([u, u + o[l]]), u = null);
        r[`stretch_${e}_areas`] = n;
      }
      function JT(r, e, n) {
        r === 1 ? e.name = n.readString() : r === 2 ? e.metadata = function(o, u) {
          return o.readFields(QT, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, u);
        }(n, n.readVarint() + n.pos) : r === 3 && (e.usvg_tree = function(o, u) {
          return o.readFields(i2, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, u);
        }(n, n.readVarint() + n.pos), e.data = "usvg_tree");
      }
      function QT(r, e, n) {
        r === 1 ? e.stretch_x = n.readPackedVarint() : r === 2 ? e.stretch_y = n.readPackedVarint() : r === 3 ? e.content_area = function(o, u) {
          return o.readFields(e2, { left: 0 }, u);
        }(n, n.readVarint() + n.pos) : r === 4 && e.variables.push(function(o, u) {
          return o.readFields(t2, { name: void 0 }, u);
        }(n, n.readVarint() + n.pos));
      }
      function e2(r, e, n) {
        r === 1 ? e.left = n.readVarint() : r === 2 ? e.width = n.readVarint() : r === 3 ? e.top = n.readVarint() : r === 4 && (e.height = n.readVarint());
      }
      function t2(r, e, n) {
        r === 1 ? e.name = n.readString() : r === 2 && (e.rgb_color = tm(n.readVarint()), e.value = "rgb_color");
      }
      function i2(r, e, n) {
        r === 1 ? e.width = e.height = n.readVarint() : r === 2 ? e.height = n.readVarint() : r === 3 ? e.children.push(Qp(n, n.readVarint() + n.pos)) : r === 4 ? e.linear_gradients.push(function(o, u) {
          return o.readFields(c2, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, u);
        }(n, n.readVarint() + n.pos)) : r === 5 ? e.radial_gradients.push(function(o, u) {
          return o.readFields(u2, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, u);
        }(n, n.readVarint() + n.pos)) : r === 7 ? e.clip_paths.push(function(o, u) {
          return o.readFields(d2, { children: [] }, u);
        }(n, n.readVarint() + n.pos)) : r === 8 && e.masks.push(function(o, u) {
          const l = o.readFields(f2, { left: 0, width: 20, mask_type: 1, children: [] }, u);
          return l.height == null && (l.height = l.width), l.top == null && (l.top = l.left), l;
        }(n, n.readVarint() + n.pos));
      }
      function Qp(r, e) {
        return r.readFields(n2, {}, e);
      }
      function n2(r, e, n) {
        r === 1 ? (e.group = function(o, u) {
          return o.readFields(s2, { opacity: 255, children: [] }, u);
        }(n, n.readVarint() + n.pos), e.node = "group") : r === 2 && (e.path = function(o, u) {
          return o.readFields(o2, { paint_order: 1, commands: [], step: 1, diffs: [], rule: 1 }, u);
        }(n, n.readVarint() + n.pos), e.node = "path");
      }
      function s2(r, e, n) {
        r === 1 ? e.transform = em(n, n.readVarint() + n.pos) : r === 2 ? e.opacity = n.readVarint() : r === 5 ? e.clip_path_idx = n.readVarint() : r === 6 ? e.mask_idx = n.readVarint() : r === 7 && e.children.push(Qp(n, n.readVarint() + n.pos));
      }
      function em(r, e) {
        return r.readFields(r2, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e);
      }
      function r2(r, e, n) {
        r === 1 ? e.sx = n.readFloat() : r === 2 ? e.ky = n.readFloat() : r === 3 ? e.kx = n.readFloat() : r === 4 ? e.sy = n.readFloat() : r === 5 ? e.tx = n.readFloat() : r === 6 && (e.ty = n.readFloat());
      }
      function o2(r, e, n) {
        r === 1 ? e.fill = function(o, u) {
          return o.readFields(a2, { rgb_color: tg, paint: "rgb_color", opacity: 255 }, u);
        }(n, n.readVarint() + n.pos) : r === 2 ? e.stroke = function(o, u) {
          return o.readFields(l2, { rgb_color: tg, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, u);
        }(n, n.readVarint() + n.pos) : r === 3 ? e.paint_order = n.readVarint() : r === 5 ? n.readPackedVarint(e.commands) : r === 6 ? e.step = n.readFloat() : r === 7 ? n.readPackedSVarint(e.diffs) : r === 8 && (e.rule = n.readVarint());
      }
      function a2(r, e, n) {
        r === 1 ? (e.rgb_color = tm(n.readVarint()), e.paint = "rgb_color") : r === 2 ? (e.linear_gradient_idx = n.readVarint(), e.paint = "linear_gradient_idx") : r === 3 ? (e.radial_gradient_idx = n.readVarint(), e.paint = "radial_gradient_idx") : r === 5 && (e.opacity = n.readVarint());
      }
      function tm(r) {
        return new ki((r >> 16 & 255) / 255, (r >> 8 & 255) / 255, (255 & r) / 255, 1);
      }
      function l2(r, e, n) {
        r === 1 ? (e.rgb_color = tm(n.readVarint()), e.paint = "rgb_color") : r === 2 ? (e.linear_gradient_idx = n.readVarint(), e.paint = "linear_gradient_idx") : r === 3 ? (e.radial_gradient_idx = n.readVarint(), e.paint = "radial_gradient_idx") : r === 5 ? n.readPackedFloat(e.dasharray) : r === 6 ? e.dashoffset = n.readFloat() : r === 7 ? e.miterlimit = n.readFloat() : r === 8 ? e.opacity = n.readVarint() : r === 9 ? e.width = n.readFloat() : r === 10 ? e.linecap = n.readVarint() : r === 11 && (e.linejoin = n.readVarint());
      }
      function c2(r, e, n) {
        r === 1 ? e.transform = em(n, n.readVarint() + n.pos) : r === 2 ? e.spread_method = n.readVarint() : r === 3 ? e.stops.push(Zx(n, n.readVarint() + n.pos)) : r === 4 ? e.x1 = n.readFloat() : r === 5 ? e.y1 = n.readFloat() : r === 6 ? e.x2 = n.readFloat() : r === 7 && (e.y2 = n.readFloat());
      }
      function Zx(r, e) {
        return r.readFields(h2, { offset: 0, opacity: 255, rgb_color: tg }, e);
      }
      function h2(r, e, n) {
        r === 1 ? e.offset = n.readFloat() : r === 2 ? e.opacity = n.readVarint() : r === 3 && (e.rgb_color = tm(n.readVarint()));
      }
      function u2(r, e, n) {
        r === 1 ? e.transform = em(n, n.readVarint() + n.pos) : r === 2 ? e.spread_method = n.readVarint() : r === 3 ? e.stops.push(Zx(n, n.readVarint() + n.pos)) : r === 4 ? e.cx = n.readFloat() : r === 5 ? e.cy = n.readFloat() : r === 6 ? e.r = n.readFloat() : r === 7 ? e.fx = n.readFloat() : r === 8 ? e.fy = n.readFloat() : r === 9 && (e.fr = n.readFloat());
      }
      function d2(r, e, n) {
        r === 1 ? e.transform = em(n, n.readVarint() + n.pos) : r === 2 ? e.clip_path_idx = n.readVarint() : r === 3 && e.children.push(Qp(n, n.readVarint() + n.pos));
      }
      function f2(r, e, n) {
        r === 1 ? e.left = e.top = n.readFloat() : r === 2 ? e.width = e.height = n.readFloat() : r === 3 ? e.top = n.readFloat() : r === 4 ? e.height = n.readFloat() : r === 5 ? e.mask_type = n.readVarint() : r === 6 ? e.mask_idx = n.readVarint() : r === 7 && e.children.push(Qp(n, n.readVarint() + n.pos));
      }
      class p2 {
        static calculate(e, n) {
          const o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map();
          if (Object.keys(e).length === 0)
            return o;
          n.forEach((l) => {
            u.set(l.name, l.rgb_color || new ki(0, 0, 0));
          });
          for (const [l, d] of Object.entries(e))
            u.has(l) ? o.set(u.get(l).toStringPremultipliedAlpha(), d) : console.warn(`Ignoring unknown image variable "${l}"`);
          return o;
        }
      }
      function Bu(r, e = 255, n) {
        const o = e / 255, u = r.toStringPremultipliedAlpha(), l = n.has(u) ? n.get(u).clone() : r.clone();
        return l.a = o, l.toString();
      }
      function ig(r, e) {
        if (!mt()) {
          const n = document.createElement("canvas");
          return n.width = r, n.height = e, n;
        }
        return new OffscreenCanvas(r, e);
      }
      function m2(r, e) {
        const n = p2.calculate(e.params, r.metadata ? r.metadata.variables : []), o = r.usvg_tree, u = o.width, l = o.height, d = e.transform ? e.transform : new DOMMatrix(), v = Math.max(1, Math.round(u * d.a)), M = Math.max(1, Math.round(l * d.d)), D = new DOMMatrix([v / u, 0, 0, M / l, 0, 0]), x = ig(v, M).getContext("2d");
        return ng(x, D, o, o, n), x.getImageData(0, 0, v, M);
      }
      function ng(r, e, n, o, u) {
        for (const l of o.children)
          Hx(r, e, n, l, u);
      }
      function Hx(r, e, n, o, u) {
        o.group ? (r.save(), function(l, d, v, M, D) {
          const x = M.mask_idx != null ? v.masks[M.mask_idx] : null, E = M.clip_path_idx != null ? v.clip_paths[M.clip_path_idx] : null;
          if (M.transform && (d = af(M.transform).preMultiplySelf(d)), !function(C, k, V) {
            return C.opacity !== 255 || k || V;
          }(M, E != null, x != null))
            return void ng(l, d, v, M, D);
          const I = ig(l.canvas.width, l.canvas.height), S = I.getContext("2d");
          E && Yx(S, d, v, E), ng(S, d, v, M, D), x && Kx(S, d, v, x, D), l.globalAlpha = M.opacity / 255, l.drawImage(I, 0, 0);
        }(r, e, n, o.group, u), r.restore()) : o.path && (r.save(), function(l, d, v, M, D) {
          const x = Jx(M);
          l.setTransform(d), M.paint_order === Ux.PAINT_ORDER_FILL_AND_STROKE ? (qx(l, v, M, x, D), Wx(l, v, M, x, D)) : (Wx(l, v, M, x, D), qx(l, v, M, x, D));
        }(r, e, n, o.path, u), r.restore());
      }
      function qx(r, e, n, o, u) {
        const l = n.fill;
        if (!l)
          return;
        const d = l.opacity / 255;
        switch (l.paint) {
          case "rgb_color":
            r.fillStyle = Bu(l.rgb_color, l.opacity, u);
            break;
          case "linear_gradient_idx":
            r.fillStyle = $x(r, e.linear_gradients[l.linear_gradient_idx], d, u);
            break;
          case "radial_gradient_idx":
            r.fillStyle = Xx(r, e.radial_gradients[l.radial_gradient_idx], d, u);
        }
        let v;
        switch (n.rule) {
          case Kp.PATH_RULE_NON_ZERO:
            v = "nonzero";
            break;
          case Kp.PATH_RULE_EVEN_ODD:
            v = "evenodd";
        }
        r.fill(o, v);
      }
      function Wx(r, e, n, o, u) {
        const l = n.stroke;
        if (!l)
          return;
        r.lineWidth = l.width, r.miterLimit = l.miterlimit, r.setLineDash(l.dasharray), r.lineDashOffset = l.dashoffset;
        const d = l.opacity / 255;
        switch (l.paint) {
          case "rgb_color":
            r.strokeStyle = Bu(l.rgb_color, l.opacity, u);
            break;
          case "linear_gradient_idx":
            r.strokeStyle = $x(r, e.linear_gradients[l.linear_gradient_idx], d, u);
            break;
          case "radial_gradient_idx":
            r.strokeStyle = Xx(r, e.radial_gradients[l.radial_gradient_idx], d, u);
        }
        switch (l.linejoin) {
          case of.LINE_JOIN_MITER_CLIP:
          case of.LINE_JOIN_MITER:
            r.lineJoin = "miter";
            break;
          case of.LINE_JOIN_ROUND:
            r.lineJoin = "round";
            break;
          case of.LINE_JOIN_BEVEL:
            r.lineJoin = "bevel";
        }
        switch (l.linecap) {
          case Jp.LINE_CAP_BUTT:
            r.lineCap = "butt";
            break;
          case Jp.LINE_CAP_ROUND:
            r.lineCap = "round";
            break;
          case Jp.LINE_CAP_SQUARE:
            r.lineCap = "square";
        }
        r.stroke(o);
      }
      function $x(r, e, n, o) {
        if (e.stops.length === 1) {
          const I = e.stops[0];
          return Bu(I.rgb_color, I.opacity * n, o);
        }
        const u = af(e.transform), { x1: l, y1: d, x2: v, y2: M } = e, D = u.transformPoint(new DOMPoint(l, d)), x = u.transformPoint(new DOMPoint(v, M)), E = r.createLinearGradient(D.x, D.y, x.x, x.y);
        for (const I of e.stops)
          E.addColorStop(I.offset, Bu(I.rgb_color, I.opacity * n, o));
        return E;
      }
      function Xx(r, e, n, o) {
        if (e.stops.length === 1) {
          const I = e.stops[0];
          return Bu(I.rgb_color, I.opacity * n, o);
        }
        const u = af(e.transform), { fx: l, fy: d, cx: v, cy: M } = e, D = u.transformPoint(new DOMPoint(l, d)), x = u.transformPoint(new DOMPoint(v, M)), E = r.createRadialGradient(D.x, D.y, 0, x.x, x.y, e.r * ((u.a + u.d) / 2));
        for (const I of e.stops)
          E.addColorStop(I.offset, Bu(I.rgb_color, I.opacity * n, o));
        return E;
      }
      function Yx(r, e, n, o) {
        const u = af(o.transform).preMultiplySelf(e), l = o.clip_path_idx != null ? n.clip_paths[o.clip_path_idx] : null;
        l && Yx(r, u, n, l);
        const d = new Path2D();
        let v;
        function M(D, x) {
          if (D.path) {
            const E = D.path;
            d.addPath(Jx(E), x), E.rule === Kp.PATH_RULE_EVEN_ODD && (v = "evenodd");
          } else if (D.group) {
            const E = D.group.transform ? af(D.group.transform).preMultiplySelf(x) : x;
            for (const I of D.group.children)
              M(I, E);
          }
        }
        for (const D of o.children)
          M(D, u);
        r.clip(d, v);
      }
      function Kx(r, e, n, o, u) {
        if (o.children.length === 0)
          return;
        const l = o.mask_idx != null ? n.masks[o.mask_idx] : null;
        l && Kx(r, e, n, l, u);
        const d = r.canvas.width, v = r.canvas.height, M = ig(d, v), D = M.getContext("2d"), x = o.width, E = o.height, I = o.left, S = o.top, C = new Path2D(), k = new Path2D();
        k.rect(I, S, x, E), C.addPath(k, e), D.clip(C);
        for (const q of o.children)
          Hx(D, e, n, q, u);
        const V = D.getImageData(0, 0, d, v), U = V.data;
        if (o.mask_type === jx.MASK_TYPE_LUMINANCE)
          for (let q = 0; q < U.length; q += 4)
            U[q + 3] = U[q + 3] / 255 * (0.2126 * U[q] + 0.7152 * U[q + 1] + 0.0722 * U[q + 2]);
        D.putImageData(V, 0, 0), r.globalCompositeOperation = "destination-in", r.drawImage(M, 0, 0);
      }
      function af(r) {
        return r ? new DOMMatrix([r.sx, r.ky, r.kx, r.sy, r.tx, r.ty]) : new DOMMatrix();
      }
      function Jx(r) {
        const e = new Path2D(), n = r.step;
        let o = r.diffs[0] * n, u = r.diffs[1] * n;
        e.moveTo(o, u);
        for (let l = 0, d = 2; l < r.commands.length; l++)
          switch (r.commands[l]) {
            case Fu.PATH_COMMAND_MOVE:
              o += r.diffs[d++] * n, u += r.diffs[d++] * n, e.moveTo(o, u);
              break;
            case Fu.PATH_COMMAND_LINE:
              o += r.diffs[d++] * n, u += r.diffs[d++] * n, e.lineTo(o, u);
              break;
            case Fu.PATH_COMMAND_QUAD: {
              const v = o + r.diffs[d++] * n, M = u + r.diffs[d++] * n;
              o = v + r.diffs[d++] * n, u = M + r.diffs[d++] * n, e.quadraticCurveTo(v, M, o, u);
              break;
            }
            case Fu.PATH_COMMAND_CUBIC: {
              const v = o + r.diffs[d++] * n, M = u + r.diffs[d++] * n, D = v + r.diffs[d++] * n, x = M + r.diffs[d++] * n;
              o = D + r.diffs[d++] * n, u = x + r.diffs[d++] * n, e.bezierCurveTo(v, M, D, x, o, u);
              break;
            }
            case Fu.PATH_COMMAND_CLOSE:
              e.closePath();
          }
        return e;
      }
      class sg {
        constructor(e) {
          this.capacity = e, this.cache = /* @__PURE__ */ new Map();
        }
        get(e) {
          if (!this.cache.has(e))
            return;
          const n = this.cache.get(e);
          return this.cache.delete(e), this.cache.set(e, n), n;
        }
        put(e, n) {
          this.cache.has(e) ? this.cache.delete(e) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(e, n);
        }
        delete(e) {
          this.cache.delete(e);
        }
      }
      class rg {
        constructor() {
          this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
        }
        static _getImage(e) {
          return new _r(e, e.data);
        }
        getFromCache(e, n, o) {
          return this.cacheMap.has(o) || this.cacheMap.set(o, new sg(150)), this.cacheMap.get(o).get(Co(e.serialize(), n));
        }
        setInCache(e, n, o, u) {
          this.cacheDependenciesMap.has(u) || this.cacheDependenciesMap.set(u, /* @__PURE__ */ new Map()), this.cacheMap.has(u) || this.cacheMap.set(u, new sg(150));
          const l = this.cacheDependenciesMap.get(u);
          l.get(Co(e.id, o)) || l.set(Co(e.id, o), /* @__PURE__ */ new Set());
          const d = this.cacheMap.get(u), v = e.serialize();
          l.get(Co(e.id, o)).add(v), d.put(Co(e.serialize(), o), n);
        }
        removeImagesFromCacheByIds(e, n, o = "") {
          if (!this.cacheMap.has(o) || !this.cacheDependenciesMap.has(o))
            return;
          const u = this.cacheMap.get(o), l = this.cacheDependenciesMap.get(o);
          for (const d of e)
            if (l.has(Co(d, n))) {
              for (const v of l.get(Co(d, n)))
                u.delete(v);
              l.delete(Co(d, n));
            }
        }
        rasterize(e, n, o, u, l = m2) {
          const d = this.getFromCache(e, o, u);
          if (d)
            return d.clone();
          const v = l(n.icon, e.options), M = rg._getImage(v);
          return this.setInCache(e, M, o, u), M.clone();
        }
      }
      class Qx {
        constructor(e) {
          this.size = e, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(e, n) {
          const o = this.toIdx(e, n);
          return { min: this.minimums[o], max: this.maximums[o] };
        }
        isLeaf(e, n) {
          return this.leaves[this.toIdx(e, n)];
        }
        toIdx(e, n) {
          return n * this.size + e;
        }
      }
      function ev(r, e, n, o) {
        let u = 0, l = Number.MAX_VALUE;
        for (let d = 0; d < 3; d++)
          if (Math.abs(o[d]) < 1e-15) {
            if (n[d] < r[d] || n[d] > e[d])
              return null;
          } else {
            const v = 1 / o[d];
            let M = (r[d] - n[d]) * v, D = (e[d] - n[d]) * v;
            if (M > D) {
              const x = M;
              M = D, D = x;
            }
            if (M > u && (u = M), D < l && (l = D), u > l)
              return null;
          }
        return u;
      }
      function tv(r, e, n, o, u, l, d, v, M, D, x) {
        const E = o - r, I = u - e, S = l - n, C = d - r, k = v - e, V = M - n, U = x[1] * V - x[2] * k, q = x[2] * C - x[0] * V, $ = x[0] * k - x[1] * C, H = E * U + I * q + S * $;
        if (Math.abs(H) < 1e-15)
          return null;
        const K = 1 / H, Q = D[0] - r, ie = D[1] - e, fe = D[2] - n, de = (Q * U + ie * q + fe * $) * K;
        if (de < 0 || de > 1)
          return null;
        const he = ie * S - fe * I, Me = fe * E - Q * S, me = Q * I - ie * E, Ee = (x[0] * he + x[1] * Me + x[2] * me) * K;
        return Ee < 0 || de + Ee > 1 ? null : (C * he + k * Me + V * me) * K;
      }
      function iv(r, e, n) {
        return (r - e) / (n - e);
      }
      function nv(r, e, n, o, u, l, d, v, M) {
        const D = 1 << n, x = l - o, E = d - u, I = (r + 1) / D * x + o, S = (e + 0) / D * E + u, C = (e + 1) / D * E + u;
        v[0] = (r + 0) / D * x + o, v[1] = S, M[0] = I, M[1] = C;
      }
      class sv {
        constructor(e) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = e, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const n = function(l) {
            const d = Math.ceil(Math.log2(l.dim / 8)), v = [];
            let M = Math.ceil(Math.pow(2, d));
            const D = 1 / M, x = (S, C, k, V, U) => {
              const q = V ? 1 : 0, $ = (S + 1) * k - q, H = C * k, K = (C + 1) * k - q;
              U[0] = S * k, U[1] = H, U[2] = $, U[3] = K;
            };
            let E = new Qx(M);
            const I = [];
            for (let S = 0; S < M * M; S++) {
              x(S % M, Math.floor(S / M), D, !1, I);
              const C = bc(I[0], I[1], l), k = bc(I[2], I[1], l), V = bc(I[2], I[3], l), U = bc(I[0], I[3], l);
              E.minimums.push(Math.min(C, k, V, U)), E.maximums.push(Math.max(C, k, V, U)), E.leaves.push(1);
            }
            for (v.push(E), M /= 2; M >= 1; M /= 2) {
              const S = v[v.length - 1];
              E = new Qx(M);
              for (let C = 0; C < M * M; C++) {
                x(C % M, Math.floor(C / M), 2, !0, I);
                const k = S.getElevation(I[0], I[1]), V = S.getElevation(I[2], I[1]), U = S.getElevation(I[2], I[3]), q = S.getElevation(I[0], I[3]), $ = S.isLeaf(I[0], I[1]), H = S.isLeaf(I[2], I[1]), K = S.isLeaf(I[2], I[3]), Q = S.isLeaf(I[0], I[3]), ie = Math.min(k.min, V.min, U.min, q.min), fe = Math.max(k.max, V.max, U.max, q.max), de = $ && H && K && Q;
                E.maximums.push(fe), E.minimums.push(ie), E.leaves.push(fe - ie <= 5 && de ? 1 : 0);
              }
              v.push(E);
            }
            return v;
          }(this.dem), o = n.length - 1, u = n[o];
          this._addNode(u.minimums[0], u.maximums[0], u.leaves[0]), this._construct(n, 0, 0, o, 0);
        }
        raycastRoot(e, n, o, u, l, d, v = 1) {
          return ev([e, n, -100], [o, u, this.maximums[0] * v], l, d);
        }
        raycast(e, n, o, u, l, d, v = 1) {
          if (!this.nodeCount)
            return null;
          const M = this.raycastRoot(e, n, o, u, l, d, v);
          if (M == null)
            return null;
          const D = [], x = [], E = [], I = [], S = [{ idx: 0, t: M, nodex: 0, nodey: 0, depth: 0 }];
          for (; S.length > 0; ) {
            const { idx: C, t: k, nodex: V, nodey: U, depth: q } = S.pop();
            if (this.leaves[C]) {
              nv(V, U, q, e, n, o, u, E, I);
              const H = 1 << q, K = (V + 0) / H, Q = (V + 1) / H, ie = (U + 0) / H, fe = (U + 1) / H, de = bc(K, ie, this.dem) * v, he = bc(Q, ie, this.dem) * v, Me = bc(Q, fe, this.dem) * v, me = bc(K, fe, this.dem) * v, Ee = tv(E[0], E[1], de, I[0], E[1], he, I[0], I[1], Me, l, d), ze = tv(I[0], I[1], Me, E[0], I[1], me, E[0], E[1], de, l, d), Ie = Math.min(Ee !== null ? Ee : Number.MAX_VALUE, ze !== null ? ze : Number.MAX_VALUE);
              if (Ie !== Number.MAX_VALUE)
                return Ie;
              {
                const Re = De.vec3.scaleAndAdd([], l, d, k);
                if (rv(de, he, me, Me, iv(Re[0], E[0], I[0]), iv(Re[1], E[1], I[1])) >= Re[2])
                  return k;
              }
              continue;
            }
            let $ = 0;
            for (let H = 0; H < this._siblingOffset.length; H++) {
              nv((V << 1) + this._siblingOffset[H][0], (U << 1) + this._siblingOffset[H][1], q + 1, e, n, o, u, E, I), E[2] = -100, I[2] = this.maximums[this.childOffsets[C] + H] * v;
              const K = ev(E, I, l, d);
              if (K != null) {
                const Q = K;
                D[H] = Q;
                let ie = !1;
                for (let fe = 0; fe < $ && !ie; fe++)
                  Q >= D[x[fe]] && (x.splice(fe, 0, H), ie = !0);
                ie || (x[$] = H), $++;
              }
            }
            for (let H = 0; H < $; H++) {
              const K = x[H];
              S.push({ idx: this.childOffsets[C] + K, t: D[K], nodex: (V << 1) + this._siblingOffset[K][0], nodey: (U << 1) + this._siblingOffset[K][1], depth: q + 1 });
            }
          }
          return null;
        }
        _addNode(e, n, o) {
          return this.minimums.push(e), this.maximums.push(n), this.leaves.push(o), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(e, n, o, u, l) {
          if (e[u].isLeaf(n, o) === 1)
            return;
          this.childOffsets[l] || (this.childOffsets[l] = this.nodeCount);
          const d = u - 1, v = e[d];
          let M = 0, D = 0;
          for (let x = 0; x < this._siblingOffset.length; x++) {
            const E = 2 * n + this._siblingOffset[x][0], I = 2 * o + this._siblingOffset[x][1], S = v.getElevation(E, I), C = v.isLeaf(E, I), k = this._addNode(S.min, S.max, C);
            C && (M |= 1 << x), D || (D = k);
          }
          for (let x = 0; x < this._siblingOffset.length; x++)
            M & 1 << x || this._construct(e, 2 * n + this._siblingOffset[x][0], 2 * o + this._siblingOffset[x][1], d, D + x);
        }
      }
      function rv(r, e, n, o, u, l) {
        return ei(ei(r, n, l), ei(e, o, l), u);
      }
      function bc(r, e, n) {
        const o = n.dim, u = si(r * o - 0.5, 0, o - 1), l = si(e * o - 0.5, 0, o - 1), d = Math.floor(u), v = Math.floor(l), M = Math.min(d + 1, o - 1), D = Math.min(v + 1, o - 1);
        return rv(n.get(d, v), n.get(M, v), n.get(d, D), n.get(M, D), u - d, l - v);
      }
      const _2 = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function g2(r, e, n) {
        return (256 * r * 256 + 256 * e + n) / 10 - 1e4;
      }
      function y2(r, e, n) {
        return 256 * r + e + n / 256 - 32768;
      }
      class im {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(e, n, o, u = !1) {
          if (this.uid = e, n.height !== n.width)
            throw new RangeError("DEM tiles must be square");
          if (o && o !== "mapbox" && o !== "terrarium")
            return void mi(`"${o}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = n.height;
          const l = this.dim = n.height - 2, d = new Uint32Array(n.data.buffer);
          if (this.pixels = new Uint8Array(n.data.buffer), this.floatView = new Float32Array(n.data.buffer), this.borderReady = u, this._modifiedForSources = {}, !u) {
            for (let M = 0; M < l; M++)
              d[this._idx(-1, M)] = d[this._idx(0, M)], d[this._idx(l, M)] = d[this._idx(l - 1, M)], d[this._idx(M, -1)] = d[this._idx(M, 0)], d[this._idx(M, l)] = d[this._idx(M, l - 1)];
            d[this._idx(-1, -1)] = d[this._idx(0, 0)], d[this._idx(l, -1)] = d[this._idx(l - 1, 0)], d[this._idx(-1, l)] = d[this._idx(0, l - 1)], d[this._idx(l, l)] = d[this._idx(l - 1, l - 1)];
          }
          const v = o === "terrarium" ? y2 : g2;
          for (let M = 0; M < d.length; ++M) {
            const D = 4 * M;
            this.floatView[M] = v(this.pixels[D], this.pixels[D + 1], this.pixels[D + 2]);
          }
          this._timestamp = Ct.now();
        }
        _buildQuadTree() {
          this._tree = new sv(this);
        }
        get(e, n, o = !1) {
          o && (e = si(e, -1, this.dim), n = si(n, -1, this.dim));
          const u = this._idx(e, n);
          return this.floatView[u];
        }
        set(e, n, o) {
          const u = this._idx(e, n), l = this.floatView[u];
          return this.floatView[u] = o, o - l;
        }
        static getUnpackVector(e) {
          return _2[e];
        }
        _idx(e, n) {
          if (e < -1 || e >= this.dim + 1 || n < -1 || n >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (n + 1) * this.stride + (e + 1);
        }
        static pack(e, n) {
          const o = [0, 0, 0, 0], u = im.getUnpackVector(n);
          let l = Math.floor((e + u[3]) / u[2]);
          return o[2] = l % 256, l = Math.floor(l / 256), o[1] = l % 256, l = Math.floor(l / 256), o[0] = l, o;
        }
        getPixels() {
          return new Sy({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(e, n, o) {
          if (this.dim !== e.dim)
            throw new Error("dem dimension mismatch");
          let u = n * this.dim, l = n * this.dim + this.dim, d = o * this.dim, v = o * this.dim + this.dim;
          switch (n) {
            case -1:
              u = l - 1;
              break;
            case 1:
              l = u + 1;
          }
          switch (o) {
            case -1:
              d = v - 1;
              break;
            case 1:
              v = d + 1;
          }
          const M = -n * this.dim, D = -o * this.dim;
          for (let x = d; x < v; x++)
            for (let E = u; E < l; E++) {
              const I = 4 * this._idx(E, x), S = 4 * this._idx(E + M, x + D);
              this.pixels[I + 0] = e.pixels[S + 0], this.pixels[I + 1] = e.pixels[S + 1], this.pixels[I + 2] = e.pixels[S + 2], this.pixels[I + 3] = e.pixels[S + 3];
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      function x2(r, e, n) {
        r === 1 ? e.headerLength = n.readFixed32() : r === 2 ? e.x = n.readVarint() : r === 3 ? e.y = n.readVarint() : r === 4 ? e.z = n.readVarint() : r === 5 && e.layers.push(function(o, u) {
          return o.readFields(S2, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, u);
        }(n, n.readVarint() + n.pos));
      }
      function v2(r, e, n) {
        r === 1 ? (e.delta_filter = function(o, u) {
          return o.readFields(b2, { blockSize: 0 }, u);
        }(n, n.readVarint() + n.pos), e.filter = "delta_filter") : r === 2 ? (n.readVarint(), e.filter = "zigzag_filter") : r === 3 ? (n.readVarint(), e.filter = "bitshuffle_filter") : r === 4 && (n.readVarint(), e.filter = "byteshuffle_filter");
      }
      function b2(r, e, n) {
        r === 1 && (e.blockSize = n.readVarint());
      }
      function w2(r, e, n) {
        r === 1 ? (n.readVarint(), e.codec = "gzip_data") : r === 2 ? (n.readVarint(), e.codec = "jpeg_image") : r === 3 ? (n.readVarint(), e.codec = "webp_image") : r === 4 && (n.readVarint(), e.codec = "png_image");
      }
      function T2(r, e, n) {
        let o = 0, u = 0;
        r === 1 ? e.firstByte = n.readFixed64() : r === 2 ? e.lastByte = n.readFixed64() : r === 3 ? e.filters.push(function(l, d) {
          return l.readFields(v2, {}, d);
        }(n, n.readVarint() + n.pos)) : r === 4 ? e.codec = function(l, d) {
          return l.readFields(w2, {}, d);
        }(n, n.readVarint() + n.pos) : r === 5 ? u = n.readFloat() : r === 6 ? o = n.readFloat() : r === 7 ? e.bands.push(n.readString()) : r === 8 ? e.offset = n.readDouble() : r === 9 && (e.scale = n.readDouble()), e.offset === 0 && (e.offset = u), e.scale === 0 && (e.scale = o);
      }
      function S2(r, e, n) {
        r === 1 ? e.version = n.readVarint() : r === 2 ? e.name = n.readString() : r === 3 ? e.units = n.readString() : r === 4 ? e.tileSize = n.readVarint() : r === 5 ? e.buffer = n.readVarint() : r === 6 ? e.pixelFormat = n.readVarint() : r === 7 && e.dataIndex.push(function(o, u) {
          return o.readFields(T2, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, u);
        }(n, n.readVarint() + n.pos));
      }
      function M2(r, e, n) {
        if (r === 2)
          (function(o, u, l) {
            o.readFields(E2, l, u);
          })(n, n.readVarint() + n.pos, e);
        else if (r === 3)
          throw new Error("Not implemented");
      }
      function E2(r, e, n) {
        if (r === 1) {
          let o = 0;
          const u = n.readVarint() + n.pos;
          for (; n.pos < u; )
            e[o++] = n.readVarint();
        }
      }
      function A2(r, e) {
        if (e.length !== 4)
          throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
        let n = e[3];
        for (let o = 2; o >= 1; o--) {
          const u = o === 1 ? 1 : 0, l = o === 2 ? 1 : 0;
          for (let d = 0; d < e[0]; d++) {
            const v = e[1] * d;
            for (let M = u; M < e[1]; M++) {
              const D = e[2] * (M + v);
              for (let x = l; x < e[2]; x++) {
                const E = e[3] * (x + D);
                for (let I = 0; I < e[3]; I++) {
                  const S = E + I;
                  r[S] += r[S - n];
                }
              }
            }
          }
          n *= e[o];
        }
        return r;
      }
      function P2(r) {
        for (let e = 0, n = r.length; e < n; e++)
          r[e] = r[e] >>> 1 ^ -(1 & r[e]);
        return r;
      }
      function C2(r, e) {
        switch (e) {
          case "uint32":
            return r;
          case "uint16":
            for (let n = 0; n < r.length; n += 2) {
              const o = r[n], u = r[n + 1];
              r[n] = (240 & o) >> 4 | (61440 & o) >> 8 | (240 & u) << 4 | 61440 & u, r[n + 1] = 15 & o | (3840 & o) >> 4 | (15 & u) << 8 | (3840 & u) << 4;
            }
            return r;
          case "uint8":
            for (let n = 0; n < r.length; n += 4) {
              const o = r[n], u = r[n + 1], l = r[n + 2], d = r[n + 3];
              r[n + 0] = (192 & o) >> 6 | (192 & u) >> 4 | (192 & l) >> 2 | 192 & d, r[n + 1] = (48 & o) >> 4 | (48 & u) >> 2 | 48 & l | (48 & d) << 2, r[n + 2] = (12 & o) >> 2 | 12 & u | (12 & l) << 2 | (12 & d) << 4, r[n + 3] = 3 & o | (3 & u) << 2 | (3 & l) << 4 | (3 & d) << 6;
            }
            return r;
          default:
            throw new Error(`Invalid pixel format, "${e}"`);
        }
      }
      Ft(im, "DEMData"), Ft(sv, "DemMinMaxQuadTree", { omit: ["dem"] });
      var Ro = Uint8Array, lf = Uint16Array, I2 = Int32Array, ov = new Ro([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), av = new Ro([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), L2 = new Ro([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), lv = function(r, e) {
        for (var n = new lf(31), o = 0; o < 31; ++o)
          n[o] = e += 1 << r[o - 1];
        var u = new I2(n[30]);
        for (o = 1; o < 30; ++o)
          for (var l = n[o]; l < n[o + 1]; ++l)
            u[l] = l - n[o] << 5 | o;
        return { b: n, r: u };
      }, cv = lv(ov, 2), hv = cv.b, z2 = cv.r;
      hv[28] = 258, z2[258] = 28;
      for (var D2 = lv(av, 0).b, uv = new lf(32768), os = 0; os < 32768; ++os) {
        var Nu = (43690 & os) >> 1 | (21845 & os) << 1;
        uv[os] = ((65280 & (Nu = (61680 & (Nu = (52428 & Nu) >> 2 | (13107 & Nu) << 2)) >> 4 | (3855 & Nu) << 4)) >> 8 | (255 & Nu) << 8) >> 1;
      }
      var cf = function(r, e, n) {
        for (var o = r.length, u = 0, l = new lf(e); u < o; ++u)
          r[u] && ++l[r[u] - 1];
        var d, v = new lf(e);
        for (u = 1; u < e; ++u)
          v[u] = v[u - 1] + l[u - 1] << 1;
        d = new lf(1 << e);
        var M = 15 - e;
        for (u = 0; u < o; ++u)
          if (r[u])
            for (var D = u << 4 | r[u], x = e - r[u], E = v[r[u] - 1]++ << x, I = E | (1 << x) - 1; E <= I; ++E)
              d[uv[E] >> M] = D;
        return d;
      }, hf = new Ro(288);
      for (os = 0; os < 144; ++os)
        hf[os] = 8;
      for (os = 144; os < 256; ++os)
        hf[os] = 9;
      for (os = 256; os < 280; ++os)
        hf[os] = 7;
      for (os = 280; os < 288; ++os)
        hf[os] = 8;
      var dv = new Ro(32);
      for (os = 0; os < 32; ++os)
        dv[os] = 5;
      var k2 = cf(hf, 9), R2 = cf(dv, 5), og = function(r) {
        for (var e = r[0], n = 1; n < r.length; ++n)
          r[n] > e && (e = r[n]);
        return e;
      }, Ea = function(r, e, n) {
        var o = e / 8 | 0;
        return (r[o] | r[o + 1] << 8) >> (7 & e) & n;
      }, ag = function(r, e) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8 | r[n + 2] << 16) >> (7 & e);
      }, O2 = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Aa = function(r, e, n) {
        var o = new Error(e || O2[r]);
        if (o.code = r, Error.captureStackTrace && Error.captureStackTrace(o, Aa), !n)
          throw o;
        return o;
      }, F2 = new Ro(0), B2 = typeof TextDecoder < "u" && new TextDecoder();
      try {
        B2.decode(F2, { stream: !0 });
      } catch {
      }
      const N2 = { gzip_data: "gzip" };
      class ia extends Error {
        constructor(e) {
          super(e), this.name = "MRTError";
        }
      }
      const V2 = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, fv = { uint32: 1, uint16: 2, uint8: 4 }, U2 = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
      let lg;
      class cg {
        constructor(e = 5) {
          this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = e;
        }
        getLayer(e) {
          const n = this.layers[e];
          if (!n)
            throw new ia(`Layer '${e}' not found`);
          return n;
        }
        getHeaderLength(e) {
          const n = new Uint8Array(e), o = new DataView(e);
          if (n[0] !== 13)
            throw new ia("File is not a valid MRT.");
          return o.getUint32(1, !0);
        }
        parseHeader(e) {
          const n = new Uint8Array(e), o = this.getHeaderLength(e);
          if (n.length < o)
            throw new ia(`Expected header with length >= ${o} but got buffer of length ${n.length}`);
          const u = function(l, d) {
            return l.readFields(x2, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
          }(new lg(n.subarray(0, o)));
          if (!isNaN(this.x) && (this.x !== u.x || this.y !== u.y || this.z !== u.z))
            throw new ia(`Invalid attempt to parse header ${u.z}/${u.x}/${u.y} for tile ${this.z}/${this.x}/${this.y}`);
          this.x = u.x, this.y = u.y, this.z = u.z;
          for (const l of u.layers)
            this.layers[l.name] = new j2(l, { cacheSize: this._cacheSize });
          return this;
        }
        createDecodingTask(e) {
          const n = [], o = this.getLayer(e.layerName);
          for (let u of e.blockIndices) {
            const l = o.dataIndex[u], d = l.firstByte - e.firstByte, v = l.lastByte - e.firstByte;
            if (o._blocksInProgress.has(u))
              continue;
            const M = { layerName: o.name, firstByte: d, lastByte: v, pixelFormat: o.pixelFormat, blockIndex: u, blockShape: [l.bands.length].concat(o.bandShape), buffer: o.buffer, codec: l.codec.codec, filters: l.filters.map((D) => D.filter) };
            o._blocksInProgress.add(u), n.push(M);
          }
          return new pv(n, () => {
            n.forEach((u) => o._blocksInProgress.delete(u.blockIndex));
          }, (u, l) => {
            if (n.forEach((d) => o._blocksInProgress.delete(d.blockIndex)), u)
              throw u;
            l.forEach((d) => {
              this.getLayer(d.layerName).processDecodedData(d);
            });
          });
        }
      }
      class j2 {
        constructor({ version: e, name: n, units: o, tileSize: u, pixelFormat: l, buffer: d, dataIndex: v }, M) {
          if (this.version = e, this.version !== 1)
            throw new ia(`Cannot parse raster layer encoded with MRT version ${e}`);
          this.name = n, this.units = o, this.tileSize = u, this.buffer = d, this.pixelFormat = V2[l], this.dataIndex = v, this.bandShape = [u + 2 * d, u + 2 * d, fv[this.pixelFormat]], this._decodedBlocks = new sg(M ? M.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
        }
        get dimension() {
          return fv[this.pixelFormat];
        }
        get cacheSize() {
          return this._decodedBlocks.capacity;
        }
        getBandList() {
          return this.dataIndex.map(({ bands: e }) => e).flat();
        }
        processDecodedData(e) {
          const n = e.blockIndex.toString();
          this._decodedBlocks.get(n) || this._decodedBlocks.put(n, e.data);
        }
        getBlockForBand(e) {
          let n = 0;
          switch (typeof e) {
            case "string":
              for (const [o, u] of this.dataIndex.entries()) {
                for (const [l, d] of u.bands.entries())
                  if (d === e)
                    return { bandIndex: n + l, blockIndex: o, blockBandIndex: l };
                n += u.bands.length;
              }
              break;
            case "number":
              for (const [o, u] of this.dataIndex.entries()) {
                if (e >= n && e < n + u.bands.length)
                  return { bandIndex: e, blockIndex: o, blockBandIndex: e - n };
                n += u.bands.length;
              }
              break;
            default:
              throw new ia(`Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`);
          }
          throw new ia(`Band not found: ${JSON.stringify(e)}`);
        }
        getDataRange(e) {
          let n = 1 / 0, o = -1 / 0;
          const u = [], l = /* @__PURE__ */ new Set();
          for (const d of e) {
            const { blockIndex: v } = this.getBlockForBand(d);
            if (v < 0)
              throw new ia(`Invalid band: ${JSON.stringify(d)}`);
            const M = this.dataIndex[v];
            u.includes(v) || u.push(v), l.add(v), n = Math.min(n, M.firstByte), o = Math.max(o, M.lastByte);
          }
          if (l.size > this.cacheSize)
            throw new ia(`Number of blocks to decode (${l.size}) exceeds cache size (${this.cacheSize}).`);
          return { layerName: this.name, firstByte: n, lastByte: o, blockIndices: u };
        }
        hasBand(e) {
          const { blockIndex: n } = this.getBlockForBand(e);
          return n >= 0;
        }
        hasDataForBand(e) {
          const { blockIndex: n } = this.getBlockForBand(e);
          return n >= 0 && !!this._decodedBlocks.get(n.toString());
        }
        getBandView(e) {
          const { blockIndex: n, blockBandIndex: o } = this.getBlockForBand(e), u = this._decodedBlocks.get(n.toString());
          if (!u)
            throw new ia(`Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`);
          const l = this.dataIndex[n], d = this.bandShape.reduce((D, x) => D * x, 1), v = o * d, M = u.subarray(v, v + d);
          return { data: M, bytes: new Uint8Array(M.buffer).subarray(M.byteOffset, M.byteOffset + M.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: l.offset, scale: l.scale };
        }
      }
      cg.setPbf = function(r) {
        lg = r;
      };
      class pv {
        constructor(e, n, o) {
          this.tasks = e, this._onCancel = n, this._onComplete = o, this._finalized = !1;
        }
        cancel() {
          this._finalized || (this._onCancel(), this._finalized = !0);
        }
        complete(e, n) {
          this._finalized || (this._onComplete(e, n), this._finalized = !0);
        }
      }
      cg.performDecoding = function(r, e) {
        const n = new Uint8Array(r);
        return Promise.all(e.tasks.map((o) => {
          const { layerName: u, firstByte: l, lastByte: d, pixelFormat: v, blockShape: M, blockIndex: D, filters: x, codec: E } = o, I = n.subarray(l, d + 1), S = new Uint32Array(M[0] * M[1] * M[2]);
          let C;
          if (E !== "gzip_data")
            throw new ia(`Unhandled codec: ${E}`);
          return C = function(k, V) {
            if (!globalThis.DecompressionStream && V === "gzip_data")
              return Promise.resolve(((H = function(ie) {
                ie[0] == 31 && ie[1] == 139 && ie[2] == 8 || Aa(6, "invalid gzip data");
                var fe = ie[3], de = 10;
                4 & fe && (de += 2 + (ie[10] | ie[11] << 8));
                for (var he = (fe >> 3 & 1) + (fe >> 4 & 1); he > 0; he -= !ie[de++])
                  ;
                return de + (2 & fe);
              }($ = k)) + 8 > $.length && Aa(6, "invalid gzip data"), function(ie, fe, de, he) {
                var Me = ie.length;
                if (!Me || fe.f && !fe.l)
                  return de || new Ro(0);
                var me = !de, Ee = me || fe.i != 2, ze = fe.i;
                me && (de = new Ro(3 * Me));
                var Ie, Re, Ve = function(Ll) {
                  var Sc = de.length;
                  if (Ll > Sc) {
                    var Mc = new Ro(Math.max(2 * Sc, Ll));
                    Mc.set(de), de = Mc;
                  }
                }, Ue = fe.f || 0, Fe = fe.p || 0, et = fe.b || 0, dt = fe.l, tt = fe.d, Tt = fe.m, vt = fe.n, Pt = 8 * Me;
                do {
                  if (!dt) {
                    Ue = Ea(ie, Fe, 1);
                    var rt = Ea(ie, Fe + 1, 3);
                    if (Fe += 3, !rt) {
                      var Ut = ie[(hi = 4 + ((Fe + 7) / 8 | 0)) - 4] | ie[hi - 3] << 8, St = hi + Ut;
                      if (St > Me) {
                        ze && Aa(0);
                        break;
                      }
                      Ee && Ve(et + Ut), de.set(ie.subarray(hi, St), et), fe.b = et += Ut, fe.p = Fe = 8 * St, fe.f = Ue;
                      continue;
                    }
                    if (rt == 1)
                      dt = k2, tt = R2, Tt = 9, vt = 5;
                    else if (rt == 2) {
                      var Nt = Ea(ie, Fe, 31) + 257, Qt = Ea(ie, Fe + 10, 15) + 4, pi = Nt + Ea(ie, Fe + 5, 31) + 1;
                      Fe += 14;
                      for (var gi = new Ro(pi), Pi = new Ro(19), yi = 0; yi < Qt; ++yi)
                        Pi[L2[yi]] = Ea(ie, Fe + 3 * yi, 7);
                      Fe += 3 * Qt;
                      var Ii = og(Pi), fn = (1 << Ii) - 1, rn = cf(Pi, Ii);
                      for (yi = 0; yi < pi; ) {
                        var hi, on = rn[Ea(ie, Fe, fn)];
                        if (Fe += 15 & on, (hi = on >> 4) < 16)
                          gi[yi++] = hi;
                        else {
                          var Qi = 0, pn = 0;
                          for (hi == 16 ? (pn = 3 + Ea(ie, Fe, 3), Fe += 2, Qi = gi[yi - 1]) : hi == 17 ? (pn = 3 + Ea(ie, Fe, 7), Fe += 3) : hi == 18 && (pn = 11 + Ea(ie, Fe, 127), Fe += 7); pn--; )
                            gi[yi++] = Qi;
                        }
                      }
                      var as = gi.subarray(0, Nt), ls = gi.subarray(Nt);
                      Tt = og(as), vt = og(ls), dt = cf(as, Tt), tt = cf(ls, vt);
                    } else
                      Aa(1);
                    if (Fe > Pt) {
                      ze && Aa(0);
                      break;
                    }
                  }
                  Ee && Ve(et + 131072);
                  for (var Kn = (1 << Tt) - 1, Vr = (1 << vt) - 1, Mn = Fe; ; Mn = Fe) {
                    var Ln = (Qi = dt[ag(ie, Fe) & Kn]) >> 4;
                    if ((Fe += 15 & Qi) > Pt) {
                      ze && Aa(0);
                      break;
                    }
                    if (Qi || Aa(2), Ln < 256)
                      de[et++] = Ln;
                    else {
                      if (Ln == 256) {
                        Mn = Fe, dt = null;
                        break;
                      }
                      var Tr = Ln - 254;
                      Ln > 264 && (Tr = Ea(ie, Fe, (1 << (Ss = ov[yi = Ln - 257])) - 1) + hv[yi], Fe += Ss);
                      var cs = tt[ag(ie, Fe) & Vr], to = cs >> 4;
                      if (cs || Aa(3), Fe += 15 & cs, ls = D2[to], to > 3) {
                        var Ss = av[to];
                        ls += ag(ie, Fe) & (1 << Ss) - 1, Fe += Ss;
                      }
                      if (Fe > Pt) {
                        ze && Aa(0);
                        break;
                      }
                      Ee && Ve(et + 131072);
                      var il = et + Tr;
                      if (et < ls) {
                        var wc = 0 - ls, Tc = Math.min(ls, il);
                        for (wc + et < 0 && Aa(3); et < Tc; ++et)
                          de[et] = (void 0)[wc + et];
                      }
                      for (; et < il; ++et)
                        de[et] = de[et - ls];
                    }
                  }
                  fe.l = dt, fe.p = Mn, fe.b = et, fe.f = Ue, dt && (Ue = 1, fe.m = Tt, fe.d = tt, fe.n = vt);
                } while (!Ue);
                return et != de.length && me ? (Ie = de, ((Re = et) == null || Re > Ie.length) && (Re = Ie.length), new Ro(Ie.subarray(0, Re))) : de.subarray(0, et);
              }($.subarray(H, -8), { i: 2 }, new Ro(((U = $)[(q = U.length) - 4] | U[q - 3] << 8 | U[q - 2] << 16 | U[q - 1] << 24) >>> 0))));
            var U, q, $, H;
            const K = N2[V];
            if (!K)
              throw new Error(`Unhandled codec: ${V}`);
            const Q = new globalThis.DecompressionStream(K);
            return new Response(new Blob([k]).stream().pipeThrough(Q)).arrayBuffer().then((ie) => new Uint8Array(ie));
          }(I, E).then((k) => (function(V, U) {
            V.readFields(M2, U);
          }(new lg(k), S), new U2[v](S.buffer))), C.then((k) => {
            for (let V = x.length - 1; V >= 0; V--)
              switch (x[V]) {
                case "delta_filter":
                  A2(k, M);
                  break;
                case "zigzag_filter":
                  P2(k);
                  break;
                case "bitshuffle_filter":
                  C2(k, v);
                  break;
                default:
                  throw new ia(`Unhandled filter "${x[V]}"`);
              }
            return { layerName: u, blockIndex: D, data: k };
          }).catch((k) => {
            throw k;
          });
        }));
      }, Ft(pv, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] });
      let uf, hg, Pa, Vu, ug, Uu = null;
      function mv() {
        return Jn() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : hg || ge.DRACO_URL;
      }
      function _v() {
        if (Jn() && self.worker && self.worker.meshoptUrl)
          return self.worker.meshoptUrl;
        if (Vu)
          return Vu;
        const r = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
        if (typeof WebAssembly != "object")
          throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
        return Vu = WebAssembly.validate(r) ? ge.MESHOPT_SIMD_URL : ge.MESHOPT_URL, Vu;
      }
      const nm = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, G2 = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, df = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function gv(r, e, n) {
        const o = n.json.bufferViews.length, u = n.buffers.length;
        e.bufferView = o, n.json.bufferViews[o] = { buffer: u, byteLength: r.byteLength }, n.buffers[u] = r;
      }
      const dg = "KHR_draco_mesh_compression";
      function Z2(r, e) {
        const n = r.extensions && r.extensions[dg];
        if (!n)
          return;
        const o = new Pa.Decoder(), u = bv(e, n.bufferView), l = new Pa.Mesh();
        if (!o.DecodeArrayToMesh(u, u.byteLength, l))
          throw new Error("Failed to decode Draco mesh");
        const d = e.json.accessors[r.indices], v = nm[d.componentType], M = d.count * v.BYTES_PER_ELEMENT, D = Pa._malloc(M);
        v === Uint16Array ? o.GetTrianglesUInt16Array(l, M, D) : o.GetTrianglesUInt32Array(l, M, D), gv(Pa.memory.buffer.slice(D, D + M), d, e), Pa._free(D);
        for (const x of Object.keys(n.attributes)) {
          const E = o.GetAttributeByUniqueId(l, n.attributes[x]), I = e.json.accessors[r.attributes[x]], S = G2[I.componentType], C = I.count * df[I.type] * nm[I.componentType].BYTES_PER_ELEMENT, k = Pa._malloc(C);
          o.GetAttributeDataArrayForAllPoints(l, E, Pa[S], C, k), gv(Pa.memory.buffer.slice(k, k + C), I, e), Pa._free(k);
        }
        o.destroy(), l.destroy(), delete r.extensions[dg];
      }
      const sm = "EXT_meshopt_compression";
      function H2(r, e) {
        if (!r.extensions || !r.extensions[sm])
          return;
        const n = r.extensions[sm], o = new Uint8Array(e.buffers[n.buffer], n.byteOffset || 0, n.byteLength || 0), u = new Uint8Array(n.count * n.byteStride);
        ug.decodeGltfBuffer(u, n.count, n.byteStride, o, n.mode, n.filter), r.buffer = e.buffers.length, r.byteOffset = 0, e.buffers[r.buffer] = u.buffer, delete r.extensions[sm];
      }
      const yv = 1179937895, xv = new TextDecoder("utf8");
      function vv(r, e) {
        return new URL(r, e).href;
      }
      function q2(r, e, n, o) {
        return fetch(vv(r.uri, o)).then((u) => u.arrayBuffer()).then((u) => {
          e.buffers[n] = u;
        });
      }
      function bv(r, e) {
        const n = r.json.bufferViews[e];
        return new Uint8Array(r.buffers[n.buffer], n.byteOffset || 0, n.byteLength);
      }
      function W2(r, e, n, o) {
        if (r.uri) {
          const u = vv(r.uri, o);
          return fetch(u).then((l) => l.blob()).then((l) => createImageBitmap(l)).then((l) => {
            e.images[n] = l;
          });
        }
        if (r.bufferView !== void 0) {
          const u = bv(e, r.bufferView), l = new Blob([u], { type: r.mimeType });
          return createImageBitmap(l).then((d) => {
            e.images[n] = d;
          });
        }
      }
      function wv(r, e = 0, n) {
        const o = { json: null, images: [], buffers: [] };
        if (new Uint32Array(r, e, 1)[0] === yv) {
          const x = new Uint32Array(r, e);
          let E = 2;
          const I = (x[E++] >> 2) - 3, S = x[E++] >> 2;
          if (E++, o.json = JSON.parse(xv.decode(x.subarray(E, E + S))), E += S, E < I) {
            const C = x[E++];
            E++;
            const k = e + (E << 2);
            o.buffers[0] = r.slice(k, k + C);
          }
        } else
          o.json = JSON.parse(xv.decode(new Uint8Array(r, e)));
        const { buffers: u, images: l, meshes: d, extensionsUsed: v, bufferViews: M } = o.json;
        let D = Promise.resolve();
        if (u) {
          const x = [];
          for (let E = 0; E < u.length; E++) {
            const I = u[E];
            I.uri ? x.push(q2(I, o, E, n)) : o.buffers[E] || (o.buffers[E] = null);
          }
          D = Promise.all(x);
        }
        return D.then(() => {
          const x = [], E = v && v.includes(dg), I = v && v.includes(sm);
          if (E && x.push(function() {
            if (!Pa)
              return uf ?? (uf = function(S) {
                let C, k = null;
                function V() {
                  C = new Uint8Array(k.buffer);
                }
                function U() {
                  throw new Error("Unexpected Draco error.");
                }
                const q = { a: { a: U, d: function($, H, K) {
                  return C.copyWithin($, H, H + K);
                }, c: function($) {
                  const H = C.length, K = Math.max($ >>> 0, Math.ceil(1.2 * H)), Q = Math.ceil((K - H) / 65536);
                  try {
                    return k.grow(Q), V(), !0;
                  } catch {
                    return !1;
                  }
                }, b: U } };
                return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(S, q) : S.then(($) => $.arrayBuffer()).then(($) => WebAssembly.instantiate($, q))).then(($) => {
                  const { Rb: H, Qb: K, P: Q, T: ie, X: fe, Ja: de, La: he, Qa: Me, Va: me, Wa: Ee, eb: ze, jb: Ie, f: Re, e: Ve, yb: Ue, zb: Fe, Ab: et, Bb: dt, Db: tt, Gb: Tt } = $.instance.exports;
                  k = Ve;
                  const vt = (() => {
                    let Pt = 0, rt = 0, Ut = 0, St = 0;
                    return (Nt) => {
                      Ut && (H(St), H(Pt), rt += Ut, Ut = Pt = 0), Pt || (rt += 128, Pt = K(rt));
                      const Qt = Nt.length + 7 & -8;
                      let pi = Pt;
                      Qt >= rt && (Ut = Qt, pi = St = K(Qt));
                      for (let gi = 0; gi < Nt.length; gi++)
                        C[pi + gi] = Nt[gi];
                      return pi;
                    };
                  })();
                  return V(), Re(), { memory: Ve, _free: H, _malloc: K, Mesh: class {
                    constructor() {
                      this.ptr = Q();
                    }
                    destroy() {
                      ie(this.ptr);
                    }
                  }, Decoder: class {
                    constructor() {
                      this.ptr = de();
                    }
                    destroy() {
                      Ie(this.ptr);
                    }
                    DecodeArrayToMesh(Pt, rt, Ut) {
                      const St = vt(Pt), Nt = he(this.ptr, St, rt, Ut.ptr);
                      return !!fe(Nt);
                    }
                    GetAttributeByUniqueId(Pt, rt) {
                      return { ptr: Me(this.ptr, Pt.ptr, rt) };
                    }
                    GetTrianglesUInt16Array(Pt, rt, Ut) {
                      me(this.ptr, Pt.ptr, rt, Ut);
                    }
                    GetTrianglesUInt32Array(Pt, rt, Ut) {
                      Ee(this.ptr, Pt.ptr, rt, Ut);
                    }
                    GetAttributeDataArrayForAllPoints(Pt, rt, Ut, St, Nt) {
                      ze(this.ptr, Pt.ptr, rt.ptr, Ut, St, Nt);
                    }
                  }, DT_INT8: Ue(), DT_UINT8: Fe(), DT_INT16: et(), DT_UINT16: dt(), DT_UINT32: tt(), DT_FLOAT32: Tt() };
                });
              }(fetch(mv())), uf.then((S) => {
                Pa = S, uf = void 0;
              }));
          }()), I && x.push(function() {
            if (ug)
              return;
            const S = function(C) {
              let k;
              const V = WebAssembly.instantiateStreaming(C, {}).then(($) => {
                k = $.instance, k.exports.__wasm_call_ctors();
              }), U = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, q = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
              return { ready: V, supported: !0, decodeGltfBuffer($, H, K, Q, ie, fe) {
                (function(de, he, Me, me, Ee, ze, Ie) {
                  const Re = de.exports.sbrk, Ve = me + 3 & -4, Ue = Re(Ve * Ee), Fe = Re(ze.length), et = new Uint8Array(de.exports.memory.buffer);
                  et.set(ze, Fe);
                  const dt = he(Ue, me, Ee, Fe, ze.length);
                  if (dt === 0 && Ie && Ie(Ue, Ve, Ee), Me.set(et.subarray(Ue, Ue + me * Ee)), Re(Ue - Re(0)), dt !== 0)
                    throw new Error(`Malformed buffer data: ${dt}`);
                })(k, k.exports[q[ie]], $, H, K, Q, k.exports[U[fe]]);
              } };
            }(fetch(_v()));
            return S.ready.then(() => {
              ug = S;
            });
          }()), l)
            for (let S = 0; S < l.length; S++)
              x.push(W2(l[S], o, S, n));
          return (x.length ? Promise.all(x) : Promise.resolve()).then(() => {
            if (E && d)
              for (const { primitives: S } of d)
                for (const C of S)
                  Z2(C, o);
            if (I && d && M)
              for (const S of M)
                H2(S, o);
            return o;
          });
        });
      }
      function bh(r, e) {
        const n = r.json.bufferViews[e.bufferView], o = nm[e.componentType];
        return new o(r.buffers[n.buffer], (e.byteOffset || 0) + (n.byteOffset || 0), e.count * (n.byteStride && n.byteStride !== df[e.type] * o.BYTES_PER_ELEMENT ? n.byteStride / o.BYTES_PER_ELEMENT : df[e.type]));
      }
      function fg(r, e, n, o) {
        const u = nm[e.componentType], l = function(x) {
          switch (x) {
            case Int8Array:
              return 1 / 127;
            case Uint8Array:
              return 1 / 255;
            case Int16Array:
              return 1 / 32767;
            case Uint16Array:
              return 1 / 65535;
            default:
              return 1;
          }
        }(u), d = r.json.bufferViews[e.bufferView], v = d.byteStride ? d.byteStride / u.BYTES_PER_ELEMENT : df[e.type], M = n.float32, D = M.length / n.capacity;
        for (let x = 0, E = 0; x < e.count * v; x += v, E += D)
          for (let I = 0; I < D; I++)
            M[E + I] = o[x + I] * l;
        n._trim();
      }
      function $2(r, e, n) {
        const o = r.indices, u = r.attributes, l = {};
        l.indexArray = new qs();
        const d = e.json.accessors[o], v = d.count / 3;
        l.indexArray.reserve(v);
        const M = bh(e, d);
        for (let I = 0; I < v; I++)
          l.indexArray.emplaceBack(M[3 * I], M[3 * I + 1], M[3 * I + 2]);
        l.indexArray._trim(), l.vertexArray = new xa();
        const D = e.json.accessors[u.POSITION];
        l.vertexArray.reserve(D.count);
        const x = bh(e, D);
        for (let I = 0; I < D.count; I++)
          l.vertexArray.emplaceBack(x[3 * I], x[3 * I + 1], x[3 * I + 2]);
        if (l.vertexArray._trim(), l.aabb = new Jt(D.min, D.max), l.centroid = function(I, S) {
          const C = [0, 0, 0], k = I.length;
          if (k > 0) {
            for (let V = 0; V < k; V++) {
              const U = 3 * I[V];
              C[0] += S[U], C[1] += S[U + 1], C[2] += S[U + 2];
            }
            C[0] /= k, C[1] /= k, C[2] /= k;
          }
          return C;
        }(M, x), u.COLOR_0 !== void 0) {
          const I = e.json.accessors[u.COLOR_0], S = df[I.type], C = bh(e, I);
          l.colorArray = S === 3 ? new xa() : new Wa(), l.colorArray.resize(I.count), fg(e, I, l.colorArray, C);
        }
        if (u.NORMAL !== void 0) {
          l.normalArray = new xa();
          const I = e.json.accessors[u.NORMAL];
          l.normalArray.resize(I.count);
          const S = bh(e, I);
          fg(e, I, l.normalArray, S);
        }
        if (u.TEXCOORD_0 !== void 0 && n.length > 0) {
          l.texcoordArray = new Ml();
          const I = e.json.accessors[u.TEXCOORD_0];
          l.texcoordArray.resize(I.count);
          const S = bh(e, I);
          fg(e, I, l.texcoordArray, S);
        }
        if (u._FEATURE_ID_RGBA4444 !== void 0) {
          const I = e.json.accessors[u._FEATURE_ID_RGBA4444];
          e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (l.featureData = bh(e, I));
        }
        u._FEATURE_RGBA4444 !== void 0 && (l.featureData = new Uint32Array(bh(e, e.json.accessors[u._FEATURE_RGBA4444]).buffer));
        const E = r.material;
        return l.material = function(I, S) {
          const { emissiveFactor: C = [0, 0, 0], alphaMode: k = "OPAQUE", alphaCutoff: V = 0.5, normalTexture: U, occlusionTexture: q, emissiveTexture: $, doubleSided: H } = I, { baseColorFactor: K = [1, 1, 1, 1], metallicFactor: Q = 1, roughnessFactor: ie = 1, baseColorTexture: fe, metallicRoughnessTexture: de } = I.pbrMetallicRoughness || {}, he = q ? S[q.index] : void 0;
          if (q && q.extensions && q.extensions.KHR_texture_transform && he) {
            const Me = q.extensions.KHR_texture_transform;
            he.offsetScale = [Me.offset[0], Me.offset[1], Me.scale[0], Me.scale[1]];
          }
          return { pbrMetallicRoughness: { baseColorFactor: new ki(...K), metallicFactor: Q, roughnessFactor: ie, baseColorTexture: fe ? S[fe.index] : void 0, metallicRoughnessTexture: de ? S[de.index] : void 0 }, doubleSided: H, emissiveFactor: C, alphaMode: k, alphaCutoff: V, normalTexture: U ? S[U.index] : void 0, occlusionTexture: he, emissionTexture: $ ? S[$.index] : void 0, defined: I.defined === void 0 };
        }(E !== void 0 ? e.json.materials[E] : { defined: !1 }, n), l;
      }
      function Tv(r, e, n) {
        const { matrix: o, rotation: u, translation: l, scale: d, mesh: v, extras: M, children: D } = r, x = {};
        if (x.matrix = o || De.mat4.fromRotationTranslationScale([], u || [0, 0, 0, 1], l || [0, 0, 0], d || [1, 1, 1]), v !== void 0) {
          x.meshes = n[v];
          const E = x.anchor = [0, 0];
          for (const I of x.meshes) {
            const { min: S, max: C } = I.aabb;
            E[0] += S[0] + C[0], E[1] += S[1] + C[1];
          }
          E[0] = Math.floor(E[0] / x.meshes.length / 2), E[1] = Math.floor(E[1] / x.meshes.length / 2);
        }
        if (M && (M.id && (x.id = M.id), M.lights && (x.lights = function(E) {
          if (!E.length)
            return [];
          const I = function(U) {
            const q = atob(U), $ = new Uint8Array(q.length);
            for (let H = 0; H < q.length; H++)
              $[H] = q.codePointAt(H);
            return $;
          }(E), S = [], C = I.length / 24, k = new Uint16Array(I.buffer), V = new Float32Array(I.buffer);
          for (let U = 0; U < C; U++) {
            const q = k[2 * U * 6] / 30, $ = k[2 * U * 6 + 1] / 30, H = k[2 * U * 6 + 10] / 100, K = V[6 * U + 1], Q = V[6 * U + 2], ie = V[6 * U + 3], fe = V[6 * U + 4], de = ie - K, he = fe - Q, Me = Math.hypot(de, he);
            S.push({ pos: [K + 0.5 * de, Q + 0.5 * he, $], normal: [he / Me, -de / Me, 0], width: Me, height: q, depth: H, points: [K, Q, ie, fe] });
          }
          return S;
        }(M.lights))), D) {
          const E = [];
          for (const I of D)
            E.push(Tv(e.json.nodes[I], e, n));
          x.children = E;
        }
        return x;
      }
      function X2(r) {
        if (r.vertices.length === 0 || r.indices.length === 0)
          return null;
        const e = new m_(r.vertices, r.indices, 8, 256), [n, o] = [e.min.clone(), e.max.clone()];
        return { vertices: r.vertices, indices: r.indices, grid: e, min: n, max: o };
      }
      function Y2(r) {
        if (!r.extras || !r.extras.ground)
          return null;
        const e = r.extras.ground;
        if (!e || !Array.isArray(e) || e.length === 0)
          return null;
        const n = e[0];
        if (!n || !Array.isArray(n) || n.length === 0)
          return null;
        const o = [];
        for (const d of n) {
          if (!Array.isArray(d) || d.length !== 2)
            continue;
          const v = d[0], M = d[1];
          typeof v == "number" && typeof M == "number" && o.push(new Mt(v, M));
        }
        if (o.length < 3)
          return null;
        o.length > 1 && o[o.length - 1].equals(o[0]) && o.pop();
        let u = 0;
        for (let d = 0; d < o.length; d++) {
          const v = o[d], M = o[(d + 1) % o.length], D = o[(d + 2) % o.length];
          u += (v.x - M.x) * (D.y - M.y) - (D.x - M.x) * (v.y - M.y);
        }
        u > 0 && o.reverse();
        const l = Od(o.flatMap((d) => [d.x, d.y]), []);
        return l.length === 0 ? null : { vertices: o, indices: l };
      }
      function K2(r, e) {
        const n = [], o = [];
        let u = 0;
        const l = [];
        for (const d of r) {
          u = n.length;
          const v = d.vertexArray.float32, M = d.indexArray.uint16;
          for (let D = 0; D < d.vertexArray.length; D++)
            l[0] = v[3 * D + 0], l[1] = v[3 * D + 1], l[2] = v[3 * D + 2], De.vec3.transformMat4(l, l, e), n.push(new Mt(l[0], l[1]));
          for (let D = 0; D < 3 * d.indexArray.length; D++)
            o.push(M[D] + u);
        }
        if (o.length % 3 != 0)
          return null;
        for (let d = 0; d < o.length; d += 3) {
          const v = n[o[d + 0]], M = n[o[d + 1]], D = n[o[d + 2]];
          (v.x - M.x) * (D.y - M.y) - (D.x - M.x) * (v.y - M.y) > 0 && ([o[d + 1], o[d + 2]] = [o[d + 2], o[d + 1]]);
        }
        return { vertices: n, indices: o };
      }
      function Sv(r) {
        const e = function(M, D) {
          const x = [], E = WebGL2RenderingContext;
          if (M.json.textures)
            for (const I of M.json.textures) {
              const S = { magFilter: E.LINEAR, minFilter: E.NEAREST, wrapS: E.REPEAT, wrapT: E.REPEAT };
              I.sampler !== void 0 && Object.assign(S, M.json.samplers[I.sampler]), x.push({ image: D[I.source], sampler: S, uploaded: !1 });
            }
          return x;
        }(r, r.images), n = function(M, D) {
          const x = [];
          for (const E of M.json.meshes) {
            const I = [];
            for (const S of E.primitives)
              I.push($2(S, M, D));
            x.push(I);
          }
          return x;
        }(r, e), { scenes: o, scene: u, nodes: l } = r.json, d = o ? o[u || 0].nodes : l, v = [];
        for (const M of d)
          v.push(Tv(l[M], r, n));
        return function(M, D, x) {
          const E = {}, I = /* @__PURE__ */ new Set();
          for (let S = 0; S < M.length; S++) {
            const C = x[D[S]];
            if (!C.extras)
              continue;
            const k = C.extras["mapbox:footprint:version"], V = C.extras["mapbox:footprint:id"];
            (k || V) && I.add(S), k === "1.0.0" && V && (E[V] = S);
          }
          for (let S = 0; S < M.length; S++) {
            if (I.has(S))
              continue;
            const C = M[S], k = x[D[S]];
            if (!k.extras)
              continue;
            let V = null;
            C.id in E && (V = K2(M[E[C.id]].meshes, C.matrix)), V || (V = Y2(k)), V && (C.footprint = X2(V));
          }
          if (I.size > 0) {
            const S = Array.from(I.values()).sort((C, k) => C - k);
            for (let C = S.length - 1; C >= 0; C--)
              M.splice(S[C], 1);
          }
        }(v, d, r.json.nodes), v;
      }
      function J2(r) {
        r.heightmap = new Float32Array(4096), r.heightmap.fill(-1);
        const e = r.vertexArray.float32, n = r.aabb.min[0] - 1, o = r.aabb.min[1] - 1, u = yh / (r.aabb.max[0] - n + 2), l = yh / (r.aabb.max[1] - o + 2);
        for (let d = 0; d < e.length; d += 3) {
          const v = e[d + 2], M = (e[d + 0] - n) * u | 0, D = (e[d + 1] - o) * l | 0;
          v > r.heightmap[D * yh + M] && (r.heightmap[D * yh + M] = v);
        }
      }
      function Q2(r, e) {
        const n = {};
        n.indexArray = new qs(), n.indexArray.reserve(4 * r.length), n.vertexArray = new xa(), n.vertexArray.reserve(10 * r.length), n.colorArray = new Wa(), n.vertexArray.reserve(10 * r.length);
        let o = 0;
        for (const d of r) {
          const v = Math.min(10, Math.max(4, 1.3 * d.height)) * e, M = [-d.normal[1], d.normal[0], 0], D = Math.min(0.29, 0.1 * d.width / d.depth), x = d.width - 2 * d.depth * e * (D + 0.01), E = De.vec3.scaleAndAdd([], d.pos, M, x / 2), I = De.vec3.scaleAndAdd([], d.pos, M, -x / 2), S = [E[0], E[1], E[2] + d.height], C = [I[0], I[1], I[2] + d.height], k = De.vec3.scaleAndAdd([], d.normal, M, D);
          De.vec3.scale(k, k, v);
          const V = De.vec3.scaleAndAdd([], d.normal, M, -D);
          De.vec3.scale(V, V, v), De.vec3.add(k, E, k), De.vec3.add(V, I, V), E[2] += 0.1, I[2] += 0.1, n.vertexArray.emplaceBack(k[0], k[1], k[2]), n.vertexArray.emplaceBack(V[0], V[1], V[2]), n.vertexArray.emplaceBack(E[0], E[1], E[2]), n.vertexArray.emplaceBack(I[0], I[1], I[2]), n.vertexArray.emplaceBack(S[0], S[1], S[2]), n.vertexArray.emplaceBack(C[0], C[1], C[2]), n.vertexArray.emplaceBack(E[0], E[1], E[2]), n.vertexArray.emplaceBack(I[0], I[1], I[2]), n.vertexArray.emplaceBack(k[0], k[1], k[2]), n.vertexArray.emplaceBack(V[0], V[1], V[2]);
          const U = x / v / 2;
          n.colorArray.emplaceBack(-U - D, -1, U, 0.8), n.colorArray.emplaceBack(U + D, -1, U, 0.8), n.colorArray.emplaceBack(-U, 0, U, 1.3), n.colorArray.emplaceBack(U, 0, U, 1.3), n.colorArray.emplaceBack(U + D, -0.8, U, 0.7), n.colorArray.emplaceBack(U + D, -0.8, U, 0.7), n.colorArray.emplaceBack(0, 0, U, 1.3), n.colorArray.emplaceBack(0, 0, U, 1.3), n.colorArray.emplaceBack(U + D, -1.2, U, 0.8), n.colorArray.emplaceBack(U + D, -1.2, U, 0.8), n.indexArray.emplaceBack(6 + o, 4 + o, 8 + o), n.indexArray.emplaceBack(7 + o, 9 + o, 5 + o), n.indexArray.emplaceBack(0 + o, 1 + o, 2 + o), n.indexArray.emplaceBack(1 + o, 3 + o, 2 + o), o += 10;
        }
        const u = { defined: !0, emissiveFactor: [0, 0, 0] }, l = {};
        return l.baseColorFactor = ki.white, u.pbrMetallicRoughness = l, n.material = u, n.aabb = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), n;
      }
      class Mv {
        constructor(e) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let n = 0; n < e.length; n++) {
            const o = e[n];
            this._stringToNumber[o] = n, this._numberToString[n] = o;
          }
        }
        encode(e) {
          return this._stringToNumber[e];
        }
        decode(e) {
          return this._numberToString[e];
        }
      }
      const eS = ["id", "tile", "layer", "source", "sourceLayer", "state"];
      class ju {
        constructor(e, n, o, u, l) {
          this.type = "Feature", this._vectorTileFeature = e, this._z = n, this._x = o, this._y = u, this.properties = e.properties, this.id = l;
        }
        clone() {
          const e = new ju(this._vectorTileFeature, this._z, this._x, this._y, this.id);
          return this.state && (e.state = { ...this.state }), this.layer && (e.layer = { ...this.layer }), this.source && (e.source = this.source), this.sourceLayer && (e.sourceLayer = this.sourceLayer), e;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(e) {
          this._geometry = e;
        }
        toJSON() {
          const e = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
          for (const n of eS)
            this[n] !== void 0 && (e[n] = this[n]);
          return e;
        }
      }
      class Ev {
        constructor(e, n) {
          this.tileID = e, this.x = e.canonical.x, this.y = e.canonical.y, this.z = e.canonical.z, this.grid = new nc(wt, 16, 0), this.featureIndexArray = new ch(), this.promoteId = n, this.is3DTile = !1, this.serializedLayersCache = /* @__PURE__ */ new Map();
        }
        insert(e, n, o, u, l, d = 0, v = 0) {
          const M = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(o, u, l, d);
          const D = this.grid;
          for (let x = 0; x < n.length; x++) {
            const E = n[x], I = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let S = 0; S < E.length; S++) {
              const C = E[S];
              I[0] = Math.min(I[0], C.x), I[1] = Math.min(I[1], C.y), I[2] = Math.max(I[2], C.x), I[3] = Math.max(I[3], C.y);
            }
            v !== 0 && (I[0] -= v, I[1] -= v, I[2] += v, I[3] += v), I[0] < wt && I[1] < wt && I[2] >= 0 && I[3] >= 0 && D.insert(M, I[0], I[1], I[2], I[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            this.vtLayers = new Pu.VectorTile(new Pp(this.rawTileData)).layers, this.sourceLayerCoder = new Mv(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
            for (const e in this.vtLayers)
              this.vtFeatures[e] = [];
          }
          return this.vtLayers;
        }
        query(e, n) {
          const { tilespaceGeometry: o, transform: u, tileTransform: l, pixelPosMatrix: d, availableImages: v } = n;
          this.loadVTLayers(), this.serializedLayersCache.clear();
          const M = o.bufferedTilespaceBounds, D = this.grid.query(M.min.x, M.min.y, M.max.x, M.max.y, (S, C, k, V) => Oe(o.bufferedTilespaceGeometry, S, C, k, V));
          D.sort(tS);
          let x = null;
          u.elevation && D.length > 0 && (x = Ru.create(u.elevation, this.tileID));
          const E = {};
          let I;
          for (let S = 0; S < D.length; S++) {
            const C = D[S];
            if (C === I)
              continue;
            I = C;
            const k = this.featureIndexArray.get(C);
            let V = null;
            this.is3DTile ? this.loadMatchingModelFeature(E, k, e, o, u) : this.loadMatchingFeature(E, k, e, v, (U, q, $, H = 0) => (V || (V = j(U, this.tileID.canonical, l)), q.queryIntersectsFeature(o, U, $, V, this.z, u, d, x, H)));
          }
          return E;
        }
        loadMatchingFeature(e, n, o, u, l) {
          const { featureIndex: d, bucketIndex: v, sourceLayerIndex: M, layoutVertexArrayOffset: D } = n, x = this.bucketLayerIDs[v], E = o.layers, I = Object.keys(E);
          if (I.length && !function(U, q) {
            for (let $ = 0; $ < U.length; $++)
              if (q.indexOf(U[$]) >= 0)
                return !0;
            return !1;
          }(I, x))
            return;
          const S = o.sourceCache, C = this.sourceLayerCoder.decode(M), k = this.vtLayers[C].feature(d), V = this.getId(k, C);
          for (let U = 0; U < x.length; U++) {
            const q = x[U];
            if (!E[q])
              continue;
            const { styleLayer: $, targets: H } = E[q];
            let K = {};
            V !== void 0 && (K = S.getFeatureState($.sourceLayer, V));
            const Q = !l || l(k, $, K, D);
            if (!Q)
              continue;
            const ie = new ju(k, this.z, this.x, this.y, V);
            ie.tile = this.tileID.canonical, ie.state = K;
            let fe = this.serializedLayersCache.get(q);
            fe || (fe = $.serialize(), fe.id = q, this.serializedLayersCache.set(q, fe)), ie.source = fe.source, ie.sourceLayer = fe["source-layer"], ie.layer = Pn({}, fe), ie.layer.paint = Av(fe.paint, $.paint, k, K, u), ie.layer.layout = Av(fe.layout, $.layout, k, K, u);
            let de = !1;
            for (const he of H) {
              this.updateFeatureProperties(ie, he);
              const { filter: Me } = he;
              if (Me) {
                if (k.properties = ie.properties, Me.needGeometry) {
                  const me = G(k, !0);
                  if (!Me.filter(new Tn(this.tileID.overscaledZ), me, this.tileID.canonical))
                    continue;
                } else if (!Me.filter(new Tn(this.tileID.overscaledZ), k))
                  continue;
              }
              de = !0, he.targetId && this.addFeatureVariant(ie, he);
            }
            de && this.appendToResult(e, q, d, ie, Q);
          }
        }
        loadMatchingModelFeature(e, n, o, u, l) {
          const d = this.bucketLayerIDs[0][0], v = o.layers;
          if (!v[d])
            return;
          const { styleLayer: M, targets: D } = v[d];
          if (M.type !== "model")
            return;
          const x = u.tile, E = n.featureIndex, I = x.getBucket(M);
          if (!(I && I instanceof Xp))
            return;
          const S = function(fe, de, he, Me) {
            const me = fe.getNodesInfo()[de];
            if (me.hiddenByReplacement || !me.node.meshes)
              return;
            let Ee = Number.MAX_VALUE;
            const ze = me.node, Ie = he.tile, Re = Me.calculatePosMatrix(Ie.tileID.toUnwrapped(), Me.worldSize), Ve = me.evaluatedScale;
            let Ue = 0;
            Me.elevation && ze.elevation && (Ue = ze.elevation * Me.elevation.exaggeration()), De.mat4.translate(Re, Re, [(ze.anchor ? ze.anchor[0] : 0) * (Ve[0] - 1), (ze.anchor ? ze.anchor[1] : 0) * (Ve[1] - 1), Ue]), De.mat4.scale(Re, Re, Ve);
            const Fe = he.queryGeometry, et = Fe.isPointQuery() ? Fe.screenBounds : Fe.screenGeometry, dt = function(Tt) {
              const vt = De.mat4.multiply([], Re, Tt.matrix);
              De.mat4.multiply(vt, Me.expandedFarZProjMatrix, vt);
              for (let Pt = 0; Pt < Tt.meshes.length; ++Pt) {
                const rt = Tt.meshes[Pt];
                if (Pt === Tt.lightMeshIndex)
                  continue;
                const Ut = Ax(et, Me, vt, rt.aabb);
                Ut != null && (Ee = Math.min(Ut, Ee));
              }
              if (Tt.children)
                for (const Pt of Tt.children)
                  dt(Pt);
            };
            if (dt(ze), Ee === Number.MAX_VALUE)
              return;
            const tt = new Ui(0, 0);
            return Nx(Ie.tileID.canonical, tt, me.node.anchor[0], me.node.anchor[1]), { intersectionZ: Ee, position: tt, feature: me.feature };
          }(I, E, u, l);
          if (!S)
            return;
          const { z: C, x: k, y: V } = x.tileID.canonical, { feature: U, intersectionZ: q, position: $ } = S;
          let H = {};
          U.id !== void 0 && (H = o.sourceCache.getFeatureState(M.sourceLayer, U.id));
          const K = new ju({}, C, k, V, U.id);
          K.tile = this.tileID.canonical, K.state = H, K.properties = U.properties, K.geometry = { type: "Point", coordinates: [$.lng, $.lat] };
          let Q = this.serializedLayersCache.get(d);
          Q || (Q = M.serialize(), Q.id = d, this.serializedLayersCache.set(d, Q)), K.source = Q.source, K.sourceLayer = Q["source-layer"], K.layer = Pn({}, Q);
          let ie = !1;
          for (const fe of D) {
            this.updateFeatureProperties(K, fe);
            const { filter: de } = fe;
            if (de) {
              if (U.properties = K.properties, de.needGeometry) {
                if (!de.filter(new Tn(this.tileID.overscaledZ), U, this.tileID.canonical))
                  continue;
              } else if (!de.filter(new Tn(this.tileID.overscaledZ), U))
                continue;
            }
            ie = !0, fe.targetId && this.addFeatureVariant(K, fe);
          }
          ie && this.appendToResult(e, d, E, K, q);
        }
        updateFeatureProperties(e, n, o) {
          if (n.properties) {
            const u = {};
            for (const l in n.properties) {
              const d = n.properties[l].evaluate({ zoom: this.z }, e._vectorTileFeature, e.state, e.tile, o);
              d != null && (u[l] = d);
            }
            e.properties = u;
          }
        }
        addFeatureVariant(e, n, o) {
          const u = { target: n.target, namespace: n.namespace };
          n.properties && (u.properties = e.properties), e.variants = e.variants || {}, e.variants[n.targetId] = e.variants[n.targetId] || [], e.variants[n.targetId].push(u);
        }
        appendToResult(e, n, o, u, l) {
          let d = e[n];
          d === void 0 && (d = e[n] = []), d.push({ featureIndex: o, feature: u, intersectionZ: l });
        }
        lookupSymbolFeatures(e, n, o, u, l) {
          const d = {};
          this.loadVTLayers();
          for (const v of e)
            this.loadMatchingFeature(d, { bucketIndex: n, sourceLayerIndex: o, featureIndex: v, layoutVertexArrayOffset: 0 }, u, l);
          return d;
        }
        loadFeature(e) {
          const { featureIndex: n, sourceLayerIndex: o } = e;
          this.loadVTLayers();
          const u = this.sourceLayerCoder.decode(o), l = this.vtFeatures[u];
          if (l[n])
            return l[n];
          const d = this.vtLayers[u].feature(n);
          return l[n] = d, d;
        }
        hasLayer(e) {
          for (const n of this.bucketLayerIDs)
            for (const o of n)
              if (e === o)
                return !0;
          return !1;
        }
        getId(e, n) {
          let o = e.id;
          if (this.promoteId) {
            const u = typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n];
            u != null && (o = e.properties[u]), typeof o == "boolean" && (o = Number(o));
          }
          return o;
        }
      }
      function Av(r, e, n, o, u) {
        return Sr(r, (l, d) => {
          const v = e instanceof ac ? e.get(d) : null;
          return v && v.evaluate ? v.evaluate(n, o, u) : v;
        });
      }
      function tS(r, e) {
        return e - r;
      }
      Ft(Ev, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
      const Pv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class pg {
        static from(e) {
          if (!(e instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [n, o] = new Uint8Array(e, 0, 2);
          if (n !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const u = o >> 4;
          if (u !== 1)
            throw new Error(`Got v${u} data when expected v1.`);
          const l = Pv[15 & o];
          if (!l)
            throw new Error("Unrecognized array type.");
          const [d] = new Uint16Array(e, 2, 1), [v] = new Uint32Array(e, 4, 1);
          return new pg(v, d, l, e);
        }
        constructor(e, n = 64, o = Float64Array, u) {
          if (isNaN(e) || e < 0)
            throw new Error(`Unpexpected numItems value: ${e}.`);
          this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = o, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
          const l = Pv.indexOf(this.ArrayType), d = 2 * e * this.ArrayType.BYTES_PER_ELEMENT, v = e * this.IndexArrayType.BYTES_PER_ELEMENT, M = (8 - v % 8) % 8;
          if (l < 0)
            throw new Error(`Unexpected typed array class: ${o}.`);
          u && u instanceof ArrayBuffer ? (this.data = u, this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + v + M, 2 * e), this._pos = 2 * e, this._finished = !0) : (this.data = new ArrayBuffer(8 + d + v + M), this.ids = new this.IndexArrayType(this.data, 8, e), this.coords = new this.ArrayType(this.data, 8 + v + M, 2 * e), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + l]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
        }
        add(e, n) {
          const o = this._pos >> 1;
          return this.ids[o] = o, this.coords[this._pos++] = e, this.coords[this._pos++] = n, o;
        }
        finish() {
          const e = this._pos >> 1;
          if (e !== this.numItems)
            throw new Error(`Added ${e} items when expected ${this.numItems}.`);
          return mg(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(e, n, o, u) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: l, coords: d, nodeSize: v } = this, M = [0, l.length - 1, 0], D = [];
          for (; M.length; ) {
            const x = M.pop() || 0, E = M.pop() || 0, I = M.pop() || 0;
            if (E - I <= v) {
              for (let V = I; V <= E; V++) {
                const U = d[2 * V], q = d[2 * V + 1];
                U >= e && U <= o && q >= n && q <= u && D.push(l[V]);
              }
              continue;
            }
            const S = I + E >> 1, C = d[2 * S], k = d[2 * S + 1];
            C >= e && C <= o && k >= n && k <= u && D.push(l[S]), (x === 0 ? e <= C : n <= k) && (M.push(I), M.push(S - 1), M.push(1 - x)), (x === 0 ? o >= C : u >= k) && (M.push(S + 1), M.push(E), M.push(1 - x));
          }
          return D;
        }
        within(e, n, o) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: u, coords: l, nodeSize: d } = this, v = [0, u.length - 1, 0], M = [], D = o * o;
          for (; v.length; ) {
            const x = v.pop() || 0, E = v.pop() || 0, I = v.pop() || 0;
            if (E - I <= d) {
              for (let V = I; V <= E; V++)
                Iv(l[2 * V], l[2 * V + 1], e, n) <= D && M.push(u[V]);
              continue;
            }
            const S = I + E >> 1, C = l[2 * S], k = l[2 * S + 1];
            Iv(C, k, e, n) <= D && M.push(u[S]), (x === 0 ? e - o <= C : n - o <= k) && (v.push(I), v.push(S - 1), v.push(1 - x)), (x === 0 ? e + o >= C : n + o >= k) && (v.push(S + 1), v.push(E), v.push(1 - x));
          }
          return M;
        }
      }
      function mg(r, e, n, o, u, l) {
        if (u - o <= n)
          return;
        const d = o + u >> 1;
        Cv(r, e, d, o, u, l), mg(r, e, n, o, d - 1, 1 - l), mg(r, e, n, d + 1, u, 1 - l);
      }
      function Cv(r, e, n, o, u, l) {
        for (; u > o; ) {
          if (u - o > 600) {
            const D = u - o + 1, x = n - o + 1, E = Math.log(D), I = 0.5 * Math.exp(2 * E / 3), S = 0.5 * Math.sqrt(E * I * (D - I) / D) * (x - D / 2 < 0 ? -1 : 1);
            Cv(r, e, n, Math.max(o, Math.floor(n - x * I / D + S)), Math.min(u, Math.floor(n + (D - x) * I / D + S)), l);
          }
          const d = e[2 * n + l];
          let v = o, M = u;
          for (ff(r, e, o, n), e[2 * u + l] > d && ff(r, e, o, u); v < M; ) {
            for (ff(r, e, v, M), v++, M--; e[2 * v + l] < d; )
              v++;
            for (; e[2 * M + l] > d; )
              M--;
          }
          e[2 * o + l] === d ? ff(r, e, o, M) : (M++, ff(r, e, M, u)), M <= n && (o = M + 1), n <= M && (u = M - 1);
        }
      }
      function ff(r, e, n, o) {
        _g(r, n, o), _g(e, 2 * n, 2 * o), _g(e, 2 * n + 1, 2 * o + 1);
      }
      function _g(r, e, n) {
        const o = r[e];
        r[e] = r[n], r[n] = o;
      }
      function Iv(r, e, n, o) {
        const u = r - n, l = e - o;
        return u * u + l * l;
      }
      i.$ = yd, i.A = ss, i.B = 2, i.C = Z0, i.D = Ou, i.E = Go, i.F = D_, i.G = class extends Wp {
      }, i.H = Ho, i.I = rg, i.J = Bi, i.K = Kf, i.L = sd, i.M = tc, i.N = Uf, i.O = Qh, i.P = Mt, i.Q = au, i.R = Vo, i.S = ld, i.T = H_, i.U = Yc, i.V = Wp, i.W = gl, i.X = oo, i.Y = ro, i.Z = or, i._ = Da, i.a = function(r) {
        return ge.API_CDN_URL_REGEX.test(r);
      }, i.a$ = ju, i.a0 = Kh, i.a1 = Yh, i.a2 = function(r) {
        const e = r.value;
        let n = [];
        if (!e)
          return n;
        const o = Ho(e);
        return o !== "string" ? (n = n.concat([new Wp(r.key, e, `string expected, "${o}" found`)]), n) : (Cx(e, !0) || (n = n.concat([new Wp(r.key, e, `invalid url "${e}"`)])), n);
      }, i.a3 = $e, i.a4 = Qc, i.a5 = Bn, i.a6 = gt, i.a7 = class {
        constructor(r) {
          this.specification = r;
        }
        possiblyEvaluate(r, e) {
          return Zi(r.expression.evaluate(e));
        }
        interpolate(r, e, n) {
          return { x: ei(r.x, e.x, n), y: ei(r.y, e.y, n), z: ei(r.z, e.z, n), azimuthal: ei(r.azimuthal, e.azimuthal, n), polar: ei(r.polar, e.polar, n) };
        }
      }, i.a8 = Tn, i.a9 = ic, i.aA = wa, i.aB = class {
        constructor(r) {
          this.entries = {}, this.scheduler = r;
        }
        request(r, e, n, o) {
          const u = this.entries[r] = this.entries[r] || { callbacks: [] };
          if (u.result) {
            const [l, d] = u.result;
            return this.scheduler ? this.scheduler.add(() => {
              o(l, d);
            }, e) : o(l, d), () => {
            };
          }
          return u.callbacks.push(o), u.cancel || (u.cancel = n((l, d) => {
            u.result = [l, d];
            for (const v of u.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                v(l, d);
              }, e) : v(l, d);
            setTimeout(() => delete this.entries[r], 3e3);
          })), () => {
            u.result || (u.callbacks = u.callbacks.filter((l) => l !== o), u.callbacks.length || (u.cancel(), delete this.entries[r]));
          };
        }
      }, i.aC = Co, i.aD = function(r, e, n) {
        const o = JSON.stringify(r.request);
        return r.data && (this.deduped.entries[o] = { result: [null, r.data] }), this.deduped.request(o, { type: "parseTile", isSymbolTile: r.isSymbolTile, zoom: r.tileZoom }, (u) => {
          const l = no(r.request, (d, v, M, D) => {
            d ? u(d) : v && u(null, { vectorTile: n ? void 0 : new Pu.VectorTile(new Pp(v)), rawData: v, cacheControl: M, expires: D });
          });
          return () => {
            l.cancel(), u();
          };
        }, e);
      }, i.aE = function(r) {
        Xn++, Xn > ri && (r.getActor().send("enforceCacheSizeLimit", li), Xn = 0);
      }, i.aF = function(r) {
        return r <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
      }, i.aG = xt, i.aH = _x, i.aI = wx, i.aJ = mx, i.aK = function(r, e) {
        const n = document.createElement("video");
        n.muted = !0, n.onloadstart = function() {
          e(null, n);
        };
        for (let o = 0; o < r.length; o++) {
          const u = document.createElement("source");
          jo(r[o]) || (n.crossOrigin = "Anonymous"), u.src = r[o], n.appendChild(u);
        }
        return { cancel: () => {
        } };
      }, i.aL = jp, i.aM = function(r) {
        return fetch(r).then((e) => e.arrayBuffer()).then((e) => wv(e, 0, r));
      }, i.aN = Sv, i.aO = class {
        constructor(r, e, n, o) {
          this.id = r, this.position = e != null ? new Ui(e[0], e[1]) : new Ui(0, 0), this.orientation = n ?? [0, 0, 0], this.nodes = o, this.uploaded = !1, this.aabb = new Jt([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
        }
        _applyTransformations(r, e) {
          if (De.mat4.multiply(r.matrix, e, r.matrix), r.meshes)
            for (const n of r.meshes) {
              const o = Jt.applyTransformFast(n.aabb, r.matrix);
              this.aabb.encapsulate(o);
            }
          if (r.children)
            for (const n of r.children)
              this._applyTransformations(n, r.matrix);
        }
        computeBoundsAndApplyParent() {
          const r = De.mat4.identity([]);
          for (const e of this.nodes)
            this._applyTransformations(e, r);
        }
        computeModelMatrix(r, e, n, o, u, l, d = !1) {
          kx(this.matrix, this, r.transform, this.position, e, n, o, u, l, d);
        }
        upload(r) {
          if (!this.uploaded) {
            for (const e of this.nodes)
              Y_(e, r);
            for (const e of this.nodes)
              $p(e);
            this.uploaded = !0;
          }
        }
        destroy() {
          for (const r of this.nodes)
            K_(r);
        }
      }, i.aP = xo, i.aQ = Yd, i.aR = Fr, i.aS = Os, i.aT = qa, i.aU = qs, i.aV = go, i.aW = ip, i.aX = Vp, i.aY = function() {
        co.isLoading() || co.isLoaded() || ru() !== "deferred" || Xf();
      }, i.aZ = Jf, i.a_ = G, i.aa = h, i.ab = De, i.ac = fs, i.ad = ac, i.ae = mr, i.af = ei, i.ag = wt, i.ah = cl, i.ai = vi, i.aj = ki, i.ak = class {
        constructor(r) {
          this.specification = r;
        }
        possiblyEvaluate(r, e) {
          return function([n, o]) {
            const u = Zi([1, n, o]);
            return { x: u.x, y: u.y, z: u.z };
          }(r.expression.evaluate(e));
        }
        interpolate(r, e, n) {
          return { x: ei(r.x, e.x, n), y: ei(r.y, e.y, n), z: ei(r.z, e.z, n) };
        }
      }, i.al = function(r, e, n = 0, o = !0) {
        const u = new Mt(n, n), l = r.sub(u), d = e.add(u), v = [l, new Mt(d.x, l.y), d, new Mt(l.x, d.y)];
        return o && v.push(l.clone()), v;
      }, i.am = function(r, e) {
        const n = [];
        for (let o = 0; o < r.length; o++) {
          const u = zn(o - 1, -1, r.length - 1), l = zn(o + 1, -1, r.length - 1), d = r[o], v = r[l], M = r[u].sub(d).unit(), D = v.sub(d).unit(), x = D.angleWithSep(M.x, M.y), E = M.add(D).unit().mult(-1 * e / Math.sin(x / 2));
          n.push(d.add(E));
        }
        return n;
      }, i.an = tx, i.ao = Oe, i.ap = function(r, e, n = 0) {
        return De.vec3.fromValues(((e.x - n) * r.scale - r.x) * wt, (e.y * r.scale - r.y) * wt, mp(e.z, e.y));
      }, i.aq = zi, i.ar = x0, i.as = function(r) {
        let e = 1 / 0, n = 1 / 0, o = -1 / 0, u = -1 / 0;
        for (const l of r)
          e = Math.min(e, l.x), n = Math.min(n, l.y), o = Math.max(o, l.x), u = Math.max(u, l.y);
        return { min: new Mt(e, n), max: new Mt(o, u) };
      }, i.at = ea, i.au = Pe, i.av = g, i.aw = si, i.ax = dr, i.ay = function(r, e) {
        const n = {};
        for (let o = 0; o < e.length; o++) {
          const u = e[o];
          u in r && (n[u] = r[u]);
        }
        return n;
      }, i.az = Qa, i.b = function(r) {
        return ge.API_FONTS_REGEX.test(r);
      }, i.b$ = Hp, i.b0 = Fn, i.b1 = S_, i.b2 = p_, i.b3 = j, i.b4 = Io, i.b5 = gu, i.b6 = ai, i.b7 = Wn, i.b8 = Od, i.b9 = j_, i.bA = Ky, i.bB = O_, i.bC = K0, i.bD = z_, i.bE = pg, i.bF = zn, i.bG = zs, i.bH = fr, i.bI = function(r, e, n) {
        r[4 * e + 0] = n[0], r[4 * e + 1] = n[1], r[4 * e + 2] = n[2], r[4 * e + 3] = n[3];
      }, i.bJ = dh, i.bK = Lo, i.bL = Ld, i.bM = Nn, i.bN = hc, i.bO = Ui, i.bP = ox, i.bQ = Lt, i.bR = _i, i.bS = Sx, i.bT = nt, i.bU = jn, i.bV = function(r, e, n, o, u, l, d, v, M) {
        if (M.name === "globe")
          return jn(r, e, new nt(n, o, u), !1);
        const D = Yd({ z: n, x: o, y: u }, M);
        return new Jt([(l + D.x / D.scale) * e, e * (D.y / D.scale), d], [(l + D.x2 / D.scale) * e, e * (D.y2 / D.scale), v]);
      }, i.bW = function(r, e, n) {
        let o = 0;
        for (let u = 0; u < 2; ++u)
          r[u] > 0 && (o += (r[u] - 0) * (r[u] - 0)), e[u] < 0 && (o += (0 - e[u]) * (0 - e[u]));
        return o;
      }, i.bX = Un, i.bY = dp, i.bZ = function(r) {
        const e = De.mat4.identity(new Float64Array(16));
        De.mat4.multiply(e, r.pixelMatrix, r.globeMatrix);
        const n = [0, uo, 0], o = [0, fo, 0];
        return De.vec3.transformMat4(n, n, e), De.vec3.transformMat4(o, o, e), [n[0] > 0 && n[0] <= r.width && n[1] > 0 && n[1] <= r.height && !Nr(r, new Ui(r.center.lat, 90)), o[0] > 0 && o[0] <= r.width && o[1] > 0 && o[1] <= r.height && !Nr(r, new Ui(r.center.lat, -90))];
      }, i.b_ = function(r, e) {
        const { scale: n } = r.tileTransform, o = n * wt / (r.tileSize * Math.pow(2, e.zoom - r.tileID.overscaledZ + r.tileID.canonical.z));
        return De.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [o, o]);
      }, i.ba = function(r, e) {
        const n = mr(e.zoom);
        if (n === 0)
          return ts(r);
        const o = dn(r), u = _n(o), l = ea(o.getWest()) * e.worldSize, d = ea(o.getEast()) * e.worldSize, v = wa(o.getNorth()) * e.worldSize, M = wa(o.getSouth()) * e.worldSize, D = [l, v, 0], x = [d, v, 0], E = [l, M, 0], I = [d, M, 0], S = De.mat4.invert([], e.globeMatrix);
        return De.vec3.transformMat4(D, D, S), De.vec3.transformMat4(x, x, S), De.vec3.transformMat4(E, E, S), De.vec3.transformMat4(I, I, S), u[0] = As(u[0], E, n), u[1] = As(u[1], I, n), u[2] = As(u[2], x, n), u[3] = As(u[3], D, n), Jt.fromPoints(u);
      }, i.bb = cn, i.bc = Ri, i.bd = As, i.be = nh, i.bf = Xt, i.bg = cg, i.bh = Pp, i.bi = no, i.bj = function(r) {
        const e = [];
        for (const n in r)
          e.push(r[n]);
        return e;
      }, i.bk = function(r, e) {
        const n = [];
        for (const o in r)
          o in e || n.push(o);
        return n;
      }, i.bl = Rn, i.bm = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], i.bn = ir, i.bo = function(r, e) {
        const { x: n, y: o } = r.point, u = Ta(n, o, r.worldSize / r._pixelsPerMercatorPixel, 0, 0);
        return De.mat4.multiply(u, u, Qs(ts(e)));
      }, i.bp = Cu, i.bq = ko, i.br = Ap, i.bs = function(r, e, n, o, u) {
        const l = 5 * e + 2;
        r.float32[l + 0] = n, r.float32[l + 1] = o, r.float32[l + 2] = u;
      }, i.bt = Np, i.bu = G0, i.bv = se, i.bw = er, i.bx = Hy, i.by = Px, i.bz = Yy, i.c = Ce, i.c$ = (r, e, n, o, u, l, d, v) => {
        const M = r.transform, D = M.pitch < 15 ? v0(0.07, 0.7, si((14 - M.zoom) / 5, 0, 1)) : 0.07, x = n.paint.get("line-trim-color-use-theme").constantOr("default") === "none";
        return { u_matrix: w0(r, e, n, o), u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: M.calculatePixelsToTileUnitsMatrix(e), u_device_pixel_ratio: u, u_width_scale: l, u_floor_width_scale: d, u_image: 0, u_tile_units_to_pixels: b0(e, M), u_units_to_pixels: [1 / M.pixelsToGLUnits[0], 1 / M.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: v, u_trim_fade_range: n.paint.get("line-trim-fade-range"), u_trim_color: n.paint.get("line-trim-color").toRenderColor(x ? null : n.lut).toArray01(), u_emissive_strength: n.paint.get("line-emissive-strength"), u_zbias_factor: D, u_tile_to_meter: s(e.tileID.canonical, 0) };
      }, i.c0 = Tx, i.c1 = function(r) {
        const e = Tx(r, !0);
        return De.mat2.invert([], [e[0], e[1], e[4], e[5]]);
      }, i.c2 = wi, i.c3 = function(r) {
        const { x: e, y: n } = r.point, { lng: o, lat: u } = r._center;
        return Ta(e, n, r.worldSize, o, u);
      }, i.c4 = kn, i.c5 = zt, i.c6 = Tu, i.c7 = function(r) {
        const e = Math.round((r + 45 + 360) % 360 / 90) % 4;
        return $s[e];
      }, i.c8 = 45, i.c9 = ph, i.cA = class extends va {
        constructor(r) {
          super(r), this.current = i_;
        }
        set(r, e, n) {
          if (this.fetchUniformLocation(r, e)) {
            for (let o = 0; o < 9; o++)
              if (n[o] !== this.current[o]) {
                this.current = n, this.gl.uniformMatrix3fv(this.location, !1, n);
                break;
              }
          }
        }
      }, i.cB = Hr, i.cC = function(r, e, n) {
        const o = mr(n.zoom), u = r.style.map._antialias, l = e.options.extStandardDerivativesForceOff || r.terrain && r.terrain.exaggeration() > 0;
        return o === 0 && !u && !l;
      }, i.cD = function(r) {
        const e = r.pixelsPerMeter, n = e / fr(1, r.center.lat), o = De.mat4.identity(new Float64Array(16));
        return De.mat4.translate(o, o, [r.point.x, r.point.y, 0]), De.mat4.scale(o, o, [n, n, e]), Float32Array.from(o);
      }, i.cE = dn, i.cF = function(r) {
        const e = Un - 5;
        r = si(r, -e, e) / e * 90;
        const n = Math.pow(Math.abs(Math.sin(vi(r))), 3);
        return Math.round(n * (Su.length - 1));
      }, i.cG = function(r, e, n, o) {
        const u = e.getNorth(), l = e.getSouth(), d = e.getWest(), v = e.getEast(), M = 1 << r.z, D = v - d, x = u - l, E = D / Pl, I = -x / Su[n], S = [0, E, 0, I, 0, 0, u, d, 0];
        if (r.z > 0) {
          const C = 180 / o;
          De.mat3.multiply(S, S, [C / D + 1, 0, 0, 0, C / x + 1, 0, -0.5 * C / E, 0.5 * C / I, 1]);
        }
        return S[2] = M, S[5] = r.x, S[8] = r.y, S;
      }, i.cH = ts, i.cI = function(r, e, n) {
        const o = De.mat4.identity(new Float64Array(16)), u = (e / (1 << r) - 0.5) * Math.PI * 2;
        return De.mat4.rotateY(o, n.globeMatrix, u), Float32Array.from(o);
      }, i.cJ = class {
        isDataAvailableAtPoint(r) {
          const e = this._source();
          if (this.isUsingMockSource() || !e || r.y < 0 || r.y > 1)
            return !1;
          const n = e.getSource().maxzoom, o = 1 << n, u = Math.floor(r.x), l = Math.floor((r.x - u) * o), d = Math.floor(r.y * o), v = this.findDEMTileFor(new xt(n, u, n, l, d));
          return !(!v || !v.dem);
        }
        getAtPointOrZero(r, e = 0) {
          return this.getAtPoint(r, e) || 0;
        }
        getAtPoint(r, e, n = !0) {
          if (this.isUsingMockSource())
            return null;
          e == null && (e = null);
          const o = this._source();
          if (!o || r.y < 0 || r.y > 1)
            return e;
          const u = o.getSource().maxzoom, l = 1 << u, d = Math.floor(r.x), v = r.x - d, M = new xt(u, d, u, Math.floor(v * l), Math.floor(r.y * l)), D = this.findDEMTileFor(M);
          if (!D || !D.dem)
            return e;
          const x = D.dem, E = 1 << D.tileID.canonical.z, I = (v * E - D.tileID.canonical.x) * x.dim, S = (r.y * E - D.tileID.canonical.y) * x.dim, C = Math.floor(I), k = Math.floor(S);
          return (n ? this.exaggeration() : 1) * ei(ei(x.get(C, k), x.get(C, k + 1), S - k), ei(x.get(C + 1, k), x.get(C + 1, k + 1), S - k), I - C);
        }
        getAtTileOffset(r, e, n) {
          const o = 1 << r.canonical.z;
          return this.getAtPointOrZero(new h(r.wrap + (r.canonical.x + e / wt) / o, (r.canonical.y + n / wt) / o));
        }
        getAtTileOffsetFunc(r, e, n, o) {
          return (u) => {
            const l = this.getAtTileOffset(r, u.x, u.y), d = o.upVector(r.canonical, u.x, u.y), v = o.upVectorScale(r.canonical, e, n).metersToTile;
            return De.vec3.scale(d, d, l * v), d;
          };
        }
        getForTilePoints(r, e, n, o) {
          if (this.isUsingMockSource())
            return !1;
          const u = Ru.create(this, r, o);
          return !!u && (e.forEach((l) => {
            l[2] = this.exaggeration() * u.getElevationAt(l[0], l[1], n);
          }), !0);
        }
        getMinMaxForTile(r) {
          if (this.isUsingMockSource())
            return null;
          const e = this.findDEMTileFor(r);
          if (!e || !e.dem)
            return null;
          const n = e.dem.tree, o = e.tileID, u = 1 << r.canonical.z - o.canonical.z;
          let l = r.canonical.x / u - o.canonical.x, d = r.canonical.y / u - o.canonical.y, v = 0;
          for (let M = 0; M < r.canonical.z - o.canonical.z && !n.leaves[v]; M++) {
            l *= 2, d *= 2;
            const D = 2 * Math.floor(d) + Math.floor(l);
            v = n.childOffsets[v] + D, l %= 1, d %= 1;
          }
          return { min: this.exaggeration() * n.minimums[v], max: this.exaggeration() * n.maximums[v] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(r, e, n) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(r) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        isUsingMockSource() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(r) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
        getMinMaxForVisibleTiles() {
          const r = this.visibleDemTiles;
          if (r.length === 0)
            return null;
          let e = !1, n = Number.MAX_VALUE, o = Number.MIN_VALUE;
          for (const u of r) {
            const l = this.getMinMaxForTile(u.tileID);
            l && (n = Math.min(n, l.min), o = Math.max(o, l.max), e = !0);
          }
          return e ? { min: n, max: o } : null;
        }
      }, i.cK = Sy, i.cL = ji, i.cM = function(r, e) {
        return [Math.pow(r[0], 2.2) * e, Math.pow(r[1], 2.2) * e, Math.pow(r[2], 2.2) * e];
      }, i.cN = Br, i.cO = le, i.cP = re, i.cQ = 256, i.cR = function(r, e) {
        const n = [0, 0, 0], o = cn(ts(e.canonical));
        return De.vec3.transformMat4(n, n, o), De.vec3.transformMat4(n, n, r), n;
      }, i.cS = (r) => ({ u_camera_to_center_distance: new Nn(r), u_extrude_scale: new Dd(r), u_device_pixel_ratio: new Nn(r), u_matrix: new dh(r), u_inv_rot_matrix: new dh(r), u_merc_center: new Lo(r), u_tile_id: new Ld(r), u_zoom_transition: new Nn(r), u_up_dir: new Ld(r), u_emissive_strength: new Nn(r) }), i.cT = (r) => ({ u_matrix: new dh(r), u_pixels_to_tile_units: new Dd(r), u_device_pixel_ratio: new Nn(r), u_width_scale: new Nn(r), u_floor_width_scale: new Nn(r), u_units_to_pixels: new Lo(r), u_dash_image: new hc(r), u_gradient_image: new hc(r), u_image_height: new Nn(r), u_texsize: new Lo(r), u_tile_units_to_pixels: new Nn(r), u_alpha_discard_threshold: new Nn(r), u_trim_offset: new Lo(r), u_trim_fade_range: new Lo(r), u_trim_color: new uh(r), u_emissive_strength: new Nn(r), u_zbias_factor: new Nn(r), u_tile_to_meter: new Nn(r) }), i.cU = (r) => ({ u_matrix: new dh(r), u_texsize: new Lo(r), u_pixels_to_tile_units: new Dd(r), u_device_pixel_ratio: new Nn(r), u_width_scale: new Nn(r), u_floor_width_scale: new Nn(r), u_image: new hc(r), u_units_to_pixels: new Lo(r), u_tile_units_to_pixels: new Nn(r), u_alpha_discard_threshold: new Nn(r), u_trim_offset: new Lo(r), u_trim_fade_range: new Lo(r), u_trim_color: new uh(r), u_emissive_strength: new Nn(r), u_zbias_factor: new Nn(r), u_tile_to_meter: new Nn(r) }), i.cV = pu, i.cW = rT, i.cX = oT, i.cY = Mu, i.cZ = (r, e, n, o, u, l) => {
        const d = r.transform, v = d.projection.name === "globe";
        let M;
        if (l.paint.get("circle-pitch-alignment") === "map")
          if (v) {
            const x = Br(d.zoom, e.canonical) * d._pixelsPerMercatorPixel;
            M = Float32Array.from([x, 0, 0, x]);
          } else
            M = d.calculatePixelsToTileUnitsMatrix(n);
        else
          M = new Float32Array([d.pixelsToGLUnits[0], 0, 0, d.pixelsToGLUnits[1]]);
        const D = { u_camera_to_center_distance: r.transform.getCameraToCenterDistance(d.projection), u_matrix: r.translatePosMatrix(e.projMatrix, n, l.paint.get("circle-translate"), l.paint.get("circle-translate-anchor")), u_device_pixel_ratio: Ct.devicePixelRatio, u_extrude_scale: M, u_inv_rot_matrix: mh, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: l.paint.get("circle-emissive-strength") };
        if (v) {
          D.u_inv_rot_matrix = o, D.u_merc_center = u, D.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], D.u_zoom_transition = mr(d.zoom);
          const x = u[0] * wt, E = u[1] * wt;
          D.u_up_dir = d.projection.upVector(new nt(0, 0, 0), x, E);
        }
        return D;
      }, i.c_ = T0, i.ca = uh, i.cb = function(r, e, n) {
        const o = Math.sqrt(r * r + e * e + n * n), u = o > 0 ? Math.acos(n / o) * Ws : 0;
        let l = r !== 0 || e !== 0 ? Math.atan2(-e, -r) * Ws + 90 : 0;
        return l < 0 && (l += 360), [o, l, u];
      }, i.cc = s, i.cd = Jt, i.ce = Zi, i.cf = function(r) {
        return [Math.pow(r[0], 1 / 2.2), Math.pow(r[1], 1 / 2.2), Math.pow(r[2], 1 / 2.2)];
      }, i.cg = function(r, e) {
        return r.readFields(KT, { icons: [] }, e);
      }, i.ch = function(r) {
        return r({ pluginStatus: br, pluginURL: Za }), sc.on("pluginStateChange", r), r;
      }, i.ci = Yp, i.cj = Lu, i.ck = k_, i.cl = tn, i.cm = Jc, i.cn = Kt, i.co = $r, i.cp = Xs, i.cq = function(r) {
        const e = r.indexOf(Po);
        return e >= 0 ? r.slice(0, e) : r;
      }, i.cr = function(r) {
        return r.indexOf(Po) >= 0;
      }, i.cs = function(r) {
        const e = r.indexOf(Po);
        return e >= 0 ? r.slice(e + 1) : "";
      }, i.ct = function(r) {
        const e = [], n = r.id;
        return n === void 0 && e.push({ message: `layers.${n}: missing required property "id"` }), r.render === void 0 && e.push({ message: `layers.${n}: missing required method "render"` }), r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && e.push({ message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"` }), e;
      }, i.cu = function(r, e, n, o) {
        return r.type === "custom" ? new FT(r, e) : new $T[r.type](r, e, n, o);
      }, i.cv = io, i.cw = class extends ju {
        constructor(r, e) {
          super(r._vectorTileFeature, r._z, r._x, r._y, r.id), r.state && (this.state = { ...r.state }), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = r.source, this.sourceLayer = r.sourceLayer, this.layer = r.layer);
        }
        toJSON() {
          const r = super.toJSON();
          return r.target = this.target, r.namespace = this.namespace, r;
        }
      }, i.cx = sc, i.cy = xn, i.cz = up, i.d = function(r) {
        return ge.API_TILEJSON_REGEX.test(r);
      }, i.d$ = Sr, i.d0 = (r, e, n, o, u, l, d, v, M) => {
        const D = r.transform, x = D.calculatePixelsToTileUnitsMatrix(e), E = n.paint.get("line-trim-color-use-theme").constantOr("default") === "none", I = D.pitch < 15 ? v0(0.07, 0.7, si((14 - D.zoom) / 5, 0, 1)) : 0.07;
        return { u_matrix: w0(r, e, n, o), u_pixels_to_tile_units: x, u_device_pixel_ratio: l, u_width_scale: d, u_floor_width_scale: v, u_units_to_pixels: [1 / D.pixelsToGLUnits[0], 1 / D.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: u, u_texsize: S0(n) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: b0(e, r.transform), u_alpha_discard_threshold: 0, u_trim_offset: M, u_trim_fade_range: n.paint.get("line-trim-fade-range"), u_trim_color: n.paint.get("line-trim-color").toRenderColor(E ? null : n.lut).toArray01(), u_emissive_strength: n.paint.get("line-emissive-strength"), u_zbias_factor: I, u_tile_to_meter: s(e.tileID.canonical, 0) };
      }, i.d1 = yo, i.d2 = Rd, i.d3 = h0, i.d4 = Bt, i.d5 = Mp, i.d6 = _c, i.d7 = 450, i.d8 = 7, i.d9 = OT, i.dA = Wr, i.dB = t, i.dC = Ja, i.dD = function([r, e, n]) {
        const o = Math.hypot(r, e, n), u = Math.atan2(r, n), l = 0.5 * Math.PI - Math.acos(-e / o);
        return new Ui(kn(u), kn(l));
      }, i.dE = W_, i.dF = function(r) {
        const e = r.navigator ? r.navigator.userAgent : null;
        return !!function(n) {
          if (Ls == null) {
            const o = n.navigator ? n.navigator.userAgent : null;
            Ls = !!n.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
          }
          return Ls;
        }(r) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
      }, i.dG = function(r, e) {
        li = r, ri = e;
      }, i.dH = Nr, i.dI = Do, i.dJ = function(r) {
        const e = [0, 0, 0], n = De.mat4.identity(new Float64Array(16));
        return De.mat4.multiply(n, r.pixelMatrix, r.globeMatrix), De.vec3.transformMat4(e, e, n), new Mt(e[0], e[1]);
      }, i.dK = function(r, e, n = !1) {
        if (br === md || br === Qo || br === _d)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Za = Ct.resolveURL(r), br = md, gd = e, su(), n || Xf();
      }, i.dL = ru, i.dM = function() {
        Yp().acquire(Q_);
      }, i.dN = function() {
        const r = rf;
        r && (r.isPreloaded() && r.numActive() === 1 ? (r.release(Q_), rf = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, i.dO = vh, i.dP = function(r) {
        const e = $i();
        if (!e)
          return;
        const n = e.delete(di);
        r && n.catch(r).then(() => r());
      }, i.dQ = sf, i.dR = mv, i.dS = function(r) {
        hg = Ct.resolveURL(r), Uu || (Uu = new Ou(Yp(), new Go())), Uu.broadcast("setDracoUrl", hg);
      }, i.dT = _v, i.dU = function(r) {
        Vu = Ct.resolveURL(r), Uu || (Uu = new Ou(Yp(), new Go())), Uu.broadcast("setMeshoptUrl", Vu);
      }, i.dV = Ft, i.dW = mc, i.dX = Ma, i.dY = Mv, i.dZ = Ev, i.d_ = _0, i.da = qi, i.db = Cd, i.dc = 256, i.dd = Qs, i.de = xa, i.df = Rr, i.dg = _u, i.dh = function(r, e, n, o, u) {
        return si((r - e) / (n - e) * (u - o) + o, o, u);
      }, i.di = es, i.dj = c, i.dk = class {
        constructor(r, e, n, o) {
          this.context = r, this.format = o, this.size = n, this.texture = r.gl.createTexture();
          const [u, l, d] = this.size, { gl: v } = r;
          v.bindTexture(v.TEXTURE_3D, this.texture), r.pixelStoreUnpackFlipY.set(!1), r.pixelStoreUnpack.set(1), r.pixelStoreUnpackPremultiplyAlpha.set(!1), v.texImage3D(v.TEXTURE_3D, 0, this.format, u, l, d, 0, G_(this.format), Z_(this.format), e.data);
        }
        bind(r, e) {
          const { context: n } = this, { gl: o } = n;
          o.bindTexture(o.TEXTURE_3D, this.texture), r !== this.minFilter && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MAG_FILTER, r), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MIN_FILTER, r), this.minFilter = r), e !== this.wrapS && (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_S, e), o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_T, e), this.wrapS = e);
        }
        destroy() {
          const { gl: r } = this.context;
          r.deleteTexture(this.texture), this.texture = null;
        }
      }, i.dl = $_, i.dm = [1, 1, 1], i.dn = Ru, i.dp = ku, i.dq = Xa, i.dr = Ml, i.ds = pc, i.dt = Ad, i.du = Ed, i.dv = class {
        constructor() {
          this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new Mt(1 / 0, 1 / 0), max: new Mt(-1 / 0, -1 / 0) };
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(r, e = !1) {
          const n = Wy(new Mt(0, 0), new Mt(wt, wt), r), o = [];
          if (e && !x_(n, this._globalClipBounds))
            return o;
          for (const u of this._activeRegions) {
            if (u.hiddenByOverlap || !x_(n, u))
              continue;
            const l = zw(u.min, u.max, r);
            o.push({ min: l.min, max: l.max, sourceId: this._sourceIds[u.priority], footprint: u.footprint, footprintTileId: u.tileId, order: u.order, clipMask: u.clipMask, clipScope: u.clipScope });
          }
          return o;
        }
        setSources(r) {
          this._setSources(r.map((e) => ({ getSourceId: () => e.cache.id, getFootprints: () => {
            const n = [];
            for (const o of e.cache.getVisibleCoordinates()) {
              const u = e.cache.getTile(o).buckets[e.layer];
              u && u.updateFootprints(o.toUnwrapped(), n);
            }
            return n;
          }, getOrder: () => e.order, getClipMask: () => e.clipMask, getClipScope: () => e.clipScope })));
        }
        _addSource(r) {
          const e = r.getFootprints();
          if (e.length === 0)
            return;
          const n = r.getOrder(), o = r.getClipMask(), u = r.getClipScope();
          for (const l of e) {
            if (!l.footprint)
              continue;
            const d = Wy(l.footprint.min, l.footprint.max, l.id);
            this._activeRegions.push({ min: d.min, max: d.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: l.id, footprint: l.footprint, order: n, clipMask: o, clipScope: u });
          }
          this._sourceIds.push(r.getSourceId());
        }
        _computeReplacement() {
          this._activeRegions.sort((e, n) => e.priority - n.priority || Tp(e.min, n.min) || Tp(e.max, n.max) || e.order - n.order || e.clipMask - n.clipMask || function(o, u) {
            const l = (d, v) => d + v;
            return o.length - u.length || o.reduce(l, "").localeCompare(u.reduce(l, ""));
          }(e.clipScope, n.clipScope));
          let r = this._activeRegions.length !== this._prevRegions.length;
          if (!r) {
            let e = 0;
            for (; !r && e !== this._activeRegions.length; ) {
              const n = this._activeRegions[e], o = this._prevRegions[e];
              r = n.priority !== o.priority || !qy(n, o) || n.order !== o.order || n.clipMask !== o.clipMask || !ir(n.clipScope, o.clipScope), ++e;
            }
          }
          if (r) {
            ++this._updateTime;
            for (const n of this._activeRegions)
              n.order !== wp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, n.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, n.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, n.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, n.max.y));
            const e = (n) => {
              const o = this._activeRegions;
              if (n >= o.length)
                return n;
              const u = o[n].priority;
              for (; n < o.length && o[n].priority === u; )
                ++n;
              return n;
            };
            if (this._sourceIds.length > 1) {
              let n = 0, o = e(n);
              for (; n !== o; ) {
                let u = n;
                const l = n;
                for (; u !== o; ) {
                  const d = this._activeRegions[u];
                  d.hiddenByOverlap = !1;
                  for (let v = 0; v < l; v++) {
                    const M = this._activeRegions[v];
                    if (!M.hiddenByOverlap && d.order === wp && x_(d, M) && (d.hiddenByOverlap = Xy(d.footprint, d.tileId, M.footprint, M.tileId), d.hiddenByOverlap))
                      break;
                  }
                  ++u;
                }
                n = o, o = e(n);
              }
            }
          }
        }
        _setSources(r) {
          [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
          for (let e = r.length - 1; e >= 0; e--)
            this._addSource(r[e]);
          this._computeReplacement();
        }
      }, i.dw = class {
        constructor(r) {
          this._createGrid(r), this._createPoles(r);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const r of this._poleSegments)
            r.destroy();
          for (const r of this._gridSegments)
            r.withSkirts.destroy(), r.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(r, e) {
          const n = new Io(), o = new qs(), u = [], l = r + 1 + 2, d = e[0] + 1, v = e[0] + 1 + (1 + e.length), M = (D, x, E) => {
            let I = D === l - 1 ? D - 2 : D === 0 ? D : D - 1;
            return I += E ? 24575 : 0, [I, x];
          };
          for (let D = 0; D < l; ++D)
            n.emplaceBack(...M(D, 0, !0));
          for (let D = 0; D < d; ++D)
            for (let x = 0; x < l; ++x)
              n.emplaceBack(...M(x, D, (x === 0 || x === l - 1) && !0));
          for (let D = 0; D < e.length; ++D) {
            const x = e[D];
            for (let E = 0; E < l; ++E)
              n.emplaceBack(...M(E, x, !0));
          }
          for (let D = 0; D < e.length; ++D) {
            const x = o.length, E = e[D] + 1 + 2, I = new qs();
            for (let k = 0; k < E - 1; k++) {
              const V = k === E - 2, U = V ? l * (v - e.length + D - k) : l;
              for (let q = 0; q < l - 1; q++) {
                const $ = k * l + q;
                k === 0 || V || q === 0 || q === l - 2 ? (I.emplaceBack($ + 1, $, $ + U), I.emplaceBack($ + U, $ + U + 1, $ + 1)) : (o.emplaceBack($ + 1, $, $ + U), o.emplaceBack($ + U, $ + U + 1, $ + 1));
              }
            }
            const S = Wn.simpleSegment(0, x, n.length, o.length - x);
            for (let k = 0; k < I.uint16.length; k += 3)
              o.emplaceBack(I.uint16[k], I.uint16[k + 1], I.uint16[k + 2]);
            const C = Wn.simpleSegment(0, x, n.length, o.length - x);
            u.push({ withoutSkirts: S, withSkirts: C });
          }
          return { vertices: n, indices: o, segments: u };
        }
        _createGrid(r) {
          const e = this._fillGridMeshWithLods(Pl, Su);
          this._gridSegments = e.segments, this._gridBuffer = r.createVertexBuffer(e.vertices, ai.members), this._gridIndexBuffer = r.createIndexBuffer(e.indices, !0);
        }
        _createPoles(r) {
          const e = new qs();
          for (let d = 0; d <= Pl; d++)
            e.emplaceBack(0, d + 1, d + 2);
          this._poleIndexBuffer = r.createIndexBuffer(e, !0);
          const n = new Rr(), o = new Rr(), u = new Rr(), l = new Rr();
          this._poleSegments = [];
          for (let d = 0, v = 0; d < Tu; d++) {
            const M = 360 / (1 << d);
            n.emplaceBack(0, -dr, 0, 0.5, 0), o.emplaceBack(0, -dr, 0, 0.5, 1), u.emplaceBack(0, -dr, 0, 0.5, 0.5), l.emplaceBack(0, -dr, 0, 0.5, 0.5);
            for (let D = 0; D <= Pl; D++) {
              let x = D / Pl, E = 0;
              const I = ei(0, M, x), [S, C, k] = fc(ta, Cl, I, dr);
              n.emplaceBack(S, C, k, x, E), o.emplaceBack(S, C, k, x, 1 - E);
              const V = vi(I);
              x = 0.5 + 0.5 * Math.sin(V), E = 0.5 + 0.5 * Math.cos(V), u.emplaceBack(S, C, k, x, E), l.emplaceBack(S, C, k, x, 1 - E);
            }
            this._poleSegments.push(Wn.simpleSegment(v, 0, 66, 64)), v += 66;
          }
          this._poleNorthVertexBuffer = r.createVertexBuffer(n, $t, !1), this._poleSouthVertexBuffer = r.createVertexBuffer(o, $t, !1), this._texturedPoleNorthVertexBuffer = r.createVertexBuffer(u, $t, !1), this._texturedPoleSouthVertexBuffer = r.createVertexBuffer(l, $t, !1);
        }
        getGridBuffers(r, e) {
          return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[r].withSkirts : this._gridSegments[r].withoutSkirts];
        }
        getPoleBuffers(r, e) {
          return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[r]];
        }
      }, i.dx = wp, i.dy = qr, i.dz = function() {
        return !!document.fullscreenElement || !!document.webkitFullscreenElement;
      }, i.e = ge, i.e0 = rr, i.e1 = H0, i.e2 = function(r, e, n, o, u, l, d, v, M, D, x = 1, E, I) {
        r.createArrays(), r.tilePixelRatio = wt / (512 * r.overscaling), r.compareText = {}, r.iconsNeedLinear = !1;
        const S = r.layers[0].layout, C = r.layers[0]._unevaluatedLayout._values, k = {};
        k.scaleFactor = x, k.textSizeScaleRange = S.get("text-size-scale-range"), k.iconSizeScaleRange = S.get("icon-size-scale-range");
        const [V, U] = k.textSizeScaleRange, [q, $] = k.iconSizeScaleRange;
        if (k.textScaleFactor = si(k.scaleFactor, V, U), k.iconScaleFactor = si(k.scaleFactor, q, $), r.textSizeData.kind === "composite") {
          const { minZoom: ie, maxZoom: fe } = r.textSizeData;
          k.compositeTextSizes = [C["text-size"].possiblyEvaluate(new Tn(ie), v), C["text-size"].possiblyEvaluate(new Tn(fe), v)];
        }
        if (r.iconSizeData.kind === "composite") {
          const { minZoom: ie, maxZoom: fe } = r.iconSizeData;
          k.compositeIconSizes = [C["icon-size"].possiblyEvaluate(new Tn(ie), v), C["icon-size"].possiblyEvaluate(new Tn(fe), v)];
        }
        k.layoutTextSize = C["text-size"].possiblyEvaluate(new Tn(M + 1), v), k.layoutIconSize = C["icon-size"].possiblyEvaluate(new Tn(M + 1), v), k.textMaxSize = C["text-size"].possiblyEvaluate(new Tn(18), v);
        const H = S.get("text-rotation-alignment") === "map" && S.get("symbol-placement") !== "point", K = S.get("text-size");
        let Q = !1;
        for (const ie of r.features)
          if (ie.icon && ie.icon.nameSecondary) {
            Q = !0;
            break;
          }
        for (const ie of r.features) {
          const fe = S.get("text-font").evaluate(ie, {}, v).join(","), de = K.evaluate(ie, {}, v) * k.textScaleFactor, he = k.layoutTextSize.evaluate(ie, {}, v) * k.textScaleFactor, Me = (k.layoutIconSize.evaluate(ie, {}, v), { horizontal: {}, vertical: void 0 }), me = ie.text;
          let Ee, ze = [0, 0];
          if (me) {
            const Ue = me.toString(), Fe = S.get("text-letter-spacing").evaluate(ie, {}, v) * er, et = S.get("text-line-height").evaluate(ie, {}, v) * er, dt = qf(Ue) ? Fe : 0, tt = S.get("text-anchor").evaluate(ie, {}, v), Tt = S.get("text-variable-anchor");
            if (!Tt) {
              const St = S.get("text-radial-offset").evaluate(ie, {}, v);
              ze = St ? K0(tt, [St * er, R_]) : S.get("text-offset").evaluate(ie, {}, v).map((Nt) => Nt * er);
            }
            let vt = H ? "center" : S.get("text-justify").evaluate(ie, {}, v);
            const Pt = S.get("symbol-placement") === "point", rt = Pt ? S.get("text-max-width").evaluate(ie, {}, v) * er : 1 / 0, Ut = (St) => {
              r.allowVerticalPlacement && dd(Ue) && (Me.vertical = L_(me, e, n, u, fe, rt, et, tt, St, dt, ze, ko.vertical, !0, he, de));
            };
            if (!H && Tt) {
              const St = vt === "auto" ? Tt.map((Qt) => O_(Qt)) : [vt];
              let Nt = !1;
              for (let Qt = 0; Qt < St.length; Qt++) {
                const pi = St[Qt];
                if (!Me.horizontal[pi])
                  if (Nt)
                    Me.horizontal[pi] = Me.horizontal[0];
                  else {
                    const gi = L_(me, e, n, u, fe, rt, et, "center", pi, dt, ze, ko.horizontal, !1, he, de);
                    gi && (Me.horizontal[pi] = gi, Nt = gi.positionedLines.length === 1);
                  }
              }
              Ut("left");
            } else {
              if (vt === "auto" && (vt = O_(tt)), Pt || S.get("text-writing-mode").indexOf("horizontal") >= 0 || !dd(Ue)) {
                const St = L_(me, e, n, u, fe, rt, et, tt, vt, dt, ze, ko.horizontal, !1, he, de);
                St && (Me.horizontal[vt] = St);
              }
              Ut(Pt ? "left" : vt);
            }
          }
          let Ie = !1, Re = !1;
          if (ie.icon && ie.icon.namePrimary) {
            const Ue = Ep(r.iconSizeData, C["icon-size"], v, r.zoom, ie) * k.iconScaleFactor * E, Fe = ie.icon.getPrimary().scaleSelf(Ue).serialize(), et = o[Fe];
            et && (Ee = _T(u[Fe], ie.icon.nameSecondary ? u[ie.icon.getSecondary().scaleSelf(Ue).serialize()] : void 0, S.get("icon-offset").evaluate(ie, {}, v), S.get("icon-anchor").evaluate(ie, {}, v)), Ie = et.sdf, Re = et.usvg, r.sdfIcons === void 0 ? r.sdfIcons = et.sdf : r.sdfIcons !== et.sdf && mi("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (et.pixelRatio !== r.pixelRatio || S.get("icon-rotate").constantOr(1) !== 0) && (r.iconsNeedLinear = !0));
          }
          const Ve = Q0(Me.horizontal) || Me.vertical;
          r.iconsInText || (r.iconsInText = !!Ve && Ve.iconsInText), (Ve || Ee) && TT(r, ie, Me, Ee, o, k, he, 0, ze, Ie, Re, d, v, D, I, Q);
        }
        l && r.generateCollisionDebugBuffers(M, r.collisionBoxArray, k.textScaleFactor);
      }, i.e3 = Pu, i.e4 = im, i.e5 = Zr, i.e6 = Uy, i.e7 = I0, i.e8 = O, i.e9 = function(r) {
        let e = 0;
        if (new Uint32Array(r, 0, 1)[0] !== yv) {
          const n = new Uint32Array(r, 0, 7), [, , o, u, l, d] = n;
          e = n.byteLength + u + l + d + l, (o !== r.byteLength || e >= r.byteLength) && mi("Invalid b3dm header information.");
        }
        return wv(r, e);
      }, i.ea = function(r, e) {
        const n = Sv(r);
        for (const o of n) {
          for (const u of o.meshes)
            J2(u);
          o.lights && (o.lightMeshIndex = o.meshes.length, o.meshes.push(Q2(o.lights, e)));
        }
        return n;
      }, i.eb = Xp, i.ec = Vx, i.ed = co, i.ee = function(r) {
        Hi(), Ni != null && Ni.then((e) => {
          e.keys().then((n) => {
            for (let o = 0; o < n.length - r; o++)
              e.delete(n[o]);
          });
        });
      }, i.f = function(r) {
        return r.indexOf("mapbox:") === 0;
      }, i.g = function(r, e) {
        return xn(Pn(r, { method: "GET" }), e);
      }, i.h = Le, i.i = function(r) {
        return ge.API_STYLE_REGEX.test(r) && !Ce(r);
      }, i.j = function(r) {
        return decodeURIComponent(atob(r).split("").map((e) => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join(""));
      }, i.k = function(r) {
        return btoa(encodeURIComponent(r).replace(/%([0-9A-F]{2})/g, (e, n) => String.fromCharCode(+("0x" + n))));
      }, i.l = Pn, i.m = Gs, i.n = function(r, e) {
        return xn(Pn(r, { type: "json" }), e);
      }, i.o = Hn, i.p = function(r, e) {
        return xn(Pn(r, { method: "POST" }), e);
      }, i.q = Ct, i.r = _r, i.s = function(r) {
        try {
          const e = self[r];
          return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
        } catch {
          return !1;
        }
      }, i.t = mt, i.u = function() {
        return function r(e) {
          return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, r);
        }();
      }, i.v = function(r) {
        return !!r && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(r);
      }, i.w = mi, i.x = function() {
        return eg || (eg = new vh()), eg;
      }, i.y = Cr, i.z = Pr;
    }), b(["./shared"], function(i) {
      function O(Ke) {
        const re = Ke ? Ke.url.toString() : void 0;
        return re ? performance.getEntriesByName(re) : [];
      }
      function Z(Ke) {
        if (typeof Ke == "number" || typeof Ke == "boolean" || typeof Ke == "string" || Ke == null)
          return JSON.stringify(Ke);
        if (Array.isArray(Ke)) {
          let le = "[";
          for (const ge of Ke)
            le += `${Z(ge)},`;
          return `${le}]`;
        }
        let re = "{";
        for (const le of Object.keys(Ke).sort())
          re += `${le}:${Z(Ke[le])},`;
        return `${re}}`;
      }
      function Y(Ke) {
        let re = "";
        for (const le of i.bm)
          re += `/${Z(Ke[le])}`;
        return re;
      }
      class J {
        constructor(re) {
          this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, re && this.replace(re);
        }
        replace(re, le) {
          this._layerConfigs = {}, this._layers = {}, this.update(re, [], le);
        }
        update(re, le, ge) {
          this._options = ge;
          for (const Ce of re)
            this._layerConfigs[Ce.id] = Ce, (this._layers[Ce.id] = i.cu(Ce, this.scope, null, this._options)).compileFilter(ge), this.keyCache[Ce.id] && delete this.keyCache[Ce.id];
          for (const Ce of le)
            delete this.keyCache[Ce], delete this._layerConfigs[Ce], delete this._layers[Ce];
          this.familiesBySource = {};
          const Le = function(Ce, Be) {
            const He = {};
            for (let Ye = 0; Ye < Ce.length; Ye++) {
              const Qe = Ce[Ye];
              let it = Be && Be[Qe.id];
              !it && (it = Y(Qe), Qe.type === "line" && Qe.paint) && function Ct(It) {
                return typeof It == "string" && It === "line-progress" || (Array.isArray(It) ? It.some(Ct) : !(!It || typeof It != "object") && Object.values(It).some(Ct));
              }(Qe.paint["line-width"]) && (it += `/${Z(Qe.paint["line-width"])}`), Be && (Be[Qe.id] = it);
              let mt = He[it];
              mt || (mt = He[it] = []), mt.push(Qe);
            }
            const Ae = [];
            for (const Ye in He)
              Ae.push(He[Ye]);
            return Ae;
          }(i.bj(this._layerConfigs), this.keyCache);
          for (const Ce of Le) {
            const Be = Ce.map((mt) => this._layers[mt.id]), He = Be[0];
            if (He.visibility === "none")
              continue;
            const Ae = He.source || "";
            let Ye = this.familiesBySource[Ae];
            Ye || (Ye = this.familiesBySource[Ae] = {});
            const Qe = He.sourceLayer || "_geojsonTileLayer";
            let it = Ye[Qe];
            it || (it = Ye[Qe] = []), it.push(Be);
          }
        }
      }
      const ae = 1 * i.dX;
      class ue {
        constructor(re) {
          const le = {}, ge = [];
          for (const He in re) {
            const Ae = re[He], Ye = le[He] = {};
            for (const Qe in Ae.glyphs) {
              const it = Ae.glyphs[+Qe];
              if (!it || it.bitmap.width === 0 || it.bitmap.height === 0)
                continue;
              const mt = it.metrics.localGlyph ? ae : 1, Ct = { x: 0, y: 0, w: it.bitmap.width + 2 * mt, h: it.bitmap.height + 2 * mt };
              ge.push(Ct), Ye[Qe] = Ct;
            }
          }
          const { w: Le, h: Ce } = i.C(ge), Be = new i.dW({ width: Le || 1, height: Ce || 1 });
          for (const He in re) {
            const Ae = re[He];
            for (const Ye in Ae.glyphs) {
              const Qe = Ae.glyphs[+Ye];
              if (!Qe || Qe.bitmap.width === 0 || Qe.bitmap.height === 0)
                continue;
              const it = le[He][Ye], mt = Qe.metrics.localGlyph ? ae : 1;
              i.dW.copy(Qe.bitmap, Be, { x: 0, y: 0 }, { x: it.x + mt, y: it.y + mt }, Qe.bitmap);
            }
          }
          this.image = Be, this.positions = le;
        }
      }
      i.dV(ue, "GlyphAtlas");
      class Se {
        constructor(re) {
          this.tileID = new i.aG(re.tileID.overscaledZ, re.tileID.wrap, re.tileID.canonical.z, re.tileID.canonical.x, re.tileID.canonical.y), this.tileZoom = re.tileZoom, this.uid = re.uid, this.zoom = re.zoom, this.lut = re.lut, this.canonical = re.tileID.canonical, this.pixelRatio = re.pixelRatio, this.tileSize = re.tileSize, this.source = re.source, this.scope = re.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = re.showCollisionBoxes, this.collectResourceTiming = !!re.request && re.request.collectResourceTiming, this.promoteId = re.promoteId, this.isSymbolTile = re.isSymbolTile, this.tileTransform = i.aQ(re.tileID.canonical, re.projection), this.projection = re.projection, this.worldview = re.worldview, this.localizableLayerIds = re.localizableLayerIds, this.brightness = re.brightness, this.extraShadowCaster = !!re.extraShadowCaster, this.tessellationStep = re.tessellationStep, this.scaleFactor = re.scaleFactor;
        }
        parse(re, le, ge, Le, Ce) {
          this.status = "parsing", this.data = re, this.collisionBoxArray = new i.aW();
          const Be = new i.dY(Object.keys(re.layers).sort()), He = new i.dZ(this.tileID, this.promoteId);
          He.bucketLayerIDs = [];
          const Ae = {}, Ye = new i.d_(256, 256), Qe = { featureIndex: He, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: Ye, availableImages: ge, brightness: this.brightness, scaleFactor: this.scaleFactor }, it = le.familiesBySource[this.source];
          for (const ri in it) {
            const Ki = re.layers[ri];
            if (!Ki)
              continue;
            let Ni = !1, Ei = !1, $i = !1;
            for (const Gs of it[ri])
              Gs[0].type === "symbol" ? Ni = !0 : Ei = !0, Gs[0].is3D() && Gs[0].type !== "model" && ($i = !0);
            if (this.extraShadowCaster && !$i || this.isSymbolTile === !0 && !Ni || this.isSymbolTile === !1 && !Ei)
              continue;
            Ki.version === 1 && i.w(`Vector tile source "${this.source}" layer "${ri}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const Hi = Be.encode(ri), Xn = [];
            for (let Gs = 0, ps = 0; Gs < Ki.length; Gs++) {
              const vs = Ki.feature(Gs), sa = He.getId(vs, ri);
              if (this.localizableLayerIds && this.localizableLayerIds.has(ri)) {
                const Er = vs.properties ? vs.properties.worldview : null;
                if (this.worldview && typeof Er == "string")
                  if (Er === "all")
                    vs.properties.$localized = !0;
                  else {
                    if (!Er.split(",").includes(this.worldview))
                      continue;
                    vs.properties.$localized = !0, vs.properties.worldview = this.worldview;
                  }
              }
              Xn.push({ feature: vs, id: sa, index: ps, sourceLayerIndex: Hi }), ps++;
            }
            for (const Gs of it[ri]) {
              const ps = Gs[0];
              (!this.extraShadowCaster || ps.is3D() && ps.type !== "model") && (this.isSymbolTile !== void 0 && ps.type === "symbol" !== this.isSymbolTile || ps.minzoom && this.zoom < Math.floor(ps.minzoom) || ps.maxzoom && this.zoom >= ps.maxzoom || ps.visibility !== "none" && (we(Gs, this.zoom, Qe.brightness, ge), (Ae[ps.id] = ps.createBucket({ index: He.bucketLayerIDs.length, layers: Gs, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Hi, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep })).populate(Xn, Qe, this.tileID.canonical, this.tileTransform), He.bucketLayerIDs.push(Gs.map((vs) => i.aC(vs.id, vs.scope)))));
            }
          }
          let mt, Ct, It, Kt;
          Ye.trim();
          const di = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, li = () => {
            if (mt)
              return this.status = "done", Ce(mt);
            if (this.extraShadowCaster)
              this.status = "done", Ce(null, { buckets: i.bj(Ae).filter((ri) => !ri.isEmpty()), featureIndex: He, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: Qe.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
            else if (Ct && It && Kt) {
              const ri = new ue(Ct), Ki = new i.e1(It, Kt, this.lut);
              for (const Ni in Ae) {
                const Ei = Ae[Ni];
                Ei instanceof i.aX ? (we(Ei.layers, this.zoom, Qe.brightness, ge), i.e2(Ei, Ct, ri.positions, It, Ki.iconPositions, this.showCollisionBoxes, ge, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : Ei.hasPattern && (Ei instanceof i.b1 || Ei instanceof i.b2 || Ei instanceof i.d5) && (we(Ei.layers, this.zoom, Qe.brightness, ge), Ei.addFeatures(Qe, this.tileID.canonical, Ki.patternPositions, ge, this.tileTransform, this.brightness));
              }
              this.status = "done", Ce(null, { buckets: i.bj(Ae).filter((Ni) => !Ni.isEmpty()), featureIndex: He, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: ri.image, lineAtlas: Ye, imageAtlas: Ki, brightness: Qe.brightness });
            }
          };
          if (!this.extraShadowCaster) {
            const ri = i.d$(Qe.glyphDependencies, (Ei) => Object.keys(Ei).map(Number));
            Object.keys(ri).length ? Le.send("getGlyphs", { uid: this.uid, stacks: ri, scope: this.scope }, (Ei, $i) => {
              mt || (mt = Ei, Ct = $i, li());
            }, void 0, !1, di) : Ct = {};
            const Ki = Object.keys(Qe.iconDependencies);
            Ki.length ? Le.send("getImages", { icons: Ki, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (Ei, $i) => {
              if (mt)
                return;
              mt = Ei;
              const Hi = {};
              Object.values($i).some((Xn) => Xn.usvg) ? this.rasterize(Le, Hi, $i, Qe.iconDependencies, () => {
                It = Hi, li();
              }) : (this.fillImageMap(Hi, Qe.iconDependencies, $i), It = Hi, li());
            }, void 0, !1, di) : It = {};
            const Ni = Object.keys(Qe.patternDependencies);
            Ni.length ? Le.send("getImages", { icons: Ni, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (Ei, $i) => {
              if (!mt) {
                mt = Ei;
                const Hi = {};
                Object.values($i).some((Xn) => Xn.usvg) ? this.rasterize(Le, Hi, $i, Qe.patternDependencies, () => {
                  Kt = Hi, li();
                }) : (this.fillImageMap(Hi, Qe.patternDependencies, $i), Kt = Hi, li());
              }
            }, void 0, !1, di) : Kt = {};
          }
          li();
        }
        fillImageMap(re, le, ge) {
          for (const Le in ge) {
            const Ce = le[Le] || [];
            for (const Be of Ce)
              ge[Be.id].usvg || (re[Be.serialize()] = ge[Be.id]);
          }
        }
        getImageTaskQueue(re, le, ge) {
          const Le = {};
          for (const Ce in le) {
            const Be = ge[Ce] || [];
            for (const He of Be) {
              const Ae = He.serialize();
              le[He.id].usvg ? Le[Ae] || (Le[Ae] = He) : re[Ae] = le[He.id];
            }
          }
          return Le;
        }
        rasterize(re, le, ge, Le, Ce) {
          const Be = this.getImageTaskQueue(le, ge, Le);
          this.rasterizeTask = re.send("rasterizeImages", { scope: this.scope, imageTasks: Be }, (He, Ae) => {
            if (!He)
              for (const Ye in Ae) {
                const { id: Qe } = i.e0.deserializeFromString(Ye);
                le[Ye] = Object.assign({}, ge[Qe], { data: Ae[Ye] });
              }
            Ce();
          });
        }
        cancelRasterize() {
          this.rasterizeTask && this.rasterizeTask.cancel();
        }
      }
      function we(Ke, re, le, ge) {
        const Le = new i.a8(re, { brightness: le });
        for (const Ce of Ke)
          Ce.recalculate(Le, ge);
      }
      class qe extends i.E {
        constructor(re, le, ge, Le, Ce, Be) {
          super(), this.actor = re, this.layerIndex = le, this.availableImages = ge, this.loadVectorData = Ce || i.aD, this.loading = {}, this.loaded = {}, this.deduped = new i.aB(re.scheduler), this.isSpriteLoaded = Le, this.scheduler = re.scheduler, this.brightness = Be;
        }
        loadTile(re, le) {
          const ge = re.uid, Le = re && re.request, Ce = Le && Le.collectResourceTiming, Be = this.loading[ge] = new Se(re);
          Be.abort = this.loadVectorData(re, (He, Ae) => {
            const Ye = !this.loading[ge];
            if (delete this.loading[ge], Be.cancelRasterize(), Ye || He || !Ae)
              return Be.status = "done", Ye || (this.loaded[ge] = Be), le(He);
            const Qe = Ae.rawData, it = {};
            Ae.expires && (it.expires = Ae.expires), Ae.cacheControl && (it.cacheControl = Ae.cacheControl), Be.vectorTile = Ae.vectorTile || new i.e3.VectorTile(new i.bh(Qe));
            const mt = () => {
              Be.parse(Be.vectorTile, this.layerIndex, this.availableImages, this.actor, (Ct, It) => {
                if (Ct || !It)
                  return le(Ct);
                const Kt = {};
                if (Ce) {
                  const di = O(Le);
                  di.length > 0 && (Kt.resourceTiming = JSON.parse(JSON.stringify(di)));
                }
                le(null, i.l({ rawTileData: Qe.slice(0) }, It, it, Kt));
              });
            };
            this.isSpriteLoaded ? mt() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(mt, { type: "parseTile", isSymbolTile: re.isSymbolTile, zoom: re.tileZoom }) : mt();
            }), this.loaded = this.loaded || {}, this.loaded[ge] = Be;
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          if (ge && ge[Le]) {
            const Ce = ge[Le];
            Ce.scaleFactor = re.scaleFactor, Ce.showCollisionBoxes = re.showCollisionBoxes, Ce.projection = re.projection, Ce.brightness = re.brightness, Ce.tileTransform = i.aQ(re.tileID.canonical, re.projection), Ce.extraShadowCaster = re.extraShadowCaster, Ce.lut = re.lut;
            const Be = (He, Ae) => {
              const Ye = Ce.reloadCallback;
              Ye && (delete Ce.reloadCallback, Ce.parse(Ce.vectorTile, this.layerIndex, this.availableImages, this.actor, Ye)), le(He, Ae);
            };
            Ce.status === "parsing" ? Ce.reloadCallback = Be : Ce.status === "done" && (Ce.vectorTile ? Ce.parse(Ce.vectorTile, this.layerIndex, this.availableImages, this.actor, Be) : Be());
          } else
            le(null, void 0);
        }
        abortTile(re, le) {
          const ge = re.uid, Le = this.loading[ge];
          Le && (Le.abort && Le.abort(), delete this.loading[ge]), le();
        }
        removeTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          ge && ge[Le] && delete ge[Le], le();
        }
      }
      class Ge {
        loadTile(re, le) {
          const { uid: ge, encoding: Le, rawImageData: Ce, padding: Be } = re, He = ImageBitmap && Ce instanceof ImageBitmap ? this.getImageData(Ce, Be) : Ce;
          le(null, new i.e4(ge, He, Le, Be < 1));
        }
        getImageData(re, le) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(re.width, re.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: !0 })), this.offscreenCanvas.width = re.width, this.offscreenCanvas.height = re.height, this.offscreenCanvasContext.drawImage(re, 0, 0, re.width, re.height);
          const ge = this.offscreenCanvasContext.getImageData(-le, -le, re.width + 2 * le, re.height + 2 * le);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), ge;
        }
      }
      i.bg.setPbf(i.bh);
      class lt {
        decodeRasterArray({ task: re, buffer: le }, ge) {
          i.bg.performDecoding(le, re).then((Le) => {
            ge(null, Le);
          }, (Le) => {
            ge(Le);
          });
        }
      }
      const Et = i.e3.VectorTileFeature.prototype.toGeoJSON;
      class ut {
        constructor(re) {
          this._feature = re, this.extent = i.ag, this.type = re.type, this.properties = re.tags, "id" in re && !isNaN(re.id) && (this.id = parseInt(re.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const re = [];
            for (const le of this._feature.geometry)
              re.push([new i.P(le[0], le[1])]);
            return re;
          }
          {
            const re = [];
            for (const le of this._feature.geometry) {
              const ge = [];
              for (const Le of le)
                ge.push(new i.P(Le[0], Le[1]));
              re.push(ge);
            }
            return re;
          }
        }
        toGeoJSON(re, le, ge) {
          return Et.call(this, re, le, ge);
        }
      }
      class bt {
        constructor(re) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = i.ag, this.length = re.length, this._features = re;
        }
        feature(re) {
          return new ut(this._features[re]);
        }
      }
      const Vt = 64 / 4096, pt = 128;
      class Gt {
        constructor() {
          this.features = /* @__PURE__ */ new Map();
        }
        clear() {
          this.features.clear();
        }
        load(re = [], le) {
          for (const ge of re) {
            const Le = ge.id;
            if (Le == null)
              continue;
            let Ce = this.features.get(Le);
            Ce && this.updateCache(Ce, le), ge.geometry ? (Ce = kt(ge), this.updateCache(Ce, le), this.features.set(Le, Ce)) : this.features.delete(Le), this.updateCache(Ce, le);
          }
        }
        updateCache(re, le) {
          for (const { canonical: ge, uid: Le } of Object.values(le)) {
            const { z: Ce, x: Be, y: He } = ge;
            ui(re, Math.pow(2, Ce), Be, He) && delete le[Le];
          }
        }
        getTile(re, le, ge) {
          const Le = Math.pow(2, re), Ce = [];
          for (const Be of this.features.values())
            ui(Be, Le, le, ge) && Ce.push(hn(Be, Le, le, ge));
          return { features: Ce };
        }
        getFeatures() {
          return [...this.features.values()];
        }
      }
      function ui({ minX: Ke, minY: re, maxX: le, maxY: ge }, Le, Ce, Be) {
        return Ke < (Ce + 1 + Vt) / Le && re < (Be + 1 + Vt) / Le && le > (Ce - Vt) / Le && ge > (Be - Vt) / Le;
      }
      function kt(Ke) {
        const { id: re, geometry: le, properties: ge } = Ke;
        if (!le)
          return;
        if (le.type === "GeometryCollection")
          throw new Error("GeometryCollection not supported in dynamic mode.");
        const { type: Le, coordinates: Ce } = le, Be = { id: re, type: 1, geometry: [], tags: ge, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, He = Be.geometry;
        if (Le === "Point")
          At(Ce, He, Be);
        else if (Le === "MultiPoint")
          for (const Ae of Ce)
            At(Ae, He, Be);
        else if (Le === "LineString")
          Be.type = 2, Si(Ce, He, Be);
        else if (Le === "MultiLineString")
          Be.type = 2, An(Ce, He, Be);
        else if (Le === "Polygon")
          Be.type = 3, An(Ce, He, Be, !0);
        else {
          if (Le !== "MultiPolygon")
            throw new Error("Input data is not a valid GeoJSON object.");
          Be.type = 3;
          for (const Ae of Ce)
            An(Ae, He, Be, !0);
        }
        return Be;
      }
      function At([Ke, re], le, ge) {
        const Le = i.at(Ke);
        let Ce = i.aA(re);
        Ce = Ce < 0 ? 0 : Ce > 1 ? 1 : Ce, le.push(Le, Ce), ge.minX = Math.min(ge.minX, Le), ge.minY = Math.min(ge.minY, Ce), ge.maxX = Math.max(ge.maxX, Le), ge.maxY = Math.max(ge.maxY, Ce);
      }
      function Si(Ke, re, le, ge = !1, Le = !1) {
        const Ce = [];
        for (const Be of Ke)
          At(Be, Ce, le);
        re.push(Ce), ge && function(Be, He) {
          let Ae = 0;
          for (let Ye = 0, Qe = Be.length, it = Qe - 2; Ye < Qe; it = Ye, Ye += 2)
            Ae += (Be[Ye] - Be[it]) * (Be[Ye + 1] + Be[it + 1]);
          if (Ae > 0 === He)
            for (let Ye = 0, Qe = Be.length; Ye < Qe / 2; Ye += 2) {
              const it = Be[Ye], mt = Be[Ye + 1];
              Be[Ye] = Be[Qe - 2 - Ye], Be[Ye + 1] = Be[Qe - 1 - Ye], Be[Qe - 2 - Ye] = it, Be[Qe - 1 - Ye] = mt;
            }
        }(Ce, Le);
      }
      function An(Ke, re, le, ge = !1) {
        for (let Le = 0; Le < Ke.length; Le++)
          Si(Ke[Le], re, le, ge, Le === 0);
      }
      function hn(Ke, re, le, ge) {
        const { id: Le, type: Ce, geometry: Be, tags: He } = Ke, Ae = [];
        if (Ce === 1)
          (function(Ye, Qe, it, mt, Ct) {
            for (let It = 0; It < Ye.length; It += 2) {
              const Kt = Math.round(i.ag * (Ye[It + 0] * Qe - it)), di = Math.round(i.ag * (Ye[It + 1] * Qe - mt));
              Ct.push([Kt, di]);
            }
          })(Be, re, le, ge, Ae);
        else
          for (const Ye of Be)
            Ht(Ye, re, le, ge, Ae);
        return { id: Le, type: Ce, geometry: Ae, tags: He };
      }
      function Ht(Ke, re, le, ge, Le) {
        const Ce = -pt, Be = i.ag + pt;
        let He;
        for (let Ae = 0; Ae < Ke.length - 2; Ae += 2) {
          let Ye = Math.round(i.ag * (Ke[Ae + 0] * re - le)), Qe = Math.round(i.ag * (Ke[Ae + 1] * re - ge)), it = Math.round(i.ag * (Ke[Ae + 2] * re - le)), mt = Math.round(i.ag * (Ke[Ae + 3] * re - ge));
          const Ct = it - Ye, It = mt - Qe;
          Ye < Ce && it < Ce || (Ye < Ce ? (Qe += Math.round(It * ((Ce - Ye) / Ct)), Ye = Ce) : it < Ce && (mt = Qe + Math.round(It * ((Ce - Ye) / Ct)), it = Ce), Qe < Ce && mt < Ce || (Qe < Ce ? (Ye += Math.round(Ct * ((Ce - Qe) / It)), Qe = Ce) : mt < Ce && (it = Ye + Math.round(Ct * ((Ce - Qe) / It)), mt = Ce), Ye >= Be && it >= Be || (Ye >= Be ? (Qe += Math.round(It * ((Be - Ye) / Ct)), Ye = Be) : it >= Be && (mt = Qe + Math.round(It * ((Be - Ye) / Ct)), it = Be), Qe >= Be && mt >= Be || (Qe >= Be ? (Ye += Math.round(Ct * ((Be - Qe) / It)), Qe = Be) : mt >= Be && (it = Ye + Math.round(Ct * ((Be - Qe) / It)), mt = Be), He && Ye === He[He.length - 1][0] && Qe === He[He.length - 1][1] || (He = [[Ye, Qe]], Le.push(He)), He.push([it, mt])))));
        }
      }
      var Mi, Ji, fi, jt = { exports: {} }, ni = function() {
        if (fi)
          return jt.exports;
        fi = 1;
        var Ke = i.e7(), re = function() {
          if (Ji)
            return Mi;
          Ji = 1;
          var Qe = i.e5(), it = i.e6().VectorTileFeature;
          function mt(It, Kt) {
            this.options = Kt || {}, this.features = It, this.length = It.length;
          }
          function Ct(It, Kt) {
            this.id = typeof It.id == "number" ? It.id : void 0, this.type = It.type, this.rawGeometry = It.type === 1 ? [It.geometry] : It.geometry, this.properties = It.tags, this.extent = Kt || 4096;
          }
          return Mi = mt, mt.prototype.feature = function(It) {
            return new Ct(this.features[It], this.options.extent);
          }, Ct.prototype.loadGeometry = function() {
            var It = this.rawGeometry;
            this.geometry = [];
            for (var Kt = 0; Kt < It.length; Kt++) {
              for (var di = It[Kt], li = [], ri = 0; ri < di.length; ri++)
                li.push(new Qe(di[ri][0], di[ri][1]));
              this.geometry.push(li);
            }
            return this.geometry;
          }, Ct.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var It = this.geometry, Kt = 1 / 0, di = -1 / 0, li = 1 / 0, ri = -1 / 0, Ki = 0; Ki < It.length; Ki++)
              for (var Ni = It[Ki], Ei = 0; Ei < Ni.length; Ei++) {
                var $i = Ni[Ei];
                Kt = Math.min(Kt, $i.x), di = Math.max(di, $i.x), li = Math.min(li, $i.y), ri = Math.max(ri, $i.y);
              }
            return [Kt, li, di, ri];
          }, Ct.prototype.toGeoJSON = it.prototype.toGeoJSON, Mi;
        }();
        function le(Qe) {
          var it = new Ke();
          return function(mt, Ct) {
            for (var It in mt.layers)
              Ct.writeMessage(3, ge, mt.layers[It]);
          }(Qe, it), it.finish();
        }
        function ge(Qe, it) {
          var mt;
          it.writeVarintField(15, Qe.version || 1), it.writeStringField(1, Qe.name || ""), it.writeVarintField(5, Qe.extent || 4096);
          var Ct = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (mt = 0; mt < Qe.length; mt++)
            Ct.feature = Qe.feature(mt), it.writeMessage(2, Le, Ct);
          var It = Ct.keys;
          for (mt = 0; mt < It.length; mt++)
            it.writeStringField(3, It[mt]);
          var Kt = Ct.values;
          for (mt = 0; mt < Kt.length; mt++)
            it.writeMessage(4, Ye, Kt[mt]);
        }
        function Le(Qe, it) {
          var mt = Qe.feature;
          mt.id !== void 0 && it.writeVarintField(1, mt.id), it.writeMessage(2, Ce, Qe), it.writeVarintField(3, mt.type), it.writeMessage(4, Ae, mt);
        }
        function Ce(Qe, it) {
          var mt = Qe.feature, Ct = Qe.keys, It = Qe.values, Kt = Qe.keycache, di = Qe.valuecache;
          for (var li in mt.properties) {
            var ri = mt.properties[li], Ki = Kt[li];
            if (ri !== null) {
              Ki === void 0 && (Ct.push(li), Kt[li] = Ki = Ct.length - 1), it.writeVarint(Ki);
              var Ni = typeof ri;
              Ni !== "string" && Ni !== "boolean" && Ni !== "number" && (ri = JSON.stringify(ri));
              var Ei = Ni + ":" + ri, $i = di[Ei];
              $i === void 0 && (It.push(ri), di[Ei] = $i = It.length - 1), it.writeVarint($i);
            }
          }
        }
        function Be(Qe, it) {
          return (it << 3) + (7 & Qe);
        }
        function He(Qe) {
          return Qe << 1 ^ Qe >> 31;
        }
        function Ae(Qe, it) {
          for (var mt = Qe.loadGeometry(), Ct = Qe.type, It = 0, Kt = 0, di = mt.length, li = 0; li < di; li++) {
            var ri = mt[li], Ki = 1;
            Ct === 1 && (Ki = ri.length), it.writeVarint(Be(1, Ki));
            for (var Ni = Ct === 3 ? ri.length - 1 : ri.length, Ei = 0; Ei < Ni; Ei++) {
              Ei === 1 && Ct !== 1 && it.writeVarint(Be(2, Ni - 1));
              var $i = ri[Ei].x - It, Hi = ri[Ei].y - Kt;
              it.writeVarint(He($i)), it.writeVarint(He(Hi)), It += $i, Kt += Hi;
            }
            Ct === 3 && it.writeVarint(Be(7, 1));
          }
        }
        function Ye(Qe, it) {
          var mt = typeof Qe;
          mt === "string" ? it.writeStringField(1, Qe) : mt === "boolean" ? it.writeBooleanField(7, Qe) : mt === "number" && (Qe % 1 != 0 ? it.writeDoubleField(3, Qe) : Qe < 0 ? it.writeSVarintField(6, Qe) : it.writeVarintField(5, Qe));
        }
        return jt.exports = le, jt.exports.fromVectorTileJs = le, jt.exports.fromGeojsonVt = function(Qe, it) {
          it = it || {};
          var mt = {};
          for (var Ct in Qe)
            mt[Ct] = new re(Qe[Ct].features, it), mt[Ct].name = Ct, mt[Ct].version = it.version, mt[Ct].extent = it.extent;
          return le({ layers: mt });
        }, jt.exports.GeoJSONWrapper = re, jt.exports;
      }(), Gi = i.e8(ni);
      const an = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (Ke) => Ke }, qt = Math.fround || (ln = new Float32Array(1), (Ke) => (ln[0] = +Ke, ln[0]));
      var ln;
      const Di = 3, xi = 5, Cs = 6;
      class xs {
        constructor(re) {
          this.options = Object.assign(Object.create(an), re), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(re) {
          const { log: le, minZoom: ge, maxZoom: Le } = this.options;
          le && console.time("total time");
          const Ce = `prepare ${re.length} points`;
          le && console.time(Ce), this.points = re;
          const Be = [];
          for (let Ae = 0; Ae < re.length; Ae++) {
            const Ye = re[Ae];
            if (!Ye.geometry)
              continue;
            const [Qe, it] = Ye.geometry.coordinates, mt = qt(Vs(Qe)), Ct = qt(Us(it));
            Be.push(mt, Ct, 1 / 0, Ae, -1, 1), this.options.reduce && Be.push(0);
          }
          let He = this.trees[Le + 1] = this._createTree(Be);
          le && console.timeEnd(Ce);
          for (let Ae = Le; Ae >= ge; Ae--) {
            const Ye = +Date.now();
            He = this.trees[Ae] = this._createTree(this._cluster(He, Ae)), le && console.log("z%d: %d clusters in %dms", Ae, He.numItems, +Date.now() - Ye);
          }
          return le && console.timeEnd("total time"), this;
        }
        getClusters(re, le) {
          let ge = ((re[0] + 180) % 360 + 360) % 360 - 180;
          const Le = Math.max(-90, Math.min(90, re[1]));
          let Ce = re[2] === 180 ? 180 : ((re[2] + 180) % 360 + 360) % 360 - 180;
          const Be = Math.max(-90, Math.min(90, re[3]));
          if (re[2] - re[0] >= 360)
            ge = -180, Ce = 180;
          else if (ge > Ce) {
            const it = this.getClusters([ge, Le, 180, Be], le), mt = this.getClusters([-180, Le, Ce, Be], le);
            return it.concat(mt);
          }
          const He = this.trees[this._limitZoom(le)], Ae = He.range(Vs(ge), Us(Be), Vs(Ce), Us(Le)), Ye = He.data, Qe = [];
          for (const it of Ae) {
            const mt = this.stride * it;
            Qe.push(Ye[mt + xi] > 1 ? Is(Ye, mt, this.clusterProps) : this.points[Ye[mt + Di]]);
          }
          return Qe;
        }
        getChildren(re) {
          const le = this._getOriginId(re), ge = this._getOriginZoom(re), Le = "No cluster with the specified id.", Ce = this.trees[ge];
          if (!Ce)
            throw new Error(Le);
          const Be = Ce.data;
          if (le * this.stride >= Be.length)
            throw new Error(Le);
          const He = this.options.radius / (this.options.extent * Math.pow(2, ge - 1)), Ae = Ce.within(Be[le * this.stride], Be[le * this.stride + 1], He), Ye = [];
          for (const Qe of Ae) {
            const it = Qe * this.stride;
            Be[it + 4] === re && Ye.push(Be[it + xi] > 1 ? Is(Be, it, this.clusterProps) : this.points[Be[it + Di]]);
          }
          if (Ye.length === 0)
            throw new Error(Le);
          return Ye;
        }
        getLeaves(re, le, ge) {
          const Le = [];
          return this._appendLeaves(Le, re, le = le || 10, ge = ge || 0, 0), Le;
        }
        getTile(re, le, ge) {
          const Le = this.trees[this._limitZoom(re)], Ce = Math.pow(2, re), { extent: Be, radius: He } = this.options, Ae = He / Be, Ye = (ge - Ae) / Ce, Qe = (ge + 1 + Ae) / Ce, it = { features: [] };
          return this._addTileFeatures(Le.range((le - Ae) / Ce, Ye, (le + 1 + Ae) / Ce, Qe), Le.data, le, ge, Ce, it), le === 0 && this._addTileFeatures(Le.range(1 - Ae / Ce, Ye, 1, Qe), Le.data, Ce, ge, Ce, it), le === Ce - 1 && this._addTileFeatures(Le.range(0, Ye, Ae / Ce, Qe), Le.data, -1, ge, Ce, it), it.features.length ? it : null;
        }
        getClusterExpansionZoom(re) {
          let le = this._getOriginZoom(re) - 1;
          for (; le <= this.options.maxZoom; ) {
            const ge = this.getChildren(re);
            if (le++, ge.length !== 1)
              break;
            re = ge[0].properties.cluster_id;
          }
          return le;
        }
        _appendLeaves(re, le, ge, Le, Ce) {
          const Be = this.getChildren(le);
          for (const He of Be) {
            const Ae = He.properties;
            if (Ae && Ae.cluster ? Ce + Ae.point_count <= Le ? Ce += Ae.point_count : Ce = this._appendLeaves(re, Ae.cluster_id, ge, Le, Ce) : Ce < Le ? Ce++ : re.push(He), re.length === ge)
              break;
          }
          return Ce;
        }
        _createTree(re) {
          const le = new i.bE(re.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let ge = 0; ge < re.length; ge += this.stride)
            le.add(re[ge], re[ge + 1]);
          return le.finish(), le.data = re, le;
        }
        _addTileFeatures(re, le, ge, Le, Ce, Be) {
          for (const He of re) {
            const Ae = He * this.stride, Ye = le[Ae + xi] > 1;
            let Qe, it, mt;
            if (Ye)
              Qe = De(le, Ae, this.clusterProps), it = le[Ae], mt = le[Ae + 1];
            else {
              const Kt = this.points[le[Ae + Di]];
              Qe = Kt.properties;
              const [di, li] = Kt.geometry.coordinates;
              it = Vs(di), mt = Us(li);
            }
            const Ct = { type: 1, geometry: [[Math.round(this.options.extent * (it * Ce - ge)), Math.round(this.options.extent * (mt * Ce - Le))]], tags: Qe };
            let It;
            It = Ye || this.options.generateId ? le[Ae + Di] : this.points[le[Ae + Di]].id, It !== void 0 && (Ct.id = It), Be.features.push(Ct);
          }
        }
        _limitZoom(re) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+re), this.options.maxZoom + 1));
        }
        _cluster(re, le) {
          const { radius: ge, extent: Le, reduce: Ce, minPoints: Be } = this.options, He = ge / (Le * Math.pow(2, le)), Ae = re.data, Ye = [], Qe = this.stride;
          for (let it = 0; it < Ae.length; it += Qe) {
            if (Ae[it + 2] <= le)
              continue;
            Ae[it + 2] = le;
            const mt = Ae[it], Ct = Ae[it + 1], It = re.within(Ae[it], Ae[it + 1], He), Kt = Ae[it + xi];
            let di = Kt;
            for (const li of It) {
              const ri = li * Qe;
              Ae[ri + 2] > le && (di += Ae[ri + xi]);
            }
            if (di > Kt && di >= Be) {
              let li, ri = mt * Kt, Ki = Ct * Kt, Ni = -1;
              const Ei = (it / Qe << 5) + (le + 1) + this.points.length;
              for (const $i of It) {
                const Hi = $i * Qe;
                if (Ae[Hi + 2] <= le)
                  continue;
                Ae[Hi + 2] = le;
                const Xn = Ae[Hi + xi];
                ri += Ae[Hi] * Xn, Ki += Ae[Hi + 1] * Xn, Ae[Hi + 4] = Ei, Ce && (li || (li = this._map(Ae, it, !0), Ni = this.clusterProps.length, this.clusterProps.push(li)), Ce(li, this._map(Ae, Hi)));
              }
              Ae[it + 4] = Ei, Ye.push(ri / di, Ki / di, 1 / 0, Ei, -1, di), Ce && Ye.push(Ni);
            } else {
              for (let li = 0; li < Qe; li++)
                Ye.push(Ae[it + li]);
              if (di > 1)
                for (const li of It) {
                  const ri = li * Qe;
                  if (!(Ae[ri + 2] <= le)) {
                    Ae[ri + 2] = le;
                    for (let Ki = 0; Ki < Qe; Ki++)
                      Ye.push(Ae[ri + Ki]);
                  }
                }
            }
          }
          return Ye;
        }
        _getOriginId(re) {
          return re - this.points.length >> 5;
        }
        _getOriginZoom(re) {
          return (re - this.points.length) % 32;
        }
        _map(re, le, ge) {
          if (re[le + xi] > 1) {
            const Be = this.clusterProps[re[le + Cs]];
            return ge ? Object.assign({}, Be) : Be;
          }
          const Le = this.points[re[le + Di]].properties, Ce = this.options.map(Le);
          return ge && Ce === Le ? Object.assign({}, Ce) : Ce;
        }
      }
      function Is(Ke, re, le) {
        return { type: "Feature", id: Ke[re + Di], properties: De(Ke, re, le), geometry: { type: "Point", coordinates: [(ge = Ke[re], 360 * (ge - 0.5)), Zr(Ke[re + 1])] } };
        var ge;
      }
      function De(Ke, re, le) {
        const ge = Ke[re + xi], Le = ge >= 1e4 ? `${Math.round(ge / 1e3)}k` : ge >= 1e3 ? Math.round(ge / 100) / 10 + "k" : ge, Ce = Ke[re + Cs], Be = Ce === -1 ? {} : Object.assign({}, le[Ce]);
        return Object.assign(Be, { cluster: !0, cluster_id: Ke[re + Di], point_count: ge, point_count_abbreviated: Le });
      }
      function Vs(Ke) {
        return Ke / 360 + 0.5;
      }
      function Us(Ke) {
        const re = Math.sin(Ke * Math.PI / 180), le = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
        return le < 0 ? 0 : le > 1 ? 1 : le;
      }
      function Zr(Ke) {
        const re = (180 - 360 * Ke) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(re)) / Math.PI - 90;
      }
      function Mt(Ke, re, le, ge) {
        let Le = ge;
        const Ce = re + (le - re >> 1);
        let Be, He = le - re;
        const Ae = Ke[re], Ye = Ke[re + 1], Qe = Ke[le], it = Ke[le + 1];
        for (let mt = re + 3; mt < le; mt += 3) {
          const Ct = ir(Ke[mt], Ke[mt + 1], Ae, Ye, Qe, it);
          if (Ct > Le)
            Be = mt, Le = Ct;
          else if (Ct === Le) {
            const It = Math.abs(mt - Ce);
            It < He && (Be = mt, He = It);
          }
        }
        Le > ge && (Be - re > 3 && Mt(Ke, re, Be, ge), Ke[Be + 2] = Le, le - Be > 3 && Mt(Ke, Be, le, ge));
      }
      function ir(Ke, re, le, ge, Le, Ce) {
        let Be = Le - le, He = Ce - ge;
        if (Be !== 0 || He !== 0) {
          const Ae = ((Ke - le) * Be + (re - ge) * He) / (Be * Be + He * He);
          Ae > 1 ? (le = Le, ge = Ce) : Ae > 0 && (le += Be * Ae, ge += He * Ae);
        }
        return Be = Ke - le, He = re - ge, Be * Be + He * He;
      }
      function $n(Ke, re, le, ge) {
        const Le = { id: Ke ?? null, type: re, geometry: le, tags: ge, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (re === "Point" || re === "MultiPoint" || re === "LineString")
          Ws(Le, le);
        else if (re === "Polygon")
          Ws(Le, le[0]);
        else if (re === "MultiLineString")
          for (const Ce of le)
            Ws(Le, Ce);
        else if (re === "MultiPolygon")
          for (const Ce of le)
            Ws(Le, Ce[0]);
        return Le;
      }
      function Ws(Ke, re) {
        for (let le = 0; le < re.length; le += 3)
          Ke.minX = Math.min(Ke.minX, re[le]), Ke.minY = Math.min(Ke.minY, re[le + 1]), Ke.maxX = Math.max(Ke.maxX, re[le]), Ke.maxY = Math.max(Ke.maxY, re[le + 1]);
      }
      function vi(Ke, re, le, ge) {
        if (!re.geometry)
          return;
        const Le = re.geometry.coordinates;
        if (Le && Le.length === 0)
          return;
        const Ce = re.geometry.type, Be = Math.pow(le.tolerance / ((1 << le.maxZoom) * le.extent), 2);
        let He = [], Ae = re.id;
        if (le.promoteId ? Ae = re.properties[le.promoteId] : le.generateId && (Ae = ge || 0), Ce === "Point")
          kn(Le, He);
        else if (Ce === "MultiPoint")
          for (const Ye of Le)
            kn(Ye, He);
        else if (Ce === "LineString")
          $s(Le, He, Be, !1);
        else if (Ce === "MultiLineString") {
          if (le.lineMetrics) {
            for (const Ye of Le)
              He = [], $s(Ye, He, Be, !1), Ke.push($n(Ae, "LineString", He, re.properties));
            return;
          }
          Hr(Le, He, Be, !1);
        } else if (Ce === "Polygon")
          Hr(Le, He, Be, !0);
        else {
          if (Ce !== "MultiPolygon") {
            if (Ce === "GeometryCollection") {
              for (const Ye of re.geometry.geometries)
                vi(Ke, { id: Ae, geometry: Ye, properties: re.properties }, le, ge);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const Ye of Le) {
            const Qe = [];
            Hr(Ye, Qe, Be, !0), He.push(Qe);
          }
        }
        Ke.push($n(Ae, Ce, He, re.properties));
      }
      function kn(Ke, re) {
        re.push(qr(Ke[0]), Wr(Ke[1]), 0);
      }
      function $s(Ke, re, le, ge) {
        let Le, Ce, Be = 0;
        for (let Ae = 0; Ae < Ke.length; Ae++) {
          const Ye = qr(Ke[Ae][0]), Qe = Wr(Ke[Ae][1]);
          re.push(Ye, Qe, 0), Ae > 0 && (Be += ge ? (Le * Qe - Ye * Ce) / 2 : Math.sqrt(Math.pow(Ye - Le, 2) + Math.pow(Qe - Ce, 2))), Le = Ye, Ce = Qe;
        }
        const He = re.length - 3;
        re[2] = 1, Mt(re, 0, He, le), re[He + 2] = 1, re.size = Math.abs(Be), re.start = 0, re.end = re.size;
      }
      function Hr(Ke, re, le, ge) {
        for (let Le = 0; Le < Ke.length; Le++) {
          const Ce = [];
          $s(Ke[Le], Ce, le, ge), re.push(Ce);
        }
      }
      function qr(Ke) {
        return Ke / 360 + 0.5;
      }
      function Wr(Ke) {
        const re = Math.sin(Ke * Math.PI / 180), le = 0.5 - 0.25 * Math.log((1 + re) / (1 - re)) / Math.PI;
        return le < 0 ? 0 : le > 1 ? 1 : le;
      }
      function si(Ke, re, le, ge, Le, Ce, Be, He) {
        if (ge /= re, Ce >= (le /= re) && Be < ge)
          return Ke;
        if (Be < le || Ce >= ge)
          return null;
        const Ae = [];
        for (const Ye of Ke) {
          const Qe = Ye.geometry;
          let it = Ye.type;
          const mt = Le === 0 ? Ye.minX : Ye.minY, Ct = Le === 0 ? Ye.maxX : Ye.maxY;
          if (mt >= le && Ct < ge) {
            Ae.push(Ye);
            continue;
          }
          if (Ct < le || mt >= ge)
            continue;
          let It = [];
          if (it === "Point" || it === "MultiPoint")
            fs(Qe, It, le, ge, Le);
          else if (it === "LineString")
            zn(Qe, It, le, ge, Le, !1, He.lineMetrics);
          else if (it === "MultiLineString")
            Pn(Qe, It, le, ge, Le, !1);
          else if (it === "Polygon")
            Pn(Qe, It, le, ge, Le, !0);
          else if (it === "MultiPolygon")
            for (const Kt of Qe) {
              const di = [];
              Pn(Kt, di, le, ge, Le, !0), di.length && It.push(di);
            }
          if (It.length) {
            if (He.lineMetrics && it === "LineString") {
              for (const Kt of It)
                Ae.push($n(Ye.id, it, Kt, Ye.tags));
              continue;
            }
            it !== "LineString" && it !== "MultiLineString" || (It.length === 1 ? (it = "LineString", It = It[0]) : it = "MultiLineString"), it !== "Point" && it !== "MultiPoint" || (it = It.length === 3 ? "Point" : "MultiPoint"), Ae.push($n(Ye.id, it, It, Ye.tags));
          }
        }
        return Ae.length ? Ae : null;
      }
      function fs(Ke, re, le, ge, Le) {
        for (let Ce = 0; Ce < Ke.length; Ce += 3) {
          const Be = Ke[Ce + Le];
          Be >= le && Be <= ge && js(re, Ke[Ce], Ke[Ce + 1], Ke[Ce + 2]);
        }
      }
      function zn(Ke, re, le, ge, Le, Ce, Be) {
        let He = Rn(Ke);
        const Ae = Le === 0 ? go : yo;
        let Ye, Qe, it = Ke.start;
        for (let di = 0; di < Ke.length - 3; di += 3) {
          const li = Ke[di], ri = Ke[di + 1], Ki = Ke[di + 2], Ni = Ke[di + 3], Ei = Ke[di + 4], $i = Le === 0 ? li : ri, Hi = Le === 0 ? Ni : Ei;
          let Xn = !1;
          Be && (Ye = Math.sqrt(Math.pow(li - Ni, 2) + Math.pow(ri - Ei, 2))), $i < le ? Hi > le && (Qe = Ae(He, li, ri, Ni, Ei, le), Be && (He.start = it + Ye * Qe)) : $i > ge ? Hi < ge && (Qe = Ae(He, li, ri, Ni, Ei, ge), Be && (He.start = it + Ye * Qe)) : js(He, li, ri, Ki), Hi < le && $i >= le && (Qe = Ae(He, li, ri, Ni, Ei, le), Xn = !0), Hi > ge && $i <= ge && (Qe = Ae(He, li, ri, Ni, Ei, ge), Xn = !0), !Ce && Xn && (Be && (He.end = it + Ye * Qe), re.push(He), He = Rn(Ke)), Be && (it += Ye);
        }
        let mt = Ke.length - 3;
        const Ct = Ke[mt], It = Ke[mt + 1], Kt = Le === 0 ? Ct : It;
        Kt >= le && Kt <= ge && js(He, Ct, It, Ke[mt + 2]), mt = He.length - 3, Ce && mt >= 3 && (He[mt] !== He[0] || He[mt + 1] !== He[1]) && js(He, He[0], He[1], He[2]), He.length && re.push(He);
      }
      function Rn(Ke) {
        const re = [];
        return re.size = Ke.size, re.start = Ke.start, re.end = Ke.end, re;
      }
      function Pn(Ke, re, le, ge, Le, Ce) {
        for (const Be of Ke)
          zn(Be, re, le, ge, Le, Ce, !1);
      }
      function js(Ke, re, le, ge) {
        Ke.push(re, le, ge);
      }
      function go(Ke, re, le, ge, Le, Ce) {
        const Be = (Ce - re) / (ge - re);
        return js(Ke, Ce, le + (Le - le) * Be, 1), Be;
      }
      function yo(Ke, re, le, ge, Le, Ce) {
        const Be = (Ce - le) / (Le - le);
        return js(Ke, re + (ge - re) * Be, Ce, 1), Be;
      }
      function xo(Ke, re) {
        const le = [];
        for (let ge = 0; ge < Ke.length; ge++) {
          const Le = Ke[ge], Ce = Le.type;
          let Be;
          if (Ce === "Point" || Ce === "MultiPoint" || Ce === "LineString")
            Be = yr(Le.geometry, re);
          else if (Ce === "MultiLineString" || Ce === "Polygon") {
            Be = [];
            for (const He of Le.geometry)
              Be.push(yr(He, re));
          } else if (Ce === "MultiPolygon") {
            Be = [];
            for (const He of Le.geometry) {
              const Ae = [];
              for (const Ye of He)
                Ae.push(yr(Ye, re));
              Be.push(Ae);
            }
          }
          le.push($n(Le.id, Ce, Be, Le.tags));
        }
        return le;
      }
      function yr(Ke, re) {
        const le = [];
        le.size = Ke.size, Ke.start !== void 0 && (le.start = Ke.start, le.end = Ke.end);
        for (let ge = 0; ge < Ke.length; ge += 3)
          le.push(Ke[ge] + re, Ke[ge + 1], Ke[ge + 2]);
        return le;
      }
      function Sr(Ke, re) {
        if (Ke.transformed)
          return Ke;
        const le = 1 << Ke.z, ge = Ke.x, Le = Ke.y;
        for (const Ce of Ke.features) {
          const Be = Ce.geometry, He = Ce.type;
          if (Ce.geometry = [], He === 1)
            for (let Ae = 0; Ae < Be.length; Ae += 2)
              Ce.geometry.push(io(Be[Ae], Be[Ae + 1], re, le, ge, Le));
          else
            for (let Ae = 0; Ae < Be.length; Ae++) {
              const Ye = [];
              for (let Qe = 0; Qe < Be[Ae].length; Qe += 2)
                Ye.push(io(Be[Ae][Qe], Be[Ae][Qe + 1], re, le, ge, Le));
              Ce.geometry.push(Ye);
            }
        }
        return Ke.transformed = !0, Ke;
      }
      function io(Ke, re, le, ge, Le, Ce) {
        return [Math.round(le * (Ke * ge - Le)), Math.round(le * (re * ge - Ce))];
      }
      function Xs(Ke, re, le, ge, Le) {
        const Ce = re === Le.maxZoom ? 0 : Le.tolerance / ((1 << re) * Le.extent), Be = { features: [], numPoints: 0, numSimplified: 0, numFeatures: Ke.length, source: null, x: le, y: ge, z: re, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const He of Ke)
          Mr(Be, He, Ce, Le);
        return Be;
      }
      function Mr(Ke, re, le, ge) {
        const Le = re.geometry, Ce = re.type, Be = [];
        if (Ke.minX = Math.min(Ke.minX, re.minX), Ke.minY = Math.min(Ke.minY, re.minY), Ke.maxX = Math.max(Ke.maxX, re.maxX), Ke.maxY = Math.max(Ke.maxY, re.maxY), Ce === "Point" || Ce === "MultiPoint")
          for (let He = 0; He < Le.length; He += 3)
            Be.push(Le[He], Le[He + 1]), Ke.numPoints++, Ke.numSimplified++;
        else if (Ce === "LineString")
          mi(Be, Le, Ke, le, !1, !1);
        else if (Ce === "MultiLineString" || Ce === "Polygon")
          for (let He = 0; He < Le.length; He++)
            mi(Be, Le[He], Ke, le, Ce === "Polygon", He === 0);
        else if (Ce === "MultiPolygon")
          for (let He = 0; He < Le.length; He++) {
            const Ae = Le[He];
            for (let Ye = 0; Ye < Ae.length; Ye++)
              mi(Be, Ae[Ye], Ke, le, !0, Ye === 0);
          }
        if (Be.length) {
          let He = re.tags || null;
          if (Ce === "LineString" && ge.lineMetrics) {
            He = {};
            for (const Ye in re.tags)
              He[Ye] = re.tags[Ye];
            He.mapbox_clip_start = Le.start / Le.size, He.mapbox_clip_end = Le.end / Le.size;
          }
          const Ae = { geometry: Be, type: Ce === "Polygon" || Ce === "MultiPolygon" ? 3 : Ce === "LineString" || Ce === "MultiLineString" ? 2 : 1, tags: He };
          re.id !== null && (Ae.id = re.id), Ke.features.push(Ae);
        }
      }
      function mi(Ke, re, le, ge, Le, Ce) {
        const Be = ge * ge;
        if (ge > 0 && re.size < (Le ? Be : ge))
          return void (le.numPoints += re.length / 3);
        const He = [];
        for (let Ae = 0; Ae < re.length; Ae += 3)
          (ge === 0 || re[Ae + 2] > Be) && (le.numSimplified++, He.push(re[Ae], re[Ae + 1])), le.numPoints++;
        Le && function(Ae, Ye) {
          let Qe = 0;
          for (let it = 0, mt = Ae.length, Ct = mt - 2; it < mt; Ct = it, it += 2)
            Qe += (Ae[it] - Ae[Ct]) * (Ae[it + 1] + Ae[Ct + 1]);
          if (Qe > 0 === Ye)
            for (let it = 0, mt = Ae.length; it < mt / 2; it += 2) {
              const Ct = Ae[it], It = Ae[it + 1];
              Ae[it] = Ae[mt - 2 - it], Ae[it + 1] = Ae[mt - 1 - it], Ae[mt - 2 - it] = Ct, Ae[mt - 1 - it] = It;
            }
        }(He, Ce), Ke.push(He);
      }
      const On = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class Vn {
        constructor(re, le) {
          const ge = (le = this.options = function(Ce, Be) {
            for (const He in Be)
              Ce[He] = Be[He];
            return Ce;
          }(Object.create(On), le)).debug;
          if (ge && console.time("preprocess data"), le.maxZoom < 0 || le.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (le.promoteId && le.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let Le = function(Ce, Be) {
            const He = [];
            if (Ce.type === "FeatureCollection")
              for (let Ae = 0; Ae < Ce.features.length; Ae++)
                vi(He, Ce.features[Ae], Be, Ae);
            else
              vi(He, Ce.type === "Feature" ? Ce : { geometry: Ce }, Be);
            return He;
          }(re, le);
          this.tiles = {}, this.tileCoords = [], ge && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", le.indexMaxZoom, le.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Le = function(Ce, Be) {
            const He = Be.buffer / Be.extent;
            let Ae = Ce;
            const Ye = si(Ce, 1, -1 - He, He, 0, -1, 2, Be), Qe = si(Ce, 1, 1 - He, 2 + He, 0, -1, 2, Be);
            return (Ye || Qe) && (Ae = si(Ce, 1, -He, 1 + He, 0, -1, 2, Be) || [], Ye && (Ae = xo(Ye, 1).concat(Ae)), Qe && (Ae = Ae.concat(xo(Qe, -1)))), Ae;
          }(Le, le), Le.length && this.splitTile(Le, 0, 0, 0), ge && (Le.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(re, le, ge, Le, Ce, Be, He) {
          const Ae = [re, le, ge, Le], Ye = this.options, Qe = Ye.debug;
          for (; Ae.length; ) {
            Le = Ae.pop(), ge = Ae.pop(), le = Ae.pop(), re = Ae.pop();
            const it = 1 << le, mt = Zi(le, ge, Le);
            let Ct = this.tiles[mt];
            if (!Ct && (Qe > 1 && console.time("creation"), Ct = this.tiles[mt] = Xs(re, le, ge, Le, Ye), this.tileCoords.push({ z: le, x: ge, y: Le }), Qe)) {
              Qe > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", le, ge, Le, Ct.numFeatures, Ct.numPoints, Ct.numSimplified), console.timeEnd("creation"));
              const Xn = `z${le}`;
              this.stats[Xn] = (this.stats[Xn] || 0) + 1, this.total++;
            }
            if (Ct.source = re, Ce == null) {
              if (le === Ye.indexMaxZoom || Ct.numPoints <= Ye.indexMaxPoints)
                continue;
            } else {
              if (le === Ye.maxZoom || le === Ce)
                continue;
              if (Ce != null) {
                const Xn = Ce - le;
                if (ge !== Be >> Xn || Le !== He >> Xn)
                  continue;
              }
            }
            if (Ct.source = null, re.length === 0)
              continue;
            Qe > 1 && console.time("clipping");
            const It = 0.5 * Ye.buffer / Ye.extent, Kt = 0.5 - It, di = 0.5 + It, li = 1 + It;
            let ri = null, Ki = null, Ni = null, Ei = null, $i = si(re, it, ge - It, ge + di, 0, Ct.minX, Ct.maxX, Ye), Hi = si(re, it, ge + Kt, ge + li, 0, Ct.minX, Ct.maxX, Ye);
            re = null, $i && (ri = si($i, it, Le - It, Le + di, 1, Ct.minY, Ct.maxY, Ye), Ki = si($i, it, Le + Kt, Le + li, 1, Ct.minY, Ct.maxY, Ye), $i = null), Hi && (Ni = si(Hi, it, Le - It, Le + di, 1, Ct.minY, Ct.maxY, Ye), Ei = si(Hi, it, Le + Kt, Le + li, 1, Ct.minY, Ct.maxY, Ye), Hi = null), Qe > 1 && console.timeEnd("clipping"), Ae.push(ri || [], le + 1, 2 * ge, 2 * Le), Ae.push(Ki || [], le + 1, 2 * ge, 2 * Le + 1), Ae.push(Ni || [], le + 1, 2 * ge + 1, 2 * Le), Ae.push(Ei || [], le + 1, 2 * ge + 1, 2 * Le + 1);
          }
        }
        getTile(re, le, ge) {
          re = +re, le = +le, ge = +ge;
          const Le = this.options, { extent: Ce, debug: Be } = Le;
          if (re < 0 || re > 24)
            return null;
          const He = 1 << re, Ae = Zi(re, le = le + He & He - 1, ge);
          if (this.tiles[Ae])
            return Sr(this.tiles[Ae], Ce);
          Be > 1 && console.log("drilling down to z%d-%d-%d", re, le, ge);
          let Ye, Qe = re, it = le, mt = ge;
          for (; !Ye && Qe > 0; )
            Qe--, it >>= 1, mt >>= 1, Ye = this.tiles[Zi(Qe, it, mt)];
          return Ye && Ye.source ? (Be > 1 && (console.log("found parent tile z%d-%d-%d", Qe, it, mt), console.time("drilling down")), this.splitTile(Ye.source, Qe, it, mt, re, le, ge), Be > 1 && console.timeEnd("drilling down"), this.tiles[Ae] ? Sr(this.tiles[Ae], Ce) : null) : null;
        }
      }
      function Zi(Ke, re, le) {
        return 32 * ((1 << Ke) * le + re) + Ke;
      }
      function Jn(Ke, re) {
        const le = Ke.tileID.canonical;
        if (!this._geoJSONIndex)
          return void re(null, null);
        const ge = this._geoJSONIndex.getTile(le.z, le.x, le.y);
        if (!ge)
          return void re(null, null);
        const Le = new bt(ge.features);
        let Ce = Gi(Le);
        Ce.byteOffset === 0 && Ce.byteLength === Ce.buffer.byteLength || (Ce = new Uint8Array(Ce)), re(null, { vectorTile: Le, rawData: Ce.buffer });
      }
      class Fn extends qe {
        constructor(re, le, ge, Le, Ce, Be) {
          super(re, le, ge, Le, Jn, Be), Ce && (this.loadGeoJSON = Ce), this._dynamicIndex = new Gt();
        }
        loadData(re, le) {
          const ge = re && re.request, Le = ge && ge.collectResourceTiming;
          this.loadGeoJSON(re, (Ce, Be) => {
            if (Ce || !Be)
              return le(Ce);
            if (typeof Be != "object")
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            {
              try {
                if (re.filter) {
                  const Ae = i.U(re.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                  if (Ae.result === "error")
                    throw new Error(Ae.value.map((Ye) => `${Ye.key}: ${Ye.message}`).join(", "));
                  Be.features = Be.features.filter((Ye) => Ae.value.evaluate({ zoom: 0 }, Ye));
                }
                re.dynamic ? (Be.type === "Feature" && (Be = { type: "FeatureCollection", features: [Be] }), re.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(Be.features, this.loaded), re.cluster && (Be.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = re.cluster ? new xs(function({ superclusterOptions: Ae, clusterProperties: Ye }) {
                  if (!Ye || !Ae)
                    return Ae;
                  const Qe = {}, it = {}, mt = { accumulated: null, zoom: 0 }, Ct = { properties: null }, It = Object.keys(Ye);
                  for (const Kt of It) {
                    const [di, li] = Ye[Kt], ri = i.U(li), Ki = i.U(typeof di == "string" ? [di, ["accumulated"], ["get", Kt]] : di);
                    Qe[Kt] = ri.value, it[Kt] = Ki.value;
                  }
                  return Ae.map = (Kt) => {
                    Ct.properties = Kt;
                    const di = {};
                    for (const li of It)
                      di[li] = Qe[li].evaluate(mt, Ct);
                    return di;
                  }, Ae.reduce = (Kt, di) => {
                    Ct.properties = di;
                    for (const li of It)
                      mt.accumulated = Kt[li], Kt[li] = it[li].evaluate(mt, Ct);
                  }, Ae;
                }(re)).load(Be.features) : re.dynamic ? this._dynamicIndex : function(Ae, Ye) {
                  return new Vn(Ae, Ye);
                }(Be, re.geojsonVtOptions);
              } catch (Ae) {
                return le(Ae);
              }
              const He = {};
              if (Le) {
                const Ae = O(ge);
                Ae && (He.resourceTiming = {}, He.resourceTiming[re.source] = JSON.parse(JSON.stringify(Ae)));
              }
              le(null, He);
            }
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded;
          return ge && ge[re.uid] ? re.partial ? le(null, void 0) : super.reloadTile(re, le) : this.loadTile(re, le);
        }
        loadGeoJSON(re, le) {
          if (re.request)
            i.n(re.request, le);
          else {
            if (typeof re.data != "string")
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            try {
              return le(null, JSON.parse(re.data));
            } catch {
              return le(new Error(`Input data given to '${re.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(re, le) {
          try {
            le(null, this._geoJSONIndex.getClusterExpansionZoom(re.clusterId));
          } catch (ge) {
            le(ge);
          }
        }
        getClusterChildren(re, le) {
          try {
            le(null, this._geoJSONIndex.getChildren(re.clusterId));
          } catch (ge) {
            le(ge);
          }
        }
        getClusterLeaves(re, le) {
          try {
            le(null, this._geoJSONIndex.getLeaves(re.clusterId, re.limit, re.offset));
          } catch (ge) {
            le(ge);
          }
        }
      }
      class Ls {
        constructor(re, le) {
          this.tileID = new i.aG(re.tileID.overscaledZ, re.tileID.wrap, re.tileID.canonical.z, re.tileID.canonical.x, re.tileID.canonical.y), this.tileZoom = re.tileZoom, this.uid = re.uid, this.zoom = re.zoom, this.canonical = re.tileID.canonical, this.pixelRatio = re.pixelRatio, this.tileSize = re.tileSize, this.source = re.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = re.projection, this.brightness = le;
        }
        parse(re, le, ge, Le) {
          this.status = "parsing";
          const Ce = new i.aG(ge.tileID.overscaledZ, ge.tileID.wrap, ge.tileID.canonical.z, ge.tileID.canonical.x, ge.tileID.canonical.y), Be = [], He = le.familiesBySource[ge.source], Ae = new i.dZ(Ce, ge.promoteId);
          return Ae.bucketLayerIDs = [], Ae.is3DTile = !0, i.e9(re).then((Ye) => {
            if (!Ye)
              return Le(new Error("Could not parse tile"));
            const Qe = i.ea(Ye, 1 / i.cc(ge.tileID.canonical)), it = Ye.json.extensionsUsed && Ye.json.extensionsUsed.includes("MAPBOX_mesh_features") || Ye.json.asset.extras && Ye.json.asset.extras.MAPBOX_mesh_features, mt = Ye.json.extensionsUsed && Ye.json.extensionsUsed.includes("EXT_meshopt_compression"), Ct = new i.a8(this.zoom, { brightness: this.brightness });
            for (const It in He)
              for (const Kt of He[It]) {
                const di = Kt[0];
                Ae.bucketLayerIDs.push(Kt.map((ri) => i.aC(ri.id, ri.scope))), di.recalculate(Ct, []);
                const li = new i.eb(Kt, Qe, Ce, it, mt, this.brightness, Ae);
                it || (li.needsUpload = !0), Be.push(li), li.evaluate(di);
              }
            this.status = "done", Le(null, { buckets: Be, featureIndex: Ae, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
          }).catch((Ye) => Le(new Error(Ye.message)));
        }
      }
      class zs {
        constructor(re, le, ge, Le, Ce, Be) {
          this.actor = re, this.layerIndex = le, this.availableImages = ge, this.brightness = Be, this.loading = {}, this.loaded = {};
        }
        loadTile(re, le) {
          const ge = re.uid, Le = this.loading[ge] = new Ls(re, this.brightness);
          i.bi(re.request, (Ce, Be) => {
            const He = !this.loading[ge];
            return delete this.loading[ge], He || Ce ? (Le.status = "done", He || (this.loaded[ge] = Le), le(Ce)) : Be && Be.byteLength !== 0 ? void Le.parse(Be, this.layerIndex, re, (Ae, Ye) => {
              Le.status = "done", this.loaded = this.loaded || {}, this.loaded[ge] = Le, Ae || !Ye ? le(Ae) : le(null, Ye);
            }) : (Le.status = "done", this.loaded[ge] = Le, le());
          });
        }
        reloadTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          if (ge && ge[Le]) {
            const Ce = ge[Le];
            Ce.projection = re.projection, Ce.brightness = re.brightness;
            const Be = (He, Ae) => {
              Ce.reloadCallback && (delete Ce.reloadCallback, this.loadTile(re, le)), le(He, Ae);
            };
            Ce.status === "parsing" ? Ce.reloadCallback = Be : Ce.status === "done" && this.loadTile(re, le);
          }
        }
        abortTile(re, le) {
          const ge = re.uid;
          this.loading[ge] && delete this.loading[ge], le();
        }
        removeTile(re, le) {
          const ge = this.loaded, Le = re.uid;
          ge && ge[Le] && delete ge[Le], le();
        }
      }
      class No {
        constructor(re) {
          this.self = re, this.actor = new i.ec(re, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new i.I(), this.projections = {}, this.defaultProjection = i.bP({ name: "mercator" }), this.workerSourceTypes = { vector: qe, geojson: Fn, "batched-model": zs }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (le, ge) => {
            if (this.workerSourceTypes[le])
              throw new Error(`Worker source with name "${le}" already registered.`);
            this.workerSourceTypes[le] = ge;
          }, this.self.registerRTLTextPlugin = (le) => {
            if (i.ed.isParsed())
              throw new Error("RTL text plugin already registered.");
            i.ed.applyArabicShaping = le.applyArabicShaping, i.ed.processBidirectionalText = le.processBidirectionalText, i.ed.processStyledBidirectionalText = le.processStyledBidirectionalText;
          };
        }
        clearCaches(re, le, ge) {
          delete this.layerIndexes[re], delete this.availableImages[re], delete this.workerSources[re], delete this.demWorkerSources[re], delete this.rasterArrayWorkerSource, ge();
        }
        checkIfReady(re, le, ge) {
          ge();
        }
        setReferrer(re, le) {
          this.referrer = le;
        }
        spriteLoaded(re, { scope: le, isLoaded: ge }) {
          if (this.isSpriteLoaded[re] || (this.isSpriteLoaded[re] = {}), this.isSpriteLoaded[re][le] = ge, this.workerSources[re] && this.workerSources[re][le])
            for (const Le in this.workerSources[re][le]) {
              const Ce = this.workerSources[re][le][Le];
              for (const Be in Ce) {
                const He = Ce[Be];
                He instanceof qe && (He.isSpriteLoaded = ge, He.fire(new i.z("isSpriteLoaded")));
              }
            }
        }
        setImages(re, { scope: le, images: ge }, Le) {
          if (this.availableImages[re] || (this.availableImages[re] = {}), this.availableImages[re][le] = ge, this.workerSources[re] && this.workerSources[re][le]) {
            for (const Ce in this.workerSources[re][le]) {
              const Be = this.workerSources[re][le][Ce];
              for (const He in Be)
                Be[He].availableImages = ge;
            }
            Le();
          } else
            Le();
        }
        setProjection(re, le) {
          this.projections[re] = i.bP(le);
        }
        setBrightness(re, le, ge) {
          this.brightness = le, ge();
        }
        setLayers(re, le, ge) {
          this.getLayerIndex(re, le.scope).replace(le.layers, le.options), ge();
        }
        updateLayers(re, le, ge) {
          this.getLayerIndex(re, le.scope).update(le.layers, le.removedIds, le.options), ge();
        }
        loadTile(re, le, ge) {
          le.projection = this.projections[re] || this.defaultProjection, this.getWorkerSource(re, le.type, le.source, le.scope).loadTile(le, ge);
        }
        loadDEMTile(re, le, ge) {
          this.getDEMWorkerSource(re, le.source, le.scope).loadTile(le, ge);
        }
        decodeRasterArray(re, le, ge) {
          this.getRasterArrayWorkerSource().decodeRasterArray(le, ge);
        }
        reloadTile(re, le, ge) {
          le.projection = this.projections[re] || this.defaultProjection, this.getWorkerSource(re, le.type, le.source, le.scope).reloadTile(le, ge);
        }
        abortTile(re, le, ge) {
          this.getWorkerSource(re, le.type, le.source, le.scope).abortTile(le, ge);
        }
        removeTile(re, le, ge) {
          this.getWorkerSource(re, le.type, le.source, le.scope).removeTile(le, ge);
        }
        removeSource(re, le, ge) {
          if (!(this.workerSources[re] && this.workerSources[re][le.scope] && this.workerSources[re][le.scope][le.type] && this.workerSources[re][le.scope][le.type][le.source]))
            return;
          const Le = this.workerSources[re][le.scope][le.type][le.source];
          delete this.workerSources[re][le.scope][le.type][le.source], Le.removeSource !== void 0 ? Le.removeSource(le, ge) : ge();
        }
        loadWorkerSource(re, le, ge) {
          try {
            this.self.importScripts(le.url), ge();
          } catch (Le) {
            ge(Le.toString());
          }
        }
        syncRTLPluginState(re, le, ge) {
          try {
            i.ed.setState(le);
            const Le = i.ed.getPluginURL();
            if (i.ed.isLoaded() && !i.ed.isParsed() && Le != null) {
              this.self.importScripts(Le);
              const Ce = i.ed.isParsed();
              ge(Ce ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${Le}`), Ce);
            }
          } catch (Le) {
            ge(Le.toString());
          }
        }
        setDracoUrl(re, le) {
          this.dracoUrl = le;
        }
        getAvailableImages(re, le) {
          this.availableImages[re] || (this.availableImages[re] = {});
          let ge = this.availableImages[re][le];
          return ge || (ge = []), ge;
        }
        getLayerIndex(re, le) {
          this.layerIndexes[re] || (this.layerIndexes[re] = {});
          let ge = this.layerIndexes[re][le];
          return ge || (ge = this.layerIndexes[re][le] = new J(), ge.scope = le), ge;
        }
        getWorkerSource(re, le, ge, Le) {
          return this.workerSources[re] || (this.workerSources[re] = {}), this.workerSources[re][Le] || (this.workerSources[re][Le] = {}), this.workerSources[re][Le][le] || (this.workerSources[re][Le][le] = {}), this.isSpriteLoaded[re] || (this.isSpriteLoaded[re] = {}), this.workerSources[re][Le][le][ge] || (this.workerSources[re][Le][le][ge] = new this.workerSourceTypes[le]({ send: (Ce, Be, He, Ae, Ye, Qe) => {
            this.actor.send(Ce, Be, He, re, Ye, Qe);
          }, scheduler: this.actor.scheduler }, this.getLayerIndex(re, Le), this.getAvailableImages(re, Le), this.isSpriteLoaded[re][Le], void 0, this.brightness)), this.workerSources[re][Le][le][ge];
        }
        rasterizeImages(re, le, ge) {
          const { imageTasks: Le, scope: Ce } = le, Be = {};
          for (const He in Le) {
            const { image: Ae, imageIdWithOptions: Ye } = Le[He];
            Be[He] = this.imageRasterizer.rasterize(Ye, Ae, Ce, re);
          }
          ge(void 0, Be);
        }
        removeRasterizedImages(re, le, ge) {
          const { imageIds: Le, scope: Ce } = le;
          this.imageRasterizer.removeImagesFromCacheByIds(Le, Ce, re), ge();
        }
        getDEMWorkerSource(re, le, ge) {
          return this.demWorkerSources[re] || (this.demWorkerSources[re] = {}), this.demWorkerSources[re][ge] || (this.demWorkerSources[re][ge] = {}), this.demWorkerSources[re][ge][le] || (this.demWorkerSources[re][ge][le] = new Ge()), this.demWorkerSources[re][ge][le];
        }
        getRasterArrayWorkerSource() {
          return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new lt()), this.rasterArrayWorkerSource;
        }
        enforceCacheSizeLimit(re, le) {
          i.ee(le);
        }
        getWorkerPerformanceMetrics(re, le, ge) {
          ge(void 0, void 0);
        }
      }
      return typeof WorkerGlobalScope < "u" && typeof self < "u" && self instanceof WorkerGlobalScope && (self.worker = new No(self)), No;
    }), b(["./shared"], function(i) {
      var O = "3.9.4";
      const Z = { create: "create", load: "load", fullLoad: "fullLoad" }, Y = { mark(c) {
        performance.mark(c);
      }, measure(c, t, s) {
        performance.measure(c, t, s);
      } };
      function J(c) {
        const t = c.name.split("?")[0];
        return i.a(t) && t.includes("mapbox-gl.js") ? "javascript" : i.a(t) && t.includes("mapbox-gl.css") ? "css" : i.b(t) ? "fontRange" : i.c(t) ? "sprite" : i.i(t) ? "style" : i.d(t) ? "tilejson" : "other";
      }
      var ae, ue = {}, Se = function() {
        if (ae)
          return ue;
        function c(h) {
          return !t(h);
        }
        function t(h) {
          return typeof window > "u" || typeof document > "u" ? "not a browser" : function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return !1;
            var g, T, z = new Blob([""], { type: "text/javascript" }), R = URL.createObjectURL(z);
            try {
              T = new Worker(R), g = !0;
            } catch {
              g = !1;
            }
            return T && T.terminate(), URL.revokeObjectURL(R), g;
          }() ? function() {
            var g = document.createElement("canvas");
            g.width = g.height = 1;
            var T = g.getContext("2d");
            if (!T)
              return !1;
            var z = T.getImageData(0, 0, 1, 1);
            return z && z.width === g.width;
          }() ? (s[m = h && h.failIfMajorPerformanceCaveat] === void 0 && (s[m] = function(g) {
            var T, z = function(R) {
              var F = document.createElement("canvas"), N = Object.create(c.webGLContextAttributes);
              return N.failIfMajorPerformanceCaveat = R, F.getContext("webgl2", N);
            }(g);
            if (!z)
              return !1;
            try {
              T = z.createShader(z.VERTEX_SHADER);
            } catch {
              return !1;
            }
            return !(!T || z.isContextLost()) && (z.shaderSource(T, "void main() {}"), z.compileShader(T), z.getShaderParameter(T, z.COMPILE_STATUS) === !0);
          }(m)), s[m] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
          var m;
        }
        ae = 1, ue.supported = c, ue.notSupportedReason = t;
        var s = {};
        return c.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 }, ue;
      }();
      function we(c, t, s) {
        const h = document.createElement(c);
        return t != null && (h.className = t), s && s.appendChild(h), h;
      }
      function qe(c, t, s) {
        const h = document.createElementNS("http://www.w3.org/2000/svg", c);
        for (const m of Object.keys(t))
          h.setAttributeNS(null, m, String(t[m]));
        return s && s.appendChild(h), h;
      }
      const Ge = typeof document < "u" ? document.documentElement && document.documentElement.style : null, lt = Ge && Ge.userSelect !== void 0 ? "userSelect" : "WebkitUserSelect";
      let Et;
      function ut() {
        Ge && lt && (Et = Ge[lt], Ge[lt] = "none");
      }
      function bt() {
        Ge && lt && (Ge[lt] = Et);
      }
      function Vt(c) {
        c.preventDefault(), c.stopPropagation(), window.removeEventListener("click", Vt, !0);
      }
      function pt() {
        window.addEventListener("click", Vt, !0), window.setTimeout(() => {
          window.removeEventListener("click", Vt, !0);
        }, 0);
      }
      function Gt(c, t) {
        const s = c.getBoundingClientRect();
        return At(c, s, t);
      }
      function ui(c, t) {
        const s = c.getBoundingClientRect(), h = [];
        for (let m = 0; m < t.length; m++)
          h.push(At(c, s, t[m]));
        return h;
      }
      function kt(c) {
        return window.InstallTrigger !== void 0 && c.button === 2 && c.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : c.button;
      }
      function At(c, t, s) {
        const h = c.offsetWidth === t.width ? 1 : c.offsetWidth / t.width;
        return new i.P((s.clientX - t.left) * h, (s.clientY - t.top) * h);
      }
      const Si = "01", An = "NO_ACCESS_TOKEN";
      class hn {
        constructor(t, s, h) {
          this._transformRequestFn = t, this._customAccessToken = s, this._silenceAuthErrors = !!h, this._createSkuToken();
        }
        _createSkuToken() {
          const t = function() {
            let s = "";
            for (let h = 0; h < 10; h++)
              s += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", Si, s].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t.token, this._skuTokenExpiresAt = t.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t, s) {
          return this._transformRequestFn && this._transformRequestFn(t, s) || { url: t };
        }
        normalizeStyleURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Mi(t);
          return h.params.push(`sdk=js-${O}`), h.path = `/styles/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeGlyphsURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Mi(t);
          return h.path = `/fonts/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeModelURL(t, s) {
          if (!i.f(t))
            return t;
          const h = Mi(t);
          return h.path = `/models/v1${h.path}`, this._makeAPIURL(h, this._customAccessToken || s);
        }
        normalizeSourceURL(t, s, h, m) {
          if (!i.f(t))
            return t;
          const g = Mi(t);
          return g.path = `/v4/${g.authority}.json`, g.params.push("secure"), h && g.params.push(`language=${h}`), m && g.params.push(`worldview=${m}`), this._makeAPIURL(g, this._customAccessToken || s);
        }
        normalizeIconsetURL(t, s) {
          const h = Mi(t);
          return i.f(t) ? (h.path = `/styles/v1${h.path}/iconset.pbf`, this._makeAPIURL(h, this._customAccessToken || s)) : Ji(h);
        }
        normalizeSpriteURL(t, s, h, m) {
          const g = Mi(t);
          return i.f(t) ? (g.path = `/styles/v1${g.path}/sprite${s}${h}`, this._makeAPIURL(g, this._customAccessToken || m)) : (g.path += `${s}${h}`, Ji(g));
        }
        normalizeTileURL(t, s, h) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t && !i.f(t))
            return t;
          const m = Mi(t);
          m.path = m.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${s || h && m.authority !== "raster" && h === 512 ? "@2x" : ""}${i.m.supported ? ".webp" : "$1"}`), m.authority === "raster" ? m.path = `/${i.e.RASTER_URL_PREFIX}${m.path}` : m.authority === "rasterarrays" ? m.path = `/${i.e.RASTERARRAYS_URL_PREFIX}${m.path}` : m.authority === "3dtiles" ? m.path = `/${i.e.TILES3D_URL_PREFIX}${m.path}` : (m.path = m.path.replace(/^.+\/v4\//, "/"), m.path = `/${i.e.TILE_URL_VERSION}${m.path}`);
          const g = this._customAccessToken || function(T) {
            for (const z of T) {
              const R = z.match(/^access_token=(.*)$/);
              if (R)
                return R[1];
            }
            return null;
          }(m.params) || i.e.ACCESS_TOKEN;
          return i.e.REQUIRE_ACCESS_TOKEN && g && this._skuToken && m.params.push(`sku=${this._skuToken}`), this._makeAPIURL(m, g);
        }
        canonicalizeTileURL(t, s) {
          const h = Mi(t);
          if (!h.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !h.path.match(/\.[\w]+$/))
            return t;
          let m = "mapbox://";
          h.path.match(/^\/raster\/v1\//) ? m += `raster/${h.path.replace(`/${i.e.RASTER_URL_PREFIX}/`, "")}` : h.path.match(/^\/rasterarrays\/v1\//) ? m += `rasterarrays/${h.path.replace(`/${i.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : m += `tiles/${h.path.replace(`/${i.e.TILE_URL_VERSION}/`, "")}`;
          let g = h.params;
          return s && (g = g.filter((T) => !T.match(/^access_token=/))), g.length && (m += `?${g.join("&")}`), m;
        }
        canonicalizeTileset(t, s) {
          const h = !!s && i.f(s), m = [];
          for (const g of t.tiles || [])
            i.h(g) ? m.push(this.canonicalizeTileURL(g, h)) : m.push(g);
          return m;
        }
        _makeAPIURL(t, s) {
          const h = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", m = Mi(i.e.API_URL);
          if (t.protocol = m.protocol, t.authority = m.authority, t.protocol === "http") {
            const g = t.params.indexOf("secure");
            g >= 0 && t.params.splice(g, 1);
          }
          if (m.path !== "/" && (t.path = `${m.path}${t.path}`), !i.e.REQUIRE_ACCESS_TOKEN)
            return Ji(t);
          if (s = s || i.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!s)
              throw new Error(`An API access token is required to use Mapbox GL. ${h}`);
            if (s[0] === "s")
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${h}`);
          }
          return t.params = t.params.filter((g) => g.indexOf("access_token") === -1), t.params.push(`access_token=${s || ""}`), Ji(t);
        }
      }
      const Ht = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Mi(c) {
        const t = c.match(Ht);
        if (!t)
          throw new Error("Unable to parse URL object");
        return { protocol: t[1], authority: t[2], path: t[3] || "/", params: t[4] ? t[4].split("&") : [] };
      }
      function Ji(c) {
        const t = c.params.length ? `?${c.params.join("&")}` : "";
        return `${c.protocol}://${c.authority}${c.path}${t}`;
      }
      const fi = "mapbox.eventData";
      function jt(c) {
        if (!c)
          return null;
        const t = c.split(".");
        if (!t || t.length !== 3)
          return null;
        try {
          return JSON.parse(i.j(t[1]));
        } catch {
          return null;
        }
      }
      class ni {
        constructor(t) {
          this.type = t, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t) {
          const s = jt(i.e.ACCESS_TOKEN);
          let h = "";
          return h = s && s.u ? i.k(s.u) : i.e.ACCESS_TOKEN || "", t ? `${fi}.${t}:${h}` : `${fi}:${h}`;
        }
        fetchEventData() {
          const t = i.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid");
          if (t)
            try {
              const m = localStorage.getItem(s);
              m && (this.eventData = JSON.parse(m));
              const g = localStorage.getItem(h);
              g && (this.anonId = g);
            } catch {
              i.w("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t = i.s("localStorage"), s = this.getStorageKey(), h = this.getStorageKey("uuid"), m = this.anonId;
          if (t && m)
            try {
              localStorage.setItem(h, m), Object.keys(this.eventData).length >= 1 && localStorage.setItem(s, JSON.stringify(this.eventData));
            } catch {
              i.w("Unable to write to LocalStorage");
            }
        }
        processRequests(t) {
        }
        postEvent(t, s, h, m) {
          if (!i.e.EVENTS_URL)
            return;
          const g = Mi(i.e.EVENTS_URL);
          g.params.push(`access_token=${m || i.e.ACCESS_TOKEN || ""}`);
          const T = { event: this.type, created: new Date(t).toISOString() }, z = s ? i.l(T, s) : T, R = { url: Ji(g), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([z]) };
          this.pendingRequest = i.p(R, (F) => {
            this.pendingRequest = null, h(F), this.saveEventData(), this.processRequests(m);
          });
        }
        queueRequest(t, s) {
          this.queue.push(t), this.processRequests(s);
        }
      }
      const Gi = new class extends ni {
        constructor(c) {
          super("appUserTurnstile"), this._customAccessToken = c;
        }
        postTurnstileEvent(c, t) {
          i.e.EVENTS_URL && i.e.ACCESS_TOKEN && Array.isArray(c) && c.some((s) => i.f(s) || i.h(s)) && this.queueRequest(Date.now(), t);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const t = jt(i.e.ACCESS_TOKEN), s = t ? t.u : i.e.ACCESS_TOKEN;
          let h = s !== this.eventData.tokenU;
          i.v(this.anonId) || (this.anonId = i.u(), h = !0);
          const m = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const g = new Date(this.eventData.lastSuccess), T = new Date(m), z = (m - this.eventData.lastSuccess) / 864e5;
            h = h || z >= 1 || z < -1 || g.getDate() !== T.getDate();
          } else
            h = !0;
          h ? this.postEvent(m, { sdkIdentifier: "mapbox-gl-js", sdkVersion: O, skuId: Si, "enabled.telemetry": !1, userId: this.anonId }, (g) => {
            g || (this.eventData.lastSuccess = m, this.eventData.tokenU = s);
          }, c) : this.processRequests();
        }
      }(), an = Gi.postTurnstileEvent.bind(Gi), qt = new class extends ni {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(c, t, s, h) {
          this.skuToken = t, this.errorCb = h, i.e.EVENTS_URL && (s || i.e.ACCESS_TOKEN ? this.queueRequest({ id: c, timestamp: Date.now() }, s) : this.errorCb(new Error(An)));
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: t, timestamp: s } = this.queue.shift();
          t && this.success[t] || (this.anonId || this.fetchEventData(), i.v(this.anonId) || (this.anonId = i.u()), this.postEvent(s, { sdkIdentifier: "mapbox-gl-js", sdkVersion: O, skuId: Si, skuToken: this.skuToken, userId: this.anonId }, (h) => {
            h ? this.errorCb(h) : t && (this.success[t] = !0);
          }, c));
        }
        remove() {
          this.errorCb = null;
        }
      }(), ln = qt.postMapLoadEvent.bind(qt), Di = new class extends ni {
        constructor() {
          super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
        }
        getMapInstanceId(c) {
          let t = this.mapInstanceIdMap.get(c);
          return t || (t = i.u(), this.mapInstanceIdMap.set(c, t)), t;
        }
        getEventId(c) {
          const t = this.eventIdPerMapInstanceMap.get(c) || 0;
          return this.eventIdPerMapInstanceMap.set(c, t + 1), t;
        }
        postStyleLoadEvent(c, t) {
          const { map: s, style: h, importedStyles: m } = t;
          if (!i.e.EVENTS_URL || !c && !i.e.ACCESS_TOKEN)
            return;
          const g = this.getMapInstanceId(s), T = { mapInstanceId: g, eventId: this.getEventId(g), style: h };
          m.length && (T.importedStyles = m), this.queueRequest({ timestamp: Date.now(), payload: T }, c);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { timestamp: t, payload: s } = this.queue.shift();
          this.postEvent(t, s, () => {
          }, c);
        }
      }(), xi = Di.postStyleLoadEvent.bind(Di), Cs = new class extends ni {
        constructor() {
          super("gljs.performance");
        }
        postPerformanceEvent(c, t) {
          i.e.EVENTS_URL && (c || i.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, c);
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { timestamp: t, performanceData: s } = this.queue.shift(), h = function(m) {
            const g = performance.getEntriesByType("resource"), T = performance.getEntriesByType("mark"), z = function(W) {
              const te = {};
              if (W) {
                for (const ee in W)
                  if (ee !== "other")
                    for (const se of W[ee]) {
                      const oe = `${ee}ResolveRangeMin`, ce = `${ee}ResolveRangeMax`, _e = `${ee}RequestCount`, pe = `${ee}RequestCachedCount`;
                      te[oe] = Math.min(te[oe] || 1 / 0, se.startTime), te[ce] = Math.max(te[ce] || -1 / 0, se.responseEnd);
                      const Te = (xe) => {
                        te[xe] === void 0 && (te[xe] = 0), ++te[xe];
                      };
                      se.transferSize !== void 0 && se.transferSize === 0 && Te(pe), Te(_e);
                    }
              }
              return te;
            }(function(W, te) {
              const ee = {};
              if (W)
                for (const se of W) {
                  const oe = te(se);
                  ee[oe] === void 0 && (ee[oe] = []), ee[oe].push(se);
                }
              return ee;
            }(g, J)), R = window.devicePixelRatio, F = navigator.connection || navigator.mozConnection || navigator.webkitConnection, N = F ? F.effectiveType : void 0, j = { counters: [], metadata: [], attributes: [] }, G = (W, te, ee) => {
              ee != null && W.push({ name: te, value: ee.toString() });
            };
            for (const W in z)
              G(j.counters, W, z[W]);
            if (m.interactionRange[0] !== 1 / 0 && m.interactionRange[1] !== -1 / 0 && (G(j.counters, "interactionRangeMin", m.interactionRange[0]), G(j.counters, "interactionRangeMax", m.interactionRange[1])), T)
              for (const W of Object.keys(Z)) {
                const te = Z[W], ee = T.find((se) => se.name === te);
                ee && G(j.counters, te, ee.startTime);
              }
            return G(j.counters, "visibilityHidden", m.visibilityHidden), G(j.attributes, "style", function(W) {
              if (W)
                for (const te of W) {
                  const ee = te.name.split("?")[0];
                  if (i.i(ee)) {
                    const se = ee.split("/").slice(-2);
                    if (se.length === 2)
                      return `mapbox://styles/${se[0]}/${se[1]}`;
                  }
                }
            }(g)), G(j.attributes, "terrainEnabled", m.terrainEnabled ? "true" : "false"), G(j.attributes, "fogEnabled", m.fogEnabled ? "true" : "false"), G(j.attributes, "projection", m.projection), G(j.attributes, "zoom", m.zoom), G(j.metadata, "devicePixelRatio", R), G(j.metadata, "connectionEffectiveType", N), G(j.metadata, "navigatorUserAgent", navigator.userAgent), G(j.metadata, "screenWidth", window.screen.width), G(j.metadata, "screenHeight", window.screen.height), G(j.metadata, "windowWidth", window.innerWidth), G(j.metadata, "windowHeight", window.innerHeight), G(j.metadata, "mapWidth", m.width / R), G(j.metadata, "mapHeight", m.height / R), G(j.metadata, "webglRenderer", m.renderer), G(j.metadata, "webglVendor", m.vendor), G(j.metadata, "sdkVersion", O), G(j.metadata, "sdkIdentifier", "mapbox-gl-js"), j;
          }(s);
          for (const m of h.metadata)
            ;
          for (const m of h.counters)
            ;
          for (const m of h.attributes)
            ;
          this.postEvent(t, h, () => {
          }, c);
        }
      }(), xs = Cs.postPerformanceEvent.bind(Cs), Is = new class extends ni {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(c, t, s, h) {
          if (!i.e.API_URL || !i.e.SESSION_PATH)
            return;
          const m = Mi(i.e.API_URL + i.e.SESSION_PATH);
          m.params.push(`sku=${t || ""}`), m.params.push(`access_token=${h || i.e.ACCESS_TOKEN || ""}`);
          const g = { url: Ji(m), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = i.g(g, (T) => {
            this.pendingRequest = null, s(T), this.saveEventData(), this.processRequests(h);
          });
        }
        getSessionAPI(c, t, s, h) {
          this.skuToken = t, this.errorCb = h, i.e.SESSION_PATH && i.e.API_URL && (s || i.e.ACCESS_TOKEN ? this.queueRequest({ id: c, timestamp: Date.now() }, s) : this.errorCb(new Error(An)));
        }
        processRequests(c) {
          if (this.pendingRequest || this.queue.length === 0)
            return;
          const { id: t, timestamp: s } = this.queue.shift();
          t && this.success[t] || this.getSession(s, this.skuToken, (h) => {
            h ? this.errorCb(h) : t && (this.success[t] = !0);
          }, c);
        }
        remove() {
          this.errorCb = null;
        }
      }(), De = Is.getSessionAPI.bind(Is), Vs = /* @__PURE__ */ new Set();
      function Us(c, t) {
        t ? Vs.add(c) : Vs.delete(c);
      }
      class Zr {
        constructor() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = /* @__PURE__ */ new Set();
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = !0;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(t, s) {
          this._updatedSourceCaches[t] = s, this.setDirty();
        }
        discardSourceCacheUpdate(t) {
          delete this._updatedSourceCaches[t];
        }
        updateLayer(t) {
          const s = t.scope;
          this._updatedLayers[s] = this._updatedLayers[s] || /* @__PURE__ */ new Set(), this._updatedLayers[s].add(t.id), this.setDirty();
        }
        removeLayer(t) {
          const s = t.scope;
          this._removedLayers[s] = this._removedLayers[s] || {}, this._updatedLayers[s] = this._updatedLayers[s] || /* @__PURE__ */ new Set(), this._removedLayers[s][t.id] = t, this._updatedLayers[s].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty();
        }
        getRemovedLayer(t) {
          return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null;
        }
        discardLayerRemoval(t) {
          this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id];
        }
        getLayerUpdatesByScope() {
          const t = {};
          for (const s in this._updatedLayers)
            t[s] = t[s] || {}, t[s].updatedIds = Array.from(this._updatedLayers[s].values());
          for (const s in this._removedLayers)
            t[s] = t[s] || {}, t[s].removedIds = Object.keys(this._removedLayers[s]);
          return t;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(t) {
          this._updatedPaintProps.add(t.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(t) {
          this._updatedImages.add(t), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      function Mt(c) {
        const { userImage: t } = c;
        return !!(t && t.render && t.render()) && (c.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class ir extends i.E {
        constructor(t) {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t, t !== "raster" && i.t() && (this.imageRasterizerDispatcher = new i.D(i.x(), this, "Image Rasterizer Worker", 1));
        }
        get imageRasterizer() {
          return this._imageRasterizer || (this._imageRasterizer = new i.I()), this._imageRasterizer;
        }
        createScope(t) {
          this.images[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = {}, this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = {}, this.atlasImage[t] = new i.r({ width: 1, height: 1 });
        }
        isLoaded() {
          for (const t in this.loaded)
            if (!this.loaded[t])
              return !1;
          return !0;
        }
        setLoaded(t, s) {
          if (this.loaded[s] !== t && (this.loaded[s] = t, t)) {
            for (const { ids: h, callback: m } of this.requestors)
              this._notify(h, s, m);
            this.requestors = [];
          }
        }
        hasImage(t, s) {
          return !!this.getImage(t, s);
        }
        getImage(t, s) {
          return this.images[s][t];
        }
        addImage(t, s, h) {
          this._validate(t, h) && (this.images[s][t] = h);
        }
        _validate(t, s) {
          let h = !0;
          return this._validateStretch(s.stretchX, s.data && s.data.width) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchX" value`))), h = !1), this._validateStretch(s.stretchY, s.data && s.data.height) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "stretchY" value`))), h = !1), this._validateContent(s.content, s) || (this.fire(new i.y(new Error(`Image "${t}" has invalid "content" value`))), h = !1), h;
        }
        _validateStretch(t, s) {
          if (!t)
            return !0;
          let h = 0;
          for (const m of t) {
            if (m[0] < h || m[1] < m[0] || s < m[1])
              return !1;
            h = m[1];
          }
          return !0;
        }
        _validateContent(t, s) {
          return t ? t.length !== 4 || !s.usvg && (t[0] < 0 || s.data.width < t[0] || t[1] < 0 || s.data.height < t[1] || t[2] < 0 || s.data.width < t[2] || t[3] < 0 || s.data.height < t[3]) ? !1 : !(t[2] < t[0] || t[3] < t[1]) : !0;
        }
        updateImage(t, s, h) {
          h.version = this.images[s][t].version + 1, this.images[s][t] = h, this.updatedImages[s][t] = !0, this.removeFromImageRasterizerCache(t, s);
        }
        removeFromImageRasterizerCache(t, s) {
          this.spriteFormat !== "raster" && (i.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t], scope: s }) : this.imageRasterizer.removeImagesFromCacheByIds([t], s));
        }
        removeImage(t, s) {
          const h = this.images[s][t];
          delete this.images[s][t], delete this.patterns[s][t], this.removeFromImageRasterizerCache(t, s), h.userImage && h.userImage.onRemove && h.userImage.onRemove();
        }
        listImages(t) {
          return Object.keys(this.images[t]);
        }
        getImages(t, s, h) {
          let m = !0;
          const g = !!this.loaded[s];
          if (!g)
            for (const T of t)
              this.images[s][T] || (m = !1);
          g || m ? this._notify(t, s, h) : this.requestors.push({ ids: t, scope: s, callback: h });
        }
        rasterizeImages({ scope: t, imageTasks: s }, h) {
          const m = {};
          for (const g in s) {
            const T = s[g], z = this.getImage(T.id, t);
            z && (m[g] = { image: z, imageIdWithOptions: T });
          }
          i.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", { imageTasks: m, scope: t }, h) : this.rasterizeImagesInMainThread({ imageTasks: m, scope: t }, h);
        }
        rasterizeImagesInMainThread(t, s) {
          const { imageTasks: h, scope: m } = t, g = {};
          for (const T in h) {
            const { image: z, imageIdWithOptions: R } = h[T];
            g[T] = this.imageRasterizer.rasterize(R, z, m, "");
          }
          s(void 0, g);
        }
        getUpdatedImages(t) {
          return this.updatedImages[t];
        }
        _notify(t, s, h) {
          const m = {};
          for (const g of t) {
            this.images[s][g] || this.fire(new i.z("styleimagemissing", { id: g }));
            const T = this.images[s][g];
            T ? m[g] = { data: T.usvg ? null : T.data.clone(), pixelRatio: T.pixelRatio, sdf: T.sdf, usvg: T.usvg, version: T.version, stretchX: T.stretchX, stretchY: T.stretchY, content: T.content, hasRenderCallback: !!(T.userImage && T.userImage.render) } : i.w(`Image "${g}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          h(null, m);
        }
        getPixelSize(t) {
          const { width: s, height: h } = this.atlasImage[t];
          return { width: s, height: h };
        }
        getPattern(t, s, h) {
          const m = this.patterns[s][t], g = this.getImage(t, s);
          if (!g)
            return null;
          if (m && m.position.version === g.version)
            return m.position;
          if (m)
            m.position.version = g.version;
          else {
            g.usvg && !g.data && (g.data = this.imageRasterizer.rasterize(i.A.from(t).getPrimary(), g, s, ""));
            const T = { w: g.data.width + 2 * i.B, h: g.data.height + 2 * i.B, x: 0, y: 0 }, z = new i.F(T, g, i.B);
            this.patterns[s][t] = { bin: T, position: z };
          }
          return this._updatePatternAtlas(s, h), this.patterns[s][t].position;
        }
        bind(t, s) {
          const h = t.gl;
          let m = this.atlasTexture[s];
          m ? this.dirty && (m.update(this.atlasImage[s]), this.dirty = !1) : (m = new i.T(t, this.atlasImage[s], h.RGBA8), this.atlasTexture[s] = m), m.bind(h.LINEAR, h.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t, s) {
          const h = [];
          for (const z in this.patterns[t])
            h.push(this.patterns[t][z].bin);
          const { w: m, h: g } = i.C(h), T = this.atlasImage[t];
          T.resize({ width: m || 1, height: g || 1 });
          for (const z in this.patterns[t]) {
            const { bin: R, position: F } = this.patterns[t][z];
            let N = F.padding;
            const j = R.x + N, G = R.y + N, W = this.images[t][z].data, te = W.width, ee = W.height;
            N = N > 1 ? N - 1 : N, i.r.copy(W, T, { x: 0, y: 0 }, { x: j, y: G }, { width: te, height: ee }, s), i.r.copy(W, T, { x: 0, y: ee - N }, { x: j, y: G - N }, { width: te, height: N }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: j, y: G + ee }, { width: te, height: N }, s), i.r.copy(W, T, { x: te - N, y: 0 }, { x: j - N, y: G }, { width: N, height: ee }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: j + te, y: G }, { width: N, height: ee }, s), i.r.copy(W, T, { x: te - N, y: ee - N }, { x: j - N, y: G - N }, { width: N, height: N }, s), i.r.copy(W, T, { x: 0, y: ee - N }, { x: j + te, y: G - N }, { width: N, height: N }, s), i.r.copy(W, T, { x: 0, y: 0 }, { x: j + te, y: G + ee }, { width: N, height: N }, s), i.r.copy(W, T, { x: te - N, y: 0 }, { x: j - N, y: G + ee }, { width: N, height: N }, s);
          }
          this.dirty = !0;
        }
        beginFrame() {
          for (const t in this.images)
            this.callbackDispatchedThisFrame[t] = {};
        }
        dispatchRenderCallbacks(t, s) {
          for (const h of t) {
            if (this.callbackDispatchedThisFrame[s][h])
              continue;
            this.callbackDispatchedThisFrame[s][h] = !0;
            const m = this.images[s][h];
            Mt(m) && this.updateImage(h, s, m);
          }
        }
      }
      function $n(c) {
        const t = c.key, s = c.value, h = c.valueSpec || {}, m = c.objectElementValidators || {}, g = c.style, T = c.styleSpec;
        let z = [];
        const R = i.H(s);
        if (R !== "object")
          return [new i.V(t, s, `object expected, ${R} found`)];
        for (const F in s) {
          const N = F.split(".")[0];
          let j;
          m[N] ? j = m[N] : h[N] ? j = mi : m["*"] ? j = m["*"] : h["*"] && (j = mi), j ? z = z.concat(j({ key: (t && `${t}.`) + F, value: s[F], valueSpec: h[N] || h["*"], style: g, styleSpec: T, object: s, objectKey: F }, s)) : z.push(new i.G(t, s[F], `unknown property "${F}"`));
        }
        for (const F in h)
          m[F] || h[F].required && h[F].default === void 0 && s[F] === void 0 && z.push(new i.V(t, s, `missing required property "${F}"`));
        return z;
      }
      function Ws(c) {
        const t = c.value, s = c.valueSpec, h = c.style, m = c.styleSpec, g = c.key, T = c.arrayElementValidator || mi;
        if (i.H(t) !== "array")
          return [new i.V(g, t, `array expected, ${i.H(t)} found`)];
        if (s.length && t.length !== s.length)
          return [new i.V(g, t, `array length ${s.length} expected, length ${t.length} found`)];
        if (s["min-length"] && t.length < s["min-length"])
          return [new i.V(g, t, `array length at least ${s["min-length"]} expected, length ${t.length} found`)];
        let z = { type: s.value, values: s.values, minimum: s.minimum, maximum: s.maximum, function: void 0 };
        m.$version < 7 && (z.function = s.function), i.H(s.value) === "object" && (z = s.value);
        let R = [];
        for (let F = 0; F < t.length; F++)
          R = R.concat(T({ array: t, arrayIndex: F, value: t[F], valueSpec: z, style: h, styleSpec: m, key: `${g}[${F}]` }, !0));
        return R;
      }
      function vi(c) {
        const t = c.key, s = c.value, h = c.valueSpec;
        let m = i.H(s);
        if (m === "number" && s != s && (m = "NaN"), m !== "number")
          return [new i.V(t, s, `number expected, ${m} found`)];
        if ("minimum" in h) {
          let g = h.minimum;
          if (i.H(h.minimum) === "array" && (g = h.minimum[c.arrayIndex]), s < g)
            return [new i.V(t, s, `${s} is less than the minimum value ${g}`)];
        }
        if ("maximum" in h) {
          let g = h.maximum;
          if (i.H(h.maximum) === "array" && (g = h.maximum[c.arrayIndex]), s > g)
            return [new i.V(t, s, `${s} is greater than the maximum value ${g}`)];
        }
        return [];
      }
      function kn(c) {
        const t = c.valueSpec, s = i.K(c.value.type);
        let h, m, g, T = {};
        const z = s !== "categorical" && c.value.property === void 0, R = !z, F = i.H(c.value.stops) === "array" && i.H(c.value.stops[0]) === "array" && i.H(c.value.stops[0][0]) === "object", N = $n({ key: c.key, value: c.value, valueSpec: c.styleSpec.function, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { stops: function(W) {
          if (s === "identity")
            return [new i.V(W.key, W.value, 'identity function may not have a "stops" property')];
          let te = [];
          const ee = W.value;
          return te = te.concat(Ws({ key: W.key, value: ee, valueSpec: W.valueSpec, style: W.style, styleSpec: W.styleSpec, arrayElementValidator: j })), i.H(ee) === "array" && ee.length === 0 && te.push(new i.V(W.key, ee, "array must have at least one stop")), te;
        }, default: function(W) {
          return mi({ key: W.key, value: W.value, valueSpec: t, style: W.style, styleSpec: W.styleSpec });
        } } });
        return s === "identity" && z && N.push(new i.V(c.key, c.value, 'missing required property "property"')), s === "identity" || c.value.stops || N.push(new i.V(c.key, c.value, 'missing required property "stops"')), s === "exponential" && c.valueSpec.expression && !i.L(c.valueSpec) && N.push(new i.V(c.key, c.value, "exponential functions not supported")), c.styleSpec.$version >= 8 && (R && !i.M(c.valueSpec) ? N.push(new i.V(c.key, c.value, "property functions not supported")) : z && !i.N(c.valueSpec) && N.push(new i.V(c.key, c.value, "zoom functions not supported"))), s !== "categorical" && !F || c.value.property !== void 0 || N.push(new i.V(c.key, c.value, '"property" property is required')), N;
        function j(W) {
          let te = [];
          const ee = W.value, se = W.key;
          if (i.H(ee) !== "array")
            return [new i.V(se, ee, `array expected, ${i.H(ee)} found`)];
          if (ee.length !== 2)
            return [new i.V(se, ee, `array length 2 expected, length ${ee.length} found`)];
          if (F) {
            if (i.H(ee[0]) !== "object")
              return [new i.V(se, ee, `object expected, ${i.H(ee[0])} found`)];
            if (ee[0].zoom === void 0)
              return [new i.V(se, ee, "object stop key must have zoom")];
            if (ee[0].value === void 0)
              return [new i.V(se, ee, "object stop key must have value")];
            const oe = i.K(ee[0].zoom);
            if (typeof oe != "number")
              return [new i.V(se, ee[0].zoom, "stop zoom values must be numbers")];
            if (g && g > oe)
              return [new i.V(se, ee[0].zoom, "stop zoom values must appear in ascending order")];
            oe !== g && (g = oe, m = void 0, T = {}), te = te.concat($n({ key: `${se}[0]`, value: ee[0], valueSpec: { zoom: {} }, style: W.style, styleSpec: W.styleSpec, objectElementValidators: { zoom: vi, value: G } }));
          } else
            te = te.concat(G({ key: `${se}[0]`, value: ee[0], valueSpec: {}, style: W.style, styleSpec: W.styleSpec }, ee));
          return i.O(i.Q(ee[1])) ? te.concat([new i.V(`${se}[1]`, ee[1], "expressions are not allowed in function stops.")]) : te.concat(mi({ key: `${se}[1]`, value: ee[1], valueSpec: t, style: W.style, styleSpec: W.styleSpec }));
        }
        function G(W, te) {
          const ee = i.H(W.value), se = i.K(W.value), oe = W.value !== null ? W.value : te;
          if (h) {
            if (ee !== h)
              return [new i.V(W.key, oe, `${ee} stop domain type must match previous stop domain type ${h}`)];
          } else
            h = ee;
          if (ee !== "number" && ee !== "string" && ee !== "boolean" && typeof se != "number" && typeof se != "string" && typeof se != "boolean")
            return [new i.V(W.key, oe, "stop domain value must be a number, string, or boolean")];
          if (ee !== "number" && s !== "categorical") {
            let ce = `number expected, ${ee} found`;
            return i.M(t) && s === void 0 && (ce += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new i.V(W.key, oe, ce)];
          }
          return s !== "categorical" || ee !== "number" || typeof se == "number" && isFinite(se) && Math.floor(se) === se ? s !== "categorical" && ee === "number" && typeof se == "number" && typeof m == "number" && m !== void 0 && se < m ? [new i.V(W.key, oe, "stop domain values must appear in ascending order")] : (m = se, s === "categorical" && se in T ? [new i.V(W.key, oe, "stop domain values must be unique")] : (T[se] = !0, [])) : [new i.V(W.key, oe, `integer expected, found ${String(se)}`)];
        }
      }
      function $s(c) {
        const t = (c.expressionContext === "property" ? i.S : i.U)(i.Q(c.value), c.valueSpec);
        if (t.result === "error")
          return t.value.map((h) => new i.V(`${c.key}${h.key}`, c.value, h.message));
        const s = t.value.expression || t.value._styleExpression.expression;
        if (c.expressionContext === "property" && c.propertyKey === "text-font" && !s.outputDefined())
          return [new i.V(c.key, c.value, `Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (c.expressionContext === "property" && c.propertyType === "layout" && !i.W(s))
          return [new i.V(c.key, c.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (c.expressionContext === "filter")
          return Hr(s, c);
        if (c.expressionContext && c.expressionContext.indexOf("cluster") === 0) {
          if (!i.X(s, ["zoom", "feature-state"]))
            return [new i.V(c.key, c.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (c.expressionContext === "cluster-initial" && !i.Y(s))
            return [new i.V(c.key, c.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Hr(c, t) {
        const s = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
        if (t.valueSpec && t.valueSpec.expression)
          for (const m of t.valueSpec.expression.parameters)
            s.delete(m);
        if (s.size === 0)
          return [];
        const h = [];
        return c instanceof i.Z && s.has(c.name) ? [new i.V(t.key, t.value, `["${c.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)] : (c.eachChild((m) => {
          h.push(...Hr(m, t));
        }), h);
      }
      function qr(c) {
        const t = c.key, s = c.value, h = c.valueSpec, m = [];
        return Array.isArray(h.values) ? h.values.indexOf(i.K(s)) === -1 && m.push(new i.V(t, s, `expected one of [${h.values.join(", ")}], ${JSON.stringify(s)} found`)) : Object.keys(h.values).indexOf(i.K(s)) === -1 && m.push(new i.V(t, s, `expected one of [${Object.keys(h.values).join(", ")}], ${JSON.stringify(s)} found`)), m;
      }
      function Wr(c) {
        return i.$(i.Q(c.value)) ? $s(i.J({}, c, { expressionContext: "filter", valueSpec: c.styleSpec[`filter_${c.layerType || "fill"}`] })) : si(c);
      }
      function si(c) {
        const t = c.value, s = c.key;
        if (i.H(t) !== "array")
          return [new i.V(s, t, `array expected, ${i.H(t)} found`)];
        const h = c.styleSpec;
        let m, g = [];
        if (t.length < 1)
          return [new i.V(s, t, "filter array must have at least 1 element")];
        switch (g = g.concat(qr({ key: `${s}[0]`, value: t[0], valueSpec: h.filter_operator, style: c.style, styleSpec: c.styleSpec })), i.K(t[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            t.length >= 2 && i.K(t[1]) === "$type" && g.push(new i.V(s, t, `"$type" cannot be use with operator "${t[0]}"`));
          case "==":
          case "!=":
            t.length !== 3 && g.push(new i.V(s, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case "in":
          case "!in":
            t.length >= 2 && (m = i.H(t[1]), m !== "string" && g.push(new i.V(`${s}[1]`, t[1], `string expected, ${m} found`)));
            for (let T = 2; T < t.length; T++)
              m = i.H(t[T]), i.K(t[1]) === "$type" ? g = g.concat(qr({ key: `${s}[${T}]`, value: t[T], valueSpec: h.geometry_type, style: c.style, styleSpec: c.styleSpec })) : m !== "string" && m !== "number" && m !== "boolean" && g.push(new i.V(`${s}[${T}]`, t[T], `string, number, or boolean expected, ${m} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let T = 1; T < t.length; T++)
              g = g.concat(si({ key: `${s}[${T}]`, value: t[T], style: c.style, styleSpec: c.styleSpec }));
            break;
          case "has":
          case "!has":
            m = i.H(t[1]), t.length !== 2 ? g.push(new i.V(s, t, `filter array for "${t[0]}" operator must have 2 elements`)) : m !== "string" && g.push(new i.V(`${s}[1]`, t[1], `string expected, ${m} found`));
        }
        return g;
      }
      function fs(c, t) {
        const s = c.key, h = c.style, m = c.layer, g = c.styleSpec, T = c.value, z = c.objectKey, R = g[`${t}_${c.layerType}`];
        if (!R)
          return [];
        const F = z.match(/^(.*)-use-theme$/);
        if (t === "paint" && F && R[F[1]])
          return mi({ key: s, value: T, valueSpec: { type: "string" }, style: h, styleSpec: g });
        const N = z.match(/^(.*)-transition$/);
        if (t === "paint" && N && R[N[1]] && R[N[1]].transition)
          return mi({ key: s, value: T, valueSpec: g.transition, style: h, styleSpec: g });
        const j = c.valueSpec || R[z];
        if (!j)
          return [new i.G(s, T, `unknown property "${z}"`)];
        let G;
        if (i.H(T) === "string" && i.M(j) && !j.tokens && (G = /^{([^}]+)}$/.exec(T))) {
          const te = `\`{ "type": "identity", "property": ${G ? JSON.stringify(G[1]) : '"_"'} }\``;
          return [new i.V(s, T, `"${z}" does not support interpolation syntax
Use an identity property function instead: ${te}.`)];
        }
        const W = [];
        if (c.layerType === "symbol")
          z !== "text-field" || !h || h.glyphs || h.imports || W.push(new i.V(s, T, 'use of "text-field" requires a style "glyphs" property')), z === "text-font" && i.a0(i.Q(T)) && i.K(T.type) === "identity" && W.push(new i.V(s, T, '"text-font" does not support identity functions'));
        else if (c.layerType === "model" && t === "paint" && m && m.layout && m.layout.hasOwnProperty("model-id") && i.M(j) && (i.a1(j) || i.N(j))) {
          const te = i.S(i.Q(T), j), ee = te.value.expression || te.value._styleExpression.expression;
          ee && !i.X(ee, ["measure-light"]) && (z === "model-emissive-strength" && i.Y(ee) && i.W(ee) || W.push(new i.V(s, T, `${z} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return W.concat(mi({ key: c.key, value: T, valueSpec: j, style: h, styleSpec: g, expressionContext: "property", propertyType: t, propertyKey: z }));
      }
      function zn(c) {
        return fs(c, "paint");
      }
      function Rn(c) {
        return fs(c, "layout");
      }
      function Pn(c) {
        let t = [];
        const s = c.value, h = c.key, m = c.style, g = c.styleSpec;
        s.type || s.ref || t.push(new i.V(h, s, 'either "type" or "ref" is required'));
        let T = i.K(s.type);
        const z = i.K(s.ref);
        if (s.id) {
          const R = i.K(s.id);
          for (let F = 0; F < c.arrayIndex; F++) {
            const N = m.layers[F];
            i.K(N.id) === R && t.push(new i.V(h, s.id, `duplicate layer id "${s.id}", previously used at line ${N.id.__line__}`));
          }
        }
        if ("ref" in s) {
          let R;
          ["type", "source", "source-layer", "filter", "layout"].forEach((F) => {
            F in s && t.push(new i.V(h, s[F], `"${F}" is prohibited for ref layers`));
          }), m.layers.forEach((F) => {
            i.K(F.id) === z && (R = F);
          }), R ? R.ref ? t.push(new i.V(h, s.ref, "ref cannot reference another ref layer")) : T = i.K(R.type) : typeof z == "string" && t.push(new i.V(h, s.ref, `ref layer "${z}" not found`));
        } else if (T !== "background" && T !== "sky" && T !== "slot")
          if (s.source) {
            const R = m.sources && m.sources[s.source], F = R && i.K(R.type);
            R ? F === "vector" && T === "raster" ? t.push(new i.V(h, s.source, `layer "${s.id}" requires a raster source`)) : F === "raster" && T !== "raster" ? t.push(new i.V(h, s.source, `layer "${s.id}" requires a vector source`)) : F !== "vector" || s["source-layer"] ? F === "raster-dem" && T !== "hillshade" ? t.push(new i.V(h, s.source, "raster-dem source can only be used with layer type 'hillshade'.")) : F !== "raster-array" || ["raster", "raster-particle"].includes(T) ? T !== "line" || !s.paint || !s.paint["line-gradient"] && !s.paint["line-trim-offset"] || F === "geojson" && R.lineMetrics ? T === "raster-particle" && F !== "raster-array" && t.push(new i.V(h, s.source, `layer "${s.id}" requires a 'raster-array' source.`)) : t.push(new i.V(h, s, `layer "${s.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new i.V(h, s.source, "raster-array source can only be used with layer type 'raster'.")) : t.push(new i.V(h, s, `layer "${s.id}" must specify a "source-layer"`)) : t.push(new i.V(h, s.source, `source "${s.source}" not found`));
          } else
            t.push(new i.V(h, s, 'missing required property "source"'));
        return t = t.concat($n({ key: h, value: s, valueSpec: g.layer, style: c.style, styleSpec: c.styleSpec, objectElementValidators: { "*": () => [], type: () => mi({ key: `${h}.type`, value: s.type, valueSpec: g.layer.type, style: c.style, styleSpec: c.styleSpec, object: s, objectKey: "type" }), filter: (R) => Wr(i.J({ layerType: T }, R)), layout: (R) => $n({ layer: s, key: R.key, value: R.value, valueSpec: {}, style: R.style, styleSpec: R.styleSpec, objectElementValidators: { "*": (F) => Rn(i.J({ layerType: T }, F)) } }), paint: (R) => $n({ layer: s, key: R.key, value: R.value, valueSpec: {}, style: R.style, styleSpec: R.styleSpec, objectElementValidators: { "*": (F) => zn(i.J({ layerType: T, layer: s }, F)) } }) } })), t;
      }
      function js(c) {
        const t = c.value, s = c.key, h = i.H(t);
        return h !== "string" ? [new i.V(s, t, `string expected, ${h} found`)] : [];
      }
      const go = { promoteId: function({ key: c, value: t }) {
        if (i.H(t) === "string")
          return js({ key: c, value: t });
        {
          const s = [];
          for (const h in t)
            s.push(...js({ key: `${c}.${h}`, value: t[h] }));
          return s;
        }
      } };
      function yo(c) {
        const t = c.value, s = c.key, h = c.styleSpec, m = c.style;
        if (!t.type)
          return [new i.V(s, t, '"type" is required')];
        const g = i.K(t.type);
        let T = [];
        switch (["vector", "raster", "raster-dem", "raster-array"].includes(g) && (t.url || t.tiles || T.push(new i.G(s, t, 'Either "url" or "tiles" is required.'))), g) {
          case "vector":
          case "raster":
          case "raster-dem":
          case "raster-array":
            return T = T.concat($n({ key: s, value: t, valueSpec: h[`source_${g.replace("-", "_")}`], style: c.style, styleSpec: h, objectElementValidators: go })), T;
          case "geojson":
            if (T = $n({ key: s, value: t, valueSpec: h.source_geojson, style: m, styleSpec: h, objectElementValidators: go }), t.cluster)
              for (const z in t.clusterProperties) {
                const [R, F] = t.clusterProperties[z], N = typeof R == "string" ? [R, ["accumulated"], ["get", z]] : R;
                T.push(...$s({ key: `${s}.${z}.map`, value: F, expressionContext: "cluster-map" })), T.push(...$s({ key: `${s}.${z}.reduce`, value: N, expressionContext: "cluster-reduce" }));
              }
            return T;
          case "video":
            return $n({ key: s, value: t, valueSpec: h.source_video, style: m, styleSpec: h });
          case "image":
            return $n({ key: s, value: t, valueSpec: h.source_image, style: m, styleSpec: h });
          case "canvas":
            return [new i.V(s, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return qr({ key: `${s}.type`, value: t.type, valueSpec: { values: xo(h) }, style: m, styleSpec: h });
        }
      }
      function xo(c) {
        return c.source.reduce((t, s) => {
          const h = c[s];
          return h.type.type === "enum" && (t = t.concat(Object.keys(h.type.values))), t;
        }, []);
      }
      function yr(c) {
        const t = c.value, s = c.styleSpec, h = s.light, m = c.style;
        let g = [];
        const T = i.H(t);
        if (t === void 0)
          return g;
        if (T !== "object")
          return g = g.concat([new i.V("light", t, `object expected, ${T} found`)]), g;
        for (const z in t) {
          const R = z.match(/^(.*)-transition$/), F = z.match(/^(.*)-use-theme$/);
          g = g.concat(F && h[F[1]] ? mi({ key: z, value: t[z], valueSpec: { type: "string" }, style: m, styleSpec: s }) : R && h[R[1]] && h[R[1]].transition ? mi({ key: z, value: t[z], valueSpec: s.transition, style: m, styleSpec: s }) : h[z] ? mi({ key: z, value: t[z], valueSpec: h[z], style: m, styleSpec: s }) : [new i.V(z, t[z], `unknown property "${z}"`)]);
        }
        return g;
      }
      function Sr(c) {
        const t = c.value;
        let s = [];
        if (!t)
          return s;
        const h = i.H(t);
        if (h !== "object")
          return s = s.concat([new i.V("light-3d", t, `object expected, ${h} found`)]), s;
        const m = c.styleSpec, g = m["light-3d"], T = c.key, z = c.style, R = c.style.lights;
        for (const j of ["type", "id"])
          if (!(j in t))
            return s = s.concat([new i.V("light-3d", t, `missing property ${j} on light`)]), s;
        if (t.type && R)
          for (let j = 0; j < c.arrayIndex; j++) {
            const G = i.K(t.type), W = R[j];
            i.K(W.type) === G && s.push(new i.V(T, t.id, `duplicate light type "${t.type}", previously defined at line ${W.id.__line__}`));
          }
        const F = `properties_light_${t.type}`;
        if (!(F in m))
          return s = s.concat([new i.V("light-3d", t, `Invalid light type ${t.type}`)]), s;
        const N = m[F];
        for (const j in t)
          if (j === "properties") {
            const G = t[j], W = i.H(G);
            if (W !== "object")
              return s = s.concat([new i.V("properties", G, `object expected, ${W} found`)]), s;
            for (const te in G)
              s = s.concat(N[te] ? mi({ key: te, value: G[te], valueSpec: N[te], style: z, styleSpec: m }) : [new i.G(c.key, G[te], `unknown property "${te}"`)]);
          } else {
            const G = j.match(/^(.*)-transition$/), W = j.match(/^(.*)-use-theme$/);
            s = s.concat(W && g[W[1]] ? mi({ key: j, value: t[j], valueSpec: { type: "string" }, style: z, styleSpec: m }) : G && g[G[1]] && g[G[1]].transition ? mi({ key: j, value: t[j], valueSpec: m.transition, style: z, styleSpec: m }) : g[j] ? mi({ key: j, value: t[j], valueSpec: g[j], style: z, styleSpec: m }) : [new i.G(j, t[j], `unknown property "${j}"`)]);
          }
        return s;
      }
      function io(c) {
        const t = c.value, s = c.key, h = c.style, m = c.styleSpec, g = m.terrain;
        let T = [];
        const z = i.H(t);
        if (t === void 0 || z === "null")
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("terrain", t, `object expected, ${z} found`)]), T;
        for (const R in t) {
          const F = R.match(/^(.*)-transition$/), N = R.match(/^(.*)-use-theme$/);
          T = T.concat(N && g[N[1]] ? mi({ key: R, value: t[R], valueSpec: { type: "string" }, style: h, styleSpec: m }) : F && g[F[1]] && g[F[1]].transition ? mi({ key: R, value: t[R], valueSpec: m.transition, style: h, styleSpec: m }) : g[R] ? mi({ key: R, value: t[R], valueSpec: g[R], style: h, styleSpec: m }) : [new i.G(R, t[R], `unknown property "${R}"`)]);
        }
        if (t.source) {
          const R = h.sources && h.sources[t.source], F = R && i.K(R.type);
          R ? F !== "raster-dem" && T.push(new i.V(s, t.source, `terrain cannot be used with a source of type ${String(F)}, it only be used with a "raster-dem" source type`)) : T.push(new i.V(s, t.source, `source "${t.source}" not found`));
        } else
          T.push(new i.V(s, t, 'terrain is missing required property "source"'));
        return T;
      }
      function Xs(c) {
        const t = c.value, s = c.style, h = c.styleSpec, m = h.fog;
        let g = [];
        const T = i.H(t);
        if (t === void 0)
          return g;
        if (T !== "object")
          return g = g.concat([new i.V("fog", t, `object expected, ${T} found`)]), g;
        for (const z in t) {
          const R = z.match(/^(.*)-transition$/), F = z.match(/^(.*)-use-theme$/);
          g = g.concat(F && m[F[1]] ? mi({ key: z, value: t[z], valueSpec: { type: "string" }, style: s, styleSpec: h }) : R && m[R[1]] && m[R[1]].transition ? mi({ key: z, value: t[z], valueSpec: h.transition, style: s, styleSpec: h }) : m[z] ? mi({ key: z, value: t[z], valueSpec: m[z], style: s, styleSpec: h }) : [new i.G(z, t[z], `unknown property "${z}"`)]);
        }
        return g;
      }
      const Mr = { "*": () => [], array: Ws, boolean: function(c) {
        const t = c.value, s = c.key, h = i.H(t);
        return h !== "boolean" ? [new i.V(s, t, `boolean expected, ${h} found`)] : [];
      }, number: vi, color: function(c) {
        const t = c.key, s = c.value, h = i.H(s);
        return h !== "string" ? [new i.V(t, s, `color expected, ${h} found`)] : i._.parseCSSColor(s) === null ? [new i.V(t, s, `color expected, "${s}" found`)] : [];
      }, enum: qr, filter: Wr, function: kn, layer: Pn, object: $n, source: yo, model: i.a2, light: yr, "light-3d": Sr, terrain: io, fog: Xs, string: js, formatted: function(c) {
        return js(c).length === 0 ? [] : $s(c);
      }, resolvedImage: function(c) {
        return js(c).length === 0 ? [] : $s(c);
      }, projection: function(c) {
        const t = c.value, s = c.styleSpec, h = s.projection, m = c.style;
        let g = [];
        const T = i.H(t);
        if (T === "object")
          for (const z in t)
            g = g.concat(mi({ key: z, value: t[z], valueSpec: h[z], style: m, styleSpec: s }));
        else
          T !== "string" && (g = g.concat([new i.V("projection", t, `object or string expected, ${T} found`)]));
        return g;
      }, import: function(c) {
        const { value: t, styleSpec: s } = c, { data: h, ...m } = t;
        Object.defineProperty(m, "__line__", { value: t.__line__, enumerable: !1 });
        let g = $n(i.J({}, c, { value: m, valueSpec: s.import }));
        return i.K(m.id) === "" && g.push(new i.V(`${c.key}.id`, m, "import id can't be an empty string")), h && (g = g.concat(Vn(h, s, { key: `${c.key}.data` }))), g;
      } };
      function mi(c, t = !1) {
        const s = c.value, h = c.valueSpec, m = c.styleSpec;
        if (h.expression && i.a0(i.K(s)))
          return kn(c);
        if (h.expression && i.O(i.Q(s)))
          return $s(c);
        if (h.type && Mr[h.type]) {
          const g = Mr[h.type](c);
          return t === !0 && g.length > 0 && i.H(c.value) === "array" ? $s(c) : g;
        }
        return $n(i.J({}, c, { valueSpec: h.type ? m[h.type] : h }));
      }
      function On(c) {
        const t = c.value, s = c.key, h = js(c);
        return h.length || (t.indexOf("{fontstack}") === -1 && h.push(new i.V(s, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf("{range}") === -1 && h.push(new i.V(s, t, '"glyphs" url must include a "{range}" token'))), h;
      }
      function Vn(c, t = i.a3, s = {}) {
        return mi({ key: s.key || "", value: c, valueSpec: t.$root, styleSpec: t, style: c, objectElementValidators: { glyphs: On, "*": () => [] } });
      }
      function Zi(c, t = i.a3) {
        return He(Vn(c, t));
      }
      const Jn = (c) => He(yo(c)), Fn = (c) => He(yr(c)), Ls = (c) => He(Sr(c)), zs = (c) => He(io(c)), No = (c) => He(Xs(c)), Ke = (c) => He(function(t) {
        const s = t.value, h = t.style, m = t.styleSpec, g = m.snow;
        let T = [];
        const z = i.H(s);
        if (s === void 0)
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("snow", s, `object expected, ${z} found`)]), T;
        for (const R in s) {
          const F = R.match(/^(.*)-transition$/);
          T = T.concat(F && g[F[1]] && g[F[1]].transition ? mi({ key: R, value: s[R], valueSpec: m.transition, style: h, styleSpec: m }) : g[R] ? mi({ key: R, value: s[R], valueSpec: g[R], style: h, styleSpec: m }) : [new i.G(R, s[R], `unknown property "${R}"`)]);
        }
        return T;
      }(c)), re = (c) => He(function(t) {
        const s = t.value, h = t.style, m = t.styleSpec, g = m.rain;
        let T = [];
        const z = i.H(s);
        if (s === void 0)
          return T;
        if (z !== "object")
          return T = T.concat([new i.V("rain", s, `object expected, ${z} found`)]), T;
        for (const R in s) {
          const F = R.match(/^(.*)-transition$/);
          T = T.concat(F && g[F[1]] && g[F[1]].transition ? mi({ key: R, value: s[R], valueSpec: m.transition, style: h, styleSpec: m }) : g[R] ? mi({ key: R, value: s[R], valueSpec: g[R], style: h, styleSpec: m }) : [new i.G(R, s[R], `unknown property "${R}"`)]);
        }
        return T;
      }(c)), le = (c) => He(Pn(c)), ge = (c) => He(Wr(c)), Le = (c) => He(zn(c)), Ce = (c) => He(Rn(c)), Be = (c) => He(i.a2(c));
      function He(c) {
        return c.slice().sort((t, s) => t.line && s.line ? t.line - s.line : 0);
      }
      function Ae(c, t) {
        let s = !1;
        if (t && t.length)
          for (const h of t)
            h instanceof i.G ? i.w(h.message) : (c.fire(new i.y(new Error(h.message))), s = !0);
        return s;
      }
      let Ye;
      class Qe extends i.E {
        constructor(t, s = "flat") {
          super(), this._transitionable = new i.a4(Ye || (Ye = new i.a5({ anchor: new i.a6(i.a3.light.anchor), position: new i.a7(i.a3.light.position), color: new i.a6(i.a3.light.color), intensity: new i.a6(i.a3.light.intensity) }))), this.setLight(t, s), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, s, h = {}) {
          this._validate(Fn, t, h) || (this._transitionable.setTransitionOrValue(t), this.id = s);
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, h) {
          return (!h || h.validate !== !1) && Ae(this, t.call(Zi, i.l({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }
      let it = class extends i.E {
        constructor(c, t, s, h) {
          super(), this.scope = s, this._transitionable = new i.a4(new i.a5({ source: new i.a6(i.a3.terrain.source), exaggeration: new i.a6(i.a3.terrain.exaggeration) }), s, h), this._transitionable.setTransitionOrValue(c, h), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = t;
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t) {
          this._transitionable.setTransitionOrValue(c, t);
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        getExaggeration(c) {
          return this._transitioning.possiblyEvaluate(new i.a8(c)).get("exaggeration");
        }
        getAttenuationRange() {
          if (!this.isZoomDependent())
            return null;
          const c = this._transitionable._values.exaggeration;
          if (!c)
            return null;
          const t = c.value.expression;
          if (!t)
            return null;
          let s = -1, h = -1, m = 1;
          for (const g of t.zoomStops)
            m = t.evaluate(new i.a8(g)), m > 0.01 ? (s = g, h = -1) : h = g;
          return m < 0.01 && s > 0 && h > s ? [s, h] : null;
        }
        isZoomDependent() {
          const c = this._transitionable._values.exaggeration;
          return c != null && c.value != null && c.value.expression != null && c.value.expression instanceof i.a9;
        }
      };
      const mt = 45, Ct = 65, It = 0.05;
      function Kt(c, t, s, h) {
        const m = i.ac(mt, Ct, s), [g, T] = di(c, h);
        let z = 1 - Math.min(1, Math.exp((t - g) / (T - g) * -6));
        return z *= z * z, z = Math.min(1, 1.00747 * z), z * m * c.alpha;
      }
      function di(c, t) {
        const s = 0.5 / Math.tan(0.5 * t);
        return [c.range[0] + s, c.range[1] + s];
      }
      function li(c, t, s, h, m) {
        const g = i.ab.vec3.transformMat4([], [t, s, h], m.mercatorFogMatrix);
        return Kt(c, i.ab.vec3.length(g), m.pitch, m._fov);
      }
      function ri(c, t, s, h, m, g, T) {
        const z = [[s, h, 0], [m, h, 0], [m, g, 0], [s, g, 0]];
        let R = Number.MAX_VALUE, F = -Number.MAX_VALUE;
        for (const N of z) {
          const j = i.ab.vec3.transformMat4([], N, t), G = i.ab.vec3.length(j);
          R = Math.min(R, G), F = Math.max(F, G);
        }
        return [Kt(c, R, T.pitch, T._fov), Kt(c, F, T.pitch, T._fov)];
      }
      class Ki extends i.E {
        constructor(t, s, h, m) {
          super();
          const g = new i.a5({ range: new i.a6(i.a3.fog.range), color: new i.a6(i.a3.fog.color), "color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new i.a6(i.a3.fog["high-color"]), "high-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new i.a6(i.a3.fog["space-color"]), "space-color-use-theme": new i.a6({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new i.a6(i.a3.fog["horizon-blend"]), "star-intensity": new i.a6(i.a3.fog["star-intensity"]), "vertical-range": new i.a6(i.a3.fog["vertical-range"]) });
          this._transitionable = new i.a4(g, h, new Map(m)), this.set(t, m), this._transitioning = this._transitionable.untransitioned(), this._transform = s, this.properties = new i.ad(g), this.scope = h;
        }
        get state() {
          const t = this._transform, s = t.projection.name === "globe", h = i.ae(t.zoom), m = this.properties.get("range"), g = [0.5, 3];
          return { range: s ? [i.af(g[0], m[0], h), i.af(g[1], m[1], h)] : m, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t, s, h = {}) {
          if (this._validate(No, t, h))
            return;
          const m = i.l({}, t);
          for (const g of Object.keys(i.a3.fog))
            m[g] === void 0 && (m[g] = i.a3.fog[g].default);
          this._options = m, this._transitionable.setTransitionOrValue(this._options, s);
        }
        getOpacity(t) {
          if (!this._transform.projection.supportsFog)
            return 0;
          const s = this.properties && this.properties.get("color") || 1;
          return (this._transform.projection.name === "globe" ? 1 : i.ac(mt, Ct, t)) * s.a;
        }
        getOpacityAtLatLng(t, s) {
          return this._transform.projection.supportsFog ? function(h, m, g) {
            const T = i.aa.fromLngLat(m), z = g.elevation ? g.elevation.getAtPointOrZero(T) : 0;
            return li(h, T.x, T.y, z, g);
          }(this.state, t, s) : 0;
        }
        getOpacityForTile(t) {
          if (!this._transform.projection.supportsFog)
            return [1, 1];
          const s = this._transform.calculateFogTileMatrix(t.toUnwrapped());
          return ri(this.state, s, 0, 0, i.ag, i.ag, this._transform);
        }
        getOpacityForBounds(t, s, h, m, g) {
          return this._transform.projection.supportsFog ? ri(this.state, t, s, h, m, g, this._transform) : [1, 1];
        }
        getFovAdjustedRange(t) {
          return this._transform.projection.supportsFog ? di(this.state, t) : [0, 1];
        }
        isVisibleOnFrustum(t) {
          if (!this._transform.projection.supportsFog)
            return !1;
          const s = [4, 5, 6, 7];
          for (const h of s) {
            const m = t.points[h];
            let g;
            if (m[2] >= 0)
              g = m;
            else {
              const T = t.points[h - 4];
              g = i.ah(T, m, T[2] / (T[2] - m[2]));
            }
            if (li(this.state, g[0], g[1], 0, this._transform) >= It)
              return !0;
          }
          return !1;
        }
        updateConfig(t) {
          this._transitionable.setTransitionOrValue(this._options, new Map(t));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, s, h) {
          return (!h || h.validate !== !1) && Ae(this, t.call(Zi, i.l({ value: s, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }
      let Ni, Ei, $i, Hi, Xn = class extends i.E {
        constructor(c, t, s, h) {
          super();
          const m = Ni || (Ni = new i.a5({ density: new i.a6(i.a3.snow.density), intensity: new i.a6(i.a3.snow.intensity), color: new i.a6(i.a3.snow.color), opacity: new i.a6(i.a3.snow.opacity), vignette: new i.a6(i.a3.snow.vignette), "vignette-color": new i.a6(i.a3.snow["vignette-color"]), "center-thinning": new i.a6(i.a3.snow["center-thinning"]), direction: new i.a6(i.a3.snow.direction), "flake-size": new i.a6(i.a3.snow["flake-size"]) }));
          this._transitionable = new i.a4(m, s, new Map(h)), this.set(c, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(m), this.scope = s;
        }
        get state() {
          const c = this.properties.get("opacity"), t = this.properties.get("color"), s = this.properties.get("direction"), h = i.ai(s[0]), m = -Math.max(i.ai(s[1]), 0.01), g = [Math.cos(h) * Math.cos(m), Math.sin(h) * Math.cos(m), Math.sin(m)], T = this.properties.get("vignette"), z = this.properties.get("vignette-color");
          return z.a = T, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * c), direction: g, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: z };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t, s = {}) {
          if (this._validate(Ke, c, s))
            return;
          const h = i.l({}, c);
          for (const m of Object.keys(i.a3.snow))
            h[m] === void 0 && (h[m] = i.a3.snow[m].default);
          this._options = h, this._transitionable.setTransitionOrValue(this._options, t);
        }
        updateConfig(c) {
          this._transitionable.setTransitionOrValue(this._options, new Map(c));
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        _validate(c, t, s) {
          return (!s || s.validate !== !1) && Ae(this, c.call(Zi, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      }, Gs = class extends i.E {
        constructor(c, t, s, h) {
          super();
          const m = Ei || (Ei = new i.a5({ density: new i.a6(i.a3.rain.density), intensity: new i.a6(i.a3.rain.intensity), color: new i.a6(i.a3.rain.color), opacity: new i.a6(i.a3.rain.opacity), vignette: new i.a6(i.a3.rain.vignette), "vignette-color": new i.a6(i.a3.rain["vignette-color"]), "center-thinning": new i.a6(i.a3.rain["center-thinning"]), direction: new i.a6(i.a3.rain.direction), "droplet-size": new i.a6(i.a3.rain["droplet-size"]), "distortion-strength": new i.a6(i.a3.rain["distortion-strength"]) }));
          this._transitionable = new i.a4(m, s, new Map(h)), this.set(c, h), this._transitioning = this._transitionable.untransitioned(), this.properties = new i.ad(m), this.scope = s;
        }
        get state() {
          const c = this.properties.get("opacity"), t = this.properties.get("color"), s = this.properties.get("direction"), h = i.ai(s[0]), m = -Math.max(i.ai(s[1]), 0.01), g = [Math.cos(h) * Math.cos(m), Math.sin(h) * Math.cos(m), Math.sin(m)], T = this.properties.get("vignette-color");
          return T.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new i.aj(t.r, t.g, t.b, t.a * c), direction: g, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: T };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(c, t, s = {}) {
          if (this._validate(re, c, s))
            return;
          const h = i.l({}, c);
          for (const m of Object.keys(i.a3.rain))
            h[m] === void 0 && (h[m] = i.a3.rain[m].default);
          this._options = h, this._transitionable.setTransitionOrValue(this._options, t);
        }
        updateConfig(c) {
          this._transitionable.setTransitionOrValue(this._options, new Map(c));
        }
        updateTransitions(c) {
          this._transitioning = this._transitionable.transitioned(c, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(c) {
          this.properties = this._transitioning.possiblyEvaluate(c);
        }
        _validate(c, t, s) {
          return (!s || s.validate !== !1) && Ae(this, c.call(Zi, i.l({ value: t, style: { glyphs: !0, sprite: !0 }, styleSpec: i.a3 })));
        }
      };
      class ps extends i.E {
        constructor(t, s, h, m) {
          super(), this.scope = h, this._options = t, this.properties = new i.ad(s), this._transitionable = new i.a4(s, h, new Map(m)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();
        }
        updateConfig(t) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(t));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        get() {
          return this._options.properties = this._transitionable.serialize(), this._options;
        }
        set(t, s) {
          this._options = t, this._transitionable.setTransitionOrValue(t.properties, s);
        }
        shadowsEnabled() {
          return !!this.properties && this.properties.get("cast-shadows") === !0;
        }
      }
      class vs {
        constructor(t, s, h, m) {
          this.screenBounds = t, this.cameraPoint = s, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = h, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, m);
        }
        static createFromScreenPoints(t, s) {
          let h, m;
          if (t instanceof i.P || typeof t[0] == "number") {
            const g = i.P.convert(t);
            h = [g], m = s.isPointAboveHorizon(g);
          } else {
            const g = i.P.convert(t[0]), T = i.P.convert(t[1]);
            h = [g, T], m = i.al(g, T).every((z) => s.isPointAboveHorizon(z));
          }
          return new vs(h, s.getCameraPoint(), m, s);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(t) {
          return i.al(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t);
        }
        bufferedCameraGeometry(t) {
          const s = this.screenBounds[0], h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], m = i.al(s, h, 0, !1);
          return this.cameraPoint.y > h.y && (this.cameraPoint.x > s.x && this.cameraPoint.x < h.x ? m.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= h.x ? m[2] = this.cameraPoint : this.cameraPoint.x <= s.x && (m[3] = this.cameraPoint)), i.am(m, t);
        }
        bufferedCameraGeometryGlobe(t) {
          const s = this.screenBounds[0], h = this.screenBounds.length === 1 ? this.screenBounds[0].add(new i.P(1, 1)) : this.screenBounds[1], m = i.al(s, h, t), g = this.cameraPoint.clone();
          switch (3 * ((g.y > s.y) + (g.y > h.y)) + ((g.x > s.x) + (g.x > h.x))) {
            case 0:
              m[0] = g, m[4] = g.clone();
              break;
            case 1:
              m.splice(1, 0, g);
              break;
            case 2:
              m[1] = g;
              break;
            case 3:
              m.splice(4, 0, g);
              break;
            case 5:
              m.splice(2, 0, g);
              break;
            case 6:
              m[3] = g;
              break;
            case 7:
              m.splice(3, 0, g);
              break;
            case 8:
              m[2] = g;
          }
          return m;
        }
        containsTile(t, s, h, m = 0) {
          const g = t.queryPadding / s._pixelsPerMercatorPixel + 1, T = h ? this._bufferedCameraMercator(g, s) : this._bufferedScreenMercator(g, s);
          let z = t.tileID.wrap + (T.unwrapped ? m : 0);
          const R = T.polygon.map((se) => i.an(t.tileTransform, se, z));
          if (!i.ao(R, 0, 0, i.ag, i.ag))
            return;
          z = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? m : 0);
          const F = this.screenGeometryMercator.polygon.map((se) => i.ap(t.tileTransform, se, z)), N = F.map((se) => new i.P(se[0], se[1])), j = s.getFreeCameraOptions().position || new i.aa(0, 0, 0), G = i.ap(t.tileTransform, j, z), W = F.map((se) => {
            const oe = i.ab.vec3.sub(se, se, G);
            return i.ab.vec3.normalize(oe, oe), new i.aq(G, oe);
          }), te = i.ar(t, 1, s.zoom) * s._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: N, tilespaceRays: W, bufferedTilespaceGeometry: R, bufferedTilespaceBounds: (ee = i.as(R), ee.min.x = i.aw(ee.min.x, 0, i.ag), ee.min.y = i.aw(ee.min.y, 0, i.ag), ee.max.x = i.aw(ee.max.x, 0, i.ag), ee.max.y = i.aw(ee.max.y, 0, i.ag), ee), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: te };
          var ee;
        }
        _bufferedScreenMercator(t, s) {
          const h = ra(t);
          if (this._screenRaycastCache[h])
            return this._screenRaycastCache[h];
          {
            let m;
            return m = s.projection.name === "globe" ? this._projectAndResample(this.bufferedScreenGeometry(t), s) : { polygon: this.bufferedScreenGeometry(t).map((g) => s.pointCoordinate3D(g)), unwrapped: !0 }, this._screenRaycastCache[h] = m, m;
          }
        }
        _bufferedCameraMercator(t, s) {
          const h = ra(t);
          if (this._cameraRaycastCache[h])
            return this._cameraRaycastCache[h];
          {
            let m;
            return m = s.projection.name === "globe" ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), s) : { polygon: this.bufferedCameraGeometry(t).map((g) => s.pointCoordinate3D(g)), unwrapped: !0 }, this._cameraRaycastCache[h] = m, m;
          }
        }
        _projectAndResample(t, s) {
          const h = function(g, T) {
            const z = i.ab.mat4.multiply([], T.pixelMatrix, T.globeMatrix), R = [0, -i.ax, 0, 1], F = [0, i.ax, 0, 1], N = [0, 0, 0, 1];
            i.ab.vec4.transformMat4(R, R, z), i.ab.vec4.transformMat4(F, F, z), i.ab.vec4.transformMat4(N, N, z);
            const j = new i.P(R[0] / R[3], R[1] / R[3]), G = new i.P(F[0] / F[3], F[1] / F[3]), W = i.au(g, j) && R[3] < N[3], te = i.au(g, G) && F[3] < N[3];
            if (!W && !te)
              return null;
            const ee = function(be, ve, Pe) {
              for (let Oe = 1; Oe < be.length; Oe++) {
                const Xe = Er(ve.pointCoordinate3D(be[Oe - 1]).x), Ze = Er(ve.pointCoordinate3D(be[Oe]).x);
                if (Pe < 0) {
                  if (Xe < Ze)
                    return { idx: Oe, t: -Xe / (Ze - 1 - Xe) };
                } else if (Ze < Xe)
                  return { idx: Oe, t: (1 - Xe) / (Ze + 1 - Xe) };
              }
              return null;
            }(g, T, W ? -1 : 1);
            if (!ee)
              return null;
            const { idx: se, t: oe } = ee;
            let ce = se > 1 ? sa(g.slice(0, se), T) : [], _e = se < g.length ? sa(g.slice(se), T) : [];
            ce = ce.map((be) => new i.P(Er(be.x), be.y)), _e = _e.map((be) => new i.P(Er(be.x), be.y));
            const pe = [...ce];
            pe.length === 0 && pe.push(_e[_e.length - 1]);
            const Te = i.af(pe[pe.length - 1].y, (_e.length === 0 ? ce[0] : _e[0]).y, oe);
            let xe;
            return xe = W ? [new i.P(0, Te), new i.P(0, 0), new i.P(1, 0), new i.P(1, Te)] : [new i.P(1, Te), new i.P(1, 1), new i.P(0, 1), new i.P(0, Te)], pe.push(...xe), _e.length === 0 ? pe.push(ce[0]) : pe.push(..._e), { polygon: pe.map((be) => new i.aa(be.x, be.y)), unwrapped: !1 };
          }(t, s);
          if (h)
            return h;
          const m = function(g, T) {
            let z = !1, R = -1 / 0, F = 0;
            for (let j = 0; j < g.length - 1; j++)
              g[j].x > R && (R = g[j].x, F = j);
            for (let j = 0; j < g.length - 1; j++) {
              const G = (F + j) % (g.length - 1), W = g[G], te = g[G + 1];
              Math.abs(W.x - te.x) > 0.5 && (W.x < te.x ? (W.x += 1, G === 0 && (g[g.length - 1].x += 1)) : (te.x += 1, G + 1 === g.length - 1 && (g[0].x += 1)), z = !0);
            }
            const N = i.at(T.center.lng);
            return z && N < Math.abs(N - 1) && g.forEach((j) => {
              j.x -= 1;
            }), { polygon: g, unwrapped: z };
          }(sa(t, s).map((g) => new i.P(Er(g.x), g.y)), s);
          return { polygon: m.polygon.map((g) => new i.aa(g.x, g.y)), unwrapped: m.unwrapped };
        }
      }
      function sa(c, t) {
        return i.av(c, (s) => {
          const h = t.pointCoordinate3D(s);
          s.x = h.x, s.y = h.y;
        }, 1 / 256);
      }
      function Er(c) {
        return c < 0 ? 1 + c % 1 : c % 1;
      }
      function ra(c) {
        return 100 * c | 0;
      }
      function al(c, t, s, h, m) {
        const g = function(z, R) {
          if (z)
            return m(z);
          if (R) {
            if (c.url && R.tiles && c.tiles && delete c.tiles, R.variants) {
              if (!Array.isArray(R.variants))
                return m(new Error("variants must be an array"));
              for (const N of R.variants) {
                if (N == null || typeof N != "object" || N.constructor !== Object)
                  return m(new Error("variant must be an object"));
                if (!Array.isArray(N.capabilities))
                  return m(new Error("capabilities must be an array"));
                if (N.capabilities.length === 1 && N.capabilities[0] === "meshopt") {
                  R = i.l(R, N);
                  break;
                }
              }
            }
            const F = i.ay(i.l({}, R, c), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
            F.tiles = t.canonicalizeTileset(F, c.url), m(null, F);
          }
        }, T = function(z, R, F) {
          if (!z)
            return null;
          if (!R && !F)
            return z;
          F = F || z.worldview_default;
          const N = Object.values(z.language || {});
          if (N.length === 0)
            return null;
          const j = Object.values(z.worldview || {});
          if (j.length === 0)
            return null;
          const G = N.every((te) => te === R), W = j.every((te) => te === F);
          return G && W ? z : R in (z.language_options || {}) || F in (z.worldview_options || {}) ? null : z.language_options && z.worldview_options ? z : null;
        }(c.data, s, h);
        return T ? i.q.frame(() => g(null, T)) : c.url ? i.n(t.transformRequest(t.normalizeSourceURL(c.url, null, s, h), i.R.Source), g) : i.q.frame(() => {
          const { data: z, ...R } = c;
          g(null, R);
        });
      }
      class Vo {
        constructor(t, s, h) {
          this.bounds = i.az.convert(this.validateBounds(t)), this.minzoom = s || 0, this.maxzoom = h || 24;
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const s = Math.pow(2, t.z), h = Math.floor(i.at(this.bounds.getWest()) * s), m = Math.floor(i.aA(this.bounds.getNorth()) * s), g = Math.ceil(i.at(this.bounds.getEast()) * s), T = Math.ceil(i.aA(this.bounds.getSouth()) * s);
          return t.x >= h && t.x < g && t.y >= m && t.y < T;
        }
      }
      class Uo extends i.E {
        constructor(t, s, h, m) {
          if (super(), this.id = t, this.dispatcher = h, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, i.l(this, i.ay(s, ["url", "scheme", "tileSize", "promoteId"])), this._options = i.l({ type: "vector" }, s), this._collectResourceTiming = !!s.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(m), this._tileWorkers = {}, this._deduped = new i.aB();
        }
        load(t) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
          const s = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, h = this.map.getWorldview();
          this._tileJSONRequest = al(this._options, this.map._requestManager, s, h, (m, g) => {
            if (this._tileJSONRequest = null, this._loaded = !0, m)
              s && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${s}`), h && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${h}`), this.fire(new i.y(m));
            else if (g) {
              if (i.l(this, g), this.hasWorldviews = !!g.worldview_options, g.worldview_default && (this.worldviewDefault = g.worldview_default), g.vector_layers) {
                this.vectorLayers = g.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                for (const T of g.vector_layers)
                  this.vectorLayerIds.push(T.id), g.worldview && g.worldview[T.source] && this.localizableLayerIds.add(T.id);
              }
              g.bounds && (this.tileBounds = new Vo(g.bounds, this.minzoom, this.maxzoom)), an(g.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
            }
            t && t(m);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = i.aC(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return this._options.tiles = t, this.reload(), this;
        }
        setUrl(t) {
          return this.url = t, this._options.url = t, this.reload(), this;
        }
        onRemove(t) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return i.l({}, this._options);
        }
        loadTile(t, s) {
          const h = t.tileID.canonical.url(this.tiles, this.scheme), m = this.map._requestManager.normalizeTileURL(h), g = this.map._requestManager.transformRequest(m, i.R.Tile), T = this.map.style ? this.map.style.getLut(this.scope) : null, z = T ? { image: T.image.clone() } : null, R = { request: g, data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, maxZoom: this.maxzoom, lut: z, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
          if (this.hasWorldviews && i.f(h) && (R.worldview = this.map.getWorldview() || this.worldviewDefault, R.localizableLayerIds = this.localizableLayerIds), R.request.collectResourceTiming = this._collectResourceTiming, t.actor && t.state !== "expired")
            t.state === "loading" ? t.reloadCallback = s : t.request = t.actor.send("reloadTile", R, F.bind(this));
          else if (t.actor = this._tileWorkers[m] = this._tileWorkers[m] || this.dispatcher.getActor(), this.dispatcher.ready)
            t.request = t.actor.send("loadTile", R, F.bind(this), void 0, !0);
          else {
            const N = i.aD.call({ deduped: this._deduped }, R, (j, G) => {
              j || !G ? F.call(this, j) : (R.data = { cacheControl: G.cacheControl, expires: G.expires, rawData: G.rawData.slice(0) }, t.actor && t.actor.send("loadTile", R, F.bind(this), void 0, !0));
            }, !0);
            t.request = { cancel: N };
          }
          function F(N, j) {
            return delete t.request, t.aborted ? s(null) : N && N.status !== 404 ? s(N) : (j && j.resourceTiming && (t.resourceTiming = j.resourceTiming), this.map._refreshExpiredTiles && j && t.setExpiryData(j), t.loadVectorData(j, this.map.painter), i.aE(this.dispatcher), s(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));
          }
        }
        abortTile(t) {
          t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send("abortTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(t, s) {
          t.actor && t.actor.send("removeTile", { uid: t.uid, type: this.type, source: this.id, scope: this.scope }), t.destroy();
        }
        hasTransition() {
          return !1;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class tn extends i.E {
        constructor(t, s, h, m) {
          super(), this.id = t, this.dispatcher = h, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = i.l({ type: "raster" }, s), i.l(this, i.ay(s, ["url", "scheme", "tileSize"]));
        }
        load(t) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._tileJSONRequest = al(this._options, this.map._requestManager, null, null, (s, h) => {
            this._tileJSONRequest = null, this._loaded = !0, s ? this.fire(new i.y(s)) : h && (i.l(this, h), h.raster_layers && (this.rasterLayers = h.raster_layers, this.rasterLayerIds = this.rasterLayers.map((m) => m.id)), h.bounds && (this.tileBounds = new Vo(h.bounds, this.minzoom, this.maxzoom)), an(h.tiles), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), t && t(s);
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          this.map = t, this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = i.aC(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return this._options.tiles = t, this.reload(), this;
        }
        setUrl(t) {
          return this.url = t, this._options.url = t, this.reload(), this;
        }
        onRemove(t) {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return i.l({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t, s) {
          const h = i.q.devicePixelRatio >= 2, m = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), h, this.tileSize);
          t.request = i.o(this.map._requestManager.transformRequest(m, i.R.Tile), (g, T, z, R) => (delete t.request, t.aborted ? (t.state = "unloaded", s(null)) : g ? (t.state = "errored", s(g)) : T ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: z, expires: R }), t.setTexture(T, this.map.painter), t.state = "loaded", i.aE(this.dispatcher), void s(null)) : s(null)));
        }
        abortTile(t, s) {
          t.request && (t.request.cancel(), delete t.request), s && s();
        }
        unloadTile(t, s) {
          t.texture && t.texture instanceof i.T ? (t.destroy(!0), t.texture && t.texture instanceof i.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), s && s();
        }
        hasTransition() {
          return !1;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
      }
      class xn extends tn {
        constructor(t, s, h, m) {
          super(t, s, h, m), this.type = "raster-array", this.maxzoom = 22, this._options = i.l({ type: "raster-array" }, s);
        }
        triggerRepaint(t) {
          const s = this.map.painter._terrain, h = this.map.style.getSourceCache(this.id);
          s && s.enabled && h && s._clearRenderCacheForTile(h.id, t.tileID), this.map.triggerRepaint();
        }
        loadTile(t, s) {
          const h = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), m = this.map._requestManager.transformRequest(h, i.R.Tile);
          t.requestParams = m, t.actor || (t.actor = this.dispatcher.getActor()), t.request = t.fetchHeader(void 0, (g, T, z, R) => {
            if (delete t.request, t.aborted)
              return t.state = "unloaded", s(null);
            if (g)
              return g.code === 20 ? void 0 : (t.state = "errored", s(g));
            this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: z, expires: R }), t.state = "empty", s(null);
          });
        }
        unloadTile(t, s) {
          const h = t.texture;
          h && h instanceof i.T ? (t.destroy(!0), this.map.painter.saveTileTexture(h)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = "unloaded";
        }
        prepareTile(t, s, h) {
          t._isHeaderLoaded && (t.state !== "empty" && (t.state = "reloading"), t.fetchBand(s, h, (m, g) => {
            if (m)
              return t.state = "errored", this.fire(new i.y(m)), void this.triggerRepaint(t);
            g && (t.setTexture(g, this.map.painter), t.state = "loaded", this.triggerRepaint(t));
          }));
        }
        getInitialBand(t) {
          if (!this.rasterLayers)
            return 0;
          const s = this.rasterLayers.find(({ id: g }) => g === t), h = s && s.fields, m = h && h.bands && h.bands;
          return m ? m[0] : 0;
        }
        getTextureDescriptor(t, s, h) {
          if (!t)
            return;
          const m = s.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
          if (!m)
            return;
          let g = null;
          s instanceof i.aH ? g = s.paint.get("raster-array-band") : s instanceof i.aI && (g = s.paint.get("raster-particle-array-band"));
          const T = g || this.getInitialBand(m);
          if (T != null)
            if (t.textureDescriptor) {
              if (!t.updateNeeded(m, T) || h)
                return Object.assign({}, t.textureDescriptor, { texture: t.texture });
            } else
              this.prepareTile(t, m, T);
        }
      }
      const no = { vector: Uo, raster: tn, "raster-dem": class extends tn {
        constructor(c, t, s, h) {
          super(c, t, s, h), this.type = "raster-dem", this.maxzoom = 22, this._options = i.l({ type: "raster-dem" }, t), this.encoding = t.encoding || "mapbox";
        }
        loadTile(c, t) {
          const s = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
          function h(m, g) {
            m && (c.state = "errored", t(m)), g && (c.dem = g, c.dem.onDeserialize(), c.needsHillshadePrepare = !0, c.needsDEMTextureUpload = !0, c.state = "loaded", t(null));
          }
          c.request = i.o(this.map._requestManager.transformRequest(s, i.R.Tile), (function(m, g, T, z) {
            if (delete c.request, c.aborted)
              c.state = "unloaded", t(null);
            else if (m)
              c.state = "errored", t(m);
            else if (g) {
              this.map._refreshExpiredTiles && c.setExpiryData({ cacheControl: T, expires: z });
              const R = ImageBitmap && g instanceof ImageBitmap && i.t(), F = 1 - (g.width - i.aF(g.width)) / 2;
              F < 1 || c.neighboringTiles || (c.neighboringTiles = this._getNeighboringTiles(c.tileID));
              const N = R ? g : i.q.getImageData(g, F), j = { uid: c.uid, coord: c.tileID, source: this.id, scope: this.scope, rawImageData: N, encoding: this.encoding, padding: F };
              c.actor && c.state !== "expired" || (c.actor = this.dispatcher.getActor(), c.actor.send("loadDEMTile", j, h.bind(this), void 0, !0));
            }
          }).bind(this));
        }
        _getNeighboringTiles(c) {
          const t = c.canonical, s = Math.pow(2, t.z), h = (t.x - 1 + s) % s, m = t.x === 0 ? c.wrap - 1 : c.wrap, g = (t.x + 1 + s) % s, T = t.x + 1 === s ? c.wrap + 1 : c.wrap, z = {};
          return z[new i.aG(c.overscaledZ, m, t.z, h, t.y).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, g, t.y).key] = { backfilled: !1 }, t.y > 0 && (z[new i.aG(c.overscaledZ, m, t.z, h, t.y - 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, c.wrap, t.z, t.x, t.y - 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, g, t.y - 1).key] = { backfilled: !1 }), t.y + 1 < s && (z[new i.aG(c.overscaledZ, m, t.z, h, t.y + 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, c.wrap, t.z, t.x, t.y + 1).key] = { backfilled: !1 }, z[new i.aG(c.overscaledZ, T, t.z, g, t.y + 1).key] = { backfilled: !1 }), z;
        }
      }, "raster-array": xn, geojson: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = s.getActor(), this.setEventedParent(h), this._data = t.data, this._options = i.l({}, t), this._collectResourceTiming = t.collectResourceTiming, t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.minzoom !== void 0 && (this.minzoom = t.minzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), this.promoteId = t.promoteId;
          const m = i.ag / this.tileSize;
          this.workerOptions = i.l({ source: this.id, scope: this.scope, cluster: t.cluster || !1, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * m, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * m, extent: i.ag, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || !1, generateId: t.generateId || !1 }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: i.ag, radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * m, log: !1, generateId: t.generateId || !1 }, clusterProperties: t.clusterProperties, filter: t.filter, dynamic: t.dynamic }, t.workerOptions);
        }
        onAdd(c) {
          this.map = c, this.setData(this._data);
        }
        setData(c) {
          return this._data = c, this._updateWorkerData(), this;
        }
        updateData(c) {
          if (!this._options.dynamic)
            return this.fire(new i.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
          if (typeof c != "string" && (c.type === "Feature" && (c = { type: "FeatureCollection", features: [c] }), c.type !== "FeatureCollection"))
            return this.fire(new i.y(new Error("Data to update should be a feature or a feature collection.")));
          if (this._coalesce && typeof c != "string" && typeof this._data != "string" && this._data.type === "FeatureCollection") {
            const t = /* @__PURE__ */ new Map();
            for (const s of this._data.features)
              t.set(s.id, s);
            for (const s of c.features)
              t.set(s.id, s);
            this._data.features = [...t.values()];
          } else
            this._data = c;
          return this._updateWorkerData(!0), this;
        }
        getClusterExpansionZoom(c, t) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: c, source: this.id, scope: this.scope }, t), this;
        }
        getClusterChildren(c, t) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: c, source: this.id, scope: this.scope }, t), this;
        }
        getClusterLeaves(c, t, s, h) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: c, limit: t, offset: s }, h), this;
        }
        _updateWorkerData(c = !1) {
          if (this._pendingLoad)
            return void (this._coalesce = !0);
          this.fire(new i.z("dataloading", { dataType: "source" })), this._loaded = !1;
          const t = i.l({ append: c }, this.workerOptions);
          t.scope = this.scope;
          const s = this._data;
          typeof s == "string" ? (t.request = this.map._requestManager.transformRequest(i.q.resolveURL(s), i.R.Source), t.request.collectResourceTiming = this._collectResourceTiming) : t.data = JSON.stringify(s), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t, (h, m) => {
            if (this._loaded = !0, this._pendingLoad = null, h)
              this.fire(new i.y(h));
            else {
              const g = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && m && m.resourceTiming && m.resourceTiming[this.id] && (g.resourceTiming = m.resourceTiming[this.id]), c && (this._partialReload = !0), this.fire(new i.z("data", g)), this._partialReload = !1, this._metadataFired = !0;
            }
            this._coalesce && (this._updateWorkerData(c), this._coalesce = !1);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(c, t) {
          const s = c.actor ? "reloadTile" : "loadTile";
          c.actor = this.actor;
          const h = this.map.style ? this.map.style.getLut(this.scope) : null, m = h ? { image: h.image.clone() } : null, g = this._partialReload, T = { type: this.type, uid: c.uid, tileID: c.tileID, tileZoom: c.tileZoom, zoom: c.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: m, scope: this.scope, pixelRatio: i.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, scaleFactor: this.map.getScaleFactor(), partial: g };
          c.request = this.actor.send(s, T, (z, R) => g && !R ? (c.state = "loaded", t(null)) : (delete c.request, c.destroy(), c.aborted ? t(null) : z ? t(z) : (c.loadVectorData(R, this.map.painter, s === "reloadTile"), t(null))), void 0, s === "loadTile");
        }
        abortTile(c) {
          c.request && (c.request.cancel(), delete c.request), c.aborted = !0;
        }
        unloadTile(c, t) {
          this.actor.send("removeTile", { uid: c.uid, type: this.type, source: this.id, scope: this.scope }), c.destroy();
        }
        onRemove(c) {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return i.l({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }, video: class extends i.aJ {
        constructor(c, t, s, h) {
          super(c, t, s, h), this.roundZoom = !0, this.type = "video", this.options = t;
        }
        load() {
          this._loaded = !1;
          const c = this.options;
          this.urls = [];
          for (const t of c.urls)
            this.urls.push(this.map._requestManager.transformRequest(t, i.R.Source).url);
          i.aK(this.urls, (t, s) => {
            this._loaded = !0, t ? this.fire(new i.y(t)) : s && (this.video = s, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(c) {
          if (this.video) {
            const t = this.video.seekable;
            c < t.start(0) || c > t.end(0) ? this.fire(new i.y(new i.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : this.video.currentTime = c;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(c) {
          this.map || (this.map = c, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const c = this.map.painter.context, t = c.gl;
          this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : (this.texture = new i.T(c, this.video, t.RGBA8), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(c);
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: i.aJ, model: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "model", this.models = [], this._loaded = !1, this._options = t;
        }
        load() {
          const c = [];
          for (const t in this._options.models) {
            const s = this._options.models[t], h = i.aM(this.map._requestManager.transformRequest(s.uri, i.R.Model).url).then((m) => {
              if (!m)
                return;
              const g = i.aN(m), T = new i.aO(t, s.position, s.orientation, g);
              T.computeBoundsAndApplyParent(), this.models.push(T);
            }).catch((m) => {
              this.fire(new i.y(new Error(`Could not load model ${t} from ${s.uri}: ${m.message}`)));
            });
            c.push(h);
          }
          return Promise.allSettled(c).then(() => {
            this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" }));
          }).catch((t) => {
            this.fire(new i.y(new Error(`Could not load models: ${t.message}`)));
          });
        }
        onAdd(c) {
          this.map = c, this.load();
        }
        hasTransition() {
          return !1;
        }
        loaded() {
          return this._loaded;
        }
        getModels() {
          return this.models;
        }
        loadTile(c, t) {
        }
        serialize() {
          return { type: "model" };
        }
      }, "batched-model": class extends i.E {
        constructor(c, t, s, h) {
          super(), this.type = "batched-model", this.id = c, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = s, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(h);
        }
        onAdd(c) {
          this.map = c, this.load();
        }
        load(c) {
          this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" }));
          const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, s = this.map.getWorldview();
          this._tileJSONRequest = al(this._options, this.map._requestManager, t, s, (h, m) => {
            this._tileJSONRequest = null, this._loaded = !0, h ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), s && s.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${s}`), this.fire(new i.y(h))) : m && (i.l(this, m), m.bounds && (this.tileBounds = new Vo(m.bounds, this.minzoom, this.maxzoom)), an(m.tiles, this.map._requestManager._customAccessToken), this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }))), c && c(h);
          });
        }
        hasTransition() {
          return !1;
        }
        hasTile(c) {
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }
        loaded() {
          return this._loaded;
        }
        loadTile(c, t) {
          const s = this.map._requestManager.normalizeTileURL(c.tileID.canonical.url(this.tiles, this.scheme)), h = { request: this.map._requestManager.transformRequest(s, i.R.Tile), data: void 0, uid: c.uid, tileID: c.tileID, tileZoom: c.tileZoom, zoom: c.tileID.overscaledZ, tileSize: this.tileSize * c.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: c.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, lut: null, maxZoom: null, promoteId: null, pixelRatio: null, scaleFactor: null };
          if (c.actor && c.state !== "expired")
            if (c.state === "loading")
              c.reloadCallback = t;
            else {
              if (c.buckets) {
                const g = Object.values(c.buckets);
                for (const T of g)
                  T.dirty = !0;
                return void (c.state = "loaded");
              }
              c.request = c.actor.send("reloadTile", h, m.bind(this));
            }
          else
            c.actor = this.dispatcher.getActor(), c.request = c.actor.send("loadTile", h, m.bind(this), void 0, !0);
          function m(g, T) {
            return c.aborted ? t(null) : g && g.status !== 404 ? t(g) : (this.map._refreshExpiredTiles && T && c.setExpiryData(T), c.loadModelData(T, this.map.painter), c.state = "loaded", void t(null));
          }
        }
        serialize() {
          return i.l({}, this._options);
        }
      }, canvas: class extends i.aJ {
        constructor(c, t, s, h) {
          super(c, t, s, h), t.coordinates ? Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some((m) => !Array.isArray(m) || m.length !== 2 || m.some((g) => typeof g != "number")) || this.fire(new i.y(new i.V(`sources.${c}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new i.y(new i.V(`sources.${c}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != "boolean" && this.fire(new i.y(new i.V(`sources.${c}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == "string" || t.canvas instanceof HTMLCanvasElement || this.fire(new i.y(new i.V(`sources.${c}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new i.y(new i.V(`sources.${c}`, null, 'missing required property "canvas"'))), this.options = t, this.animate = t.animate === void 0 || t.animate;
        }
        load() {
          this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new i.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = !0, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = !1);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(c) {
          this.map = c, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove(c) {
          this.pause();
        }
        prepare() {
          let c = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, c = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, c = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
            return;
          const t = this.map.painter.context;
          this.texture ? !c && !this._playing || this.texture instanceof i.aL || this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new i.T(t, this.canvas, t.gl.RGBA8, { premultiply: !0 }), this._prepareData(t);
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const c of [this.canvas.width, this.canvas.height])
            if (isNaN(c) || c <= 0)
              return !0;
          return !1;
        }
      }, custom: class extends i.E {
        constructor(c, t, s, h) {
          super(), this.id = c, this.type = "custom", this._dataType = "raster", this._dispatcher = s, this._implementation = t, this.setEventedParent(h), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new i.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new i.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new Vo(this._implementation.bounds, this.minzoom, this.maxzoom)), t.update = this._update.bind(this), t.clearTiles = this._clearTiles.bind(this), t.coveringTiles = this._coveringTiles.bind(this), i.l(this, i.ay(t, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
        }
        serialize() {
          return i.ay(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
        }
        load() {
          this._loaded = !0, this.fire(new i.z("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(c) {
          this.map = c, this._loaded = !1, this.fire(new i.z("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(c), this.load();
        }
        onRemove(c) {
          this._implementation.onRemove && this._implementation.onRemove(c);
        }
        hasTile(c) {
          if (this._implementation.hasTile) {
            const { x: t, y: s, z: h } = c.canonical;
            return this._implementation.hasTile({ x: t, y: s, z: h });
          }
          return !this.tileBounds || this.tileBounds.contains(c.canonical);
        }
        loadTile(c, t) {
          const { x: s, y: h, z: m } = c.tileID.canonical, g = new AbortController();
          c.request = Promise.resolve(this._implementation.loadTile({ x: s, y: h, z: m }, { signal: g.signal })).then((function(T) {
            return delete c.request, c.aborted ? (c.state = "unloaded", t(null)) : T === void 0 ? (c.state = "errored", t(null)) : T === null ? (this.loadTileData(c, { width: this.tileSize, height: this.tileSize, data: null }), c.state = "loaded", t(null)) : function(z) {
              return z instanceof ImageData || z instanceof HTMLCanvasElement || z instanceof ImageBitmap || z instanceof HTMLImageElement;
            }(T) ? (this.loadTileData(c, T), c.state = "loaded", void t(null)) : (c.state = "errored", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
          }).bind(this)).catch((T) => {
            T.code !== 20 && (c.state = "errored", t(T));
          }), c.request.cancel = () => g.abort();
        }
        loadTileData(c, t) {
          c.setTexture(t, this.map.painter);
        }
        unloadTile(c, t) {
          if (c.texture && c.texture instanceof i.T ? (c.destroy(!0), c.texture && c.texture instanceof i.T && this.map.painter.saveTileTexture(c.texture)) : c.destroy(), this._implementation.unloadTile) {
            const { x: s, y: h, z: m } = c.tileID.canonical;
            this._implementation.unloadTile({ x: s, y: h, z: m });
          }
          t && t();
        }
        abortTile(c, t) {
          c.request && c.request.cancel && (c.request.cancel(), delete c.request), t && t();
        }
        hasTransition() {
          return !1;
        }
        _coveringTiles() {
          return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((c) => ({ x: c.canonical.x, y: c.canonical.y, z: c.canonical.z }));
        }
        _clearTiles() {
          const c = i.aC(this.id, this.scope);
          this.map.style.clearSource(c);
        }
        _update() {
          this.fire(new i.z("data", { dataType: "source", sourceDataType: "content" }));
        }
      } }, jo = function(c, t, s, h) {
        const m = new no[t.type](c, t, s, h);
        if (m.id !== c)
          throw new Error(`Expected Source id to be ${c} instead of ${m.id}`);
        return i.aP(["load", "abort", "unload", "serialize", "prepare"], m), m;
      };
      function oa(c, t, s, h, m = !1) {
        const g = t.sourceCache.transform, T = t.sourceCache.tilesIn(c, t.has3DLayers, m);
        T.sort(Hn);
        const z = [];
        for (const R of T) {
          const F = R.tile.queryRenderedFeatures(t, R, s, h, g, m);
          Object.keys(F).length && z.push({ wrappedTileID: R.tile.tileID.wrapped().key, queryResults: F });
        }
        return z.length === 0 ? {} : function(R) {
          const F = {}, N = {};
          for (const j of R) {
            const G = j.queryResults, W = j.wrappedTileID, te = N[W] = N[W] || {};
            for (const ee in G) {
              const se = G[ee], oe = te[ee] = te[ee] || {}, ce = F[ee] = F[ee] || [];
              for (const _e of se)
                oe[_e.featureIndex] || (oe[_e.featureIndex] = !0, ce.push(_e));
            }
          }
          return F;
        }(z);
      }
      function La(c, t, s, h, m) {
        const g = {}, T = h.queryRenderedSymbols(c), z = [];
        for (const R of Object.keys(T).map(Number))
          z.push(m[R]);
        z.sort(Hn);
        for (const R of z) {
          const F = R.featureIndex.lookupSymbolFeatures(T[R.bucketInstanceId], R.bucketIndex, R.sourceLayerIndex, t, s);
          for (const N in F) {
            const j = g[N] = g[N] || [], G = F[N];
            G.sort((W, te) => {
              const ee = R.featureSortOrder;
              if (ee) {
                const se = ee.indexOf(W.featureIndex);
                return ee.indexOf(te.featureIndex) - se;
              }
              return te.featureIndex - W.featureIndex;
            });
            for (const W of G)
              j.push(W);
          }
        }
        return g;
      }
      function Vi(c, t) {
        const s = c.getRenderableIds().map((g) => c.getTileByID(g)), h = [], m = {};
        for (let g = 0; g < s.length; g++) {
          const T = s[g], z = T.tileID.canonical.key;
          m[z] || (m[z] = !0, T.querySourceFeatures(h, t));
        }
        return h;
      }
      function Hn(c, t) {
        const s = c.tileID, h = t.tileID;
        return s.overscaledZ - h.overscaledZ || s.canonical.y - h.canonical.y || s.wrap - h.wrap || s.canonical.x - h.canonical.x;
      }
      function ll(c, t) {
        const s = {};
        if (!t)
          return s;
        for (const h of c) {
          const m = h.layerIds.map((g) => t.getLayer(g)).filter(Boolean);
          if (m.length !== 0) {
            h.layers = m, h.stateDependentLayerIds && (h.stateDependentLayers = h.stateDependentLayerIds.map((g) => m.filter((T) => T.id === g)[0]));
            for (const g of m)
              s[g.fqid] = h;
          }
        }
        return s;
      }
      const Zs = 32, Qn = 33, Ar = new Uint16Array(8184);
      for (let c = 0; c < 2046; c++) {
        let t = c + 2, s = 0, h = 0, m = 0, g = 0, T = 0, z = 0;
        for (1 & t ? m = g = T = Zs : s = h = z = Zs; (t >>= 1) > 1; ) {
          const F = s + m >> 1, N = h + g >> 1;
          1 & t ? (m = s, g = h, s = T, h = z) : (s = m, h = g, m = T, g = z), T = F, z = N;
        }
        const R = 4 * c;
        Ar[R + 0] = s, Ar[R + 1] = h, Ar[R + 2] = m, Ar[R + 3] = g;
      }
      const nr = new Uint16Array(2178), Ys = new Uint8Array(1089), Yn = new Uint16Array(1089);
      function $r(c) {
        return c === 0 ? -0.03125 : c === 32 ? 0.03125 : 0;
      }
      const Pr = (() => ({ type: 2, extent: i.ag, loadGeometry: () => [[new i.P(0, 0), new i.P(i.ag + 1, 0), new i.P(i.ag + 1, i.ag + 1), new i.P(0, i.ag + 1), new i.P(0, 0)]] }))();
      class Cr {
        constructor(t, s, h, m, g) {
          this.tileID = t, this.uid = i.aV(), this.uses = 0, this.tileSize = s, this.tileZoom = h, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = g, m && m.style && (this._lastUpdatedBrightness = m.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", m && m.transform && (this.projection = m.transform.projection);
        }
        registerFadeDuration(t) {
          const s = t + this.timeAdded;
          s < i.q.now() || this.fadeEndTime && s < this.fadeEndTime || (this.fadeEndTime = s);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = i.aQ(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t, s, h) {
          if (this.unloadVectorData(), this.state = "loaded", t) {
            t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = ll(t.buckets, s.style), this.hasSymbolBuckets = !1;
            for (const m in this.buckets) {
              const g = this.buckets[m];
              if (g instanceof i.aX) {
                if (this.hasSymbolBuckets = !0, !h)
                  break;
                g.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets)
              for (const m in this.buckets) {
                const g = this.buckets[m];
                if (g instanceof i.aX && g.hasRTLText) {
                  this.hasRTLText = !0, i.aY();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const m in this.buckets) {
              const g = this.buckets[m], T = s.style.getOwnLayer(m);
              if (!T)
                continue;
              const z = T.queryRadius(g);
              this.queryPadding = Math.max(this.queryPadding, z);
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;
          } else
            this.collisionBoxArray = new i.aW();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t in this.buckets)
              this.buckets[t].destroy();
            this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
          }
        }
        loadModelData(t, s, h) {
          t && (t.resourceTiming && (this.resourceTiming = t.resourceTiming), this.buckets = { ...this.buckets, ...ll(t.buckets, s.style) }, t.featureIndex && (this.latestFeatureIndex = t.featureIndex));
        }
        getBucket(t) {
          return this.buckets[t.fqid];
        }
        upload(t) {
          for (const m in this.buckets) {
            const g = this.buckets[m];
            g.uploadPending() && g.upload(t);
          }
          const s = t.gl, h = this.imageAtlas;
          if (h && !h.uploaded) {
            const m = !!Object.keys(h.patternPositions).length;
            this.imageAtlasTexture = new i.T(t, h.image, s.RGBA8, { useMipmap: m }), this.imageAtlas.uploaded = !0;
          }
          this.glyphAtlasImage && (this.glyphAtlasTexture = new i.T(t, this.glyphAtlasImage, s.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new i.T(t, this.lineAtlas.image, s.R8), this.lineAtlas.uploaded = !0);
        }
        prepare(t, s, h) {
          if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, h), !s || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)
            return;
          const m = s.style.getBrightness();
          (this._lastUpdatedBrightness || m) && (this._lastUpdatedBrightness && m && Math.abs(this._lastUpdatedBrightness - m) < 1e-3 || (this.updateBuckets(s, this._lastUpdatedBrightness !== m), this._lastUpdatedBrightness = m));
        }
        queryRenderedFeatures(t, s, h, m, g, T) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile)
            return {};
          const z = function(R, F) {
            const N = i.ab.mat4.fromScaling([], [0.5 * R.width, 0.5 * -R.height, 1]);
            return i.ab.mat4.translate(N, N, [1, -1, 0]), i.ab.mat4.multiply(N, N, R.calculateProjMatrix(F.toUnwrapped())), Float32Array.from(N);
          }(g, this.tileID);
          return this.latestFeatureIndex.query(t, { tilespaceGeometry: s, pixelPosMatrix: z, transform: m, availableImages: h, tileTransform: this.tileTransform });
        }
        querySourceFeatures(t, s) {
          const h = this.latestFeatureIndex;
          if (!h || !h.rawTileData)
            return;
          const m = h.loadVTLayers(), g = s ? s.sourceLayer : "", T = m._geojsonTileLayer || m[g];
          if (!T)
            return;
          const z = i.aZ(s && s.filter), { z: R, x: F, y: N } = this.tileID.canonical, j = { z: R, x: F, y: N };
          for (let G = 0; G < T.length; G++) {
            const W = T.feature(G);
            if (z.needGeometry) {
              const se = i.a_(W, !0);
              if (!z.filter(new i.a8(this.tileID.overscaledZ), se, this.tileID.canonical))
                continue;
            } else if (!z.filter(new i.a8(this.tileID.overscaledZ), W))
              continue;
            const te = h.getId(W, g), ee = new i.a$(W, R, F, N, te);
            ee.tile = j, t.push(ee);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const s = this.expirationTime;
          if (t.cacheControl) {
            const h = i.b0(t.cacheControl);
            h["max-age"] && (this.expirationTime = Date.now() + 1e3 * h["max-age"]);
          } else
            t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const h = Date.now();
            let m = !1;
            if (this.expirationTime > h)
              m = !1;
            else if (s)
              if (this.expirationTime < s)
                m = !0;
              else {
                const g = this.expirationTime - s;
                g ? this.expirationTime = h + Math.max(g, 3e4) : m = !0;
              }
            else
              m = !0;
            m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        refreshFeatureState(t) {
          this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && t && this.updateBuckets(t);
        }
        updateBuckets(t, s) {
          if (!this.latestFeatureIndex || !t.style)
            return;
          const h = this.latestFeatureIndex.loadVTLayers(), m = t.style.listImages(), g = t.style.getBrightness();
          for (const T in this.buckets) {
            if (!t.style.hasLayer(T))
              continue;
            const z = this.buckets[T], R = z.layers[0], F = R.sourceLayer || "_geojsonTileLayer", N = h[F], j = t.style.getLayerSourceCache(R);
            let G = {};
            j && (G = j._state.getState(F, void 0));
            const W = this.imageAtlas && this.imageAtlas.patternPositions || {}, te = Object.keys(G).length > 0 && !s;
            te && !z.stateDependentLayers.length && !s || z.update(G, N, m, W, te ? z.stateDependentLayers : z.layers, s, g), (z instanceof i.b1 || z instanceof i.b2) && t._terrain && t._terrain.enabled && j && z.programConfigurations.needsUpload && t._terrain._clearRenderCacheForTile(j.id, this.tileID);
            const ee = t && t.style && t.style.getOwnLayer(T);
            ee && (this.queryPadding = Math.max(this.queryPadding, ee.queryRadius(z)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < i.q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = i.q.now() + t;
        }
        setTexture(t, s) {
          const h = s.context, m = h.gl;
          this.texture = this.texture || s.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t) : (this.texture = new i.T(h, t, m.RGBA8, { useMipmap: !0 }), this.texture.bind(m.LINEAR, m.CLAMP_TO_EDGE));
        }
        setDependencies(t, s) {
          const h = {};
          for (const m of s)
            h[m] = !0;
          this.dependencies[t] = h;
        }
        hasDependency(t, s) {
          for (const h of t) {
            const m = this.dependencies[h];
            if (m) {
              for (const g of s)
                if (m[g])
                  return !0;
            }
          }
          return !1;
        }
        clearQueryDebugViz() {
        }
        _makeDebugTileBoundsBuffers(t, s) {
          if (!s || s.name === "mercator" || this._tileDebugBuffer)
            return;
          const h = i.b3(Pr, this.tileID.canonical, this.tileTransform)[0], m = new i.b4(), g = new i.b5();
          for (let T = 0; T < h.length; T++) {
            const { x: z, y: R } = h[T];
            m.emplaceBack(z, R), g.emplaceBack(T);
          }
          g.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(g), this._tileDebugBuffer = t.createVertexBuffer(m, i.b6.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, m.length, g.length);
        }
        _makeTileBoundsBuffers(t, s) {
          if (this._tileBoundsBuffer || !s || s.name === "mercator")
            return;
          const h = i.b3(Pr, this.tileID.canonical, this.tileTransform)[0];
          let m, g;
          if (this.isRaster) {
            const T = function(z, R) {
              const F = i.aQ(z, R), N = Math.pow(2, z.z);
              for (let se = 0; se < Qn; se++)
                for (let oe = 0; oe < Qn; oe++) {
                  const ce = i.aR((z.x + (oe + $r(oe)) / Zs) / N), _e = i.aS((z.y + (se + $r(se)) / Zs) / N), pe = R.project(ce, _e), Te = se * Qn + oe;
                  nr[2 * Te + 0] = Math.round((pe.x * F.scale - F.x) * i.ag), nr[2 * Te + 1] = Math.round((pe.y * F.scale - F.y) * i.ag);
                }
              Ys.fill(0), Yn.fill(0);
              for (let se = 2045; se >= 0; se--) {
                const oe = 4 * se, ce = Ar[oe + 0], _e = Ar[oe + 1], pe = Ar[oe + 2], Te = Ar[oe + 3], xe = ce + pe >> 1, be = _e + Te >> 1, ve = xe + be - _e, Pe = be + ce - xe, Oe = _e * Qn + ce, Xe = Te * Qn + pe, Ze = be * Qn + xe, ke = Math.hypot((nr[2 * Oe + 0] + nr[2 * Xe + 0]) / 2 - nr[2 * Ze + 0], (nr[2 * Oe + 1] + nr[2 * Xe + 1]) / 2 - nr[2 * Ze + 1]) >= 16;
                Ys[Ze] = Ys[Ze] || (ke ? 1 : 0), se < 1022 && (Ys[Ze] = Ys[Ze] || Ys[(_e + Pe >> 1) * Qn + (ce + ve >> 1)] || Ys[(Te + Pe >> 1) * Qn + (pe + ve >> 1)]);
              }
              const j = new i.aT(), G = new i.aU();
              let W = 0;
              function te(se, oe) {
                const ce = oe * Qn + se;
                return Yn[ce] === 0 && (j.emplaceBack(nr[2 * ce + 0], nr[2 * ce + 1], se * i.ag / Zs, oe * i.ag / Zs), Yn[ce] = ++W), Yn[ce] - 1;
              }
              function ee(se, oe, ce, _e, pe, Te) {
                const xe = se + ce >> 1, be = oe + _e >> 1;
                if (Math.abs(se - pe) + Math.abs(oe - Te) > 1 && Ys[be * Qn + xe])
                  ee(pe, Te, se, oe, xe, be), ee(ce, _e, pe, Te, xe, be);
                else {
                  const ve = te(se, oe), Pe = te(ce, _e), Oe = te(pe, Te);
                  G.emplaceBack(ve, Pe, Oe);
                }
              }
              return ee(0, 0, Zs, Zs, Zs, 0), ee(Zs, Zs, 0, 0, 0, Zs), { vertices: j, indices: G };
            }(this.tileID.canonical, s);
            m = T.vertices, g = T.indices;
          } else {
            m = new i.aT(), g = new i.aU();
            for (const { x: z, y: R } of h)
              m.emplaceBack(z, R, 0, 0);
            const T = i.b8(m.int16, void 0, 4);
            for (let z = 0; z < T.length; z += 3)
              g.emplaceBack(T[z], T[z + 1], T[z + 2]);
          }
          this._tileBoundsBuffer = t.createVertexBuffer(m, i.b9.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(g), this._tileBoundsSegments = i.b7.simpleSegment(0, 0, m.length, g.length);
        }
        _makeGlobeTileDebugBuffers(t, s) {
          const h = s.projection;
          if (!h || h.name !== "globe" || s.freezeTileCoverage)
            return;
          const m = this.tileID.canonical, g = i.ba(m, s), T = i.bb(g), z = i.ae(s.zoom);
          let R;
          z > 0 && (R = i.ab.mat4.invert(new Float64Array(16), s.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, m, s, T, R, z), this._makeGlobeTileDebugTextBuffer(t, m, s, T, R, z);
        }
        _globePoint(t, s, h, m, g, T, z) {
          let R = i.bc(t, s, h);
          if (T) {
            const F = 1 << h.z, N = i.at(m.center.lng), j = i.aA(m.center.lat), G = (h.x + 0.5) / F - N;
            let W = 0;
            G > 0.5 ? W = -1 : G < -0.5 && (W = 1);
            let te = (t / i.ag + h.x) / F + W, ee = (s / i.ag + h.y) / F;
            te = (te - N) * m._pixelsPerMercatorPixel + N, ee = (ee - j) * m._pixelsPerMercatorPixel + j;
            const se = [te * m.worldSize, ee * m.worldSize, 0];
            i.ab.vec3.transformMat4(se, se, T), R = i.bd(R, se, z);
          }
          return i.ab.vec3.transformMat4(R, R, g);
        }
        _makeGlobeTileDebugBorderBuffer(t, s, h, m, g, T) {
          const z = new i.b4(), R = new i.b5(), F = new i.be(), N = (G, W, te, ee, se) => {
            const oe = (te - G) / (se - 1), ce = (ee - W) / (se - 1), _e = z.length;
            for (let pe = 0; pe < se; pe++) {
              const Te = G + pe * oe, xe = W + pe * ce;
              z.emplaceBack(Te, xe);
              const be = this._globePoint(Te, xe, s, h, m, g, T);
              F.emplaceBack(be[0], be[1], be[2]), R.emplaceBack(_e + pe);
            }
          }, j = i.ag;
          N(0, 0, j, 0, 16), N(j, 0, j, j, 16), N(j, j, 0, j, 16), N(0, j, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(R), this._tileDebugBuffer = t.createVertexBuffer(z, i.b6.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(F, i.bf.members), this._tileDebugSegments = i.b7.simpleSegment(0, 0, z.length, R.length);
        }
        _makeGlobeTileDebugTextBuffer(t, s, h, m, g, T) {
          const z = i.ag / 4, R = new i.b4(), F = new i.aU(), N = new i.be(), j = 25;
          F.reserve(32), R.reserve(j), N.reserve(j);
          const G = (W, te) => j * W + te;
          for (let W = 0; W < j; W++) {
            const te = W * z;
            for (let ee = 0; ee < j; ee++) {
              const se = ee * z;
              R.emplaceBack(se, te);
              const oe = this._globePoint(se, te, s, h, m, g, T);
              N.emplaceBack(oe[0], oe[1], oe[2]);
            }
          }
          for (let W = 0; W < 4; W++)
            for (let te = 0; te < 4; te++) {
              const ee = G(W, te), se = G(W, te + 1), oe = G(W + 1, te), ce = G(W + 1, te + 1);
              F.emplaceBack(ee, se, oe), F.emplaceBack(oe, se, ce);
            }
          this._tileDebugTextIndexBuffer = t.createIndexBuffer(F), this._tileDebugTextBuffer = t.createVertexBuffer(R, i.b6.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(N, i.bf.members), this._tileDebugTextSegments = i.b7.simpleSegment(0, 0, j, 32);
        }
        destroy(t = !1) {
          for (const s in this.buckets)
            this.buckets[s].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof i.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
        }
      }
      i.bg.setPbf(i.bh);
      class za extends Cr {
        constructor(t, s, h, m, g) {
          super(t, s, h, m, g), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
        }
        setTexture(t, s) {
          const h = s.context, m = h.gl;
          this.texture = this.texture || s.getTileTexture(t.width), this.texture && this.texture instanceof i.T ? this.texture.update(t, { premultiply: !1 }) : this.texture = new i.T(h, t, m.RGBA8, { premultiply: !1 });
        }
        flushQueues() {
          for (; this._workQueue.length; )
            this._workQueue.pop()();
          for (; this._fetchQueue.length; )
            this._fetchQueue.pop()();
        }
        fetchHeader(t = 16384, s) {
          const h = this._mrt = new i.bg(30), m = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t - 1) } });
          return this.entireBuffer = null, this.request = i.bi(m, (g, T, z, R) => {
            if (g)
              s(g);
            else
              try {
                const F = h.getHeaderLength(T);
                if (F > t)
                  return void (this.request = this.fetchHeader(F, s));
                h.parseHeader(T), this._isHeaderLoaded = !0;
                let N = 0;
                for (const j of Object.values(h.layers))
                  N = Math.max(N, j.dataIndex[j.dataIndex.length - 1].last_byte);
                T.byteLength >= N && (this.entireBuffer = T), s(null, this.entireBuffer || T, z, R);
              } catch (F) {
                s(F);
              }
          }), this.request;
        }
        fetchBand(t, s, h) {
          const m = this._mrt;
          if (!this._isHeaderLoaded || !m)
            return void h(new Error("Tile header is not ready"));
          const g = this.actor;
          if (!g)
            return void h(new Error("Can't fetch tile band without an actor"));
          let T;
          const z = (j, G) => {
            T.complete(j, G), j ? h(j) : (this.updateTextureDescriptor(t, s), h(null, this.textureDescriptor && this.textureDescriptor.img));
          }, R = (j, G) => {
            if (j)
              return h(j);
            const W = g.send("decodeRasterArray", { buffer: G, task: T }, z, void 0, !0);
            this._workQueue.push(() => {
              W && W.cancel(), T.cancel();
            });
          }, F = m.getLayer(t);
          if (!F)
            return void h(new Error(`Unknown sourceLayer "${t}"`));
          if (F.hasDataForBand(s))
            return this.updateTextureDescriptor(t, s), void h(null, this.textureDescriptor ? this.textureDescriptor.img : null);
          const N = F.getDataRange([s]);
          if (T = m.createDecodingTask(N), !T || T.tasks.length)
            if (this.flushQueues(), this.entireBuffer)
              R(null, this.entireBuffer.slice(N.firstByte, N.lastByte + 1));
            else {
              const j = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${N.firstByte}-${N.lastByte}` } }), G = i.bi(j, R);
              this._fetchQueue.push(() => {
                G.cancel(), T.cancel();
              });
            }
          else
            h(null);
        }
        updateNeeded(t, s) {
          return (!this.textureDescriptor || this.textureDescriptor.band !== s || this.textureDescriptor.layer !== t) && this.state !== "errored";
        }
        updateTextureDescriptor(t, s) {
          if (!this._mrt)
            return;
          const h = this._mrt.getLayer(t);
          if (!h || !h.hasBand(s) || !h.hasDataForBand(s))
            return;
          const { bytes: m, tileSize: g, buffer: T, offset: z, scale: R } = h.getBandView(s), F = g + 2 * T, N = { data: m, width: F, height: F }, j = this.texture;
          j && j instanceof i.T && j.update(N, { premultiply: !1 }), this.textureDescriptor = { layer: t, band: s, img: N, buffer: T, offset: z, tileSize: g, format: h.pixelFormat, mix: [R, 256 * R, 65536 * R, 16777216 * R] };
        }
      }
      class aa {
        constructor(t, s) {
          this.max = t, this.onRemove = s, this.reset();
        }
        reset() {
          for (const t in this.data)
            for (const s of this.data[t])
              s.timeout && clearTimeout(s.timeout), this.onRemove(s.value);
          return this.data = {}, this.order = [], this;
        }
        add(t, s, h) {
          const m = t.wrapped().key;
          this.data[m] === void 0 && (this.data[m] = []);
          const g = { value: s, timeout: void 0 };
          if (h !== void 0 && (g.timeout = setTimeout(() => {
            this.remove(t, g);
          }, h)), this.data[m].push(g), this.order.push(m), this.order.length > this.max) {
            const T = this._getAndRemoveByKey(this.order[0]);
            T && this.onRemove(T);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const s = this.data[t].shift();
          return s.timeout && clearTimeout(s.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), s.value;
        }
        getByKey(t) {
          const s = this.data[t];
          return s ? s[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, s) {
          if (!this.has(t))
            return this;
          const h = t.wrapped().key, m = s === void 0 ? 0 : this.data[h].indexOf(s), g = this.data[h][m];
          return this.data[h].splice(m, 1), g.timeout && clearTimeout(g.timeout), this.data[h].length === 0 && delete this.data[h], this.onRemove(g.value), this.order.splice(this.order.indexOf(h), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const s = this._getAndRemoveByKey(this.order[0]);
            s && this.onRemove(s);
          }
          return this;
        }
        filter(t) {
          const s = [];
          for (const h in this.data)
            for (const m of this.data[h])
              t(m.value) || s.push(m);
          for (const h of s)
            this.remove(h.value.tileID, h);
        }
      }
      class Go {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t, s, h) {
          const m = String(s);
          if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][m] = this.stateChanges[t][m] || {}, i.l(this.stateChanges[t][m], h), this.deletedStates[t] === null) {
            this.deletedStates[t] = {};
            for (const g in this.state[t])
              g !== m && (this.deletedStates[t][g] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][m] === null) {
            this.deletedStates[t][m] = {};
            for (const g in this.state[t][m])
              h[g] || (this.deletedStates[t][m][g] = null);
          } else
            for (const g in h)
              this.deletedStates[t] && this.deletedStates[t][m] && this.deletedStates[t][m][g] === null && delete this.deletedStates[t][m][g];
        }
        removeFeatureState(t, s, h) {
          if (this.deletedStates[t] === null)
            return;
          const m = String(s);
          if (this.deletedStates[t] = this.deletedStates[t] || {}, h && s !== void 0)
            this.deletedStates[t][m] !== null && (this.deletedStates[t][m] = this.deletedStates[t][m] || {}, this.deletedStates[t][m][h] = null);
          else if (s !== void 0)
            if (this.stateChanges[t] && this.stateChanges[t][m])
              for (h in this.deletedStates[t][m] = {}, this.stateChanges[t][m])
                this.deletedStates[t][m][h] = null;
            else
              this.deletedStates[t][m] = null;
          else
            this.deletedStates[t] = null;
        }
        getState(t, s) {
          const h = this.state[t] || {}, m = this.stateChanges[t] || {}, g = this.deletedStates[t];
          if (g === null)
            return {};
          if (s !== void 0) {
            const z = String(s), R = i.l({}, h[z], m[z]);
            if (g) {
              const F = g[s];
              if (F === null)
                return {};
              for (const N in F)
                delete R[N];
            }
            return R;
          }
          const T = i.l({}, h, m);
          if (g)
            for (const z in g)
              delete T[z];
          return T;
        }
        initializeTileState(t, s) {
          t.refreshFeatureState(s);
        }
        coalesceChanges(t, s) {
          const h = {};
          for (const m in this.stateChanges) {
            this.state[m] = this.state[m] || {};
            const g = {};
            for (const T in this.stateChanges[m])
              this.state[m][T] || (this.state[m][T] = {}), i.l(this.state[m][T], this.stateChanges[m][T]), g[T] = this.state[m][T];
            h[m] = g;
          }
          for (const m in this.deletedStates) {
            this.state[m] = this.state[m] || {};
            const g = {};
            if (this.deletedStates[m] === null)
              for (const T in this.state[m])
                g[T] = {}, this.state[m][T] = {};
            else
              for (const T in this.deletedStates[m]) {
                if (this.deletedStates[m][T] === null)
                  this.state[m][T] = {};
                else if (this.state[m][T])
                  for (const z of Object.keys(this.deletedStates[m][T]))
                    delete this.state[m][T][z];
                g[T] = this.state[m][T];
              }
            h[m] = h[m] || {}, i.l(h[m], g);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(h).length !== 0)
            for (const m in t)
              t[m].refreshFeatureState(s);
        }
      }
      class sr extends i.E {
        constructor(t, s, h) {
          super(), this.id = t, this._onlySymbols = h, s.on("data", (m) => {
            m.dataType === "source" && m.sourceDataType === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && m.dataType === "source" && m.sourceDataType === "content" && (this.reload(), this.transform && this.update(this.transform));
          }), s.on("error", () => {
            this._sourceErrored = !0;
          }), this._source = s, this._tiles = {}, this._cache = new aa(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = s.minTileCacheSize, this._maxTileCacheSize = s.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Go(), this._isRaster = this._source.type === "raster" || this._source.type === "raster-dem" || this._source.type === "raster-array" || this._source.type === "custom" && this._source._dataType === "raster";
        }
        onAdd(t) {
          this.map = t, this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize;
        }
        loaded() {
          if (this._sourceErrored)
            return !0;
          if (!this._sourceLoaded || !this._source.loaded())
            return !1;
          for (const t in this._tiles) {
            const s = this._tiles[t];
            if (s.state !== "loaded" && s.state !== "errored")
              return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused)
            return;
          const t = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, t && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t, s) {
          return t.isSymbolTile = this._onlySymbols, t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key], this._source.loadTile(t, s);
        }
        _unloadTile(t) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t);
        }
        _abortTile(t) {
          if (this._source.abortTile)
            return this._source.abortTile(t);
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const s in this._tiles) {
            const h = this._tiles[s];
            h.upload(t), h.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return i.bj(this._tiles).map((t) => t.tileID).sort(la).map((t) => t.key);
        }
        getRenderableIds(t, s) {
          const h = [];
          for (const m in this._tiles)
            this._isIdRenderable(+m, t, s) && h.push(this._tiles[m]);
          return t ? h.sort((m, g) => {
            const T = m.tileID, z = g.tileID, R = new i.P(T.canonical.x, T.canonical.y)._rotate(this.transform.angle), F = new i.P(z.canonical.x, z.canonical.y)._rotate(this.transform.angle);
            return T.overscaledZ - z.overscaledZ || F.y - R.y || F.x - R.x;
          }).map((m) => m.tileID.key) : h.map((m) => m.tileID).sort(la).map((m) => m.key);
        }
        hasRenderableParent(t) {
          const s = this.findLoadedParent(t, 0);
          return !!s && this._isIdRenderable(s.tileID.key);
        }
        _isIdRenderable(t, s, h) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (s || !this._tiles[t].holdingForFade()) && (h || !this._shadowCasterTiles[t]);
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles)
              this._tiles[t].state !== "errored" && this._reloadTile(+t, "reloading");
          }
        }
        _reloadTile(t, s) {
          const h = this._tiles[t];
          h && (h.state !== "loading" && (h.state = s), this._loadTile(h, this._tileLoaded.bind(this, h, t, s)));
        }
        _tileLoaded(t, s, h, m) {
          if (m)
            if (t.state = "errored", m.status !== 404)
              this._source.fire(new i.y(m, { tile: t }));
            else {
              if (this._source.fire(new i.z("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t })), !(t.tileID.key in this._loadedParentTiles))
                return;
              if (this._source.type === "raster-dem" && this.usedForTerrain && this.map.painter.terrain) {
                const g = this.map.painter.terrain;
                this.update(this.transform, g.getScaledDemTileSize(), !0), g.resetTileLookupCache(this.id);
              } else
                this.update(this.transform);
            }
          else
            t.timeAdded = i.q.now(), h === "expired" && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(s, t), this._source.type === "raster-dem" && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new i.z("data", { dataType: "source", tile: t, coord: t.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t) {
          const s = this.getRenderableIds();
          for (let m = 0; m < s.length; m++) {
            const g = s[m];
            if (t.neighboringTiles && t.neighboringTiles[g]) {
              const T = this.getTileByID(g);
              h(t, T), h(T, t);
            }
          }
          function h(m, g) {
            if (!m.dem || m.dem.borderReady)
              return;
            m.needsHillshadePrepare = !0, m.needsDEMTextureUpload = !0;
            let T = g.tileID.canonical.x - m.tileID.canonical.x;
            const z = g.tileID.canonical.y - m.tileID.canonical.y, R = Math.pow(2, m.tileID.canonical.z), F = g.tileID.key;
            T === 0 && z === 0 || Math.abs(z) > 1 || (Math.abs(T) > 1 && (Math.abs(T + R) === 1 ? T += R : Math.abs(T - R) === 1 && (T -= R)), g.dem && m.dem && (m.dem.backfillBorder(g.dem, T, z), m.neighboringTiles && m.neighboringTiles[F] && (m.neighboringTiles[F].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, s, h, m) {
          for (const g in this._tiles) {
            let T = this._tiles[g];
            if (m[g] || !T.hasData() || T.tileID.overscaledZ <= s || T.tileID.overscaledZ > h)
              continue;
            let z = T.tileID;
            for (; T && T.tileID.overscaledZ > s + 1; ) {
              const F = T.tileID.scaledTo(T.tileID.overscaledZ - 1);
              T = this._tiles[F.key], T && T.hasData() && (z = F);
            }
            let R = z;
            for (; R.overscaledZ > s; )
              if (R = R.scaledTo(R.overscaledZ - 1), t[R.key]) {
                m[z.key] = z;
                break;
              }
          }
        }
        findLoadedParent(t, s) {
          if (t.key in this._loadedParentTiles) {
            const h = this._loadedParentTiles[t.key];
            return h && h.tileID.overscaledZ >= s ? h : null;
          }
          for (let h = t.overscaledZ - 1; h >= s; h--) {
            const m = t.scaledTo(h), g = this._getLoadedTile(m);
            if (g)
              return g;
          }
        }
        _getLoadedTile(t) {
          const s = this._tiles[t.key];
          return s && s.hasData() ? s : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
        }
        updateCacheSize(t, s) {
          s = s || this._source.tileSize;
          const h = Math.ceil(t.width / s) + 1, m = Math.ceil(t.height / s) + 1, g = Math.floor(h * m * 5), T = typeof this._minTileCacheSize == "number" ? Math.max(this._minTileCacheSize, g) : g, z = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, T) : T;
          this._cache.setMaxSize(z);
        }
        handleWrapJump(t) {
          const s = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (this._prevLng = t, s) {
            const h = {};
            for (const m in this._tiles) {
              const g = this._tiles[m];
              g.tileID = g.tileID.unwrapTo(g.tileID.wrap + s), h[g.tileID.key] = g;
            }
            this._tiles = h;
            for (const m in this._timers)
              clearTimeout(this._timers[m]), delete this._timers[m];
            for (const m in this._tiles)
              this._setTileReloadTimer(+m, this._tiles[m]);
          }
        }
        update(t, s, h, m) {
          if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || this.usedForTerrain && !h)
            return;
          this.updateCacheSize(t, s), this.transform.projection.name !== "globe" && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
          const g = this._source.type === "batched-model";
          let T, z = this._source.maxzoom;
          const R = this.map && this.map.painter ? this.map.painter._terrain : null;
          if (R && R.sourceCache === this && R.attenuationRange()) {
            const j = R.attenuationRange()[0], G = Math.floor(j) - Math.log2(R.getDemUpscale());
            z > G && (z = G);
          }
          if (this.used || this.usedForTerrain) {
            if (this._source.tileID)
              T = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((j) => new i.aG(j.canonical.z, j.wrap, j.canonical.z, j.canonical.x, j.canonical.y));
            else if (this.tileCoverLift !== 0) {
              const j = t.clone();
              j.tileCoverLift = this.tileCoverLift, T = j.coveringTiles({ tileSize: s || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: z, roundZoom: this._source.roundZoom && !h, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: g }), this._source.minzoom <= 1 && t.projection.name === "globe" && (T.push(new i.aG(1, 0, 1, 0, 0)), T.push(new i.aG(1, 0, 1, 1, 0)), T.push(new i.aG(1, 0, 1, 0, 1)), T.push(new i.aG(1, 0, 1, 1, 1)));
            } else if (T = t.coveringTiles({ tileSize: s || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: z, roundZoom: this._source.roundZoom && !h, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: g }), this._source.hasTile) {
              const j = this._source.hasTile.bind(this._source);
              T = T.filter((G) => j(G));
            }
          } else
            T = [];
          if (T.length > 0 && this.castsShadows && m && this.transform.projection.name !== "globe" && !this.usedForTerrain && !Da(this._source.type)) {
            const j = t.coveringZoomLevel({ tileSize: s || this._source.tileSize, roundZoom: this._source.roundZoom && !h }), G = Math.min(j, this._source.maxzoom);
            if (g) {
              const W = t.extendTileCover(T, G);
              for (const te of W)
                T.push(te);
            } else {
              const W = t.extendTileCover(T, G, m);
              for (const te of W)
                this._shadowCasterTiles[te.key] = !0, T.push(te);
            }
          }
          const F = this._updateRetainedTiles(T);
          if (Da(this._source.type) && T.length !== 0) {
            const j = {}, G = {}, W = Object.keys(F);
            for (const ee of W) {
              const se = F[ee], oe = this._tiles[ee];
              if (!oe || oe.fadeEndTime && oe.fadeEndTime <= i.q.now())
                continue;
              const ce = this.findLoadedParent(se, Math.max(se.overscaledZ - sr.maxOverzooming, this._source.minzoom));
              ce && (this._addTile(ce.tileID), j[ce.tileID.key] = ce.tileID), G[ee] = se;
            }
            const te = T[T.length - 1].overscaledZ;
            for (const ee in this._tiles) {
              const se = this._tiles[ee];
              if (F[ee] || !se.hasData())
                continue;
              let oe = se.tileID;
              for (; oe.overscaledZ > te; ) {
                oe = oe.scaledTo(oe.overscaledZ - 1);
                const ce = this._tiles[oe.key];
                if (ce && ce.hasData() && G[oe.key]) {
                  F[ee] = se.tileID;
                  break;
                }
              }
            }
            for (const ee in j)
              F[ee] || (this._coveredTiles[ee] = !0, F[ee] = j[ee]);
          }
          for (const j in F)
            this._tiles[j].clearFadeHold();
          const N = i.bk(this._tiles, F);
          for (const j of N) {
            const G = this._tiles[j];
            G.hasSymbolBuckets && !G.holdingForFade() ? G.setHoldDuration(this.map._fadeDuration) : G.hasSymbolBuckets && !G.symbolFadeFinished() || this._removeTile(+j);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles)
            this._tiles[t].holdingForFade() && this._removeTile(+t);
        }
        _updateRetainedTiles(t) {
          const s = {};
          if (t.length === 0)
            return s;
          const h = {}, m = t.reduce((F, N) => Math.min(F, N.overscaledZ), 1 / 0), g = t[0].overscaledZ, T = Math.max(g - sr.maxOverzooming, this._source.minzoom), z = Math.max(g + sr.maxUnderzooming, this._source.minzoom), R = {};
          for (const F of t) {
            const N = this._addTile(F);
            s[F.key] = F, N.hasData() || m < this._source.maxzoom && (R[F.key] = F);
          }
          this._retainLoadedChildren(R, m, z, s);
          for (const F of t) {
            let N = this._tiles[F.key];
            if (N.hasData())
              continue;
            if (F.canonical.z >= this._source.maxzoom) {
              const G = F.children(this._source.maxzoom)[0], W = this.getTile(G);
              if (W && W.hasData()) {
                s[G.key] = G;
                continue;
              }
            } else {
              const G = F.children(this._source.maxzoom);
              if (s[G[0].key] && s[G[1].key] && s[G[2].key] && s[G[3].key])
                continue;
            }
            let j = N.wasRequested();
            for (let G = F.overscaledZ - 1; G >= T; --G) {
              const W = F.scaledTo(G);
              if (h[W.key] || (h[W.key] = !0, N = this.getTile(W), !N && j && (N = this._addTile(W)), N && (s[W.key] = W, j = N.wasRequested(), N.hasData())))
                break;
            }
          }
          return s;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const s = [];
            let h, m = this._tiles[t].tileID;
            for (; m.overscaledZ > 0; ) {
              if (m.key in this._loadedParentTiles) {
                h = this._loadedParentTiles[m.key];
                break;
              }
              s.push(m.key);
              const g = m.scaledTo(m.overscaledZ - 1);
              if (h = this._getLoadedTile(g), h)
                break;
              m = g;
            }
            for (const g of s)
              this._loadedParentTiles[g] = h;
          }
        }
        _addTile(t) {
          let s = this._tiles[t.key];
          if (s)
            return s.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, "reloading"), s;
          s = this._cache.getAndRemove(t), s && (this._setTileReloadTimer(t.key, s), s.tileID = t, this._state.initializeTileState(s, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, s)));
          const h = !!s;
          if (!h) {
            const m = this.map ? this.map.painter : null, g = this._source.tileSize * t.overscaleFactor();
            s = this._source.type === "raster-array" ? new za(t, g, this.transform.tileZoom, m, this._isRaster) : new Cr(t, g, this.transform.tileZoom, m, this._isRaster), this._loadTile(s, this._tileLoaded.bind(this, s, t.key, s.state));
          }
          return s ? (s.uses++, this._tiles[t.key] = s, h || this._source.fire(new i.z("dataloading", { tile: s, coord: s.tileID, dataType: "source" })), s) : null;
        }
        _setTileReloadTimer(t, s) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const h = s.getExpiryTimeout();
          h && (this._timers[t] = setTimeout(() => {
            this._reloadTile(t, "expired"), delete this._timers[t];
          }, h));
        }
        _removeTile(t) {
          const s = this._tiles[t];
          s && (s.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), s.uses > 0 || (s.hasData() && s.state !== "reloading" || s.state === "empty" ? this._cache.add(s.tileID, s, s.getExpiryTimeout()) : (s.aborted = !0, this._abortTile(s), this._unloadTile(s))));
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const t in this._tiles)
            this._removeTile(+t);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t, s, h) {
          const m = [], g = this.transform;
          if (!g)
            return m;
          const T = g.projection.name === "globe", z = i.at(g.center.lng);
          for (const R in this._tiles) {
            const F = this._tiles[R];
            if (h && F.clearQueryDebugViz(), F.holdingForFade())
              continue;
            let N;
            if (T) {
              const j = F.tileID.canonical;
              if (j.z === 0) {
                const G = [Math.abs(i.aw(z, ...ki(j, -1)) - z), Math.abs(i.aw(z, ...ki(j, 1)) - z)];
                N = [0, 2 * G.indexOf(Math.min(...G)) - 1];
              } else {
                const G = [Math.abs(i.aw(z, ...ki(j, -1)) - z), Math.abs(i.aw(z, ...ki(j, 0)) - z), Math.abs(i.aw(z, ...ki(j, 1)) - z)];
                N = [G.indexOf(Math.min(...G)) - 1];
              }
            } else
              N = [0];
            for (const j of N) {
              const G = t.containsTile(F, g, s, j);
              G && m.push(G);
            }
          }
          return m;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(!1, !0);
        }
        getVisibleCoordinates(t) {
          return this._getRenderableCoordinates(t);
        }
        _getRenderableCoordinates(t, s) {
          const h = this.getRenderableIds(t, s).map((g) => this._tiles[g].tileID), m = this.transform.projection.name === "globe";
          for (const g of h)
            g.projMatrix = this.transform.calculateProjMatrix(g.toUnwrapped()), g.expandedProjMatrix = m ? this.transform.calculateProjMatrix(g.toUnwrapped(), !1, !0) : g.projMatrix;
          return h;
        }
        sortCoordinatesByDistance(t) {
          const s = t.slice(), h = this.transform._camera.position, m = this.transform._camera.forward(), g = {};
          for (const T of s) {
            const z = 1 / (1 << T.canonical.z);
            g[T.key] = ((T.canonical.x + 0.5) * z + T.wrap - h[0]) * m[0] + ((T.canonical.y + 0.5) * z - h[1]) * m[1] - h[2] * m[2];
          }
          return s.sort((T, z) => g[T.key] - g[z.key]), s;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return !0;
          if (Da(this._source.type))
            for (const t in this._tiles) {
              const s = this._tiles[t];
              if (s.fadeEndTime !== void 0 && s.fadeEndTime >= i.q.now())
                return !0;
            }
          return !1;
        }
        setFeatureState(t, s, h) {
          this._state.updateState(t = t || "_geojsonTileLayer", s, h);
        }
        removeFeatureState(t, s, h) {
          this._state.removeFeatureState(t = t || "_geojsonTileLayer", s, h);
        }
        getFeatureState(t, s) {
          return this._state.getState(t = t || "_geojsonTileLayer", s);
        }
        setDependencies(t, s, h) {
          const m = this._tiles[t];
          m && m.setDependencies(s, h);
        }
        reloadTilesForDependencies(t, s) {
          for (const h in this._tiles)
            this._tiles[h].hasDependency(t, s) && this._reloadTile(+h, "reloading");
          this._cache.filter((h) => !h.hasDependency(t, s));
        }
        _preloadTiles(t, s) {
          if (!this._sourceLoaded) {
            const R = () => {
              this._sourceLoaded && (this._source.off("data", R), this._preloadTiles(t, s));
            };
            return void this._source.on("data", R);
          }
          const h = /* @__PURE__ */ new Map(), m = Array.isArray(t) ? t : [t], g = this.map.painter.terrain, T = this.usedForTerrain && g ? g.getScaledDemTileSize() : this._source.tileSize;
          for (const R of m) {
            const F = R.coveringTiles({ tileSize: T, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const N of F)
              h.set(N.key, N);
            this.usedForTerrain && R.updateElevation(!1);
          }
          const z = Array.from(h.values());
          i.bl(z, (R, F) => {
            const N = new Cr(R, this._source.tileSize * R.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
            this._loadTile(N, (j) => {
              this._source.type === "raster-dem" && N.dem && this._backfillDEM(N), F(j, N);
            });
          }, s);
        }
      }
      function la(c, t) {
        const s = Math.abs(2 * c.wrap) - +(c.wrap < 0), h = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return c.overscaledZ - t.overscaledZ || h - s || t.canonical.y - c.canonical.y || t.canonical.x - c.canonical.x;
      }
      function Da(c) {
        return c === "raster" || c === "image" || c === "video" || c === "custom";
      }
      function ki(c, t) {
        const s = 1 << c.z;
        return [c.x / s + t, (c.x + 1) / s + t];
      }
      sr.maxOverzooming = 10, sr.maxUnderzooming = 3;
      class Ul {
        constructor(t) {
          this.style = t, this.layersGotHidden = !1, this.layers = [];
        }
        processLayersChanged() {
          this.layers = [];
          const t = !1, s = !1;
          for (const h in this.style._mergedLayers) {
            const m = this.style._mergedLayers[h];
            if (m.type === "fill-extrusion")
              this.layers.push({ layer: m, visible: t, visibilityChanged: s });
            else if (m.type === "model") {
              const g = this.style.getLayerSource(m);
              g && g.type === "batched-model" && this.layers.push({ layer: m, visible: t, visibilityChanged: s });
            }
          }
        }
        onNewFrame(t) {
          this.layersGotHidden = !1;
          for (const s of this.layers) {
            const h = s.layer;
            let m = !1;
            h.type === "fill-extrusion" ? m = !h.isHidden(t) && h.paint.get("fill-extrusion-opacity") > 0 : h.type === "model" && (m = !h.isHidden(t) && h.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !m && s.visible, s.visible = m;
          }
        }
        updateZOffset(t, s) {
          this.currentBuildingBuckets = [];
          for (const m of this.layers) {
            const g = m.layer, T = this.style.getLayerSourceCache(g);
            let z = 1;
            g.type === "fill-extrusion" && (z = m.visible ? g.paint.get("fill-extrusion-vertical-scale") : 0);
            let R = T ? T.getTile(s) : null;
            if (!R && T && s.canonical.z > T.getSource().minzoom) {
              let F = s.scaledTo(Math.min(T.getSource().maxzoom, s.overscaledZ - 1));
              for (; F.overscaledZ >= T.getSource().minzoom && (R = T.getTile(F), !R && F.overscaledZ !== 0); )
                F = F.scaledTo(F.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: R ? R.getBucket(g) : null, tileID: R ? R.tileID : s, verticalScale: z });
          }
          t.hasAnyZOffset = !1;
          let h = !1;
          for (let m = 0; m < t.symbolInstances.length; m++) {
            const g = t.symbolInstances.get(m), T = g.zOffset, z = this._getHeightAtTileOffset(s, g.tileAnchorX, g.tileAnchorY);
            g.zOffset = z !== Number.NEGATIVE_INFINITY ? z : T, h || T === g.zOffset || (h = !0), t.hasAnyZOffset || g.zOffset === 0 || (t.hasAnyZOffset = !0);
          }
          h && (t.zOffsetBuffersNeedUpload = !0, t.zOffsetSortDirty = !0);
        }
        _mapCoordToOverlappingTile(t, s, h, m) {
          let g = s, T = h;
          if (t.canonical.z !== m.canonical.z) {
            const z = m.canonical, R = 1 / (1 << t.canonical.z - z.z);
            g = (s + t.canonical.x * i.ag) * R - z.x * i.ag | 0, T = (h + t.canonical.y * i.ag) * R - z.y * i.ag | 0;
          }
          return { tileX: g, tileY: T };
        }
        _getHeightAtTileOffset(t, s, h) {
          let m, g;
          for (let T = 0; T < this.layers.length; ++T) {
            if (this.layers[T].layer.type !== "fill-extrusion")
              continue;
            const { bucket: z, tileID: R, verticalScale: F } = this.currentBuildingBuckets[T];
            if (!z)
              continue;
            const { tileX: N, tileY: j } = this._mapCoordToOverlappingTile(t, s, h, R), G = z.getHeightAtTileCoord(N, j);
            G && G.height !== void 0 && (G.hidden ? m = G.height : g = Math.max(G.height * F, g || 0));
          }
          if (g !== void 0)
            return g;
          for (let T = 0; T < this.layers.length; ++T) {
            const z = this.layers[T];
            if (z.layer.type !== "model" || !z.visible)
              continue;
            const { bucket: R, tileID: F } = this.currentBuildingBuckets[T];
            if (!R)
              continue;
            const { tileX: N, tileY: j } = this._mapCoordToOverlappingTile(t, s, h, F), G = R.getHeightAtTileCoord(N, j);
            if (G && !G.hidden)
              return G.height === void 0 && m !== void 0 ? Math.min(G.maxHeight, m) * G.verticalScale : G.height ? G.height * G.verticalScale : Number.NEGATIVE_INFINITY;
          }
          return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
        }
      }
      function ei(c, t) {
        const s = {};
        for (const h in c)
          h !== "ref" && (s[h] = c[h]);
        return i.bm.forEach((h) => {
          h in t && (s[h] = t[h]);
        }), s;
      }
      function cl(c) {
        c = c.slice();
        const t = /* @__PURE__ */ Object.create(null);
        for (let s = 0; s < c.length; s++)
          t[c[s].id] = c[s];
        for (let s = 0; s < c.length; s++)
          "ref" in c[s] && (c[s] = ei(c[s], t[c[s].ref]));
        return c;
      }
      const Oi = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport" };
      function Bi(c, t, s) {
        s.push({ command: Oi.addSource, args: [c, t[c]] });
      }
      function ns(c, t, s) {
        t.push({ command: Oi.removeSource, args: [c] }), s[c] = !0;
      }
      function Cn(c, t, s, h) {
        ns(c, s, h), Bi(c, t, s);
      }
      function ca(c, t, s) {
        let h;
        for (h in c[s])
          if (c[s].hasOwnProperty(h) && h !== "data" && !i.bn(c[s][h], t[s][h]))
            return !1;
        for (h in t[s])
          if (t[s].hasOwnProperty(h) && h !== "data" && !i.bn(c[s][h], t[s][h]))
            return !1;
        return !0;
      }
      function Ot(c, t, s, h, m, g) {
        let T;
        for (T in t = t || {}, c = c || {})
          c.hasOwnProperty(T) && (i.bn(c[T], t[T]) || s.push({ command: g, args: [h, T, t[T], m] }));
        for (T in t)
          t.hasOwnProperty(T) && !c.hasOwnProperty(T) && (i.bn(c[T], t[T]) || s.push({ command: g, args: [h, T, t[T], m] }));
      }
      function Fi(c) {
        return c.id;
      }
      function Li(c, t) {
        return c[t.id] = t, c;
      }
      class ms {
        constructor(t, s) {
          this.reset(t, s);
        }
        reset(t, s) {
          this.points = t || [], this._distances = [0];
          for (let h = 1; h < this.points.length; h++)
            this._distances[h] = this._distances[h - 1] + this.points[h].dist(this.points[h - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(s || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t) {
          if (this.points.length === 1)
            return this.points[0];
          t = i.aw(t, 0, 1);
          let s = 1, h = this._distances[s];
          const m = t * this.paddedLength + this.padding;
          for (; h < m && s < this._distances.length; )
            h = this._distances[++s];
          const g = s - 1, T = this._distances[g], z = h - T, R = z > 0 ? (m - T) / z : 0;
          return this.points[g].mult(1 - R).add(this.points[s].mult(R));
        }
      }
      class vo {
        constructor(t, s, h) {
          const m = this.boxCells = [], g = this.circleCells = [];
          this.xCellCount = Math.ceil(t / h), this.yCellCount = Math.ceil(s / h);
          for (let T = 0; T < this.xCellCount * this.yCellCount; T++)
            m.push([]), g.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t, this.height = s, this.xScale = this.xCellCount / t, this.yScale = this.yCellCount / s, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, s, h, m, g) {
          this._forEachCell(s, h, m, g, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(s), this.bboxes.push(h), this.bboxes.push(m), this.bboxes.push(g);
        }
        insertCircle(t, s, h, m) {
          this._forEachCell(s - m, h - m, s + m, h + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(s), this.circles.push(h), this.circles.push(m);
        }
        _insertBoxCell(t, s, h, m, g, T) {
          this.boxCells[g].push(T);
        }
        _insertCircleCell(t, s, h, m, g, T) {
          this.circleCells[g].push(T);
        }
        _query(t, s, h, m, g, T) {
          if (h < 0 || t > this.width || m < 0 || s > this.height)
            return !g && [];
          const z = [];
          if (t <= 0 && s <= 0 && this.width <= h && this.height <= m) {
            if (g)
              return !0;
            for (let R = 0; R < this.boxKeys.length; R++)
              z.push({ key: this.boxKeys[R], x1: this.bboxes[4 * R], y1: this.bboxes[4 * R + 1], x2: this.bboxes[4 * R + 2], y2: this.bboxes[4 * R + 3] });
            for (let R = 0; R < this.circleKeys.length; R++) {
              const F = this.circles[3 * R], N = this.circles[3 * R + 1], j = this.circles[3 * R + 2];
              z.push({ key: this.circleKeys[R], x1: F - j, y1: N - j, x2: F + j, y2: N + j });
            }
            return T ? z.filter(T) : z;
          }
          return this._forEachCell(t, s, h, m, this._queryCell, z, { hitTest: g, seenUids: { box: {}, circle: {} } }, T), g ? z.length > 0 : z;
        }
        _queryCircle(t, s, h, m, g) {
          const T = t - h, z = t + h, R = s - h, F = s + h;
          if (z < 0 || T > this.width || F < 0 || R > this.height)
            return !m && [];
          const N = [];
          return this._forEachCell(T, R, z, F, this._queryCellCircle, N, { hitTest: m, circle: { x: t, y: s, radius: h }, seenUids: { box: {}, circle: {} } }, g), m ? N.length > 0 : N;
        }
        query(t, s, h, m, g) {
          return this._query(t, s, h, m, !1, g);
        }
        hitTest(t, s, h, m, g) {
          return this._query(t, s, h, m, !0, g);
        }
        hitTestCircle(t, s, h, m) {
          return this._queryCircle(t, s, h, !0, m);
        }
        _queryCell(t, s, h, m, g, T, z, R) {
          const F = z.seenUids, N = this.boxCells[g];
          if (N !== null) {
            const G = this.bboxes;
            for (const W of N)
              if (!F.box[W]) {
                F.box[W] = !0;
                const te = 4 * W;
                if (t <= G[te + 2] && s <= G[te + 3] && h >= G[te + 0] && m >= G[te + 1] && (!R || R(this.boxKeys[W]))) {
                  if (z.hitTest)
                    return T.push(!0), !0;
                  T.push({ key: this.boxKeys[W], x1: G[te], y1: G[te + 1], x2: G[te + 2], y2: G[te + 3] });
                }
              }
          }
          const j = this.circleCells[g];
          if (j !== null) {
            const G = this.circles;
            for (const W of j)
              if (!F.circle[W]) {
                F.circle[W] = !0;
                const te = 3 * W;
                if (this._circleAndRectCollide(G[te], G[te + 1], G[te + 2], t, s, h, m) && (!R || R(this.circleKeys[W]))) {
                  if (z.hitTest)
                    return T.push(!0), !0;
                  {
                    const ee = G[te], se = G[te + 1], oe = G[te + 2];
                    T.push({ key: this.circleKeys[W], x1: ee - oe, y1: se - oe, x2: ee + oe, y2: se + oe });
                  }
                }
              }
          }
        }
        _queryCellCircle(t, s, h, m, g, T, z, R) {
          const F = z.circle, N = z.seenUids, j = this.boxCells[g];
          if (j !== null) {
            const W = this.bboxes;
            for (const te of j)
              if (!N.box[te]) {
                N.box[te] = !0;
                const ee = 4 * te;
                if (this._circleAndRectCollide(F.x, F.y, F.radius, W[ee + 0], W[ee + 1], W[ee + 2], W[ee + 3]) && (!R || R(this.boxKeys[te])))
                  return T.push(!0), !0;
              }
          }
          const G = this.circleCells[g];
          if (G !== null) {
            const W = this.circles;
            for (const te of G)
              if (!N.circle[te]) {
                N.circle[te] = !0;
                const ee = 3 * te;
                if (this._circlesCollide(W[ee], W[ee + 1], W[ee + 2], F.x, F.y, F.radius) && (!R || R(this.circleKeys[te])))
                  return T.push(!0), !0;
              }
          }
        }
        _forEachCell(t, s, h, m, g, T, z, R) {
          const F = this._convertToXCellCoord(t), N = this._convertToYCellCoord(s), j = this._convertToXCellCoord(h), G = this._convertToYCellCoord(m);
          for (let W = F; W <= j; W++)
            for (let te = N; te <= G; te++)
              if (g.call(this, t, s, h, m, this.xCellCount * te + W, T, z, R))
                return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, s, h, m, g, T) {
          const z = m - t, R = g - s, F = h + T;
          return F * F > z * z + R * R;
        }
        _circleAndRectCollide(t, s, h, m, g, T, z) {
          const R = (T - m) / 2, F = Math.abs(t - (m + R));
          if (F > R + h)
            return !1;
          const N = (z - g) / 2, j = Math.abs(s - (g + N));
          if (j > N + h)
            return !1;
          if (F <= R || j <= N)
            return !0;
          const G = F - R, W = j - N;
          return G * G + W * W <= h * h;
        }
      }
      const Ai = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, _s = Math.tan(85 * Math.PI / 180);
      function Ks(c, t, s, h, m, g, T) {
        const z = i.ab.mat4.create();
        if (s)
          if (g.name === "globe") {
            const R = i.bo(m, t);
            i.ab.mat4.multiply(z, z, R);
          } else {
            const R = i.ab.mat2.invert([], T);
            z[0] = R[0], z[1] = R[1], z[4] = R[2], z[5] = R[3], h || i.ab.mat4.rotateZ(z, z, m.angle);
          }
        else
          i.ab.mat4.multiply(z, m.labelPlaneMatrix, c);
        return z;
      }
      function Zo(c, t, s, h, m, g, T) {
        const z = Ks(c, t, s, h, m, g, T);
        return g.name === "globe" && s || (z[2] = z[6] = z[10] = z[14] = 0), z;
      }
      function Ms(c, t, s, h, m, g, T) {
        if (s) {
          if (g.name === "globe") {
            const z = Ks(c, t, s, h, m, g, T);
            return i.ab.mat4.invert(z, z), i.ab.mat4.multiply(z, c, z), z;
          }
          {
            const z = i.ab.mat4.clone(c), R = i.ab.mat4.identity([]);
            return R[0] = T[0], R[1] = T[1], R[4] = T[2], R[5] = T[3], i.ab.mat4.multiply(z, z, R), h || i.ab.mat4.rotateZ(z, z, -m.angle), z;
          }
        }
        return m.glCoordMatrix;
      }
      function un(c, t, s, h) {
        const m = [c, t, s, 1];
        s ? i.ab.vec4.transformMat4(m, m, h) : bo(m, m, h);
        const g = m[3];
        return m[0] /= g, m[1] /= g, m[2] /= g, m;
      }
      function Rc(c, t) {
        return Math.min(0.5 + c / t * 0.5, 1.5);
      }
      function ha(c, t) {
        const s = c[0] / c[3], h = c[1] / c[3];
        return s >= -t[0] && s <= t[0] && h >= -t[1] && h <= t[1];
      }
      function jl(c, t, s, h, m, g, T, z, R, F) {
        const N = s.transform, j = h ? c.textSizeData : c.iconSizeData, G = i.bp(j, s.transform.zoom), W = N.projection.name === "globe", te = [256 / s.width * 2 + 1, 256 / s.height * 2 + 1], ee = h ? c.text.dynamicLayoutVertexArray : c.icon.dynamicLayoutVertexArray;
        ee.clear();
        let se = null;
        W && (se = h ? c.text.globeExtVertexArray : c.icon.globeExtVertexArray);
        const oe = c.lineVertexArray, ce = h ? c.text.placedSymbolArray : c.icon.placedSymbolArray, _e = s.transform.width / s.transform.height;
        let pe, Te = !1;
        for (let xe = 0; xe < ce.length; xe++) {
          const be = ce.get(xe), { numGlyphs: ve, writingMode: Pe } = be;
          if (Pe !== i.bq.vertical || Te || pe === i.bq.horizontal || (Te = !0), pe = Pe, (be.hidden || Pe === i.bq.vertical) && !Te) {
            da(ve, ee);
            continue;
          }
          Te = !1;
          const Oe = new i.P(be.tileAnchorX, be.tileAnchorY);
          let { x: Xe, y: Ze, z: ke } = N.projection.projectTilePoint(Oe.x, Oe.y, F.canonical);
          if (R) {
            const [nt, Lt, xt] = R(Oe);
            Xe += nt, Ze += Lt, ke += xt;
          }
          const Ne = [Xe, Ze, ke, 1];
          if (i.ab.vec4.transformMat4(Ne, Ne, t), !ha(Ne, te)) {
            da(ve, ee);
            continue;
          }
          const st = Ne[3], ht = Rc(s.transform.getCameraToCenterDistance(N.projection), st), yt = i.br(j, G, be), je = T ? yt / ht : yt * ht, at = un(Xe, Ze, ke, m);
          if (at[3] <= 0) {
            da(ve, ee);
            continue;
          }
          let Je = {};
          const _t = T ? null : R, ct = hl(be, je, !1, z, t, m, g, c.glyphOffsetArray, oe, ee, se, at, Oe, Je, _e, _t, N.projection, F, T);
          Te = ct.useVertical, _t && ct.needsFlipping && (Je = {}), (ct.notEnoughRoom || Te || ct.needsFlipping && hl(be, je, !0, z, t, m, g, c.glyphOffsetArray, oe, ee, se, at, Oe, Je, _e, _t, N.projection, F, T).notEnoughRoom) && da(ve, ee);
        }
        h ? (c.text.dynamicLayoutVertexBuffer.updateData(ee), se && c.text.globeExtVertexBuffer && c.text.globeExtVertexBuffer.updateData(se)) : (c.icon.dynamicLayoutVertexBuffer.updateData(ee), se && c.icon.globeExtVertexBuffer && c.icon.globeExtVertexBuffer.updateData(se));
      }
      function ua(c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee) {
        const { lineStartIndex: se, glyphStartIndex: oe, segment: ce } = z, _e = oe + z.numGlyphs, pe = se + z.lineLength, Te = t.getoffsetX(oe), xe = t.getoffsetX(_e - 1), be = ss(c * Te, s, h, m, g, T, ce, se, pe, R, F, N, j, G, !0, W, te, ee);
        if (!be)
          return null;
        const ve = ss(c * xe, s, h, m, g, T, ce, se, pe, R, F, N, j, G, !0, W, te, ee);
        return ve ? { first: be, last: ve } : null;
      }
      function nn(c, t, s, h) {
        return c === i.bq.horizontal && Math.abs(h) > Math.abs(s) ? { useVertical: !0 } : c === i.bq.vertical ? h > 0 ? { needsFlipping: !0 } : null : t !== Ai.unknown && function(m, g) {
          return m === 0 || Math.abs(g / m) > _s;
        }(s, h) ? t === Ai.flipRequired ? { needsFlipping: !0 } : null : s < 0 ? { needsFlipping: !0 } : null;
      }
      function hl(c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe, ce) {
        const _e = t / 24, pe = c.lineOffsetX * _e, Te = c.lineOffsetY * _e, { lineStartIndex: xe, glyphStartIndex: be, numGlyphs: ve, segment: Pe, writingMode: Oe, flipState: Xe } = c, Ze = xe + c.lineLength, ke = (Ne) => {
          if (N) {
            const [je, at, Je] = Ne.up, _t = F.length;
            i.bs(N, _t + 0, je, at, Je), i.bs(N, _t + 1, je, at, Je), i.bs(N, _t + 2, je, at, Je), i.bs(N, _t + 3, je, at, Je);
          }
          const [st, ht, yt] = Ne.point;
          i.bt(F, st, ht, yt, Ne.angle);
        };
        if (ve > 1) {
          const Ne = ua(_e, z, pe, Te, s, j, G, c, R, g, W, ee, !1, se, oe, ce);
          if (!Ne)
            return { notEnoughRoom: !0 };
          if (h && !s) {
            let [st, ht, yt] = Ne.first.point, [je, at, Je] = Ne.last.point;
            [st, ht] = un(st, ht, yt, T), [je, at] = un(je, at, Je, T);
            const _t = nn(Oe, Xe, (je - st) * te, at - ht);
            if (c.flipState = _t && _t.needsFlipping ? Ai.flipRequired : Ai.flipNotRequired, _t)
              return _t;
          }
          ke(Ne.first);
          for (let st = be + 1; st < be + ve - 1; st++) {
            const ht = ss(_e * z.getoffsetX(st), pe, Te, s, j, G, Pe, xe, Ze, R, g, W, ee, !1, !1, se, oe, ce);
            if (!ht)
              return F.length -= 4 * (st - be), { notEnoughRoom: !0 };
            ke(ht);
          }
          ke(Ne.last);
        } else {
          if (h && !s) {
            const st = un(G.x, G.y, 0, m), ht = xe + Pe + 1, yt = new i.P(R.getx(ht), R.gety(ht)), je = un(yt.x, yt.y, 0, m), at = je[3] > 0 ? je : rr(G, yt, st, 1, m, void 0, se, oe.canonical), Je = nn(Oe, Xe, (at[0] - st[0]) * te, at[1] - st[1]);
            if (c.flipState = Je && Je.needsFlipping ? Ai.flipRequired : Ai.flipNotRequired, Je)
              return Je;
          }
          const Ne = ss(_e * z.getoffsetX(be), pe, Te, s, j, G, Pe, xe, Ze, R, g, W, ee, !1, !1, se, oe, ce);
          if (!Ne)
            return { notEnoughRoom: !0 };
          ke(Ne);
        }
        return {};
      }
      function Dn(c, t, s, h, m) {
        const { x: g, y: T, z } = h.projectTilePoint(c.x, c.y, t);
        if (!m)
          return un(g, T, z, s);
        const [R, F, N] = m(c);
        return un(g + R, T + F, z + N, s);
      }
      function rr(c, t, s, h, m, g, T, z) {
        const R = Dn(c.sub(t)._unit()._add(c), z, m, T, g);
        return i.ab.vec3.sub(R, s, R), i.ab.vec3.normalize(R, R), i.ab.vec3.scaleAndAdd(R, s, R, h);
      }
      function ss(c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe) {
        const ce = h ? c - t : c + t;
        let _e = ce > 0 ? 1 : -1, pe = 0;
        h && (_e *= -1, pe = Math.PI), _e < 0 && (pe += Math.PI);
        let Te = z + T + (_e > 0 ? 0 : 1) | 0, xe = m, be = m, ve = 0, Pe = 0;
        const Oe = Math.abs(ce), Xe = [], Ze = [];
        let ke = g, Ne = ke;
        const st = () => rr(Ne, ke, be, Oe - ve + 1, N, G, ee, se.canonical);
        for (; ve + Pe <= Oe; ) {
          if (Te += _e, Te < z || Te >= R)
            return null;
          if (be = xe, Ne = ke, Xe.push(be), W && Ze.push(Ne), ke = new i.P(F.getx(Te), F.gety(Te)), xe = j[Te], !xe) {
            const Lt = Dn(ke, se.canonical, N, ee, G);
            xe = Lt[3] > 0 ? j[Te] = Lt : st();
          }
          ve += Pe, Pe = i.ab.vec3.distance(be, xe);
        }
        te && G && (j[Te] && (xe = st(), Pe = i.ab.vec3.distance(be, xe)), j[Te] = xe);
        const ht = (Oe - ve) / Pe, yt = ke.sub(Ne)._mult(ht)._add(Ne), je = i.ab.vec3.sub([], xe, be), at = i.ab.vec3.scaleAndAdd([], be, je, ht);
        let Je = [0, 0, 1], _t = je[0], ct = je[1];
        if (oe && (Je = ee.upVector(se.canonical, yt.x, yt.y), Je[0] !== 0 || Je[1] !== 0 || Je[2] !== 1)) {
          const Lt = [Je[2], 0, -Je[0]], xt = i.ab.vec3.cross([], Je, Lt);
          i.ab.vec3.normalize(Lt, Lt), i.ab.vec3.normalize(xt, xt), _t = i.ab.vec3.dot(je, Lt), ct = i.ab.vec3.dot(je, xt);
        }
        if (s) {
          const Lt = i.ab.vec3.cross([], Je, je);
          i.ab.vec3.normalize(Lt, Lt), i.ab.vec3.scaleAndAdd(at, at, Lt, s * _e);
        }
        const nt = pe + Math.atan2(ct, _t);
        return Xe.push(at), W && Ze.push(yt), { point: at, angle: nt, path: Xe, tilePath: Ze, up: Je };
      }
      function da(c, t) {
        const s = t.length, h = s + 4 * c;
        t.resize(h), t.float32.fill(-1 / 0, 4 * s, 4 * h);
      }
      function bo(c, t, s) {
        const h = t[0], m = t[1];
        return c[0] = s[0] * h + s[4] * m + s[12], c[1] = s[1] * h + s[5] * m + s[13], c[3] = s[3] * h + s[7] * m + s[15], c;
      }
      const vn = 100;
      class Ir {
        constructor(t, s, h = new vo(t.width + 200, t.height + 200, 25), m = new vo(t.width + 200, t.height + 200, 25)) {
          this.transform = t, this.grid = h, this.ignoredGrid = m, this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance, this.screenRightBoundary = t.width + vn, this.screenBottomBoundary = t.height + vn, this.gridRightBoundary = t.width + 200, this.gridBottomBoundary = t.height + 200, this.fogState = s;
        }
        placeCollisionBox(t, s, h, m, g, T, z, R) {
          let F = h.projectedAnchorX, N = h.projectedAnchorY, j = h.projectedAnchorZ;
          const G = h.elevation, W = h.tileID, te = t.getProjection();
          if (G && W) {
            const [xe, be, ve] = te.upVector(W.canonical, h.tileAnchorX, h.tileAnchorY), Pe = te.upVectorScale(W.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            F += xe * G * Pe, N += be * G * Pe, j += ve * G * Pe;
          }
          const ee = this.projectAndGetPerspectiveRatio(z, F, N, j, h.tileID, te.name === "globe" || !!G || this.transform.pitch > 0, te), se = T * ee.perspectiveRatio, oe = (h.x1 * s + m.x - h.padding) * se + ee.point.x, ce = (h.y1 * s + m.y - h.padding) * se + ee.point.y, _e = (h.x2 * s + m.x + h.padding) * se + ee.point.x, pe = (h.y2 * s + m.y + h.padding) * se + ee.point.y, Te = ee.perspectiveRatio <= 0.55 || ee.occluded;
          return !this.isInsideGrid(oe, ce, _e, pe) || !g && this.grid.hitTest(oe, ce, _e, pe, R) || Te ? { box: [], offscreen: !1, occluded: ee.occluded } : { box: [oe, ce, _e, pe], offscreen: this.isOffscreen(oe, ce, _e, pe), occluded: !1 };
        }
        placeCollisionCircles(t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee) {
          const se = [], oe = this.transform.elevation, ce = t.getProjection(), _e = oe ? oe.getAtTileOffsetFunc(ee, this.transform.center.lat, this.transform.worldSize, ce) : null, pe = new i.P(h.tileAnchorX, h.tileAnchorY);
          let { x: Te, y: xe, z: be } = ce.projectTilePoint(pe.x, pe.y, ee.canonical);
          if (_e) {
            const [yt, je, at] = _e(pe);
            Te += yt, xe += je, be += at;
          }
          const ve = ce.name === "globe", Pe = this.projectAndGetPerspectiveRatio(z, Te, xe, be, ee, ve || !!oe || this.transform.pitch > 0, ce), { perspectiveRatio: Oe } = Pe, Xe = (j ? T / Oe : T * Oe) / i.bw, Ze = un(Te, xe, be, R), ke = Pe.signedDistanceFromCamera > 0 ? ua(Xe, g, h.lineOffsetX * Xe, h.lineOffsetY * Xe, !1, Ze, pe, h, m, R, {}, oe && !j ? _e : null, j && !!oe, ce, ee, j) : null;
          let Ne = !1, st = !1, ht = !0;
          if (ke && !Pe.occluded) {
            const yt = 0.5 * W * Oe + te, je = new i.P(-100, -100), at = new i.P(this.screenRightBoundary, this.screenBottomBoundary), Je = new ms(), { first: _t, last: ct } = ke, nt = _t.path.length;
            let Lt = [];
            for (let Bt = nt - 1; Bt >= 1; Bt--)
              Lt.push(_t.path[Bt]);
            for (let Bt = 1; Bt < ct.path.length; Bt++)
              Lt.push(ct.path[Bt]);
            const xt = 2.5 * yt;
            F && (Lt = Lt.map(([Bt, oi, $t], Xt) => (_e && !ve && ($t = _e(Xt < nt - 1 ? _t.tilePath[nt - 1 - Xt] : ct.tilePath[Xt - nt + 2])[2]), un(Bt, oi, $t, F))), Lt.some((Bt) => Bt[3] <= 0) && (Lt = []));
            let zt = [];
            if (Lt.length > 0) {
              let Bt = 1 / 0, oi = -1 / 0, $t = 1 / 0, Xt = -1 / 0;
              for (const ai of Lt)
                Bt = Math.min(Bt, ai[0]), $t = Math.min($t, ai[1]), oi = Math.max(oi, ai[0]), Xt = Math.max(Xt, ai[1]);
              oi >= je.x && Bt <= at.x && Xt >= je.y && $t <= at.y && (zt = [Lt.map((ai) => new i.P(ai[0], ai[1]))], (Bt < je.x || oi > at.x || $t < je.y || Xt > at.y) && (zt = i.bu(zt, je.x, je.y, at.x, at.y)));
            }
            for (const Bt of zt) {
              Je.reset(Bt, 0.25 * yt);
              let oi = 0;
              oi = Je.length <= 0.5 * yt ? 1 : Math.ceil(Je.paddedLength / xt) + 1;
              for (let $t = 0; $t < oi; $t++) {
                const Xt = $t / Math.max(oi - 1, 1), ai = Je.lerp(Xt), zi = ai.x + vn, wi = ai.y + vn;
                se.push(zi, wi, yt, 0);
                const mn = zi - yt, Sn = wi - yt, Xi = zi + yt, sn = wi + yt;
                if (ht = ht && this.isOffscreen(mn, Sn, Xi, sn), st = st || this.isInsideGrid(mn, Sn, Xi, sn), !s && this.grid.hitTestCircle(zi, wi, yt, G) && (Ne = !0, !N))
                  return { circles: [], offscreen: !1, collisionDetected: Ne, occluded: !1 };
              }
            }
          }
          return { circles: !N && Ne || !st ? [] : se, offscreen: ht, collisionDetected: Ne, occluded: Pe.occluded };
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const s = [];
          let h = 1 / 0, m = 1 / 0, g = -1 / 0, T = -1 / 0;
          for (const N of t) {
            const j = new i.P(N.x + vn, N.y + vn);
            h = Math.min(h, j.x), m = Math.min(m, j.y), g = Math.max(g, j.x), T = Math.max(T, j.y), s.push(j);
          }
          const z = this.grid.query(h, m, g, T).concat(this.ignoredGrid.query(h, m, g, T)), R = {}, F = {};
          for (const N of z) {
            const j = N.key;
            if (R[j.bucketInstanceId] === void 0 && (R[j.bucketInstanceId] = {}), R[j.bucketInstanceId][j.featureIndex])
              continue;
            const G = [new i.P(N.x1, N.y1), new i.P(N.x2, N.y1), new i.P(N.x2, N.y2), new i.P(N.x1, N.y2)];
            i.bv(s, G) && (R[j.bucketInstanceId][j.featureIndex] = !0, F[j.bucketInstanceId] === void 0 && (F[j.bucketInstanceId] = []), F[j.bucketInstanceId].push(j.featureIndex));
          }
          return F;
        }
        insertCollisionBox(t, s, h, m, g) {
          (s ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: h, featureIndex: m, collisionGroupID: g }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, s, h, m, g) {
          const T = s ? this.ignoredGrid : this.grid, z = { bucketInstanceId: h, featureIndex: m, collisionGroupID: g };
          for (let R = 0; R < t.length; R += 4)
            T.insertCircle(z, t[R], t[R + 1], t[R + 2]);
        }
        projectAndGetPerspectiveRatio(t, s, h, m, g, T, z) {
          const R = [s, h, m, 1];
          let F = !1;
          m || this.transform.pitch > 0 ? (i.ab.vec4.transformMat4(R, R, t), this.fogState && g && z.name !== "globe" && (F = function(G, W, te, ee, se, oe) {
            const ce = oe.calculateFogTileMatrix(se), _e = [W, te, ee];
            return i.ab.vec3.transformMat4(_e, _e, ce), Kt(G, i.ab.vec3.length(_e), oe.pitch, oe._fov);
          }(this.fogState, s, h, m, g.toUnwrapped(), this.transform) > 0.9)) : bo(R, R, t);
          const N = R[3];
          return { point: new i.P((R[0] / N + 1) / 2 * this.transform.width + vn, (-R[1] / N + 1) / 2 * this.transform.height + vn), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(z) / N * 0.5, 1.5), signedDistanceFromCamera: N, occluded: T && R[2] > N || F };
        }
        isOffscreen(t, s, h, m) {
          return h < vn || t >= this.screenRightBoundary || m < vn || s > this.screenBottomBoundary;
        }
        isInsideGrid(t, s, h, m) {
          return h >= 0 && t < this.gridRightBoundary && m >= 0 && s < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = i.ab.mat4.identity([]);
          return i.ab.mat4.translate(t, t, [-100, -100, 0]), t;
        }
      }
      function Lr(c, t, s) {
        const h = t.createTileMatrix(c, c.worldSize, s.toUnwrapped());
        return i.ab.mat4.multiply(new Float32Array(16), c.projMatrix, h);
      }
      function qn(c, t, s) {
        if (t.projection.name === s.projection.name)
          return c.projMatrix;
        const h = s.clone();
        return h.setProjection(t.projection), Lr(h, t.getProjection(), c);
      }
      function fa(c, t, s) {
        return t.name === s.projection.name ? c.projMatrix : Lr(s, t, c);
      }
      class zr {
        constructor(t, s, h, m) {
          this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s))) : m && h ? 1 : 0, this.placed = h;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class Es {
        constructor(t, s, h, m, g, T = !1) {
          this.text = new zr(t ? t.text : null, s, h, g), this.icon = new zr(t ? t.icon : null, s, m, g), this.clipped = T;
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class ka {
        constructor(t, s, h, m = !1) {
          this.text = t, this.icon = s, this.skipFade = h, this.clipped = m;
        }
      }
      class Ho {
        constructor() {
          this.invProjMatrix = i.ab.mat4.create(), this.viewportMatrix = i.ab.mat4.create(), this.circles = [];
        }
      }
      class qo {
        constructor(t, s, h, m, g) {
          this.bucketInstanceId = t, this.featureIndex = s, this.sourceLayerIndex = h, this.bucketIndex = m, this.tileID = g;
        }
      }
      class so {
        constructor(t) {
          this.crossSourceCollisions = t, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const s = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: s, predicate: (h) => h.collisionGroupID === s };
          }
          return this.collisionGroups[t];
        }
      }
      function Oc(c, t, s, h, m) {
        const { horizontalAlign: g, verticalAlign: T } = i.bD(c), z = -(g - 0.5) * t, R = -(T - 0.5) * s, F = i.bC(c, h);
        return new i.P(z + F[0] * m, R + F[1] * m);
      }
      function Ra(c, t, s, h, m) {
        const g = new i.P(c, t);
        return s && g._rotate(h ? m : -m), g;
      }
      class or {
        constructor(t, s, h, m, g, T) {
          this.transform = t.clone(), this.projection = t.projection.name, this.collisionIndex = new Ir(this.transform, g), this.buildingIndex = T, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = s, this.retainedQueryData = {}, this.collisionGroups = new so(h), this.collisionCircleArrays = {}, this.prevPlacement = m, m && (m.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t, s, h, m, g = 1) {
          const T = h.getBucket(s), z = h.latestFeatureIndex;
          if (!T || !z || s.fqid !== T.layerIds[0])
            return;
          const R = T.layers[0].layout, F = T.layers[0].paint, N = h.collisionBoxArray, j = Math.pow(2, this.transform.zoom - h.tileID.overscaledZ), G = h.tileSize / i.ag, W = h.tileID.toUnwrapped();
          this.transform.setProjection(T.projection);
          const te = (ee = h.tileID, se = T.getProjection(), oe = this.transform, se.name === this.projection ? oe.calculateProjMatrix(ee.toUnwrapped()) : Lr(oe, se, ee));
          var ee, se, oe;
          const ce = R.get("text-pitch-alignment") === "map", _e = R.get("text-rotation-alignment") === "map";
          s.compileFilter(s.options);
          const pe = s.dynamicFilter(), Te = s.dynamicFilterNeedsFeature(), xe = this.transform.calculatePixelsToTileUnitsMatrix(h), be = Zo(te, h.tileID.canonical, ce, _e, this.transform, T.getProjection(), xe);
          let ve = null;
          if (ce) {
            const yt = Ms(te, h.tileID.canonical, ce, _e, this.transform, T.getProjection(), xe);
            ve = i.ab.mat4.multiply([], this.transform.labelPlaneMatrix, yt);
          }
          let Pe = null;
          pe && h.latestFeatureIndex && (Pe = { unwrappedTileID: W, dynamicFilter: pe, dynamicFilterNeedsFeature: Te }), this.retainedQueryData[T.bucketInstanceId] = new qo(T.bucketInstanceId, z, T.sourceLayerIndex, T.index, h.tileID);
          const [Oe, Xe] = T.layers[0].layout.get("text-size-scale-range"), Ze = i.aw(g, Oe, Xe), [ke, Ne] = R.get("icon-size-scale-range"), st = i.aw(g, ke, Ne), ht = { bucket: T, layout: R, paint: F, posMatrix: te, textLabelPlaneMatrix: be, labelToScreenMatrix: ve, clippingData: Pe, scale: j, textPixelRatio: G, holdingForFade: h.holdingForFade(), collisionBoxArray: N, partiallyEvaluatedTextSize: i.bp(T.textSizeData, this.transform.zoom, Ze), partiallyEvaluatedIconSize: i.bp(T.iconSizeData, this.transform.zoom, st), collisionGroup: this.collisionGroups.get(T.sourceID), latestFeatureIndex: h.latestFeatureIndex };
          if (m)
            for (const yt of T.sortKeyRanges) {
              const { sortKey: je, symbolInstanceStart: at, symbolInstanceEnd: Je } = yt;
              t.push({ sortKey: je, symbolInstanceStart: at, symbolInstanceEnd: Je, parameters: ht });
            }
          else
            t.push({ symbolInstanceStart: 0, symbolInstanceEnd: T.symbolInstances.length, parameters: ht });
        }
        attemptAnchorPlacement(t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe, ce) {
          const { textOffset0: _e, textOffset1: pe, crossTileID: Te } = G, xe = [_e, pe], be = Oc(t, h, m, xe, g), ve = this.collisionIndex.placeCollisionBox(te, g, s, Ra(be.x, be.y, T, z, this.transform.angle), j, R, F, N.predicate);
          if (se) {
            const Pe = te.getSymbolInstanceIconSize(ce, this.transform.zoom, G.placedIconSymbolIndex);
            if (this.collisionIndex.placeCollisionBox(te, Pe, se, Ra(be.x, be.y, T, z, this.transform.angle), j, R, F, N.predicate).box.length === 0)
              return;
          }
          if (ve.box.length > 0) {
            let Pe;
            return this.prevPlacement && this.prevPlacement.variableOffsets[Te] && this.prevPlacement.placements[Te] && this.prevPlacement.placements[Te].text && (Pe = this.prevPlacement.variableOffsets[Te].anchor), this.variableOffsets[Te] = { textOffset: xe, width: h, height: m, anchor: t, textScale: g, prevAnchor: Pe }, this.markUsedJustification(te, t, G, ee), te.allowVerticalPlacement && (this.markUsedOrientation(te, ee, G), this.placedOrientations[Te] = ee), { shift: be, placedGlyphBoxes: ve };
          }
        }
        placeLayerBucketPart(t, s, h, m, g = 1) {
          const { bucket: T, layout: z, paint: R, posMatrix: F, textLabelPlaneMatrix: N, labelToScreenMatrix: j, clippingData: G, textPixelRatio: W, holdingForFade: te, collisionBoxArray: ee, partiallyEvaluatedTextSize: se, partiallyEvaluatedIconSize: oe, collisionGroup: ce, latestFeatureIndex: _e } = t.parameters, pe = z.get("text-optional"), Te = z.get("icon-optional"), xe = z.get("text-allow-overlap"), be = z.get("icon-allow-overlap"), ve = z.get("text-rotation-alignment") === "map", Pe = z.get("text-pitch-alignment") === "map", Oe = z.get("symbol-z-elevate"), Xe = R.get("symbol-z-offset"), Ze = z.get("symbol-elevation-reference") === "sea", [ke, Ne] = z.get("text-size-scale-range"), [st, ht] = z.get("icon-size-scale-range"), yt = i.aw(g, ke, Ne), je = i.aw(g, st, ht);
          this.transform.setProjection(T.projection);
          let at = xe && (be || !T.hasIconData() || Te), Je = be && (xe || !T.hasTextData() || pe);
          const _t = !Xe.isConstant();
          !T.collisionArrays && ee && T.deserializeCollisionBoxes(ee), h && m && T.updateCollisionDebugBuffers(this.transform.zoom, ee, yt, je);
          const ct = (nt, Lt, xt) => {
            const { crossTileID: zt, numVerticalGlyphVertices: Bt } = nt;
            let oi = null;
            if (G && G.dynamicFilterNeedsFeature || _t) {
              const dn = this.retainedQueryData[T.bucketInstanceId];
              oi = _e.loadFeature({ featureIndex: nt.featureIndex, bucketIndex: dn.bucketIndex, sourceLayerIndex: dn.sourceLayerIndex, layoutVertexArrayOffset: 0 });
            }
            if (G && !(0, G.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, oi, this.retainedQueryData[T.bucketInstanceId].tileID.canonical, new i.P(nt.tileAnchorX, nt.tileAnchorY), this.transform.calculateDistanceTileData(G.unwrappedTileID)))
              return this.placements[zt] = new ka(!1, !1, !1, !0), void s.add(zt);
            const $t = Xe.evaluate(oi, {});
            if (s.has(zt))
              return;
            if (te)
              return void (this.placements[zt] = new ka(!1, !1, !1));
            let Xt = !1, ai = !1, zi = !0, wi = !1, mn = !1, Sn = null, Xi = { box: null, offscreen: null, occluded: null }, sn = { box: null, offscreen: null, occluded: null }, _i = null, Jt = null, ji = null, Yi = 0, In = 0, Fs = 0;
            xt.textFeatureIndex ? Yi = xt.textFeatureIndex : nt.useRuntimeCollisionCircles && (Yi = nt.featureIndex), xt.verticalTextFeatureIndex && (In = xt.verticalTextFeatureIndex);
            const pr = (dn) => {
              dn.tileID = this.retainedQueryData[T.bucketInstanceId].tileID;
              const _n = this.transform.elevation;
              dn.elevation = Ze ? $t : $t + (_n ? _n.getAtTileOffset(dn.tileID, dn.tileAnchorX, dn.tileAnchorY) : 0), dn.elevation += nt.zOffset;
            }, ts = xt.textBox;
            if (ts) {
              pr(ts);
              const dn = (Ri) => {
                let Gn = i.bq.horizontal;
                if (T.allowVerticalPlacement && !Ri && this.prevPlacement) {
                  const Bs = this.prevPlacement.placedOrientations[zt];
                  Bs && (this.placedOrientations[zt] = Bs, Gn = Bs, this.markUsedOrientation(T, Gn, nt));
                }
                return Gn;
              }, _n = (Ri, Gn) => {
                if (T.allowVerticalPlacement && Bt > 0 && xt.verticalTextBox) {
                  for (const Bs of T.writingModes)
                    if (Bs === i.bq.vertical ? (Xi = Gn(), sn = Xi) : Xi = Ri(), Xi && Xi.box && Xi.box.length)
                      break;
                } else
                  Xi = Ri();
              };
              if (z.get("text-variable-anchor")) {
                let Ri = z.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[zt]) {
                  const cn = this.prevPlacement.variableOffsets[zt];
                  Ri.indexOf(cn.anchor) > 0 && (Ri = Ri.filter((Qs) => Qs !== cn.anchor), Ri.unshift(cn.anchor));
                }
                const Gn = (cn, Qs, eo) => {
                  const Br = T.getSymbolInstanceTextSize(se, nt, this.transform.zoom, Lt), Ta = (cn.x2 - cn.x1) * Br + 2 * cn.padding, mr = (cn.y2 - cn.y1) * Br + 2 * cn.padding, Do = nt.hasIconTextFit && !be ? Qs : null;
                  Do && pr(Do);
                  let Nr = { box: [], offscreen: !1, occluded: !1 };
                  const el = xe ? 2 * Ri.length : Ri.length;
                  for (let ta = 0; ta < el; ++ta) {
                    const Cl = this.attemptAnchorPlacement(Ri[ta % Ri.length], cn, Ta, mr, Br, ve, Pe, W, F, ce, ta >= Ri.length, nt, Lt, T, eo, Do, se, oe);
                    if (Cl && (Nr = Cl.placedGlyphBoxes, Nr && Nr.box && Nr.box.length)) {
                      Xt = !0, Sn = Cl.shift;
                      break;
                    }
                  }
                  return Nr;
                };
                _n(() => Gn(ts, xt.iconBox, i.bq.horizontal), () => {
                  const cn = xt.verticalTextBox;
                  return cn && pr(cn), T.allowVerticalPlacement && !(Xi && Xi.box && Xi.box.length) && Bt > 0 && cn ? Gn(cn, xt.verticalIconBox, i.bq.vertical) : { box: null, offscreen: null, occluded: null };
                }), Xi && (Xt = Xi.box, zi = Xi.offscreen, wi = Xi.occluded);
                const Bs = dn(!(!Xi || !Xi.box));
                if (!Xt && this.prevPlacement) {
                  const cn = this.prevPlacement.variableOffsets[zt];
                  cn && (this.variableOffsets[zt] = cn, this.markUsedJustification(T, cn.anchor, nt, Bs));
                }
              } else {
                const Ri = (Gn, Bs) => {
                  const cn = T.getSymbolInstanceTextSize(se, nt, this.transform.zoom, Lt, g), Qs = this.collisionIndex.placeCollisionBox(T, cn, Gn, new i.P(0, 0), xe, W, F, ce.predicate);
                  return Qs && Qs.box && Qs.box.length && (this.markUsedOrientation(T, Bs, nt), this.placedOrientations[zt] = Bs), Qs;
                };
                _n(() => Ri(ts, i.bq.horizontal), () => {
                  const Gn = xt.verticalTextBox;
                  return T.allowVerticalPlacement && Bt > 0 && Gn ? (pr(Gn), Ri(Gn, i.bq.vertical)) : { box: null, offscreen: null, occluded: null };
                }), dn(!!(Xi && Xi.box && Xi.box.length));
              }
            }
            if (_i = Xi, Xt = _i && _i.box && _i.box.length > 0, zi = _i && _i.offscreen, wi = _i && _i.occluded, nt.useRuntimeCollisionCircles) {
              const dn = T.text.placedSymbolArray.get(nt.centerJustifiedTextSymbolIndex >= 0 ? nt.centerJustifiedTextSymbolIndex : nt.verticalPlacedTextSymbolIndex), _n = i.br(T.textSizeData, se, dn), Ri = z.get("text-padding");
              Jt = this.collisionIndex.placeCollisionCircles(T, xe, dn, T.lineVertexArray, T.glyphOffsetArray, _n, F, N, j, h, Pe, ce.predicate, nt.collisionCircleDiameter * _n / i.bw, Ri, this.retainedQueryData[T.bucketInstanceId].tileID), Xt = xe || Jt.circles.length > 0 && !Jt.collisionDetected, zi = zi && Jt.offscreen, wi = Jt.occluded;
            }
            if (xt.iconFeatureIndex && (Fs = xt.iconFeatureIndex), xt.iconBox) {
              const dn = (_n) => {
                pr(_n);
                const Ri = nt.hasIconTextFit && Sn ? Ra(Sn.x, Sn.y, ve, Pe, this.transform.angle) : new i.P(0, 0), Gn = T.getSymbolInstanceIconSize(oe, this.transform.zoom, nt.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(T, Gn, _n, Ri, be, W, F, ce.predicate);
              };
              sn && sn.box && sn.box.length && xt.verticalIconBox ? (ji = dn(xt.verticalIconBox), ai = ji.box.length > 0) : (ji = dn(xt.iconBox), ai = ji.box.length > 0), zi = zi && ji.offscreen, mn = ji.occluded;
            }
            const As = pe || nt.numHorizontalGlyphVertices === 0 && Bt === 0, Js = Te || nt.numIconVertices === 0;
            if (As || Js ? Js ? As || (ai = ai && Xt) : Xt = ai && Xt : ai = Xt = ai && Xt, Xt && _i && _i.box && this.collisionIndex.insertCollisionBox(_i.box, z.get("text-ignore-placement"), T.bucketInstanceId, sn && sn.box && In ? In : Yi, ce.ID), ai && ji && this.collisionIndex.insertCollisionBox(ji.box, z.get("icon-ignore-placement"), T.bucketInstanceId, Fs, ce.ID), Jt && (Xt && this.collisionIndex.insertCollisionCircles(Jt.circles, z.get("text-ignore-placement"), T.bucketInstanceId, Yi, ce.ID), h)) {
              const dn = T.bucketInstanceId;
              let _n = this.collisionCircleArrays[dn];
              _n === void 0 && (_n = this.collisionCircleArrays[dn] = new Ho());
              for (let Ri = 0; Ri < Jt.circles.length; Ri += 4)
                _n.circles.push(Jt.circles[Ri + 0]), _n.circles.push(Jt.circles[Ri + 1]), _n.circles.push(Jt.circles[Ri + 2]), _n.circles.push(Jt.collisionDetected ? 1 : 0);
            }
            const jn = T.projection.name !== "globe";
            at = at && (jn || !wi), Je = Je && (jn || !mn), this.placements[zt] = new ka(Xt || at, ai || Je, zi || T.justReloaded), s.add(zt);
          };
          if (Oe && this.buildingIndex && (this.buildingIndex.updateZOffset(T, this.retainedQueryData[T.bucketInstanceId].tileID), T.updateZOffset()), T.sortFeaturesByY) {
            const nt = T.getSortedSymbolIndexes(this.transform.angle);
            for (let Lt = nt.length - 1; Lt >= 0; --Lt) {
              const xt = nt[Lt];
              ct(T.symbolInstances.get(xt), xt, T.collisionArrays[xt]);
            }
            T.hasAnyZOffset && i.w(`${T.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (T.hasAnyZOffset) {
            const nt = T.getSortedIndexesByZOffset();
            for (let Lt = 0; Lt < nt.length; ++Lt) {
              const xt = nt[Lt];
              ct(T.symbolInstances.get(xt), xt, T.collisionArrays[xt]);
            }
          } else
            for (let nt = t.symbolInstanceStart; nt < t.symbolInstanceEnd; nt++)
              ct(T.symbolInstances.get(nt), nt, T.collisionArrays[nt]);
          if (h && T.bucketInstanceId in this.collisionCircleArrays) {
            const nt = this.collisionCircleArrays[T.bucketInstanceId];
            i.ab.mat4.invert(nt.invProjMatrix, F), nt.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          T.justReloaded = !1;
        }
        markUsedJustification(t, s, h, m) {
          const { leftJustifiedTextSymbolIndex: g, centerJustifiedTextSymbolIndex: T, rightJustifiedTextSymbolIndex: z, verticalPlacedTextSymbolIndex: R, crossTileID: F } = h, N = i.bB(s), j = m === i.bq.vertical ? R : N === "left" ? g : N === "center" ? T : N === "right" ? z : -1;
          g >= 0 && (t.text.placedSymbolArray.get(g).crossTileID = j >= 0 && g !== j ? 0 : F), T >= 0 && (t.text.placedSymbolArray.get(T).crossTileID = j >= 0 && T !== j ? 0 : F), z >= 0 && (t.text.placedSymbolArray.get(z).crossTileID = j >= 0 && z !== j ? 0 : F), R >= 0 && (t.text.placedSymbolArray.get(R).crossTileID = j >= 0 && R !== j ? 0 : F);
        }
        markUsedOrientation(t, s, h) {
          const m = s === i.bq.horizontal || s === i.bq.horizontalOnly ? s : 0, g = s === i.bq.vertical ? s : 0, { leftJustifiedTextSymbolIndex: T, centerJustifiedTextSymbolIndex: z, rightJustifiedTextSymbolIndex: R, verticalPlacedTextSymbolIndex: F } = h, N = t.text.placedSymbolArray;
          T >= 0 && (N.get(T).placedOrientation = m), z >= 0 && (N.get(z).placedOrientation = m), R >= 0 && (N.get(R).placedOrientation = m), F >= 0 && (N.get(F).placedOrientation = g);
        }
        commit(t) {
          this.commitTime = t, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const s = this.prevPlacement;
          let h = !1;
          this.prevZoomAdjustment = s ? s.zoomAdjustment(this.transform.zoom) : 0;
          const m = s ? s.symbolFadeChange(t) : 1, g = s ? s.opacities : {}, T = s ? s.variableOffsets : {}, z = s ? s.placedOrientations : {};
          for (const R in this.placements) {
            const F = this.placements[R], N = g[R];
            N ? (this.opacities[R] = new Es(N, m, F.text, F.icon, null, F.clipped), h = h || F.text !== N.text.placed || F.icon !== N.icon.placed) : (this.opacities[R] = new Es(null, m, F.text, F.icon, F.skipFade, F.clipped), h = h || F.text || F.icon);
          }
          for (const R in g) {
            const F = g[R];
            if (!this.opacities[R]) {
              const N = new Es(F, m, !1, !1);
              N.isHidden() || (this.opacities[R] = N, h = h || F.text.placed || F.icon.placed);
            }
          }
          for (const R in T)
            this.variableOffsets[R] || !this.opacities[R] || this.opacities[R].isHidden() || (this.variableOffsets[R] = T[R]);
          for (const R in z)
            this.placedOrientations[R] || !this.opacities[R] || this.opacities[R].isHidden() || (this.placedOrientations[R] = z[R]);
          h ? this.lastPlacementChangeTime = t : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = s ? s.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, s, h, m) {
          const g = /* @__PURE__ */ new Set();
          for (const T of s) {
            const z = T.getBucket(t);
            z && T.latestFeatureIndex && t.fqid === z.layerIds[0] && (this.updateBucketOpacities(z, g, T, T.collisionBoxArray, h, m, T.tileID, t.scope), z.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(z, T.tileID), z.updateZOffset()));
          }
        }
        updateBucketOpacities(t, s, h, m, g, T, z, R) {
          t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const F = t.layers[0].layout, N = t.layers[0].paint, j = !!t.layers[0].dynamicFilter(), G = new Es(null, 0, !1, !1, !0), W = F.get("text-allow-overlap"), te = F.get("icon-allow-overlap"), ee = F.get("text-variable-anchor"), se = F.get("text-rotation-alignment") === "map", oe = F.get("text-pitch-alignment") === "map", ce = N.get("symbol-z-offset"), _e = F.get("symbol-elevation-reference") === "sea", pe = !ce.isConstant(), Te = new Es(null, 0, W && (te || !t.hasIconData() || F.get("icon-optional")), te && (W || !t.hasTextData() || F.get("text-optional")), !0);
          !t.collisionArrays && m && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(m);
          const xe = (ve, Pe, Oe) => {
            for (let Xe = 0; Xe < Pe / 4; Xe++)
              ve.opacityVertexArray.emplaceBack(Oe);
          };
          let be = 0;
          T && t.updateReplacement(z, T);
          for (let ve = 0; ve < t.symbolInstances.length; ve++) {
            const Pe = t.symbolInstances.get(ve), { numHorizontalGlyphVertices: Oe, numVerticalGlyphVertices: Xe, crossTileID: Ze, numIconVertices: ke, tileAnchorX: Ne, tileAnchorY: st } = Pe;
            let ht = null;
            const yt = this.retainedQueryData[t.bucketInstanceId];
            pe && Pe && yt && (ht = h.latestFeatureIndex.loadFeature({ featureIndex: Pe.featureIndex, bucketIndex: yt.bucketIndex, sourceLayerIndex: yt.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
            const je = ce.evaluate(ht, {}), at = s.has(Ze);
            let Je = this.opacities[Ze];
            at ? Je = G : Je || (Je = Te, this.opacities[Ze] = Je), s.add(Ze);
            const _t = Oe > 0 || Xe > 0, ct = ke > 0, nt = this.placedOrientations[Ze], Lt = nt === i.bq.vertical, xt = nt === i.bq.horizontal || nt === i.bq.horizontalOnly;
            !_t && !ct || Je.isHidden() || be++;
            let zt = !1;
            if ((_t || ct) && T)
              for (const Bt of t.activeReplacements) {
                if (i.bx(Bt, g, i.by.Symbol, R) || Bt.min.x > Ne || Ne > Bt.max.x || Bt.min.y > st || st > Bt.max.y)
                  continue;
                const oi = i.bz(Ne, st, z.canonical, Bt.footprintTileId.canonical);
                if (zt = i.bA(oi, Bt.footprint), zt)
                  break;
              }
            if (_t) {
              const Bt = zt ? Ds : pl(Je.text);
              xe(t.text, Oe, Lt ? Ds : Bt), xe(t.text, Xe, xt ? Ds : Bt);
              const oi = Je.text.isHidden(), { leftJustifiedTextSymbolIndex: $t, centerJustifiedTextSymbolIndex: Xt, rightJustifiedTextSymbolIndex: ai, verticalPlacedTextSymbolIndex: zi } = Pe, wi = t.text.placedSymbolArray, mn = oi || Lt ? 1 : 0;
              $t >= 0 && (wi.get($t).hidden = mn), Xt >= 0 && (wi.get(Xt).hidden = mn), ai >= 0 && (wi.get(ai).hidden = mn), zi >= 0 && (wi.get(zi).hidden = oi || xt ? 1 : 0);
              const Sn = this.variableOffsets[Ze];
              Sn && this.markUsedJustification(t, Sn.anchor, Pe, nt);
              const Xi = this.placedOrientations[Ze];
              Xi && (this.markUsedJustification(t, "left", Pe, Xi), this.markUsedOrientation(t, Xi, Pe));
            }
            if (ct) {
              const Bt = zt ? Ds : pl(Je.icon), { placedIconSymbolIndex: oi, verticalPlacedIconSymbolIndex: $t } = Pe, Xt = t.icon.placedSymbolArray, ai = Je.icon.isHidden() ? 1 : 0;
              oi >= 0 && (xe(t.icon, ke, Lt ? Ds : Bt), Xt.get(oi).hidden = ai), $t >= 0 && (xe(t.icon, Pe.numVerticalIconVertices, xt ? Ds : Bt), Xt.get($t).hidden = ai);
            }
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const Bt = t.collisionArrays[ve];
              if (Bt) {
                let oi = new i.P(0, 0), $t = !0;
                if (Bt.textBox || Bt.verticalTextBox) {
                  if (ee) {
                    const ai = this.variableOffsets[Ze];
                    ai ? (oi = Oc(ai.anchor, ai.width, ai.height, ai.textOffset, ai.textScale), se && oi._rotate(oe ? this.transform.angle : -this.transform.angle)) : $t = !1;
                  }
                  j && ($t = !Je.clipped), Bt.textBox && ul(t.textCollisionBox.collisionVertexArray, Je.text.placed, !$t || Lt, je, _e, oi.x, oi.y), Bt.verticalTextBox && ul(t.textCollisionBox.collisionVertexArray, Je.text.placed, !$t || xt, je, _e, oi.x, oi.y);
                }
                const Xt = $t && !!(!xt && Bt.verticalIconBox);
                Bt.iconBox && ul(t.iconCollisionBox.collisionVertexArray, Je.icon.placed, Xt, je, _e, Pe.hasIconTextFit ? oi.x : 0, Pe.hasIconTextFit ? oi.y : 0), Bt.verticalIconBox && ul(t.iconCollisionBox.collisionVertexArray, Je.icon.placed, !Xt, je, _e, Pe.hasIconTextFit ? oi.x : 0, Pe.hasIconTextFit ? oi.y : 0);
              }
            }
          }
          if (t.fullyClipped = be === 0, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {
            const ve = this.collisionCircleArrays[t.bucketInstanceId];
            t.placementInvProjMatrix = ve.invProjMatrix, t.placementViewportMatrix = ve.viewportMatrix, t.collisionCircleArray = ve.circles, delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, s) {
          const h = this.zoomAtLastRecencyCheck === s ? 1 - this.zoomAdjustment(s) : 1;
          return this.zoomAtLastRecencyCheck = s, this.commitTime + this.fadeDuration * h > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function ul(c, t, s, h, m, g, T) {
        c.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, T || 0, h, m ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, T || 0, h, m ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, T || 0, h, m ? 1 : 0), c.emplaceBack(t ? 1 : 0, s ? 1 : 0, g || 0, T || 0, h, m ? 1 : 0);
      }
      const dl = Math.pow(2, 25), Fh = Math.pow(2, 24), fl = Math.pow(2, 17), Fc = Math.pow(2, 16), Yu = Math.pow(2, 9), Oa = Math.pow(2, 8), Fa = Math.pow(2, 1);
      function pl(c) {
        if (c.opacity === 0 && !c.placed)
          return 0;
        if (c.opacity === 1 && c.placed)
          return 4294967295;
        const t = c.placed ? 1 : 0, s = Math.floor(127 * c.opacity);
        return s * dl + t * Fh + s * fl + t * Fc + s * Yu + t * Oa + s * Fa + t;
      }
      const Ds = 0;
      class Bh {
        constructor(t) {
          this._sortAcrossTiles = t.layout.get("symbol-z-order") !== "viewport-y" && t.layout.get("symbol-sort-key").constantOr(1) !== void 0, this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
        }
        continuePlacement(t, s, h, m, g, T) {
          const z = this._bucketParts;
          for (; this._currentTileIndex < t.length; )
            if (s.getBucketParts(z, m, t[this._currentTileIndex], this._sortAcrossTiles, T), this._currentTileIndex++, g())
              return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, z.sort((R, F) => R.sortKey - F.sortKey)); this._currentPartIndex < z.length; ) {
            const R = z[this._currentPartIndex];
            if (s.placeLayerBucketPart(R, this._seenCrossTileIDs, h, R.symbolInstanceStart === 0, T), this._currentPartIndex++, g())
              return !0;
          }
          return !1;
        }
      }
      class Wo {
        constructor(t, s, h, m, g, T, z, R, F) {
          this.placement = new or(t, g, T, z, R, F), this._currentPlacementIndex = s.length - 1, this._forceFullPlacement = h, this._showCollisionBoxes = m, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, s, h, m, g) {
          const T = i.q.now(), z = () => {
            const R = i.q.now() - T;
            return !this._forceFullPlacement && R > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const R = s[t[this._currentPlacementIndex]], F = this.placement.collisionIndex.transform.zoom;
            if (R.type === "symbol" && (!R.minzoom || R.minzoom <= F) && (!R.maxzoom || R.maxzoom > F)) {
              const N = R, j = N.layout.get("symbol-z-elevate"), G = N.layout.get("symbol-sort-key").constantOr(1) !== void 0, W = N.layout.get("symbol-z-order"), te = W === "viewport-y" || W === "auto" && !(W !== "viewport-y" && G), ee = N.layout.get("text-allow-overlap") || N.layout.get("icon-allow-overlap") || N.layout.get("text-ignore-placement") || N.layout.get("icon-ignore-placement"), se = te && ee, oe = this._inProgressLayer = this._inProgressLayer || new Bh(N), ce = i.aC(R.source, R.scope);
              if (oe.continuePlacement(j || se ? m[ce] : h[ce], this.placement, this._showCollisionBoxes, R, z, g))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const rs = 512 / i.ag / 2;
      class Nh {
        constructor(t, s, h) {
          this.tileID = t, this.bucketInstanceId = h, this.index = new i.bE(s.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
          const m = t.canonical.x * i.ag, g = t.canonical.y * i.ag;
          for (let T = 0; T < s.length; T++) {
            const { key: z, crossTileID: R, tileAnchorX: F, tileAnchorY: N } = s.get(T), j = Math.floor((m + F) * rs), G = Math.floor((g + N) * rs);
            this.index.add(j, G), this.keys.push(z), this.crossTileIDs.push(R);
          }
          this.index.finish();
        }
        findMatches(t, s, h) {
          const m = this.tileID.canonical.z < s.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - s.canonical.z), g = rs / Math.pow(2, s.canonical.z - this.tileID.canonical.z), T = s.canonical.x * i.ag, z = s.canonical.y * i.ag;
          for (let R = 0; R < t.length; R++) {
            const F = t.get(R);
            if (F.crossTileID)
              continue;
            const { key: N, tileAnchorX: j, tileAnchorY: G } = F, W = Math.floor((T + j) * g), te = Math.floor((z + G) * g), ee = this.index.range(W - m, te - m, W + m, te + m);
            for (const se of ee) {
              const oe = this.crossTileIDs[se];
              if (this.keys[se] === N && !h.has(oe)) {
                h.add(oe), F.crossTileID = oe;
                break;
              }
            }
          }
        }
      }
      class Vh {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Ku {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t) {
          const s = Math.round((t - this.lng) / 360);
          if (s !== 0)
            for (const h in this.indexes) {
              const m = this.indexes[h], g = {};
              for (const T in m) {
                const z = m[T];
                z.tileID = z.tileID.unwrapTo(z.tileID.wrap + s), g[z.tileID.key] = z;
              }
              this.indexes[h] = g;
            }
          this.lng = t;
        }
        addBucket(t, s, h) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === s.bucketInstanceId)
              return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let g = 0; g < s.symbolInstances.length; g++)
            s.symbolInstances.get(g).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = /* @__PURE__ */ new Set());
          const m = this.usedCrossTileIDs[t.overscaledZ];
          for (const g in this.indexes) {
            const T = this.indexes[g];
            if (Number(g) > t.overscaledZ)
              for (const z in T) {
                const R = T[z];
                R.tileID.isChildOf(t) && R.findMatches(s.symbolInstances, t, m);
              }
            else {
              const z = T[t.scaledTo(Number(g)).key];
              z && z.findMatches(s.symbolInstances, t, m);
            }
          }
          for (let g = 0; g < s.symbolInstances.length; g++) {
            const T = s.symbolInstances.get(g);
            T.crossTileID || (T.crossTileID = h.generate(), m.add(T.crossTileID));
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), this.indexes[t.overscaledZ][t.key] = new Nh(t, s.symbolInstances, s.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(t, s) {
          for (const h of s.crossTileIDs)
            this.usedCrossTileIDs[t].delete(h);
        }
        removeStaleBuckets(t) {
          let s = !1;
          for (const h in this.indexes) {
            const m = this.indexes[h];
            for (const g in m)
              t[m[g].bucketInstanceId] || (this.removeBucketCrossTileIDs(h, m[g]), delete m[g], s = !0);
          }
          return s;
        }
      }
      class Gl {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Vh(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t, s, h, m) {
          let g = this.layerIndexes[t.fqid];
          g === void 0 && (g = this.layerIndexes[t.fqid] = new Ku());
          let T = !1;
          const z = {};
          m.name !== "globe" && g.handleWrapJump(h);
          for (const R of s) {
            const F = R.getBucket(t);
            F && t.fqid === F.layerIds[0] && (F.bucketInstanceId || (F.bucketInstanceId = ++this.maxBucketInstanceId), g.addBucket(R.tileID, F, this.crossTileIDs) && (T = !0), z[F.bucketInstanceId] = !0);
          }
          return g.removeStaleBuckets(z) && (T = !0), T;
        }
        pruneUnusedLayers(t) {
          const s = {};
          t.forEach((h) => {
            s[h] = !0;
          });
          for (const h in this.layerIndexes)
            s[h] || delete this.layerIndexes[h];
        }
      }
      const $o = 771;
      class bi {
        constructor(t, s, h, m) {
          this.blendFunction = t, this.blendColor = s, this.mask = h, this.blendEquation = m;
        }
      }
      bi.Replace = [1, 0, 1, 0], bi.disabled = new bi(bi.Replace, i.aj.transparent, [!1, !1, !1, !1]), bi.unblended = new bi(bi.Replace, i.aj.transparent, [!0, !0, !0, !0]), bi.alphaBlended = new bi([1, $o, 1, $o], i.aj.transparent, [!0, !0, !0, !0]), bi.alphaBlendedNonPremultiplied = new bi([770, $o, 770, $o], i.aj.transparent, [!0, !0, !0, !0]), bi.multiply = new bi([774, 0, 774, 0], i.aj.transparent, [!0, !0, !0, !0]);
      class Wt {
        constructor(t, s, h) {
          this.func = t, this.mask = s, this.range = h;
        }
      }
      Wt.ReadOnly = !1, Wt.ReadWrite = !0, Wt.disabled = new Wt(519, Wt.ReadOnly, [0, 1]);
      const ml = 7680;
      class ci {
        constructor(t, s, h, m, g, T) {
          this.test = t, this.ref = s, this.mask = h, this.fail = m, this.depthFail = g, this.pass = T;
        }
      }
      ci.disabled = new ci({ func: 519, mask: 0 }, 0, 0, ml, ml, ml);
      const ar = 1029, lr = 2305;
      class ti {
        constructor(t, s, h) {
          this.enable = t, this.mode = s, this.frontFace = h;
        }
      }
      function Xr(c, t) {
        const s = i.bG(c, 3);
        i.ab.mat4.fromQuat(c, t), i.bI(c, 3, s);
      }
      function Zl(c, t) {
        const s = i.ab.quat.identity([]);
        return i.ab.quat.rotateZ(s, s, -t), i.ab.quat.rotateX(s, s, -c), s;
      }
      function Yr(c, t) {
        const s = [c[0], c[1], 0], h = [t[0], t[1], 0];
        if (i.ab.vec3.length(s) >= 1e-15) {
          const T = i.ab.vec3.normalize([], s);
          i.ab.vec3.scale(h, T, i.ab.vec3.dot(h, T)), t[0] = h[0], t[1] = h[1];
        }
        const m = i.ab.vec3.cross([], t, c);
        if (i.ab.vec3.len(m) < 1e-15)
          return null;
        const g = Math.atan2(-m[1], m[0]);
        return Zl(Math.atan2(Math.sqrt(c[0] * c[0] + c[1] * c[1]), -c[2]), g);
      }
      ti.disabled = new ti(!1, ar, lr), ti.backCCW = new ti(!0, ar, lr), ti.backCW = new ti(!0, ar, 2304), ti.frontCW = new ti(!0, 1028, 2304), ti.frontCCW = new ti(!0, 1028, lr);
      class Ba {
        constructor(t, s) {
          this.position = t, this.orientation = s;
        }
        get position() {
          return this._position;
        }
        set position(t) {
          if (t) {
            const s = t instanceof i.aa ? t : new i.aa(t[0], t[1], t[2]);
            this._renderWorldCopies && (s.x = i.bF(s.x, 0, 1)), this._position = s;
          } else
            this._position = null;
        }
        lookAtPoint(t, s) {
          if (this.orientation = null, !this.position)
            return;
          const h = this.position, m = this._elevation ? this._elevation.getAtPointOrZero(i.aa.fromLngLat(t)) : 0, g = i.aa.fromLngLat(t, m), T = [g.x - h.x, g.y - h.y, g.z - h.z];
          s || (s = [0, 0, 1]), s[2] = Math.abs(s[2]), this.orientation = Yr(T, s);
        }
        setPitchBearing(t, s) {
          this.orientation = Zl(i.ai(t), i.ai(-s));
        }
      }
      class wo {
        constructor(t, s) {
          this._transform = i.ab.mat4.identity([]), this.orientation = s, this.position = t;
        }
        get mercatorPosition() {
          const t = this.position;
          return new i.aa(t[0], t[1], t[2]);
        }
        get position() {
          const t = i.bG(this._transform, 3);
          return [t[0], t[1], t[2]];
        }
        set position(t) {
          var s;
          t && i.bI(this._transform, 3, [(s = t)[0], s[1], s[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t) {
          this._orientation = t || i.ab.quat.identity([]), t && Xr(this._transform, this._orientation);
        }
        getPitchBearing() {
          const t = this.forward(), s = this.right();
          return { bearing: Math.atan2(-s[1], s[0]), pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]) };
        }
        setPitchBearing(t, s) {
          this._orientation = Zl(t, s), Xr(this._transform, this._orientation);
        }
        forward() {
          const t = i.bG(this._transform, 2);
          return [-t[0], -t[1], -t[2]];
        }
        up() {
          const t = i.bG(this._transform, 1);
          return [-t[0], -t[1], -t[2]];
        }
        right() {
          const t = i.bG(this._transform, 0);
          return [t[0], t[1], t[2]];
        }
        getCameraToWorld(t, s) {
          const h = new Float64Array(16);
          return i.ab.mat4.invert(h, this.getWorldToCamera(t, s)), h;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t, s, h) {
          const m = this.position;
          i.ab.vec3.scale(m, m, -t);
          const g = new Float64Array(16);
          return i.ab.mat4.fromScaling(g, [h, h, h]), i.ab.mat4.translate(g, g, m), g[10] *= s, g;
        }
        getWorldToCamera(t, s) {
          const h = new Float64Array(16), m = new Float64Array(4), g = this.position;
          return i.ab.quat.conjugate(m, this._orientation), i.ab.vec3.scale(g, g, -t), i.ab.mat4.fromQuat(h, m), i.ab.mat4.translate(h, h, g), h[1] *= -1, h[5] *= -1, h[9] *= -1, h[13] *= -1, h[8] *= s, h[9] *= s, h[10] *= s, h[11] *= s, h;
        }
        getCameraToClipPerspective(t, s, h, m) {
          const g = new Float64Array(16);
          return i.ab.mat4.perspective(g, t, s, h, m), g;
        }
        getCameraToClipOrthographic(t, s, h, m, g, T) {
          const z = new Float64Array(16);
          return i.ab.mat4.ortho(z, t, s, h, m, g, T), z;
        }
        getDistanceToElevation(t, s = !1) {
          const h = t === 0 ? 0 : i.bH(t, s ? i.aS(this.position[1]) : this.position[1]), m = this.forward();
          return (h - this.position[2]) / m[2];
        }
        clone() {
          return new wo([...this.position], [...this.orientation]);
        }
      }
      const bs = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
      class ks {
        constructor(t = 0, s = 0, h = 0, m = 0) {
          if (isNaN(t) || t < 0 || isNaN(s) || s < 0 || isNaN(h) || h < 0 || isNaN(m) || m < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t, this.bottom = s, this.left = h, this.right = m;
        }
        interpolate(t, s, h) {
          return s.top != null && t.top != null && (this.top = i.af(t.top, s.top, h)), s.bottom != null && t.bottom != null && (this.bottom = i.af(t.bottom, s.bottom, h)), s.left != null && t.left != null && (this.left = i.af(t.left, s.left, h)), s.right != null && t.right != null && (this.right = i.af(t.right, s.right, h)), this;
        }
        getCenter(t, s) {
          const h = i.aw((this.left + t - this.right) / 2, 0, t), m = i.aw((this.top + s - this.bottom) / 2, 0, s);
          return new i.P(h, m);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new ks(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const Hl = (c, t, s) => (1 - s) * c + s * t, wt = (c) => c * c * c * c * c;
      class pa {
        constructor(t, s, h, m, g, T, z) {
          this.tileSize = 512, this._renderWorldCopies = g === void 0 || g, this._minZoom = t || 0, this._maxZoom = s || 22, this._minPitch = h ?? 0, this._maxPitch = m ?? 60, this.setProjection(T), this.setMaxBounds(z), this.width = 0, this.height = 0, this._center = new i.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new ks(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new wo(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = !1;
        }
        clone() {
          const t = new pa(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return t._elevation = this._elevation, t._centerAltitude = this._centerAltitude, t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, t.tileSize = this.tileSize, t.mercatorFromTransition = this.mercatorFromTransition, t.width = this.width, t.height = this.height, t.cameraElevationReference = this.cameraElevationReference, t._center = this._center, t._setZoom(this.zoom), t._seaLevelZoom = this._seaLevelZoom, t.angle = this.angle, t._fov = this._fov, t._pitch = this._pitch, t._nearZ = this._nearZ, t._farZ = this._farZ, t._averageElevation = this._averageElevation, t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, t._unmodified = this._unmodified, t._edgeInsets = this._edgeInsets.clone(), t._camera = this._camera.clone(), t._calcMatrices(), t.freezeTileCoverage = this.freezeTileCoverage, t.frustumCorners = this.frustumCorners, t;
        }
        get isOrthographic() {
          return this.projection.name !== "globe" && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          this._elevation !== t && (this._elevation = t, this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return this.projection.name !== "globe" && !this.isOrthographic;
        }
        updateElevation(t, s = !1) {
          const h = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || h) && this._updateCameraOnTerrain(), (t || h) && this._constrainCamera(s), this._calcMatrices();
        }
        getProjection() {
          return i.ay(this.projection, ["name", "center", "parallels"]);
        }
        setProjection(t) {
          this.projectionOptions = t || { name: "mercator" };
          const s = this.projection ? this.getProjection() : void 0;
          this.projection = i.bP(this.projectionOptions);
          const h = this.getProjection(), m = !i.bn(s, h);
          return m && this._calcMatrices(), this.mercatorFromTransition = !1, m;
        }
        setOrthographicProjectionAtLowPitch(t) {
          return this._orthographicProjectionAtLowPitch !== t && (this._orthographicProjectionAtLowPitch = t, this._calcMatrices(), !0);
        }
        setMercatorFromTransition() {
          const t = this.projection.name;
          this.mercatorFromTransition = !0, this.projectionOptions = { name: "mercator" }, this.projection = i.bP({ name: "mercator" });
          const s = t !== this.projection.name;
          return s && this._calcMatrices(), s;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && (this._minZoom = t, this.zoom = Math.max(this.zoom, t));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && (this._maxZoom = t, this.zoom = Math.min(this.zoom, t));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && (this._minPitch = t, this.pitch = Math.max(this.pitch, t));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && (this._maxPitch = t, this.pitch = Math.min(this.pitch, t));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
        }
        set renderWorldCopies(t) {
          t === void 0 ? t = !0 : t === null && (t = !1), this._renderWorldCopies = t;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get cameraWorldSize() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return i.bH(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new i.P(this.width, this.height);
        }
        get bearing() {
          return i.bF(this.rotation, -180, 180);
        }
        set bearing(t) {
          this.rotation = t;
        }
        get rotation() {
          return -this.angle / Math.PI * 180;
        }
        set rotation(t) {
          const s = -t * Math.PI / 180;
          this.angle !== s && (this._unmodified = !1, this.angle = s, this._calcMatrices(), this.rotationMatrix = i.ab.mat2.create(), i.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t) {
          const s = i.aw(t, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== s && (this._unmodified = !1, this._pitch = s, this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const t = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / t);
        }
        set fov(t) {
          t = Math.max(0.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = i.ai(t), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(t) {
          this._averageElevation = t, this._calcFogMatrices(), this._distanceTileDataCache = {};
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const s = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== s && (this._unmodified = !1, this._setZoom(s), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(t) {
          this._zoom = t, this.scale = this.zoomScale(t), this.tileZoom = Math.floor(t), this.zoomFraction = t - this.tileZoom;
        }
        get tileCoverLift() {
          return this._tileCoverLift;
        }
        set tileCoverLift(t) {
          this._tileCoverLift !== t && (this._tileCoverLift = t);
        }
        _updateCameraOnTerrain() {
          const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, s = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || t === Number.NEGATIVE_INFINITY && (!s || !this._centerAltitude))
            return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
          const h = this._elevation;
          s || this._centerAltitude && this._centerAltitudeValidForExaggeration && h.exaggeration() && this._centerAltitudeValidForExaggeration !== h.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * h.exaggeration(), this._centerAltitudeValidForExaggeration = h.exaggeration()) : (this._centerAltitude = t || 0, this._centerAltitudeValidForExaggeration = h.exaggeration()), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t = this._elevation, s = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], h = this.horizonLineFromTop();
          let m = 0, g = 0;
          for (let T = 0; T < s.length; T++) {
            const z = new i.P(s[T][0] * this.width, h + s[T][1] * (this.height - h)), R = t.pointCoordinate(z);
            if (!R)
              continue;
            const F = 1 / Math.hypot(R[0] - this._camera.position[0], R[1] - this._camera.position[1]);
            m += R[3] * F, g += F;
          }
          return g === 0 ? NaN : m / g;
        }
        get center() {
          return this._center;
        }
        set center(t) {
          t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1, this._center = t, this._terrainEnabled() && (this.cameraElevationReference === "ground" ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation)
            return;
          const t = this._seaLevelZoom, s = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), h = this.pixelsPerMeter / this.worldSize * s, m = this._mercatorZfromZoom(t), g = this._mercatorZfromZoom(this._maxZoom), T = Math.max(m - h, g);
          this._setZoom(this._zoomFromMercatorZ(T));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t) {
          const s = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
          let h;
          h = t.z < this._camera.position[2] ? [s.x, s.y, s.z] : [t.x, t.y, t.z];
          const m = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, h));
          return i.aw(this._zoomFromMercatorZ(m), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t) {
          if (!this.height || !t.position && !t.orientation)
            return;
          this._updateCameraState();
          let s = !1;
          if (t.orientation && !i.ab.quat.exactEquals(t.orientation, this._camera.orientation) && (s = this._setCameraOrientation(t.orientation)), t.position) {
            const h = [t.position.x, t.position.y, t.position.z];
            i.ab.vec3.exactEquals(h, this._camera.position) || (this._setCameraPosition(h), s = !0);
          }
          s && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t = this._camera.position, s = new Ba();
          return s.position = new i.aa(t[0], t[1], t[2]), s.orientation = this._camera.orientation, s._elevation = this.elevation, s._renderWorldCopies = this.renderWorldCopies, s;
        }
        _setCameraOrientation(t) {
          if (!i.ab.quat.length(t))
            return !1;
          i.ab.quat.normalize(t, t);
          const s = i.ab.vec3.transformQuat([], [0, 0, -1], t), h = i.ab.vec3.transformQuat([], [0, -1, 0], t);
          if (h[2] < 0)
            return !1;
          const m = Yr(s, h);
          return !!m && (this._camera.orientation = m, !0);
        }
        _setCameraPosition(t) {
          const s = this.zoomScale(this.minZoom) * this.tileSize, h = this.zoomScale(this.maxZoom) * this.tileSize, m = this.cameraToCenterDistance;
          t[2] = i.aw(t[2], m / h, m / s), this._camera.position = t;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, s, h) {
          this._unmodified = !1, this._edgeInsets.interpolate(t, s, h), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const s = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, s);
        }
        getVisibleUnwrappedCoordinates(t) {
          const s = [new i.bQ(0, t)];
          if (this.renderWorldCopies) {
            const h = this.pointCoordinate(new i.P(0, 0)), m = this.pointCoordinate(new i.P(this.width, 0)), g = this.pointCoordinate(new i.P(this.width, this.height)), T = this.pointCoordinate(new i.P(0, this.height)), z = Math.floor(Math.min(h.x, m.x, g.x, T.x)), R = Math.floor(Math.max(h.x, m.x, g.x, T.x)), F = 1;
            for (let N = z - F; N <= R + F; N++)
              N !== 0 && s.push(new i.bQ(N, t));
          }
          return s;
        }
        isLODDisabled(t) {
          return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCover(t, s, h) {
          let m = [];
          const g = h !== void 0, T = !g;
          if (T && this.zoom < s || g && h[0] === 0 && h[1] === 0)
            return m;
          const z = /* @__PURE__ */ new Set(), R = (N, j, G, W, te) => {
            const ee = i.c5(j, N, G, W, te);
            z.has(ee) || (m.push(new i.aG(N, j, G, W, te)), z.add(ee));
          };
          for (let N = 0; N < t.length; N++) {
            const j = t[N];
            if (T && j.canonical.z !== s)
              continue;
            const G = j.canonical, W = j.overscaledZ, te = j.wrap, ee = 1 << G.z, se = G.x + 1 < ee, oe = G.x > 0, ce = G.y + 1 < ee, _e = G.y > 0, pe = j.wrap - (oe ? 0 : 1), Te = j.wrap + (se ? 0 : 1), xe = oe ? G.x - 1 : ee - 1, be = se ? G.x + 1 : 0;
            if (g)
              h[0] < 0 ? (R(W, Te, G.z, be, G.y), h[1] < 0 && ce && (R(W, te, G.z, G.x, G.y + 1), R(W, Te, G.z, be, G.y + 1)), h[1] > 0 && _e && (R(W, te, G.z, G.x, G.y - 1), R(W, Te, G.z, be, G.y - 1))) : h[0] > 0 ? (R(W, pe, G.z, xe, G.y), h[1] < 0 && ce && (R(W, te, G.z, G.x, G.y + 1), R(W, pe, G.z, xe, G.y + 1)), h[1] > 0 && _e && (R(W, te, G.z, G.x, G.y - 1), R(W, pe, G.z, xe, G.y - 1))) : h[1] < 0 && ce ? R(W, te, G.z, G.x, G.y + 1) : _e && R(W, te, G.z, G.x, G.y - 1);
            else {
              const ve = j.visibleQuadrants;
              1 & ve && (R(W, pe, G.z, xe, G.y), _e && (R(W, te, G.z, G.x, G.y - 1), R(W, pe, G.z, xe, G.y - 1))), 2 & ve && (R(W, Te, G.z, be, G.y), _e && (R(W, te, G.z, G.x, G.y - 1), R(W, Te, G.z, be, G.y - 1))), 4 & ve && (R(W, pe, G.z, xe, G.y), ce && (R(W, te, G.z, G.x, G.y + 1), R(W, pe, G.z, xe, G.y + 1))), 8 & ve && (R(W, Te, G.z, be, G.y), ce && (R(W, te, G.z, G.x, G.y + 1), R(W, Te, G.z, be, G.y + 1)));
            }
          }
          const F = [];
          for (const N of m)
            m.some((j) => N.isChildOf(j)) || F.push(N);
          if (m = F.filter((N) => !t.some((j) => !!(N.overscaledZ < s && j.isChildOf(N)) || N.equals(j) || N.isChildOf(j))), T) {
            const N = 1 << s, j = this.projection.name === "globe" ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), G = [N * j.x, N * j.y], W = 4, te = W * W;
            m = m.filter((ee) => {
              const se = ee.canonical.x + 0.5 - G[0], oe = ee.canonical.y + 0.5 - G[1];
              return se * se + oe * oe < te;
            });
          }
          return m;
        }
        coveringTiles(t) {
          let s = this.coveringZoomLevel(t);
          const h = s, m = this.elevation && this.elevation.exaggeration(), g = m && !t.isTerrainDEM, T = this.projection.name === "mercator";
          if (t.minzoom !== void 0 && s < t.minzoom)
            return [];
          t.maxzoom !== void 0 && s > t.maxzoom && (s = t.maxzoom);
          const z = this.locationCoordinate(this.center), R = this.center.lat, F = 1 << s, N = [F * z.x, F * z.y, 0], j = this.projection.name === "globe", G = !j, W = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, s, G), te = j ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), ee = F * i.bH(1, this.center.lat), se = this._camera.position[2] / i.bH(1, this.center.lat), oe = [F * te.x, F * te.y, se * (G ? 1 : ee)], ce = j || m, _e = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : 0.502), pe = this.isLODDisabled(!0) ? s : 0;
          let Te;
          if (this._elevation && t.isTerrainDEM)
            Te = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const je = this._elevation.getMinMaxForVisibleTiles();
            Te = je ? je.max : this._centerAltitude;
          } else
            Te = this._centerAltitude;
          const xe = t.isTerrainDEM ? -Te : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, be = this.projection.isReprojectedInTileSpace ? i.bS(this) : 1, ve = (je) => {
            const Je = new i.aa(je.x + 25e-6, je.y, je.z), _t = new i.aa(je.x, je.y + 25e-6, je.z), ct = je.toLngLat(), nt = Je.toLngLat(), Lt = _t.toLngLat(), xt = this.locationCoordinate(ct), zt = this.locationCoordinate(nt), Bt = this.locationCoordinate(Lt), oi = Math.hypot(zt.x - xt.x, zt.y - xt.y), $t = Math.hypot(Bt.x - xt.x, Bt.y - xt.y);
            return Math.sqrt(oi * $t) * be / 25e-6;
          }, Pe = (je) => {
            const at = Te, Je = xe;
            return { aabb: i.bV(this, F, 0, 0, 0, je, Je, at, this.projection), zoom: 0, x: 0, y: 0, minZ: Je, maxZ: at, wrap: je, fullyVisible: !1 };
          }, Oe = [];
          let Xe = [];
          const Ze = s, ke = t.reparseOverscaled ? h : s, Ne = (se - this._centerAltitude) * ee, st = (je) => {
            if (!this._elevation || !je.tileID || !T)
              return;
            const at = this._elevation.getMinMaxForTile(je.tileID), Je = je.aabb;
            at ? (Je.min[2] = at.min, Je.max[2] = at.max, Je.center[2] = (Je.min[2] + Je.max[2]) / 2) : (je.shouldSplit = yt(je), je.shouldSplit || (Je.min[2] = Je.max[2] = Je.center[2] = this._centerAltitude));
          }, ht = (je, at) => {
            if (0.707 * at < je)
              return 1;
            const Je = at / je;
            return Je / (1.4144271570014144 + (Math.pow(1.1, Je - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
          }, yt = (je) => {
            if (je.zoom < pe)
              return !0;
            if (je.zoom === Ze)
              return !1;
            if (je.shouldSplit != null)
              return je.shouldSplit;
            const at = je.aabb.distanceX(oe), Je = je.aabb.distanceY(oe);
            let _t = Ne, ct = 1;
            if (j) {
              _t = je.aabb.distanceZ(oe);
              const $t = Math.pow(2, je.zoom), Xt = i.aS((je.y + 1) / $t), ai = i.aS(je.y / $t), zi = Math.min(Math.max(R, Xt), ai), wi = i.c9(zi) / i.c9(R);
              if (ct = zi === R ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, wi / this._mercatorScaleRatio), this.zoom <= i.c6 && je.zoom === Ze - 1 && wi >= 0.9)
                return !0;
            } else if (g && (_t = je.aabb.distanceZ(oe) * ee), this.projection.isReprojectedInTileSpace && h <= 5) {
              const $t = Math.pow(2, je.zoom), Xt = ve(new i.aa((je.x + 0.5) / $t, (je.y + 0.5) / $t));
              ct = Xt > 0.85 ? 1 : Xt;
            }
            if (!T) {
              const $t = Math.sqrt(at * at + Je * Je + _t * _t);
              let Xt = (1 << Ze - je.zoom) * _e * ct;
              return Xt *= ht(Math.max(_t, Ne), $t), $t < Xt;
            }
            let nt = Number.MAX_VALUE, Lt = 0;
            const xt = je.aabb.getCorners(), zt = [];
            for (const $t of xt) {
              i.ab.vec3.sub(zt, $t, oe), j || (g ? zt[2] *= ee : zt[2] = Ne);
              const Xt = i.ab.vec3.dot(zt, this._camera.forward());
              Xt < nt && (nt = Xt, Lt = Math.abs(zt[2]));
            }
            let Bt = (1 << Ze - je.zoom) * _e * ct;
            if (Bt *= ht(Math.max(Lt, Ne), nt), nt < Bt)
              return !0;
            const oi = je.aabb.closestPoint(N);
            return oi[0] === N[0] && oi[1] === N[1];
          };
          if (this.renderWorldCopies)
            for (let je = 1; je <= 3; je++)
              Oe.push(Pe(-je)), Oe.push(Pe(je));
          for (Oe.push(Pe(0)); Oe.length > 0; ) {
            const je = Oe.pop(), at = je.x, Je = je.y;
            let _t = je.fullyVisible;
            const ct = () => this.projection.name === "globe" && (je.y === 0 || je.y === (1 << je.zoom) - 1);
            if (!_t) {
              let nt = ce ? je.aabb.intersects(W) : je.aabb.intersectsFlat(W);
              if (nt === 0 && ct()) {
                const Lt = new i.bT(je.zoom, at, Je);
                nt = i.bU(this, F, Lt, !0).intersects(W);
              }
              if (nt === 0)
                continue;
              _t = nt === 2;
            }
            if (je.zoom !== Ze && yt(je))
              for (let nt = 0; nt < 4; nt++) {
                const Lt = (at << 1) + nt % 2, xt = (Je << 1) + (nt >> 1), zt = { aabb: T ? je.aabb.quadrant(nt) : i.bV(this, F, je.zoom + 1, Lt, xt, je.wrap, je.minZ, je.maxZ, this.projection), zoom: je.zoom + 1, x: Lt, y: xt, wrap: je.wrap, fullyVisible: _t, tileID: void 0, shouldSplit: void 0, minZ: je.minZ, maxZ: je.maxZ };
                g && !j && (zt.tileID = new i.aG(je.zoom + 1 === Ze ? ke : je.zoom + 1, je.wrap, je.zoom + 1, Lt, xt), st(zt)), Oe.push(zt);
              }
            else {
              const nt = je.zoom === Ze ? ke : je.zoom;
              if (t.minzoom && t.minzoom > nt)
                continue;
              let Lt = 0;
              if (!_t) {
                let oi = ce ? je.aabb.intersectsPrecise(W) : je.aabb.intersectsPreciseFlat(W);
                if (oi === 0 && ct()) {
                  const $t = new i.bT(je.zoom, at, Je);
                  oi = i.bU(this, F, $t, !0).intersectsPrecise(W);
                }
                if (oi === 0)
                  continue;
                if (t.calculateQuadrantVisibility)
                  if (W.containsPoint(je.aabb.center))
                    Lt = 15;
                  else
                    for (let $t = 0; $t < 4; $t++)
                      je.aabb.quadrant($t).intersects(W) !== 0 && (Lt |= 1 << $t);
              }
              const xt = N[0] - (0.5 + at + (je.wrap << je.zoom)) * (1 << s - je.zoom), zt = N[1] - 0.5 - Je, Bt = je.tileID ? je.tileID : new i.aG(nt, je.wrap, je.zoom, at, Je);
              t.calculateQuadrantVisibility && (Bt.visibleQuadrants = Lt), Xe.push({ tileID: Bt, distanceSq: xt * xt + zt * zt });
            }
          }
          if (this.fogCullDistSq) {
            const je = this.fogCullDistSq, at = this.horizonLineFromTop();
            Xe = Xe.filter((Je) => {
              const _t = [0, 0, 0, 1], ct = [i.ag, i.ag, 0, 1], nt = this.calculateFogTileMatrix(Je.tileID.toUnwrapped());
              i.ab.vec4.transformMat4(_t, _t, nt), i.ab.vec4.transformMat4(ct, ct, nt);
              const Lt = i.ab.vec4.min([], _t, ct), xt = i.ab.vec4.max([], _t, ct), zt = i.bW(Lt, xt);
              if (zt === 0)
                return !0;
              let Bt = !1;
              const oi = this._elevation;
              if (oi && zt > je && at !== 0) {
                const $t = this.calculateProjMatrix(Je.tileID.toUnwrapped());
                let Xt;
                t.isTerrainDEM || (Xt = oi.getMinMaxForTile(Je.tileID)), Xt || (Xt = { min: xe, max: Te });
                const ai = i.c7(this.rotation), zi = [ai[0] * i.ag, ai[1] * i.ag, Xt.max];
                i.ab.vec3.transformMat4(zi, zi, $t), Bt = (1 - zi[1]) * this.height * 0.5 < at;
              }
              return zt < je || Bt;
            });
          }
          return Xe.sort((je, at) => je.distanceSq - at.distanceSq).map((je) => je.tileID);
        }
        resize(t, s) {
          this.width = t, this.height = s, this.pixelsToGLUnits = [2 / t, -2 / s], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const s = i.aw(t.lat, -i.bX, i.bX), h = this.projection.project(t.lng, s);
          return new i.P(h.x * this.worldSize, h.y * this.worldSize);
        }
        unproject(t) {
          return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / i.bH(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t, s) {
          let h, m;
          const g = this.centerPoint;
          if (this.projection.name === "globe") {
            const z = this.worldSize;
            h = (s.x - g.x) / z, m = (s.y - g.y) / z;
          } else {
            const z = this.pointCoordinate(s), R = this.pointCoordinate(g);
            h = z.x - R.x, m = z.y - R.y;
          }
          const T = this.locationCoordinate(t);
          this.setLocation(new i.aa(T.x - h, T.y - m));
        }
        setLocation(t) {
          this.center = this.coordinateLocation(t), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(t) {
          return this.projection.locationPoint(this, t);
        }
        locationPoint3D(t) {
          return this.projection.locationPoint(this, t, !0);
        }
        pointLocation(t) {
          return this.coordinateLocation(this.pointCoordinate(t));
        }
        pointLocation3D(t) {
          return this.coordinateLocation(this.pointCoordinate3D(t));
        }
        locationCoordinate(t, s) {
          const h = s ? i.bH(s, t.lat) : void 0, m = this.projection.project(t.lng, t.lat);
          return new i.aa(m.x, m.y, h);
        }
        coordinateLocation(t) {
          return this.projection.unproject(t.x, t.y);
        }
        pointRayIntersection(t, s) {
          const h = s ?? this._centerAltitude, m = [t.x, t.y, 0, 1], g = [t.x, t.y, 1, 1];
          i.ab.vec4.transformMat4(m, m, this.pixelMatrixInverse), i.ab.vec4.transformMat4(g, g, this.pixelMatrixInverse);
          const T = g[3];
          i.ab.vec4.scale(m, m, 1 / m[3]), i.ab.vec4.scale(g, g, 1 / T);
          const z = m[2], R = g[2];
          return { p0: m, p1: g, t: z === R ? 0 : (h - z) / (R - z) };
        }
        screenPointToMercatorRay(t) {
          const s = [t.x, t.y, 0, 1], h = [t.x, t.y, 1, 1];
          return i.ab.vec4.transformMat4(s, s, this.pixelMatrixInverse), i.ab.vec4.transformMat4(h, h, this.pixelMatrixInverse), i.ab.vec4.scale(s, s, 1 / s[3]), i.ab.vec4.scale(h, h, 1 / h[3]), s[2] = i.bH(s[2], this._center.lat) * this.worldSize, h[2] = i.bH(h[2], this._center.lat) * this.worldSize, i.ab.vec4.scale(s, s, 1 / this.worldSize), i.ab.vec4.scale(h, h, 1 / this.worldSize), new i.aq([s[0], s[1], s[2]], i.ab.vec3.normalize([], i.ab.vec3.sub([], h, s)));
        }
        rayIntersectionCoordinate(t) {
          const { p0: s, p1: h, t: m } = t, g = i.bH(s[2], this._center.lat), T = i.bH(h[2], this._center.lat);
          return new i.aa(i.af(s[0], h[0], m) / this.worldSize, i.af(s[1], h[1], m) / this.worldSize, i.af(g, T, m));
        }
        pointCoordinate(t, s = this._centerAltitude) {
          return this.projection.pointCoordinate(this, t.x, t.y, s);
        }
        pointCoordinate3D(t) {
          if (!this.elevation)
            return this.pointCoordinate(t);
          let s = this.projection.pointCoordinate3D(this, t.x, t.y);
          if (s)
            return new i.aa(s[0], s[1], s[2]);
          let h = 0, m = this.horizonLineFromTop();
          if (t.y > m)
            return this.pointCoordinate(t);
          const g = 0.02 * m, T = t.clone();
          for (let z = 0; z < 10 && m - h > g; z++) {
            T.y = i.af(h, m, 0.66);
            const R = this.projection.pointCoordinate3D(this, T.x, T.y);
            R ? (m = T.y, s = R) : h = T.y;
          }
          return s ? new i.aa(s[0], s[1], s[2]) : this.pointCoordinate(t);
        }
        isPointAboveHorizon(t) {
          return this.projection.isPointAboveHorizon(this, t);
        }
        isPointOnSurface(t) {
          if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width)
            return !1;
          if (this.elevation || this.zoom >= i.bY)
            return !this.isPointAboveHorizon(t);
          const s = this.pointCoordinate(t);
          return s.y >= 0 && s.y <= 1;
        }
        _coordinatePoint(t, s) {
          const h = s && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude, m = [t.x * this.worldSize, t.y * this.worldSize, h + t.toAltitude(), 1];
          return i.ab.vec4.transformMat4(m, m, this.pixelMatrix), m[3] > 0 ? new i.P(m[0] / m[3], m[1] / m[3]) : new i.P(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t, left: s } = this._edgeInsets, h = this.height - this._edgeInsets.bottom, m = this.width - this._edgeInsets.right, g = this.pointLocation3D(new i.P(s, t)), T = this.pointLocation3D(new i.P(m, t)), z = this.pointLocation3D(new i.P(m, h)), R = this.pointLocation3D(new i.P(s, h));
          let F = Math.min(g.lng, T.lng, z.lng, R.lng), N = Math.max(g.lng, T.lng, z.lng, R.lng), j = Math.min(g.lat, T.lat, z.lat, R.lat), G = Math.max(g.lat, T.lat, z.lat, R.lat);
          const W = Math.pow(2, -this.zoom) / 16 * 270, te = this.projection.name === "globe" ? 1 : 4, ee = (se, oe, ce, _e, pe) => {
            const Te = (se + ce) / 2, xe = (oe + _e) / 2, be = new i.P(Te, xe), { lng: ve, lat: Pe } = this.pointLocation3D(be), Oe = Math.max(0, F - ve, j - Pe, ve - N, Pe - G);
            F = Math.min(F, ve), N = Math.max(N, ve), j = Math.min(j, Pe), G = Math.max(G, Pe), (pe < te || Oe > W) && (ee(se, oe, Te, xe, pe + 1), ee(Te, xe, ce, _e, pe + 1));
          };
          if (ee(s, t, m, t, 1), ee(m, t, m, h, 1), ee(m, h, s, h, 1), ee(s, h, s, t, 1), this.projection.name === "globe") {
            const [se, oe] = i.bZ(this);
            se ? (G = 90, N = 180, F = -180) : oe && (j = -90, N = 180, F = -180);
          }
          return new i.az(new i.bO(F, j), new i.bO(N, G));
        }
        _getBoundsRectangular(t, s) {
          const { top: h, left: m } = this._edgeInsets, g = this.height - this._edgeInsets.bottom, T = this.width - this._edgeInsets.right, z = new i.P(m, h), R = new i.P(T, h), F = new i.P(T, g), N = new i.P(m, g);
          let j = this.pointCoordinate(z, t), G = this.pointCoordinate(R, t);
          const W = this.pointCoordinate(F, s), te = this.pointCoordinate(N, s), ee = (se, oe) => (oe.y - se.y) / (oe.x - se.x);
          return j.y > 1 && G.y >= 0 ? j = new i.aa((1 - te.y) / ee(te, j) + te.x, 1) : j.y < 0 && G.y <= 1 && (j = new i.aa(-te.y / ee(te, j) + te.x, 0)), G.y > 1 && j.y >= 0 ? G = new i.aa((1 - W.y) / ee(W, G) + W.x, 1) : G.y < 0 && j.y <= 1 && (G = new i.aa(-W.y / ee(W, G) + W.x, 0)), new i.az().extend(this.coordinateLocation(j)).extend(this.coordinateLocation(G)).extend(this.coordinateLocation(te)).extend(this.coordinateLocation(W));
        }
        _getBoundsRectangularTerrain() {
          const t = this.elevation;
          if (!t.visibleDemTiles.length || t.isUsingMockSource())
            return this._getBoundsRectangular(0, 0);
          const s = t.visibleDemTiles.reduce((h, m) => {
            if (m.dem) {
              const g = m.dem.tree;
              h.min = Math.min(h.min, g.minimums[0]), h.max = Math.max(h.max, g.maximums[0]);
            }
            return h;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBoundsRectangular(s.min * t.exaggeration(), s.max * t.exaggeration());
        }
        getBounds() {
          return this.projection.name === "mercator" || this.projection.name === "equirectangular" ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(t = !0) {
          const s = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, h = this.height / 2 - s * (1 - this._horizonShift);
          return t ? Math.max(0, h) : h;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t) {
          this.maxBounds = t, this.minLat = -i.bX, this.maxLat = i.bX, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = i.at(this.minLng) * this.tileSize, this.worldMaxX = i.at(this.maxLng) * this.tileSize, this.worldMinY = i.aA(this.maxLat) * this.tileSize, this.worldMaxY = i.aA(this.minLat) * this.tileSize, this._constrain();
        }
        calculatePosMatrix(t, s) {
          return this.projection.createTileMatrix(this, s, t);
        }
        calculateDistanceTileData(t) {
          const s = t.key, h = this._distanceTileDataCache;
          if (h[s])
            return h[s];
          const m = t.canonical, g = 1 / this.height, T = this.cameraWorldSize, z = T / this.zoomScale(m.z), R = (m.x + Math.pow(2, m.z) * t.wrap) * z, F = m.y * z, N = this.point;
          N.x *= T / this.worldSize, N.y *= T / this.worldSize;
          const j = this.angle, G = Math.sin(-j), W = -Math.cos(-j);
          return h[s] = { bearing: [G, W], center: [(N.x - R) * g, (N.y - F) * g], scale: z / i.ag * g }, h[s];
        }
        calculateFogTileMatrix(t) {
          const s = t.key, h = this._fogTileMatrixCache;
          if (h[s])
            return h[s];
          const m = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
          return i.ab.mat4.multiply(m, this.worldToFogMatrix, m), h[s] = new Float32Array(m), h[s];
        }
        calculateProjMatrix(t, s = !1, h = !1) {
          const m = t.key;
          let g;
          if (g = h ? this._expandedProjMatrixCache : s ? this._alignedProjMatrixCache : this._projMatrixCache, g[m])
            return g[m];
          const T = this.calculatePosMatrix(t, this.worldSize);
          let z;
          return z = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : h ? this.expandedFarZProjMatrix : s ? this.alignedProjMatrix : this.projMatrix, i.ab.mat4.multiply(T, z, T), g[m] = new Float32Array(T), g[m];
        }
        calculatePixelsToTileUnitsMatrix(t) {
          const s = t.tileID.key, h = this._pixelsToTileUnitsCache;
          if (h[s])
            return h[s];
          const m = i.b_(t, this);
          return h[s] = m, h[s];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if (this.projection.name === "globe") {
            const t = 1 / this.worldSize, s = i.ab.mat4.fromScaling([], [t, t, t]);
            return i.ab.mat4.multiply(s, s, this.globeMatrix), s;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === "globe")
            return;
          const t = this._elevation;
          this._updateCameraState();
          const s = i.bH(1, this._center.lat) * this.worldSize, h = this._computeCameraPosition(s), m = this._camera.forward(), g = i.bH(1, this._center.lat);
          h[2] /= g, m[2] /= g, i.ab.vec3.normalize(m, m);
          const T = t.raycast(h, m, t.exaggeration());
          if (T) {
            const z = i.ab.vec3.scaleAndAdd([], h, m, T), R = new i.aa(z[0], z[1], i.bH(z[2], i.aS(z[1]))), F = (R.z + i.ab.vec3.length([R.x - h[0], R.y - h[1], R.z - h[2] * g])) * this._pixelsPerMercatorPixel;
            this._seaLevelZoom = this._zoomFromMercatorZ(F), this._centerAltitude = R.toAltitude(), this._center = this.coordinateLocation(R), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t = !1) {
          if (!this._elevation)
            return;
          const s = this._elevation, h = i.bH(1, this._center.lat) * this.worldSize, m = this._computeCameraPosition(h), g = s.getAtPointOrZero(new i.aa(...m)), T = this.pixelsPerMeter / this.worldSize * g, z = this._minimumHeightOverTerrain(), R = m[2] - T;
          if (R <= z)
            if (R < 0 || t) {
              const F = this.locationCoordinate(this._center, this._centerAltitude), N = [m[0], m[1], F.z - m[2]], j = i.ab.vec3.length(N);
              N[2] -= (z - R) / this._pixelsPerMercatorPixel;
              const G = i.ab.vec3.length(N);
              if (G === 0)
                return;
              i.ab.vec3.scale(N, N, j / G * this._pixelsPerMercatorPixel), this._camera.position = [m[0], m[1], F.z * this._pixelsPerMercatorPixel - N[2]], this._updateStateFromCamera();
            } else
              this._isCameraConstrained = !0;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = !0;
          const t = this.projection.name === "globe" || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t) {
            const G = this.center;
            return G.lat = i.aw(G.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (G.lng = i.aw(G.lng, this.minLng, this.maxLng)), this.center = G, void (this._constraining = !1);
          }
          const s = this._unmodified, { x: h, y: m } = this.point;
          let g = 0, T = h, z = m;
          const R = this.width / 2, F = this.height / 2, N = this.worldMinY * this.scale, j = this.worldMaxY * this.scale;
          if (m - F < N && (z = N + F), m + F > j && (z = j - F), j - N < this.height && (g = Math.max(g, this.height / (j - N)), z = (j + N) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
            const G = this.worldMinX * this.scale, W = this.worldMaxX * this.scale, te = this.worldSize / 2 - (G + W) / 2;
            T = (h + te + this.worldSize) % this.worldSize - te, T - R < G && (T = G + R), T + R > W && (T = W - R), W - G < this.width && (g = Math.max(g, this.width / (W - G)), T = (W + G) / 2);
          }
          T === h && z === m || (this.center = this.unproject(new i.P(T, z))), g && (this.zoom += this.scaleZoom(g)), this._constrainCamera(), this._unmodified = s, this._constraining = !1;
        }
        _minZoomForBounds() {
          let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t = this.centerOffset, s = this.projection.name === "globe", h = this.pixelsPerMeter;
          this.projection.name === "globe" && (this._mercatorScaleRatio = i.bH(1, this.center.lat) / i.bH(1, i.c8));
          const m = i.b$(this.projection, this.zoom, this.width, this.height, 1024);
          this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, m), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
          const g = this.projection.zAxisUnit === "meters" ? h : 1, T = this._camera.getWorldToCamera(this.worldSize, g);
          let z;
          const R = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (R[8] = 2 * -t.x / this.width, R[9] = 2 * t.y / this.height, this.isOrthographic) {
            let Pe = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), Oe = Pe * this.aspect, Xe = -Oe, Ze = -Pe;
            Oe -= t.x, Xe -= t.x, Pe += t.y, Ze += t.y, z = this._camera.getCameraToClipOrthographic(Xe, Oe, Ze, Pe, this._nearZ, this._farZ), ((ke, Ne, st, ht) => {
              for (let yt = 0; yt < 16; yt++)
                ke[yt] = Hl(Ne[yt], st[yt], ht);
            })(z, z, R, wt(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else
            z = R;
          const F = i.ab.mat4.mul([], R, T);
          let N = i.ab.mat4.mul([], z, T);
          if (this.projection.isReprojectedInTileSpace) {
            const Pe = this.locationCoordinate(this.center), Oe = i.ab.mat4.identity([]);
            i.ab.mat4.translate(Oe, Oe, [Pe.x * this.worldSize, Pe.y * this.worldSize, 0]), i.ab.mat4.multiply(Oe, Oe, i.c0(this)), i.ab.mat4.translate(Oe, Oe, [-Pe.x * this.worldSize, -Pe.y * this.worldSize, 0]), i.ab.mat4.multiply(N, N, Oe), i.ab.mat4.multiply(F, F, Oe), this.inverseAdjustmentMatrix = i.c1(this);
          } else
            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (this.mercatorMatrix = i.ab.mat4.scale([], N, [this.worldSize, this.worldSize, this.worldSize / g, 1]), this.projMatrix = N, this.invProjMatrix = i.ab.mat4.invert(new Float64Array(16), this.projMatrix), s) {
            const Pe = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            Pe[8] = 2 * -t.x / this.width, Pe[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = i.ab.mat4.mul([], Pe, T);
          } else
            this.expandedFarZProjMatrix = this.projMatrix;
          const j = i.ab.mat4.invert([], z);
          this.frustumCorners = i.c2.fromInvProjectionMatrix(j, this.horizonLineFromTop(), this.height), this.cameraFrustum = i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !s);
          const G = new Float32Array(16);
          i.ab.mat4.identity(G), i.ab.mat4.scale(G, G, [1, -1, 1]), i.ab.mat4.rotateX(G, G, this._pitch), i.ab.mat4.rotateZ(G, G, this.angle);
          const W = i.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = i.ab.mat4.clone(W);
          const te = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          W[8] = 2 * -t.x / this.width, W[9] = 2 * (t.y + te) / this.height, this.skyboxMatrix = i.ab.mat4.multiply(G, W, G);
          const ee = this.point, se = ee.x, oe = ee.y, ce = this.width % 2 / 2, _e = this.height % 2 / 2, pe = Math.cos(this.angle), Te = Math.sin(this.angle), xe = se - Math.round(se) + pe * ce + Te * _e, be = oe - Math.round(oe) + pe * _e + Te * ce, ve = new Float64Array(N);
          if (i.ab.mat4.translate(ve, ve, [xe > 0.5 ? xe - 1 : xe, be > 0.5 ? be - 1 : be, 0]), this.alignedProjMatrix = ve, N = i.ab.mat4.create(), i.ab.mat4.scale(N, N, [this.width / 2, -this.height / 2, 1]), i.ab.mat4.translate(N, N, [1, -1, 0]), this.labelPlaneMatrix = N, N = i.ab.mat4.create(), i.ab.mat4.scale(N, N, [1, -1, 1]), i.ab.mat4.translate(N, N, [-1, -1, 0]), i.ab.mat4.scale(N, N, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = N, this.pixelMatrix = i.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, F), this._calcFogMatrices(), this._distanceTileDataCache = {}, N = i.ab.mat4.invert(new Float64Array(16), this.pixelMatrix), !N)
            throw new Error("failed to invert matrix");
          if (this.pixelMatrixInverse = N, this.projection.name === "globe" || this.mercatorFromTransition) {
            this.globeMatrix = i.c3(this);
            const Pe = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            this.globeCenterInViewSpace = i.ab.vec3.transformMat4(Pe, Pe, T), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
          } else
            this.globeMatrix = N;
          this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t = this.cameraWorldSizeForFog, s = this.cameraPixelsPerMeter, h = this._camera.position, m = 1 / this.height / this._pixelsPerMercatorPixel, g = [t, t, s];
          i.ab.vec3.scale(g, g, m), i.ab.vec3.scale(h, h, -1), i.ab.vec3.multiply(h, h, g);
          const T = i.ab.mat4.create();
          i.ab.mat4.translate(T, T, h), i.ab.mat4.scale(T, T, g), this.mercatorFogMatrix = T, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, s, m);
        }
        _computeCameraPosition(t) {
          const s = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter, h = this._camera.forward(), m = this.point, g = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * s - t / this.worldSize * this._centerAltitude;
          return [m.x / this.worldSize - h[0] * g, m.y / this.worldSize - h[1] * g, t / this.worldSize * this._centerAltitude - h[2] * g];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
        }
        _translateCameraConstrained(t) {
          const s = this._maxCameraBoundsDistance() * Math.cos(this._pitch), h = this._camera.position[2], m = t[2];
          let g = 1;
          this.projection.wrap && (this.center = this.center.wrap()), m > 0 && (g = Math.min((s - h) / m, 1)), this._camera.position = i.ab.vec3.scaleAndAdd([], this._camera.position, t, g), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t = this._camera.position, s = this._camera.forward(), { pitch: h, bearing: m } = this._camera.getPitchBearing(), g = i.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, T = this._mercatorZfromZoom(this._maxZoom) * Math.cos(i.ai(this._maxPitch)), z = Math.max((t[2] - g) / Math.cos(h), T), R = this._zoomFromMercatorZ(z);
          i.ab.vec3.scaleAndAdd(t, t, s, z), this._pitch = i.aw(h, i.ai(this.minPitch), i.ai(this.maxPitch)), this.angle = i.bF(m, -Math.PI, Math.PI), this._setZoom(i.aw(R, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new i.aa(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(t) {
          return Math.pow(2, t) * this.tileSize;
        }
        _mercatorZfromZoom(t) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
        }
        _minimumHeightOverTerrain() {
          const t = Math.min(this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
          return this._mercatorZfromZoom(t);
        }
        _zoomFromMercatorZ(t) {
          return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t) {
          let s = 0, h = i.bY, m = 0, g = 1 / 0;
          for (; h - s > 1e-6 && h > s; ) {
            const T = s + 0.5 * (h - s), z = this.tileSize * Math.pow(2, T), R = this.getCameraToCenterDistance(this.projection, T, z), F = this.scaleZoom(R / (t * this.tileSize)), N = Math.abs(T - F);
            N < g && (g = N, m = T), T < F ? s = T : h = T;
          }
          return m;
        }
        _terrainEnabled() {
          return !(!this._elevation || !this.projection.supportsTerrain && (i.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
        }
        anyCornerOffEdge(t, s) {
          const h = Math.min(t.x, s.x), m = Math.max(t.x, s.x), g = Math.min(t.y, s.y), T = Math.max(t.y, s.y);
          if (g < this.horizonLineFromTop(!1))
            return !0;
          if (this.projection.name !== "mercator")
            return !1;
          const z = [new i.P(h, g), new i.P(m, T), new i.P(h, T), new i.P(m, g)], R = this.renderWorldCopies ? -3 : 0, F = this.renderWorldCopies ? 4 : 1;
          for (const N of z) {
            const j = this.pointRayIntersection(N);
            if (j.t < 0)
              return !0;
            const G = this.rayIntersectionCoordinate(j);
            if (G.x < R || G.y < 0 || G.x > F || G.y > 1)
              return !0;
          }
          return !1;
        }
        isHorizonVisible() {
          return this.pitch + i.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new i.P(0, 0), new i.P(this.width, this.height));
        }
        zoomDeltaToMovement(t, s) {
          const h = i.ab.vec3.length(i.ab.vec3.sub([], this._camera.position, t)), m = this._zoomFromMercatorZ(h) + s;
          return h - this._mercatorZfromZoom(m);
        }
        getCameraPoint() {
          if (this.projection.name === "globe") {
            const t = function([s, h, m], g) {
              const T = [s, h, m, 1];
              i.ab.vec4.transformMat4(T, T, g);
              const z = T[3] = Math.max(T[3], 1e-6);
              return T[0] /= z, T[1] /= z, T[2] /= z, T;
            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new i.P(t[0], t[1]);
          }
          {
            const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new i.P(0, t));
          }
        }
        getCameraToCenterDistance(t, s = this.zoom, h = this.worldSize) {
          const m = i.b$(t, s, this.width, this.height, 1024), g = t.pixelSpaceConversion(this.center.lat, h, m);
          let T = 0.5 / Math.tan(0.5 * this._fov) * this.height * g;
          return this.isOrthographic && (T = Hl(1, T, wt(this.pitch >= 15 ? 1 : this.pitch / 15))), T;
        }
        getWorldToCameraMatrix() {
          const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === "meters" ? this.pixelsPerMeter : 1);
          return this.projection.name === "globe" && i.ab.mat4.multiply(t, t, this.globeMatrix), t;
        }
        getFrustum(t) {
          return i.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === "meters");
        }
      }
      const To = (c, t) => {
        if (t > 0 && c.terrain && i.w("Cutoff is currently disabled on terrain"), t <= 0 || c.terrain)
          return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
        const s = c.transform, h = Math.max(Math.abs(s._zoom - (c.minCutoffZoom - 1)), 1), m = s.isLODDisabled(!1) ? i.ac(60, 45, s.pitch) : i.ac(30, 15, s.pitch), g = s._farZ - s._nearZ, T = t * s.height, z = ((1 - (R = m)) * s.cameraToCenterDistance + R * (s._farZ + T)) * h;
        var R;
        return { shouldRenderCutoff: m < 1, uniformValues: { u_cutoff_params: [s._nearZ, s._farZ, (z - s._nearZ) / g, (z - T - s._nearZ) / g] } };
      }, gs = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
      class Uh {
        constructor(t, s) {
          this.aabb = t, this.lastCascade = s;
        }
      }
      class Dr {
        add(t, s) {
          const h = this.receivers[t.key];
          h !== void 0 ? (h.aabb.min[0] = Math.min(h.aabb.min[0], s.min[0]), h.aabb.min[1] = Math.min(h.aabb.min[1], s.min[1]), h.aabb.min[2] = Math.min(h.aabb.min[2], s.min[2]), h.aabb.max[0] = Math.max(h.aabb.max[0], s.max[0]), h.aabb.max[1] = Math.max(h.aabb.max[1], s.max[1]), h.aabb.max[2] = Math.max(h.aabb.max[2], s.max[2])) : this.receivers[t.key] = new Uh(s, null);
        }
        clear() {
          this.receivers = {};
        }
        get(t) {
          return this.receivers[t.key];
        }
        computeRequiredCascades(t, s, h) {
          const m = i.cd.fromPoints(t.points);
          let g = 0;
          for (const T in this.receivers) {
            const z = this.receivers[T];
            if (!z || !m.intersectsAabb(z.aabb))
              continue;
            z.aabb.min = m.closestPoint(z.aabb.min), z.aabb.max = m.closestPoint(z.aabb.max);
            const R = z.aabb.getCorners();
            for (let F = 0; F < h.length; F++) {
              let N = !0;
              for (const j of R) {
                const G = [j[0] * s, j[1] * s, j[2]];
                if (i.ab.vec3.transformMat4(G, G, h[F].matrix), G[0] < -1 || G[0] > 1 || G[1] < -1 || G[1] > 1) {
                  N = !1;
                  break;
                }
              }
              if (z.lastCascade = F, g = Math.max(g, F), N)
                break;
            }
          }
          return g + 1;
        }
      }
      class So {
        constructor(t) {
          this.painter = t, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new Dr(), this._depthMode = new Wt(t.context.gl.LEQUAL, Wt.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = !1, this.useNormalOffset = !1, t.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
            this.painter.style.map.triggerRepaint();
          }), t.tp.registerParameter(gs, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), t.tp.registerParameter(gs, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), t.tp.registerParameter(gs, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), t.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: !0, label: "numCascadesToRender" });
        }
        destroy() {
          for (const t of this._cascades)
            t.texture.destroy(), t.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t, s) {
          const h = this.painter;
          if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !s || !s.properties)
            return;
          const m = s.properties.get("shadow-intensity");
          if (!s.shadowsEnabled() || m <= 0 || (this._shadowLayerCount = h.style.order.reduce((te, ee) => {
            const se = h.style._mergedLayers[ee];
            return te + (se.hasShadowPass() && !se.isHidden(t.zoom) ? 1 : 0);
          }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled))
            return;
          const g = h.context, T = gs.shadowMapResolution, z = gs.shadowMapResolution;
          if (this._cascades.length === 0 || gs.shadowMapResolution !== this._cascades[0].texture.size[0]) {
            this._cascades = [];
            for (let te = 0; te < gs.cascadeCount; ++te) {
              const ee = h._shadowMapDebug, se = g.gl, oe = g.createFramebuffer(T, z, ee, "texture"), ce = new i.T(g, { width: T, height: z, data: null }, se.DEPTH_COMPONENT16);
              if (oe.depthAttachment.set(ce.texture), ee) {
                const _e = new i.T(g, { width: T, height: z, data: null }, se.RGBA8);
                oe.colorAttachment.set(_e.texture);
              }
              this._cascades.push({ framebuffer: oe, texture: ce, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new i.bR(), scale: 0 });
            }
          }
          this.shadowDirection = Xo(s);
          let R = 0;
          if (t.elevation) {
            const te = t.elevation, ee = [1e4, -1e4];
            te.visibleDemTiles.filter((se) => se.dem).forEach((se) => {
              const oe = se.dem.tree;
              ee[0] = Math.min(ee[0], oe.minimums[0]), ee[1] = Math.max(ee[1], oe.maximums[0]);
            }), ee[0] !== 1e4 && (R = (ee[1] - ee[0]) * te.exaggeration());
          }
          const F = 1.5 * t.cameraToCenterDistance, N = 3 * F, j = new Float64Array(16);
          for (let te = 0; te < this._cascades.length; ++te) {
            const ee = this._cascades[te];
            let se = t.height / 50, oe = 1;
            gs.cascadeCount === 1 ? oe = N : te === 0 ? oe = F : (se = F, oe = N);
            const [ce, _e] = Mo(t, this.shadowDirection, se, oe, gs.shadowMapResolution, R);
            ee.scale = t.scale, ee.matrix = ce, ee.boundingSphereRadius = _e, i.ab.mat4.invert(j, ee.matrix), ee.frustum = i.bR.fromInvProjectionMatrix(j, 1, 0, !0), ee.far = oe;
          }
          const G = this._cascades.length - 1;
          this._uniformValues.u_fade_range = [0.75 * this._cascades[G].far, this._cascades[G].far], this._uniformValues.u_shadow_intensity = m, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / gs.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = gs.shadowMapResolution, this._uniformValues.u_shadowmap_0 = bs.ShadowMap0, this._uniformValues.u_shadowmap_1 = bs.ShadowMap0 + 1, this._groundShadowTiles = h.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 });
          const W = h.transform.elevation;
          for (const te of this._groundShadowTiles) {
            let ee = { min: 0, max: 0 };
            if (W) {
              const se = W.getMinMaxForTile(te);
              se && (ee = se);
            }
            this.addShadowReceiver(te.toUnwrapped(), ee.min, ee.max);
          }
        }
        get enabled() {
          return this._enabled && !this._forceDisable;
        }
        set enabled(t) {
          this._enabled = t;
        }
        drawShadowPass(t, s) {
          if (!this.enabled)
            return;
          const h = this.painter, m = h.context;
          this._numCascadesToRender = this._receivers.computeRequiredCascades(h.transform.getFrustum(0), h.transform.worldSize, this._cascades), m.viewport.set([0, 0, gs.shadowMapResolution, gs.shadowMapResolution]);
          for (let g = 0; g < this._numCascadesToRender; ++g) {
            h.currentShadowCascade = g, m.bindFramebuffer.set(this._cascades[g].framebuffer.framebuffer), m.clear({ color: i.aj.white, depth: 1 });
            for (const T of t.order) {
              const z = t._mergedLayers[T];
              if (!z.hasShadowPass() || z.isHidden(h.transform.zoom))
                continue;
              const R = t.getLayerSourceCache(z), F = R ? s[R.id] : void 0;
              (z.type === "model" || F && F.length) && h.renderLayer(h, R, z, F);
            }
          }
          h.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this.enabled)
            return;
          const t = this.painter, s = t.style, h = t.context, m = s.directionalLight, g = s.ambientLight;
          if (!m || !g)
            return;
          const T = [], z = To(t, t.longestCutoffRange);
          z.shouldRenderCutoff && T.push("RENDER_CUTOFF"), T.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && T.push("NORMAL_OFFSET");
          const R = cr(s, m, g), F = new Wt(h.gl.LEQUAL, Wt.ReadOnly, t.depthRangeFor3D);
          for (const N of this._groundShadowTiles) {
            const j = N.toUnwrapped(), G = t.isTileAffectedByFog(N), W = t.getOrCreateProgram("groundShadow", { defines: T, overrideFog: G });
            this.setupShadows(j, W), t.uploadCommonUniforms(h, W, j, null, z);
            const te = { u_matrix: t.transform.calculateProjMatrix(j), u_ground_shadow_factor: R };
            W.draw(t, h.gl.TRIANGLES, F, ci.disabled, bi.multiply, ti.disabled, te, "ground_shadow", t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? bi.unblended : bi.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t) {
          const s = this.painter.transform, h = s.calculatePosMatrix(t, s.worldSize);
          return i.ab.mat4.multiply(h, this._cascades[this.painter.currentShadowCascade].matrix, h), Float32Array.from(h);
        }
        calculateShadowPassMatrixFromMatrix(t) {
          return i.ab.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);
        }
        setupShadows(t, s, h, m = 0) {
          if (!this.enabled)
            return;
          const g = this.painter.transform, T = this.painter.context, z = T.gl, R = this._uniformValues, F = new Float64Array(16), N = g.calculatePosMatrix(t, g.worldSize);
          for (let j = 0; j < this._cascades.length; j++)
            i.ab.mat4.multiply(F, this._cascades[j].matrix, N), R[j === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(F), T.activeTexture.set(z.TEXTURE0 + bs.ShadowMap0 + j), this._cascades[j].texture.bind(z.NEAREST, z.CLAMP_TO_EDGE);
          if (this.useNormalOffset = !!h, this.useNormalOffset) {
            const j = i.cc(t.canonical), G = 2 / g.tileSize * i.ag / gs.shadowMapResolution, W = G * this._cascades[0].boundingSphereRadius, te = G * this._cascades[this._cascades.length - 1].boundingSphereRadius, ee = (h === "vector-tile" ? 1 : 3) / Math.pow(2, m - t.canonical.z - (1 - g.zoom + Math.floor(g.zoom)));
            R.u_shadow_normal_offset = [j, W * ee, te * ee], R.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            R.u_shadow_bias = [36e-5, 12e-4, 0.012];
          s.setShadowUniformValues(T, R);
        }
        setupShadowsFromMatrix(t, s, h = !1) {
          if (!this.enabled)
            return;
          const m = this.painter.context, g = m.gl, T = this._uniformValues, z = new Float64Array(16);
          for (let R = 0; R < gs.cascadeCount; R++)
            i.ab.mat4.multiply(z, this._cascades[R].matrix, t), T[R === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(z), m.activeTexture.set(g.TEXTURE0 + bs.ShadowMap0 + R), this._cascades[R].texture.bind(g.NEAREST, g.CLAMP_TO_EDGE);
          if (this.useNormalOffset = h, h) {
            const R = gs.normalOffset;
            T.u_shadow_normal_offset = [1, R, R], T.u_shadow_bias = [6e-5, 12e-4, 0.012];
          } else
            T.u_shadow_bias = [36e-5, 12e-4, 0.012];
          s.setShadowUniformValues(m, T);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t, s, h, m) {
          if (m[2] >= 0)
            return {};
          const g = function(R, F, N) {
            const j = N / (1 << R.canonical.z);
            return new i.cd([R.canonical.x * j + R.wrap * N, R.canonical.y * j + R.wrap * N, 0], [(R.canonical.x + 1) * j + R.wrap * N, (R.canonical.y + 1) * j + R.wrap * N, F]);
          }(t, s, h).getCorners(), T = s / -m[2];
          m[0] < 0 ? (i.ab.vec3.add(g[0], g[0], [m[0] * T, 0, 0]), i.ab.vec3.add(g[3], g[3], [m[0] * T, 0, 0])) : m[0] > 0 && (i.ab.vec3.add(g[1], g[1], [m[0] * T, 0, 0]), i.ab.vec3.add(g[2], g[2], [m[0] * T, 0, 0])), m[1] < 0 ? (i.ab.vec3.add(g[0], g[0], [0, m[1] * T, 0]), i.ab.vec3.add(g[1], g[1], [0, m[1] * T, 0])) : m[1] > 0 && (i.ab.vec3.add(g[2], g[2], [0, m[1] * T, 0]), i.ab.vec3.add(g[3], g[3], [0, m[1] * T, 0]));
          const z = {};
          return z.vertices = g, z.planes = [Kr(g[1], g[0], g[4]), Kr(g[2], g[1], g[5]), Kr(g[3], g[2], g[6]), Kr(g[0], g[3], g[7])], z;
        }
        addShadowReceiver(t, s, h) {
          this._receivers.add(t, i.cd.fromTileIdAndHeight(t, s, h));
        }
        getMaxCascadeForTile(t) {
          const s = this._receivers.get(t);
          return s && s.lastCascade ? s.lastCascade : 0;
        }
      }
      function Kr(c, t, s) {
        const h = i.ab.vec3.sub([], s, t), m = i.ab.vec3.sub([], c, t), g = i.ab.vec3.cross([], h, m), T = i.ab.vec3.length(g);
        return T === 0 ? [0, 0, 1, 0] : (i.ab.vec3.scale(g, g, 1 / T), [g[0], g[1], g[2], -i.ab.vec3.dot(g, t)]);
      }
      function Xo(c) {
        const t = c.properties.get("direction"), s = i.cb(t.x, t.y, t.z);
        s[2] = i.aw(s[2], 0, 75);
        const h = i.ce([s[0], s[1], s[2]]);
        return i.ab.vec3.fromValues(h.x, h.y, h.z);
      }
      function cr(c, t, s) {
        const h = t.properties.get("color-use-theme") === "none", m = t.properties.get("color"), g = t.properties.get("intensity"), T = t.properties.get("direction"), z = [T.x, T.y, T.z], R = s.properties.get("color-use-theme") === "none", F = s.properties.get("color"), N = s.properties.get("intensity"), j = Math.max(i.ab.vec3.dot([0, 0, 1], z), 0), G = [0, 0, 0];
        i.ab.vec3.scale(G, F.toRenderColor(R ? null : c.getLut(t.scope)).toArray01Linear().slice(0, 3), N);
        const W = [0, 0, 0];
        return i.ab.vec3.scale(W, m.toRenderColor(h ? null : c.getLut(s.scope)).toArray01Linear().slice(0, 3), j * g), i.cf([G[0] > 0 ? G[0] / (G[0] + W[0]) : 0, G[1] > 0 ? G[1] / (G[1] + W[1]) : 0, G[2] > 0 ? G[2] / (G[2] + W[2]) : 0]);
      }
      function Mo(c, t, s, h, m, g) {
        const T = c.zoom, z = c.scale, R = c.worldSize, F = 1 / R, N = c.aspect, j = Math.sqrt(1 + N * N) * Math.tan(0.5 * c.fovX), G = j * j, W = h - s, te = h + s;
        let ee, se;
        G > W / te ? (ee = h, se = h * j) : (ee = 0.5 * te * (1 + G), se = 0.5 * Math.sqrt(W * W + 2 * (h * h + s * s) * G + te * te * G * G));
        const oe = c.projection.pixelsPerMeter(c.center.lat, R), ce = c._camera.getCameraToWorldMercator(), _e = [0, 0, -ee * F];
        i.ab.vec3.transformMat4(_e, _e, ce);
        let pe = se * F;
        const Te = c._edgeInsets;
        if (!(Te.left === 0 && Te.top === 0 && Te.right === 0 && Te.bottom === 0 || Te.left === Te.right && Te.top === Te.bottom)) {
          const _t = c._camera.getWorldToCamera(c.worldSize, c.projection.zAxisUnit === "meters" ? oe : 1), ct = c._camera.getCameraToClipPerspective(c._fov, c.width / c.height, s, h);
          ct[8] = 2 * -c.centerOffset.x / c.width, ct[9] = 2 * c.centerOffset.y / c.height;
          const nt = new Float64Array(16);
          i.ab.mat4.mul(nt, ct, _t);
          const Lt = new Float64Array(16);
          i.ab.mat4.invert(Lt, nt);
          const xt = i.bR.fromInvProjectionMatrix(Lt, R, T, !0);
          for (const zt of xt.points) {
            const Bt = ((xe = zt)[0] /= z, xe[1] /= z, xe[2] = i.bH(xe[2], c._center.lat), xe);
            pe = Math.max(pe, i.ab.vec3.len(i.ab.vec3.subtract([], _e, Bt)));
          }
        }
        var xe;
        pe *= m / (m - 1);
        const be = Math.acos(t[2]), ve = Math.atan2(-t[0], -t[1]), Pe = new wo();
        Pe.position = _e, Pe.setPitchBearing(be, ve);
        const Oe = Pe.getWorldToCamera(R, oe), Xe = pe * R, Ze = Math.min(c._mercatorZfromZoom(17) * R * -2, -2 * Xe), ke = Pe.getCameraToClipOrthographic(-Xe, Xe, -Xe, Xe, Ze, (Xe + g * oe) / t[2]), Ne = new Float64Array(16);
        i.ab.mat4.multiply(Ne, ke, Oe);
        const st = i.ab.vec3.fromValues(Math.floor(1e6 * _e[0]) / 1e6 * R, Math.floor(1e6 * _e[1]) / 1e6 * R, 0), ht = 0.5 * m, yt = [0, 0, 0];
        i.ab.vec3.transformMat4(yt, st, Ne), i.ab.vec3.scale(yt, yt, ht);
        const je = [Math.floor(yt[0]), Math.floor(yt[1]), Math.floor(yt[2])], at = [0, 0, 0];
        i.ab.vec3.sub(at, yt, je), i.ab.vec3.scale(at, at, -1 / ht);
        const Je = new Float64Array(16);
        return i.ab.mat4.identity(Je), i.ab.mat4.translate(Je, Je, at), i.ab.mat4.multiply(Ne, Je, Ne), [Ne, Xe];
      }
      class jh extends i.E {
        constructor(t) {
          super(), this.requestManager = t, this.models = { "": {} }, this.numModelsLoading = {};
        }
        loadModel(t, s) {
          return i.aM(this.requestManager.transformRequest(s, i.R.Model).url).then((h) => {
            if (!h)
              return;
            const m = i.aN(h), g = new i.aO(t, void 0, void 0, m);
            return g.computeBoundsAndApplyParent(), g;
          }).catch((h) => {
            if (h && h.status === 404)
              return null;
            this.fire(new i.y(new Error(`Could not load model ${t} from ${s}: ${h.message}`)));
          });
        }
        load(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = Object.keys(t);
          this.numModelsLoading[s] = (this.numModelsLoading[s] || 0) + h.length;
          const m = [];
          for (const g of h)
            m.push(this.loadModel(g, t[g]));
          Promise.allSettled(m).then((g) => {
            for (let T = 0; T < g.length; T++) {
              const { status: z, value: R } = g[T];
              z === "fulfilled" && R && (this.models[s][h[T]] = { model: R, numReferences: 1 });
            }
            this.numModelsLoading[s] -= h.length, this.fire(new i.z("data", { dataType: "style" }));
          }).catch((g) => {
            this.fire(new i.y(new Error(`Could not load models: ${g.message}`)));
          });
        }
        isLoaded() {
          for (const t in this.numModelsLoading)
            if (this.numModelsLoading[t] > 0)
              return !1;
          return !0;
        }
        hasModel(t, s) {
          return !!this.getModel(t, s);
        }
        getModel(t, s) {
          return this.models[s] || (this.models[s] = {}), this.models[s][t] ? this.models[s][t].model : void 0;
        }
        addModel(t, s, h) {
          this.models[h] || (this.models[h] = {}), this.hasModel(t, h) && this.models[h][t].numReferences++, this.load({ [t]: this.requestManager.normalizeModelURL(s) }, h);
        }
        addModels(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = {};
          for (const m in t)
            this.models[s][m] = {}, h[m] = this.requestManager.normalizeModelURL(t[m]);
          this.load(h, s);
        }
        addModelsFromBucket(t, s) {
          this.models[s] || (this.models[s] = {});
          const h = {};
          for (const m of t)
            this.hasModel(m, s) ? this.models[s][m].numReferences++ : h[m] = this.requestManager.normalizeModelURL(m);
          this.load(h, s);
        }
        removeModel(t, s) {
          if (this.models[s] && this.models[s][t] && (this.models[s][t].numReferences--, this.models[s][t].numReferences === 0)) {
            const h = this.models[s][t].model;
            delete this.models[s][t], h.destroy();
          }
        }
        listModels(t) {
          return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t]);
        }
        upload(t, s) {
          this.models[s] || (this.models[s] = {});
          for (const h in this.models[s])
            this.models[s][h].model && this.models[s][h].model.upload(t.context);
        }
      }
      const Bc = new i.a5({ data: new i.a6(i.a3.colorTheme.data) }), Na = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", !1] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
      function ql(c) {
        return c = c || {}, Object.assign(c, Na);
      }
      class _l extends i.E {
        constructor(t) {
          super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, i.aP(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
        }
        destroy() {
          this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
        }
        _onLoad() {
          this._map.style.forEachFragmentStyle((t) => {
            t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new i.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId, this._scope = t.scope));
          }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (t) => (t.feature && t.feature.properties.floorplan && this.selectFloorplan(t.feature.properties.floorplan), !0) }), this._checkFloorplanVisible(!0);
        }
        _onMove() {
          this._checkFloorplanVisible(!1);
        }
        _checkFloorplanVisible(t) {
          if (!this._queryFeatureSetId || !this._map.isStyleLoaded() || this._map.transform.zoom < 13)
            return;
          this._indoorData && !function(T, z) {
            const [R, F] = T, { center: N, radius: j } = z, [G, W] = N, te = Math.abs(R - G);
            return Math.sqrt((te > 180 ? 360 - te : te) ** 2 + (F - W) ** 2) <= j;
          }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new i.z("floorplangone")));
          const s = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, h = new i.P(this._map.transform.width / 2, this._map.transform.height / 2), m = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], g = this._map.queryRenderedFeatures(t ? m : h, s);
          g.length > 0 && (this._selectedFloorplan && g[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = g[0], this._floorplanSelected(!1)));
        }
        _floorplanSelected(t) {
          this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(g) {
            const [[T, z], [R, F]] = g, N = (R - T + 360) % 360, j = N > 180 ? 360 - N : N;
            return { center: [(T + j / 2 + 360) % 360, (z + F) / 2], radius: Math.sqrt(j ** 2 + (F - z) ** 2) / 2 };
          }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
          const s = this._floorplanStates[this._indoorData.id].selectedBuilding, h = this._floorplanStates[this._indoorData.id].selectedLevel;
          let m;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel)
            for (const g of this._indoorData.levels)
              g.id === this._selectedLevel.id && (m = g.id);
          if (this.fire(new i.z("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: m })), s) {
            const g = this._indoorData.buildings.find((T) => T.id === s);
            this._buildingSelected(g, !1);
          } else
            this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
          if (h) {
            const g = this._indoorData.levels.find((T) => T.id === h);
            this._updateLevels(g, t);
          } else
            t && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
        }
        _buildingSelected(t, s) {
          s && t && t.extent && this._map.fitBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;
          const h = this._indoorData.levels.filter((m) => t.levels.includes(m.id));
          this.fire(new i.z("buildingselected", { buildingId: t.id, levels: h }));
        }
        _levelSelected(t) {
          if (t === "overview")
            this._updateLevels(void 0, !0);
          else {
            const s = this._indoorData.levels.find((h) => h.id === t);
            this._updateLevels(s, !0);
          }
          this.fire(new i.z("levelselected", { levelId: t === "overview" ? void 0 : t }));
        }
        _updateLevels(t, s) {
          if (!t)
            return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (s && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
          function h(F) {
            const N = F.indexOf("/floor/");
            if (N === -1)
              return F;
            const j = N + 7, G = F.indexOf("/", j);
            return G === -1 ? F.slice(j) : F.slice(j, G);
          }
          this._selectedLevel = t, this._floorplanStates[this._indoorData.id].selectedLevel = t ? t.id : void 0;
          const m = [], g = {}, T = {}, z = {}, R = {};
          for (const F of this._indoorData.levels)
            if (m.push(F.id), g[F.id] = F.height, T[F.id] = F.base, t) {
              if (this.mergeFloors) {
                const N = h(t.id), j = h(F.id);
                z[F.id] = j === N ? "true" : "false";
              } else
                z[F.id] = F.id === t.id ? "true" : "false";
              R[F.id] = F.base < t.base ? "true" : "false";
            } else
              R[F.id] = !0;
          if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", m]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", g]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", T]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", z]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", R]), t && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!t.isUnderground), s && t.extent)) {
            const F = this._map.cameraForBounds(t.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), N = this._map.getZoom(), j = F.zoom ? Math.abs(N - F.zoom) : 0;
            this._map.fitBounds(t.extent, j >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: N });
          }
        }
        selectFloorplan(t) {
          const s = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, h = [new i.P(0, 0), new i.P(this._map.transform.width, this._map.transform.height)], m = this._map.queryRenderedFeatures(h, s);
          if (m.length > 0) {
            for (const g of m)
              if (JSON.parse(g.properties["indoor-data"]).floorplanIDs.includes(t)) {
                this._selectedFloorplan = g, this._floorplanSelected(!0);
                break;
              }
          }
        }
        selectBuilding(t) {
          const s = this._indoorData.buildings.find((h) => h.id === t);
          this._buildingSelected(s, !0);
        }
        selectLevel(t) {
          this._levelSelected(t);
        }
      }
      function ma(c) {
        if (!c.metadata || !c.metadata.content_area)
          return;
        const t = i.q.devicePixelRatio, { left: s, top: h, width: m, height: g } = c.metadata.content_area, T = s * t, z = h * t;
        return [T, z, T + m * t, z + g * t];
      }
      function _a(c) {
        if (c)
          return c.map(([t, s]) => [t * i.q.devicePixelRatio, s * i.q.devicePixelRatio]);
      }
      const Eo = (c, t) => Ae(c, t && t.filter((s) => s.identifier !== "source.canvas")), Gh = i.ay(Oi, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport"]), Ju = i.ay(Oi, ["setCenter", "setZoom", "setBearing", "setPitch"]), Va = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), Nc = { version: 8, layers: [], sources: {} }, Vc = { duration: 300, delay: 0 };
      class hr extends i.E {
        constructor(t, s = {}) {
          super(), this.map = t, this.scope = s.scope || "", this.globalId = null, this.fragments = [], this.importDepth = s.importDepth || 0, this.importsCache = s.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = s.resolvedImports || /* @__PURE__ */ new Set(), this.transition = i.l({}, Vc), this._buildingIndex = new Ul(this), this.crossTileSymbolIndex = new Gl(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = s.styleChanges || new Zr(), this.dispatcher = s.dispatcher ? s.dispatcher : new i.D(i.ci(), this), s.imageManager ? this.imageManager = s.imageManager : (this.imageManager = new ir(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = s.glyphManager ? s.glyphManager : new i.cj(t._requestManager, s.localFontFamily ? i.ck.all : s.localIdeographFontFamily ? i.ck.ideographs : i.ck.none, s.localFontFamily || s.localIdeographFontFamily), s.modelManager ? this.modelManager = s.modelManager : (this.modelManager = new jh(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = s.configOptions ? s.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = s.configDependentLayers ? s.configDependentLayers : /* @__PURE__ */ new Set(), this._config = s.config, this._styleColorTheme = { lut: null, lutLoading: !1, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: s.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = s.initialConfig, this.dispatcher.broadcast("setReferrer", i.cl());
          const h = this;
          this._rtlTextPluginCallback = hr.registerForPluginStateChange((m) => {
            h.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: m.pluginStatus, pluginURL: m.pluginURL }, (g, T) => {
              if (i.cm(g), T && T.every((z) => z))
                for (const z in h._sourceCaches) {
                  const R = h._sourceCaches[z], F = R.getSource().type;
                  F !== "vector" && F !== "geojson" || R.reload();
                }
            });
          }), this.on("data", (m) => {
            if (m.dataType !== "source" || m.sourceDataType !== "metadata")
              return;
            const g = this.getOwnSource(m.sourceId);
            if (g && g.vectorLayerIds)
              for (const T in this._layers) {
                const z = this._layers[T];
                z.source === g.id && this._validateLayer(z);
              }
          });
        }
        load(t) {
          return t ? (typeof t == "string" ? this.loadURL(t) : this.loadJSON(t), this) : this;
        }
        _getGlobalId(t) {
          if (!t)
            return null;
          if (typeof t == "string") {
            if (i.f(t))
              return t;
            const s = i.cn(t);
            if (!s.startsWith("http"))
              try {
                return new URL(s, location.href).toString();
              } catch {
                return s;
              }
            return s;
          }
          return `json://${i.co(JSON.stringify(t))}`;
        }
        _diffStyle(t, s, h) {
          this.globalId = this._getGlobalId(t);
          const m = (g, T) => {
            try {
              T(null, this.setState(g, h));
            } catch (z) {
              T(z, !1);
            }
          };
          if (typeof t == "string") {
            const g = this.map._requestManager.normalizeStyleURL(t), T = this.map._requestManager.transformRequest(g, i.R.Style);
            i.n(T, (z, R) => {
              z ? this.fire(new i.y(z)) : R && m(R, s);
            });
          } else
            typeof t == "object" && m(t, s);
        }
        loadURL(t, s = {}) {
          this.fire(new i.z("dataloading", { dataType: "style" }));
          const h = typeof s.validate == "boolean" ? s.validate : !i.f(t);
          this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, s.accessToken), this.resolvedImports.add(t);
          const m = this.importsCache.get(t);
          if (m)
            return this._load(m, h);
          const g = this.map._requestManager.transformRequest(t, i.R.Style);
          this._request = i.n(g, (T, z) => {
            if (this._request = null, T)
              this.fire(new i.y(T));
            else if (z)
              return this.importsCache.set(t, z), this._load(z, h);
          });
        }
        loadJSON(t, s = {}) {
          this.fire(new i.z("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t), this._request = i.q.frame(() => {
            this._request = null, this._load(t, s.validate !== !1);
          });
        }
        loadEmpty() {
          this.fire(new i.z("dataloading", { dataType: "style" })), this._load(Nc, !1);
        }
        _loadImports(t, s, h) {
          if (this.importDepth >= 4)
            return i.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const m = [];
          for (const g of t) {
            const T = this._createFragmentStyle(g), z = new Promise((N) => {
              T.once("style.import.load", N), T.once("error", N);
            }).then(() => this.mergeAll());
            if (m.push(z), this.resolvedImports.has(g.url)) {
              T.loadEmpty();
              continue;
            }
            const R = g.data || this.importsCache.get(g.url);
            R ? (T.loadJSON(R, { validate: s }), this._isInternalStyle(R) && (T.globalId = null)) : g.url ? T.loadURL(g.url, { validate: s }) : T.loadEmpty();
            const F = { style: T, id: g.id, config: g.config };
            if (h) {
              const N = this.fragments.findIndex(({ id: j }) => j === h);
              this.fragments = this.fragments.slice(0, N).concat(F).concat(this.fragments.slice(N));
            } else
              this.fragments.push(F);
          }
          return Promise.allSettled(m);
        }
        getImportGlobalIds(t = this, s = /* @__PURE__ */ new Set()) {
          for (const h of t.fragments)
            h.style.globalId && s.add(h.style.globalId), this.getImportGlobalIds(h.style, s);
          return [...s.values()];
        }
        _createFragmentStyle(t) {
          const s = this.scope ? i.aC(t.id, this.scope) : t.id;
          let h;
          const m = this._initialConfig && this._initialConfig[s];
          (t.config || m) && (h = i.l({}, t.config, m));
          const g = new hr(this.map, { scope: s, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: h, configOptions: this.options, colorThemeOverride: t["color-theme"], configDependentLayers: this._configDependentLayers });
          return g.setEventedParent(this.map, { style: g }), g;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
        }
        _isInternalStyle(t) {
          return this.isRootStyle() && (t.fragment || !!t.schema && t.fragment !== !1);
        }
        _load(t, s) {
          const h = t.indoor ? ql(t.schema) : t.schema;
          if (this._isInternalStyle(t)) {
            const T = i.l({}, Nc, { imports: [{ id: "basemap", data: t, url: "" }] });
            return void this._load(T, s);
          }
          if (this.updateConfig(this._config, h), s && Eo(this, Zi(t)))
            return;
          this._loaded = !0, this.stylesheet = i.cp(t);
          const m = () => {
            for (const F in t.sources)
              this.addSource(F, t.sources[F], { validate: !1, isInitialLoad: !0 });
            t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 })), this.glyphManager.setURL(t.glyphs, this.scope);
            const T = cl(this.stylesheet.layers);
            if (this._order = T.map((F) => F.id), this.stylesheet.light && i.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights)
              if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === "flat") {
                const F = this.stylesheet.lights[0];
                this.light = new Qe(F.properties, F.id);
              } else
                this.setLights(this.stylesheet.lights);
            this.light || (this.light = new Qe(this.stylesheet.light)), this._layers = {};
            for (const F of T) {
              const N = i.cu(F, this.scope, this._styleColorTheme.lut, this.options);
              N.configDependencies.size !== 0 && this._configDependentLayers.add(N.fqid), N.setEventedParent(this, { layer: { id: N.id } }), this._layers[N.id] = N;
              const j = this.getOwnLayerSourceCache(N), G = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              j && N.canCastShadows() && G && (j.castsShadows = !0);
            }
            this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
            const z = this.stylesheet.terrain;
            z && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(z, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new i.z("data", { dataType: "style" }));
            const R = this.isRootStyle();
            t.imports ? this._loadImports(t.imports, s).then(() => {
              this._reloadImports(), this.fire(new i.z(R ? "style.load" : "style.import.load"));
            }) : (this._reloadImports(), this.fire(new i.z(R ? "style.load" : "style.import.load")));
          };
          this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
          const g = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (g) {
            const T = this._evaluateColorThemeData(g);
            this._loadColorTheme(T).then(() => {
              m();
            }).catch((z) => {
              i.w(`Couldn't load color theme from the stylesheet: ${z}`), m();
            });
          } else
            this._styleColorTheme.lut = null, m();
        }
        isRootStyle() {
          return this.importDepth === 0;
        }
        mergeAll() {
          let t, s, h, m, g, T, z, R, F, N;
          const j = {};
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((G) => {
            if (G.stylesheet) {
              if (G.light != null && (t = G.light), G.stylesheet.lights)
                for (const W of G.stylesheet.lights)
                  W.type === "ambient" && G.ambientLight != null && (s = G.ambientLight), W.type === "directional" && G.directionalLight != null && (h = G.directionalLight);
              m = this._prioritizeTerrain(m, G.terrain, G.stylesheet.terrain), G.stylesheet.fog && G.fog != null && (g = G.fog), G.stylesheet.snow && G.snow != null && (T = G.snow), G.stylesheet.rain && G.rain != null && (z = G.rain), G.stylesheet.camera != null && (N = G.stylesheet.camera), G.stylesheet.projection != null && (R = G.stylesheet.projection), G.stylesheet.transition != null && (F = G.stylesheet.transition), j[G.scope] = G._styleColorTheme;
            }
          }), this.light = t, this.ambientLight = s, this.directionalLight = h, this.fog = g, this.snow = T, this.rain = z, this._styleColorThemeForScope = j, m === null ? delete this.terrain : this.terrain = m, this.camera = N || { "camera-projection": "perspective" }, this.projection = R || { name: "mercator" }, this.transition = i.l({}, Vc, F), this.mergeSources(), this.mergeLayers();
        }
        forEachFragmentStyle(t) {
          const s = (h) => {
            for (const m of h.fragments)
              s(m.style);
            t(h);
          };
          s(this);
        }
        _prioritizeTerrain(t, s, h) {
          const m = t && t.drapeRenderMode === 0;
          return h === null ? s && s.drapeRenderMode === 0 ? s : m ? t : null : s != null && (!t || m || s && s.drapeRenderMode === 1) ? s : t;
        }
        mergeTerrain() {
          let t;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((s) => {
            t = this._prioritizeTerrain(t, s.terrain, s.stylesheet.terrain);
          }), t === null ? delete this.terrain : this.terrain = t;
        }
        mergeProjection() {
          let t;
          this.forEachFragmentStyle((s) => {
            s.stylesheet.projection != null && (t = s.stylesheet.projection);
          }), this.projection = t || { name: "mercator" };
        }
        mergeSources() {
          const t = {}, s = {}, h = {};
          this.forEachFragmentStyle((m) => {
            for (const g in m._sourceCaches) {
              const T = i.aC(g, m.scope);
              t[T] = m._sourceCaches[g];
            }
            for (const g in m._otherSourceCaches) {
              const T = i.aC(g, m.scope);
              s[T] = m._otherSourceCaches[g];
            }
            for (const g in m._symbolSourceCaches) {
              const T = i.aC(g, m.scope);
              h[T] = m._symbolSourceCaches[g];
            }
          }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = s, this._mergedSymbolSourceCaches = h;
        }
        mergeLayers() {
          const t = {}, s = [], h = {};
          this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((g) => {
            for (const T of g._order) {
              const z = g._layers[T];
              if (z.type === "slot") {
                const R = i.cq(T);
                if (t[R])
                  continue;
                t[R] = [];
              }
              z.slot && t[z.slot] ? t[z.slot].push(z) : s.push(z);
            }
          }), this._mergedOrder = [];
          const m = (g = []) => {
            for (const T of g)
              if (T.type === "slot") {
                const z = i.cq(T.id);
                t[z] && m(t[z]), this._mergedSlots.push(z);
              } else {
                const z = i.aC(T.id, T.scope);
                this._mergedOrder.push(z), h[z] = T, T.is3D() && (this._has3DLayers = !0), T.type === "circle" && (this._hasCircleLayers = !0), T.type === "symbol" && (this._hasSymbolLayers = !0), T.type === "clip" && (this._clipLayerPresent = !0);
              }
          };
          m(s), this._mergedOrder.sort((g, T) => {
            const z = h[g], R = h[T];
            return z.hasInitialOcclusionOpacityProperties ? R.is3D() ? 1 : 0 : z.is3D() && R.hasInitialOcclusionOpacityProperties ? -1 : 0;
          }), this._mergedLayers = h, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t) {
          return this.stylesheet.camera = i.l({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;
        }
        _evaluateColorThemeData(t) {
          return t.data ? function(s, h, m) {
            const g = i.l({}, h);
            for (const z of Object.keys(i.a3.colorTheme))
              g[z] === void 0 && (g[z] = i.a3.colorTheme[z].default);
            const T = new i.a4(Bc, s, new Map(m));
            return T.setTransitionOrValue(g, m), T.untransitioned().possiblyEvaluate(new i.a8(0));
          }(this.scope, t, this.options).get("data") : null;
        }
        _loadColorTheme(t) {
          this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
          const s = this._styleColorTheme.lutLoadingCorrelationID;
          return new Promise((h, m) => {
            const g = "data:image/png;base64,";
            if (!t || t.length === 0)
              return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void h();
            let T = t;
            T.startsWith(g) || (T = g + T);
            const z = "mapbox-reserved-lut", R = new Image();
            R.src = T, R.onerror = () => {
              this._styleColorTheme.lutLoading = !1, m(new Error("Failed to load image data"));
            }, R.onload = () => {
              if (this._styleColorTheme.lutLoadingCorrelationID !== s)
                return void h();
              this._styleColorTheme.lutLoading = !1;
              const { width: F, height: N, data: j } = i.q.getImageData(R);
              if (N > 32)
                return void m(new Error("The height of the image must be less than or equal to 32 pixels."));
              if (F !== N * N)
                return void m(new Error("The width of the image must be equal to the height squared."));
              this.getImage(z) && this.removeImage(z), this.addImage(z, { data: new i.r({ width: F, height: N }, j), pixelRatio: 1, sdf: !1, usvg: !1, version: 0 });
              const G = this.imageManager.getImage(z, this.scope);
              G ? (this._styleColorTheme.lut = { image: G.data, data: t }, h()) : m(new Error("Missing LUT image."));
            };
          });
        }
        getLut(t) {
          const s = this._styleColorThemeForScope[t];
          return s ? s.lut : null;
        }
        setProjection(t) {
          t ? this.stylesheet.projection = t : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t) {
          this._spriteRequest = function(s, h, m) {
            let g, T, z;
            const R = i.q.devicePixelRatio > 1 ? "@2x" : "";
            let F = i.n(h.transformRequest(h.normalizeSpriteURL(s, R, ".json"), i.R.SpriteJSON), (G, W) => {
              F = null, z || (z = G, g = W, j());
            }), N = i.o(h.transformRequest(h.normalizeSpriteURL(s, R, ".png"), i.R.SpriteImage), (G, W) => {
              N = null, z || (z = G, T = W, j());
            });
            function j() {
              if (z)
                m(z);
              else if (g && T) {
                const G = i.q.getImageData(T), W = {};
                for (const te in g) {
                  const { width: ee, height: se, x: oe, y: ce, sdf: _e, pixelRatio: pe, stretchX: Te, stretchY: xe, content: be } = g[te], ve = new i.r({ width: ee, height: se });
                  i.r.copy(G, ve, { x: oe, y: ce }, { x: 0, y: 0 }, { width: ee, height: se }, null), W[te] = { data: ve, pixelRatio: pe, sdf: _e, stretchX: Te, stretchY: xe, content: be, usvg: !1 };
                }
                m(null, W);
              }
            }
            return { cancel() {
              F && (F.cancel(), F = null), N && (N.cancel(), N = null);
            } };
          }(t, this.map._requestManager, (s, h) => {
            if (this._spriteRequest = null, s)
              this.fire(new i.y(s));
            else if (h)
              for (const m in h)
                this.imageManager.addImage(m, this.scope, h[m]);
            this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
          });
        }
        _loadIconset(t) {
          if (!i.f(t) && this.map._spriteFormat !== "icon_set" || this.map._spriteFormat === "raster")
            return void this._loadSprite(t);
          const s = this.map._spriteFormat === "auto";
          var h, m;
          this._spriteRequest = (m = (g, T) => {
            if (this._spriteRequest = null, g)
              s ? this._loadSprite(t) : this.fire(new i.y(g));
            else if (T)
              for (const z in T)
                this.imageManager.addImage(z, this.scope, T[z]);
            this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: !0 }), this.fire(new i.z("data", { dataType: "style" }));
          }, i.bi((h = this.map._requestManager).transformRequest(h.normalizeIconsetURL(t), i.R.Iconset), (g, T) => {
            if (g)
              return void m(g);
            const z = {}, R = i.cg(new i.bh(T));
            for (const F of R.icons) {
              const N = { version: 1, pixelRatio: i.q.devicePixelRatio, content: ma(F), stretchX: F.metadata ? _a(F.metadata.stretch_x_areas) : void 0, stretchY: F.metadata ? _a(F.metadata.stretch_y_areas) : void 0, sdf: !1, usvg: !0, icon: F };
              z[F.name] = N;
            }
            m(null, z);
          }));
        }
        _validateLayer(t) {
          const s = this.getOwnSource(t.source);
          if (!s)
            return;
          const h = t.sourceLayer;
          h && (s.type === "geojson" || s.vectorLayerIds && s.vectorLayerIds.indexOf(h) === -1) && this.fire(new i.y(new Error(`Source layer "${h}" does not exist on source "${s.id}" as specified by style layer "${t.id}"`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length)
            return !1;
          for (const t in this._sourceCaches)
            if (!this._sourceCaches[t].loaded())
              return !1;
          if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded() || this._styleColorTheme.lutLoading)
            return !1;
          for (const { style: t } of this.fragments)
            if (!t.loaded())
              return !1;
          return !0;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((t, s) => {
              const h = this.fragments[s];
              return h && h.style && (t.data = h.style.serialize()), t;
            });
        }
        _serializeSources() {
          const t = {};
          for (const s in this._sourceCaches) {
            const h = this._sourceCaches[s].getSource();
            t[h.id] || (t[h.id] = h.serialize());
          }
          return t;
        }
        _serializeLayers(t) {
          const s = [];
          for (const h of t) {
            const m = this._layers[h];
            m && m.type !== "custom" && s.push(m.serialize());
          }
          return s;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasSnowTransition() {
          return !!this.snow && this.snow.hasTransition();
        }
        hasRainTransition() {
          return !!this.rain && this.rain.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions() || this.hasFogTransition() || this.hasSnowTransition() || this.hasRainTransition())
            return !0;
          for (const t in this._sourceCaches)
            if (this._sourceCaches[t].hasTransition())
              return !0;
          for (const t in this._layers)
            if (this._layers[t].hasTransition())
              return !0;
          return !1;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        _getOrder(t) {
          return t ? this.order : this._mergedOrder;
        }
        isLayerDraped(t) {
          return !!this.terrain && t.isDraped(this.getLayerSourceCache(t));
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        _checkLayer(t) {
          const s = this.getOwnLayer(t);
          if (s)
            return s;
          this.fire(new i.y(new Error(`The layer '${t}' does not exist in the map's style.`)));
        }
        _checkSource(t) {
          const s = this.getOwnSource(t);
          if (s)
            return s;
          this.fire(new i.y(new Error(`The source '${t}' does not exist in the map's style.`)));
        }
        precompilePrograms(t, s) {
          const h = this.map.painter;
          if (h)
            for (let m = t.minzoom || 0; m < (t.maxzoom || 25.5); m++) {
              const g = t.getProgramIds();
              if (g)
                for (const T of g) {
                  const z = t.getDefaultProgramParams(T, s.zoom, this._styleColorTheme.lut);
                  z && (h.style = this, this.fog && (h._fogVisible = !0, z.overrideFog = !0, h.getOrCreateProgram(T, z)), h._fogVisible = !1, z.overrideFog = !1, h.getOrCreateProgram(T, z), (this.stylesheet.terrain || this.stylesheet.projection && this.stylesheet.projection.name === "globe") && (z.overrideRtt = !0, h.getOrCreateProgram(T, z)));
                }
            }
        }
        update(t) {
          if (!this._loaded)
            return;
          this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
          const s = this.calculateLightsBrightness();
          t.brightness = s || 0, s !== this._brightness && (this._brightness = s, this.dispatcher.broadcast("setBrightness", s));
          const h = this._changes.isDirty();
          let m = !1;
          if (this._changes.isDirty()) {
            const T = this._changes.getLayerUpdatesByScope();
            for (const z in T) {
              const { updatedIds: R, removedIds: F } = T[z];
              (R || F) && (this._updateWorkerLayers(z, R, F), m = !0);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();
          }
          const g = {};
          for (const T in this._mergedSourceCaches) {
            const z = this._mergedSourceCaches[T];
            g[T] = z.used, z.used = !1, z.tileCoverLift = 0;
          }
          for (const T of this._mergedOrder) {
            const z = this._mergedLayers[T];
            if (z.recalculate(t, this._availableImages), !z.isHidden(t.zoom)) {
              const R = this.getLayerSourceCache(z);
              R && (R.used = !0, R.tileCoverLift = Math.max(R.tileCoverLift, z.tileCoverLift()));
            }
            !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
              this.precompilePrograms(z, t);
            }) : this.precompilePrograms(z, t));
          }
          this._shouldPrecompile && (this._precompileDone = !0), this.terrain && m && this.mergeLayers();
          for (const T in g) {
            const z = this._mergedSourceCaches[T];
            g[T] !== z.used && z.getSource().fire(new i.z("data", { sourceDataType: "visibility", dataType: "source", sourceId: z.getSource().id }));
          }
          this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), h && this.fire(new i.z("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t = this._changes.getUpdatedImages();
          if (t.length) {
            for (const s in this._sourceCaches)
              this._sourceCaches[s].reloadTilesForDependencies(["icons", "patterns"], t);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(t, s, h) {
          const m = this.getFragmentStyle(t);
          m && this.dispatcher.broadcast("updateLayers", { layers: s ? m._serializeLayers(s) : [], scope: t, removedIds: h || [], options: m.options });
        }
        setState(t, s) {
          if (this._checkLoaded(), Eo(this, Zi(t)))
            return !1;
          (t = i.cp(t)).layers = cl(t.layers);
          const h = function(T, z) {
            if (!T)
              return [{ command: Oi.setStyle, args: [z] }];
            let R = [];
            try {
              if (!i.bn(T.version, z.version))
                return [{ command: Oi.setStyle, args: [z] }];
              if (i.bn(T.center, z.center) || R.push({ command: Oi.setCenter, args: [z.center] }), i.bn(T.zoom, z.zoom) || R.push({ command: Oi.setZoom, args: [z.zoom] }), i.bn(T.bearing, z.bearing) || R.push({ command: Oi.setBearing, args: [z.bearing] }), i.bn(T.pitch, z.pitch) || R.push({ command: Oi.setPitch, args: [z.pitch] }), i.bn(T.sprite, z.sprite) || R.push({ command: Oi.setSprite, args: [z.sprite] }), i.bn(T.glyphs, z.glyphs) || R.push({ command: Oi.setGlyphs, args: [z.glyphs] }), i.bn(T.imports, z.imports) || function(W = [], te = [], ee) {
                te = te || [];
                const se = (W = W || []).map(Fi), oe = te.map(Fi), ce = W.reduce(Li, {}), _e = te.reduce(Li, {}), pe = se.slice();
                let Te, xe, be, ve;
                for (Te = 0, xe = 0; Te < se.length; Te++)
                  be = se[Te], _e.hasOwnProperty(be) ? xe++ : (ee.push({ command: Oi.removeImport, args: [be] }), pe.splice(pe.indexOf(be, xe), 1));
                for (Te = 0, xe = 0; Te < oe.length; Te++)
                  be = oe[oe.length - 1 - Te], pe[pe.length - 1 - Te] !== be && (ce.hasOwnProperty(be) ? (ee.push({ command: Oi.removeImport, args: [be] }), pe.splice(pe.lastIndexOf(be, pe.length - xe), 1)) : xe++, ve = pe[pe.length - Te], ee.push({ command: Oi.addImport, args: [_e[be], ve] }), pe.splice(pe.length - Te, 0, be));
                for (const Pe of te) {
                  const Oe = ce[Pe.id];
                  Oe && !i.bn(Oe, Pe) && ee.push({ command: Oi.updateImport, args: [Pe.id, Pe] });
                }
              }(T.imports, z.imports, R), i.bn(T.transition, z.transition) || R.push({ command: Oi.setTransition, args: [z.transition] }), i.bn(T.light, z.light) || R.push({ command: Oi.setLight, args: [z.light] }), i.bn(T.fog, z.fog) || R.push({ command: Oi.setFog, args: [z.fog] }), i.bn(T.snow, z.snow) || R.push({ command: Oi.setSnow, args: [z.snow] }), i.bn(T.rain, z.rain) || R.push({ command: Oi.setRain, args: [z.rain] }), i.bn(T.projection, z.projection) || R.push({ command: Oi.setProjection, args: [z.projection] }), i.bn(T.lights, z.lights) || R.push({ command: Oi.setLights, args: [z.lights] }), i.bn(T.camera, z.camera) || R.push({ command: Oi.setCamera, args: [z.camera] }), !i.bn(T["color-theme"], z["color-theme"]))
                return [{ command: Oi.setStyle, args: [z] }];
              const F = {}, N = [];
              (function(W, te, ee, se) {
                let oe;
                for (oe in te = te || {}, W = W || {})
                  W.hasOwnProperty(oe) && (te.hasOwnProperty(oe) || ns(oe, ee, se));
                for (oe in te) {
                  if (!te.hasOwnProperty(oe))
                    continue;
                  const ce = te[oe];
                  W.hasOwnProperty(oe) ? i.bn(W[oe], ce) || (W[oe].type === "geojson" && ce.type === "geojson" && ca(W, te, oe) ? ee.push({ command: Oi.setGeoJSONSourceData, args: [oe, ce.data] }) : Cn(oe, te, ee, se)) : Bi(oe, te, ee);
                }
              })(T.sources, z.sources, N, F);
              const j = [];
              T.layers && T.layers.forEach((W) => {
                W.source && F[W.source] ? R.push({ command: Oi.removeLayer, args: [W.id] }) : j.push(W);
              });
              let G = T.terrain;
              G && F[G.source] && (R.push({ command: Oi.setTerrain, args: [void 0] }), G = void 0), R = R.concat(N), i.bn(G, z.terrain) || R.push({ command: Oi.setTerrain, args: [z.terrain] }), function(W, te, ee) {
                te = te || [];
                const se = (W = W || []).map(Fi), oe = te.map(Fi), ce = W.reduce(Li, {}), _e = te.reduce(Li, {}), pe = se.slice(), Te = /* @__PURE__ */ Object.create(null);
                let xe, be, ve, Pe, Oe, Xe, Ze;
                for (xe = 0, be = 0; xe < se.length; xe++)
                  ve = se[xe], _e.hasOwnProperty(ve) ? be++ : (ee.push({ command: Oi.removeLayer, args: [ve] }), pe.splice(pe.indexOf(ve, be), 1));
                for (xe = 0, be = 0; xe < oe.length; xe++)
                  ve = oe[oe.length - 1 - xe], pe[pe.length - 1 - xe] !== ve && (ce.hasOwnProperty(ve) ? (ee.push({ command: Oi.removeLayer, args: [ve] }), pe.splice(pe.lastIndexOf(ve, pe.length - be), 1)) : be++, Xe = pe[pe.length - xe], ee.push({ command: Oi.addLayer, args: [_e[ve], Xe] }), pe.splice(pe.length - xe, 0, ve), Te[ve] = !0);
                for (xe = 0; xe < oe.length; xe++)
                  if (ve = oe[xe], Pe = ce[ve], Oe = _e[ve], !Te[ve] && !i.bn(Pe, Oe))
                    if (i.bn(Pe.source, Oe.source) && i.bn(Pe["source-layer"], Oe["source-layer"]) && i.bn(Pe.type, Oe.type)) {
                      for (Ze in Ot(Pe.layout, Oe.layout, ee, ve, null, Oi.setLayoutProperty), Ot(Pe.paint, Oe.paint, ee, ve, null, Oi.setPaintProperty), i.bn(Pe.slot, Oe.slot) || ee.push({ command: Oi.setSlot, args: [ve, Oe.slot] }), i.bn(Pe.filter, Oe.filter) || ee.push({ command: Oi.setFilter, args: [ve, Oe.filter] }), i.bn(Pe.minzoom, Oe.minzoom) && i.bn(Pe.maxzoom, Oe.maxzoom) || ee.push({ command: Oi.setLayerZoomRange, args: [ve, Oe.minzoom, Oe.maxzoom] }), Pe)
                        Pe.hasOwnProperty(Ze) && Ze !== "layout" && Ze !== "paint" && Ze !== "filter" && Ze !== "metadata" && Ze !== "minzoom" && Ze !== "maxzoom" && Ze !== "slot" && (Ze.indexOf("paint.") === 0 ? Ot(Pe[Ze], Oe[Ze], ee, ve, Ze.slice(6), Oi.setPaintProperty) : i.bn(Pe[Ze], Oe[Ze]) || ee.push({ command: Oi.setLayerProperty, args: [ve, Ze, Oe[Ze]] }));
                      for (Ze in Oe)
                        Oe.hasOwnProperty(Ze) && !Pe.hasOwnProperty(Ze) && Ze !== "layout" && Ze !== "paint" && Ze !== "filter" && Ze !== "metadata" && Ze !== "minzoom" && Ze !== "maxzoom" && Ze !== "slot" && (Ze.indexOf("paint.") === 0 ? Ot(Pe[Ze], Oe[Ze], ee, ve, Ze.slice(6), Oi.setPaintProperty) : i.bn(Pe[Ze], Oe[Ze]) || ee.push({ command: Oi.setLayerProperty, args: [ve, Ze, Oe[Ze]] }));
                    } else
                      ee.push({ command: Oi.removeLayer, args: [ve] }), Xe = pe[pe.lastIndexOf(ve) + 1], ee.push({ command: Oi.addLayer, args: [Oe, Xe] });
              }(j, z.layers, R);
            } catch (F) {
              console.warn("Unable to compute style diff:", F), R = [{ command: Oi.setStyle, args: [z] }];
            }
            return R;
          }(this.serialize(), t).filter((T) => !(T.command in Ju));
          if (h.length === 0)
            return !1;
          const m = h.filter((T) => !(T.command in Gh));
          if (m.length > 0)
            throw new Error(`Unimplemented: ${m.map((T) => T.command).join(", ")}.`);
          const g = [];
          return h.forEach((T) => {
            g.push(this[T.command].apply(this, T.args));
          }), s && Promise.all(g).then(s), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), !0;
        }
        addImage(t, s) {
          return this.getImage(t) ? this.fire(new i.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t, this.scope, s), this._afterImageUpdated(t), this);
        }
        updateImage(t, s, h = !1) {
          this.imageManager.updateImage(t, this.scope, s), h && this._afterImageUpdated(t);
        }
        getImage(t) {
          return this.imageManager.getImage(t, this.scope);
        }
        removeImage(t) {
          return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new i.y(new Error("No image with this name exists.")));
        }
        _afterImageUpdated(t) {
          this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages }), this.fire(new i.z("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(t, s, h = {}) {
          return this._checkLoaded(), this._validate(Be, `models.${t}`, s, null, h) || (this.modelManager.addModel(t, s, this.scope), this._changes.setDirty()), this;
        }
        hasModel(t) {
          return this.modelManager.hasModel(t, this.scope);
        }
        removeModel(t) {
          return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new i.y(new Error("No model with this ID exists.")));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t, s, h = {}) {
          if (this._checkLoaded(), this.getOwnSource(t) !== void 0)
            throw new Error(`There is already a source with ID "${t}".`);
          if (!s.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(s.type) >= 0 && this._validate(Jn, `sources.${t}`, s, null, h))
            return;
          this.map && this.map._collectResourceTiming && (s.collectResourceTiming = !0);
          const m = jo(t, s, this.dispatcher, this);
          m.scope = this.scope, m.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(m.id), source: m.serialize(), sourceId: m.id }));
          const g = (T) => {
            const z = (T ? "symbol:" : "other:") + m.id, R = i.aC(z, this.scope), F = this._sourceCaches[z] = new sr(R, m, T);
            (T ? this._symbolSourceCaches : this._otherSourceCaches)[m.id] = F, F.onAdd(this.map);
          };
          g(!1), s.type !== "vector" && s.type !== "geojson" || g(!0), m.onAdd && m.onAdd(this.map), h.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t) {
          this._checkLoaded();
          const s = this.getOwnSource(t);
          if (!s)
            throw new Error("There is no source with this ID");
          for (const m in this._layers)
            if (this._layers[m].source === t)
              return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while layer "${m}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t)
            return this.fire(new i.y(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
          const h = this.getOwnSourceCaches(t);
          for (const m of h) {
            const g = i.cq(m.id);
            delete this._sourceCaches[g], this._changes.discardSourceCacheUpdate(m.id), m.fire(new i.z("data", { sourceDataType: "metadata", dataType: "source", sourceId: m.getSource().id })), m.setEventedParent(null), m.clearTiles();
          }
          return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), s.setEventedParent(null), s.onRemove && s.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(t, s) {
          this._checkLoaded(), this.getOwnSource(t).setData(s), this._changes.setDirty();
        }
        getOwnSource(t) {
          const s = this.getOwnSourceCache(t);
          return s && s.getSource();
        }
        getOwnSources() {
          const t = [];
          for (const s in this._otherSourceCaches) {
            const h = this.getOwnSourceCache(s);
            h && t.push(h.getSource());
          }
          return t;
        }
        areTilesLoaded() {
          const t = this._mergedSourceCaches;
          for (const s in t) {
            const h = t[s]._tiles;
            for (const m in h) {
              const g = h[m];
              if (g.state !== "loaded" && g.state !== "errored")
                return !1;
            }
          }
          return !0;
        }
        setLights(t) {
          if (this._checkLoaded(), !t)
            return delete this.ambientLight, void delete this.directionalLight;
          const s = this._getTransitionParameters();
          for (const m of t) {
            if (this._validate(Ls, "lights", m))
              return;
            switch (m.type) {
              case "ambient":
                if (this.ambientLight) {
                  const g = this.ambientLight;
                  g.set(m), g.updateTransitions(s);
                } else
                  this.ambientLight = new ps(m, $i || ($i = new i.a5({ color: new i.a6(i.a3.properties_light_ambient.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_ambient.intensity) })), this.scope, this.options);
                break;
              case "directional":
                if (this.directionalLight) {
                  const g = this.directionalLight;
                  g.set(m), g.updateTransitions(s);
                } else
                  this.directionalLight = new ps(m, Hi || (Hi = new i.a5({ direction: new i.ak(i.a3.properties_light_directional.direction), color: new i.a6(i.a3.properties_light_directional.color), "color-use-theme": new i.a6({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new i.a6(i.a3.properties_light_directional.intensity), "cast-shadows": new i.a6(i.a3.properties_light_directional["cast-shadows"]), "shadow-quality": new i.a6(i.a3.properties_light_directional["shadow-quality"]), "shadow-intensity": new i.a6(i.a3.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
            }
          }
          const h = new i.a8(this.z || 0, s);
          this.ambientLight && this.ambientLight.recalculate(h), this.directionalLight && this.directionalLight.recalculate(h), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
        }
        calculateLightsBrightness() {
          const t = this.directionalLight, s = this.ambientLight;
          if (!t || !s)
            return;
          const h = (G) => 0.2126 * (G[0] <= 0.03928 ? G[0] / 12.92 : Math.pow((G[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (G[1] <= 0.03928 ? G[1] / 12.92 : Math.pow((G[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (G[2] <= 0.03928 ? G[2] / 12.92 : Math.pow((G[2] + 0.055) / 1.055, 2.4)), m = t.properties.get("color").toRenderColor(null).toArray01(), g = t.properties.get("intensity"), T = t.properties.get("direction"), z = 1 - i.cb(T.x, T.y, T.z)[2] / 90, R = h(m) * g * z, F = s.properties.get("color").toRenderColor(null).toArray01(), N = s.properties.get("intensity"), j = h(F) * N;
          return Number(((R + j) / 2).toFixed(6));
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights())
            return null;
          const t = [];
          return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t) {
          if (!t)
            return this;
          if (i.cr(t)) {
            const s = i.cs(t), h = this.fragments.find(({ id: g }) => g === s);
            if (!h)
              throw new Error(`Style import '${t}' not found`);
            const m = i.cq(t);
            return h.style.getFragmentStyle(m);
          }
          {
            const s = this.fragments.find(({ id: h }) => h === t);
            if (!s)
              throw new Error(`Style import '${t}' not found`);
            return s.style;
          }
        }
        setFeaturesetSelectors(t) {
          if (!t)
            return;
          const s = {}, h = (m, g = "") => `${m}::${g}`;
          this.featuresetSelectors = {};
          for (const m in t) {
            const g = this.featuresetSelectors[m] = [];
            for (const T of t[m].selectors) {
              if (T.featureNamespace) {
                const R = this.getOwnLayer(T.layer);
                if (!R) {
                  i.w(`Layer is undefined for selector: ${T.layer}`);
                  continue;
                }
                const F = h(R.source, R.sourceLayer);
                if (F in s && s[F] !== T.featureNamespace) {
                  i.w(`"featureNamespace ${T.featureNamespace} of featureset ${m}'s selector is not associated to the same source, skip this selector`);
                  continue;
                }
                s[F] = T.featureNamespace;
              }
              let z;
              if (T.properties)
                for (const R in T.properties) {
                  const F = i.U(T.properties[R]);
                  F.result === "success" && (z = z || {}, z[R] = F.value);
                }
              g.push({ layerId: T.layer, namespace: T.featureNamespace, properties: z });
            }
          }
        }
        getFeaturesetDescriptors(t) {
          const s = this.getFragmentStyle(t);
          if (!s || !s.stylesheet.featuresets)
            return [];
          const h = [];
          for (const m in s.stylesheet.featuresets)
            h.push({ featuresetId: m, importId: s.scope ? s.scope : void 0 });
          return h;
        }
        getFeaturesetLayers(t, s) {
          const h = this.getFragmentStyle(s), m = h.stylesheet.featuresets;
          if (!m || !m[t])
            return this.fire(new i.y(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];
          const g = [];
          for (const T of m[t].selectors) {
            const z = h.getOwnLayer(T.layer);
            z && g.push(z);
          }
          return g;
        }
        getConfigProperty(t, s) {
          const h = this.getFragmentStyle(t);
          if (!h)
            return null;
          const m = i.aC(s, h.scope), g = h.options.get(m), T = g ? g.value || g.default : null;
          return T ? T.serialize() : null;
        }
        setConfigProperty(t, s, h) {
          const m = this.getFragmentStyle(t);
          if (!m)
            return;
          const g = m.stylesheet.indoor ? ql(m.stylesheet.schema) : m.stylesheet.schema;
          if (!g || !g[s])
            return;
          const T = i.U(h);
          if (T.result !== "success")
            return void Eo(this, T.value);
          const z = T.value.expression, R = i.aC(s, m.scope), F = m.options.get(R);
          if (!F)
            return;
          let N;
          const { minValue: j, maxValue: G, stepValue: W, type: te, values: ee } = g[s], se = i.U(g[s].default);
          se.result === "success" && (N = se.value.expression), N ? (this.options.set(R, { ...F, value: z, default: N, minValue: j, maxValue: G, stepValue: W, type: te, values: ee }), this.updateConfigDependencies(s)) : this.fire(new i.y(new Error(`No schema defined for the config option "${s}" in the "${t}" fragment.`)));
        }
        getConfig(t) {
          const s = this.getFragmentStyle(t);
          if (!s)
            return null;
          const h = s.stylesheet.schema;
          if (!h)
            return null;
          const m = {};
          for (const g in h) {
            const T = i.aC(g, s.scope), z = s.options.get(T), R = z ? z.value || z.default : null;
            m[g] = R ? R.serialize() : null;
          }
          return m;
        }
        setConfig(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h.updateConfig(s, h.stylesheet.schema), this.updateConfigDependencies());
        }
        getSchema(t) {
          const s = this.getFragmentStyle(t);
          return s ? s.stylesheet.schema : null;
        }
        setSchema(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h.stylesheet.schema = s, h.updateConfig(h._config, s), this.updateConfigDependencies());
        }
        updateConfig(t, s) {
          if (this._config = t, t || s)
            if (s)
              for (const h in s) {
                let m, g;
                const T = i.U(s[h].default);
                if (T.result === "success" && (m = T.value.expression), t && t[h] !== void 0) {
                  const G = i.U(t[h]);
                  G.result === "success" && (g = G.value.expression);
                }
                const { minValue: z, maxValue: R, stepValue: F, type: N, values: j } = s[h];
                if (m) {
                  const G = i.aC(h, this.scope);
                  this.options.set(G, { default: m, value: g, minValue: z, maxValue: R, stepValue: F, type: N, values: j });
                } else
                  this.fire(new i.y(new Error(`No schema defined for config option "${h}".`)));
              }
            else
              this.fire(new i.y(new Error("Attempting to set config for a style without schema.")));
        }
        updateConfigDependencies(t) {
          for (const s of this._configDependentLayers) {
            const h = this.getLayer(s);
            if (h) {
              if (t && !h.configDependencies.has(t))
                continue;
              h.possiblyEvaluateVisibility(), this._updateLayer(h);
            }
          }
          this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((s) => {
            const h = s._styleColorTheme.colorThemeOverride ? s._styleColorTheme.colorThemeOverride : s._styleColorTheme.colorTheme;
            if (h) {
              const m = s._evaluateColorThemeData(h);
              (!s._styleColorTheme.lut && m !== "" || s._styleColorTheme.lut && m !== s._styleColorTheme.lut.data) && s.setColorTheme(h);
            }
          }), this._changes.setDirty();
        }
        addLayer(t, s, h = {}) {
          this._checkLoaded();
          const m = t.id;
          if (this._layers[m])
            return void this.fire(new i.y(new Error(`Layer with id "${m}" already exists on this map`)));
          let g;
          if (t.type === "custom") {
            if (Eo(this, i.ct(t)))
              return;
            g = i.cu(t, this.scope, this._styleColorTheme.lut, this.options);
          } else {
            if (typeof t.source == "object" && (this.addSource(m, t.source), t = i.cp(t), t = i.l(t, { source: m })), this._validate(le, `layers.${m}`, t, { arrayIndex: -1 }, h))
              return;
            g = i.cu(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(g), g.setEventedParent(this, { layer: { id: m } });
          }
          g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid);
          let T = this._order.length;
          if (s) {
            const N = this._order.indexOf(s);
            if (N === -1)
              return void this.fire(new i.y(new Error(`Layer with id "${s}" does not exist on this map.`)));
            g.slot === this._layers[s].slot ? T = N : i.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(T, 0, m), this._layerOrderChanged = !0, this._layers[m] = g;
          const z = this.getOwnLayerSourceCache(g), R = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          z && g.canCastShadows() && R && (z.castsShadows = !0);
          const F = this._changes.getRemovedLayer(g);
          if (F && g.source && z && g.type !== "custom") {
            this._changes.discardLayerRemoval(g);
            const N = i.aC(g.source, g.scope);
            F.type !== g.type ? this._changes.updateSourceCache(N, "clear") : (this._changes.updateSourceCache(N, "reload"), z.pause());
          }
          this._updateLayer(g), g.onAdd && g.onAdd(this.map), g.scope = this.scope, this.mergeLayers();
        }
        moveLayer(t, s) {
          this._checkLoaded();
          const h = this._checkLayer(t);
          if (!h || t === s)
            return;
          const m = this._order.indexOf(t);
          this._order.splice(m, 1);
          let g = this._order.length;
          if (s) {
            const T = this._order.indexOf(s);
            if (T === -1)
              return void this.fire(new i.y(new Error(`Layer with id "${s}" does not exist on this map.`)));
            h.slot === this._layers[s].slot ? g = T : i.w(`Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(g, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
        }
        removeLayer(t) {
          this._checkLoaded();
          const s = this._checkLayer(t);
          if (!s)
            return;
          s.setEventedParent(null);
          const h = this._order.indexOf(t);
          this._order.splice(h, 1), delete this._layers[t], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(s.fqid), this._changes.removeLayer(s);
          const m = this.getOwnLayerSourceCache(s);
          if (m && m.castsShadows) {
            let g = !1;
            for (const T in this._layers)
              if (this._layers[T].source === s.source && this._layers[T].canCastShadows()) {
                g = !0;
                break;
              }
            m.castsShadows = g;
          }
          s.onRemove && s.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(t) {
          return this._layers[t];
        }
        hasLayer(t) {
          return t in this._mergedLayers;
        }
        hasLayerType(t) {
          for (const s in this._layers)
            if (this._layers[s].type === t)
              return !0;
          return !1;
        }
        setLayerZoomRange(t, s, h) {
          this._checkLoaded();
          const m = this._checkLayer(t);
          m && (m.minzoom === s && m.maxzoom === h || (s != null && (m.minzoom = s), h != null && (m.maxzoom = h), this._updateLayer(m)));
        }
        getSlots() {
          return this._checkLoaded(), this._mergedSlots;
        }
        setSlot(t, s) {
          this._checkLoaded();
          const h = this._checkLayer(t);
          h && h.slot !== s && (h.slot = s, this._updateLayer(h));
        }
        setFilter(t, s, h = {}) {
          this._checkLoaded();
          const m = this._checkLayer(t);
          if (m && !i.bn(m.filter, s))
            return s == null ? (m.filter = void 0, void this._updateLayer(m)) : void (this._validate(ge, `layers.${m.id}.filter`, s, { layerType: m.type }, h) || (m.filter = i.cp(s), this._updateLayer(m)));
        }
        getFilter(t) {
          const s = this._checkLayer(t);
          if (s)
            return i.cp(s.filter);
        }
        setLayoutProperty(t, s, h, m = {}) {
          this._checkLoaded();
          const g = this._checkLayer(t);
          if (g && !i.bn(g.getLayoutProperty(s), h)) {
            if (h != null && (!m || m.validate !== !1) && Eo(g, Ce.call(Zi, { key: `layers.${t}.layout.${s}`, layerType: g.type, objectKey: s, value: h, styleSpec: i.a3, style: { glyphs: !0, sprite: !0 } })))
              return;
            g.setLayoutProperty(s, h), g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid), this._updateLayer(g);
          }
        }
        getLayoutProperty(t, s) {
          const h = this._checkLayer(t);
          if (h)
            return h.getLayoutProperty(s);
        }
        setPaintProperty(t, s, h, m = {}) {
          this._checkLoaded();
          const g = this._checkLayer(t);
          if (!g || i.bn(g.getPaintProperty(s), h) || h != null && (!m || m.validate !== !1) && Eo(g, Le.call(Zi, { key: `layers.${t}.paint.${s}`, layerType: g.type, objectKey: s, value: h, styleSpec: i.a3 })))
            return;
          const T = g.setPaintProperty(s, h);
          g.configDependencies.size !== 0 && this._configDependentLayers.add(g.fqid), T && this._updateLayer(g), this._changes.updatePaintProperties(g);
        }
        getPaintProperty(t, s) {
          const h = this._checkLayer(t);
          if (h)
            return h.getPaintProperty(s);
        }
        setFeatureState(t, s) {
          if (this._checkLoaded(), "target" in t) {
            if ("featuresetId" in t.target) {
              const { featuresetId: R, importId: F } = t.target, N = this.getFragmentStyle(F), j = N.getFeaturesetLayers(R);
              for (const { source: G, sourceLayer: W } of j)
                N.setFeatureState({ id: t.id, source: G, sourceLayer: W }, s);
            } else if ("layerId" in t.target) {
              const { layerId: R } = t.target, F = this.getLayer(R);
              this.setFeatureState({ id: t.id, source: F.source, sourceLayer: F.sourceLayer }, s);
            }
            return;
          }
          const h = t.source, m = t.sourceLayer, g = this._checkSource(h);
          if (!g)
            return;
          const T = g.type;
          if (T === "geojson" && m)
            return void this.fire(new i.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if (T === "vector" && !m)
            return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided.")));
          const z = this.getOwnSourceCaches(h);
          for (const R of z)
            R.setFeatureState(m, t.id, s);
        }
        removeFeatureState(t, s) {
          if (this._checkLoaded(), "target" in t) {
            if ("featuresetId" in t.target) {
              const { featuresetId: R, importId: F } = t.target, N = this.getFragmentStyle(F), j = N.getFeaturesetLayers(R);
              for (const { source: G, sourceLayer: W } of j)
                N.removeFeatureState({ id: t.id, source: G, sourceLayer: W }, s);
            } else if ("layerId" in t.target) {
              const { layerId: R } = t.target, F = this.getLayer(R);
              this.removeFeatureState({ id: t.id, source: F.source, sourceLayer: F.sourceLayer }, s);
            }
            return;
          }
          const h = t.source, m = this._checkSource(h);
          if (!m)
            return;
          const g = m.type, T = g === "vector" ? t.sourceLayer : void 0;
          if (g === "vector" && !T)
            return void this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (s && typeof t.id != "string" && typeof t.id != "number")
            return void this.fire(new i.y(new Error("A feature id is required to remove its specific state property.")));
          const z = this.getOwnSourceCaches(h);
          for (const R of z)
            R.removeFeatureState(T, t.id, s);
        }
        getFeatureState(t) {
          if (this._checkLoaded(), "target" in t) {
            let g;
            if ("featuresetId" in t.target) {
              const { featuresetId: T, importId: z } = t.target, R = this.getFragmentStyle(z), F = R.getFeaturesetLayers(T);
              for (const { source: N, sourceLayer: j } of F) {
                const G = R.getFeatureState({ id: t.id, source: N, sourceLayer: j });
                if (G && !g)
                  g = G;
                else if (!i.bn(g, G))
                  return void this.fire(new i.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
              }
            } else if ("layerId" in t.target) {
              const { layerId: T } = t.target, z = this.getLayer(T);
              g = this.getFeatureState({ id: t.id, source: z.source, sourceLayer: z.sourceLayer });
            }
            return g;
          }
          const s = t.source, h = t.sourceLayer, m = this._checkSource(s);
          if (m) {
            if (m.type !== "vector" || h)
              return t.id === void 0 && this.fire(new i.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(s)[0].getFeatureState(h, t.id);
            this.fire(new i.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
        }
        setTransition(t) {
          return this.stylesheet.transition = i.l({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;
        }
        getTransition() {
          return i.l({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t = this.getTerrain(), s = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
          return i.cv({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: s, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (h) => h !== void 0);
        }
        _updateFilteredLayers(t) {
          for (const s of Object.values(this._mergedLayers))
            t(s) && this._updateLayer(s);
        }
        _updateLayer(t) {
          this._changes.updateLayer(t);
          const s = this.getLayerSourceCache(t), h = i.aC(t.source, t.scope), m = this._changes.getUpdatedSourceCaches();
          t.source && !m[h] && s && s.getSource().type !== "raster" && (this._changes.updateSourceCache(h, "reload"), s.pause()), t.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(t) {
          const s = (z) => this._mergedLayers[z].is3D(), h = this.order, m = {}, g = [];
          for (let z = h.length - 1; z >= 0; z--) {
            const R = h[z];
            if (s(R)) {
              m[R] = z;
              for (const F of t) {
                const N = F[R];
                if (N)
                  for (const j of N)
                    g.push(j);
              }
            }
          }
          g.sort((z, R) => R.intersectionZ - z.intersectionZ);
          const T = [];
          for (let z = h.length - 1; z >= 0; z--) {
            const R = h[z];
            if (s(R))
              for (let F = g.length - 1; F >= 0; F--) {
                const N = g[F].feature;
                if (N.layer && m[N.layer.id] < z)
                  break;
                T.push(N), g.pop();
              }
            else
              for (const F of t) {
                const N = F[R];
                if (N)
                  for (const j of N)
                    T.push(j.feature);
              }
          }
          return T;
        }
        queryRenderedFeatures(t, s, h) {
          let m;
          s && !Array.isArray(s) && s.filter && (this._validate(ge, "queryRenderedFeatures.filter", s.filter, null, s), m = i.aZ(s.filter));
          const g = {}, T = (N) => {
            if (Va.has(N.type))
              return;
            const j = this.getOwnLayerSourceCache(N), G = g[j.id] = g[j.id] || { sourceCache: j, layers: {}, has3DLayers: !1 };
            N.is3D() && (G.has3DLayers = !0), G.layers[N.fqid] = G.layers[N.fqid] || { styleLayer: N, targets: [] }, G.layers[N.fqid].targets.push({ filter: m });
          };
          if (s && s.layers) {
            if (!Array.isArray(s.layers))
              return this.fire(new i.y(new Error("parameters.layers must be an Array."))), [];
            for (const N of s.layers) {
              const j = this._layers[N];
              if (!j)
                return this.fire(new i.y(new Error(`The layer '${N}' does not exist in the map's style and cannot be queried for features.`))), [];
              T(j);
            }
          } else
            for (const N in this._layers)
              T(this._layers[N]);
          const z = this._queryRenderedFeatures(t, g, h), R = this._flattenAndSortRenderedFeatures(z), F = [];
          for (const N of R)
            i.cs(N.layer.id) === this.scope && F.push(N);
          return F;
        }
        queryRenderedFeatureset(t, s, h) {
          let m;
          s && !Array.isArray(s) && s.filter && (this._validate(ge, "queryRenderedFeatures.filter", s.filter, null, s), m = i.aZ(s.filter));
          const g = "mock", T = [];
          if (s && s.target)
            T.push({ ...s, targetId: g, filter: m });
          else {
            const F = this.getFeaturesetDescriptors();
            for (const N of F)
              T.push({ targetId: g, filter: m, target: N });
            for (const { style: N } of this.fragments) {
              const j = N.getFeaturesetDescriptors();
              for (const G of j)
                T.push({ targetId: g, filter: m, target: G });
            }
          }
          const z = this.queryRenderedTargets(t, T, h), R = [];
          for (const F of z)
            for (const N of F.variants[g])
              R.push(new i.cw(F, N));
          return R;
        }
        queryRenderedTargets(t, s, h) {
          const m = {}, g = (z, R, F, N) => {
            const j = m[R.id] = m[R.id] || { sourceCache: R, layers: {}, has3DLayers: !1 };
            j.layers[z.fqid] = j.layers[z.fqid] || { styleLayer: z, targets: [] }, z.is3D() && (j.has3DLayers = !0), j.layers[z.fqid].targets.push(N ? { ...F, namespace: N.namespace, properties: N.properties } : F);
          };
          for (const z of s)
            if ("featuresetId" in z.target) {
              const { featuresetId: R, importId: F } = z.target, N = this.getFragmentStyle(F), j = N.featuresetSelectors[R];
              if (!j) {
                this.fire(new i.y(new Error(`The featureset '${R}' does not exist in the map's style and cannot be queried for features.`)));
                continue;
              }
              for (const G of j) {
                const W = N.getOwnLayer(G.layerId);
                W && !Va.has(W.type) && g(W, N.getOwnLayerSourceCache(W), z, G);
              }
            } else if ("layerId" in z.target) {
              const { layerId: R } = z.target, F = this.getLayer(R);
              if (!F || Va.has(F.type))
                continue;
              g(F, this.getLayerSourceCache(F), z);
            }
          const T = this._queryRenderedFeatures(t, m, h);
          return this._flattenAndSortRenderedFeatures(T);
        }
        _queryRenderedFeatures(t, s, h) {
          const m = [], g = !!this.map._showQueryGeometry, T = vs.createFromScreenPoints(t, h);
          for (const z in s) {
            const R = oa(T, s[z], this._availableImages, h, g);
            Object.keys(R).length && m.push(R);
          }
          if (this.placement)
            for (const z in s) {
              if (!s[z].sourceCache._onlySymbols)
                continue;
              const R = La(T.screenGeometry, s[z], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
              Object.keys(R).length && m.push(R);
            }
          return m;
        }
        querySourceFeatures(t, s) {
          const h = s && s.filter;
          h && this._validate(ge, "querySourceFeatures.filter", h, null, s);
          let m = [];
          const g = this.getOwnSourceCaches(t);
          for (const T of g)
            m = m.concat(Vi(T, s));
          return m;
        }
        addSourceType(t, s, h) {
          return hr.getSourceType(t) ? h(new Error(`A source type called "${t}" already exists.`)) : (hr.setSourceType(t, s), s.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t, url: s.workerSourceURL }, h) : h(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(t, s, h = {}) {
          this._checkLoaded();
          const m = this.light.getLight();
          let g = !1;
          for (const z in t)
            if (!i.bn(t[z], m[z])) {
              g = !0;
              break;
            }
          if (!g)
            return;
          const T = this._getTransitionParameters();
          this.light.setLight(t, s, h), this.light.updateTransitions(T);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: "", exaggeration: 0 }, 0);
        }
        checkCanvasFingerprintNoise() {
          this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = i.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && i.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
        }
        setTerrain(t, s = 1) {
          if (this._checkLoaded(), !t)
            return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), s === 0 && delete this.terrain, t === null ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
          this.checkCanvasFingerprintNoise();
          let h = t;
          const m = t.source == null;
          if (s === 1) {
            if (this.disableElevatedTerrain)
              return;
            if (typeof h.source == "object") {
              const z = "terrain-dem-src";
              this.addSource(z, h.source), h = i.cp(h), h = i.l(h, { source: z });
            }
            const g = i.l({}, h), T = {};
            if (this.terrain && m) {
              g.source = this.terrain.get().source;
              const z = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              z && (T.style = z.serialize());
            }
            if (this._validate(zs, "terrain", g, T))
              return;
          }
          if (!this.terrain || this.terrain.scope !== this.scope && !m || this.terrain && s !== this.terrain.drapeRenderMode) {
            if (!h)
              return;
            this._createTerrain(h, s), this.fire(new i.z("data", { dataType: "style" }));
          } else {
            const g = this.terrain, T = g.get();
            for (const z of Object.keys(i.a3.terrain))
              !h.hasOwnProperty(z) && i.a3.terrain[z].default && (h[z] = i.a3.terrain[z].default);
            for (const z in t)
              if (!i.bn(t[z], T[z])) {
                g.set(t, this.options), this.stylesheet.terrain = t;
                const R = this._getTransitionParameters({ duration: 0 });
                g.updateTransitions(R), this.fire(new i.z("data", { dataType: "style" }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
        }
        _createFog(t) {
          const s = this.fog = new Ki(t, this.map.transform, this.scope, this.options);
          this.stylesheet.fog = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _createSnow(t) {
          const s = this.snow = new Xn(t, this.map.transform, this.scope, this.options);
          this.stylesheet.snow = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _createRain(t) {
          const s = this.rain = new Gs(t, this.map.transform, this.scope, this.options);
          this.stylesheet.rain = s.get();
          const h = this._getTransitionParameters({ duration: 0 });
          s.updateTransitions(h);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 && this.map._requestDomTask(() => {
            for (const t of this.map._markers)
              t._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t) {
          if (this._checkLoaded(), !t)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
          if (this.fog) {
            const s = this.fog;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.fog = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createFog(t);
          this._markersNeedUpdate = !0;
        }
        getSnow() {
          return this.snow ? this.snow.get() : null;
        }
        setSnow(t) {
          if (this._checkLoaded(), !t)
            return delete this.snow, void delete this.stylesheet.snow;
          if (this.snow) {
            const s = this.snow;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.snow = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createSnow(t);
          this._markersNeedUpdate = !0;
        }
        getRain() {
          return this.rain ? this.rain.get() : null;
        }
        setRain(t) {
          if (this._checkLoaded(), !t)
            return delete this.rain, void delete this.stylesheet.rain;
          if (this.rain) {
            const s = this.rain;
            if (!i.bn(s.get(), t)) {
              s.set(t, this.options), this.stylesheet.rain = s.get();
              const h = this._getTransitionParameters({ duration: 0 });
              s.updateTransitions(h);
            }
          } else
            this._createRain(t);
          this._markersNeedUpdate = !0;
        }
        _reloadColorTheme() {
          const t = () => {
            for (const m in this._layers)
              this._layers[m].lut = this._styleColorTheme.lut;
            for (const m in this._sourceCaches)
              this._sourceCaches[m].clearTiles();
          }, s = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
          if (!s)
            return this._styleColorTheme.lut = null, void t();
          const h = this._evaluateColorThemeData(s);
          this._loadColorTheme(h).then(() => {
            this.fire(new i.z("colorthemeset")), t();
          }).catch((m) => {
            i.w(`Couldn't set color theme: ${m}`);
          });
        }
        setColorTheme(t) {
          this._checkLoaded(), this._styleColorTheme.colorThemeOverride && i.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();
        }
        setImportColorTheme(t, s) {
          const h = this.getFragmentStyle(t);
          h && (h._styleColorTheme.colorThemeOverride = s, h._reloadColorTheme());
        }
        _getTransitionParameters(t) {
          return { now: i.q.now(), transition: i.l(this.transition, t) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain)
            return;
          const t = [], s = [];
          for (const h of this._mergedOrder)
            this.isLayerDraped(this._mergedLayers[h]) ? t.push(h) : s.push(h);
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...s);
        }
        _createTerrain(t, s) {
          const h = this.terrain = new it(t, s, this.scope, this.options);
          s === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const m = this._getTransitionParameters({ duration: 0 });
          h.updateTransitions(m);
        }
        _force3DLayerUpdate() {
          for (const t in this._layers) {
            const s = this._layers[t];
            s.type === "fill-extrusion" && this._updateLayer(s);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const t in this._layers) {
            const s = this._layers[t];
            s.type === "symbol" && this._updateLayer(s);
          }
        }
        _validate(t, s, h, m, g = {}) {
          if (g && g.validate === !1)
            return !1;
          const T = i.l({}, this.serialize());
          return Eo(this, t.call(Zi, i.l({ key: s, style: T, value: h, styleSpec: i.a3 }, m)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), i.cx.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const t in this._mergedLayers)
            this._mergedLayers[t].setEventedParent(null);
          for (const t in this._mergedSourceCaches)
            this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(t) {
          const s = this.getSourceCaches(t);
          for (const h of s)
            h.clearTiles();
        }
        clearSources() {
          for (const t in this._mergedSourceCaches)
            this._mergedSourceCaches[t].clearTiles();
        }
        reloadSource(t) {
          const s = this.getSourceCaches(t);
          for (const h of s)
            h.resume(), h.reload();
        }
        reloadSources() {
          for (const t of this.getSources())
            t.reload && t.reload();
        }
        updateSources(t) {
          let s;
          this.directionalLight && (s = Xo(this.directionalLight));
          for (const h in this._mergedSourceCaches)
            this._mergedSourceCaches[h].update(t, void 0, void 0, s);
        }
        _generateCollisionBoxes() {
          for (const t in this._sourceCaches) {
            const s = this._sourceCaches[t];
            s.resume(), s.reload();
          }
        }
        _updatePlacement(t, s, h, m, g, T, z = !1) {
          let R = !1, F = !1;
          const N = {}, j = {};
          for (const G of this._mergedOrder) {
            const W = this._mergedLayers[G];
            if (W.type !== "symbol")
              continue;
            const te = i.aC(W.source, W.scope);
            let ee = N[te];
            if (!ee) {
              const oe = this.getLayerSourceCache(W);
              if (!oe)
                continue;
              const ce = oe.getRenderableIds(!0).map((_e) => oe.getTileByID(_e));
              j[te] = ce.slice(), ee = N[te] = ce.sort((_e, pe) => pe.tileID.overscaledZ - _e.tileID.overscaledZ || (_e.tileID.isLessThan(pe.tileID) ? -1 : 1));
            }
            const se = this.crossTileSymbolIndex.addLayer(W, ee, s.center.lng, s.projection);
            R = R || se;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), z = z || this._layerOrderChanged || m === 0, this._layerOrderChanged && this.fire(new i.z("neworder")), (z || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(i.q.now(), s.zoom)) && (this.pauseablePlacement = new Wo(s, this._mergedOrder, z, h, m, g, this.placement, this.fog && s.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, N, j, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(i.q.now()), F = !0), R && this.pauseablePlacement.placement.setStale()), F || R) {
            this._buildingIndex.onNewFrame(s.zoom);
            for (let G = 0; G < this._mergedOrder.length; G++) {
              const W = this._mergedLayers[this._mergedOrder[G]];
              if (W.type !== "symbol")
                continue;
              const te = this.isLayerClipped(W);
              this.placement.updateLayerOpacities(W, N[i.aC(W.source, W.scope)], G, te ? T : null);
            }
          }
          return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(i.q.now()) };
        }
        _releaseSymbolFadeTiles() {
          for (const t in this._sourceCaches)
            this._sourceCaches[t].releaseSymbolFadeTiles();
        }
        addImport(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports = this.stylesheet.imports || [];
          if (h.findIndex(({ id: g }) => g === t.id) !== -1)
            return void this.fire(new i.y(new Error(`Import with id '${t.id}' already exists in the map's style.`)));
          if (!s)
            return h.push(t), this._loadImports([t], !0);
          const m = h.findIndex(({ id: g }) => g === s);
          return m === -1 && this.fire(new i.y(new Error(`Import with id "${s}" does not exist on this map.`))), this.stylesheet.imports = h.slice(0, m).concat(t).concat(h.slice(m)), this._loadImports([t], !0, s);
        }
        updateImport(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports || [], m = this.getImportIndex(t);
          return m === -1 ? this : typeof s == "string" ? (this.setImportUrl(t, s), this) : (s.url && s.url !== h[m].url && this.setImportUrl(t, s.url), i.bn(s.config, h[m].config) || this.setImportConfig(t, s.config), i.bn(s.data, h[m].data) || this.setImportData(t, s.data), this);
        }
        moveImport(t, s) {
          this._checkLoaded();
          let h = this.stylesheet.imports || [];
          const m = this.getImportIndex(t);
          if (m === -1)
            return this;
          const g = this.getImportIndex(s);
          if (g === -1)
            return this;
          const T = h[m], z = this.fragments[m];
          return h = h.filter(({ id: R }) => R !== t), this.fragments = this.fragments.filter(({ id: R }) => R !== t), this.stylesheet.imports = h.slice(0, g).concat(T).concat(h.slice(g)), this.fragments = this.fragments.slice(0, g).concat(z).concat(this.fragments.slice(g)), this.mergeLayers(), this;
        }
        setImportUrl(t, s) {
          this._checkLoaded();
          const h = this.stylesheet.imports || [], m = this.getImportIndex(t);
          if (m === -1)
            return this;
          h[m].url = s;
          const g = this.fragments[m];
          return g.style = this._createFragmentStyle(h[m]), g.style.on("style.import.load", () => this.mergeAll()), g.style.loadURL(s), this;
        }
        setImportData(t, s) {
          this._checkLoaded();
          const h = this.getImportIndex(t), m = this.stylesheet.imports || [];
          return h === -1 ? this : s ? (this.fragments[h].style.setState(s), this._reloadImports(), this) : (delete m[h].data, this.setImportUrl(t, m[h].url));
        }
        setImportConfig(t, s) {
          this._checkLoaded();
          const h = this.getImportIndex(t), m = this.stylesheet.imports || [];
          if (h === -1)
            return this;
          s ? m[h].config = s : delete m[h].config;
          const g = this.fragments[h], T = g.style.stylesheet && g.style.stylesheet.schema;
          return g.config = s, g.style.updateConfig(s, T), this.updateConfigDependencies(), this;
        }
        removeImport(t) {
          this._checkLoaded();
          const s = this.stylesheet.imports || [], h = this.getImportIndex(t);
          h !== -1 && (s.splice(h, 1), this.fragments[h].style._remove(), this.fragments.splice(h, 1), this._reloadImports());
        }
        getImportIndex(t) {
          const s = (this.stylesheet.imports || []).findIndex((h) => h.id === t);
          return s === -1 && this.fire(new i.y(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), s;
        }
        getLayer(t) {
          return this._mergedLayers[t];
        }
        getSources() {
          const t = [];
          for (const s in this._mergedOtherSourceCaches) {
            const h = this._mergedOtherSourceCaches[s];
            h && t.push(h.getSource());
          }
          return t;
        }
        getSource(t, s) {
          const h = this.getSourceCache(t, s);
          return h && h.getSource();
        }
        getLayerSource(t) {
          const s = this.getLayerSourceCache(t);
          return s && s.getSource();
        }
        getSourceCache(t, s) {
          const h = i.aC(t, s);
          return this._mergedOtherSourceCaches[h];
        }
        getLayerSourceCache(t) {
          const s = i.aC(t.source, t.scope);
          return t.type === "symbol" ? this._mergedSymbolSourceCaches[s] : this._mergedOtherSourceCaches[s];
        }
        getSourceCaches(t) {
          if (t == null)
            return Object.values(this._mergedSourceCaches);
          const s = [];
          return this._mergedOtherSourceCaches[t] && s.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && s.push(this._mergedSymbolSourceCaches[t]), s;
        }
        updateSourceCaches() {
          const t = this._changes.getUpdatedSourceCaches();
          for (const s in t) {
            const h = t[s];
            h === "reload" ? this.reloadSource(s) : h === "clear" && this.clearSource(s);
          }
        }
        updateLayers(t) {
          const s = this._changes.getUpdatedPaintProperties();
          for (const h of s) {
            const m = this.getLayer(h);
            m && m.updateTransitions(t);
          }
        }
        getImages(t, s, h) {
          this.imageManager.getImages(s.icons, s.scope, h), this._updateTilesForChangedImages();
          const m = (g) => {
            g && g.setDependencies(s.tileID.key, s.type, s.icons);
          };
          m(this._otherSourceCaches[s.source]), m(this._symbolSourceCaches[s.source]);
        }
        rasterizeImages(t, s, h) {
          this.imageManager.rasterizeImages(s, h);
        }
        getGlyphs(t, s, h) {
          this.glyphManager.getGlyphs(s.stacks, s.scope, h);
        }
        getResource(t, s, h) {
          return i.cy(s, h);
        }
        getOwnSourceCache(t) {
          return this._otherSourceCaches[t];
        }
        getOwnLayerSourceCache(t) {
          return t.type === "symbol" ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source];
        }
        getOwnSourceCaches(t) {
          const s = [];
          return this._otherSourceCaches[t] && s.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && s.push(this._symbolSourceCaches[t]), s;
        }
        _isSourceCacheLoaded(t) {
          const s = this.getOwnSourceCaches(t);
          return s.length === 0 ? (this.fire(new i.y(new Error(`There is no source with ID '${t}'`))), !1) : s.every((h) => h.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        isLayerClipped(t, s) {
          if (!this._clipLayerPresent && t.type !== "fill-extrusion")
            return !1;
          const h = t.type === "fill-extrusion" && t.sourceLayer === "building";
          if (t.is3D()) {
            if (h || s && s.type === "batched-model" || t.type === "model")
              return !0;
          } else if (t.type === "symbol")
            return !0;
          return !1;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast("clearCaches");
        }
        destroy() {
          this._clearWorkerCaches(), this.fragments.forEach((t) => {
            t.style._remove();
          }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      hr.getSourceType = function(c) {
        return no[c];
      }, hr.setSourceType = function(c, t) {
        no[c] = t;
      }, hr.registerForPluginStateChange = i.ch;
      var Uc = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`, jc = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`, xr = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`, Yo = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Wl = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`, Jr = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`, $l = `highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}
#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {
#ifdef FOG_DITHERING
vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);
#else
return color;
#endif
}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`, Xl = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`, ga = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`, ro = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`, gl = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef TEXTURE_GATHER
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
      const kr = [];
      ao(Uc, kr), ao(xr, kr), ao(jc, kr);
      const oo = { "_prelude_fog.vertex.glsl": Jr, "_prelude_terrain.vertex.glsl": Wl, "_prelude_shadow.vertex.glsl": ro, "_prelude_fog.fragment.glsl": $l, "_prelude_shadow.fragment.glsl": gl, "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`, "_prelude_raster_array.glsl": Xl, "_prelude_raster_particle.glsl": ga }, Ko = {};
      Ti("", Wl), Ti($l, Jr), Ti(gl, ro), Ti(Xl, ""), Ti(ga, "");
      const Yl = Ti(jc, xr), Qr = Uc;
      var yl = { background: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), backgroundPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), circle: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`), clippingMask: Ti("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Ti(`#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), heatmapTexture: Ti(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Ti("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`), collisionCircle: Ti("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`), debug: Ti("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`), fill: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`), fillOutline: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillOutlinePattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), fillExtrusion: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`), fillExtrusionDepth: Ti(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`), fillExtrusionPattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`), groundShadow: Ti(`#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`), fillExtrusionGroundEffect: Ti(`uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`, `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`), hillshadePrepare: Ti(`precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`), line: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec2 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec4 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
halfwidth=(u_width_scale*a_z_offset_width.y)/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);
#else
v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), linePattern: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec4 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec2 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec4 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec4 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
float a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`), raster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`), rasterParticle: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), rasterParticleDraw: Ti("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`), rasterParticleTexture: Ti("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Ti(`#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`, "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Ti(`#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#else
z+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#endif
}`), terrainRaster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`), terrainDepth: Ti("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`), skybox: Ti(`#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Yo), skyboxGradient: Ti(`#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`, Yo), skyboxCapture: Ti(`
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`, "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`), globeAtmosphere: Ti(`#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;
#ifndef NATIVE
c=dither(c,gl_FragCoord.xy+u_temporal_offset);
#endif
glFragColor=vec4(c*t,t);
#endif
}`, `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`), model: Ti(`#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`, `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`), modelDepth: Ti(`in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`, `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`), stars: Ti(`in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`, `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`), snowParticle: Ti("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`), rainParticle: Ti("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`), vignette: Ti("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Ti("uniform vec4 u_color;void main() {glFragColor=u_color;}", `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`) };
      function ao(c, t) {
        const s = c.replace(/\s*\/\/[^\n]*\n/g, `
`).split(`
`);
        for (let h of s)
          if (h = h.trim(), h[0] === "#" && h.includes("if") && !h.includes("endif")) {
            h = h.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
            const m = h.split(" ");
            for (const g of m)
              t.includes(g) || t.push(g);
          }
      }
      function Ti(c, t) {
        const s = /#include\s+"([^"]+)"/g, h = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let m = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        m && (m = m.map((F) => {
          const N = F.split(" ");
          return N[N.length - 1];
        }), m = [...new Set(m)]);
        const g = {}, T = [], z = [];
        if (c = c.replace(s, (F, N) => (z.push(N), "")), (t = t.replace(s, (F, N) => (T.push(N), ""))).includes("flat out"))
          return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
        let R = [...kr];
        ao(c, R), ao(t, R);
        for (const F of [...T, ...z])
          oo[F] || console.error(`Undefined include: ${F}`), Ko[F] || (Ko[F] = [], ao(oo[F], Ko[F])), R = [...R, ...Ko[F]];
        return { fragmentSource: c = c.replace(h, (F, N, j, G, W) => (g[W] = !0, N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
in ${j} ${G} ${W};
#else
uniform ${j} ${G} u_${W};
#endif
` : N === "initialize" ? `
#ifdef HAS_UNIFORM_u_${W}
    ${j} ${G} ${W} = u_${W};
#endif
` : N === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    in ${j} ${G} ${W};
#endif
` : N === "initialize-attribute" ? "" : void 0)), vertexSource: t = t.replace(h, (F, N, j, G, W) => {
          const te = G === "float" ? "vec2" : G, ee = W.match(/color/) ? "color" : te;
          return N === "define-attribute-vertex-shader-only" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
in ${j} ${G} a_${W};
#endif
` : g[W] ? N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
uniform lowp float u_${W}_t;
in ${j} ${te} a_${W};
out ${j} ${G} ${W};
#else
uniform ${j} ${G} u_${W};
#endif
` : N === "initialize" ? ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${W}
    ${W} = a_${W};
#else
    ${j} ${G} ${W} = u_${W};
#endif
` : `
#ifndef HAS_UNIFORM_u_${W}
    ${W} = unpack_mix_${ee}(a_${W}, u_${W}_t);
#else
    ${j} ${G} ${W} = u_${W};
#endif
` : N === "define-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    in ${j} ${G} a_${W};
    out ${j} ${G} ${W};
#endif
` : N === "initialize-attribute" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    ${W} = a_${W};
#endif
` : void 0 : N === "define" ? `
#ifndef HAS_UNIFORM_u_${W}
uniform lowp float u_${W}_t;
in ${j} ${te} a_${W};
#else
uniform ${j} ${G} u_${W};
#endif
` : N === "define-instanced" ? ee === "mat4" ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${W}0;
in vec4 a_${W}1;
in vec4 a_${W}2;
in vec4 a_${W}3;
#else
uniform ${j} ${G} u_${W};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${j} ${te} a_${W};
#else
uniform ${j} ${G} u_${W};
#endif
` : N === "initialize-attribute-custom" ? `
#ifdef HAS_ATTRIBUTE_a_${W}
    ${j} ${G} ${W} = a_${W};
#endif
` : ee === "vec4" ? `
#ifndef HAS_UNIFORM_u_${W}
    ${j} ${G} ${W} = a_${W};
#else
    ${j} ${G} ${W} = u_${W};
#endif
` : `
#ifndef HAS_UNIFORM_u_${W}
    ${j} ${G} ${W} = unpack_mix_${ee}(a_${W}, u_${W}_t);
#else
    ${j} ${G} ${W} = u_${W};
#endif
`;
        }), staticAttributes: m, usedDefines: R, vertexIncludes: T, fragmentIncludes: z };
      }
      class Zh {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
        }
        bind(t, s, h, m, g, T, z, R) {
          this.context = t;
          let F = this.boundPaintVertexBuffers.length !== m.length;
          for (let j = 0; !F && j < m.length; j++)
            this.boundPaintVertexBuffers[j] !== m[j] && (F = !0);
          let N = this.boundDynamicVertexBuffers.length !== z.length;
          for (let j = 0; !N && j < z.length; j++)
            this.boundDynamicVertexBuffers[j] !== z[j] && (N = !0);
          if (!this.vao || this.boundProgram !== s || this.boundLayoutVertexBuffer !== h || F || N || this.boundIndexBuffer !== g || this.boundVertexOffset !== T)
            this.freshBind(s, h, m, g, T, z, R);
          else {
            t.bindVertexArrayOES.set(this.vao);
            for (const j of z)
              j && (j.bind(), R && j.instanceCount && j.setVertexAttribDivisor(t.gl, s, R));
            g && g.dynamicDraw && g.bind();
          }
        }
        freshBind(t, s, h, m, g, T, z) {
          const R = t.numAttributes, F = this.context, N = F.gl;
          this.vao && this.destroy(), this.vao = F.gl.createVertexArray(), F.bindVertexArrayOES.set(this.vao), this.boundProgram = t, this.boundLayoutVertexBuffer = s, this.boundPaintVertexBuffers = h, this.boundIndexBuffer = m, this.boundVertexOffset = g, this.boundDynamicVertexBuffers = T, s.enableAttributes(N, t), s.bind(), s.setVertexAttribPointers(N, t, g);
          for (const j of h)
            j.enableAttributes(N, t), j.bind(), j.setVertexAttribPointers(N, t, g);
          for (const j of T)
            j && (j.enableAttributes(N, t), j.bind(), j.setVertexAttribPointers(N, t, g), z && j.instanceCount && j.setVertexAttribDivisor(N, t, z));
          m && m.bind(), F.currentNumAttributes = R;
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      function xl(c, t) {
        const s = Math.pow(2, t.canonical.z), h = t.canonical.y;
        return [new i.aa(0, h / s).toLngLat().lat, new i.aa(0, (h + 1) / s).toLngLat().lat];
      }
      function Ua(c, t, s, h, m, g, T) {
        const z = c.context, R = z.gl, F = s.hillshadeFBO;
        if (!F)
          return;
        c.prepareDrawTile();
        const N = c.isTileAffectedByFog(t), j = c.getOrCreateProgram("hillshade", { overrideFog: N });
        z.activeTexture.set(R.TEXTURE0), R.bindTexture(R.TEXTURE_2D, F.colorAttachment.get());
        const G = ((se, oe, ce, _e) => {
          const pe = ce.paint.get("hillshade-shadow-color"), Te = ce.paint.get("hillshade-shadow-color-use-theme").constantOr("default") === "none", xe = ce.paint.get("hillshade-highlight-color"), be = ce.paint.get("hillshade-highlight-color-use-theme").constantOr("default") === "none", ve = ce.paint.get("hillshade-accent-color"), Pe = ce.paint.get("hillshade-accent-color-use-theme").constantOr("default") === "none", Oe = ce.paint.get("hillshade-emissive-strength");
          let Xe = i.ai(ce.paint.get("hillshade-illumination-direction"));
          if (ce.paint.get("hillshade-illumination-anchor") === "viewport")
            Xe -= se.transform.angle;
          else if (se.style && se.style.enable3dLights() && se.style.directionalLight) {
            const ke = se.style.directionalLight.properties.get("direction"), Ne = i.cb(ke.x, ke.y, ke.z);
            Xe = i.ai(Ne[1]);
          }
          const Ze = !se.options.moving;
          return { u_matrix: _e || se.transform.calculateProjMatrix(oe.tileID.toUnwrapped(), Ze), u_image: 0, u_latrange: xl(0, oe.tileID), u_light: [ce.paint.get("hillshade-exaggeration"), Xe], u_shadow: pe.toRenderColor(Te ? null : ce.lut), u_highlight: xe.toRenderColor(be ? null : ce.lut), u_emissive_strength: Oe, u_accent: ve.toRenderColor(Pe ? null : ce.lut) };
        })(c, s, h, c.terrain ? t.projMatrix : null);
        c.uploadCommonUniforms(z, j, t.toUnwrapped());
        const { tileBoundsBuffer: W, tileBoundsIndexBuffer: te, tileBoundsSegments: ee } = c.getTileBoundsBuffers(s);
        j.draw(c, R.TRIANGLES, m, g, T, ti.disabled, G, h.id, W, te, ee);
      }
      function Jo(c, t, s) {
        if (!t.needsDEMTextureUpload)
          return;
        const h = c.context, m = h.gl;
        h.pixelStoreUnpackPremultiplyAlpha.set(!1), t.demTexture = t.demTexture || c.getTileTexture(s.stride);
        const g = s.getPixels();
        t.demTexture ? t.demTexture.update(g, { premultiply: !1 }) : t.demTexture = new i.T(h, g, m.R32F, { premultiply: !1 }), t.needsDEMTextureUpload = !1;
      }
      function Gc(c, t, s) {
        const h = c.context, m = h.gl;
        if (!t.dem)
          return;
        const g = t.dem;
        if (h.activeTexture.set(m.TEXTURE1), Jo(c, t, g), !t.demTexture)
          return;
        t.demTexture.bind(m.NEAREST, m.CLAMP_TO_EDGE);
        const T = g.dim;
        h.activeTexture.set(m.TEXTURE0);
        let z = t.hillshadeFBO;
        if (!z) {
          const G = new i.T(h, { width: T, height: T, data: null }, m.RGBA8);
          G.bind(m.LINEAR, m.CLAMP_TO_EDGE), z = t.hillshadeFBO = h.createFramebuffer(T, T, !0, "renderbuffer"), z.colorAttachment.set(G.texture);
        }
        h.bindFramebuffer.set(z.framebuffer), h.viewport.set([0, 0, T, T]);
        const { tileBoundsBuffer: R, tileBoundsIndexBuffer: F, tileBoundsSegments: N } = c.getMercatorTileBoundsBuffers(), j = [];
        c.linearFloatFilteringSupported() && j.push("TERRAIN_DEM_FLOAT_FORMAT"), c.getOrCreateProgram("hillshadePrepare", { defines: j }).draw(c, m.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.disabled, ((G, W) => {
          const te = W.stride, ee = i.ab.mat4.create();
          return i.ab.mat4.ortho(ee, 0, i.ag, -i.ag, 0, 0, 1), i.ab.mat4.translate(ee, ee, [0, -i.ag, 0]), { u_matrix: ee, u_image: 1, u_dimension: [te, te], u_zoom: G.overscaledZ };
        })(t.tileID, g), s.id, R, F, N), t.needsHillshadePrepare = !1;
      }
      class gn {
        constructor(t) {
          this.gl = t.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(t) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Hh extends gn {
        getDefault() {
          return i.aj.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class qh extends gn {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), this.current = t, this.dirty = !1);
        }
      }
      class Kl extends gn {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), this.current = t, this.dirty = !1);
        }
      }
      class Jl extends gn {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Ql extends gn {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Zc extends gn {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), this.current = t, this.dirty = !1);
        }
      }
      class Hc extends gn {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const s = this.current;
          (t.func !== s.func || t.ref !== s.ref || t.mask !== s.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), this.current = t, this.dirty = !1);
        }
      }
      class qc extends gn {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), this.current = t, this.dirty = !1);
        }
      }
      class Qu extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST), this.current = t, this.dirty = !1;
        }
      }
      class p extends gn {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), this.current = t, this.dirty = !1);
        }
      }
      class A extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST), this.current = t, this.dirty = !1;
        }
      }
      class B extends gn {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), this.current = t, this.dirty = !1);
        }
      }
      class X extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.BLEND) : s.disable(s.BLEND), this.current = t, this.dirty = !1;
        }
      }
      class ne extends gn {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO, t.ONE, t.ZERO];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class ye extends gn {
        getDefault() {
          return i.aj.transparent;
        }
        set(t) {
          const s = this.current;
          (t.r !== s.r || t.g !== s.g || t.b !== s.b || t.a !== s.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), this.current = t, this.dirty = !1);
        }
      }
      class We extends gn {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), this.current = t, this.dirty = !1);
        }
      }
      class ot extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE), this.current = t, this.dirty = !1;
        }
      }
      class ft extends gn {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), this.current = t, this.dirty = !1);
        }
      }
      class Rt extends gn {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), this.current = t, this.dirty = !1);
        }
      }
      let ii = class extends gn {
        getDefault() {
          return null;
        }
        set(c) {
          (c !== this.current || this.dirty) && (this.gl.useProgram(c), this.current = c, this.dirty = !1);
        }
      };
      class Ci extends gn {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), this.current = t, this.dirty = !1);
        }
      }
      class Wi extends gn {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const s = this.current;
          (t[0] !== s[0] || t[1] !== s[1] || t[2] !== s[2] || t[3] !== s[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), this.current = t, this.dirty = !1);
        }
      }
      class Hs extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindFramebuffer(s.FRAMEBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ws extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindRenderbuffer(s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Rs extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindTexture(s.TEXTURE_2D, t), this.current = t, this.dirty = !1;
        }
      }
      class ur extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.bindBuffer(s.ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ja extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          const s = this.gl;
          s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class ed extends gn {
        getDefault() {
          return null;
        }
        set(t) {
          this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), this.current = t, this.dirty = !1);
        }
      }
      class td extends gn {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_ALIGNMENT, t), this.current = t, this.dirty = !1;
        }
      }
      class id extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class Wh extends gn {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          const s = this.gl;
          s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t), this.current = t, this.dirty = !1;
        }
      }
      class vl extends gn {
        constructor(t, s) {
          super(t), this.context = t, this.parent = s;
        }
        getDefault() {
          return null;
        }
      }
      class ec extends vl {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class es extends vl {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferRenderbuffer(s.FRAMEBUFFER, this.attachment(), s.RENDERBUFFER, t), this.current = t, this.dirty = !1;
        }
      }
      class Ao extends vl {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const s = this.gl;
          s.framebufferTexture2D(s.FRAMEBUFFER, this.attachment(), s.TEXTURE_2D, t, 0), this.current = t, this.dirty = !1;
        }
      }
      class $h extends es {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      const Xh = (c, t, s) => ({ u_matrix: c, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: s }), Wc = (c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee) => ({ u_proj_matrix: Float32Array.from(c), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(h), u_merc_matrix: s, u_zoom_transition: m, u_merc_center: g, u_image0: 0, u_frustum_tl: T, u_frustum_tr: z, u_frustum_br: R, u_frustum_bl: F, u_globe_pos: N, u_globe_radius: j, u_viewport: G, u_grid_matrix: ee ? Float32Array.from(ee) : new Float32Array(9), u_skirt_height: W, u_far_z_cutoff: te });
      function Ga(c, t) {
        return c != null && t != null && !(!c.hasData() || !t.hasData()) && c.demTexture != null && t.demTexture != null && c.tileID.key !== t.tileID.key;
      }
      const vr = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(c, t, s, h, m) {
          if (c in this.operations) {
            const g = this.operations[c];
            g.to.tileID.key !== s.tileID.key && (g.queued = s);
          } else
            this.operations[c] = { startTime: h, phase: 0, duration: m, from: t, to: s, queued: null };
        }
        getMorphValuesForProxy(c) {
          if (!(c in this.operations))
            return null;
          const t = this.operations[c];
          return { from: t.from, to: t.to, phase: t.phase };
        }
        update(c) {
          for (const t in this.operations) {
            const s = this.operations[t];
            for (s.phase = (c - s.startTime) / s.duration; s.phase >= 1 || !this._validOp(s); )
              if (!this._nextOp(s, c)) {
                delete this.operations[t];
                break;
              }
          }
        }
        _nextOp(c, t) {
          return !!c.queued && (c.from = c.to, c.to = c.queued, c.queued = null, c.phase = 0, c.startTime = t, !0);
        }
        _validOp(c) {
          return c.from.hasData() && c.to.hasData();
        }
      }(), $c = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
      function ya(c, t, s) {
        if (t === 0)
          return 0;
        const h = t < 1 && s === 514 ? 0.25 / t : 1;
        return 6 * Math.pow(1.5, 22 - c) * Math.max(t, 1) * h;
      }
      function nd(c, t) {
        const s = 1 << c.z;
        return !t && (c.x === 0 || c.x === s - 1) || c.y === 0 || c.y === s - 1;
      }
      const tc = (c) => ({ u_matrix: c });
      function Yh(c, t, s, h, m) {
        if (m > 0) {
          const g = i.q.now(), T = (g - c.timeAdded) / m, z = t ? (g - t.timeAdded) / m : -1, R = s.getSource(), F = h.coveringZoomLevel({ tileSize: R.tileSize, roundZoom: R.roundZoom }), N = !t || Math.abs(t.tileID.overscaledZ - F) > Math.abs(c.tileID.overscaledZ - F), j = N && c.refreshedUponExpiration ? 1 : i.aw(N ? T : 1 - z, 0, 1);
          return c.refreshedUponExpiration && T >= 1 && (c.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - j } : { opacity: j, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class Uf extends sr {
        constructor(t) {
          const s = { type: "raster-dem", maxzoom: t.transform.maxZoom }, h = new i.D(i.ci(), null), m = jo("mock-dem", s, h, t.style);
          super("mock-dem", m, !1), m.setEventedParent(this), this._sourceLoaded = !0;
        }
        _loadTile(t, s) {
          t.state = "loaded", s(null);
        }
      }
      class sd extends sr {
        constructor(t) {
          const s = jo("proxy", { type: "geojson", maxzoom: t.transform.maxZoom }, new i.D(i.ci(), null), t.style);
          super("proxy", s, !1), s.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t, s, h) {
          if (t.freezeTileCoverage)
            return;
          this.transform = t;
          const m = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((g, T) => {
            if (g[T.key] = "", !this._tiles[T.key]) {
              const z = new Cr(T, this._source.tileSize * T.overscaleFactor(), t.tileZoom);
              z.state = "loaded", this._tiles[T.key] = z;
            }
            return g;
          }, {});
          for (const g in this._tiles)
            g in m || (this.freeFBO(g), this._tiles[g].unloadVectorData(), delete this._tiles[g]);
        }
        freeFBO(t) {
          const s = this.proxyCachedFBO[t];
          if (s !== void 0) {
            const h = Object.values(s);
            this.renderCachePool.push(...h), delete this.proxyCachedFBO[t];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((t) => t.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class Kh extends i.aG {
        constructor(t, s, h) {
          super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), this.proxyTileKey = s, this.projMatrix = h;
        }
      }
      class jf extends i.cJ {
        constructor(t, s) {
          super(), this._debugParams = { sortTilesHiZFirst: !0, disableRenderCache: !1 }, t.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
            this._style.map.triggerRepaint();
          }), t.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
            this._style.map.triggerRepaint();
          }), t.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
            this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
          }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [h, m, g] = function(R) {
            const F = new i.b4(), N = new i.aU(), j = 131;
            F.reserve(17161), N.reserve(33800);
            const G = i.ag / 128, W = i.ag + G / 2, te = W + G;
            for (let se = -G; se < te; se += G)
              for (let oe = -G; oe < te; oe += G) {
                const ce = oe < 0 || oe > W || se < 0 || se > W ? 24575 : 0, _e = i.aw(Math.round(oe), 0, i.ag), pe = i.aw(Math.round(se), 0, i.ag);
                F.emplaceBack(_e + ce, pe);
              }
            const ee = (se, oe) => {
              const ce = oe * j + se;
              N.emplaceBack(ce + 1, ce, ce + j), N.emplaceBack(ce + j, ce + j + 1, ce + 1);
            };
            for (let se = 1; se < 129; se++)
              for (let oe = 1; oe < 129; oe++)
                ee(oe, se);
            return [0, 129].forEach((se) => {
              for (let oe = 0; oe < 130; oe++)
                ee(oe, se), ee(se, oe);
            }), [F, N, 32768];
          }(), T = t.context;
          this.gridBuffer = T.createVertexBuffer(h, i.b6.members), this.gridIndexBuffer = T.createIndexBuffer(m), this.gridSegments = i.b7.simpleSegment(0, 0, h.length, m.length), this.gridNoSkirtSegments = i.b7.simpleSegment(0, 0, h.length, g), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new sd(s.map), this.orthoMatrix = i.ab.mat4.create(), i.ab.mat4.ortho(this.orthoMatrix, this.painter.transform.projection.name === "globe" ? 0.015 : 0, i.ag, 0, i.ag, 0, 1);
          const z = T.gl;
          this._overlapStencilMode = new ci({ func: z.GEQUAL, mask: 255 }, 0, 255, z.KEEP, z.KEEP, z.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = s, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Uf(s.map), this._pendingGroundEffectLayers = [];
        }
        set style(t) {
          t.on("data", this._onStyleDataEvent.bind(this)), this._style = t, this._style.map.on("moveend", () => {
            this._clearLineLayersFromRenderCache();
          });
        }
        update(t, s, h) {
          if (t && t.terrain) {
            this._style !== t && (this.style = t, this._evaluationZoom = void 0);
            const m = t.terrain.properties, g = t.terrain.drapeRenderMode === 0, T = t.terrain.isZoomDependent();
            this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = i.q.now();
            const z = t.terrain && t.terrain.scope, R = m.get("source"), F = g ? this._mockSourceCache : t.getSourceCache(R, z);
            if (!F)
              return void i.w(`Couldn't find terrain source "${R}".`);
            if (this.sourceCache = F, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = T ? this.calculateExaggeration(s) : m.get("exaggeration"), !s.projection.requiresDraping && T && this._exaggeration === 0)
              return void this._disable();
            this.enabled = !0;
            const N = () => {
              this.sourceCache.used && i.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const j = this.getScaledDemTileSize();
              this.sourceCache.update(s, j, !0), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, N(), this._initializing = !0), N(), s.updateElevation(!0, h), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(s), this._emptyDEMTextureDirty = !0, this._previousZoom = s.zoom;
          } else
            this._disable();
        }
        calculateExaggeration(t) {
          if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1]))
            return this._style.terrain.getExaggeration(t.zoom);
          const s = this._previousCameraAltitude, h = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;
          this._previousCameraAltitude = h;
          const m = s != null ? h - s : Number.MAX_VALUE;
          if (Math.abs(m) < 2)
            return this._exaggeration;
          const g = t.zoom, T = this._style.terrain;
          if (!this._previousUpdateTimestamp)
            return T.getExaggeration(g);
          let z = g - this._previousZoom;
          const R = this._previousUpdateTimestamp;
          let F = g;
          this._evaluationZoom != null && (F = this._evaluationZoom, Math.abs(g - F) > 0.5 && (z = 0.5 * (g - F + z)), z * m < 0 && (F += z)), this._evaluationZoom = F;
          const N = T.getExaggeration(F), j = N === T.getExaggeration(Math.max(0, F - 0.1));
          if (j && Math.abs(N - this._exaggeration) < 0.01)
            return N;
          let G = Math.min(0.1, 375e-5 * (this._updateTimestamp - R));
          return (j || N < 0.1 || Math.abs(z) < 1e-4) && (G = Math.min(0.2, 4 * G)), i.af(this._exaggeration, N, G);
        }
        resetTileLookupCache(t) {
          this._findCoveringTileCache[t] = {};
        }
        attenuationRange() {
          return this._attenuationRange;
        }
        getDemUpscale() {
          return this.proxySourceCache.getSource().tileSize / 128;
        }
        getScaledDemTileSize() {
          return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(t) {
          t.coord && t.dataType === "source" ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === "style" && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
        }
        _disable() {
          if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const t in this._style._mergedSourceCaches)
              this._style._mergedSourceCaches[t].usedForTerrain = !1;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((t) => t.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this.enabled ? this._exaggeration : 0;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const t = 2 * this.proxySourceCache.getSource().tileSize;
          return [t, t];
        }
        set useVertexMorphing(t) {
          this._useVertexMorphing = t;
        }
        updateTileBinding(t) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const s = this.proxySourceCache, h = this.painter.transform;
          this._initializing && (this._initializing = h._centerAltitude === 0 && this.getAtPointOrZero(i.aa.fromLngLat(h.center), -1) === -1, this._emptyDEMTextureDirty = !this._initializing);
          const m = this.proxyCoords = s.getIds().map((R) => {
            const F = s.getTileByID(R).tileID;
            return F.projMatrix = h.calculateProjMatrix(F.toUnwrapped()), F;
          });
          (function(R, F) {
            const N = F.transform.pointCoordinate(F.transform.getCameraPoint()), j = new i.P(N.x, N.y);
            R.sort((G, W) => {
              if (W.overscaledZ - G.overscaledZ)
                return W.overscaledZ - G.overscaledZ;
              const te = new i.P(G.canonical.x + (1 << G.canonical.z) * G.wrap, G.canonical.y), ee = new i.P(W.canonical.x + (1 << W.canonical.z) * W.wrap, W.canonical.y), se = j.mult(1 << G.canonical.z);
              return se.x -= 0.5, se.y -= 0.5, se.distSqr(te) - se.distSqr(ee);
            });
          })(m, this.painter);
          const g = this.proxyToSource || {};
          this.proxyToSource = {}, m.forEach((R) => {
            this.proxyToSource[R.key] = {};
          }), this.terrainTileForTile = {};
          const T = this._style._mergedSourceCaches;
          for (const R in T) {
            const F = T[R];
            if (!F.used || (F !== this.sourceCache && this.resetTileLookupCache(F.id), this._setupProxiedCoordsForOrtho(F, t[R], g), F.usedForTerrain))
              continue;
            const N = t[R];
            F.getSource().reparseOverscaled && this._assignTerrainTiles(N);
          }
          this.proxiedCoords[s.id] = m.map((R) => new Kh(R, R.key, this.orthoMatrix)), this._assignTerrainTiles(m), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(g), this.renderingToTexture = !1;
          const z = {};
          this._visibleDemTiles = [];
          for (const R of this.proxyCoords) {
            const F = this.terrainTileForTile[R.key];
            if (!F)
              continue;
            const N = F.tileID.key;
            N in z || (this._visibleDemTiles.push(F), z[N] = N);
          }
        }
        _assignTerrainTiles(t) {
          this._initializing || t.forEach((s) => {
            if (this.terrainTileForTile[s.key])
              return;
            const h = this._findTileCoveringTileID(s, this.sourceCache);
            h && (this.terrainTileForTile[s.key] = h);
          });
        }
        _prepareDEMTextures() {
          const t = this.painter.context, s = t.gl;
          for (const h in this.terrainTileForTile) {
            const m = this.terrainTileForTile[h], g = m.dem;
            !g || m.demTexture && !m.needsDEMTextureUpload || (t.activeTexture.set(s.TEXTURE1), Jo(this.painter, m, g));
          }
        }
        _prepareDemTileUniforms(t, s, h, m) {
          if (!s || s.demTexture == null)
            return !1;
          const g = t.tileID.canonical, T = Math.pow(2, s.tileID.canonical.z - g.z), z = m || "";
          return h[`u_dem_tl${z}`] = [g.x * T % 1, g.y * T % 1], h[`u_dem_scale${z}`] = T, !0;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        _getLoadedAreaMinimum() {
          if (!this.enabled)
            return 0;
          let t = 0;
          const s = this._visibleDemTiles.reduce((h, m) => {
            if (!m.dem)
              return h;
            const g = m.dem.tree.minimums[0];
            return g > 0 && t++, h + g;
          }, 0);
          return t ? s / t : 0;
        }
        _updateEmptyDEMTexture() {
          const t = this.painter.context, s = t.gl;
          t.activeTexture.set(s.TEXTURE2);
          const h = this._getLoadedAreaMinimum(), m = new i.cK({ width: 1, height: 1 }, new Float32Array([h]));
          this._emptyDEMTextureDirty = !1;
          let g = this._emptyDEMTexture;
          return g ? g.update(m, { premultiply: !1 }) : g = this._emptyDEMTexture = new i.T(t, m, s.R32F, { premultiply: !1 }), g;
        }
        setupElevationDraw(t, s, h) {
          const m = this.painter.context, g = m.gl, T = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
          T.u_exaggeration = this.exaggeration();
          let z = null, R = null, F = 1;
          if (h && h.morphing && this._useVertexMorphing) {
            const W = h.morphing.srcDemTile, te = h.morphing.dstDemTile;
            F = h.morphing.phase, W && te && (this._prepareDemTileUniforms(t, W, T, "_prev") && (R = W), this._prepareDemTileUniforms(t, te, T) && (z = te));
          }
          const N = (W) => W && W.demTexture && this.painter.linearFloatFilteringSupported() ? g.LINEAR : g.NEAREST;
          let j = null;
          var G;
          if (this.enabled ? R && z ? (j = z.demTexture, m.activeTexture.set(g.TEXTURE4), R.demTexture.bind(N(R), g.CLAMP_TO_EDGE), T.u_dem_lerp = F) : (z = this.terrainTileForTile[t.tileID.key], j = this._prepareDemTileUniforms(t, z, T) ? z.demTexture : this.emptyDEMTexture) : j = this.emptyDEMTexture, m.activeTexture.set(g.TEXTURE2), j && (T.u_dem_size = (G = j).size[0] === 1 ? 1 : G.size[0] - 2, j.bind(N(z), g.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(h && h.useDepthForOcclusion, s, T), h && h.useMeterToDem && z) {
            const W = (1 << z.tileID.canonical.z) * i.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            T.u_meter_to_dem = W;
          }
          if (h && h.labelPlaneMatrixInv && (T.u_label_plane_matrix_inv = h.labelPlaneMatrixInv), s.setTerrainUniformValues(m, T), this.painter.transform.projection.name === "globe") {
            const W = this.globeUniformValues(this.painter.transform, t.tileID.canonical, h && h.useDenormalizedUpVectorScale);
            s.setGlobeUniformValues(m, W);
          }
        }
        globeUniformValues(t, s, h) {
          const m = t.projection;
          return { u_tile_tl_up: m.upVector(s, 0, 0), u_tile_tr_up: m.upVector(s, i.ag, 0), u_tile_br_up: m.upVector(s, i.ag, i.ag), u_tile_bl_up: m.upVector(s, 0, i.ag), u_tile_up_scale: h ? i.cL(1) : m.upVectorScale(s, t.center.lat, t.worldSize).metersToTile };
        }
        renderToBackBuffer(t) {
          const s = this.painter, h = this.painter.context;
          t.length !== 0 && (h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), s.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(m, g, T, z, R) {
            if (m.transform.projection.name === "globe")
              (function(F, N, j, G, W) {
                const te = F.context, ee = te.gl;
                let se, oe;
                const ce = F.transform, _e = i.cC(F, te, ce), pe = (ke, Ne) => {
                  if (oe === Ne)
                    return;
                  const st = [$c[Ne], "PROJECTION_GLOBE_VIEW"];
                  _e && st.push("CUSTOM_ANTIALIASING");
                  const ht = F.isTileAffectedByFog(ke);
                  se = F.getOrCreateProgram("globeRaster", { defines: st, overrideFog: ht }), oe = Ne;
                }, Te = F.colorModeForRenderPass(), xe = new Wt(ee.LEQUAL, Wt.ReadWrite, F.depthRangeFor3D);
                vr.update(W);
                const be = i.cD(ce), ve = [i.at(ce.center.lng), i.aA(ce.center.lat)], Pe = F.globeSharedBuffers, Oe = [ce.width * i.q.devicePixelRatio, ce.height * i.q.devicePixelRatio], Xe = Float32Array.from(ce.globeMatrix), Ze = { useDenormalizedUpVectorScale: !0 };
                {
                  const ke = F.transform, Ne = ya(ke.zoom, N.exaggeration(), N.sourceCache._source.tileSize);
                  oe = -1;
                  const st = ee.TRIANGLES;
                  for (const ht of G) {
                    const yt = j.getTile(ht), je = ci.disabled, at = N.prevTerrainTileForTile[ht.key], Je = N.terrainTileForTile[ht.key];
                    Ga(at, Je) && vr.newMorphing(ht.key, at, Je, W, 250), te.activeTexture.set(ee.TEXTURE0), yt.texture && yt.texture.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
                    const _t = vr.getMorphValuesForProxy(ht.key), ct = _t ? 1 : 0;
                    _t && i.J(Ze, { morphing: { srcDemTile: _t.from, dstDemTile: _t.to, phase: i.cB(_t.phase) } });
                    const nt = i.cE(ht.canonical), Lt = i.cF(nt.getCenter().lat), xt = i.cG(ht.canonical, nt, Lt, ke.worldSize / ke._pixelsPerMercatorPixel), zt = i.bb(i.cH(ht.canonical)), Bt = Wc(ke.expandedFarZProjMatrix, Xe, be, zt, i.ae(ke.zoom), ve, ke.frustumCorners.TL, ke.frustumCorners.TR, ke.frustumCorners.BR, ke.frustumCorners.BL, ke.globeCenterInViewSpace, ke.globeRadius, Oe, Ne, ke._farZ, xt);
                    if (pe(ht, ct), se && (N.setupElevationDraw(yt, se, Ze), F.uploadCommonUniforms(te, se, ht.toUnwrapped()), Pe)) {
                      const [oi, $t, Xt] = Pe.getGridBuffers(Lt, Ne !== 0);
                      se.draw(F, st, xe, je, Te, ti.backCCW, Bt, "globe_raster", oi, $t, Xt);
                    }
                  }
                }
                if (Pe && (F.renderDefaultNorthPole || F.renderDefaultSouthPole)) {
                  const ke = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                  _e && ke.push("CUSTOM_ANTIALIASING"), se = F.getOrCreateProgram("globeRaster", { defines: ke });
                  for (const Ne of G) {
                    const { x: st, y: ht, z: yt } = Ne.canonical, je = ht === 0, at = ht === (1 << yt) - 1, [Je, _t, ct, nt] = Pe.getPoleBuffers(yt, !1);
                    if (nt && (je || at)) {
                      const Lt = j.getTile(Ne);
                      te.activeTexture.set(ee.TEXTURE0), Lt.texture && Lt.texture.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
                      let xt = i.cI(yt, st, ce);
                      const zt = i.bb(i.cH(Ne.canonical)), Bt = (oi, $t) => oi.draw(F, ee.TRIANGLES, xe, ci.disabled, Te, ti.disabled, Wc(ce.expandedFarZProjMatrix, xt, xt, zt, 0, ve, ce.frustumCorners.TL, ce.frustumCorners.TR, ce.frustumCorners.BR, ce.frustumCorners.BL, ce.globeCenterInViewSpace, ce.globeRadius, Oe, 0, ce._farZ), "globe_pole_raster", $t, ct, nt);
                      N.setupElevationDraw(Lt, se, Ze), F.uploadCommonUniforms(te, se, Ne.toUnwrapped()), je && F.renderDefaultNorthPole && Bt(se, Je), at && F.renderDefaultSouthPole && (xt = i.ab.mat4.scale(i.ab.mat4.create(), xt, [1, -1, 1]), Bt(se, _t));
                    }
                  }
                }
              })(m, g, T, z, R);
            else {
              const F = m.context, N = F.gl;
              let j, G;
              const W = m.shadowRenderer, te = To(m, m.longestCutoffRange), ee = (Te) => {
                if (G === Te)
                  return;
                const xe = [];
                xe.push($c[Te]), te.shouldRenderCutoff && xe.push("RENDER_CUTOFF"), W && (xe.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), W.useNormalOffset && xe.push("NORMAL_OFFSET")), j = m.getOrCreateProgram("terrainRaster", { defines: xe }), G = Te;
              }, se = m.colorModeForRenderPass(), oe = new Wt(N.LEQUAL, Wt.ReadWrite, m.depthRangeFor3D);
              vr.update(R);
              const ce = m.transform, _e = ya(ce.zoom, g.exaggeration(), g.sourceCache._source.tileSize);
              let pe = [0, 0, 0];
              if (W) {
                const Te = m.style.directionalLight, xe = m.style.ambientLight;
                Te && xe && (pe = cr(m.style, Te, xe));
              }
              {
                G = -1;
                const Te = N.TRIANGLES, [xe, be] = [g.gridIndexBuffer, g.gridSegments];
                for (const ve of z) {
                  const Pe = T.getTile(ve), Oe = ci.disabled, Xe = g.prevTerrainTileForTile[ve.key], Ze = g.terrainTileForTile[ve.key];
                  Ga(Xe, Ze) && vr.newMorphing(ve.key, Xe, Ze, R, 250), F.activeTexture.set(N.TEXTURE0), Pe.texture && Pe.texture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
                  const ke = vr.getMorphValuesForProxy(ve.key), Ne = ke ? 1 : 0;
                  let st;
                  ke && (st = { morphing: { srcDemTile: ke.from, dstDemTile: ke.to, phase: i.cB(ke.phase) } });
                  const ht = Xh(ve.projMatrix, nd(ve.canonical, ce.renderWorldCopies) ? _e / 10 : _e, pe);
                  if (ee(Ne), !j)
                    continue;
                  g.setupElevationDraw(Pe, j, st);
                  const yt = ve.toUnwrapped();
                  W && W.setupShadows(yt, j), m.uploadCommonUniforms(F, j, yt, null, te), j.draw(m, Te, oe, Oe, se, ti.backCCW, ht, "terrain_raster", g.gridBuffer, xe, be);
                }
              }
            }
          }(s, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, s.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));
        }
        renderBatch(t) {
          if (this._drapedRenderBatches.length === 0)
            return t + 1;
          this.renderingToTexture = !0;
          const s = this.painter, h = this.painter.context, m = this.proxySourceCache, g = this.proxiedCoords[m.id], T = this._drapedRenderBatches.shift(), z = s.style.order, R = [];
          let F = 0;
          for (const N of g) {
            const j = m.getTileByID(N.proxyTileKey), G = m.proxyCachedFBO[N.key] ? m.proxyCachedFBO[N.key][t] : void 0, W = G !== void 0 ? m.renderCache[G] : this.pool[F++], te = G !== void 0;
            if (j.texture = W.tex, te && !W.dirty) {
              R.push(j.tileID);
              continue;
            }
            let ee;
            h.bindFramebuffer.set(W.fb.framebuffer), this.renderedToTile = !1, W.dirty && (h.clear({ color: i.aj.transparent, stencil: 0 }), W.dirty = !1);
            for (let se = T.start; se <= T.end; ++se) {
              const oe = s.style._mergedLayers[z[se]];
              if (oe.isHidden(s.transform.zoom))
                continue;
              const ce = s.style.getLayerSourceCache(oe), _e = ce ? this.proxyToSource[N.key][ce.id] : [N];
              if (!_e)
                continue;
              const pe = _e;
              h.viewport.set([0, 0, W.fb.width, W.fb.height]), ee !== (ce ? ce.id : null) && (this._setupStencil(W, _e, oe, ce), ee = ce ? ce.id : null), s.renderLayer(s, ce, oe, pe);
            }
            if (this._drapedRenderBatches.length === 0)
              for (const se of this._pendingGroundEffectLayers) {
                const oe = s.style._mergedLayers[z[se]];
                if (oe.isHidden(s.transform.zoom))
                  continue;
                const ce = s.style.getLayerSourceCache(oe), _e = ce ? this.proxyToSource[N.key][ce.id] : [N];
                if (!_e)
                  continue;
                const pe = _e;
                h.viewport.set([0, 0, W.fb.width, W.fb.height]), ee !== (ce ? ce.id : null) && (this._setupStencil(W, _e, oe, ce), ee = ce ? ce.id : null), s.renderLayer(s, ce, oe, pe);
              }
            this.renderedToTile ? (W.dirty = !0, R.push(j.tileID)) : te || --F, F === 5 && (F = 0, this.renderToBackBuffer(R));
          }
          return this.renderToBackBuffer(R), this.renderingToTexture = !1, h.bindFramebuffer.set(null), h.viewport.set([0, 0, s.width, s.height]), T.end + 1;
        }
        postRender() {
        }
        isLayerOrderingCorrect(t) {
          const s = t.order.length;
          let h = -1, m = s;
          for (let g = 0; g < s; ++g)
            this._style.isLayerDraped(t._mergedLayers[t.order[g]]) ? h = Math.max(h, g) : m = Math.min(m, g);
          return m > h;
        }
        getMinElevationBelowMSL() {
          let t = 0;
          return this._visibleDemTiles.filter((s) => s.dem).forEach((s) => {
            t = Math.min(t, s.dem.tree.minimums[0]);
          }), t === 0 ? t : (t - 30) * this._exaggeration;
        }
        raycast(t, s, h) {
          if (!this._visibleDemTiles)
            return null;
          const m = this._visibleDemTiles.filter((g) => g.dem).map((g) => {
            const T = g.tileID, z = 1 << T.overscaledZ, { x: R, y: F } = T.canonical, N = R / z, j = (R + 1) / z, G = F / z, W = (F + 1) / z;
            return { minx: N, miny: G, maxx: j, maxy: W, t: g.dem.tree.raycastRoot(N, G, j, W, t, s, h), tile: g };
          });
          m.sort((g, T) => (g.t !== null ? g.t : Number.MAX_VALUE) - (T.t !== null ? T.t : Number.MAX_VALUE));
          for (const g of m) {
            if (g.t == null)
              return null;
            const T = g.tile.dem.tree.raycast(g.minx, g.miny, g.maxx, g.maxy, t, s, h);
            if (T != null)
              return T;
          }
          return null;
        }
        _createFBO() {
          const t = this.painter.context, s = t.gl, h = this.drapeBufferSize;
          t.activeTexture.set(s.TEXTURE0);
          const m = new i.T(t, { width: h[0], height: h[1], data: null }, s.RGBA8);
          m.bind(s.LINEAR, s.CLAMP_TO_EDGE);
          const g = t.createFramebuffer(h[0], h[1], !0, null);
          return g.colorAttachment.set(m.texture), g.depthAttachment = new $h(t, g.framebuffer), this._sharedDepthStencil === void 0 ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, h[0], h[1]), this._stencilRef = 0, g.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : g.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && s.texParameterf(s.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: g, tex: m, dirty: !1 };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._debugParams.disableRenderCache || this._style.hasLightTransitions())
            return !0;
          for (const t in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[t].hasTransition())
              return !0;
          return this._style.order.some((t) => {
            const s = this._style._mergedLayers[t], h = s.isHidden(this.painter.transform.zoom);
            return s.type === "hillshade" || s.type === "custom" ? !h && s.shouldRedrape() : !h && s.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t = !1;
          for (const h of this._style.getSources())
            if (h instanceof Uo) {
              t = !0;
              break;
            }
          if (!t)
            return;
          const s = {};
          for (let h = 0; h < this._style.order.length; ++h) {
            const m = this._style._mergedLayers[this._style.order[h]], g = this._style.getLayerSourceCache(m);
            if (g && !s[g.id] && !m.isHidden(this.painter.transform.zoom) && m.type === "line" && m.widthExpression() instanceof i.a9) {
              s[g.id] = !0;
              for (const T of this.proxyCoords) {
                const z = this.proxyToSource[T.key][g.id];
                if (z)
                  for (const R of z)
                    this._clearRenderCacheForTile(g.id, R);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let t = !1;
          for (const h in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[h]._source instanceof tn) {
              t = !0;
              break;
            }
          if (!t)
            return;
          const s = {};
          for (let h = 0; h < this._style.order.length; ++h) {
            const m = this._style._mergedLayers[this._style.order[h]], g = this._style.getLayerSourceCache(m);
            if (!g || s[g.id] || m.isHidden(this.painter.transform.zoom) || m.type !== "raster")
              continue;
            const T = m.paint.get("raster-fade-duration");
            for (const z of this.proxyCoords) {
              const R = this.proxyToSource[z.key][g.id];
              if (R)
                for (const F of R) {
                  const N = Yh(g.getTile(F), g.findLoadedParent(F, 0), g, this.painter.transform, T);
                  (N.opacity !== 1 || N.mix !== 0) && this._clearRenderCacheForTile(g.id, F);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          this._style.updateDrapeFirstLayers();
          const t = this._style.order, s = t.length;
          if (s === 0)
            return;
          const h = [];
          this._pendingGroundEffectLayers = [];
          let m, g = 0, T = this._style._mergedLayers[t[g]];
          for (; !this._style.isLayerDraped(T) && T.isHidden(this.painter.transform.zoom) && ++g < s; )
            T = this._style._mergedLayers[t[g]];
          for (; g < s; ++g) {
            const z = this._style._mergedLayers[t[g]];
            z.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(z) ? m === void 0 && (m = g) : (z.type === "fill-extrusion" && this._pendingGroundEffectLayers.push(g), m !== void 0 && (h.push({ start: m, end: g - 1 }), m = void 0)));
          }
          if (m !== void 0 && h.push({ start: m, end: g - 1 }), h.length !== 0) {
            const z = h[h.length - 1];
            this._pendingGroundEffectLayers.every((R) => R > z.end) || i.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
          }
          this._drapedRenderBatches = h;
        }
        _setupRenderCache(t) {
          const s = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (this.invalidateRenderCache = !1, s.renderCache.length > s.renderCachePool.length) {
              const T = Object.values(s.proxyCachedFBO);
              s.proxyCachedFBO = {};
              for (let z = 0; z < T.length; ++z) {
                const R = Object.values(T[z]);
                s.renderCachePool.push(...R);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const h = this.proxyCoords, m = this._tilesDirty;
          for (let T = h.length - 1; T >= 0; T--) {
            const z = h[T];
            if (s.getTileByID(z.key), s.proxyCachedFBO[z.key] !== void 0) {
              const R = t[z.key], F = this.proxyToSource[z.key];
              let N = 0;
              for (const j in F) {
                const G = F[j], W = R[j];
                if (!W || W.length !== G.length || G.some((te, ee) => te !== W[ee] || m[j] && m[j].hasOwnProperty(te.key))) {
                  N = -1;
                  break;
                }
                ++N;
              }
              for (const j in s.proxyCachedFBO[z.key])
                s.renderCache[s.proxyCachedFBO[z.key][j]].dirty = N < 0 || N !== Object.values(R).length;
            }
          }
          const g = [...this._drapedRenderBatches];
          g.sort((T, z) => z.end - z.start - (T.end - T.start));
          for (const T of g)
            for (const z of h) {
              if (s.proxyCachedFBO[z.key])
                continue;
              let R = s.renderCachePool.pop();
              R === void 0 && s.renderCache.length < 50 && (R = s.renderCache.length, s.renderCache.push(this._createFBO())), R !== void 0 && (s.proxyCachedFBO[z.key] = {}, s.proxyCachedFBO[z.key][T.start] = R, s.renderCache[R].dirty = !0);
            }
          this._tilesDirty = {};
        }
        _setupStencil(t, s, h, m) {
          if (!m || !this._sourceTilesOverlap[m.id])
            return void (this._overlapStencilType && (this._overlapStencilType = !1));
          const g = this.painter.context, T = g.gl;
          if (s.length <= 1)
            return void (this._overlapStencilType = !1);
          let z;
          if (h.isTileClipped())
            z = s.length, this._overlapStencilMode.test = { func: T.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(s[0].overscaledZ > s[s.length - 1].overscaledZ))
              return void (this._overlapStencilType = !1);
            z = 1, this._overlapStencilMode.test = { func: T.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + z > 255 && (g.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += z, this._overlapStencilMode.ref = this._stencilRef, h.isTileClipped() && this._renderTileClippingMasks(s, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === "Clip" || this._overlapStencilType === "Mask";
        }
        stencilModeForRTTOverlap(t) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === "Clip" && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : ci.disabled;
        }
        _renderTileClippingMasks(t, s) {
          const h = this.painter, m = this.painter.context, g = m.gl;
          h._tileClippingMaskIDs = {}, m.setColorMode(bi.disabled), m.setDepthMode(Wt.disabled);
          const T = h.getOrCreateProgram("clippingMask");
          for (const z of t) {
            const R = h._tileClippingMaskIDs[z.key] = --s;
            T.draw(h, g.TRIANGLES, Wt.disabled, new ci({ func: g.ALWAYS, mask: 0 }, R, 255, g.KEEP, g.KEEP, g.REPLACE), bi.disabled, ti.disabled, tc(z.projMatrix), "$clipping", h.tileExtentBuffer, h.quadTriangleIndexBuffer, h.tileExtentSegments);
          }
        }
        pointCoordinate(t) {
          const s = this.painter.transform;
          if (t.x < 0 || t.x > s.width || t.y < 0 || t.y > s.height)
            return null;
          const h = [t.x, t.y, 1, 1];
          i.ab.vec4.transformMat4(h, h, s.pixelMatrixInverse), i.ab.vec4.scale(h, h, 1 / h[3]), h[0] /= s.worldSize, h[1] /= s.worldSize;
          const m = s._camera.position, g = i.bH(1, s.center.lat), T = [m[0], m[1], m[2] / g, 0], z = i.ab.vec3.subtract([], h.slice(0, 3), T);
          i.ab.vec3.normalize(z, z);
          const R = this.raycast(T, z, this._exaggeration);
          return R !== null && R ? (i.ab.vec3.scaleAndAdd(T, T, z, R), T[3] = T[2], T[2] *= g, T) : null;
        }
        _setupProxiedCoordsForOrtho(t, s, h) {
          if (t.getSource() instanceof i.aJ)
            return this._setupProxiedCoordsForImageSource(t, s, h);
          this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
          const m = this.proxiedCoords[t.id] = [], g = this.proxyCoords;
          for (let R = 0; R < g.length; R++) {
            const F = g[R], N = this._findTileCoveringTileID(F, t);
            if (N) {
              const j = this._createProxiedId(F, N, h[F.key] && h[F.key][t.id]);
              m.push(j), this.proxyToSource[F.key][t.id] = [j];
            }
          }
          let T = !1;
          const z = /* @__PURE__ */ new Set();
          for (let R = 0; R < s.length; R++) {
            const F = t.getTile(s[R]);
            if (!F || !F.hasData())
              continue;
            const N = this._findTileCoveringTileID(F.tileID, this.proxySourceCache);
            if (N && N.tileID.canonical.z !== F.tileID.canonical.z) {
              const j = this.proxyToSource[N.tileID.key][t.id], G = this._createProxiedId(N.tileID, F, h[N.tileID.key] && h[N.tileID.key][t.id]);
              j ? j.splice(j.length - 1, 0, G) : this.proxyToSource[N.tileID.key][t.id] = [G];
              const W = this.proxyToSource[N.tileID.key][t.id];
              z.has(W) || z.add(W), m.push(G), T = !0;
            }
          }
          if (this._sourceTilesOverlap[t.id] = T, T && this._debugParams.sortTilesHiZFirst)
            for (const R of z)
              R.sort((F, N) => N.overscaledZ - F.overscaledZ);
        }
        _setupProxiedCoordsForImageSource(t, s, h) {
          if (!t.getSource().loaded())
            return;
          const m = this.proxiedCoords[t.id] = [], g = this.proxyCoords, T = t.getSource(), z = T.tileID;
          if (!z)
            return;
          const R = new i.P(z.x, z.y)._div(1 << z.z), F = T.coordinates.map(i.aa.fromLngLat).reduce((j, G) => (j.min.x = Math.min(j.min.x, G.x - R.x), j.min.y = Math.min(j.min.y, G.y - R.y), j.max.x = Math.max(j.max.x, G.x - R.x), j.max.y = Math.max(j.max.y, G.y - R.y), j), { min: new i.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new i.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), N = (j, G) => {
            const W = j.wrap + j.canonical.x / (1 << j.canonical.z), te = j.canonical.y / (1 << j.canonical.z), ee = i.ag / (1 << j.canonical.z), se = G.wrap + G.canonical.x / (1 << G.canonical.z), oe = G.canonical.y / (1 << G.canonical.z);
            return W + ee < se + F.min.x || W > se + F.max.x || te + ee < oe + F.min.y || te > oe + F.max.y;
          };
          for (let j = 0; j < g.length; j++) {
            const G = g[j];
            for (let W = 0; W < s.length; W++) {
              const te = t.getTile(s[W]);
              if (!te || !te.hasData() || N(G, te.tileID))
                continue;
              const ee = this._createProxiedId(G, te, h[G.key] && h[G.key][t.id]), se = this.proxyToSource[G.key][t.id];
              se ? se.push(ee) : this.proxyToSource[G.key][t.id] = [ee], m.push(ee);
            }
          }
        }
        _createProxiedId(t, s, h) {
          let m = this.orthoMatrix;
          if (h) {
            const g = h.find((T) => T.key === s.tileID.key);
            if (g)
              return g;
          }
          if (s.tileID.key !== t.key) {
            const g = t.canonical.z - s.tileID.canonical.z;
            let T, z, R;
            m = i.ab.mat4.create();
            const F = s.tileID.wrap - t.wrap << t.overscaledZ;
            g > 0 ? (T = i.ag >> g, z = T * ((s.tileID.canonical.x << g) - t.canonical.x + F), R = T * ((s.tileID.canonical.y << g) - t.canonical.y)) : (T = i.ag << -g, z = i.ag * (s.tileID.canonical.x - (t.canonical.x + F << -g)), R = i.ag * (s.tileID.canonical.y - (t.canonical.y << -g))), i.ab.mat4.ortho(m, 0, T, 0, T, 0, 1), i.ab.mat4.translate(m, m, [z, R, 0]);
          }
          return new Kh(s.tileID, t.key, m);
        }
        _findTileCoveringTileID(t, s) {
          let h = s.getTile(t);
          if (h && h.hasData())
            return h;
          const m = this._findCoveringTileCache[s.id], g = m[t.key];
          if (h = g ? s.getTileByID(g) : null, h && h.hasData() || g === null)
            return h;
          let T = h ? h.tileID : t, z = T.overscaledZ;
          const R = s.getSource().minzoom, F = [];
          if (!g) {
            const j = s.getSource().maxzoom;
            if (t.canonical.z >= j) {
              const G = t.canonical.z - j;
              s.getSource().reparseOverscaled ? (z = Math.max(t.canonical.z + 2, s.transform.tileZoom), T = new i.aG(z, t.wrap, j, t.canonical.x >> G, t.canonical.y >> G)) : G !== 0 && (z = j, T = new i.aG(z, t.wrap, j, t.canonical.x >> G, t.canonical.y >> G));
            }
            T.key !== t.key && (F.push(T.key), h = s.getTile(T));
          }
          const N = (j) => {
            F.forEach((G) => {
              m[G] = j;
            }), F.length = 0;
          };
          for (z -= 1; z >= R && (!h || !h.hasData()); z--) {
            h && N(h.tileID.key);
            const j = T.calculateScaledKey(z);
            if (h = s.getTileByID(j), h && h.hasData())
              break;
            const G = m[j];
            if (G === null)
              break;
            G === void 0 ? F.push(j) : h = s.getTileByID(G);
          }
          return N(h ? h.tileID.key : null), h && h.hasData() ? h : null;
        }
        findDEMTileFor(t) {
          return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = !0;
        }
        _clearRenderCacheForTile(t, s) {
          let h = this._tilesDirty[t];
          h || (h = this._tilesDirty[t] = {}), h[s.key] = !0;
        }
      }
      function Gf(c, t, s) {
        const h = function(z, R, F) {
          const N = i.ab.vec3.dot(R, z), j = i.ab.vec3.dot(F, [0.2126, 0.7152, 0.0722]), G = (te, ee, se) => (1 - se) * te + se * ee, W = G(1 - 0.3 * Math.min(j, 1), 1, Math.min(N + 1, 1));
          return G(0.92, 1, Math.asin(i.aw(R[2], -1, 1)) / Math.PI + 0.5) * W;
        }(c, [0, 0, 1], t), m = [0, 0, 0];
        i.ab.vec3.scale(m, s.slice(0, 3), h);
        const g = [0, 0, 0];
        i.ab.vec3.scale(g, t.slice(0, 3), c[2]);
        const T = [0, 0, 0];
        return i.ab.vec3.add(T, m, g), i.cf(T);
      }
      const Xc = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], qm = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "model", "symbol"];
      class Zf {
        static cacheKey(t, s, h, m) {
          let g = `${s}${m ? m.cacheKey : ""}`;
          for (const T of h)
            t.usedDefines.includes(T) && (g += `/${T}`);
          return g;
        }
        constructor(t, s, h, m, g, T) {
          const z = t.gl;
          this.program = z.createProgram(), this.configuration = m, this.name = s, this.fixedDefines = [...T];
          const R = m ? m.getBinderAttributes() : [], F = (h.staticAttributes || []).concat(R);
          let N = m ? m.defines() : [];
          N = N.concat(T.map((se) => `#define ${se}`));
          const j = `#version 300 es
`;
          let G = j + N.concat("precision mediump float;", Qr, Yl.fragmentSource).join(`
`);
          for (const se of h.fragmentIncludes)
            G += `
${oo[se]}`;
          G += `
${h.fragmentSource}`;
          let W = j + N.concat("precision highp float;", Qr, Yl.vertexSource).join(`
`);
          for (const se of h.vertexIncludes)
            W += `
${oo[se]}`;
          this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && h.vertexSource.indexOf("gl_InstanceID") !== -1, this.forceManualRenderingForInstanceIDShaders && (W += `
uniform int u_instanceID;
`), W += `
${h.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (W = W.replaceAll("gl_InstanceID", "u_instanceID"));
          const te = z.createShader(z.FRAGMENT_SHADER);
          if (z.isContextLost())
            return void (this.failedToCreate = !0);
          z.shaderSource(te, G), z.compileShader(te), z.attachShader(this.program, te);
          const ee = z.createShader(z.VERTEX_SHADER);
          if (z.isContextLost())
            this.failedToCreate = !0;
          else {
            z.shaderSource(ee, W), z.compileShader(ee), z.attachShader(this.program, ee), this.attributes = {}, this.numAttributes = F.length;
            for (let se = 0; se < this.numAttributes; se++)
              if (F[se]) {
                const oe = F[se].startsWith("a_") ? F[se] : `a_${F[se]}`;
                z.bindAttribLocation(this.program, se, oe), this.attributes[oe] = se;
              }
            z.linkProgram(this.program), z.deleteShader(ee), z.deleteShader(te), this.fixedUniforms = g(t), this.binderUniforms = m ? m.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((se) => ({ u_instanceID: new i.bN(se) }))(t)), (T.includes("TERRAIN") || s.indexOf("symbol") !== -1 || s.indexOf("circle") !== -1) && (this.terrainUniforms = ((se) => ({ u_dem: new i.bN(se), u_dem_prev: new i.bN(se), u_dem_tl: new i.bK(se), u_dem_scale: new i.bM(se), u_dem_tl_prev: new i.bK(se), u_dem_scale_prev: new i.bM(se), u_dem_size: new i.bM(se), u_dem_lerp: new i.bM(se), u_exaggeration: new i.bM(se), u_depth: new i.bN(se), u_depth_size_inv: new i.bK(se), u_depth_range_unpack: new i.bK(se), u_occluder_half_size: new i.bM(se), u_occlusion_depth_offset: new i.bM(se), u_meter_to_dem: new i.bM(se), u_label_plane_matrix_inv: new i.bJ(se) }))(t)), T.includes("GLOBE") && (this.globeUniforms = ((se) => ({ u_tile_tl_up: new i.bL(se), u_tile_tr_up: new i.bL(se), u_tile_br_up: new i.bL(se), u_tile_bl_up: new i.bL(se), u_tile_up_scale: new i.bM(se) }))(t)), T.includes("FOG") && (this.fogUniforms = ((se) => ({ u_fog_matrix: new i.bJ(se), u_fog_range: new i.bK(se), u_fog_color: new i.ca(se), u_fog_horizon_blend: new i.bM(se), u_fog_vertical_limit: new i.bK(se), u_fog_temporal_offset: new i.bM(se), u_frustum_tl: new i.bL(se), u_frustum_tr: new i.bL(se), u_frustum_br: new i.bL(se), u_frustum_bl: new i.bL(se), u_globe_pos: new i.bL(se), u_globe_radius: new i.bM(se), u_globe_transition: new i.bM(se), u_is_globe: new i.bN(se), u_viewport: new i.bK(se) }))(t)), T.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((se) => ({ u_cutoff_params: new i.ca(se) }))(t)), T.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((se) => ({ u_lighting_ambient_color: new i.bL(se), u_lighting_directional_dir: new i.bL(se), u_lighting_directional_color: new i.bL(se), u_ground_radiance: new i.bL(se) }))(t)), T.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((se) => ({ u_light_matrix_0: new i.bJ(se), u_light_matrix_1: new i.bJ(se), u_fade_range: new i.bK(se), u_shadow_normal_offset: new i.bL(se), u_shadow_intensity: new i.bM(se), u_shadow_texel_size: new i.bM(se), u_shadow_map_resolution: new i.bM(se), u_shadow_direction: new i.bL(se), u_shadow_bias: new i.bL(se), u_shadowmap_0: new i.bN(se), u_shadowmap_1: new i.bN(se) }))(t));
          }
        }
        setTerrainUniformValues(t, s) {
          if (!this.terrainUniforms)
            return;
          const h = this.terrainUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const m in s)
              h[m] && h[m].set(this.program, m, s[m]);
          }
        }
        setGlobeUniformValues(t, s) {
          if (!this.globeUniforms)
            return;
          const h = this.globeUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const m in s)
              h[m] && h[m].set(this.program, m, s[m]);
          }
        }
        setFogUniformValues(t, s) {
          if (!this.fogUniforms)
            return;
          const h = this.fogUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const m in s)
              h[m].set(this.program, m, s[m]);
          }
        }
        setCutoffUniformValues(t, s) {
          if (!this.cutoffUniforms)
            return;
          const h = this.cutoffUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const m in s)
              h[m].set(this.program, m, s[m]);
          }
        }
        setLightsUniformValues(t, s) {
          if (!this.lightsUniforms)
            return;
          const h = this.lightsUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const m in s)
              h[m].set(this.program, m, s[m]);
          }
        }
        setShadowUniformValues(t, s) {
          if (this.failedToCreate || !this.shadowUniforms)
            return;
          const h = this.shadowUniforms;
          t.program.set(this.program);
          for (const m in s)
            h[m].set(this.program, m, s[m]);
        }
        _drawDebugWireframe(t, s, h, m, g, T, z, R, F, N) {
          const j = t.options.wireframe;
          if (j.terrain === !1 && j.layers2D === !1 && j.layers3D === !1)
            return;
          const G = t.context;
          if (!(() => !(!j.terrain || this.name !== "terrainRaster" && this.name !== "globeRaster") || !(!j.layers2D || t._terrain && t._terrain.renderingToTexture || !Xc.includes(this.name)) || !(!j.layers3D || !qm.includes(this.name)))())
            return;
          const W = G.gl, te = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, g, G);
          if (!te)
            return;
          const ee = [...this.fixedDefines];
          ee.push("DEBUG_WIREFRAME");
          const se = t.getOrCreateProgram(this.name, { config: this.configuration, defines: ee });
          G.program.set(se.program);
          const oe = (pe, Te, xe) => {
            if (Te[pe] && xe[pe])
              for (const be in Te[pe])
                xe[pe][be] && xe[pe][be].set(xe.program, be, Te[pe][be].current);
          };
          F && F.setUniforms(se.program, G, se.binderUniforms, z, { zoom: R }), oe("fixedUniforms", this, se), oe("terrainUniforms", this, se), oe("globeUniforms", this, se), oe("fogUniforms", this, se), oe("lightsUniforms", this, se), oe("shadowUniforms", this, se), te.bind(), G.setColorMode(new bi([W.ONE, W.ONE_MINUS_SRC_ALPHA, W.ZERO, W.ONE], i.aj.transparent, [!0, !0, !0, !1])), G.setDepthMode(new Wt(s.func === W.LESS ? W.LEQUAL : s.func, Wt.ReadOnly, s.range)), G.setStencilMode(ci.disabled);
          const ce = 3 * T.primitiveLength * 2, _e = 3 * T.primitiveOffset * 2 * 2;
          if (this.forceManualRenderingForInstanceIDShaders) {
            const pe = N || 1;
            for (let Te = 0; Te < pe; ++Te)
              se.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", Te), W.drawElements(W.LINES, ce, W.UNSIGNED_SHORT, _e);
          } else
            N && N > 1 ? W.drawElementsInstanced(W.LINES, ce, W.UNSIGNED_SHORT, _e, N) : W.drawElements(W.LINES, ce, W.UNSIGNED_SHORT, _e);
          g.bind(), G.program.set(this.program), G.setDepthMode(s), G.setStencilMode(h), G.setColorMode(m);
        }
        checkUniforms(t, s, h) {
          if (this.fixedDefines.includes(s)) {
            for (const m of Object.keys(h))
              if (!h[m].initialized)
                throw new Error(`Program '${this.name}', from draw '${t}': uniform ${m} not set but required by ${s} being defined`);
          }
        }
        draw(t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se) {
          const oe = t.context, ce = oe.gl;
          if (this.failedToCreate)
            return;
          oe.program.set(this.program), oe.setDepthMode(h), oe.setStencilMode(m), oe.setColorMode(g), oe.setCullFace(T);
          for (const Te of Object.keys(this.fixedUniforms))
            this.fixedUniforms[Te].set(this.program, Te, z[Te]);
          te && te.setUniforms(this.program, oe, this.binderUniforms, G, { zoom: W });
          const _e = { [ce.POINTS]: 1, [ce.LINES]: 2, [ce.TRIANGLES]: 3, [ce.LINE_STRIP]: 1 }[s];
          this.checkUniforms(R, "RENDER_SHADOWS", this.shadowUniforms);
          const pe = se && se > 0 ? 1 : void 0;
          for (const Te of j.get()) {
            const xe = Te.vaos || (Te.vaos = {});
            if ((xe[R] || (xe[R] = new Zh())).bind(oe, this, F, te ? te.getPaintVertexBuffers() : [], N, Te.vertexOffset, ee || [], pe), this.forceManualRenderingForInstanceIDShaders) {
              const be = se || 1;
              for (let ve = 0; ve < be; ++ve)
                this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", ve), N ? ce.drawElements(s, Te.primitiveLength * _e, ce.UNSIGNED_SHORT, Te.primitiveOffset * _e * 2) : ce.drawArrays(s, Te.vertexOffset, Te.vertexLength);
            } else
              se && se > 1 ? ce.drawElementsInstanced(s, Te.primitiveLength * _e, ce.UNSIGNED_SHORT, Te.primitiveOffset * _e * 2, se) : N ? ce.drawElements(s, Te.primitiveLength * _e, ce.UNSIGNED_SHORT, Te.primitiveOffset * _e * 2) : ce.drawArrays(s, Te.vertexOffset, Te.vertexLength);
            s === ce.TRIANGLES && N && this._drawDebugWireframe(t, h, m, g, N, Te, G, W, te, se);
          }
        }
      }
      function rd(c, t) {
        const s = Math.pow(2, t.tileID.overscaledZ), h = t.tileSize * Math.pow(2, c.transform.tileZoom) / s, m = h * (t.tileID.canonical.x + t.tileID.wrap * s), g = h * t.tileID.canonical.y;
        return { u_image: 0, u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / i.ar(t, 1, c.transform.tileZoom), u_pixel_coord_upper: [m >> 16, g >> 16], u_pixel_coord_lower: [65535 & m, 65535 & g] };
      }
      const Jh = { terrain: 0, flat: 1 }, od = i.ab.mat4.create(), Qh = (c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe) => {
        const ce = t.style.light, _e = ce.properties.get("position"), pe = [_e.x, _e.y, _e.z], Te = i.ab.mat3.create();
        ce.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(Te, -t.transform.angle), i.ab.vec3.transformMat3(pe, pe, Te));
        const xe = ce.properties.get("color"), be = t.transform, ve = { u_matrix: c, u_lightpos: pe, u_lightintensity: ce.properties.get("intensity"), u_lightcolor: [xe.r, xe.g, xe.b], u_vertical_gradient: +s, u_opacity: h, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: od, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: Jh[F], u_base_type: Jh[N], u_ao: m, u_edge_radius: g, u_width_scale: T, u_flood_light_color: te, u_vertical_scale: ee, u_flood_light_intensity: se, u_ground_shadow_factor: oe };
        return be.projection.name === "globe" && (ve.u_tile_id = [z.canonical.x, z.canonical.y, 1 << z.canonical.z], ve.u_zoom_transition = j, ve.u_inv_rot_matrix = W, ve.u_merc_center = G, ve.u_up_dir = be.projection.upVector(new i.bT(0, 0, 0), G[0] * i.ag, G[1] * i.ag), ve.u_height_lift = R), ve;
      }, Yc = (c, t, s, h, m, g) => ({ u_matrix: c, u_edge_radius: t, u_width_scale: s, u_vertical_scale: h, u_height_type: Jh[m], u_base_type: Jh[g] }), ad = (c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se) => {
        const oe = Qh(c, t, s, h, m, g, T, z, F, N, j, G, W, te, ee, se, 1, [0, 0, 0]), ce = { u_height_factor: -Math.pow(2, z.overscaledZ) / R.tileSize / 8 };
        return i.l(oe, rd(t, R), ce);
      }, ic = (c, t) => ({ u_matrix: c, u_emissive_strength: t }), ld = (c, t, s, h) => i.l(ic(c, t), rd(s, h)), eu = (c, t, s) => ({ u_matrix: c, u_world: s, u_emissive_strength: t }), tu = (c, t, s, h, m) => i.l(ld(c, t, s, h), { u_world: m }), cd = (c, t, s, h) => {
        const m = i.ag / s.tileSize;
        return { u_matrix: c, u_camera_to_center_distance: t.getCameraToCenterDistance(h), u_extrude_scale: [t.pixelsToGLUnits[0] / m, t.pixelsToGLUnits[1] / m] };
      }, hd = (c, t, s = 1) => ({ u_matrix: c, u_color: t.toRenderColor(null), u_overlay: 0, u_overlay_scale: s }), Wm = i.ab.mat4.create(), nc = (c, t, s, h, m, g, T) => {
        const z = c.transform, R = z.projection.name === "globe", F = R ? i.cN(z.zoom, t.canonical) * z._pixelsPerMercatorPixel : i.ar(s, 1, g), N = { u_matrix: t.projMatrix, u_extrude_scale: F, u_intensity: T, u_inv_rot_matrix: Wm, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
        if (R) {
          N.u_inv_rot_matrix = h, N.u_merc_center = m, N.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z], N.u_zoom_transition = i.ae(z.zoom);
          const j = m[0] * i.ag, G = m[1] * i.ag;
          N.u_up_dir = z.projection.upVector(new i.bT(0, 0, 0), j, G);
        }
        return N;
      };
      function Kc(c, [t, s, h, m], [g, T]) {
        if (g === T)
          return [0, 0, 0, 0];
        const z = 255 * (c - 1) / (c * (T - g));
        return [t * z, s * z, h * z, m * z];
      }
      function Ft(c, t, [s, h]) {
        return s === h ? 0 : 0.5 / c + (t - s) * (c - 1) / (c * (h - s));
      }
      const ud = (c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe, ce, _e, pe) => ({ u_matrix: c, u_normalize_matrix: t, u_globe_matrix: s, u_merc_matrix: h, u_grid_matrix: m, u_tl_parent: g, u_scale_parent: F, u_fade_t: N.mix, u_opacity: N.opacity * j.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: j.paint.get("raster-brightness-min"), u_brightness_high: j.paint.get("raster-brightness-max"), u_saturation_factor: i.cO(j.paint.get("raster-saturation")), u_contrast_factor: i.cP(j.paint.get("raster-contrast")), u_spin_weights: Hf(j.paint.get("raster-hue-rotate")), u_perspective_transform: G, u_raster_elevation: W, u_zoom_transition: T, u_merc_center: z, u_cutoff_params: R, u_colorization_mix: Kc(i.cQ, ee, oe), u_colorization_offset: Ft(i.cQ, se, oe), u_color_ramp: te, u_texture_offset: [_e / (ce + 2 * _e), ce / (ce + 2 * _e)], u_texture_res: [ce + 2 * _e, ce + 2 * _e], u_emissive_strength: pe });
      function Hf(c) {
        c *= Math.PI / 180;
        const t = Math.sin(c), s = Math.cos(c);
        return [(2 * s + 1) / 3, (-Math.sqrt(3) * t - s + 1) / 3, (Math.sqrt(3) * t - s + 1) / 3];
      }
      const lo = 0.05, bl = (c, t, s, h, m, g, T, z, R, F, N, j) => ({ u_matrix: c, u_normalize_matrix: t, u_globe_matrix: s, u_merc_matrix: h, u_grid_matrix: m, u_tl_parent: g, u_scale_parent: F, u_fade_t: N.mix, u_opacity: N.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: j, u_zoom_transition: T, u_merc_center: z, u_cutoff_params: R }), Zt = (c, t, s, h, m, g, T, z, R, F) => ({ u_particle_texture: c, u_particle_texture_side_len: t, u_tile_offset: s, u_velocity: h, u_color_ramp: g, u_velocity_res: m, u_max_speed: T, u_uv_offset: z, u_data_scale: [255 * R[0], 255 * R[1]], u_data_offset: F, u_particle_pos_scale: 1.1, u_particle_pos_offset: [lo, lo] }), dd = (c, t, s, h, m, g, T, z, R, F) => ({ u_particle_texture: c, u_particle_texture_side_len: t, u_velocity: s, u_velocity_res: h, u_max_speed: m, u_speed_factor: g, u_reset_rate: T, u_rand_seed: Math.random(), u_uv_offset: z, u_data_scale: [255 * R[0], 255 * R[1]], u_data_offset: F, u_particle_pos_scale: 1.1, u_particle_pos_offset: [lo, lo] }), qf = i.ab.mat4.create(), Wf = (c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe, ce, _e, pe, Te) => {
        const xe = m.transform, be = { u_is_size_zoom_constant: +(c === "constant" || c === "source"), u_is_size_feature_constant: +(c === "constant" || c === "camera"), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: xe.getCameraToCenterDistance(ce), u_rotate_symbol: +s, u_aspect_ratio: xe.width / xe.height, u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1, u_matrix: g, u_label_plane_matrix: T, u_coord_matrix: z, u_is_text: +F, u_elevation_from_sea: R ? 1 : 0, u_pitch_with_map: +h, u_texsize: N, u_texsize_icon: j, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: qf, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: qf, u_up_vector: [0, -1, 0], u_color_adj_mat: _e, u_icon_transition: pe || 0, u_gamma_scale: h ? m.transform.getCameraToCenterDistance(ce) * Math.cos(m.terrain ? 0 : m.transform._pitch) : 1, u_device_pixel_ratio: i.q.devicePixelRatio, u_is_halo: +G, u_scale_factor: Te || 1 };
        return ce.name === "globe" && (be.u_tile_id = [W.canonical.x, W.canonical.y, 1 << W.canonical.z], be.u_zoom_transition = te, be.u_inv_rot_matrix = se, be.u_merc_center = ee, be.u_camera_forward = xe._camera.forward(), be.u_ecef_origin = i.cR(xe.globeMatrix, W.toUnwrapped()), be.u_tile_matrix = Float32Array.from(xe.globeMatrix), be.u_up_vector = oe), be;
      }, iu = (c, t, s, h) => ({ u_matrix: c, u_emissive_strength: t, u_opacity: s, u_color: h }), fd = (c, t, s, h, m, g, T, z, R) => i.l(function(F, N, j, G, W, te) {
        const { width: ee, height: se } = G.imageManager.getPixelSize(N), oe = Math.pow(2, te.tileID.overscaledZ), ce = te.tileSize * Math.pow(2, G.transform.tileZoom) / oe, _e = ce * (te.tileID.canonical.x + te.tileID.wrap * oe), pe = ce * te.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl: j.tl, u_pattern_br: j.br, u_texsize: [ee, se], u_pattern_size: j.displaySize, u_pattern_units_to_pixels: W ? [G.transform.width, -1 * G.transform.height] : [1 / i.ar(te, 1, G.transform.tileZoom), 1 / i.ar(te, 1, G.transform.tileZoom)], u_pixel_coord_upper: [_e >> 16, pe >> 16], u_pixel_coord_lower: [65535 & _e, 65535 & pe] };
      }(0, g, T, h, z, R), { u_matrix: c, u_emissive_strength: t, u_opacity: s }), nu = new Float32Array(i.ab.mat4.identity([])), pd = (c, t, s, h, m, g, T, z, R, F, N, j, G, W = [0, 0, 0], te) => {
        const ee = m.style.light, se = ee.properties.get("position"), oe = [-se.x, -se.y, se.z], ce = i.ab.mat3.create();
        ee.properties.get("anchor") === "viewport" && (i.ab.mat3.fromRotation(ce, -m.transform.angle), i.ab.vec3.transformMat3(oe, oe, ce));
        const _e = N.alphaMode === "MASK", pe = ee.properties.get("color").toRenderColor(null), Te = G.paint.get("model-ambient-occlusion-intensity"), xe = G.paint.get("model-color").constantOr(i.aj.white).toRenderColor(null), be = G.paint.get("model-color-mix-intensity").constantOr(0);
        return { u_matrix: c, u_lighting_matrix: t, u_normal_matrix: s, u_node_matrix: h || nu, u_lightpos: oe, u_lightintensity: ee.properties.get("intensity"), u_lightcolor: [pe.r, pe.g, pe.b], u_camera_pos: W, u_opacity: g, u_baseTextureIsAlpha: 0, u_alphaMask: +_e, u_alphaCutoff: N.alphaCutoff, u_baseColorFactor: [T.r, T.g, T.b, T.a], u_emissiveFactor: [z[0], z[1], z[2], 1], u_metallicFactor: R, u_roughnessFactor: F, u_baseColorTexture: bs.BaseColor, u_metallicRoughnessTexture: bs.MetallicRoughness, u_normalTexture: bs.Normal, u_occlusionTexture: bs.Occlusion, u_emissionTexture: bs.Emission, u_lutTexture: bs.LUT, u_color_mix: [xe.r, xe.g, xe.b, be], u_aoIntensity: Te, u_emissive_strength: j, u_occlusionTextureTransform: te || [0, 0, 0, 0] };
      }, $f = (c, t = nu, s = nu) => ({ u_matrix: c, u_instance: t, u_node_matrix: s }), md = { fillExtrusion: (c) => ({ u_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_vertical_gradient: new i.bM(c), u_opacity: new i.bM(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_ao: new i.bK(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_up_dir: new i.bL(c), u_height_lift: new i.bM(c), u_flood_light_color: new i.bL(c), u_vertical_scale: new i.bM(c), u_flood_light_intensity: new i.bM(c), u_ground_shadow_factor: new i.bL(c) }), fillExtrusionDepth: (c) => ({ u_matrix: new i.bJ(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_vertical_scale: new i.bM(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c) }), fillExtrusionPattern: (c) => ({ u_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_vertical_gradient: new i.bM(c), u_height_factor: new i.bM(c), u_edge_radius: new i.bM(c), u_width_scale: new i.bM(c), u_ao: new i.bK(c), u_height_type: new i.bN(c), u_base_type: new i.bN(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_up_dir: new i.bL(c), u_height_lift: new i.bM(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c), u_opacity: new i.bM(c) }), fillExtrusionGroundEffect: (c) => ({ u_matrix: new i.bJ(c), u_opacity: new i.bM(c), u_ao_pass: new i.bM(c), u_meter_to_tile: new i.bM(c), u_ao: new i.bK(c), u_flood_light_intensity: new i.bM(c), u_flood_light_color: new i.bL(c), u_attenuation: new i.bM(c), u_edge_radius: new i.bM(c), u_fb: new i.bN(c), u_fb_size: new i.bM(c), u_dynamic_offset: new i.bM(c) }), fill: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c) }), fillPattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c) }), fillOutline: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_world: new i.bK(c) }), fillOutlinePattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_world: new i.bK(c), u_image: new i.bN(c), u_texsize: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_tile_units_to_pixels: new i.bM(c) }), circle: i.cS, collisionBox: (c) => ({ u_matrix: new i.bJ(c), u_camera_to_center_distance: new i.bM(c), u_extrude_scale: new i.bK(c) }), collisionCircle: (c) => ({ u_matrix: new i.bJ(c), u_inv_matrix: new i.bJ(c), u_camera_to_center_distance: new i.bM(c), u_viewport_size: new i.bK(c) }), debug: (c) => ({ u_color: new i.cz(c), u_matrix: new i.bJ(c), u_overlay: new i.bN(c), u_overlay_scale: new i.bM(c) }), clippingMask: (c) => ({ u_matrix: new i.bJ(c) }), heatmap: (c) => ({ u_extrude_scale: new i.bM(c), u_intensity: new i.bM(c), u_matrix: new i.bJ(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_up_dir: new i.bL(c) }), heatmapTexture: (c) => ({ u_image: new i.bN(c), u_color_ramp: new i.bN(c), u_opacity: new i.bM(c) }), hillshade: (c) => ({ u_matrix: new i.bJ(c), u_image: new i.bN(c), u_latrange: new i.bK(c), u_light: new i.bK(c), u_shadow: new i.cz(c), u_highlight: new i.cz(c), u_emissive_strength: new i.bM(c), u_accent: new i.cz(c) }), hillshadePrepare: (c) => ({ u_matrix: new i.bJ(c), u_image: new i.bN(c), u_dimension: new i.bK(c), u_zoom: new i.bM(c) }), line: i.cT, linePattern: i.cU, raster: (c) => ({ u_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_grid_matrix: new i.cA(c), u_tl_parent: new i.bK(c), u_scale_parent: new i.bM(c), u_fade_t: new i.bM(c), u_opacity: new i.bM(c), u_image0: new i.bN(c), u_image1: new i.bN(c), u_brightness_low: new i.bM(c), u_brightness_high: new i.bM(c), u_saturation_factor: new i.bM(c), u_contrast_factor: new i.bM(c), u_spin_weights: new i.bL(c), u_perspective_transform: new i.bK(c), u_raster_elevation: new i.bM(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_cutoff_params: new i.ca(c), u_colorization_mix: new i.ca(c), u_colorization_offset: new i.bM(c), u_color_ramp: new i.bN(c), u_texture_offset: new i.bK(c), u_texture_res: new i.bK(c), u_emissive_strength: new i.bM(c) }), rasterParticle: (c) => ({ u_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_grid_matrix: new i.cA(c), u_tl_parent: new i.bK(c), u_scale_parent: new i.bM(c), u_fade_t: new i.bM(c), u_opacity: new i.bM(c), u_image0: new i.bN(c), u_image1: new i.bN(c), u_raster_elevation: new i.bM(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_cutoff_params: new i.ca(c) }), rasterParticleTexture: (c) => ({ u_texture: new i.bN(c), u_opacity: new i.bM(c) }), rasterParticleDraw: (c) => ({ u_particle_texture: new i.bN(c), u_particle_texture_side_len: new i.bM(c), u_tile_offset: new i.bK(c), u_velocity: new i.bN(c), u_color_ramp: new i.bN(c), u_velocity_res: new i.bK(c), u_max_speed: new i.bM(c), u_uv_offset: new i.bK(c), u_data_scale: new i.bK(c), u_data_offset: new i.bM(c), u_particle_pos_scale: new i.bM(c), u_particle_pos_offset: new i.bK(c) }), rasterParticleUpdate: (c) => ({ u_particle_texture: new i.bN(c), u_particle_texture_side_len: new i.bM(c), u_velocity: new i.bN(c), u_velocity_res: new i.bK(c), u_max_speed: new i.bM(c), u_speed_factor: new i.bM(c), u_reset_rate: new i.bM(c), u_rand_seed: new i.bM(c), u_uv_offset: new i.bK(c), u_data_scale: new i.bK(c), u_data_offset: new i.bM(c), u_particle_pos_scale: new i.bM(c), u_particle_pos_offset: new i.bK(c) }), symbol: (c) => ({ u_is_size_zoom_constant: new i.bN(c), u_is_size_feature_constant: new i.bN(c), u_size_t: new i.bM(c), u_size: new i.bM(c), u_camera_to_center_distance: new i.bM(c), u_rotate_symbol: new i.bN(c), u_aspect_ratio: new i.bM(c), u_fade_change: new i.bM(c), u_matrix: new i.bJ(c), u_label_plane_matrix: new i.bJ(c), u_coord_matrix: new i.bJ(c), u_is_text: new i.bN(c), u_elevation_from_sea: new i.bN(c), u_pitch_with_map: new i.bN(c), u_texsize: new i.bK(c), u_texsize_icon: new i.bK(c), u_texture: new i.bN(c), u_texture_icon: new i.bN(c), u_gamma_scale: new i.bM(c), u_device_pixel_ratio: new i.bM(c), u_tile_id: new i.bL(c), u_zoom_transition: new i.bM(c), u_inv_rot_matrix: new i.bJ(c), u_merc_center: new i.bK(c), u_camera_forward: new i.bL(c), u_tile_matrix: new i.bJ(c), u_up_vector: new i.bL(c), u_ecef_origin: new i.bL(c), u_is_halo: new i.bN(c), u_icon_transition: new i.bM(c), u_color_adj_mat: new i.bJ(c), u_scale_factor: new i.bM(c) }), background: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_opacity: new i.bM(c), u_color: new i.cz(c) }), backgroundPattern: (c) => ({ u_matrix: new i.bJ(c), u_emissive_strength: new i.bM(c), u_opacity: new i.bM(c), u_image: new i.bN(c), u_pattern_tl: new i.bK(c), u_pattern_br: new i.bK(c), u_texsize: new i.bK(c), u_pattern_size: new i.bK(c), u_pixel_coord_upper: new i.bK(c), u_pixel_coord_lower: new i.bK(c), u_pattern_units_to_pixels: new i.bK(c) }), terrainRaster: (c) => ({ u_matrix: new i.bJ(c), u_image0: new i.bN(c), u_skirt_height: new i.bM(c), u_ground_shadow_factor: new i.bL(c) }), skybox: (c) => ({ u_matrix: new i.bJ(c), u_sun_direction: new i.bL(c), u_cubemap: new i.bN(c), u_opacity: new i.bM(c), u_temporal_offset: new i.bM(c) }), skyboxGradient: (c) => ({ u_matrix: new i.bJ(c), u_color_ramp: new i.bN(c), u_center_direction: new i.bL(c), u_radius: new i.bM(c), u_opacity: new i.bM(c), u_temporal_offset: new i.bM(c) }), skyboxCapture: (c) => ({ u_matrix_3f: new i.cA(c), u_sun_direction: new i.bL(c), u_sun_intensity: new i.bM(c), u_color_tint_r: new i.ca(c), u_color_tint_m: new i.ca(c), u_luminance: new i.bM(c) }), globeRaster: (c) => ({ u_proj_matrix: new i.bJ(c), u_globe_matrix: new i.bJ(c), u_normalize_matrix: new i.bJ(c), u_merc_matrix: new i.bJ(c), u_zoom_transition: new i.bM(c), u_merc_center: new i.bK(c), u_image0: new i.bN(c), u_grid_matrix: new i.cA(c), u_skirt_height: new i.bM(c), u_far_z_cutoff: new i.bM(c), u_frustum_tl: new i.bL(c), u_frustum_tr: new i.bL(c), u_frustum_br: new i.bL(c), u_frustum_bl: new i.bL(c), u_globe_pos: new i.bL(c), u_globe_radius: new i.bM(c), u_viewport: new i.bK(c) }), globeAtmosphere: (c) => ({ u_frustum_tl: new i.bL(c), u_frustum_tr: new i.bL(c), u_frustum_br: new i.bL(c), u_frustum_bl: new i.bL(c), u_horizon: new i.bM(c), u_transition: new i.bM(c), u_fadeout_range: new i.bM(c), u_color: new i.ca(c), u_high_color: new i.ca(c), u_space_color: new i.ca(c), u_temporal_offset: new i.bM(c), u_horizon_angle: new i.bM(c) }), model: (c) => ({ u_matrix: new i.bJ(c), u_lighting_matrix: new i.bJ(c), u_normal_matrix: new i.bJ(c), u_node_matrix: new i.bJ(c), u_lightpos: new i.bL(c), u_lightintensity: new i.bM(c), u_lightcolor: new i.bL(c), u_camera_pos: new i.bL(c), u_opacity: new i.bM(c), u_baseColorFactor: new i.ca(c), u_emissiveFactor: new i.ca(c), u_metallicFactor: new i.bM(c), u_roughnessFactor: new i.bM(c), u_baseTextureIsAlpha: new i.bN(c), u_alphaMask: new i.bN(c), u_alphaCutoff: new i.bM(c), u_baseColorTexture: new i.bN(c), u_metallicRoughnessTexture: new i.bN(c), u_normalTexture: new i.bN(c), u_occlusionTexture: new i.bN(c), u_emissionTexture: new i.bN(c), u_lutTexture: new i.bN(c), u_color_mix: new i.ca(c), u_aoIntensity: new i.bM(c), u_emissive_strength: new i.bM(c), u_occlusionTextureTransform: new i.ca(c) }), modelDepth: (c) => ({ u_matrix: new i.bJ(c), u_instance: new i.bJ(c), u_node_matrix: new i.bJ(c) }), groundShadow: (c) => ({ u_matrix: new i.bJ(c), u_ground_shadow_factor: new i.bL(c) }), stars: (c) => ({ u_matrix: new i.bJ(c), u_up: new i.bL(c), u_right: new i.bL(c), u_intensity_multiplier: new i.bM(c) }), snowParticle: (c) => ({ u_modelview: new i.bJ(c), u_projection: new i.bJ(c), u_time: new i.bM(c), u_cam_pos: new i.bL(c), u_velocityConeAperture: new i.bM(c), u_velocity: new i.bM(c), u_horizontalOscillationRadius: new i.bM(c), u_horizontalOscillationRate: new i.bM(c), u_boxSize: new i.bM(c), u_billboardSize: new i.bM(c), u_simpleShapeParameters: new i.bK(c), u_screenSize: new i.bK(c), u_thinningCenterPos: new i.bK(c), u_thinningShape: new i.bL(c), u_thinningAffectedRatio: new i.bM(c), u_thinningParticleOffset: new i.bM(c), u_particleColor: new i.ca(c), u_direction: new i.bL(c) }), rainParticle: (c) => ({ u_modelview: new i.bJ(c), u_projection: new i.bJ(c), u_time: new i.bM(c), u_cam_pos: new i.bL(c), u_texScreen: new i.bN(c), u_velocityConeAperture: new i.bM(c), u_velocity: new i.bM(c), u_boxSize: new i.bM(c), u_rainDropletSize: new i.bK(c), u_distortionStrength: new i.bM(c), u_rainDirection: new i.bL(c), u_color: new i.ca(c), u_screenSize: new i.bK(c), u_thinningCenterPos: new i.bK(c), u_thinningShape: new i.bL(c), u_thinningAffectedRatio: new i.bM(c), u_thinningParticleOffset: new i.bM(c), u_shapeDirectionalPower: new i.bM(c), u_shapeNormalPower: new i.bM(c), u_mode: new i.bM(c) }), vignette: (c) => ({ u_vignetteShape: new i.bL(c), u_vignetteColor: new i.ca(c) }), occlusion: (c) => ({ u_matrix: new i.bJ(c), u_anchorPos: new i.bL(c), u_screenSizePx: new i.bK(c), u_occluderSizePx: new i.bK(c), u_color: new i.ca(c) }) };
      class Qo {
        constructor(t, s, h, m) {
          this.id = Qo.uniqueIdxCounter, Qo.uniqueIdxCounter++, this.context = t;
          const g = t.gl;
          this.buffer = g.createBuffer(), this.dynamicDraw = !!h, this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), g.bufferData(g.ELEMENT_ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW), this.dynamicDraw || m || s.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          this.id = Qo.uniqueIdxCounter, Qo.uniqueIdxCounter++;
          const s = this.context.gl;
          this.context.unbindVAO(), this.bind(), s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      Qo.uniqueIdxCounter = 0;
      const _d = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class gd {
        constructor(t, s, h, m, g, T) {
          this.length = s.length, this.attributes = h, this.itemSize = s.bytesPerElement, this.dynamicDraw = m, this.instanceCount = T, this.context = t;
          const z = t.gl;
          this.buffer = z.createBuffer(), t.bindVertexBuffer.set(this.buffer), z.bufferData(z.ARRAY_BUFFER, s.arrayBuffer, this.dynamicDraw ? z.DYNAMIC_DRAW : z.STATIC_DRAW), this.dynamicDraw || g || s.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          const s = this.context.gl;
          this.bind(), s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, s) {
          for (let h = 0; h < this.attributes.length; h++) {
            const m = s.attributes[this.attributes[h].name];
            m !== void 0 && t.enableVertexAttribArray(m);
          }
        }
        setVertexAttribPointers(t, s, h) {
          for (let m = 0; m < this.attributes.length; m++) {
            const g = this.attributes[m], T = s.attributes[g.name];
            T !== void 0 && t.vertexAttribPointer(T, g.components, t[_d[g.type]], !1, this.itemSize, g.offset + this.itemSize * (h || 0));
          }
        }
        setVertexAttribDivisor(t, s, h) {
          for (let m = 0; m < this.attributes.length; m++) {
            const g = s.attributes[this.attributes[m].name];
            g !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(g, h);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class br {
        constructor(t, s, h, m, g) {
          this.context = t, this.width = s, this.height = h;
          const T = this.framebuffer = t.gl.createFramebuffer();
          m && (this.colorAttachment = new ec(t, T)), g && (this.depthAttachmentType = g, this.depthAttachment = g === "renderbuffer" ? new es(t, T) : new Ao(t, T));
        }
        destroy() {
          const t = this.context.gl;
          if (this.colorAttachment) {
            const s = this.colorAttachment.get();
            s && t.deleteTexture(s);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if (this.depthAttachmentType === "renderbuffer") {
              const s = this.depthAttachment.get();
              s && t.deleteRenderbuffer(s);
            } else {
              const s = this.depthAttachment.get();
              s && t.deleteTexture(s);
            }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class Za {
        constructor(t, s) {
          this.gl = t, this.clearColor = new Hh(this), this.clearDepth = new qh(this), this.clearStencil = new Kl(this), this.colorMask = new Jl(this), this.depthMask = new Ql(this), this.stencilMask = new Zc(this), this.stencilFunc = new Hc(this), this.stencilOp = new qc(this), this.stencilTest = new Qu(this), this.depthRange = new p(this), this.depthTest = new A(this), this.depthFunc = new B(this), this.blend = new X(this), this.blendFunc = new ne(this), this.blendColor = new ye(this), this.blendEquation = new We(this), this.cullFace = new ot(this), this.cullFaceSide = new ft(this), this.frontFace = new Rt(this), this.program = new ii(this), this.activeTexture = new Ci(this), this.viewport = new Wi(this), this.bindFramebuffer = new Hs(this), this.bindRenderbuffer = new ws(this), this.bindTexture = new Rs(this), this.bindVertexBuffer = new ur(this), this.bindElementBuffer = new ja(this), this.bindVertexArrayOES = new ed(this), this.pixelStoreUnpack = new td(this), this.pixelStoreUnpackPremultiplyAlpha = new id(this), this.pixelStoreUnpackFlipY = new Wh(this), this.options = s ? { ...s } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = s && !!s.forceManualRenderingForInstanceIDShaders || this.renderer && this.renderer.indexOf("PowerVR") !== -1, this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE), this.maxPointSize = t.getParameter(t.ALIASED_POINT_SIZE_RANGE)[1];
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(t, s, h) {
          return new Qo(this, t, s, h);
        }
        createVertexBuffer(t, s, h, m, g) {
          return new gd(this, t, s, h, m, g);
        }
        createRenderbuffer(t, s, h) {
          const m = this.gl, g = m.createRenderbuffer();
          return this.bindRenderbuffer.set(g), m.renderbufferStorage(m.RENDERBUFFER, t, s, h), this.bindRenderbuffer.set(null), g;
        }
        createFramebuffer(t, s, h, m) {
          return new br(this, t, s, h, m);
        }
        clear({ color: t, depth: s, stencil: h, colorMask: m }) {
          const g = this.gl;
          let T = 0;
          t && (T |= g.COLOR_BUFFER_BIT, this.clearColor.set(t), this.colorMask.set(m || [!0, !0, !0, !0])), s !== void 0 && (T |= g.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(s), this.depthMask.set(!0)), h !== void 0 && (T |= g.STENCIL_BUFFER_BIT, this.clearStencil.set(h), this.stencilMask.set(255)), g.clear(T);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          i.bn(t.blendFunction, bi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      let Jc;
      function su(c, t, s, h, m, g, T) {
        const z = c.context, R = z.gl, F = c.transform, N = c.getOrCreateProgram("collisionBox"), j = [];
        let G = 0, W = 0;
        for (let pe = 0; pe < h.length; pe++) {
          const Te = h[pe], xe = t.getTile(Te), be = xe.getBucket(s);
          if (!be)
            continue;
          const ve = qn(Te, be, F);
          let Pe = ve;
          m[0] === 0 && m[1] === 0 || (Pe = c.translatePosMatrix(ve, xe, m, g));
          const Oe = T ? be.textCollisionBox : be.iconCollisionBox, Xe = be.collisionCircleArray;
          if (Xe.length > 0) {
            const Ze = i.ab.mat4.create(), ke = Pe;
            i.ab.mat4.mul(Ze, be.placementInvProjMatrix, F.glCoordMatrix), i.ab.mat4.mul(Ze, Ze, be.placementViewportMatrix), j.push({ circleArray: Xe, circleOffset: W, transform: ke, invTransform: Ze, projection: be.getProjection() }), G += Xe.length / 4, W = G;
          }
          Oe && (c.terrain && c.terrain.setupElevationDraw(xe, N), N.draw(c, R.LINES, Wt.disabled, ci.disabled, c.colorModeForRenderPass(), ti.disabled, cd(Pe, F, xe, be.getProjection()), s.id, Oe.layoutVertexBuffer, Oe.indexBuffer, Oe.segments, null, F.zoom, null, [Oe.collisionVertexBuffer, Oe.collisionVertexBufferExt]));
        }
        if (!T || !j.length)
          return;
        const te = c.getOrCreateProgram("collisionCircle"), ee = new i.cV();
        ee.resize(4 * G), ee._trim();
        let se = 0;
        for (const pe of j)
          for (let Te = 0; Te < pe.circleArray.length / 4; Te++) {
            const xe = 4 * Te, be = pe.circleArray[xe + 0], ve = pe.circleArray[xe + 1], Pe = pe.circleArray[xe + 2], Oe = pe.circleArray[xe + 3];
            ee.emplace(se++, be, ve, Pe, Oe, 0), ee.emplace(se++, be, ve, Pe, Oe, 1), ee.emplace(se++, be, ve, Pe, Oe, 2), ee.emplace(se++, be, ve, Pe, Oe, 3);
          }
        (!Jc || Jc.length < 2 * G) && (Jc = function(pe) {
          const Te = 2 * pe, xe = new i.aU();
          xe.resize(Te), xe._trim();
          for (let be = 0; be < Te; be++) {
            const ve = 6 * be;
            xe.uint16[ve + 0] = 4 * be + 0, xe.uint16[ve + 1] = 4 * be + 1, xe.uint16[ve + 2] = 4 * be + 2, xe.uint16[ve + 3] = 4 * be + 2, xe.uint16[ve + 4] = 4 * be + 3, xe.uint16[ve + 5] = 4 * be + 0;
          }
          return xe;
        }(G));
        const oe = z.createIndexBuffer(Jc, !0), ce = z.createVertexBuffer(ee, i.cW.members, !0);
        for (const pe of j) {
          const Te = { u_matrix: pe.transform, u_inv_matrix: pe.invTransform, u_camera_to_center_distance: (_e = F).getCameraToCenterDistance(pe.projection), u_viewport_size: [_e.width, _e.height] };
          te.draw(c, R.TRIANGLES, Wt.disabled, ci.disabled, c.colorModeForRenderPass(), ti.disabled, Te, s.id, ce, oe, i.b7.simpleSegment(0, 2 * pe.circleOffset, pe.circleArray.length, pe.circleArray.length / 2), null, F.zoom);
        }
        var _e;
        ce.destroy(), oe.destroy();
      }
      const sc = i.ab.mat4.create();
      function ru(c) {
        const t = c._camera.getWorldToCamera(c.worldSize, 1), s = i.ab.mat4.multiply([], t, c.globeMatrix);
        i.ab.mat4.invert(s, s);
        const h = [0, 0, 0], m = [0, 1, 0, 0];
        return i.ab.vec4.transformMat4(m, m, s), h[0] = m[0], h[1] = m[1], h[2] = m[2], i.ab.vec3.normalize(h, h), h;
      }
      function Xf({ width: c, height: t, anchor: s, textOffset: h, textScale: m }, g) {
        const { horizontalAlign: T, verticalAlign: z } = i.bD(s), R = -(T - 0.5) * c, F = -(z - 0.5) * t, N = i.bC(s, h);
        return new i.P((R / m + N[0]) * g, (F / m + N[1]) * g);
      }
      function co(c, t, s, h, m, g, T, z, R, F, N) {
        const j = c.text.placedSymbolArray, G = c.text.dynamicLayoutVertexArray, W = c.icon.dynamicLayoutVertexArray, te = {}, ee = c.getProjection(), se = fa(z, ee, g), oe = g.elevation, ce = ee.upVectorScale(z.canonical, g.center.lat, g.worldSize).metersToTile;
        G.clear();
        for (let _e = 0; _e < j.length; _e++) {
          const pe = j.get(_e), { tileAnchorX: Te, tileAnchorY: xe, numGlyphs: be } = pe, ve = pe.hidden || !pe.crossTileID || c.allowVerticalPlacement && !pe.placedOrientation ? null : h[pe.crossTileID];
          if (ve) {
            let Pe = 0, Oe = 0, Xe = 0;
            if (oe) {
              const Je = oe ? oe.getAtTileOffset(z, Te, xe) : 0, [_t, ct, nt] = ee.upVector(z.canonical, Te, xe);
              Pe = Je * _t * ce, Oe = Je * ct * ce, Xe = Je * nt * ce;
            }
            let [Ze, ke, Ne, st] = un(pe.projectedAnchorX + Pe, pe.projectedAnchorY + Oe, pe.projectedAnchorZ + Xe, s ? se : T);
            const ht = Rc(g.getCameraToCenterDistance(ee), st);
            let yt = m.evaluateSizeForFeature(c.textSizeData, F, pe) * ht / i.bw;
            s && (yt *= c.tilePixelRatio / R);
            const je = Xf(ve, yt);
            s ? ({ x: Ze, y: ke, z: Ne } = ee.projectTilePoint(Te + je.x, xe + je.y, z.canonical), [Ze, ke, Ne] = un(Ze + Pe, ke + Oe, Ne + Xe, T)) : (t && je._rotate(-g.angle), Ze += je.x, ke += je.y, Ne = 0);
            const at = c.allowVerticalPlacement && pe.placedOrientation === i.bq.vertical ? Math.PI / 2 : 0;
            for (let Je = 0; Je < be; Je++)
              i.bt(G, Ze, ke, Ne, at);
            N && pe.associatedIconIndex >= 0 && (te[pe.associatedIconIndex] = { x: Ze, y: ke, z: Ne, angle: at });
          } else
            da(be, G);
        }
        if (N) {
          W.clear();
          const _e = c.icon.placedSymbolArray;
          for (let pe = 0; pe < _e.length; pe++) {
            const Te = _e.get(pe), { numGlyphs: xe } = Te, be = te[pe];
            if (Te.hidden || !be)
              da(xe, W);
            else {
              const { x: ve, y: Pe, z: Oe, angle: Xe } = be;
              for (let Ze = 0; Ze < xe; Ze++)
                i.bt(W, ve, Pe, Oe, Xe);
            }
          }
          c.icon.dynamicLayoutVertexBuffer.updateData(W);
        }
        c.text.dynamicLayoutVertexBuffer.updateData(G);
      }
      function Tn(c, t, s, h, m, g, T = {}) {
        const z = s.paint.get("icon-translate"), R = s.paint.get("text-translate"), F = s.paint.get("icon-translate-anchor"), N = s.paint.get("text-translate-anchor"), j = s.layout.get("icon-rotation-alignment"), G = s.layout.get("text-rotation-alignment"), W = s.layout.get("icon-pitch-alignment"), te = s.layout.get("text-pitch-alignment"), ee = s.layout.get("icon-keep-upright"), se = s.layout.get("text-keep-upright"), oe = s.paint.get("icon-color-saturation"), ce = s.paint.get("icon-color-contrast"), _e = s.paint.get("icon-color-brightness-min"), pe = s.paint.get("icon-color-brightness-max"), Te = s.layout.get("symbol-elevation-reference") === "sea", xe = c.context, be = xe.gl, ve = c.transform, Pe = j === "map", Oe = G === "map", Xe = W === "map", Ze = te === "map", ke = s.layout.get("symbol-sort-key").constantOr(1) !== void 0;
        let Ne = !1;
        const st = c.depthModeForSublayer(0, Wt.ReadOnly), ht = [i.at(ve.center.lng), i.aA(ve.center.lat)], yt = s.layout.get("text-variable-anchor"), je = ve.projection.name === "globe", at = [], Je = [0, -1, 0];
        for (const _t of h) {
          const ct = t.getTile(_t), nt = ct.getBucket(s);
          if (!nt || nt.projection.name === "mercator" && je || nt.fullyClipped)
            continue;
          const Lt = nt.projection.name === "globe", xt = Lt ? i.ae(ve.zoom) : 0, zt = fa(_t, nt.getProjection(), ve), Bt = ve.calculatePixelsToTileUnitsMatrix(ct), oi = yt && nt.hasTextData(), $t = nt.hasIconTextFit() && oi && nt.hasIconData(), Xt = nt.getProjection().createInversionMatrix(ve, _t.canonical), ai = (ji) => {
            ve.depthOcclusionForSymbolsAndCircles && (s.hasInitialOcclusionOpacityProperties || c.terrain) && (ji.push("DEPTH_D24"), ji.push("DEPTH_OCCLUSION"));
          }, zi = () => {
            const ji = Pe && s.layout.get("symbol-placement") !== "point", Yi = [];
            ai(Yi);
            const In = ji || $t, Fs = s.paint.get("icon-image-cross-fade").constantOr(0);
            c.terrainRenderModeElevated() && Xe && Yi.push("PITCH_WITH_MAP_TERRAIN"), Lt && (Yi.push("PROJECTION_GLOBE_VIEW"), In && Yi.push("PROJECTED_POS_ON_VIEWPORT")), Fs > 0 && Yi.push("ICON_TRANSITION"), nt.icon.zOffsetVertexBuffer && Yi.push("Z_OFFSET"), oe === 0 && ce === 0 && _e === 0 && pe === 1 || Yi.push("COLOR_ADJUSTMENT"), nt.sdfIcons && Yi.push("RENDER_SDF");
            const pr = nt.icon.programConfigurations.get(s.id), ts = c.getOrCreateProgram("symbol", { config: pr, defines: Yi }), As = ct.imageAtlasTexture ? ct.imageAtlasTexture.size : [0, 0], Js = nt.iconSizeData, jn = i.bp(Js, ve.zoom), dn = Xe || ve.pitch !== 0, _n = Ks(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt), Ri = Ms(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt), Gn = c.translatePosMatrix(Ri, ct, z, F, !0), Bs = c.translatePosMatrix(zt, ct, z, F), cn = In ? sc : _n, Qs = Pe && !Xe && !ji;
            let eo = Je;
            !je && !ve.mercatorFromTransition || Pe || (eo = ru(ve));
            const Br = Lt ? eo : Je, Ta = s.getColorAdjustmentMatrix(oe, ce, _e, pe), mr = Wf(Js.kind, jn, Qs, Xe, c, Bs, cn, Gn, Te, !1, As, [0, 0], !0, _t, xt, ht, Xt, Br, nt.getProjection(), Ta, Fs), Do = ct.imageAtlasTexture ? ct.imageAtlasTexture : null, Nr = s.layout.get("icon-size").constantOr(0) !== 1 || nt.iconsNeedLinear, el = nt.sdfIcons || c.options.rotating || c.options.zooming || Nr || dn ? be.LINEAR : be.NEAREST, ta = nt.sdfIcons && s.paint.get("icon-halo-width").constantOr(1) !== 0, Cl = c.terrain && Xe && ji ? i.ab.mat4.invert(i.ab.mat4.create(), _n) : sc;
            if (ji && nt.icon) {
              const mh = ve.elevation, Mu = mh ? mh.getAtTileOffsetFunc(_t, ve.center.lat, ve.worldSize, nt.getProjection()) : null, Eu = Zo(zt, ct.tileID.canonical, Xe, Pe, ve, nt.getProjection(), Bt);
              jl(nt, zt, c, !1, Eu, Ri, Xe, ee, Mu, _t);
            }
            return { program: ts, buffers: nt.icon, uniformValues: mr, atlasTexture: Do, atlasTextureIcon: null, atlasInterpolation: el, atlasInterpolationIcon: null, isSDF: nt.sdfIcons, hasHalo: ta, tile: ct, labelPlaneMatrixInv: Cl };
          }, wi = () => {
            const ji = Oe && s.layout.get("symbol-placement") !== "point", Yi = [], In = ji || yt || $t;
            c.terrainRenderModeElevated() && Ze && Yi.push("PITCH_WITH_MAP_TERRAIN"), Lt && (Yi.push("PROJECTION_GLOBE_VIEW"), In && Yi.push("PROJECTED_POS_ON_VIEWPORT")), nt.text.zOffsetVertexBuffer && Yi.push("Z_OFFSET"), nt.iconsInText && Yi.push("RENDER_TEXT_AND_SYMBOL"), Yi.push("RENDER_SDF"), ai(Yi);
            const Fs = nt.text.programConfigurations.get(s.id), pr = c.getOrCreateProgram("symbol", { config: Fs, defines: Yi });
            let ts, As = [0, 0], Js = null;
            const jn = nt.textSizeData;
            nt.iconsInText && (As = ct.imageAtlasTexture ? ct.imageAtlasTexture.size : [0, 0], Js = ct.imageAtlasTexture ? ct.imageAtlasTexture : null, ts = Ze || ve.pitch !== 0 || c.options.rotating || c.options.zooming || jn.kind === "composite" || jn.kind === "camera" ? be.LINEAR : be.NEAREST);
            const dn = ct.glyphAtlasTexture ? ct.glyphAtlasTexture.size : [0, 0], _n = s.layout.get("text-size-scale-range"), Ri = i.aw(c.scaleFactor, _n[0], _n[1]), Gn = i.bp(jn, ve.zoom, Ri), Bs = Ks(zt, ct.tileID.canonical, Ze, Oe, ve, nt.getProjection(), Bt), cn = Ms(zt, ct.tileID.canonical, Ze, Oe, ve, nt.getProjection(), Bt), Qs = c.translatePosMatrix(cn, ct, R, N, !0), eo = c.translatePosMatrix(zt, ct, R, N), Br = In ? sc : Bs, Ta = Oe && !Ze && !ji;
            let mr = Je;
            !je && !ve.mercatorFromTransition || Oe || (mr = ru(ve));
            const Do = Wf(jn.kind, Gn, Ta, Ze, c, eo, Br, Qs, Te, !0, dn, As, !0, _t, xt, ht, Xt, Lt ? mr : Je, nt.getProjection(), null, null, Ri), Nr = ct.glyphAtlasTexture ? ct.glyphAtlasTexture : null, el = be.LINEAR, ta = s.paint.get("text-halo-width").constantOr(1) !== 0, Cl = c.terrain && Ze && ji ? i.ab.mat4.invert(i.ab.mat4.create(), Bs) : sc;
            if (ji && nt.text) {
              const mh = ve.elevation, Mu = mh ? mh.getAtTileOffsetFunc(_t, ve.center.lat, ve.worldSize, nt.getProjection()) : null, Eu = Zo(zt, ct.tileID.canonical, Ze, Oe, ve, nt.getProjection(), Bt);
              jl(nt, zt, c, !0, Eu, cn, Ze, se, Mu, _t);
            }
            return { program: pr, buffers: nt.text, uniformValues: Do, atlasTexture: Nr, atlasTextureIcon: Js, atlasInterpolation: el, atlasInterpolationIcon: ts, isSDF: !0, hasHalo: ta, tile: ct, labelPlaneMatrixInv: Cl };
          }, mn = nt.icon.segments.get().length, Sn = nt.text.segments.get().length, Xi = mn && !T.onlyText ? zi() : null, sn = Sn && !T.onlyIcons ? wi() : null, _i = s.paint.get("icon-opacity").constantOr(1), Jt = s.paint.get("text-opacity").constantOr(1);
          if (ke && nt.canOverlap) {
            Ne = !0;
            const ji = _i && !T.onlyText ? nt.icon.segments.get() : [], Yi = Jt && !T.onlyIcons ? nt.text.segments.get() : [];
            for (const In of ji)
              at.push({ segments: new i.b7([In]), sortKey: In.sortKey, state: Xi });
            for (const In of Yi)
              at.push({ segments: new i.b7([In]), sortKey: In.sortKey, state: sn });
          } else
            T.onlyText || at.push({ segments: _i ? nt.icon.segments : new i.b7([]), sortKey: 0, state: Xi }), T.onlyIcons || at.push({ segments: Jt ? nt.text.segments : new i.b7([]), sortKey: 0, state: sn });
        }
        Ne && at.sort((_t, ct) => _t.sortKey - ct.sortKey);
        for (const _t of at) {
          const ct = _t.state;
          if (ct)
            if (c.terrain ? c.terrain.setupElevationDraw(ct.tile, ct.program, { useDepthForOcclusion: ve.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: ct.labelPlaneMatrixInv }) : c.setupDepthForOcclusion(ve.depthOcclusionForSymbolsAndCircles, ct.program), xe.activeTexture.set(be.TEXTURE0), ct.atlasTexture && ct.atlasTexture.bind(ct.atlasInterpolation, be.CLAMP_TO_EDGE, !0), ct.atlasTextureIcon && (xe.activeTexture.set(be.TEXTURE1), ct.atlasTextureIcon && ct.atlasTextureIcon.bind(ct.atlasInterpolationIcon, be.CLAMP_TO_EDGE, !0)), c.uploadCommonLightUniforms(c.context, ct.program), ct.hasHalo) {
              const nt = ct.uniformValues;
              nt.u_is_halo = 1, rc(ct.buffers, _t.segments, s, c, ct.program, st, m, g, nt, 2), nt.u_is_halo = 0;
            } else {
              if (ct.isSDF) {
                const nt = ct.uniformValues;
                ct.hasHalo && (nt.u_is_halo = 1, rc(ct.buffers, _t.segments, s, c, ct.program, st, m, g, nt, 1)), nt.u_is_halo = 0;
              }
              rc(ct.buffers, _t.segments, s, c, ct.program, st, m, g, ct.uniformValues, 1);
            }
        }
      }
      function rc(c, t, s, h, m, g, T, z, R, F) {
        const N = [c.dynamicLayoutVertexBuffer, c.opacityVertexBuffer, c.iconTransitioningVertexBuffer, c.globeExtVertexBuffer, c.zOffsetVertexBuffer];
        m.draw(h, h.context.gl.TRIANGLES, g, T, z, ti.disabled, R, s.id, c.layoutVertexBuffer, c.indexBuffer, t, s.paint, h.transform.zoom, c.programConfigurations.get(s.id), N, F);
      }
      function ou(c, t, s, h, m, g, T) {
        const z = c.context.gl, R = s.paint.get("fill-pattern"), F = s.is3D(), N = F ? c.stencilModeFor3D() : ci.disabled, j = R && R.constantOr(1);
        let G, W, te, ee, se;
        T ? (W = j && !s.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", G = z.LINES) : (W = j ? "fillPattern" : "fill", G = z.TRIANGLES);
        for (const oe of h) {
          const ce = t.getTile(oe);
          if (j && !ce.patternsLoaded())
            continue;
          const _e = ce.getBucket(s);
          if (!_e)
            continue;
          c.prepareDrawTile();
          const pe = _e.programConfigurations.get(s.id), Te = c.isTileAffectedByFog(oe), xe = c.getOrCreateProgram(W, { config: pe, overrideFog: Te });
          j && (c.context.activeTexture.set(z.TEXTURE0), ce.imageAtlasTexture && ce.imageAtlasTexture.bind(z.LINEAR, z.CLAMP_TO_EDGE), pe.updatePaintBuffers());
          const be = R.constantOr(null);
          if (be && ce.imageAtlas) {
            const Oe = ce.imageAtlas, Xe = i.A.from(be), Ze = Oe.patternPositions[Xe.getSerializedPrimary()];
            Ze && pe.setConstantPatternPositions(Ze);
          }
          const ve = c.translatePosMatrix(oe.projMatrix, ce, s.paint.get("fill-translate"), s.paint.get("fill-translate-anchor")), Pe = s.paint.get("fill-emissive-strength");
          if (T) {
            ee = _e.indexBuffer2, se = _e.segments2;
            const Oe = c.terrain && c.terrain.renderingToTexture ? c.terrain.drapeBufferSize : [z.drawingBufferWidth, z.drawingBufferHeight];
            te = W === "fillOutlinePattern" && j ? tu(ve, Pe, c, ce, Oe) : eu(ve, Pe, Oe);
          } else
            ee = _e.indexBuffer, se = _e.segments, te = j ? ld(ve, Pe, c, ce) : ic(ve, Pe);
          c.uploadCommonUniforms(c.context, xe, oe.toUnwrapped()), xe.draw(c, G, m, F ? N : c.stencilModeForClipping(oe), g, ti.disabled, te, s.id, _e.layoutVertexBuffer, ee, se, s.paint, c.transform.zoom, pe, void 0);
        }
      }
      function Qc(c, t, s, h, m, g, T, z) {
        s.resetLayerRenderingStats(c);
        const R = c.context, F = R.gl, N = c.transform, j = s.paint.get("fill-extrusion-pattern"), G = j.constantOr(1), W = s.paint.get("fill-extrusion-opacity"), te = c.style.enable3dLights(), ee = s.paint.get(te && !G ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), se = [s.paint.get("fill-extrusion-ambient-occlusion-intensity"), ee], oe = s.layout.get("fill-extrusion-edge-radius"), ce = oe > 0 && !s.paint.get("fill-extrusion-rounded-roof"), _e = ce ? 0 : oe, pe = N.projection.name === "globe" ? i.d3() : 0, Te = N.projection.name === "globe", xe = Te ? i.ae(N.zoom) : 0, be = [i.at(N.center.lng), i.aA(N.center.lat)], ve = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", Pe = s.paint.get("fill-extrusion-flood-light-color").toRenderColor(ve ? null : s.lut).toArray01().slice(0, 3), Oe = s.paint.get("fill-extrusion-flood-light-intensity"), Xe = s.paint.get("fill-extrusion-vertical-scale"), Ze = s.paint.get("fill-extrusion-line-width").constantOr(1) !== 0, ke = s.paint.get("fill-extrusion-height-alignment"), Ne = s.paint.get("fill-extrusion-base-alignment"), st = To(c, s.paint.get("fill-extrusion-cutoff-fade-range")), ht = [];
        let yt;
        Te && ht.push("PROJECTION_GLOBE_VIEW"), se[0] > 0 && ht.push("FAUX_AO"), ce && ht.push("ZERO_ROOF_RADIUS"), z && ht.push("HAS_CENTROID"), Oe > 0 && ht.push("FLOOD_LIGHT"), st.shouldRenderCutoff && ht.push("RENDER_CUTOFF"), Ze && ht.push("RENDER_WALL_MODE");
        const je = c.renderPass === "shadow", at = c.shadowRenderer, Je = je && !!at;
        c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !0);
        let _t = [0, 0, 0];
        if (at) {
          const Lt = c.style.directionalLight, xt = c.style.ambientLight;
          Lt && xt && (_t = cr(c.style, Lt, xt)), je || (ht.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), at.useNormalOffset && ht.push("NORMAL_OFFSET")), yt = ht.concat(["SHADOWS_SINGLE_CASCADE"]);
        }
        const ct = Je ? "fillExtrusionDepth" : G ? "fillExtrusionPattern" : "fillExtrusion", nt = s.getLayerRenderingStats();
        for (const Lt of h) {
          const xt = t.getTile(Lt), zt = xt.getBucket(s);
          if (!zt || zt.projection.name !== N.projection.name)
            continue;
          let Bt = !1;
          at && (Bt = at.getMaxCascadeForTile(Lt.toUnwrapped()) === 0);
          const oi = c.isTileAffectedByFog(Lt), $t = zt.programConfigurations.get(s.id), Xt = c.getOrCreateProgram(ct, { config: $t, defines: Bt ? yt : ht, overrideFog: oi });
          if (c.terrain && c.terrain.setupElevationDraw(xt, Xt, { useMeterToDem: !0 }), !zt.centroidVertexBuffer) {
            const sn = Xt.attributes.a_centroid_pos;
            sn !== void 0 && F.vertexAttrib2f(sn, 0, 0);
          }
          !je && at && at.setupShadows(xt.tileID.toUnwrapped(), Xt, "vector-tile", xt.tileID.overscaledZ), G && (c.context.activeTexture.set(F.TEXTURE0), xt.imageAtlasTexture && xt.imageAtlasTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), $t.updatePaintBuffers());
          const ai = j.constantOr(null);
          if (ai && xt.imageAtlas) {
            const sn = xt.imageAtlas, _i = i.A.from(ai), Jt = sn.patternPositions[_i.getSerializedPrimary()];
            Jt && $t.setConstantPatternPositions(Jt);
          }
          const zi = s.paint.get("fill-extrusion-vertical-gradient"), wi = 1 / zt.tileToMeter;
          let mn;
          if (je && at) {
            if (gt(xt.tileID, zt, c))
              continue;
            const sn = at.calculateShadowPassMatrixFromTile(xt.tileID.toUnwrapped());
            mn = Yc(sn, _e, wi, Xe, ke, Ne);
          } else {
            const sn = c.translatePosMatrix(Lt.expandedProjMatrix, xt, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), _i = N.projection.createInversionMatrix(N, Lt.canonical);
            mn = G ? ad(sn, c, zi, W, se, _e, wi, Lt, xt, pe, ke, Ne, xe, be, _i, Pe, Xe) : Qh(sn, c, zi, W, se, _e, wi, Lt, pe, ke, Ne, xe, be, _i, Pe, Xe, Oe, _t);
          }
          c.uploadCommonUniforms(R, Xt, Lt.toUnwrapped(), null, st);
          let Sn = zt.segments;
          if (N.projection.name === "mercator" && !je && (Sn = zt.getVisibleSegments(xt.tileID, c.terrain, c.transform.getFrustum(0)), !Sn.get().length))
            continue;
          if (nt)
            if (je)
              for (const sn of Sn.get())
                nt.numRenderedVerticesInShadowPass += sn.primitiveLength;
            else
              for (const sn of Sn.get())
                nt.numRenderedVerticesInTransparentPass += sn.primitiveLength;
          const Xi = [];
          (c.terrain || z) && Xi.push(zt.centroidVertexBuffer), Te && Xi.push(zt.layoutVertexExtBuffer), Ze && Xi.push(zt.wallVertexBuffer), Xt.draw(c, R.gl.TRIANGLES, m, g, T, ti.backCCW, mn, s.id, zt.layoutVertexBuffer, zt.indexBuffer, Sn, s.paint, c.transform.zoom, $t, Xi);
        }
        c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !1);
      }
      function wl(c, t, s, h, m, g, T, z, R, F, N, j, G, W, te, ee, se, oe, ce) {
        const _e = c.context, pe = _e.gl, Te = c.transform, xe = c.transform.zoom, be = [], ve = To(c, s.paint.get("fill-extrusion-cutoff-fade-range"));
        F === "clear" ? (be.push("CLEAR_SUBPASS"), ce && (be.push("CLEAR_FROM_TEXTURE"), _e.activeTexture.set(pe.TEXTURE0), ce.bind(pe.LINEAR, pe.CLAMP_TO_EDGE))) : F === "sdf" && be.push("SDF_SUBPASS"), se && be.push("HAS_CENTROID"), ve.shouldRenderCutoff && be.push("RENDER_CUTOFF");
        const Pe = s.layout.get("fill-extrusion-edge-radius"), Oe = (Xe, Ze, ke, Ne, st) => {
          const ht = Ze.programConfigurations.get(s.id), yt = c.isTileAffectedByFog(Xe), je = c.getOrCreateProgram("fillExtrusionGroundEffect", { config: ht, defines: be, overrideFog: yt }), at = ((_t, ct, nt, Lt, xt, zt, Bt, oi, $t, Xt, ai) => ({ u_matrix: ct, u_opacity: nt, u_ao_pass: Lt ? 1 : 0, u_meter_to_tile: xt, u_ao: zt, u_flood_light_intensity: Bt, u_flood_light_color: oi, u_attenuation: $t, u_edge_radius: Xt, u_fb: 0, u_fb_size: ai, u_dynamic_offset: 1 }))(0, Ne, N, R, st, [j, G * st], W, te, ee, xe >= 17 ? 0 : Pe * st, ce ? ce.size[0] : 0), Je = [];
          se && Je.push(Ze.hiddenByLandmarkVertexBuffer), c.uploadCommonUniforms(_e, je, Xe.toUnwrapped(), null, ve), je.draw(c, _e.gl.TRIANGLES, m, g, T, z, at, s.id, Ze.vertexBuffer, Ze.indexBuffer, ke, s.paint, xe, ht, Je);
        };
        for (const Xe of h) {
          const Ze = t.getTile(Xe), ke = Ze.getBucket(s);
          if (!ke || ke.projection.name !== Te.projection.name || !ke.groundEffect || ke.groundEffect && !ke.groundEffect.hasData())
            continue;
          const Ne = ke.groundEffect, st = 1 / ke.tileToMeter;
          {
            const ht = c.translatePosMatrix(Xe.projMatrix, Ze, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), yt = Ne.getDefaultSegment();
            Oe(Xe, Ne, yt, ht, st);
          }
          if (oe)
            for (let ht = 0; ht < 4; ht++) {
              const yt = i.d4[ht](Xe), je = t.getTile(yt);
              if (!je)
                continue;
              const at = je.getBucket(s);
              if (!at || at.projection.name !== Te.projection.name || !at.groundEffect || at.groundEffect && !at.groundEffect.hasData())
                continue;
              const Je = at.groundEffect;
              let _t, ct;
              ht === 0 ? (_t = [-i.ag, 0, 0], ct = 1) : ht === 1 ? (_t = [i.ag, 0, 0], ct = 0) : ht === 2 ? (_t = [0, -i.ag, 0], ct = 3) : (_t = [0, i.ag, 0], ct = 2);
              const nt = Je.regionSegments[ct];
              if (!nt)
                continue;
              const Lt = new Float32Array(16);
              i.ab.mat4.translate(Lt, Xe.projMatrix, _t), Oe(Xe, Je, nt, c.translatePosMatrix(Lt, Ze, s.paint.get("fill-extrusion-translate"), s.paint.get("fill-extrusion-translate-anchor")), st);
            }
        }
      }
      function Yf(c, t, s, h, m, g, T) {
        h.centroidVertexArray.length === 0 && h.createCentroidsBuffer();
        const z = g ? g.findDEMTileFor(s) : null;
        if (!(z && z.dem || T))
          return;
        g && z && z.dem && h.selfDEMTileTimestamp !== z.dem._timestamp && (h.borderDoneWithNeighborZ = [-1, -1, -1, -1], h.selfDEMTileTimestamp = z.dem._timestamp);
        const R = (oe) => new i.P(Math.ceil((oe + i.d7) * i.d8), 0), F = (oe) => {
          const ce = t.getSource().minzoom, _e = (Te) => {
            const xe = t.getTileByID(Te);
            if (xe && xe.hasData())
              return xe.getBucket(m);
          }, pe = [0, -1, 1];
          for (const Te of pe) {
            if (oe.overscaledZ + Te < ce)
              continue;
            const xe = _e(oe.calculateScaledKey(oe.overscaledZ + Te));
            if (xe)
              return xe;
          }
        }, N = [0, 0, 0], j = (oe, ce) => (N[0] = Math.min(oe.min.y, ce.min.y), N[1] = Math.max(oe.max.y, ce.max.y), N[2] = i.ag - ce.min.x > oe.max.x ? ce.min.x - i.ag : oe.max.x, N), G = (oe, ce) => (N[0] = Math.min(oe.min.x, ce.min.x), N[1] = Math.max(oe.max.x, ce.max.x), N[2] = i.ag - ce.min.y > oe.max.y ? ce.min.y - i.ag : oe.max.y, N), W = [(oe, ce) => j(oe, ce), (oe, ce) => j(ce, oe), (oe, ce) => G(oe, ce), (oe, ce) => G(ce, oe)], te = (oe, ce, _e, pe, Te, xe, be) => {
          if (!g)
            return 0;
          const ve = [[xe ? _e : oe, xe ? oe : _e, 0], [xe ? _e : ce, xe ? ce : _e, 0]], Pe = be < 0 ? i.ag + be : be, Oe = [xe ? Pe : (oe + ce) / 2, xe ? (oe + ce) / 2 : Pe, 0];
          return _e === 0 && be < 0 || _e !== 0 && be > 0 ? g.getForTilePoints(Te, [Oe], !0, pe) : ve.push(Oe), g.getForTilePoints(s, ve, !0, z), Math.max(ve[0][2], ve[1][2], Oe[2]) / g.exaggeration();
        };
        for (let oe = 0; oe < 4; oe++) {
          const ce = h.borderFeatureIndices[oe];
          if (ce.length === 0)
            continue;
          const _e = i.d4[oe](s), pe = F(_e);
          if (!(pe && pe instanceof i.d5))
            continue;
          const Te = g ? g.findDEMTileFor(_e) : null;
          if (!(Te && Te.dem || T) || (g && Te && Te.dem && h.borderDEMTileTimestamp[oe] !== Te.dem._timestamp && (h.borderDoneWithNeighborZ[oe] = -1, h.borderDEMTileTimestamp[oe] = Te.dem._timestamp), h.borderDoneWithNeighborZ[oe] === pe.canonical.z))
            continue;
          pe.centroidVertexArray.length === 0 && pe.createCentroidsBuffer();
          const xe = (oe < 2 ? 1 : 5) - oe, be = pe.borderDoneWithNeighborZ[xe] !== h.canonical.z, ve = pe.borderFeatureIndices[xe];
          let Pe = 0;
          if (h.canonical.z !== pe.canonical.z) {
            for (const Oe of ce)
              h.showCentroid(h.featuresOnBorder[Oe]);
            if (be)
              for (const Oe of ve)
                pe.showCentroid(pe.featuresOnBorder[Oe]);
            h.borderDoneWithNeighborZ[oe] = pe.canonical.z, pe.borderDoneWithNeighborZ[xe] = h.canonical.z;
          }
          for (const Oe of ce) {
            const Xe = h.featuresOnBorder[Oe], Ze = h.centroidData[Xe.centroidDataIndex], ke = Xe.borders[oe];
            let Ne;
            for (; Pe < ve.length; ) {
              Ne = pe.featuresOnBorder[ve[Pe]];
              const st = Ne.borders[xe];
              if (st[1] > ke[0] + 3 || st[0] > ke[0] - 3)
                break;
              pe.showCentroid(Ne), Pe++;
            }
            if (Ne && Pe < ve.length) {
              const st = Pe;
              let ht = 0;
              for (; !(Ne.borders[xe][0] > ke[1] - 3) && (ht++, ++Pe !== ve.length); )
                Ne = pe.featuresOnBorder[ve[Pe]];
              Ne = pe.featuresOnBorder[ve[st]];
              let yt = !1;
              if (ht >= 1) {
                const Je = Ne.borders[xe];
                Math.abs(ke[0] - Je[0]) < 3 && Math.abs(ke[1] - Je[1]) < 3 && (ht = 1, yt = !0, Pe = st + 1);
              } else if (ht === 0) {
                h.showCentroid(Xe);
                continue;
              }
              const je = pe.centroidData[Ne.centroidDataIndex];
              T && yt && (((ee = Ze).flags | (se = je).flags) & i.d6 ? (ee.flags |= i.d6, se.flags |= i.d6) : (ee.flags &= ~i.d6, se.flags &= ~i.d6));
              const at = Xe.intersectsCount() > 1 || Ne.intersectsCount() > 1;
              if (ht > 1)
                Pe = st, Ze.centroidXY = je.centroidXY = new i.P(0, 0);
              else if (Te && Te.dem && !at) {
                const Je = W[oe](Ze, je), _t = oe % 2 ? i.ag - 1 : 0, ct = te(Je[0], Math.min(i.ag - 1, Je[1]), _t, Te, _e, oe < 2, Je[2]);
                Ze.centroidXY = je.centroidXY = R(ct);
              } else
                at ? Ze.centroidXY = je.centroidXY = new i.P(0, 0) : (Ze.centroidXY = h.encodeBorderCentroid(Xe), je.centroidXY = pe.encodeBorderCentroid(Ne));
              h.writeCentroidToBuffer(Ze), pe.writeCentroidToBuffer(je);
            } else
              h.showCentroid(Xe);
          }
          h.borderDoneWithNeighborZ[oe] = pe.canonical.z, pe.borderDoneWithNeighborZ[xe] = h.canonical.z;
        }
        var ee, se;
        (h.needsCentroidUpdate || !h.centroidVertexBuffer && h.centroidVertexArray.length !== 0) && h.uploadCentroid(c);
      }
      const $m = [1, 0, 0], oc = [0, 1, 0], ac = [0, 0, 1];
      function gt(c, t, s) {
        const h = s.transform, m = s.shadowRenderer;
        if (!m)
          return !0;
        const g = c.toUnwrapped(), T = h.tileSize * m._cascades[s.currentShadowCascade].scale;
        let z = t.maxHeight;
        if (h.elevation) {
          const ee = h.elevation.getMinMaxForTile(c);
          ee && (z += ee.max);
        }
        const R = [...m.shadowDirection];
        R[2] = -R[2];
        const F = m.computeSimplifiedTileShadowVolume(g, z, T, R);
        if (!F)
          return !1;
        const N = [$m, oc, ac, R, [R[0], 0, R[2]], [0, R[1], R[2]]], j = h.projection.name === "globe", G = h.scaleZoom(T), W = i.bR.fromInvProjectionMatrix(h.invProjMatrix, h.worldSize, G, !j), te = m.getCurrentCascadeFrustum();
        return W.intersectsPrecise(F.vertices, F.planes, N) === 0 || te.intersectsPrecise(F.vertices, F.planes, N) === 0;
      }
      function Dt(c) {
        return [c[0] * i.d9, c[1] * i.d9, c[2] * i.d9, 0];
      }
      function Ha(c, t, s, h, m, g, T, z, R) {
        const F = h.getSource(), N = s.globeSharedBuffers;
        if (!N)
          return;
        let j, G, W;
        if (t && (j = h.getTile(t)), F instanceof i.aJ ? (G = F.texture, W = i.cI(0, 0, s.transform)) : j && t && (G = j.texture, W = i.cI(t.canonical.z, t.canonical.x, s.transform)), !G || !W)
          return;
        c || (W = i.ab.mat4.scale(i.ab.mat4.create(), W, [1, -1, 1]));
        const te = s.context, ee = te.gl, se = m.paint.get("raster-resampling") === "nearest" ? ee.NEAREST : ee.LINEAR, oe = s.colorModeForDrapableLayerRenderPass(g), ce = T.defines;
        ce.push("GLOBE_POLES");
        const _e = new Wt(ee.LEQUAL, Wt.ReadWrite, s.depthRangeFor3D), pe = Float32Array.from(s.transform.expandedFarZProjMatrix), Te = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0))));
        s.terrain && s.terrain.prepareDrawTile(), te.activeTexture.set(ee.TEXTURE0), G.bind(se, ee.CLAMP_TO_EDGE), te.activeTexture.set(ee.TEXTURE1), G.bind(se, ee.CLAMP_TO_EDGE), G.useMipmap && te.extTextureFilterAnisotropic && s.transform.pitch > 20 && ee.texParameterf(ee.TEXTURE_2D, te.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, te.extTextureFilterAnisotropicMax);
        const [xe, be, ve, Pe] = t ? N.getPoleBuffers(t.canonical.z, !1) : N.getPoleBuffers(0, !0), Oe = m.paint.get("raster-elevation");
        let Xe;
        c ? (Xe = xe, s.renderDefaultNorthPole = Oe !== 0) : (Xe = be, s.renderDefaultSouthPole = Oe !== 0);
        const Ze = Dt(T.mix), ke = ((st, ht, yt, je, at, Je, _t, ct, nt, Lt, xt, zt, Bt) => ud(st, ht, yt, new Float32Array(16), new Float32Array(9), [0, 0], je, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, Je, [0, 0], ct, 2, Lt, xt, zt, 1, 0, Bt))(pe, Te, W, i.ae(s.transform.zoom), 0, m, 0, Oe, 0, Ze, T.offset, T.range, g), Ne = s.getOrCreateProgram("raster", { defines: ce });
        s.uploadCommonUniforms(te, Ne, null), Ne.draw(s, ee.TRIANGLES, _e, R, oe, z, ke, m.id, Xe, ve, Pe);
      }
      function Bn(c) {
        const t = c._nearZ, s = c.projection.farthestPixelDistance(c), h = s - t, m = 0.2 * c.height, g = t + m;
        return [t, s, (g - m - t) / h, (g - t) / h];
      }
      function $e(c, t, s, h) {
        if (c)
          return t instanceof xn && c instanceof za ? t.getTextureDescriptor(c, s, !0) : { texture: c.texture, mix: Dt(h.mix), offset: h.offset, buffer: 0, tileSize: 1 };
      }
      var Kf = i.da([{ name: "a_index", type: "Int16", components: 1 }]);
      class au {
        constructor(t, s, h, m) {
          const g = { width: h[0], height: h[1], data: null }, T = t.gl;
          this.targetColorTexture = new i.T(t, g, T.RGBA8, { useMipmap: !1 }), this.backgroundColorTexture = new i.T(t, g, T.RGBA8, { useMipmap: !1 }), this.context = t, this.updateParticleTexture(s, m), this.lastInvalidatedAt = 0;
        }
        updateParticleTexture(t, s) {
          if (this.particleTextureDimension === s.width)
            return;
          (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
          const h = this.context.gl, m = s.width * s.height;
          this.particleTexture0 = new i.T(this.context, s, h.RGBA8, { premultiply: !1, useMipmap: !1 }), this.particleTexture1 = new i.T(this.context, s, h.RGBA8, { premultiply: !1, useMipmap: !1 });
          const g = new i.db();
          g.reserve(m);
          for (let T = 0; T < m; T++)
            g.emplaceBack(T);
          this.particleIndexBuffer = this.context.createVertexBuffer(g, Kf.members, !0), this.particleSegment = i.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = s.width;
        }
        update(t) {
          return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = i.q.now(), 1));
        }
        destroy() {
          this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
        }
      }
      function yd(c, t, s) {
        if (!c)
          return null;
        const h = t.getTextureDescriptor(c, s, !0);
        if (!h)
          return null;
        let { texture: m, mix: g, offset: T, tileSize: z, buffer: R, format: F } = h;
        if (!m || !F)
          return null;
        let N = !1;
        return F === "uint32" && (N = !0, g[3] = 0, g = Kc(i.dc, g, [0, s.paint.get("raster-particle-max-speed")]), T = Ft(i.dc, T, [0, s.paint.get("raster-particle-max-speed")])), { texture: m, textureOffset: [R / (z + 2 * R), z / (z + 2 * R)], tileSize: z, scalarData: N, scale: g, offset: T, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[F]] };
      }
      function Jf(c) {
        const t = c._nearZ, s = c.projection.farthestPixelDistance(c), h = s - t, m = 0.2 * c.height, g = t + m;
        return [t, s, (g - m - t) / h, (g - t) / h];
      }
      const Qf = new i.aj(1, 0, 0, 1), ep = new i.aj(0, 1, 0, 1), lc = new i.aj(0, 0, 1, 1), Xm = new i.aj(1, 0, 1, 1), Ym = new i.aj(0, 1, 1, 1);
      function Tl(c, t, s, h, m, g, T) {
        const z = c.context, R = c.transform, F = z.gl, N = R.projection.name === "globe", j = N ? ["PROJECTION_GLOBE_VIEW"] : [];
        let G = i.ab.mat4.clone(s.projMatrix);
        if (N && i.ae(R.zoom) > 0) {
          const Ze = i.ba(s.canonical, R), ke = i.dd(Ze);
          G = i.ab.mat4.multiply(new Float32Array(16), R.globeMatrix, ke), i.ab.mat4.multiply(G, R.projMatrix, G);
        }
        const W = i.ab.mat4.create();
        W[12] += 2 * m / (i.q.devicePixelRatio * R.width), W[13] += 2 * g / (i.q.devicePixelRatio * R.height), i.ab.mat4.multiply(G, W, G);
        const te = c.getOrCreateProgram("debug", { defines: j }), ee = t.getTileByID(s.key);
        c.terrain && c.terrain.setupElevationDraw(ee, te);
        const se = Wt.disabled, oe = ci.disabled, ce = c.colorModeForRenderPass(), _e = "$debug";
        z.activeTexture.set(F.TEXTURE0), c.emptyTexture.bind(F.LINEAR, F.CLAMP_TO_EDGE), N ? ee._makeGlobeTileDebugBuffers(c.context, R) : ee._makeDebugTileBoundsBuffers(c.context, R.projection);
        const pe = ee._tileDebugBuffer || c.debugBuffer, Te = ee._tileDebugIndexBuffer || c.debugIndexBuffer, xe = ee._tileDebugSegments || c.debugSegments;
        if (te.draw(c, F.LINE_STRIP, se, oe, ce, ti.disabled, hd(G, h), _e, pe, Te, xe, null, null, null, [ee._globeTileDebugBorderBuffer]), T) {
          const Ze = ee.latestRawTileData, ke = Math.floor((Ze && Ze.byteLength || 0) / 1024);
          let Ne = s.canonical.toString();
          s.overscaledZ !== s.canonical.z && (Ne += ` => ${s.overscaledZ}`), Ne += ` ${ee.state}`, Ne += ` ${ke}kb`, function(st, ht) {
            st.initDebugOverlayCanvas();
            const yt = st.debugOverlayCanvas, je = st.context.gl, at = st.debugOverlayCanvas.getContext("2d");
            at.clearRect(0, 0, yt.width, yt.height), at.shadowColor = "white", at.shadowBlur = 2, at.lineWidth = 1.5, at.strokeStyle = "white", at.textBaseline = "top", at.font = "bold 36px Open Sans, sans-serif", at.fillText(ht, 5, 5), at.strokeText(ht, 5, 5), st.debugOverlayTexture.update(yt), st.debugOverlayTexture.bind(je.LINEAR, je.CLAMP_TO_EDGE);
          }(c, Ne);
        }
        const be = t.getTile(s).tileSize, ve = 512 / Math.min(be, 512) * (s.overscaledZ / R.zoom) * 0.5, Pe = ee._tileDebugTextBuffer || c.debugBuffer, Oe = ee._tileDebugTextIndexBuffer || c.quadTriangleIndexBuffer, Xe = ee._tileDebugTextSegments || c.debugSegments;
        te.draw(c, F.TRIANGLES, se, oe, bi.alphaBlended, ti.disabled, hd(G, i.aj.transparent, ve), _e, Pe, Oe, Xe, null, null, null, [ee._globeTileDebugTextBuffer]);
      }
      function eh(c, t, s, h) {
        th(c, 0, t + s / 2, c.transform.width, s, h);
      }
      function lu(c, t, s, h) {
        th(c, t - s / 2, 0, s, c.transform.height, h);
      }
      function th(c, t, s, h, m, g) {
        const T = c.context, z = T.gl;
        z.enable(z.SCISSOR_TEST), z.scissor(t * i.q.devicePixelRatio, s * i.q.devicePixelRatio, h * i.q.devicePixelRatio, m * i.q.devicePixelRatio), T.clear({ color: g }), z.disable(z.SCISSOR_TEST);
      }
      const tp = i.da([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: cu } = tp;
      function Po(c, t, s, h) {
        c.emplaceBack(t, s, h);
      }
      class Co {
        constructor(t) {
          this.vertexArray = new i.de(), this.indices = new i.aU(), Po(this.vertexArray, -1, -1, 1), Po(this.vertexArray, 1, -1, 1), Po(this.vertexArray, -1, 1, 1), Po(this.vertexArray, 1, 1, 1), Po(this.vertexArray, -1, -1, -1), Po(this.vertexArray, 1, -1, -1), Po(this.vertexArray, -1, 1, -1), Po(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, cu), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = i.b7.simpleSegment(0, 0, 36, 12);
        }
      }
      function Sl(c, t, s, h, m, g) {
        const T = c.context.gl, z = t.paint.get("sky-atmosphere-color"), R = t.paint.get("sky-atmosphere-halo-color"), F = t.paint.get("sky-atmosphere-sun-intensity"), N = ((j, G, W, te, ee) => ({ u_matrix_3f: j, u_sun_direction: G, u_sun_intensity: W, u_color_tint_r: [te.r, te.g, te.b, te.a], u_color_tint_m: [ee.r, ee.g, ee.b, ee.a], u_luminance: 5e-5 }))(i.ab.mat3.fromMat4(i.ab.mat3.create(), h), m, F, z, R);
        T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_CUBE_MAP_POSITIVE_X + g, t.skyboxTexture, 0), s.draw(c, T.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.frontCW, N, "skyboxCapture", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);
      }
      const Km = i.da([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
      class wr {
        constructor(t) {
          const s = new i.df();
          s.emplaceBack(-1, 1, 1, 0, 0), s.emplaceBack(1, 1, 1, 1, 0), s.emplaceBack(1, -1, 1, 1, 1), s.emplaceBack(-1, -1, 1, 0, 1);
          const h = new i.aU();
          h.emplaceBack(0, 1, 2), h.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(s, Km.members), this.indexBuffer = t.createIndexBuffer(h), this.segments = i.b7.simpleSegment(0, 0, 4, 2);
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const Jm = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
      class ih {
        constructor() {
          this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
        }
      }
      class bn {
        constructor(t) {
          this.colorModeAlphaBlendedWriteRGB = new bi([1, $o, 1, $o], i.aj.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new bi([1, 0, 1, 0], i.aj.transparent, [!1, !1, !1, !0]), this.params = new ih(), this.updateNeeded = !0, t.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
            this.updateNeeded = !0;
          }), t.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = !0;
          }), t.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
            this.updateNeeded = !0;
          });
        }
        update(t) {
          const s = t.context;
          if (!this.atmosphereBuffer || this.updateNeeded) {
            this.updateNeeded = !1, this.atmosphereBuffer = new wr(s);
            const h = this.params.sizeRange, m = this.params.intensityRange, g = function(N) {
              const j = i.di(30), G = [];
              for (let W = 0; W < N; ++W) {
                const te = 2 * Math.PI * j(), ee = Math.acos(1 - 2 * j()) - 0.5 * Math.PI;
                G.push(i.ab.vec3.fromValues(Math.cos(ee) * Math.cos(te), Math.cos(ee) * Math.sin(te), Math.sin(ee)));
              }
              return G;
            }(this.params.starsCount), T = i.di(300), z = new i.dg(), R = new i.aU();
            let F = 0;
            for (let N = 0; N < g.length; ++N) {
              const j = i.ab.vec3.scale([], g[N], 200), G = Math.max(0, 1 + 0.01 * h * (1 * T() - 0.5)), W = Math.max(0, 1 + 0.01 * m * (1 * T() - 0.5));
              z.emplaceBack(j[0], j[1], j[2], -1, -1, G, W), z.emplaceBack(j[0], j[1], j[2], 1, -1, G, W), z.emplaceBack(j[0], j[1], j[2], 1, 1, G, W), z.emplaceBack(j[0], j[1], j[2], -1, 1, G, W), R.emplaceBack(F + 0, F + 1, F + 2), R.emplaceBack(F + 0, F + 2, F + 3), F += 4;
            }
            this.starsVx = s.createVertexBuffer(z, Jm.members), this.starsIdx = s.createIndexBuffer(R), this.starsSegments = i.b7.simpleSegment(0, 0, z.length, R.length);
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t, s) {
          const h = t.context, m = h.gl, g = t.transform, T = new Wt(m.LEQUAL, Wt.ReadOnly, [0, 1]), z = i.ae(g.zoom), R = t.style.getLut(s.scope), F = s.properties.get("color-use-theme") === "none", N = s.properties.get("color").toRenderColor(F ? null : R).toArray01(), j = s.properties.get("high-color-use-theme") === "none", G = s.properties.get("high-color").toRenderColor(j ? null : R).toArray01(), W = s.properties.get("space-color-use-theme") === "none", te = s.properties.get("space-color").toRenderColor(W ? null : R).toArray01PremultipliedAlpha(), ee = 5e-4, se = i.dh(s.properties.get("horizon-blend"), 0, 1, ee, 0.25), oe = i.cC(t, h, g) && se === ee ? g.worldSize / (2 * Math.PI * 1.025) - 1 : g.globeRadius, ce = t.frameCounter / 1e3 % 1, _e = i.ab.vec3.length(g.globeCenterInViewSpace), pe = Math.sqrt(Math.pow(_e, 2) - Math.pow(oe, 2)), Te = Math.acos(pe / _e), xe = (be) => {
            const ve = g.projection.name === "globe" ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
            be && ve.push("ALPHA_PASS");
            const Pe = t.getOrCreateProgram("globeAtmosphere", { defines: ve }), Oe = ((Ze, ke, Ne, st, ht, yt, je, at, Je, _t, ct, nt) => ({ u_frustum_tl: Ze, u_frustum_tr: ke, u_frustum_br: Ne, u_frustum_bl: st, u_horizon: ht, u_transition: yt, u_fadeout_range: je, u_color: at, u_high_color: Je, u_space_color: _t, u_temporal_offset: ct, u_horizon_angle: nt }))(g.frustumCorners.TL, g.frustumCorners.TR, g.frustumCorners.BR, g.frustumCorners.BL, g.frustumCorners.horizon, z, se, N, G, te, ce, Te);
            t.uploadCommonUniforms(h, Pe);
            const Xe = this.atmosphereBuffer;
            Xe && Pe.draw(t, m.TRIANGLES, T, ci.disabled, be ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, ti.backCW, Oe, be ? "atmosphere_glow_alpha" : "atmosphere_glow", Xe.vertexBuffer, Xe.indexBuffer, Xe.segments);
          };
          xe(!1), xe(!0);
        }
        drawStars(t, s) {
          const h = i.aw(s.properties.get("star-intensity"), 0, 1);
          if (h === 0)
            return;
          const m = t.context, g = m.gl, T = t.transform, z = t.getOrCreateProgram("stars"), R = i.ab.quat.identity([]);
          i.ab.quat.rotateX(R, R, -T._pitch), i.ab.quat.rotateZ(R, R, -T.angle), i.ab.quat.rotateX(R, R, i.ai(T._center.lat)), i.ab.quat.rotateY(R, R, -i.ai(T._center.lng));
          const F = i.ab.mat4.fromQuat(new Float32Array(16), R), N = i.ab.mat4.multiply([], T.starsProjMatrix, F), j = i.ab.mat3.fromMat4([], F), G = i.ab.mat3.invert([], j), W = [0, 1, 0];
          i.ab.vec3.transformMat3(W, W, G), i.ab.vec3.scale(W, W, this.params.sizeMultiplier);
          const te = [1, 0, 0];
          i.ab.vec3.transformMat3(te, te, G), i.ab.vec3.scale(te, te, this.params.sizeMultiplier);
          const ee = (se = W, oe = te, ce = h, { u_matrix: Float32Array.from(N), u_up: se, u_right: oe, u_intensity_multiplier: ce });
          var se, oe, ce;
          t.uploadCommonUniforms(m, z), this.starsVx && this.starsIdx && z.draw(t, g.TRIANGLES, Wt.disabled, ci.disabled, this.colorModeAlphaBlendedWriteRGB, ti.disabled, ee, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function qi(c, t) {
        const s = [...c], h = t.cameraWorldSizeForFog / t.worldSize, m = i.ab.mat4.identity([]);
        return i.ab.mat4.scale(m, m, [h, h, 1]), i.ab.mat4.multiply(s, m, s), i.ab.mat4.multiply(s, t.worldToFogMatrix, s), s;
      }
      function hu(c, t, s, h, m) {
        const g = s.material, T = h.context, { baseColorTexture: z, metallicRoughnessTexture: R } = g.pbrMetallicRoughness, { normalTexture: F, occlusionTexture: N, emissionTexture: j } = g;
        function G(te, ee, se) {
          if (te && (c.push(ee), T.activeTexture.set(T.gl.TEXTURE0 + se), te.gfxTexture)) {
            const { minFilter: oe, magFilter: ce, wrapS: _e, wrapT: pe } = te.sampler;
            te.gfxTexture.bindExtraParam(oe, ce, _e, pe);
          }
        }
        G(z, "HAS_TEXTURE_u_baseColorTexture", bs.BaseColor), G(R, "HAS_TEXTURE_u_metallicRoughnessTexture", bs.MetallicRoughness), G(F, "HAS_TEXTURE_u_normalTexture", bs.Normal), G(N, "HAS_TEXTURE_u_occlusionTexture", bs.Occlusion), G(j, "HAS_TEXTURE_u_emissionTexture", bs.Emission), m && (m.texture || (m.texture = new i.dk(h.context, m.image, [m.image.height, m.image.height, m.image.height], T.gl.RGBA8)), T.activeTexture.set(T.gl.TEXTURE0 + bs.LUT), m.texture && m.texture.bind(T.gl.LINEAR, T.gl.CLAMP_TO_EDGE), c.push("APPLY_LUT_ON_GPU")), s.texcoordBuffer && (c.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(s.texcoordBuffer)), s.colorBuffer && (c.push(s.colorBuffer.itemSize === 12 ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), t.push(s.colorBuffer)), s.normalBuffer && (c.push("HAS_ATTRIBUTE_a_normal_3f"), t.push(s.normalBuffer)), s.pbrBuffer && (c.push("HAS_ATTRIBUTE_a_pbr"), c.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), t.push(s.pbrBuffer)), g.alphaMode !== "OPAQUE" && g.alphaMode !== "MASK" || c.push("UNPREMULT_TEXTURE_IN_SHADER"), g.defined || c.push("DIFFUSE_SHADED"), c.push("USE_STANDARD_DERIVATIVES");
        const W = h.shadowRenderer;
        W && (c.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), W.useNormalOffset && c.push("NORMAL_OFFSET"));
      }
      function Io(c, t, s, h, m, g) {
        const T = s.paint.get("model-opacity").constantOr(1), z = t.context, R = new Wt(t.context.gl.LEQUAL, Wt.ReadWrite, t.depthRangeFor3D), F = t.transform, N = c.mesh, j = N.material, G = j.pbrMetallicRoughness, W = t.style.fog;
        let te;
        te = t.transform.projection.zAxisUnit === "pixels" ? [...c.nodeModelMatrix] : i.ab.mat4.multiply([], h.zScaleMatrix, c.nodeModelMatrix), i.ab.mat4.multiply(te, h.negCameraPosMatrix, te);
        const ee = i.ab.mat4.invert([], te);
        i.ab.mat4.transpose(ee, ee);
        const se = s.paint.get("model-color-use-theme").constantOr("default") === "none", oe = s.paint.get("model-emissive-strength").constantOr(0), ce = pd(new Float32Array(c.worldViewProjection), new Float32Array(te), new Float32Array(ee), null, t, T, G.baseColorFactor.toRenderColor(null), j.emissiveFactor, G.metallicFactor, G.roughnessFactor, j, oe, s), _e = { defines: [] }, pe = [], Te = t.shadowRenderer;
        Te && (Te.useNormalOffset = !1), hu(_e.defines, pe, N, t, se ? null : s.lut);
        let xe = null;
        if (W) {
          const Pe = qi(c.nodeModelMatrix, t.transform);
          if (xe = new Float32Array(Pe), F.projection.name !== "globe") {
            const Oe = N.aabb.min, Xe = N.aabb.max, [Ze, ke] = W.getOpacityForBounds(Pe, Oe[0], Oe[1], Xe[0], Xe[1]);
            _e.overrideFog = Ze >= It || ke >= It;
          }
        }
        const be = To(t, s.paint.get("model-cutoff-fade-range"));
        be.shouldRenderCutoff && _e.defines.push("RENDER_CUTOFF");
        const ve = t.getOrCreateProgram("model", _e);
        t.uploadCommonUniforms(z, ve, null, xe, be), t.renderPass !== "shadow" && Te && Te.setupShadowsFromMatrix(c.nodeModelMatrix, ve), ve.draw(t, z.gl.TRIANGLES, R, m, g, N.material.doubleSided ? ti.disabled : ti.backCCW, ce, s.id, N.vertexBuffer, N.indexBuffer, N.segments, s.paint, t.transform.zoom, void 0, pe);
      }
      function nh(c, t, s, h, m, g, T) {
        let z;
        z = c.projection.name === "globe" ? i.dl(s, c) : [...s], i.ab.mat4.multiply(z, z, t.matrix);
        const R = i.ab.mat4.multiply([], h, z);
        if (t.meshes)
          for (const F of t.meshes) {
            if (F.material.alphaMode !== "BLEND") {
              T.push({ mesh: F, depth: 0, modelIndex: m, worldViewProjection: R, nodeModelMatrix: z });
              continue;
            }
            const N = i.ab.vec3.transformMat4([], F.centroid, R);
            N[2] > 0 && g.push({ mesh: F, depth: N[2], modelIndex: m, worldViewProjection: R, nodeModelMatrix: z });
          }
        if (t.children)
          for (const F of t.children)
            nh(c, F, s, h, m, g, T);
      }
      function qa(c, t, s, h) {
        const m = s.shadowRenderer;
        if (!m)
          return;
        const g = m.getShadowPassDepthMode(), T = m.getShadowPassColorMode(), z = m.calculateShadowPassMatrixFromMatrix(t), R = $f(z);
        s.getOrCreateProgram("modelDepth", { defines: s._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(s, s.context.gl.TRIANGLES, g, ci.disabled, T, ti.backCCW, R, h.id, c.vertexBuffer, c.indexBuffer, c.segments, h.paint, s.transform.zoom, void 0, void 0);
      }
      function xd(c, t, s) {
        const h = t.updateZoomBasedPaintProperties(), m = function(g, T, z) {
          let R, F, N, j = g.terrain ? g.terrain.exaggeration() : 0;
          if (g.terrain && j > 0) {
            const G = g.terrain, W = G.findDEMTileFor(z);
            W && W.dem ? R = i.dn.create(G, z, W) : j = 0;
          }
          if (j === 0 && (T.terrainElevationMin = 0, T.terrainElevationMax = 0), j === T.validForExaggeration && (j === 0 || R && R._demTile && R._demTile.tileID === T.validForDEMTile.id && R._dem._timestamp === T.validForDEMTile.timestamp))
            return !1;
          for (const G in T.instancesPerModel) {
            const W = T.instancesPerModel[G];
            for (let te = 0; te < W.instancedDataArray.length; ++te) {
              const ee = (R ? j * R.getElevationAt(0 | W.instancedDataArray.float32[16 * te], 0 | W.instancedDataArray.float32[16 * te + 1], !0, !0) : 0) + W.instancesEvaluatedElevation[te];
              W.instancedDataArray.float32[16 * te + 6] = ee, F = F ? Math.min(T.terrainElevationMin, ee) : ee, N = N ? Math.max(T.terrainElevationMax, ee) : ee;
            }
          }
          return T.terrainElevationMin = F || 0, T.terrainElevationMax = N || 0, T.validForExaggeration = j, T.validForDEMTile = R && R._demTile ? { id: R._demTile.tileID, timestamp: R._dem._timestamp } : { id: void 0, timestamp: 0 }, !0;
        }(c, t, s);
        (h || m) && (t.uploaded = !1, t.upload(c.context));
      }
      const ho = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new i.cd([0, 0, 0], [i.ag, i.ag, 0]) };
      function Wa(c, t) {
        const s = 1 << c.canonical.z, h = t.getFreeCameraOptions().position, m = t.elevation, g = c.canonical.x / s, T = (c.canonical.x + 1) / s, z = c.canonical.y / s, R = (c.canonical.y + 1) / s;
        let F = t._centerAltitude;
        if (m) {
          const W = m.getMinMaxForTile(c);
          W && W.max > F && (F = W.max);
        }
        const N = i.aw(h.x, g, T) - h.x, j = i.aw(h.y, z, R) - h.y, G = i.bH(F, t.center.lat) - h.z;
        return t._zoomFromMercatorZ(Math.sqrt(N * N + j * j + G * G));
      }
      function xa(c, t, s, h, m, g, T) {
        const z = c.context, R = c.renderPass === "shadow", F = c.shadowRenderer, N = R && F ? F.getShadowPassDepthMode() : new Wt(z.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D), j = c.isTileAffectedByFog(g);
        if (s.meshes)
          for (const G of s.meshes) {
            const W = ["MODEL_POSITION_ON_GPU"], te = [];
            let ee, se, oe;
            h.instancedDataArray.length > 20 && W.push("INSTANCED_ARRAYS");
            const ce = To(c, t.paint.get("model-cutoff-fade-range"));
            if (ce.shouldRenderCutoff && W.push("RENDER_CUTOFF"), R && F)
              ee = c.getOrCreateProgram("modelDepth", { defines: W }), se = $f(T.shadowTileMatrix, T.shadowTileMatrix, Float32Array.from(s.matrix)), oe = F.getShadowPassColorMode();
            else {
              hu(W, te, G, c, t.paint.get("model-color-use-theme").constantOr("default") === "none" ? null : t.lut), ee = c.getOrCreateProgram("model", { defines: W, overrideFog: j });
              const pe = G.material, Te = pe.pbrMetallicRoughness, xe = t.paint.get("model-opacity").constantOr(1), be = t.paint.get("model-emissive-strength").constantOr(0);
              se = pd(g.expandedProjMatrix, Float32Array.from(s.matrix), new Float32Array(16), null, c, xe, Te.baseColorFactor.toRenderColor(null), pe.emissiveFactor, Te.metallicFactor, Te.roughnessFactor, pe, be, t, m), F && (T.shadowUniformsInitialized ? ee.setShadowUniformValues(z, F.getShadowUniformValues()) : (F.setupShadows(g.toUnwrapped(), ee, "model-tile", g.overscaledZ), T.shadowUniformsInitialized = !0)), oe = ce.shouldRenderCutoff || xe < 1 || pe.alphaMode !== "OPAQUE" ? bi.alphaBlended : bi.unblended;
            }
            c.uploadCommonUniforms(z, ee, g.toUnwrapped(), null, ce);
            const _e = G.material.doubleSided ? ti.disabled : ti.backCCW;
            if (h.instancedDataArray.length > 20)
              te.push(h.instancedDataBuffer), ee.draw(c, z.gl.TRIANGLES, N, ci.disabled, oe, _e, se, t.id, G.vertexBuffer, G.indexBuffer, G.segments, t.paint, c.transform.zoom, void 0, te, h.instancedDataArray.length);
            else {
              const pe = R ? "u_instance" : "u_normal_matrix";
              for (let Te = 0; Te < h.instancedDataArray.length; ++Te)
                se[pe] = new Float32Array(h.instancedDataArray.arrayBuffer, 64 * Te, 16), ee.draw(c, z.gl.TRIANGLES, N, ci.disabled, oe, _e, se, t.id, G.vertexBuffer, G.indexBuffer, G.segments, t.paint, c.transform.zoom, void 0, te);
            }
          }
        if (s.children)
          for (const G of s.children)
            xa(c, t, G, h, m, g, T);
      }
      const $a = [1, -1, 1];
      function uu(c, t, s, h) {
        if (!s.modelManager)
          return !0;
        const m = s.modelManager;
        if (!s.shadowRenderer)
          return !0;
        const g = s.shadowRenderer, T = t.aabb;
        let z = !0, R = c.maxHeight;
        if (R === 0) {
          let N = 0;
          for (const j in c.instancesPerModel) {
            const G = m.getModel(j, h);
            G ? N = Math.max(N, Math.max(Math.max(G.aabb.max[0], G.aabb.max[1]), G.aabb.max[2])) : z = !1;
          }
          R = c.maxScale * N * 1.41 + c.maxVerticalOffset, z && (c.maxHeight = R);
        }
        T.max[2] = R, T.min[2] += c.terrainElevationMin, T.max[2] += c.terrainElevationMax, i.ab.vec3.transformMat4(T.min, T.min, t.tileMatrix), i.ab.vec3.transformMat4(T.max, T.max, t.tileMatrix);
        const F = T.intersects(g.getCurrentCascadeFrustum());
        return s.currentShadowCascade === 0 && (c.isInsideFirstShadowMapFrustum = F === 2), F === 0;
      }
      function du(c, t) {
        const s = c.uniformValues.u_cutoff_params[0], h = c.uniformValues.u_cutoff_params[1], m = c.uniformValues.u_cutoff_params[2], g = c.uniformValues.u_cutoff_params[3];
        return h === s || g === m ? 1 : i.aw(((t - s) / (h - s) - m) / (g - m), 0, 1);
      }
      function vd(c, t, s, h) {
        if (t.pitch < 20)
          return 1;
        const m = t.getWorldToCameraMatrix();
        i.ab.mat4.multiply(m, m, c);
        const g = i.ab.vec4.fromValues(s.min[0], s.min[1], s.min[2], 1);
        let T = i.ab.vec4.transformMat4(i.ab.vec4.create(), g, m), z = T, R = T;
        g[1] = s.max[1], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), g, m), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R, g[0] = s.max[0], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), g, m), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R, g[1] = s.min[1], T = i.ab.vec4.transformMat4(i.ab.vec4.create(), g, m), z = T[1] < z[1] ? T : z, R = T[1] > R[1] ? T : R;
        const F = i.aw(h[0], 0, 1), N = 100 * t.pixelsPerMeter * i.aw(h[1], 0, 1), j = i.aw(h[2], 0, 1), G = i.ab.vec4.lerp(i.ab.vec4.create(), z, R, F), W = Math.tan(0.5 * t.fovX), te = -G[2] * W;
        if (N === 0)
          return G[1] < -Math.abs(te) ? j : 1;
        const ee = (-Math.abs(te) - G[1]) / N, se = (ce, _e, pe) => (1 - pe) * ce + pe * _e, oe = i.aw(se(1, j, ee), j, 1);
        return se(1, oe, i.aw((t.pitch - 20) / 20, 0, 1));
      }
      class bd {
      }
      class wd {
        constructor() {
          this._storage = /* @__PURE__ */ new Map();
        }
        getLinesFromTrianglesBuffer(t, s, h) {
          {
            const j = this._storage.get(s.id);
            if (j)
              return j.lastUsedFrameIdx = t, j.buf;
          }
          const m = h.gl, g = m.getBufferParameter(m.ELEMENT_ARRAY_BUFFER, m.BUFFER_SIZE), T = new ArrayBuffer(g), z = new Int16Array(T);
          m.getBufferSubData(m.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(T));
          const R = new i.dq();
          for (let j = 0; j < g / 2; j += 3) {
            const G = z[j], W = z[j + 1], te = z[j + 2];
            R.emplaceBack(G, W), R.emplaceBack(W, te), R.emplaceBack(te, G);
          }
          const F = h.bindVertexArrayOES.current, N = new bd();
          return N.buf = new Qo(h, R), N.lastUsedFrameIdx = t, this._storage.set(s.id, N), h.bindVertexArrayOES.set(F), N.buf;
        }
        update(t) {
          for (const [s, h] of this._storage)
            t - h.lastUsedFrameIdx > 30 && (h.buf.destroy(), this._storage.delete(s));
        }
        destroy() {
          for (const [t, s] of this._storage)
            s.buf.destroy(), this._storage.delete(t);
        }
      }
      class Xa {
        constructor(t) {
          this.occluderSize = 30, this.depthOffset = -1e-4, t.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), t.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
        }
      }
      const Td = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
      class fu {
        registerParameter() {
        }
        registerButton() {
        }
        registerBinding() {
        }
        refreshUI() {
        }
      }
      class pu {
        constructor(t, s) {
          this.revealStart = 11, this.revealRange = 2, t.registerParameter(this, [...s, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), t.registerParameter(this, [...s, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
        }
      }
      const Sd = i.da([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
      class qs {
        destroy() {
          this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
        }
        draw(t, s) {
          const h = t.getOrCreateProgram("vignette");
          if (!this.vignetteVx || !this.vignetteIdx) {
            const T = new i.dr(), z = new i.aU();
            T.emplaceBack(-1, -1), T.emplaceBack(1, -1), T.emplaceBack(1, 1), T.emplaceBack(-1, 1), z.emplaceBack(0, 1, 2), z.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(T, Sd.members), this.vignetteIdx = t.context.createIndexBuffer(z);
          }
          const m = i.b7.simpleSegment(0, 0, 4, 6);
          if (this.vignetteVx && this.vignetteIdx) {
            t.uploadCommonUniforms(t.context, h);
            const T = { u_vignetteShape: (g = { vignetteShape: [s.start, s.range, Math.pow(10, s.fadePower)], vignetteColor: [s.color.r, s.color.g, s.color.b, s.color.a * s.strength] }).vignetteShape, u_vignetteColor: g.vignetteColor };
            h.draw(t, t.context.gl.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, T, "vignette", this.vignetteVx, this.vignetteIdx, m, {});
          }
          var g;
        }
      }
      class Md {
        constructor() {
          this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
        }
        update(t, s) {
          const h = t.getFreeCameraOptions().position, m = h.toAltitude(), g = h.toLngLat(), T = i.ai(g.lng), z = i.ai(g.lat), R = t.pixelsPerMeter / s, F = T * i.ds, N = i.ds * Math.log(Math.tan(Math.PI / 4 + z / 2));
          if (this._offsetXPrev === void 0)
            this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
          else {
            const j = -this._offsetYPrev + N, G = -this._elevationPrev + m;
            this._accumulatedOffsetX += (-this._offsetXPrev + F) * R, this._accumulatedOffsetY += j * R, this._accumulatedElevation += G * R, this._offsetXPrev = F, this._offsetYPrev = N, this._elevationPrev = m;
          }
        }
        getPosition() {
          return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
        }
      }
      function mu(c, t) {
        return [-(c[0] - Math.floor(c[0] / t) * t), -(c[1] - Math.floor(c[1] / t) * t), -(c[2] - Math.floor(c[2] / t) * t)];
      }
      function cc(c) {
        const t = i.di(1323123451230), s = [];
        for (let h = 0; h < c; ++h) {
          const m = 2 * t() - 1, g = 2 * t() - 1, T = 2 * t() - 1;
          s.push(i.ab.vec3.fromValues(m, g, T));
        }
        return s;
      }
      function Rr(c, t, s, h, m) {
        const g = i.aw((m - s) / (h - s), 0, 1);
        return (1 - g) * c + g * t;
      }
      class _u {
        constructor(t) {
          this._movement = new Md(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new qs(), this._ppmScaleFactor = t;
        }
        destroy() {
          this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
        }
        updateOnRender(t, s) {
          const h = t.transform;
          this._movement.update(h, this._ppmScaleFactor);
          const m = h.starsProjMatrix, g = i.ab.quat.identity([]);
          i.ab.quat.rotateX(g, g, i.ai(90) - h._pitch), i.ab.quat.rotateZ(g, g, -h.angle);
          const T = i.ab.mat4.fromQuat(new Float32Array(16), g), z = i.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), R = i.ab.mat4.transpose([], z), F = i.ab.mat4.multiply([], R, T), N = Date.now() / 1e3;
          return this._accumulatedTimeFromStart += (N - this._prevTime) * s, this._prevTime = N, { projectionMatrix: m, modelviewMatrix: F };
        }
      }
      class Ed extends _u {
        constructor(t) {
          super(4.25), this._params = { overrideStyleParameters: !1, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new pu(t.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t) {
          const s = t.context;
          if (!this.particlesVx) {
            const h = cc(this.particlesCount), m = new i.dt(), g = new i.aU();
            let T = 0;
            const z = i.di(1323123451230);
            for (let R = 0; R < h.length; ++R) {
              const F = h[R], N = [2 * z() - 1, z(), z(), z()];
              m.emplaceBack(F[0], F[1], F[2], -1, -1, ...N), m.emplaceBack(F[0], F[1], F[2], 1, -1, ...N), m.emplaceBack(F[0], F[1], F[2], 1, 1, ...N), m.emplaceBack(F[0], F[1], F[2], -1, 1, ...N), g.emplaceBack(T + 0, T + 1, T + 2), g.emplaceBack(T + 0, T + 2, T + 3), T += 4;
            }
            this.particlesVx = s.createVertexBuffer(m, Td.members), this.particlesIdx = s.createIndexBuffer(g);
          }
        }
        draw(t) {
          if (!this._params.overrideStyleParameters && !t.style.rain)
            return;
          const s = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, h = t.transform.zoom;
          if (s.revealStart > h)
            return;
          const m = Rr(0, 1, s.revealStart, s.revealStart + s.revealRange, h);
          if (!this.particlesVx || !this.particlesIdx)
            return;
          const g = structuredClone(this._params);
          let T = [-g.direction.x, g.direction.y, -100];
          i.ab.vec3.normalize(T, T);
          const z = structuredClone(this._vignetteParams);
          z.strength *= m, g.overrideStyleParameters || (g.intensity = t.style.rain.state.density, g.timeFactor = t.style.rain.state.intensity, g.color = structuredClone(t.style.rain.state.color), T = structuredClone(t.style.rain.state.direction), g.screenThinning.intensity = t.style.rain.state.centerThinning, g.dropletSizeX = t.style.rain.state.dropletSize[0], g.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], g.distortionStrength = 100 * t.style.rain.state.distortionStrength, z.strength = 1, z.color = structuredClone(t.style.rain.state.vignetteColor));
          const R = this.updateOnRender(t, g.timeFactor), F = t.context, N = F.gl, j = t.transform;
          this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new i.T(F, { width: t.width, height: t.height, data: null }, N.RGBA8)), g.distortionStrength > 0 && (F.activeTexture.set(N.TEXTURE0), this.screenTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE), N.copyTexSubImage2D(N.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));
          const G = t.getOrCreateProgram("rainParticle");
          t.uploadCommonUniforms(F, G), F.activeTexture.set(N.TEXTURE0), this.screenTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE);
          const W = [g.color.r, g.color.g, g.color.b, g.color.a], te = (ee, se) => {
            const oe = mu(this._movement.getPosition(), ee), ce = g.dropletSizeX, _e = g.dropletSizeX * g.dropletSizeYScale, pe = t.width / 2, Te = t.height / 2, xe = Rr(0, g.screenThinning.start, 0, 1, g.screenThinning.intensity), be = Rr(1e-3, g.screenThinning.range, 0, 1, g.screenThinning.intensity), ve = Rr(0, g.screenThinning.particleOffset, 0, 1, g.screenThinning.intensity), Pe = (Oe = { modelview: R.modelviewMatrix, projection: R.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: oe, velocityConeAperture: g.velocityConeAperture, velocity: g.velocity, boxSize: ee, rainDropletSize: [ce, _e], distortionStrength: g.distortionStrength, rainDirection: T, color: W, screenSize: [j.width, j.height], thinningCenterPos: [pe, Te], thinningShape: [xe, be, Math.pow(10, g.screenThinning.fadePower)], thinningAffectedRatio: g.screenThinning.affectedRatio, thinningParticleOffset: ve, shapeDirectionalPower: g.shapeDirPower, shapeNormalPower: g.shapeNormalPower, mode: se ? 0 : 1 }, { u_modelview: Float32Array.from(Oe.modelview), u_projection: Float32Array.from(Oe.projection), u_time: Oe.time, u_cam_pos: Oe.camPos, u_texScreen: 0, u_velocityConeAperture: Oe.velocityConeAperture, u_velocity: Oe.velocity, u_boxSize: Oe.boxSize, u_rainDropletSize: Oe.rainDropletSize, u_distortionStrength: Oe.distortionStrength, u_rainDirection: Oe.rainDirection, u_color: Oe.color, u_screenSize: Oe.screenSize, u_thinningCenterPos: Oe.thinningCenterPos, u_thinningShape: Oe.thinningShape, u_thinningAffectedRatio: Oe.thinningAffectedRatio, u_thinningParticleOffset: Oe.thinningParticleOffset, u_shapeDirectionalPower: Oe.shapeDirectionalPower, u_shapeNormalPower: Oe.shapeNormalPower, u_mode: Oe.mode });
            var Oe;
            const Xe = Math.round(m * g.intensity * this.particlesCount), Ze = i.b7.simpleSegment(0, 0, 4 * Xe, 2 * Xe);
            G.draw(t, N.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, Pe, "rain_particles", this.particlesVx, this.particlesIdx, Ze, {});
          };
          g.distortionStrength > 0 && te(g.boxSize, !0), te(g.boxSize, !1), this._vignette.draw(t, z);
        }
      }
      const Ad = i.da([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
      class Ml extends _u {
        constructor(t) {
          super(2.25), this._params = { overrideStyleParameters: !1, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new pu(t.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
        }
        update(t) {
          const s = t.context;
          if (!this.particlesVx) {
            const h = cc(this.particlesCount), m = new i.du(), g = new i.aU();
            let T = 0;
            const z = i.di(1323123451230);
            for (let R = 0; R < h.length; ++R) {
              const F = h[R], N = z(), j = z(), G = z(), W = [R / h.length, N, j, G], te = [z(), z()];
              m.emplaceBack(F[0], F[1], F[2], -1, -1, ...W, ...te), m.emplaceBack(F[0], F[1], F[2], 1, -1, ...W, ...te), m.emplaceBack(F[0], F[1], F[2], 1, 1, ...W, ...te), m.emplaceBack(F[0], F[1], F[2], -1, 1, ...W, ...te), g.emplaceBack(T + 0, T + 1, T + 2), g.emplaceBack(T + 0, T + 2, T + 3), T += 4;
            }
            this.particlesVx = s.createVertexBuffer(m, Ad.members), this.particlesIdx = s.createIndexBuffer(g);
          }
        }
        draw(t) {
          if (!this._params.overrideStyleParameters && !t.style.snow)
            return;
          const s = structuredClone(this._params);
          let h = [-s.direction.x, s.direction.y, -100];
          i.ab.vec3.normalize(h, h);
          const m = structuredClone(this._vignetteParams), g = s.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, T = t.transform.zoom;
          if (g.revealStart > T)
            return;
          const z = Rr(0, 1, g.revealStart, g.revealStart + g.revealRange, T);
          m.strength *= z, s.overrideStyleParameters || (s.intensity = t.style.snow.state.density, s.timeFactor = t.style.snow.state.intensity, s.color = structuredClone(t.style.snow.state.color), h = structuredClone(t.style.snow.state.direction), s.screenThinning.intensity = t.style.snow.state.centerThinning, s.billboardSize = 2.79 * t.style.snow.state.flakeSize, m.strength = 1, m.color = structuredClone(t.style.snow.state.vignetteColor));
          const R = this.updateOnRender(t, s.timeFactor);
          if (!this.particlesVx || !this.particlesIdx)
            return;
          const F = t.context, N = F.gl, j = t.transform, G = t.getOrCreateProgram("snowParticle");
          t.uploadCommonUniforms(F, G), ((W, te, ee) => {
            const se = mu(this._movement.getPosition(), W), oe = j.width / 2, ce = j.height / 2, _e = Rr(0, ee.screenThinning.start, 0, 1, ee.screenThinning.intensity), pe = Rr(1e-3, ee.screenThinning.range, 0, 1, ee.screenThinning.intensity), Te = Rr(0, ee.screenThinning.particleOffset, 0, 1, ee.screenThinning.intensity), xe = (be = { modelview: R.modelviewMatrix, projection: R.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: se, velocityConeAperture: ee.velocityConeAperture, velocity: ee.velocity, horizontalOscillationRadius: ee.horizontalOscillationRadius, horizontalOscillationRate: ee.horizontalOscillationRate, boxSize: W, billboardSize: 1 * ee.billboardSize, simpleShapeParameters: [ee.shapeFadeStart, ee.shapeFadePower], screenSize: [j.width, j.height], thinningCenterPos: [oe, ce], thinningShape: [_e, pe, Math.pow(10, ee.screenThinning.fadePower)], thinningAffectedRatio: ee.screenThinning.affectedRatio, thinningParticleOffset: Te, color: [ee.color.r, ee.color.g, ee.color.b, ee.color.a], direction: h }, { u_modelview: Float32Array.from(be.modelview), u_projection: Float32Array.from(be.projection), u_time: be.time, u_cam_pos: be.camPos, u_velocityConeAperture: be.velocityConeAperture, u_velocity: be.velocity, u_horizontalOscillationRadius: be.horizontalOscillationRadius, u_horizontalOscillationRate: be.horizontalOscillationRate, u_boxSize: be.boxSize, u_billboardSize: be.billboardSize, u_simpleShapeParameters: be.simpleShapeParameters, u_screenSize: be.screenSize, u_thinningCenterPos: be.thinningCenterPos, u_thinningShape: be.thinningShape, u_thinningAffectedRatio: be.thinningAffectedRatio, u_thinningParticleOffset: be.thinningParticleOffset, u_particleColor: be.color, u_direction: be.direction });
            var be;
            const ve = Math.round(z * ee.intensity * this.particlesCount), Pe = i.b7.simpleSegment(0, 0, 4 * ve, 2 * ve);
            this.particlesVx && this.particlesIdx && G.draw(t, N.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, xe, "snow_particles", this.particlesVx, this.particlesIdx, Pe, {});
          })(s.boxSize, 0, s), this._vignette.draw(t, m);
        }
      }
      const sh = { symbol: function(c, t, s, h, m) {
        if (c.renderPass !== "translucent")
          return;
        const g = ci.disabled, T = c.colorModeForRenderPass(), z = s.layout.get("text-variable-anchor"), R = s.layout.get("text-size-scale-range"), F = i.aw(c.scaleFactor, R[0], R[1]);
        z && function(G, W, te, ee, se, oe, ce, _e) {
          const pe = W.transform, Te = se === "map", xe = oe === "map";
          for (const be of G) {
            const ve = ee.getTile(be), Pe = ve.getBucket(te);
            if (!Pe || !Pe.text || !Pe.text.segments.get().length)
              continue;
            const Oe = i.bp(Pe.textSizeData, pe.zoom, _e), Xe = fa(be, Pe.getProjection(), pe), Ze = pe.calculatePixelsToTileUnitsMatrix(ve), ke = Ks(Xe, ve.tileID.canonical, xe, Te, pe, Pe.getProjection(), Ze), Ne = Pe.hasIconTextFit() && Pe.hasIconData();
            if (Oe) {
              const st = Math.pow(2, pe.zoom - ve.tileID.overscaledZ);
              co(Pe, Te, xe, ce, i.cX, pe, ke, be, st, Oe, Ne);
            }
          }
        }(h, c, s, t, s.layout.get("text-rotation-alignment"), s.layout.get("text-pitch-alignment"), m, F);
        const N = s.paint.get("icon-opacity").constantOr(1) !== 0, j = s.paint.get("text-opacity").constantOr(1) !== 0;
        s.layout.get("symbol-sort-key").constantOr(1) !== void 0 && (N || j) ? Tn(c, t, s, h, g, T) : (N && Tn(c, t, s, h, g, T, { onlyIcons: !0 }), j && Tn(c, t, s, h, g, T, { onlyText: !0 })), t.map.showCollisionBoxes && (su(c, t, s, h, s.paint.get("text-translate"), s.paint.get("text-translate-anchor"), !0), su(c, t, s, h, s.paint.get("icon-translate"), s.paint.get("icon-translate-anchor"), !1));
      }, circle: function(c, t, s, h) {
        if (c.renderPass !== "translucent")
          return;
        const m = s.paint.get("circle-opacity"), g = s.paint.get("circle-stroke-width"), T = s.paint.get("circle-stroke-opacity"), z = s.layout.get("circle-sort-key").constantOr(1) !== void 0, R = s.paint.get("circle-emissive-strength");
        if (m.constantOr(1) === 0 && (g.constantOr(1) === 0 || T.constantOr(1) === 0))
          return;
        const F = c.context, N = F.gl, j = c.transform, G = c.depthModeForSublayer(0, Wt.ReadOnly), W = ci.disabled, te = c.colorModeForDrapableLayerRenderPass(R), ee = j.projection.name === "globe", se = [i.at(j.center.lng), i.aA(j.center.lat)], oe = [];
        for (let _e = 0; _e < h.length; _e++) {
          const pe = h[_e], Te = t.getTile(pe), xe = Te.getBucket(s);
          if (!xe || xe.projection.name !== j.projection.name)
            continue;
          const be = xe.programConfigurations.get(s.id), ve = i.cY(s), Pe = c.isTileAffectedByFog(pe);
          ee && ve.push("PROJECTION_GLOBE_VIEW"), ve.push("DEPTH_D24"), c.terrain && j.depthOcclusionForSymbolsAndCircles && ve.push("DEPTH_OCCLUSION");
          const Oe = c.getOrCreateProgram("circle", { config: be, defines: ve, overrideFog: Pe }), Xe = xe.layoutVertexBuffer, Ze = xe.globeExtVertexBuffer, ke = xe.indexBuffer, Ne = j.projection.createInversionMatrix(j, pe.canonical), st = { programConfiguration: be, program: Oe, layoutVertexBuffer: Xe, globeExtVertexBuffer: Ze, indexBuffer: ke, uniformValues: i.cZ(c, pe, Te, Ne, se, s), tile: Te };
          if (z) {
            const ht = xe.segments.get();
            for (const yt of ht)
              oe.push({ segments: new i.b7([yt]), sortKey: yt.sortKey, state: st });
          } else
            oe.push({ segments: xe.segments, sortKey: 0, state: st });
        }
        z && oe.sort((_e, pe) => _e.sortKey - pe.sortKey);
        const ce = { useDepthForOcclusion: j.depthOcclusionForSymbolsAndCircles };
        for (const _e of oe) {
          const { programConfiguration: pe, program: Te, layoutVertexBuffer: xe, globeExtVertexBuffer: be, indexBuffer: ve, uniformValues: Pe, tile: Oe } = _e.state, Xe = _e.segments;
          c.terrain && c.terrain.setupElevationDraw(Oe, Te, ce), c.uploadCommonUniforms(F, Te, Oe.tileID.toUnwrapped()), Te.draw(c, N.TRIANGLES, G, W, te, ti.disabled, Pe, s.id, xe, ve, Xe, s.paint, j.zoom, pe, [be]);
        }
      }, heatmap: function(c, t, s, h) {
        if (s.paint.get("heatmap-opacity") !== 0)
          if (c.renderPass === "offscreen") {
            const m = c.context, g = m.gl, T = ci.disabled, z = new bi([g.ONE, g.ONE, g.ONE, g.ONE], i.aj.transparent, [!0, !0, !0, !0]);
            (function(W, te, ee, se) {
              const oe = W.gl, ce = te.width * se, _e = te.height * se;
              W.activeTexture.set(oe.TEXTURE1), W.viewport.set([0, 0, ce, _e]);
              let pe = ee.heatmapFbo;
              if (!pe || pe && (pe.width !== ce || pe.height !== _e)) {
                pe && pe.destroy();
                const Te = oe.createTexture();
                oe.bindTexture(oe.TEXTURE_2D, Te), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_S, oe.CLAMP_TO_EDGE), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_WRAP_T, oe.CLAMP_TO_EDGE), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MIN_FILTER, oe.LINEAR), oe.texParameteri(oe.TEXTURE_2D, oe.TEXTURE_MAG_FILTER, oe.LINEAR), pe = ee.heatmapFbo = W.createFramebuffer(ce, _e, !0, null), function(xe, be, ve, Pe, Oe, Xe) {
                  const Ze = xe.gl;
                  Ze.texImage2D(Ze.TEXTURE_2D, 0, xe.extRenderToTextureHalfFloat ? Ze.RGBA16F : Ze.RGBA, Oe, Xe, 0, Ze.RGBA, xe.extRenderToTextureHalfFloat ? Ze.HALF_FLOAT : Ze.UNSIGNED_BYTE, null), Pe.colorAttachment.set(ve);
                }(W, 0, Te, pe, ce, _e);
              } else
                oe.bindTexture(oe.TEXTURE_2D, pe.colorAttachment.get()), W.bindFramebuffer.set(pe.framebuffer);
            })(m, c, s, c.transform.projection.name === "globe" ? 0.5 : 0.25), m.clear({ color: i.aj.transparent });
            const R = c.transform, F = R.projection.name === "globe", N = F ? ["PROJECTION_GLOBE_VIEW"] : [], j = F ? ti.frontCCW : ti.disabled, G = [i.at(R.center.lng), i.aA(R.center.lat)];
            for (let W = 0; W < h.length; W++) {
              const te = h[W];
              if (t.hasRenderableParent(te))
                continue;
              const ee = t.getTile(te), se = ee.getBucket(s);
              if (!se || se.projection.name !== R.projection.name)
                continue;
              const oe = c.isTileAffectedByFog(te), ce = se.programConfigurations.get(s.id), _e = c.getOrCreateProgram("heatmap", { config: ce, defines: N, overrideFog: oe }), { zoom: pe } = c.transform;
              c.terrain && c.terrain.setupElevationDraw(ee, _e), c.uploadCommonUniforms(m, _e, te.toUnwrapped());
              const Te = R.projection.createInversionMatrix(R, te.canonical);
              _e.draw(c, g.TRIANGLES, Wt.disabled, T, z, j, nc(c, te, ee, Te, G, pe, s.paint.get("heatmap-intensity")), s.id, se.layoutVertexBuffer, se.indexBuffer, se.segments, s.paint, c.transform.zoom, ce, F ? [se.globeExtVertexBuffer] : null);
            }
            m.viewport.set([0, 0, c.width, c.height]);
          } else
            c.renderPass === "translucent" && (c.context.setColorMode(c.colorModeForRenderPass()), function(m, g) {
              const T = m.context, z = T.gl, R = g.heatmapFbo;
              if (!R)
                return;
              T.activeTexture.set(z.TEXTURE0), z.bindTexture(z.TEXTURE_2D, R.colorAttachment.get()), T.activeTexture.set(z.TEXTURE1);
              let F = g.colorRampTexture;
              F || (F = g.colorRampTexture = new i.T(T, g.colorRamp, z.RGBA8)), F.bind(z.LINEAR, z.CLAMP_TO_EDGE), m.getOrCreateProgram("heatmapTexture").draw(m, z.TRIANGLES, Wt.disabled, ci.disabled, m.colorModeForRenderPass(), ti.disabled, ((N, j, G, W) => ({ u_image: 0, u_color_ramp: 1, u_opacity: j.paint.get("heatmap-opacity") }))(0, g), g.id, m.viewportBuffer, m.quadTriangleIndexBuffer, m.viewportSegments, g.paint, m.transform.zoom);
            }(c, s));
      }, line: function(c, t, s, h) {
        if (c.renderPass !== "translucent")
          return;
        const m = s.paint.get("line-opacity"), g = s.paint.get("line-width");
        if (m.constantOr(1) === 0 || g.constantOr(1) === 0)
          return;
        const T = s.paint.get("line-emissive-strength"), z = s.paint.get("line-occlusion-opacity"), R = s.layout.get("line-elevation-reference"), F = s.layout.get("line-width-unit") === "meters", N = R === "sea", j = c.context, G = j.gl, W = !s.isDraped();
        if (W && c.transform.projection.name === "globe")
          return;
        const te = s.layout.get("line-cross-slope"), ee = te !== void 0, se = te < 1, oe = W ? new Wt(c.depthOcclusion ? G.GREATER : G.LEQUAL, Wt.ReadOnly, c.depthRangeFor3D) : c.depthModeForSublayer(0, Wt.ReadOnly), ce = c.colorModeForDrapableLayerRenderPass(T), _e = c.terrain && c.terrain.renderingToTexture, pe = _e ? 1 : i.q.devicePixelRatio, Te = s.paint.get("line-dasharray"), xe = Te.constantOr(1), be = s.layout.get("line-cap"), ve = Te.constantOr(null), Pe = be.constantOr(null), Oe = s.paint.get("line-pattern"), Xe = Oe.constantOr(1), Ze = Oe.constantOr(null), ke = s.paint.get("line-opacity").constantOr(1);
        let Ne = !Xe && ke !== 1 || c.depthOcclusion && z > 0 && z < 1;
        const st = s.paint.get("line-gradient"), ht = Xe ? "linePattern" : "line", yt = i.c_(s);
        let je;
        if (_e && c.terrain && c.terrain.clipOrMaskOverlapStencilType() && (Ne = !1), z !== 0 && c.depthOcclusion) {
          const Je = s.paint._values["line-opacity"];
          Je && Je.value && Je.value.kind === "constant" ? je = Je.value : i.w(`Occlusion opacity for layer ${s.id} is supported only when line-opacity isn't data-driven.`);
        }
        if (W && (c.forceTerrainMode = !0), !W && z !== 0 && c.terrain && !_e)
          return void i.w(`Occlusion opacity for layer ${s.id} is supported on terrain only if the layer has line-z-offset enabled.`);
        const at = Ne && W ? c.stencilModeFor3D() : ci.disabled;
        W && (yt.push("ELEVATED"), ee && yt.push(se ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), N && yt.push("ELEVATION_REFERENCE_SEA")), g.value.kind !== "constant" && g.value.isLineProgressConstant === !1 && yt.push("VARIABLE_LINE_WIDTH");
        for (const Je of h) {
          const _t = t.getTile(Je);
          if (Xe && !_t.patternsLoaded())
            continue;
          const ct = _t.getBucket(s);
          if (!ct)
            continue;
          c.prepareDrawTile();
          const nt = ct.programConfigurations.get(s.id), Lt = c.isTileAffectedByFog(Je), xt = c.getOrCreateProgram(ht, { config: nt, defines: yt, overrideFog: Lt, overrideRtt: !W && void 0 });
          if (Ze && _t.imageAtlas) {
            const wi = i.A.from(Ze), mn = _t.imageAtlas.patternPositions[wi.getSerializedPrimary()];
            mn && nt.setConstantPatternPositions(mn);
          }
          if (!Xe && ve && Pe && _t.lineAtlas) {
            const wi = _t.lineAtlas.getDash(ve, Pe);
            wi && nt.setConstantPatternPositions(wi);
          }
          let [zt, Bt] = s.paint.get("line-trim-offset");
          (Pe === "round" || Pe === "square") && zt !== Bt && (zt === 0 && (zt -= 1), Bt === 1 && (Bt += 1));
          const oi = _e ? Je.projMatrix : null, $t = F ? 1 / ct.tileToMeter / i.ar(_t, 1, c.transform.zoom) : 1, Xt = F ? 1 / ct.tileToMeter / i.ar(_t, 1, Math.floor(c.transform.zoom)) : 1, ai = Xe ? i.c$(c, _t, s, oi, pe, $t, Xt, [zt, Bt]) : i.d0(c, _t, s, oi, ct.lineClipsArray.length, pe, $t, Xt, [zt, Bt]);
          if (st) {
            const wi = ct.gradients[s.id];
            let mn = wi.texture;
            if (s.gradientVersion !== wi.version) {
              let Sn = 256;
              if (s.stepInterpolant) {
                const Xi = t.getSource().maxzoom, sn = Je.canonical.z === Xi ? Math.ceil(1 << c.transform.maxZoom - Je.canonical.z) : 1;
                Sn = i.aw(i.d1(ct.maxLineLength / i.ag * 1024 * sn), 256, j.maxTextureSize);
              }
              wi.gradient = i.d2({ expression: s.gradientExpression(), evaluationKey: "lineProgress", resolution: Sn, image: wi.gradient || void 0, clips: ct.lineClipsArray }), wi.texture ? wi.texture.update(wi.gradient) : wi.texture = new i.T(j, wi.gradient, G.RGBA8), wi.version = s.gradientVersion, mn = wi.texture;
            }
            j.activeTexture.set(G.TEXTURE1), mn.bind(s.stepInterpolant ? G.NEAREST : G.LINEAR, G.CLAMP_TO_EDGE);
          }
          xe && (j.activeTexture.set(G.TEXTURE0), _t.lineAtlasTexture && _t.lineAtlasTexture.bind(G.LINEAR, G.REPEAT), nt.updatePaintBuffers()), Xe && (j.activeTexture.set(G.TEXTURE0), _t.imageAtlasTexture && _t.imageAtlasTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE), nt.updatePaintBuffers()), W && !N && c.terrain.setupElevationDraw(_t, xt), c.uploadCommonUniforms(j, xt, Je.toUnwrapped());
          const zi = (wi) => {
            je != null && (je.value = ke * z), xt.draw(c, G.TRIANGLES, oe, wi, ce, ti.disabled, ai, s.id, ct.layoutVertexBuffer, ct.indexBuffer, ct.segments, s.paint, c.transform.zoom, nt, [ct.layoutVertexBuffer2, ct.patternVertexBuffer, ct.zOffsetVertexBuffer]), je != null && (je.value = ke);
          };
          if (Ne && !W) {
            const wi = c.stencilModeForClipping(Je).ref;
            wi === 0 && _e && j.clear({ stencil: 0 });
            const mn = { func: G.EQUAL, mask: 255 };
            ai.u_alpha_discard_threshold = 0.8, zi(new ci(mn, wi, 255, G.KEEP, G.KEEP, G.INVERT)), ai.u_alpha_discard_threshold = 0, zi(new ci(mn, wi, 255, G.KEEP, G.KEEP, G.KEEP));
          } else
            Ne && W && (ai.u_alpha_discard_threshold = 1e-3), zi(W ? at : c.stencilModeForClipping(Je));
        }
        W && (c.forceTerrainMode = !1), Ne && (c.resetStencilClippingMasks(), _e && j.clear({ stencil: 0 })), z === 0 || c.depthOcclusion || _e || c.layersWithOcclusionOpacity.push(c.currentLayer);
      }, fill: function(c, t, s, h) {
        const m = s.paint.get("fill-color"), g = s.paint.get("fill-opacity"), T = s.is3D(), z = new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D);
        if (g.constantOr(1) === 0)
          return;
        const R = s.paint.get("fill-emissive-strength"), F = c.colorModeForDrapableLayerRenderPass(R), N = s.paint.get("fill-pattern"), j = c.opaquePassEnabledForLayer() && !N.constantOr(1) && m.constantOr(i.aj.transparent).a === 1 && g.constantOr(0) === 1 ? "opaque" : "translucent";
        if (c.renderPass === j) {
          const G = T ? z : c.depthModeForSublayer(1, c.renderPass === "opaque" ? Wt.ReadWrite : Wt.ReadOnly);
          ou(c, t, s, h, G, F, !1);
        }
        if (!T && c.renderPass === "translucent" && s.paint.get("fill-antialias")) {
          const G = T ? z : c.depthModeForSublayer(s.getPaintProperty("fill-outline-color") ? 2 : 0, Wt.ReadOnly);
          ou(c, t, s, h, G, F, !0);
        }
      }, "fill-extrusion": function(c, t, s, h) {
        const m = s.paint.get("fill-extrusion-opacity"), g = c.context, T = g.gl, z = c.terrain, R = z && z.renderingToTexture;
        if (m === 0)
          return;
        const F = c.conflationActive && c.style.isLayerClipped(s, t.getSource()), N = c.style.order.indexOf(s.fqid);
        if (F && function(j, G, W, te, ee) {
          for (const se of te) {
            const oe = G.getTile(se).getBucket(W);
            oe && (oe.updateReplacement(se, j.replacementSource, ee), oe.uploadCentroid(j.context));
          }
        }(c, t, s, h, N), z || F)
          for (const j of h) {
            const G = t.getTile(j).getBucket(s);
            G && Yf(c.context, t, j, G, s, z, F);
          }
        if (c.renderPass === "shadow" && c.shadowRenderer) {
          const j = c.shadowRenderer;
          if (z && m < 0.65 && s._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof i.a9)
            return;
          const G = j.getShadowPassDepthMode(), W = j.getShadowPassColorMode();
          Qc(c, t, s, h, G, ci.disabled, W, F);
        } else if (c.renderPass === "translucent") {
          const j = !s.paint.get("fill-extrusion-pattern").constantOr(1), G = s.paint.get("fill-extrusion-color").constantOr(i.aj.white);
          if (!R && G.a !== 0) {
            const W = new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D);
            m === 1 && j ? Qc(c, t, s, h, W, ci.disabled, bi.unblended, F) : (Qc(c, t, s, h, W, ci.disabled, bi.disabled, F), Qc(c, t, s, h, W, c.stencilModeFor3D(), c.colorModeForRenderPass(), F), c.resetStencilClippingMasks());
          }
          if (c.style.enable3dLights() && j && (!z && c.transform.projection.name !== "globe" || R)) {
            const W = s.paint.get("fill-extrusion-opacity"), te = s.paint.get("fill-extrusion-ambient-occlusion-intensity"), ee = s.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), se = s.paint.get("fill-extrusion-flood-light-intensity"), oe = s.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default") === "none", ce = s.paint.get("fill-extrusion-flood-light-color").toRenderColor(oe ? null : s.lut).toArray01().slice(0, 3), _e = te > 0 && ee > 0, pe = se > 0, Te = (be, ve, Pe) => (1 - Pe) * be + Pe * ve, xe = (be) => {
              const ve = c.depthModeForSublayer(1, Wt.ReadOnly, T.LEQUAL, !0), Pe = s.paint.get(be ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), Oe = Te(0.1, 3, Pe), Xe = c._showOverdrawInspector;
              if (!Xe) {
                const Ze = new ci({ func: T.ALWAYS, mask: 255 }, 255, 255, T.KEEP, T.KEEP, T.REPLACE), ke = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0], T.MIN);
                wl(c, t, s, h, ve, Ze, ke, ti.disabled, be, "sdf", W, te, ee, se, ce, Oe, F, !1);
              }
              {
                const Ze = Xe ? ci.disabled : new ci({ func: T.EQUAL, mask: 255 }, 255, 255, T.KEEP, T.DECR, T.DECR), ke = Xe ? c.colorModeForRenderPass() : new bi([T.ONE_MINUS_DST_ALPHA, T.DST_ALPHA, T.ONE, T.ONE], i.aj.transparent, [!0, !0, !0, !0]);
                wl(c, t, s, h, ve, Ze, ke, ti.disabled, be, "color", W, te, ee, se, ce, Oe, F, !1);
              }
            };
            if (R) {
              const be = (ve, Pe, Oe) => {
                const Xe = c.depthModeForSublayer(1, Wt.ReadOnly, T.LEQUAL, !1), Ze = s.paint.get(ve ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), ke = Te(0.1, 3, Ze);
                {
                  const Ne = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0]);
                  wl(c, t, s, h, Xe, ci.disabled, Ne, ti.disabled, ve, "clear", W, te, ee, se, ce, ke, F, Pe);
                }
                {
                  const Ne = new ci({ func: T.ALWAYS, mask: 255 }, 255, 255, T.KEEP, T.KEEP, T.REPLACE), st = new bi([T.ONE, T.ONE, T.ONE, T.ONE], i.aj.transparent, [!1, !1, !1, !0], T.MIN);
                  wl(c, t, s, h, Xe, Ne, st, ti.disabled, ve, "sdf", W, te, ee, se, ce, ke, F, Pe);
                }
                {
                  const Ne = ve ? T.ZERO : T.ONE_MINUS_DST_ALPHA, st = new ci({ func: T.EQUAL, mask: 255 }, 255, 255, T.KEEP, T.DECR, T.DECR), ht = new bi([Ne, T.DST_ALPHA, T.ONE_MINUS_DST_ALPHA, T.ZERO], i.aj.transparent, [!0, !0, !0, !0]);
                  wl(c, t, s, h, Xe, st, ht, ti.disabled, ve, "color", W, te, ee, se, ce, ke, F, Pe);
                }
                {
                  const Ne = new bi([T.ONE, T.ONE, T.ONE, ve ? T.ZERO : T.ONE], i.aj.transparent, [!1, !1, !1, !0], ve ? T.FUNC_ADD : T.MAX);
                  wl(c, t, s, h, Xe, ci.disabled, Ne, ti.disabled, ve, "clear", W, te, ee, se, ce, ke, F, Pe, Oe);
                }
              };
              if (_e || pe) {
                let ve;
                if (c.prepareDrawTile(), z) {
                  const Pe = z.drapeBufferSize[0], Oe = z.drapeBufferSize[1];
                  ve = z.framebufferCopyTexture, ve && (!ve || ve.size[0] === Pe && ve.size[1] === Oe) || (ve && ve.destroy(), ve = z.framebufferCopyTexture = new i.T(g, new i.r({ width: Pe, height: Oe }), T.RGBA8)), ve.bind(T.LINEAR, T.CLAMP_TO_EDGE), T.copyTexSubImage2D(T.TEXTURE_2D, 0, 0, 0, 0, 0, Pe, Oe);
                }
                _e && be(!0, !1, ve), pe && be(!1, !0, ve);
              }
            } else
              _e && xe(!0), pe && xe(!1), (_e || pe) && c.resetStencilClippingMasks();
          }
        }
      }, hillshade: function(c, t, s, h) {
        if (c.renderPass !== "offscreen" && c.renderPass !== "translucent" || c.style.disableElevatedTerrain)
          return;
        const m = c.context, g = c.terrain && c.terrain.renderingToTexture, [T, z] = c.renderPass !== "translucent" || g ? [{}, h] : c.stencilConfigForOverlap(h);
        for (const R of z) {
          const F = t.getTile(R);
          if (F.needsHillshadePrepare && c.renderPass === "offscreen")
            Gc(c, F, s);
          else if (c.renderPass === "translucent") {
            const N = c.depthModeForSublayer(0, Wt.ReadOnly), j = s.paint.get("hillshade-emissive-strength"), G = c.colorModeForDrapableLayerRenderPass(j), W = g && c.terrain ? c.terrain.stencilModeForRTTOverlap(R) : T[R.overscaledZ];
            Ua(c, R, F, s, N, W, G);
          }
        }
        m.viewport.set([0, 0, c.width, c.height]), c.resetStencilClippingMasks();
      }, raster: function(c, t, s, h, m, g) {
        if (c.renderPass !== "translucent" || s.paint.get("raster-opacity") === 0)
          return;
        const T = c.transform.projection.name === "globe", z = s.paint.get("raster-elevation") !== 0, R = z && T;
        if (c.renderElevatedRasterBackface && !R)
          return;
        const F = c.context, N = F.gl, j = t.getSource(), G = function(xe, be, ve, Pe) {
          const Oe = be.paint.get("raster-color"), Xe = xe.type === "raster-array", Ze = [], ke = be.paint.get("raster-resampling"), Ne = be.paint.get("raster-color-mix");
          let st = be.paint.get("raster-color-range");
          const ht = [Ne[0], Ne[1], Ne[2], 0], yt = Ne[3];
          let je = ke === "nearest" ? Pe.NEAREST : Pe.LINEAR;
          if (Xe && (Ze.push("RASTER_ARRAY"), Oe || Ze.push("RASTER_COLOR"), ke === "linear" && Ze.push("RASTER_ARRAY_LINEAR"), je = Pe.NEAREST, !st && xe.rasterLayers)) {
            const at = xe.rasterLayers.find(({ id: Je }) => Je === be.sourceLayer);
            at && at.fields && at.fields.range && (st = at.fields.range);
          }
          if (st = st || [0, 1], Oe) {
            Ze.push("RASTER_COLOR"), ve.activeTexture.set(Pe.TEXTURE2), be.updateColorRamp(st);
            let at = be.colorRampTexture;
            at || (at = be.colorRampTexture = new i.T(ve, be.colorRamp, Pe.RGBA8)), at.bind(Pe.LINEAR, Pe.CLAMP_TO_EDGE);
          }
          return { mix: ht, range: st, offset: yt, defines: Ze, resampling: je };
        }(j, s, F, N);
        if (j instanceof i.aJ && !h.length && !T)
          return;
        const W = s.paint.get("raster-emissive-strength"), te = c.colorModeForDrapableLayerRenderPass(W), ee = c.terrain && c.terrain.renderingToTexture, se = !c.options.moving, oe = s.paint.get("raster-resampling") === "nearest" ? N.NEAREST : N.LINEAR;
        if (j instanceof i.aJ && !h.length && (j.onNorthPole || j.onSouthPole)) {
          const xe = z ? c.stencilModeFor3D() : ci.disabled;
          return void Ha(!!j.onNorthPole, null, c, t, s, W, G, ti.disabled, xe);
        }
        if (!h.length)
          return;
        const [ce, _e] = j instanceof i.aJ || ee ? [{}, h] : c.stencilConfigForOverlap(h), pe = _e[_e.length - 1].overscaledZ;
        R && G.defines.push("PROJECTION_GLOBE_VIEW"), z && G.defines.push("RENDER_CUTOFF");
        const Te = (xe, be, ve) => {
          for (const Pe of xe) {
            const Oe = Pe.toUnwrapped(), Xe = t.getTile(Pe);
            if (ee && (!Xe || !Xe.hasData()))
              continue;
            F.activeTexture.set(N.TEXTURE0);
            const Ze = $e(Xe, j, s, G);
            if (!Ze || !Ze.texture)
              continue;
            const { texture: ke, mix: Ne, offset: st, tileSize: ht, buffer: yt } = Ze;
            let je, at;
            ee ? (je = Wt.disabled, at = Pe.projMatrix) : z ? (je = new Wt(N.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D), at = T ? Float32Array.from(c.transform.expandedFarZProjMatrix) : c.transform.calculateProjMatrix(Oe, se)) : (je = c.depthModeForSublayer(Pe.overscaledZ - pe, s.paint.get("raster-opacity") === 1 ? Wt.ReadWrite : Wt.ReadOnly, N.LESS), at = c.transform.calculateProjMatrix(Oe, se));
            const Je = c.terrain && ee ? c.terrain.stencilModeForRTTOverlap(Pe) : ce[Pe.overscaledZ], _t = g ? 0 : s.paint.get("raster-fade-duration");
            Xe.registerFadeDuration(_t);
            const ct = t.findLoadedParent(Pe, 0), nt = Yh(Xe, ct, t, c.transform, _t);
            let Lt, xt;
            c.terrain && c.terrain.prepareDrawTile(), F.activeTexture.set(N.TEXTURE0), ke.bind(oe, N.CLAMP_TO_EDGE), F.activeTexture.set(N.TEXTURE1), ct ? (ct.texture && ct.texture.bind(oe, N.CLAMP_TO_EDGE), Lt = Math.pow(2, ct.tileID.overscaledZ - Xe.tileID.overscaledZ), xt = [Xe.tileID.canonical.x * Lt % 1, Xe.tileID.canonical.y * Lt % 1]) : ke.bind(oe, N.CLAMP_TO_EDGE), ke.useMipmap && F.extTextureFilterAnisotropic && c.transform.pitch > 20 && N.texParameterf(N.TEXTURE_2D, F.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, F.extTextureFilterAnisotropicMax);
            const zt = c.transform;
            let Bt;
            const oi = z ? Bn(zt) : [0, 0, 0, 0];
            let $t, Xt, ai, zi, wi, mn = 0;
            if (R && j instanceof i.aJ && j.coordinates.length > 3)
              $t = Float32Array.from(i.bb(i.cH(new i.bT(0, 0, 0)))), Xt = Float32Array.from(zt.globeMatrix), ai = Float32Array.from(i.cD(zt)), zi = [i.at(zt.center.lng), i.aA(zt.center.lat)], Bt = j.elevatedGlobePerspectiveTransform, wi = j.elevatedGlobeGridMatrix || new Float32Array(9);
            else if (R) {
              const _i = i.cE(Pe.canonical);
              mn = i.cF(_i.getCenter().lat), $t = Float32Array.from(i.bb(i.cH(Pe.canonical))), Xt = Float32Array.from(zt.globeMatrix), ai = Float32Array.from(i.cD(zt)), zi = [i.at(zt.center.lng), i.aA(zt.center.lat)], Bt = [0, 0], wi = Float32Array.from(i.cG(Pe.canonical, _i, mn, zt.worldSize / zt._pixelsPerMercatorPixel));
            } else
              Bt = j instanceof i.aJ ? j.perspectiveTransform : [0, 0], $t = new Float32Array(16), Xt = new Float32Array(9), ai = new Float32Array(16), zi = [0, 0], wi = new Float32Array(9);
            const Sn = ud(at, $t, Xt, ai, wi, xt || [0, 0], i.ae(c.transform.zoom), zi, oi, Lt || 1, nt, s, Bt, z ? s.paint.get("raster-elevation") : 0, 2, Ne, st, G.range, ht, yt, W), Xi = c.isTileAffectedByFog(Pe), sn = c.getOrCreateProgram("raster", { defines: G.defines, overrideFog: Xi });
            if (c.uploadCommonUniforms(F, sn, Oe), j instanceof i.aJ) {
              const _i = j.elevatedGlobeVertexBuffer, Jt = j.elevatedGlobeIndexBuffer;
              if (ee || !T)
                j.boundsBuffer && j.boundsSegments && sn.draw(c, N.TRIANGLES, je, ci.disabled, te, ti.disabled, Sn, s.id, j.boundsBuffer, c.quadTriangleIndexBuffer, j.boundsSegments);
              else if (_i && Jt) {
                const ji = zt.zoom <= i.c6 ? j.elevatedGlobeSegments : j.getSegmentsForLongitude(zt.center.lng);
                ji && sn.draw(c, N.TRIANGLES, je, ci.disabled, te, be, Sn, s.id, _i, Jt, ji);
              }
            } else if (R) {
              je = new Wt(N.LEQUAL, Wt.ReadOnly, c.depthRangeFor3D);
              const _i = c.globeSharedBuffers;
              if (_i) {
                const [Jt, ji, Yi] = _i.getGridBuffers(mn, !1);
                sn.draw(c, N.TRIANGLES, je, ve || Je, c.colorModeForRenderPass(), be, Sn, s.id, Jt, ji, Yi);
              }
            } else {
              const { tileBoundsBuffer: _i, tileBoundsIndexBuffer: Jt, tileBoundsSegments: ji } = c.getTileBoundsBuffers(Xe);
              sn.draw(c, N.TRIANGLES, je, Je, te, ti.disabled, Sn, s.id, _i, Jt, ji);
            }
          }
          if (!(j instanceof i.aJ) && R)
            for (const Pe of xe) {
              const Oe = Pe.canonical.y === (1 << Pe.canonical.z) - 1;
              Pe.canonical.y === 0 && Ha(!0, Pe, c, t, s, W, G, be, ve || ci.disabled), Oe && Ha(!1, Pe, c, t, s, W, G, be === ti.frontCW ? ti.backCW : ti.frontCW, ve || ci.disabled);
            }
        };
        R ? Te(_e, c.renderElevatedRasterBackface ? ti.backCW : ti.frontCW, c.stencilModeFor3D()) : Te(_e, ti.disabled, void 0), c.resetStencilClippingMasks();
      }, "raster-particle": function(c, t, s, h, m, g) {
        c.renderPass === "offscreen" && function(T, z, R, F) {
          if (!F.length)
            return;
          const N = T.context, j = N.gl, G = z.getSource();
          if (!(G instanceof xn))
            return;
          const W = Math.ceil(Math.sqrt(R.paint.get("raster-particle-count")));
          let te = R.particlePositionRGBAImage;
          if (!te || te.width !== W) {
            const _e = function(pe) {
              const Te = pe * pe, xe = new Uint8Array(4 * Te), be = function(Pe) {
                return Pe |= 0, Pe = Math.imul(2747636419 ^ Pe, 2654435769), Pe = Math.imul(Pe ^ Pe >>> 16, 2654435769), ((Pe = Math.imul(Pe ^ Pe >>> 16, 2654435769)) >>> 0) / 4294967296;
              }, ve = 1 / 1.1;
              for (let Pe = 0; Pe < Te; Pe++) {
                const Oe = ve * (be(2 * Pe + 0) + lo), Xe = ve * (be(2 * Pe + 1) + lo), Ze = 255 * Oe % 1, ke = 255 * Xe % 1, Ne = Ze, st = Xe - ke / 255, ht = ke;
                xe[4 * Pe + 0] = 255 * (Oe - Ze / 255), xe[4 * Pe + 1] = 255 * Ne, xe[4 * Pe + 2] = 255 * st, xe[4 * Pe + 3] = 255 * ht;
              }
              return xe;
            }(W);
            te = R.particlePositionRGBAImage = new i.r({ width: W, height: W }, _e);
          }
          let ee = R.particleFramebuffer;
          ee ? ee.width !== W && (ee.destroy(), ee = R.particleFramebuffer = N.createFramebuffer(W, W, !0, null)) : ee = R.particleFramebuffer = N.createFramebuffer(W, W, !0, null);
          const se = [];
          for (const _e of F) {
            const pe = z.getTile(_e);
            if (!(pe instanceof za))
              continue;
            const Te = yd(pe, G, R);
            if (!Te)
              continue;
            const xe = [pe.tileSize, pe.tileSize];
            let be = R.tileFramebuffer;
            be || (be = R.tileFramebuffer = N.createFramebuffer(xe[0], xe[1], !0, null));
            let ve = pe.rasterParticleState;
            ve || (ve = pe.rasterParticleState = new au(N, _e, xe, te));
            const Pe = ve.update(R.lastInvalidatedAt);
            ve.particleTextureDimension !== W && ve.updateParticleTexture(_e, te);
            const Oe = ve.targetColorTexture;
            ve.targetColorTexture = ve.backgroundColorTexture, ve.backgroundColorTexture = Oe;
            const Xe = ve.particleTexture0;
            ve.particleTexture0 = ve.particleTexture1, ve.particleTexture1 = Xe, se.push([_e, Te, ve, Pe]);
          }
          if (se.length === 0)
            return;
          const oe = i.q.now(), ce = R.previousDrawTimestamp ? 1e-3 * (oe - R.previousDrawTimestamp) : 0.0167;
          if (R.previousDrawTimestamp = oe, R.hasColorMap()) {
            N.activeTexture.set(j.TEXTURE0 + 2);
            let _e = R.colorRampTexture;
            _e || (_e = R.colorRampTexture = new i.T(N, R.colorRamp, j.RGBA8)), _e.bind(j.LINEAR, j.CLAMP_TO_EDGE);
          }
          N.bindFramebuffer.set(R.tileFramebuffer.framebuffer), function(_e, pe, Te) {
            const xe = _e.context, be = xe.gl, ve = pe.tileFramebuffer;
            xe.activeTexture.set(be.TEXTURE0);
            const Pe = { u_texture: 0, u_opacity: 1.05 * (Xe = pe.paint.get("raster-particle-fade-opacity-factor")) / (Xe + 0.05) }, Oe = _e.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: !1 });
            var Xe;
            for (const Ze of Te) {
              const [, , ke, Ne] = Ze;
              ve.colorAttachment.set(ke.targetColorTexture.texture), xe.viewport.set([0, 0, ve.width, ve.height]), xe.clear({ color: i.aj.transparent }), Ne && (ke.backgroundColorTexture.bind(be.NEAREST, be.CLAMP_TO_EDGE), Oe.draw(_e, be.TRIANGLES, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, Pe, pe.id, _e.viewportBuffer, _e.quadTriangleIndexBuffer, _e.viewportSegments));
            }
          }(T, R, se), function(_e, pe, Te, xe) {
            const be = _e.context, ve = be.gl, Pe = Te.tileFramebuffer, Oe = _e.transform.projection.name === "globe", Xe = Te.paint.get("raster-particle-max-speed");
            for (const Ze of xe) {
              const [ke, Ne, st] = Ze;
              be.activeTexture.set(ve.TEXTURE0 + 0), Ne.texture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), Pe.colorAttachment.set(st.targetColorTexture.texture);
              const ht = _e.getOrCreateProgram("rasterParticleDraw", { defines: Ne.defines, overrideFog: !1 });
              be.activeTexture.set(ve.TEXTURE0 + 1);
              const yt = Ne.scalarData ? [] : [0, 1, 2, 3].map((Je) => i.d4[Je](ke));
              yt.push(ke);
              const je = ke.canonical.x, at = ke.canonical.y;
              for (const Je of yt) {
                const _t = pe.getTile(Oe ? Je.wrapped() : Je);
                if (!_t)
                  continue;
                const ct = _t.rasterParticleState;
                if (!ct)
                  continue;
                const nt = Je.canonical.x + (1 << Je.canonical.z) * (Je.wrap - ke.wrap), Lt = Je.canonical.y;
                ct.particleTexture0.bind(ve.NEAREST, ve.CLAMP_TO_EDGE);
                const xt = Zt(1, ct.particleTexture0.size[0], [nt - je, Lt - at], 0, Ne.texture.size, 2, Xe, Ne.textureOffset, Ne.scale, Ne.offset);
                ht.draw(_e, ve.POINTS, Wt.disabled, ci.disabled, bi.alphaBlended, ti.disabled, xt, Te.id, ct.particleIndexBuffer, void 0, ct.particleSegment);
              }
            }
          }(T, z, R, se), N.bindFramebuffer.set(R.particleFramebuffer.framebuffer), function(_e, pe, Te, xe) {
            const be = _e.context, ve = be.gl, Pe = pe.paint.get("raster-particle-max-speed"), Oe = xe * pe.paint.get("raster-particle-speed-factor") * 0.15, Xe = function(ke) {
              return Math.pow(ke, 6);
            }(0.01 + 1 * pe.paint.get("raster-particle-reset-rate-factor")), Ze = pe.particleFramebuffer;
            be.viewport.set([0, 0, Ze.width, Ze.height]);
            for (const ke of Te) {
              const [, Ne, st] = ke;
              be.activeTexture.set(ve.TEXTURE0 + 0), Ne.texture.bind(ve.LINEAR, ve.CLAMP_TO_EDGE), be.activeTexture.set(ve.TEXTURE0 + 1);
              const ht = st.particleTexture0;
              ht.bind(ve.NEAREST, ve.CLAMP_TO_EDGE);
              const yt = dd(1, ht.size[0], 0, Ne.texture.size, Pe, Oe, Xe, Ne.textureOffset, Ne.scale, Ne.offset);
              Ze.colorAttachment.set(st.particleTexture1.texture), be.clear({ color: i.aj.transparent }), _e.getOrCreateProgram("rasterParticleUpdate", { defines: Ne.defines }).draw(_e, ve.TRIANGLES, Wt.disabled, ci.disabled, bi.unblended, ti.disabled, yt, pe.id, _e.viewportBuffer, _e.quadTriangleIndexBuffer, _e.viewportSegments);
            }
          }(T, R, se, ce);
        }(c, t, s, h), c.renderPass === "translucent" && (function(T, z, R, F, N) {
          const j = T.context, G = j.gl, W = z.getSource().tileSize, te = 5 * (1 - i.ac(i.bY, i.bY + 1, T.transform.zoom)) * W + R.paint.get("raster-particle-elevation"), ee = !T.options.moving, se = T.transform.projection.name === "globe";
          if (!F.length)
            return;
          const [oe, ce] = T.stencilConfigForOverlap(F), _e = [];
          se && _e.push("PROJECTION_GLOBE_VIEW");
          const pe = T.stencilModeFor3D();
          for (const Te of ce) {
            const xe = Te.toUnwrapped(), be = z.getTile(Te);
            if (!be.rasterParticleState)
              continue;
            const ve = be.rasterParticleState, Pe = 100;
            be.registerFadeDuration(Pe);
            const Oe = z.findLoadedParent(Te, 0), Xe = Yh(be, Oe, z, T.transform, Pe);
            let Ze, ke;
            T.terrain && T.terrain.prepareDrawTile(), j.activeTexture.set(G.TEXTURE0), ve.targetColorTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE), j.activeTexture.set(G.TEXTURE1), Oe && Oe.rasterParticleState ? (Oe.rasterParticleState.targetColorTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE), Ze = Math.pow(2, Oe.tileID.overscaledZ - be.tileID.overscaledZ), ke = [be.tileID.canonical.x * Ze % 1, be.tileID.canonical.y * Ze % 1]) : ve.targetColorTexture.bind(G.LINEAR, G.CLAMP_TO_EDGE);
            const Ne = se ? Float32Array.from(T.transform.expandedFarZProjMatrix) : T.transform.calculateProjMatrix(xe, ee), st = T.transform, ht = Jf(st), yt = i.cE(Te.canonical), je = i.cF(yt.getCenter().lat);
            let at, Je, _t, ct, nt;
            se ? (at = Float32Array.from(i.bb(i.cH(Te.canonical))), Je = Float32Array.from(st.globeMatrix), _t = Float32Array.from(i.cD(st)), ct = [i.at(st.center.lng), i.aA(st.center.lat)], nt = Float32Array.from(i.cG(Te.canonical, yt, je, st.worldSize / st._pixelsPerMercatorPixel))) : (at = new Float32Array(16), Je = new Float32Array(9), _t = new Float32Array(16), ct = [0, 0], nt = new Float32Array(9));
            const Lt = bl(Ne, at, Je, _t, nt, ke || [0, 0], i.ae(T.transform.zoom), ct, ht, Ze || 1, Xe, te), xt = T.isTileAffectedByFog(Te), zt = T.getOrCreateProgram("rasterParticle", { defines: _e, overrideFog: xt });
            if (T.uploadCommonUniforms(j, zt, xe), se) {
              const Bt = new Wt(G.LEQUAL, Wt.ReadOnly, T.depthRangeFor3D), oi = 0, $t = T.globeSharedBuffers;
              if ($t) {
                const [Xt, ai, zi] = $t.getGridBuffers(je, oi !== 0);
                zt.draw(T, G.TRIANGLES, Bt, pe, bi.alphaBlended, T.renderElevatedRasterBackface ? ti.frontCCW : ti.backCCW, Lt, R.id, Xt, ai, zi);
              }
            } else {
              const Bt = T.depthModeForSublayer(0, Wt.ReadOnly), oi = oe[Te.overscaledZ], { tileBoundsBuffer: $t, tileBoundsIndexBuffer: Xt, tileBoundsSegments: ai } = T.getTileBoundsBuffers(be);
              zt.draw(T, G.TRIANGLES, Bt, oi, bi.alphaBlended, ti.disabled, Lt, R.id, $t, Xt, ai);
            }
          }
          T.resetStencilClippingMasks();
        }(c, t, s, h), c.style.map.triggerRepaint());
      }, background: function(c, t, s, h) {
        const m = s.paint.get("background-color"), g = s.paint.get("background-color-use-theme").constantOr("default") === "none", T = s.paint.get("background-opacity"), z = s.paint.get("background-emissive-strength"), R = s.paint.get("background-pitch-alignment") === "viewport";
        if (T === 0)
          return;
        const F = c.context, N = F.gl, j = c.transform, G = j.tileSize, W = s.paint.get("background-pattern");
        let te;
        if (W !== void 0 && (W === null || (te = c.imageManager.getPattern(W.toString(), s.scope, c.style.getLut(s.scope)), !te)))
          return;
        const ee = !W && m.a === 1 && T === 1 && c.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (c.renderPass !== ee)
          return;
        const se = ci.disabled, oe = c.depthModeForSublayer(0, ee === "opaque" ? Wt.ReadWrite : Wt.ReadOnly), ce = c.colorModeForDrapableLayerRenderPass(z), _e = W ? "backgroundPattern" : "background";
        let pe, Te = h;
        if (Te || (pe = c.getBackgroundTiles(), Te = Object.values(pe).map((xe) => xe.tileID)), W && (F.activeTexture.set(N.TEXTURE0), c.imageManager.bind(c.context, s.scope)), R) {
          const xe = c.getOrCreateProgram(_e, { overrideFog: !1, overrideRtt: !0 }), be = new Float32Array(i.ab.mat4.identity([])), ve = new i.aG(0, 0, 0, 0, 0), Pe = W ? fd(be, z, T, c, 0, s.scope, te, R, { tileID: ve, tileSize: G }) : iu(be, z, T, m.toRenderColor(g ? null : s.lut));
          xe.draw(c, N.TRIANGLES, oe, se, ce, ti.disabled, Pe, s.id, c.viewportBuffer, c.quadTriangleIndexBuffer, c.viewportSegments);
        } else
          for (const xe of Te) {
            const be = c.isTileAffectedByFog(xe), ve = c.getOrCreateProgram(_e, { overrideFog: be }), Pe = xe.toUnwrapped(), Oe = h ? xe.projMatrix : c.transform.calculateProjMatrix(Pe);
            c.prepareDrawTile();
            const Xe = t ? t.getTile(xe) : pe ? pe[xe.key] : new Cr(xe, G, j.zoom, c), Ze = W ? fd(Oe, z, T, c, 0, s.scope, te, R, { tileID: xe, tileSize: G }) : iu(Oe, z, T, m.toRenderColor(g ? null : s.lut));
            c.uploadCommonUniforms(F, ve, Pe);
            const { tileBoundsBuffer: ke, tileBoundsIndexBuffer: Ne, tileBoundsSegments: st } = c.getTileBoundsBuffers(Xe);
            ve.draw(c, N.TRIANGLES, oe, se, ce, ti.disabled, Ze, s.id, ke, Ne, st);
          }
      }, sky: function(c, t, s) {
        const h = c._atmosphere ? i.ae(c.transform.zoom) : 1, m = s.paint.get("sky-opacity") * h;
        if (m === 0)
          return;
        const g = c.context, T = s.paint.get("sky-type"), z = new Wt(g.gl.LEQUAL, Wt.ReadOnly, [0, 1]), R = c.frameCounter / 1e3 % 1;
        T === "atmosphere" ? c.renderPass === "offscreen" ? s.needsSkyboxCapture(c) && (function(F, N, j, G) {
          const W = F.context, te = W.gl;
          let ee = N.skyboxFbo;
          if (!ee) {
            ee = N.skyboxFbo = W.createFramebuffer(32, 32, !0, null), N.skyboxGeometry = new Co(W), N.skyboxTexture = W.gl.createTexture(), te.bindTexture(te.TEXTURE_CUBE_MAP, N.skyboxTexture), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_WRAP_S, te.CLAMP_TO_EDGE), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_WRAP_T, te.CLAMP_TO_EDGE), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_MIN_FILTER, te.LINEAR), te.texParameteri(te.TEXTURE_CUBE_MAP, te.TEXTURE_MAG_FILTER, te.LINEAR);
            for (let _e = 0; _e < 6; ++_e)
              te.texImage2D(te.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0, te.RGBA, 32, 32, 0, te.RGBA, te.UNSIGNED_BYTE, null);
          }
          W.bindFramebuffer.set(ee.framebuffer), W.viewport.set([0, 0, 32, 32]);
          const se = N.getCenter(F, !0), oe = F.getOrCreateProgram("skyboxCapture"), ce = new Float64Array(16);
          i.ab.mat4.identity(ce), i.ab.mat4.rotateY(ce, ce, 0.5 * -Math.PI), Sl(F, N, oe, ce, se, 0), i.ab.mat4.identity(ce), i.ab.mat4.rotateY(ce, ce, 0.5 * Math.PI), Sl(F, N, oe, ce, se, 1), i.ab.mat4.identity(ce), i.ab.mat4.rotateX(ce, ce, 0.5 * -Math.PI), Sl(F, N, oe, ce, se, 2), i.ab.mat4.identity(ce), i.ab.mat4.rotateX(ce, ce, 0.5 * Math.PI), Sl(F, N, oe, ce, se, 3), i.ab.mat4.identity(ce), Sl(F, N, oe, ce, se, 4), i.ab.mat4.identity(ce), i.ab.mat4.rotateY(ce, ce, Math.PI), Sl(F, N, oe, ce, se, 5), W.viewport.set([0, 0, F.width, F.height]);
        }(c, s), s.markSkyboxValid(c)) : c.renderPass === "sky" && function(F, N, j, G, W) {
          const te = F.context, ee = te.gl, se = F.transform, oe = F.getOrCreateProgram("skybox");
          te.activeTexture.set(ee.TEXTURE0), ee.bindTexture(ee.TEXTURE_CUBE_MAP, N.skyboxTexture);
          const ce = ((_e, pe, Te, xe, be) => ({ u_matrix: _e, u_sun_direction: pe, u_cubemap: 0, u_opacity: xe, u_temporal_offset: be }))(se.skyboxMatrix, N.getCenter(F, !1), 0, G, W);
          F.uploadCommonUniforms(te, oe), oe.draw(F, ee.TRIANGLES, j, ci.disabled, F.colorModeForRenderPass(), ti.backCW, ce, "skybox", N.skyboxGeometry.vertexBuffer, N.skyboxGeometry.indexBuffer, N.skyboxGeometry.segment);
        }(c, s, z, m, R) : T === "gradient" && c.renderPass === "sky" && function(F, N, j, G, W) {
          const te = F.context, ee = te.gl, se = F.transform, oe = F.getOrCreateProgram("skyboxGradient");
          N.skyboxGeometry || (N.skyboxGeometry = new Co(te)), te.activeTexture.set(ee.TEXTURE0);
          let ce = N.colorRampTexture;
          ce || (ce = N.colorRampTexture = new i.T(te, N.colorRamp, ee.RGBA8)), ce.bind(ee.LINEAR, ee.CLAMP_TO_EDGE);
          const _e = ((pe, Te, xe, be, ve) => ({ u_matrix: pe, u_color_ramp: 0, u_center_direction: Te, u_radius: i.ai(xe), u_opacity: be, u_temporal_offset: ve }))(se.skyboxMatrix, N.getCenter(F, !1), N.paint.get("sky-gradient-radius"), G, W);
          F.uploadCommonUniforms(te, oe), oe.draw(F, ee.TRIANGLES, j, ci.disabled, F.colorModeForRenderPass(), ti.backCW, _e, "skyboxGradient", N.skyboxGeometry.vertexBuffer, N.skyboxGeometry.indexBuffer, N.skyboxGeometry.segment);
        }(c, s, z, m, R);
      }, debug: function(c, t, s, h, m, g) {
        for (let T = 0; T < s.length; T++)
          if (m) {
            const F = new i.aj(h.r * 0.8, h.g * 0.8, h.b * 0.8, 1);
            Tl(c, t, s[T], h, -1, -1, g), Tl(c, t, s[T], h, -1, 1, g), Tl(c, t, s[T], h, 1, 1, g), Tl(c, t, s[T], h, 1, -1, g), Tl(c, t, s[T], F, 0, 0, g);
          } else
            Tl(c, t, s[T], h, 0, 0, g);
      }, custom: function(c, t, s, h) {
        const m = c.context, g = s.implementation;
        if (!c.transform.projection.unsupportedLayers || !c.transform.projection.unsupportedLayers.includes("custom") || c.terrain && (c.terrain.renderingToTexture || c.renderPass === "offscreen") && s.isDraped(t)) {
          if (c.renderPass === "offscreen") {
            const T = g.prerender;
            if (T) {
              if (c.setCustomLayerDefaults(), m.setColorMode(c.colorModeForRenderPass()), c.transform.projection.name === "globe") {
                const z = c.transform.pointMerc;
                T.call(g, m.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), i.ae(c.transform.zoom), [z.x, z.y], c.transform.pixelsPerMeterRatio);
              } else
                T.call(g, m.gl, c.transform.customLayerMatrix());
              m.setDirty(), c.setBaseState();
            }
          } else if (c.renderPass === "translucent") {
            if (c.terrain && c.terrain.renderingToTexture) {
              const z = g.renderToTile;
              if (z) {
                const R = h[0].canonical, F = new i.aa(R.x + h[0].wrap * (1 << R.z), R.y, R.z);
                m.setDepthMode(Wt.disabled), m.setStencilMode(ci.disabled), m.setColorMode(c.colorModeForRenderPass()), c.setCustomLayerDefaults(), z.call(g, m.gl, F), m.setDirty(), c.setBaseState();
              }
              return;
            }
            c.setCustomLayerDefaults(), m.setColorMode(c.colorModeForRenderPass()), m.setStencilMode(ci.disabled);
            const T = g.renderingMode === "3d" ? new Wt(c.context.gl.LEQUAL, Wt.ReadWrite, c.depthRangeFor3D) : c.depthModeForSublayer(0, Wt.ReadOnly);
            if (m.setDepthMode(T), c.transform.projection.name === "globe") {
              const z = c.transform.pointMerc;
              g.render(m.gl, c.transform.customLayerMatrix(), c.transform.getProjection(), c.transform.globeToMercatorMatrix(), i.ae(c.transform.zoom), [z.x, z.y], c.transform.pixelsPerMeterRatio);
            } else
              g.render(m.gl, c.transform.customLayerMatrix());
            m.setDirty(), c.setBaseState(), m.bindFramebuffer.set(null);
          }
        } else
          i.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
      }, model: function(c, t, s, h) {
        if (c.renderPass === "opaque")
          return;
        const m = s.paint.get("model-opacity").constantOr(1);
        if (m === 0)
          return;
        const g = s.paint.get("model-cast-shadows");
        if (c.renderPass === "shadow" && (!g || c.terrain && m < 0.65 && s._transitionablePaint._values["model-opacity"].value.expression instanceof i.a9))
          return;
        const T = c.shadowRenderer, z = s.paint.get("model-receive-shadows");
        T && (T.useNormalOffset = !0, z || (T.enabled = !1));
        const R = () => {
          T && (T.useNormalOffset = !0, z || (T.enabled = !0));
        }, F = t.getSource();
        if (c.renderPass === "light-beam" && F.type !== "batched-model")
          return;
        if (F.type === "vector" || F.type === "geojson")
          return function(oe, ce, _e, pe, Te) {
            const xe = oe.transform;
            if (xe.projection.name !== "mercator")
              return void i.w(`Drawing 3D models for ${xe.projection.name} projection is not yet implemented`);
            const be = xe.getFreeCameraOptions().position;
            if (!oe.modelManager)
              return;
            const ve = oe.modelManager;
            _e.modelManager = ve;
            const Pe = oe.shadowRenderer;
            if (!_e._unevaluatedLayout._values.hasOwnProperty("model-id"))
              return;
            const Oe = _e._unevaluatedLayout._values["model-id"], Xe = { ..._e.layout.get("model-id").parameters }, Ze = oe.style.order.indexOf(_e.fqid);
            for (const ke of pe) {
              const Ne = ce.getTile(ke).getBucket(_e);
              if (!Ne || Ne.projection.name !== xe.projection.name)
                continue;
              const st = Ne.getModelUris();
              st && !Ne.modelsRequested && (ve.addModelsFromBucket(st, Te), Ne.modelsRequested = !0);
              const ht = Wa(ke, xe);
              Xe.zoom = ht;
              const yt = Oe.possiblyEvaluate(Xe);
              if (xd(oe, Ne, ke), ho.shadowUniformsInitialized = !1, ho.useSingleShadowCascade = !!Pe && Pe.getMaxCascadeForTile(ke.toUnwrapped()) === 0, oe.renderPass === "shadow" && Pe) {
                if (oe.currentShadowCascade === 1 && Ne.isInsideFirstShadowMapFrustum)
                  continue;
                const Je = xe.calculatePosMatrix(ke.toUnwrapped(), xe.worldSize);
                if (ho.tileMatrix.set(Je), ho.shadowTileMatrix = Float32Array.from(Pe.calculateShadowPassMatrixFromMatrix(Je)), ho.aabb.min.fill(0), ho.aabb.max[0] = ho.aabb.max[1] = i.ag, ho.aabb.max[2] = 0, uu(Ne, ho, oe, _e.scope))
                  continue;
              }
              const je = 1 << ke.canonical.z, at = [((be.x - ke.wrap) * je - ke.canonical.x) * i.ag, (be.y * je - ke.canonical.y) * i.ag, be.z * je * i.ag];
              oe.conflationActive && Object.keys(Ne.instancesPerModel).length > 0 && oe.style.isLayerClipped(_e, ce.getSource()) && Ne.updateReplacement(ke, oe.replacementSource, Ze, Te) && (Ne.uploaded = !1, Ne.upload(oe.context));
              for (let Je in Ne.instancesPerModel) {
                const _t = Ne.instancesPerModel[Je];
                _t.features.length > 0 && (Je = yt.evaluate(_t.features[0].feature, {}));
                const ct = ve.getModel(Je, Te);
                if (ct && ct.uploaded)
                  for (const nt of ct.nodes)
                    xa(oe, _e, nt, _t, at, ke, ho);
              }
            }
          }(c, t, s, h, F.type === "vector" ? s.scope : ""), void R();
        if (!F.loaded())
          return;
        if (F.type === "batched-model")
          return function(oe, ce, _e, pe) {
            _e.resetLayerRenderingStats(oe);
            const Te = oe.context, xe = oe.transform, be = oe.style.fog, ve = oe.shadowRenderer;
            if (xe.projection.name !== "mercator")
              return void i.w(`Drawing 3D landmark models for ${xe.projection.name} projection is not yet implemented`);
            const Pe = oe.transform.getFreeCameraOptions().position, Oe = i.ab.vec3.scale([], [Pe.x, Pe.y, Pe.z], oe.transform.worldSize), Xe = i.ab.vec3.negate([], Oe), Ze = i.ab.mat4.identity([]), ke = i.dj(xe.center.lat, xe.zoom), Ne = i.ab.mat4.fromScaling([], [1, 1, 1 / ke]);
            i.ab.mat4.translate(Ze, Ze, Xe);
            const st = _e.paint.get("model-opacity").constantOr(1), ht = new Wt(Te.gl.LEQUAL, Wt.ReadWrite, oe.depthRangeFor3D), yt = new Wt(Te.gl.LEQUAL, Wt.ReadOnly, oe.depthRangeFor3D), je = new i.cd([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), at = oe.renderPass === "shadow", Je = at && ve ? ve.getCurrentCascadeFrustum() : xe.getFrustum(xe.scaleZoom(xe.worldSize)), _t = _e.paint.get("model-front-cutoff"), ct = _t[2] < 1, nt = To(oe, _e.paint.get("model-cutoff-fade-range")), Lt = _e.getLayerRenderingStats();
            (function(xt, zt, Bt, oi) {
              const $t = xt.terrain ? xt.terrain.exaggeration() : 0, Xt = xt.transform.zoom;
              for (const ai of oi) {
                const zi = zt.getTile(ai).getBucket(Bt);
                zi && (xt.conflationActive && zi.updateReplacement(ai, xt.replacementSource), zi.evaluateScale(xt, Bt), xt.terrain && $t > 0 && zi.elevationUpdate(xt.terrain, $t, ai, Bt.source), zi.needsReEvaluation(xt, Xt, Bt) && zi.evaluate(Bt));
              }
            })(oe, ce, _e, pe), function() {
              let xt, zt, Bt;
              ct ? (xt = pe.length - 1, zt = -1, Bt = -1) : (xt = 0, zt = pe.length, Bt = 1);
              const oi = new Float64Array(16), $t = i.ab.vec3.create(), Xt = new i.P(0, 0);
              for (let ai = xt; ai !== zt; ai += Bt) {
                const zi = pe[ai], wi = ce.getTile(zi).getBucket(_e);
                if (!wi || !wi.uploaded)
                  continue;
                let mn = !1;
                ve && (mn = ve.getMaxCascadeForTile(zi.toUnwrapped()) === 0);
                const Sn = xe.calculatePosMatrix(zi.toUnwrapped(), xe.worldSize), Xi = wi.modelTraits;
                !at && ct && (i.ab.mat4.invert(oi, Sn), i.ab.vec3.transformMat4($t, Oe, oi), Xt.x = $t[0], Xt.y = $t[1]);
                const sn = [];
                for (const _i of wi.getNodesInfo()) {
                  if (_i.hiddenByReplacement || !_i.node.meshes)
                    continue;
                  const Jt = _i.node;
                  let ji = 0;
                  oe.terrain && Jt.elevation && (ji = Jt.elevation * oe.terrain.exaggeration());
                  const Yi = (() => {
                    const Ri = _i.aabb;
                    return je.min = [...Ri.min], je.max = [...Ri.max], je.min[2] += ji, je.max[2] += ji, i.ab.vec3.transformMat4(je.min, je.min, Sn), i.ab.vec3.transformMat4(je.max, je.max, Sn), je;
                  })(), In = _i.evaluatedScale;
                  if (In[0] <= 1 && In[1] <= 1 && In[2] <= 1 && Yi.intersects(Je) === 0)
                    continue;
                  if (!at && ct) {
                    const Ri = 0.16666666666666666;
                    _i.cameraCollisionOpacity = Oe[0] > Yi.min[0] && Oe[0] < Yi.max[0] && Oe[1] > Yi.min[1] && Oe[1] < Yi.max[1] && Oe[2] * ke < Yi.max[2] && Jt.footprint && i.bA(Xt, Jt.footprint) ? Math.max(_i.cameraCollisionOpacity - Ri, 0) : Math.min(1, _i.cameraCollisionOpacity + Ri);
                  }
                  const Fs = [...Sn], pr = Jt.anchor ? Jt.anchor[0] : 0, ts = Jt.anchor ? Jt.anchor[1] : 0;
                  i.ab.mat4.translate(Fs, Fs, [pr * (In[0] - 1), ts * (In[1] - 1), ji]), i.ab.vec3.exactEquals(In, i.dm) || i.ab.mat4.scale(Fs, Fs, In);
                  const As = i.ab.mat4.multiply([], Fs, Jt.matrix), Js = i.ab.mat4.multiply([], xe.expandedFarZProjMatrix, As), jn = i.ab.mat4.multiply([], xe.expandedFarZProjMatrix, Fs), dn = i.ab.vec4.transformMat4([], [pr, ts, ji, 1], Js)[2];
                  Jt.hidden = !1;
                  let _n = st;
                  at || (ct && (_n *= _i.cameraCollisionOpacity, _n *= vd(Fs, xe, _i.aabb, _t)), _n *= du(nt, dn)), _n !== 0 ? sn.push({ nodeInfo: _i, depth: dn, opacity: _n, wvpForNode: Js, wvpForTile: jn, nodeModelMatrix: As, tileModelMatrix: Fs }) : Jt.hidden = !0;
                }
                at || sn.sort((_i, Jt) => !ct || _i.opacity === 1 && Jt.opacity === 1 ? _i.depth < Jt.depth ? -1 : 1 : _i.opacity === 1 ? -1 : Jt.opacity === 1 ? 1 : _i.depth > Jt.depth ? -1 : 1);
                for (const _i of sn) {
                  const Jt = _i.nodeInfo, ji = Jt.node;
                  let Yi = i.ab.mat4.multiply([], Ne, _i.tileModelMatrix);
                  i.ab.mat4.multiply(Yi, Ze, Yi);
                  const In = i.ab.mat4.invert([], Yi);
                  i.ab.mat4.transpose(In, In), i.ab.mat4.scale(In, In, $a), Yi = i.ab.mat4.multiply(Yi, Yi, ji.matrix);
                  const Fs = oe.renderPass === "light-beam", pr = _e.paint.get("model-color-use-theme").constantOr("default") === "none", ts = Xi & i.dp.HasMapboxMeshFeatures, As = ts ? 0 : Jt.evaluatedRMEA[0][2];
                  for (let Js = 0; Js < ji.meshes.length; ++Js) {
                    const jn = ji.meshes[Js], dn = Js === ji.lightMeshIndex;
                    let _n = _i.wvpForNode;
                    if (dn) {
                      if (!Fs && !oe.terrain && oe.shadowRenderer) {
                        oe.currentLayer < oe.firstLightBeamLayer && (oe.firstLightBeamLayer = oe.currentLayer);
                        continue;
                      }
                      _n = _i.wvpForTile;
                    } else if (Fs)
                      continue;
                    const Ri = { defines: [] }, Gn = [];
                    if (!at && ve && (ve.useNormalOffset = !!jn.normalBuffer), hu(Ri.defines, Gn, jn, oe, pr ? null : _e.lut), ts || Ri.defines.push("DIFFUSE_SHADED"), mn && Ri.defines.push("SHADOWS_SINGLE_CASCADE"), Lt && (at ? Lt.numRenderedVerticesInShadowPass += jn.vertexArray.length : Lt.numRenderedVerticesInTransparentPass += jn.vertexArray.length), at) {
                      qa(jn, _i.nodeModelMatrix, oe, _e);
                      continue;
                    }
                    let Bs = null;
                    if (be) {
                      const mr = qi(_i.nodeModelMatrix, oe.transform);
                      if (Bs = new Float32Array(mr), xe.projection.name !== "globe") {
                        const Do = jn.aabb.min, Nr = jn.aabb.max, [el, ta] = be.getOpacityForBounds(mr, Do[0], Do[1], Nr[0], Nr[1]);
                        Ri.overrideFog = el >= It || ta >= It;
                      }
                    }
                    const cn = jn.material;
                    let Qs;
                    cn.occlusionTexture && cn.occlusionTexture.offsetScale && (Qs = cn.occlusionTexture.offsetScale, Ri.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                    const eo = oe.getOrCreateProgram("model", Ri);
                    !at && ve && ve.setupShadowsFromMatrix(_i.tileModelMatrix, eo, ve.useNormalOffset), oe.uploadCommonUniforms(Te, eo, null, Bs);
                    const Br = cn.pbrMetallicRoughness;
                    Br.metallicFactor = 0.9, Br.roughnessFactor = 0.5;
                    const Ta = pd(new Float32Array(_n), new Float32Array(Yi), new Float32Array(In), new Float32Array(ji.matrix), oe, _i.opacity, Br.baseColorFactor.toRenderColor(null), cn.emissiveFactor, Br.metallicFactor, Br.roughnessFactor, cn, As, _e, [0, 0, 0], Qs);
                    !dn && (Jt.hasTranslucentParts || _i.opacity < 1) && eo.draw(oe, Te.gl.TRIANGLES, ht, ci.disabled, bi.disabled, ti.backCCW, Ta, _e.id, jn.vertexBuffer, jn.indexBuffer, jn.segments, _e.paint, oe.transform.zoom, void 0, Gn), eo.draw(oe, Te.gl.TRIANGLES, dn ? yt : ht, ci.disabled, dn || _i.opacity < 1 || Jt.hasTranslucentParts ? bi.alphaBlended : bi.unblended, ti.backCCW, Ta, _e.id, jn.vertexBuffer, jn.indexBuffer, jn.segments, _e.paint, oe.transform.zoom, void 0, Gn);
                  }
                }
              }
            }();
          }(c, t, s, h), void R();
        if (F.type !== "model")
          return;
        const N = F.getModels(), j = [], G = c.transform.getFreeCameraOptions().position, W = i.ab.vec3.scale([], [G.x, G.y, G.z], c.transform.worldSize);
        i.ab.vec3.negate(W, W);
        const te = [], ee = [];
        let se = 0;
        for (const oe of N) {
          const ce = s.paint.get("model-rotation").constantOr(null), _e = s.paint.get("model-scale").constantOr(null), pe = s.paint.get("model-translation").constantOr(null);
          oe.computeModelMatrix(c, ce, _e, pe, !0, !0, !1);
          const Te = i.ab.mat4.identity([]), xe = i.dj(oe.position.lat, c.transform.zoom), be = i.ab.mat4.fromScaling([], [1, 1, 1 / xe]);
          i.ab.mat4.translate(Te, Te, W), j.push({ zScaleMatrix: be, negCameraPosMatrix: Te });
          for (const ve of oe.nodes)
            nh(c.transform, ve, oe.matrix, c.transform.expandedFarZProjMatrix, se, te, ee);
          se++;
        }
        if (te.sort((oe, ce) => ce.depth - oe.depth), c.renderPass !== "shadow") {
          if (m === 1)
            for (const oe of ee)
              Io(oe, c, s, j[oe.modelIndex], ci.disabled, c.colorModeForRenderPass());
          else {
            for (const oe of ee)
              Io(oe, c, s, j[oe.modelIndex], ci.disabled, bi.disabled);
            for (const oe of ee)
              Io(oe, c, s, j[oe.modelIndex], c.stencilModeFor3D(), c.colorModeForRenderPass());
            c.resetStencilClippingMasks();
          }
          for (const oe of te)
            Io(oe, c, s, j[oe.modelIndex], ci.disabled, c.colorModeForRenderPass());
          R();
        } else {
          for (const oe of ee)
            qa(oe.mesh, oe.nodeModelMatrix, c, s);
          for (const oe of te)
            qa(oe.mesh, oe.nodeModelMatrix, c, s);
          R();
        }
      } }, gu = { model: function(c, t, s) {
        const h = t.getSource();
        if (!h.loaded())
          return;
        if (h.type === "vector" || h.type === "geojson")
          return void (s.modelManager && s.modelManager.upload(s, h.type === "vector" ? c.scope : ""));
        if (h.type === "batched-model" || h.type !== "model")
          return;
        const m = h.getModels();
        for (const g of m)
          g.upload(s.context);
      }, raster: function(c, t, s) {
        const h = t.getSource();
        if (!(h instanceof xn && h.loaded()))
          return;
        const m = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
        if (!m)
          return;
        const g = c.paint.get("raster-array-band") || h.getInitialBand(m);
        if (g == null)
          return;
        const T = t.getIds().map((z) => t.getTileByID(z));
        for (const z of T)
          z.updateNeeded(m, g) && h.prepareTile(z, m, g);
      }, "raster-particle": function(c, t, s) {
        const h = t.getSource();
        if (!(h instanceof xn && h.loaded()))
          return;
        const m = c.sourceLayer || h.rasterLayerIds && h.rasterLayerIds[0];
        if (!m)
          return;
        const g = c.paint.get("raster-particle-array-band") || h.getInitialBand(m);
        if (g == null)
          return;
        const T = t.getIds().map((z) => t.getTileByID(z));
        for (const z of T)
          z.updateNeeded(m, g) && h.prepareTile(z, m, g);
      } };
      class Pd {
        constructor(t, s, h, m, g) {
          this.context = new Za(t, s), this.transform = h, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = g, this._timeStamp = i.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: !1, showTerrainProxyTiles: !1, fpsWindow: 30, continousRedraw: !1, enabledLayers: {} };
          const T = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
          for (const R of T)
            this._debugParams.enabledLayers[R] = !0;
          g.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
            this.style.map.triggerRepaint();
          }), g.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), g.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), g.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: !0, label: "continuous redraw" }), g.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "value" }), g.registerBinding(this, ["FPS"], "_averageFPS", { readonly: !0, label: "graph", view: "graph", min: 0, max: 200 });
          for (const R of T)
            g.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], R);
          this.occlusionParams = new Xa(g), this.setup(), this.numSublayers = sr.maxUnderzooming + sr.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new i.dv(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new So(this), this._wireframeDebugCache = new wd(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
          const z = new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
          this.emptyDepthTexture = new i.T(this.context, z, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = m;
        }
        updateTerrain(t, s) {
          const h = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
          if (!(h || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new jf(this, t));
          const m = this._terrain;
          this.transform.elevation = h ? m : null, m.update(t, this.transform, s), this.transform.elevation && !m.enabled && (this.transform.elevation = null);
        }
        _updateFog(t) {
          const s = t.fog;
          if (!s || this.transform.projection.name === "globe" || s.getOpacity(this.transform.pitch) < 1 || s.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [h, m] = s.getFovAdjustedRange(this.transform._fov);
          if (h > m)
            return void (this.transform.fogCullDistSq = null);
          const g = h + 0.78 * (m - h);
          this.transform.fogCullDistSq = g * g;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
        }
        get forceTerrainMode() {
          return this._forceTerrainMode;
        }
        set forceTerrainMode(t) {
          t && !this._terrain && (this._terrain = new jf(this, this.style)), this._forceTerrainMode = t;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t, s) {
          if (this.width = t * i.q.devicePixelRatio, this.height = s * i.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const h of this.style.order)
              this.style._mergedLayers[h].resize();
        }
        setup() {
          const t = this.context, s = new i.b4();
          s.emplaceBack(0, 0), s.emplaceBack(i.ag, 0), s.emplaceBack(0, i.ag), s.emplaceBack(i.ag, i.ag), this.tileExtentBuffer = t.createVertexBuffer(s, i.b6.members), this.tileExtentSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const h = new i.b4();
          h.emplaceBack(0, 0), h.emplaceBack(i.ag, 0), h.emplaceBack(0, i.ag), h.emplaceBack(i.ag, i.ag), this.debugBuffer = t.createVertexBuffer(h, i.b6.members), this.debugSegments = i.b7.simpleSegment(0, 0, 4, 5);
          const m = new i.b4();
          m.emplaceBack(-1, -1), m.emplaceBack(1, -1), m.emplaceBack(-1, 1), m.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(m, i.b6.members), this.viewportSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const g = new i.aT();
          g.emplaceBack(0, 0, 0, 0), g.emplaceBack(i.ag, 0, i.ag, 0), g.emplaceBack(0, i.ag, 0, i.ag), g.emplaceBack(i.ag, i.ag, i.ag, i.ag), this.mercatorBoundsBuffer = t.createVertexBuffer(g, i.b9.members), this.mercatorBoundsSegments = i.b7.simpleSegment(0, 0, 4, 2);
          const T = new i.aU();
          T.emplaceBack(0, 1, 2), T.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(T);
          const z = new i.b5();
          for (const F of [0, 1, 3, 2, 0])
            z.emplaceBack(F);
          this.debugIndexBuffer = t.createIndexBuffer(z), this.emptyTexture = new i.T(t, new i.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = i.ab.mat4.create();
          const R = this.context.gl;
          this.stencilClearMode = new ci({ func: R.ALWAYS, mask: 0 }, 0, 255, R.ZERO, R.ZERO, R.ZERO), this.loadTimeStamps.push(performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(t) {
          return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? { tileBoundsBuffer: t._tileBoundsBuffer, tileBoundsIndexBuffer: t._tileBoundsIndexBuffer, tileBoundsSegments: t._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t = this.context.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, t.TRIANGLES, Wt.disabled, this.stencilClearMode, bi.disabled, ti.disabled, tc(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
        }
        _renderTileClippingMasks(t, s, h) {
          if (!s || this.currentStencilSource === s.id || !t.isTileClipped() || !h || h.length === 0)
            return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let z = !1;
            for (const R of h)
              if (this._tileClippingMaskIDs[R.key] === void 0) {
                z = !0;
                break;
              }
            if (!z)
              return;
          }
          this.currentStencilSource = s.id;
          const m = this.context, g = m.gl;
          this.nextStencilID + h.length > 256 && this.clearStencil(), m.setColorMode(bi.disabled), m.setDepthMode(Wt.disabled);
          const T = this.getOrCreateProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const z of h) {
            const R = s.getTile(z), F = this._tileClippingMaskIDs[z.key] = this.nextStencilID++, { tileBoundsBuffer: N, tileBoundsIndexBuffer: j, tileBoundsSegments: G } = this.getTileBoundsBuffers(R);
            T.draw(this, g.TRIANGLES, Wt.disabled, new ci({ func: g.ALWAYS, mask: 0 }, F, 255, g.KEEP, g.KEEP, g.REPLACE), bi.disabled, ti.disabled, tc(z.projMatrix), "$clipping", N, j, G);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++, s = this.context.gl;
          return new ci({ func: s.NOTEQUAL, mask: 255 }, t, 255, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilModeForClipping(t) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t);
          const s = this.context.gl;
          return new ci({ func: s.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, s.KEEP, s.KEEP, s.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const s = this.context.gl, h = t.sort((T, z) => z.overscaledZ - T.overscaledZ), m = h[h.length - 1].overscaledZ, g = h[0].overscaledZ - m + 1;
          if (g > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + g > 256 && this.clearStencil();
            const T = {};
            for (let z = 0; z < g; z++)
              T[z + m] = new ci({ func: s.GEQUAL, mask: 255 }, z + this.nextStencilID, 255, s.KEEP, s.KEEP, s.REPLACE);
            return this.nextStencilID += g, [T, h];
          }
          return [{ [m]: ci.disabled }, h];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new bi([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new i.aj(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? bi.unblended : bi.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t) {
          const s = this.context.gl;
          return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && this.renderPass === "translucent" ? new bi([s.ONE, s.ONE_MINUS_SRC_ALPHA, s.CONSTANT_ALPHA, s.ONE_MINUS_SRC_ALPHA], new i.aj(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(t, s, h, m = !1) {
          if (this.depthOcclusion)
            return new Wt(this.context.gl.GREATER, Wt.ReadOnly, this.depthRangeFor3D);
          if (!this.opaquePassEnabledForLayer() && !m)
            return Wt.disabled;
          const g = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Wt(h || this.context.gl.LEQUAL, s, [g, g]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        blitDepth() {
          const t = this.context.gl, s = Math.ceil(this.width), h = Math.ceil(this.height), m = this.context.bindFramebuffer.get(), g = t.getParameter(t.TEXTURE_BINDING_2D);
          this.depthFBO && this.depthFBO.width === s && this.depthFBO.height === h || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), s !== 0 && h !== 0 && (this.depthFBO = new br(this.context, s, h, !1, "texture"), this.depthTexture = new i.T(this.context, { width: s, height: h, data: null }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(m), t.bindTexture(t.TEXTURE_2D, g), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, s, h, 0, 0, s, h, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));
        }
        updateAverageFPS() {
          this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((t, s) => t + s / this._fpsHistory.length, 0));
        }
        render(t, s) {
          const h = i.q.now();
          this._dt = h - this._timeStamp, this._timeStamp = h, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = s;
          const m = this.style._mergedLayers, g = this.style._getOrder(!(!this.terrain || !this.terrain.enabled)).filter((ke) => {
            const Ne = m[ke];
            return !(Ne.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[Ne.type];
          });
          let T = !1, z = !1;
          for (const ke of g) {
            const Ne = m[ke];
            Ne.type === "circle" && (T = !0), Ne.type === "symbol" && (Ne.hasInitialOcclusionOpacityProperties ? z = !0 : T = !0);
          }
          const R = g.map((ke) => m[ke]), F = this.style._mergedSourceCaches;
          this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(i.q.now()), this.imageManager.beginFrame();
          let N = 0, j = !1;
          for (const ke in F) {
            const Ne = F[ke];
            Ne.used && (Ne.prepare(this.context), Ne.getSource().usedInConflation && ++N);
          }
          let G = !1;
          for (const ke of R)
            ke.isHidden(this.transform.zoom) || (ke.type === "clip" && (G = !0), this.prepareLayer(ke));
          const W = {}, te = {}, ee = {}, se = {}, oe = {};
          for (const ke in F) {
            const Ne = F[ke];
            W[ke] = Ne.getVisibleCoordinates(), te[ke] = W[ke].slice().reverse(), ee[ke] = Ne.getVisibleCoordinates(!0).reverse(), se[ke] = Ne.getShadowCasterCoordinates(), oe[ke] = Ne.sortCoordinatesByDistance(W[ke]);
          }
          const ce = (ke) => {
            const Ne = this.style.getLayerSourceCache(ke);
            return Ne && Ne.used ? Ne.getSource() : null;
          };
          if (N || G || this._clippingActiveLastFrame) {
            const ke = [], Ne = [];
            let st = 0;
            for (const ht of R)
              this.isSourceForClippingOrConflation(ht, ce(ht)) && (ke.push(ht), Ne.push(st)), st++;
            if (ke && (G || ke.length > 1) || this._clippingActiveLastFrame) {
              G = !1;
              const ht = [];
              for (let yt = 0; yt < ke.length; yt++) {
                const je = ke[yt], at = Ne[yt], Je = this.style.getLayerSourceCache(je);
                if (!Je || !Je.used || !Je.getSource().usedInConflation && je.type !== "clip")
                  continue;
                let _t = i.dx, ct = i.by.None;
                const nt = [];
                let Lt = !0;
                if (je.type === "clip") {
                  _t = at;
                  for (const xt of je.layout.get("clip-layer-types"))
                    ct |= xt === "model" ? i.by.Model : xt === "symbol" ? i.by.Symbol : i.by.FillExtrusion;
                  for (const xt of je.layout.get("clip-layer-scope"))
                    nt.push(xt);
                  je.isHidden(this.transform.zoom) ? Lt = !1 : G = !0;
                }
                Lt && ht.push({ layer: je.fqid, cache: Je, order: _t, clipMask: ct, clipScope: nt });
              }
              this.replacementSource.setSources(ht), j = !0;
            }
          }
          this._clippingActiveLastFrame = G, j || this.replacementSource.clear(), this.conflationActive = j, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
          for (let ke = 0; ke < R.length; ke++) {
            const Ne = R[ke], st = Ne.cutoffRange();
            if (this.longestCutoffRange = Math.max(st, this.longestCutoffRange), st > 0) {
              const ht = ce(Ne);
              ht && (this.minCutoffZoom = Math.max(ht.minzoom, this.minCutoffZoom)), Ne.minzoom && (this.minCutoffZoom = Math.max(Ne.minzoom, this.minCutoffZoom));
            }
            Ne.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = ke), this._lastOcclusionLayer = ke);
          }
          const _e = this.style && this.style.fog;
          _e ? (this._fogVisible = _e.getOpacity(this.transform.pitch) !== 0, this._fogVisible && this.transform.projection.name !== "globe" && (this._fogVisible = _e.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(ee), this.opaquePassCutoff = 0);
          const pe = this._shadowRenderer;
          if (pe) {
            pe.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const ke in F)
              for (const Ne of W[ke]) {
                let st = { min: 0, max: 0 };
                this.terrain && (st = this.terrain.getMinMaxForTile(Ne) || st), pe.addShadowReceiver(Ne.toUnwrapped(), st.min, st.max);
              }
          }
          this.transform.projection.name !== "globe" || this.globeSharedBuffers || (this.globeSharedBuffers = new i.dw(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new bn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
          const Te = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), xe = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
          if (Te && !this._snow && (this._snow = new Ml(this)), !Te && this._snow && (this._snow.destroy(), delete this._snow), xe && !this._rain && (this._rain = new Ed(this)), !xe && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !Vs.has(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const ke of R) {
            const Ne = t.getLayerSourceCache(ke);
            if (!ke.hasOffscreenPass() || ke.isHidden(this.transform.zoom))
              continue;
            const st = Ne ? te[Ne.id] : void 0;
            (ke.type === "custom" || ke.type === "raster" || ke.type === "raster-particle" || ke.isSky() || st && st.length) && this.renderLayer(this, Ne, ke, st);
          }
          this.depthRangeFor3D = [0, 1 - (R.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, se)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const be = this.transform.projection.name === "globe" || this.transform.isHorizonVisible(), ve = (() => {
            if (s.showOverdrawInspector)
              return i.aj.black;
            const ke = this.style.fog;
            if (ke && this.transform.projection.supportsFog) {
              const Ne = this.style.getLut(ke.scope);
              if (!be) {
                const st = ke.properties.get("color-use-theme") === "none", ht = ke.properties.get("color").toRenderColor(st ? null : Ne).toArray01();
                return new i.aj(...ht);
              }
              if (be) {
                const st = ke.properties.get("space-color-use-theme") === "none", ht = ke.properties.get("space-color").toRenderColor(st ? null : Ne).toArray01();
                return new i.aj(...ht);
              }
            }
            return i.aj.transparent;
          })();
          if (this.context.clear({ color: ve, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = s.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && be && this._atmosphere.drawStars(this, this.style.fog), !this.terrain)
            for (this.currentLayer = g.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
              if (ke.isSky())
                continue;
              const st = Ne ? (ke.is3D() ? oe : te)[Ne.id] : void 0;
              this._renderTileClippingMasks(ke, Ne, st), this.renderLayer(this, Ne, ke, st);
            }
          if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && be && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || i.ae(this.transform.zoom) > 0) && (this.transform.projection.name === "globe" || this.transform.isHorizonVisible()))
            for (this.currentLayer = 0; this.currentLayer < g.length; this.currentLayer++) {
              const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
              ke.isSky() && this.renderLayer(this, Ne, ke, Ne ? te[Ne.id] : void 0);
            }
          function Pe(ke, Ne) {
            let st;
            return Ne && (st = (ke.type === "symbol" ? ee : ke.is3D() ? oe : te)[Ne.id]), st;
          }
          if (this.renderPass = "translucent", this.transform.projection.name === "globe") {
            for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < g.length; ) {
              const ke = R[this.currentLayer];
              if (ke.type === "raster" || ke.type === "raster-particle") {
                const Ne = t.getLayerSourceCache(ke);
                this.renderLayer(this, Ne, ke, Pe(ke, Ne));
              }
              ++this.currentLayer;
            }
            this.renderElevatedRasterBackface = !1;
          }
          this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
          let Oe = 0;
          pe && (Oe = pe.getShadowCastingLayerCount());
          let Xe = !1, Ze = -1;
          for (let ke = 0; ke < g.length; ++ke) {
            const Ne = R[ke];
            Ne.isHidden(this.transform.zoom) || Ne.is3D() && (Ze = ke);
          }
          for (z && Ze === -1 && (T = !0); this.currentLayer < g.length; ) {
            const ke = R[this.currentLayer], Ne = t.getLayerSourceCache(ke);
            if (ke.isSky())
              ++this.currentLayer;
            else if (this.terrain && this.style.isLayerDraped(ke)) {
              if (ke.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
            } else {
              if (T && !Xe && this.terrain && !this.transform.isOrthographic && (Xe = !0, this.blitDepth()), z && Ze !== -1 && this.currentLayer === Ze + 1 && !this.transform.isOrthographic && this.blitDepth(), ke.is3D() || this.terrain || this._renderTileClippingMasks(ke, Ne, Ne ? W[Ne.id] : void 0), this.renderLayer(this, Ne, ke, Pe(ke, Ne)), !this.terrain && pe && Oe > 0 && ke.hasShadowPass() && --Oe == 0 && (pe.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                const st = this.currentLayer;
                for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= st; this.currentLayer++) {
                  const ht = R[this.currentLayer];
                  if (!ht.hasLightBeamPass())
                    continue;
                  const yt = t.getLayerSourceCache(ht);
                  this.renderLayer(this, yt, ht, yt ? te[yt.id] : void 0);
                }
                this.currentLayer = st, this.renderPass = "translucent";
              }
              if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                const st = this.currentLayer;
                this.depthOcclusion = !0;
                for (const ht of this.layersWithOcclusionOpacity) {
                  this.currentLayer = ht;
                  const yt = R[this.currentLayer], je = t.getLayerSourceCache(yt), at = je ? te[je.id] : void 0;
                  yt.is3D() || this.terrain || this._renderTileClippingMasks(yt, je, je ? W[je.id] : void 0), this.renderLayer(this, je, yt, at);
                }
                this.depthOcclusion = !1, this.currentLayer = st, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
              }
              ++this.currentLayer;
            }
          }
          if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
            let ke = null;
            R.forEach((Ne) => {
              const st = t.getLayerSourceCache(Ne);
              st && !Ne.isHidden(this.transform.zoom) && st.getVisibleCoordinates().length && (!ke || ke.getSource().maxzoom < st.getSource().maxzoom) && (ke = st);
            }), ke && this.options.showTileBoundaries && sh.debug(this, ke, ke.getVisibleCoordinates(), i.aj.red, !1, this.options.showParseStatus);
          }
          this.terrain && this._debugParams.showTerrainProxyTiles && sh.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new i.aj(1, 0.8, 0.1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(ke) {
            const Ne = ke.transform.padding;
            eh(ke, ke.transform.height - (Ne.top || 0), 3, Qf), eh(ke, Ne.bottom || 0, 3, ep), lu(ke, Ne.left || 0, 3, lc), lu(ke, ke.transform.width - (Ne.right || 0), 3, Xm);
            const st = ke.transform.centerPoint;
            (function(ht, yt, je, at) {
              th(ht, yt - 1, je - 10, 2, 20, at), th(ht, yt - 10, je - 1, 20, 2, at);
            })(ke, st.x, ke.transform.height - st.y, Ym);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), j || (this.conflationActive = !1);
        }
        prepareLayer(t) {
          this.gpuTimingStart(t);
          const { unsupportedLayers: s } = this.transform.projection, h = !s || !s.includes(t.type);
          if (gu[t.type] && (h || this.terrain && t.type === "custom")) {
            const m = this.style.getLayerSourceCache(t);
            gu[t.type](t, m, this);
          }
          this.gpuTimingEnd();
        }
        renderLayer(t, s, h, m) {
          h.isHidden(this.transform.zoom) || (h.type === "background" || h.type === "sky" || h.type === "custom" || h.type === "model" || h.type === "raster" || h.type === "raster-particle" || m && m.length) && (this.id = h.id, this.gpuTimingStart(h), t.transform.projection.unsupportedLayers && t.transform.projection.unsupportedLayers.includes(h.type) && (!t.terrain || h.type !== "custom") || h.type === "clip" || sh[h.type](t, s, h, m, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(t) {
          if (!this.options.gpuTiming)
            return;
          const s = this.context.extTimerQuery, h = this.context.gl;
          let m = this.gpuTimers[t.id];
          m || (m = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: h.createQuery() }), m.calls++, h.beginQuery(s.TIME_ELAPSED_EXT, m.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const t = this.context.extTimerQuery, s = this.context.gl, h = s.createQuery();
            this.deferredRenderGpuTimeQueries.push(h), s.beginQuery(t.TIME_ELAPSED_EXT, h);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const t = this.gpuTimers;
          return this.gpuTimers = {}, t;
        }
        collectDeferredRenderGpuQueries() {
          const t = this.deferredRenderGpuTimeQueries;
          return this.deferredRenderGpuTimeQueries = [], t;
        }
        queryGpuTimers(t) {
          const s = {};
          for (const h in t) {
            const m = t[h], g = this.context.extTimerQuery, T = g.getQueryParameter(m.query, this.context.gl.QUERY_RESULT) / 1e6;
            g.deleteQueryEXT(m.query), s[h] = T;
          }
          return s;
        }
        queryGpuTimeDeferredRender(t) {
          if (!this.options.gpuTimingDeferredRender)
            return 0;
          const s = this.context.gl;
          let h = 0;
          for (const m of t)
            h += s.getQueryParameter(m, s.QUERY_RESULT) / 1e6, s.deleteQuery(m);
          return h;
        }
        translatePosMatrix(t, s, h, m, g) {
          if (!h[0] && !h[1])
            return t;
          const T = g ? m === "map" ? this.transform.angle : 0 : m === "viewport" ? -this.transform.angle : 0;
          if (T) {
            const F = Math.sin(T), N = Math.cos(T);
            h = [h[0] * N - h[1] * F, h[0] * F + h[1] * N];
          }
          const z = [g ? h[0] : i.ar(s, h[0], this.transform.zoom), g ? h[1] : i.ar(s, h[1], this.transform.zoom), 0], R = new Float32Array(16);
          return i.ab.mat4.translate(R, t, z), R;
        }
        saveTileTexture(t) {
          const s = t.size[0], h = this._tileTextures[s];
          h ? h.push(t) : this._tileTextures[s] = [t];
        }
        getTileTexture(t) {
          const s = this._tileTextures[t];
          return s && s.length > 0 ? s.pop() : null;
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
        }
        linearFloatFilteringSupported() {
          return this.context.extTextureFloatLinear != null;
        }
        currentGlobalDefines(t, s, h) {
          const m = h === void 0 ? this.terrain && this.terrain.renderingToTexture : h, g = [];
          return this.style && this.style.enable3dLights() && (t === "globeRaster" || t === "terrainRaster" ? (g.push("LIGHTING_3D_MODE"), g.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : m || g.push("LIGHTING_3D_MODE")), this.renderPass === "shadow" && (this._shadowMapDebug || g.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (g.push("TERRAIN"), this.linearFloatFilteringSupported() && g.push("TERRAIN_DEM_FLOAT_FORMAT")), this.transform.projection.name === "globe" && g.push("GLOBE"), !this._fogVisible || m || s !== void 0 && !s || g.push("FOG", "FOG_DITHERING"), m && g.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && g.push("OVERDRAW_INSPECTOR"), g;
        }
        getOrCreateProgram(t, s) {
          this.cache = this.cache || {};
          const h = s && s.defines || [], m = s && s.config, g = this.currentGlobalDefines(t, s && s.overrideFog, s && s.overrideRtt).concat(h), T = Zf.cacheKey(yl[t], t, g, m);
          return this.cache[T] || (this.cache[T] = new Zf(this.context, t, yl[t], m, md[t], g)), this.cache[T];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new i.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t, s) {
          if (this.style.enable3dLights()) {
            const h = this.style.directionalLight, m = this.style.ambientLight;
            if (h && m) {
              const g = ((T, z, R) => {
                const F = T.properties.get("direction"), N = T.properties.get("color-use-theme") === "none", j = T.properties.get("color").toRenderColor(N ? null : R.getLut(T.scope)).toArray01(), G = T.properties.get("intensity"), W = z.properties.get("color-use-theme") === "none", te = z.properties.get("color").toRenderColor(W ? null : R.getLut(z.scope)).toArray01(), ee = z.properties.get("intensity"), se = [F.x, F.y, F.z], oe = i.cM(te, ee), ce = i.cM(j, G);
                return { u_lighting_ambient_color: oe, u_lighting_directional_dir: se, u_lighting_directional_color: ce, u_ground_radiance: Gf(se, ce, oe) };
              })(h, m, this.style);
              s.setLightsUniformValues(t, g);
            }
          }
        }
        uploadCommonUniforms(t, s, h, m, g) {
          if (this.uploadCommonLightUniforms(t, s), this.terrain && this.terrain.renderingToTexture)
            return;
          const T = this.style.fog;
          if (T) {
            const z = T.getOpacity(this.transform.pitch), R = ((F, N, j, G, W, te, ee, se, oe, ce, _e, pe) => {
              const Te = F.transform, xe = N.properties.get("color-use-theme") === "none", be = N.properties.get("color").toRenderColor(xe ? null : F.style.getLut(N.scope)).toArray01();
              be[3] = G;
              const ve = F.frameCounter / 1e3 % 1, [Pe, Oe] = N.properties.get("vertical-range");
              return { u_fog_matrix: j ? Te.calculateFogTileMatrix(j) : pe || F.identityMat, u_fog_range: N.getFovAdjustedRange(Te._fov), u_fog_color: be, u_fog_horizon_blend: N.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(Pe, Oe), Oe], u_fog_temporal_offset: ve, u_frustum_tl: W, u_frustum_tr: te, u_frustum_br: ee, u_frustum_bl: se, u_globe_pos: oe, u_globe_radius: ce, u_viewport: _e, u_globe_transition: i.ae(Te.zoom), u_is_globe: +(Te.projection.name === "globe") };
            })(this, T, h, z, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * i.q.devicePixelRatio, this.transform.height * i.q.devicePixelRatio], m);
            s.setFogUniformValues(t, R);
          }
          g && s.setCutoffUniformValues(t, g.uniformValues);
        }
        setTileLoadedFlag(t) {
          this.tileLoaded = t;
        }
        saveCanvasCopy() {
          const t = this.canvasCopy();
          t && (this.frameCopies.push(t), this.tileLoaded = !1);
        }
        canvasCopy() {
          const t = this.context.gl, s = t.createTexture();
          return t.bindTexture(t.TEXTURE_2D, s), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), s;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return !1;
          const t = this.style && this.style.fog;
          return !!t && t.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const t = this._backgroundTiles, s = this._backgroundTiles = {}, h = this.transform.coveringTiles({ tileSize: 512 });
          for (const m of h)
            s[m.key] = t[m.key] || new Cr(m, 512, this.transform.tileZoom, this);
          return s;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        isSourceForClippingOrConflation(t, s) {
          return !(!t.is3D() || t.type !== "clip" && (t.minzoom && t.minzoom > this.transform.zoom || (this.style._clipLayerPresent || t.sourceLayer !== "building") && (!s || s.type !== "batched-model")));
        }
        isTileAffectedByFog(t) {
          if (!this.style || !this.style.fog)
            return !1;
          if (this.transform.projection.name === "globe")
            return !0;
          let s = this._cachedTileFogOpacities[t.key];
          return s || (this._cachedTileFogOpacities[t.key] = s = this.style.fog.getOpacityForTile(t)), s[0] >= It || s[1] >= It;
        }
        setupDepthForOcclusion(t, s, h) {
          const m = this.context, g = m.gl, T = !!h;
          var z;
          h || (h = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), m.activeTexture.set(g.TEXTURE3), t && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE), h.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], h.u_depth_range_unpack = [2 / ((z = this.depthRangeFor3D)[1] - z[0]), -1 - 2 * z[0] / (z[1] - z[0])], h.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, h.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE), m.activeTexture.set(g.TEXTURE0), T || s.setTerrainUniformValues(m, h);
        }
      }
      function rh(c, t) {
        let s = !1, h = null;
        const m = () => {
          h = null, s && (c(), h = setTimeout(m, t), s = !1);
        };
        return () => (s = !0, h || m(), h);
      }
      class Cd {
        constructor(t) {
          this._hashName = t && encodeURIComponent(t), i.aP(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = rh(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t) {
          return this._map = t, window.addEventListener("hashchange", this._onHashChange, !1), t.on("moveend", this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
        }
        getHashString() {
          const t = this._map;
          if (!t)
            return "";
          const s = yu(t);
          if (this._hashName) {
            const h = this._hashName;
            let m = !1;
            const g = location.hash.slice(1).split("&").map((T) => {
              const z = T.split("=")[0];
              return z === h ? (m = !0, `${z}=${s}`) : T;
            }).filter((T) => T);
            return m || g.push(`${h}=${s}`), `#${g.join("&")}`;
          }
          return `#${s}`;
        }
        _getCurrentHash() {
          const t = location.hash.replace("#", "");
          if (this._hashName) {
            let s;
            return t.split("&").map((h) => h.split("=")).forEach((h) => {
              h[0] === this._hashName && (s = h);
            }), (s && s[1] || "").split("/");
          }
          return t.split("/");
        }
        _onHashChange() {
          const t = this._map;
          if (!t)
            return !1;
          const s = this._getCurrentHash();
          if (s.length >= 3 && !s.some((h) => isNaN(h))) {
            const h = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(s[3] || 0) : t.getBearing();
            return t.jumpTo({ center: [+s[2], +s[1]], zoom: +s[0], bearing: h, pitch: +(s[4] || 0) }), !0;
          }
          return !1;
        }
        _updateHashUnthrottled() {
          history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
        }
      }
      function yu(c, t) {
        const s = c.getCenter(), h = Math.round(100 * c.getZoom()) / 100, m = Math.ceil((h * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), g = Math.pow(10, m), T = Math.round(s.lng * g) / g, z = Math.round(s.lat * g) / g, R = c.getBearing(), F = c.getPitch();
        let N = t ? `/${T}/${z}/${h}` : `${h}/${z}/${T}`;
        return (R || F) && (N += "/" + Math.round(10 * R) / 10), F && (N += `/${Math.round(F)}`), N;
      }
      const oh = { linearity: 0.3, easing: i.dy(0, 0, 0.3, 1) }, ip = i.l({ deceleration: 2500, maxSpeed: 1400 }, oh), np = i.l({ deceleration: 20, maxSpeed: 1400 }, oh), sp = i.l({ deceleration: 1e3, maxSpeed: 360 }, oh), rp = i.l({ deceleration: 1e3, maxSpeed: 90 }, oh);
      class op {
        constructor(t) {
          this._map = t, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: i.q.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer, s = i.q.now();
          for (; t.length > 0 && s - t[0].time > 160; )
            t.shift();
        }
        _onMoveEnd(t) {
          if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2))
            return;
          const s = { zoom: 0, bearing: 0, pitch: 0, pan: new i.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: g } of this._inertiaBuffer)
            s.zoom += g.zoomDelta || 0, s.bearing += g.bearingDelta || 0, s.pitch += g.pitchDelta || 0, g.panDelta && s.pan._add(g.panDelta), g.around && (s.around = g.around), g.pinchAround && (s.pinchAround = g.pinchAround);
          const h = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, m = {};
          if (s.pan.mag()) {
            const g = lh(s.pan.mag(), h, i.l({}, ip, t || {}));
            m.offset = s.pan.mult(g.amount / s.pan.mag()), m.center = this._map.transform.center, ah(m, g);
          }
          if (s.zoom) {
            const g = lh(s.zoom, h, np);
            m.zoom = this._map.transform.zoom + g.amount, ah(m, g);
          }
          if (s.bearing) {
            const g = lh(s.bearing, h, sp);
            m.bearing = this._map.transform.bearing + i.aw(g.amount, -179, 179), ah(m, g);
          }
          if (s.pitch) {
            const g = lh(s.pitch, h, rp);
            m.pitch = this._map.transform.pitch + g.amount, ah(m, g);
          }
          if (m.zoom || m.bearing) {
            const g = s.pinchAround === void 0 ? s.around : s.pinchAround;
            m.around = g ? this._map.unproject(g) : this._map.getCenter();
          }
          return this.clear(), m.noMoveStart = !0, m;
        }
      }
      function ah(c, t) {
        (!c.duration || c.duration < t.duration) && (c.duration = t.duration, c.easing = t.easing);
      }
      function lh(c, t, s) {
        const { maxSpeed: h, linearity: m, deceleration: g } = s, T = i.aw(c * m / (t / 1e3), -h, h), z = Math.abs(T) / (g * m);
        return { easing: s.easing, duration: 1e3 * z, amount: T * (z / 2) };
      }
      class Or extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, h, m = {}) {
          const g = Gt(s.getCanvasContainer(), h), T = s.unproject(g);
          super(t, i.l({ point: g, lngLat: T, originalEvent: h }, m)), this._defaultPrevented = !1, this.target = s;
        }
      }
      class ch extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s, h) {
          const m = t === "touchend" ? h.changedTouches : h.touches, g = ui(s.getCanvasContainer(), m), T = g.map((R) => s.unproject(R)), z = g.reduce((R, F, N, j) => R.add(F.div(j.length)), new i.P(0, 0));
          super(t, { points: g, point: z, lngLats: T, lngLat: s.unproject(z), originalEvent: h }), this._defaultPrevented = !1;
        }
      }
      class ap extends i.z {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, s) {
          super("wheel", { originalEvent: s }), this._defaultPrevented = !1;
        }
      }
      class lp {
        constructor(t, s) {
          this._map = t, this._clickTolerance = s.clickTolerance;
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(t) {
          return this._firePreventable(new ap(this._map, t));
        }
        mousedown(t, s) {
          return this._mousedownPos = s, this._firePreventable(new Or(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        preclick(t) {
          const s = i.l({}, t);
          s.type = "preclick", this._map.fire(new Or(s.type, this._map, s));
        }
        click(t, s) {
          this._mousedownPos && this._mousedownPos.dist(s) >= this._clickTolerance || (this.preclick(t), this._map.fire(new Or(t.type, this._map, t)));
        }
        dblclick(t) {
          return this._firePreventable(new Or(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new ch(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new ch(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new ch(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new ch(t.type, this._map, t));
        }
        _firePreventable(t) {
          if (this._map.fire(t), t.defaultPrevented)
            return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class cp {
        constructor(t) {
          this._map = t;
        }
        reset() {
          this._delayContextMenu = !1, this._contextMenuEvent = void 0;
        }
        mousemove(t) {
          this._map.fire(new Or(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new Or("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new Or(t.type, this._map, t)), this._map.listens("contextmenu") && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Qm {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._container = t.getContainer(), this._clickTolerance = s.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, s) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (ut(), this._startPos = this._lastPos = s, this._active = !0);
        }
        mousemoveWindow(t, s) {
          if (!this._active)
            return;
          const h = s, m = this._startPos, g = this._lastPos;
          if (!m || !g || g.equals(h) || !this._box && h.dist(m) < this._clickTolerance)
            return;
          this._lastPos = h, this._box || (this._box = we("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t));
          const T = Math.min(m.x, h.x), z = Math.max(m.x, h.x), R = Math.min(m.y, h.y), F = Math.max(m.y, h.y);
          this._map._requestDomTask(() => {
            this._box && (this._box.style.transform = `translate(${T}px,${R}px)`, this._box.style.width = z - T + "px", this._box.style.height = F - R + "px");
          });
        }
        mouseupWindow(t, s) {
          if (!this._active)
            return;
          const h = this._startPos, m = s;
          if (h && t.button === 0) {
            if (this.reset(), pt(), h.x !== m.x || h.y !== m.y)
              return this._map.fire(new i.z("boxzoomend", { originalEvent: t })), { cameraAnimation: (g) => g.fitScreenCoordinates(h, m, this._map.getBearing(), { linear: !1 }) };
            this._fireEvent("boxzoomcancel", t);
          }
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), bt(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, s) {
          return this._map.fire(new i.z(t, { originalEvent: s }));
        }
      }
      function Id(c, t) {
        const s = {};
        for (let h = 0; h < c.length; h++)
          s[c[h].identifier] = t[h];
        return s;
      }
      class Wn {
        constructor(t) {
          this.reset(), this.numTouches = t.numTouches;
        }
        reset() {
          this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
        }
        touchstart(t, s, h) {
          (this.centroid || h.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === 0 && (this.startTime = t.timeStamp), h.length === this.numTouches && (this.centroid = function(m) {
            const g = new i.P(0, 0);
            for (const T of m)
              g._add(T);
            return g.div(m.length);
          }(s), this.touches = Id(h, s)));
        }
        touchmove(t, s, h) {
          if (this.aborted || !this.centroid)
            return;
          const m = Id(h, s);
          for (const g in this.touches) {
            const T = m[g];
            (!T || T.dist(this.touches[g]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, s, h) {
          if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), h.length === 0) {
            const m = !this.aborted && this.centroid;
            if (this.reset(), m)
              return m;
          }
        }
      }
      class xu {
        constructor(t) {
          this.singleTap = new Wn(t), this.numTaps = t.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
        }
        touchstart(t, s, h) {
          this.singleTap.touchstart(t, s, h);
        }
        touchmove(t, s, h) {
          this.singleTap.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          const m = this.singleTap.touchend(t, s, h);
          if (m) {
            const g = t.timeStamp - this.lastTime < 500, T = !this.lastTap || this.lastTap.dist(m) < 30;
            if (g && T || this.reset(), this.count++, this.lastTime = t.timeStamp, this.lastTap = m, this.count === this.numTaps)
              return this.reset(), m;
          }
        }
      }
      class e_ {
        constructor() {
          this._zoomIn = new xu({ numTouches: 1, numTaps: 2 }), this._zoomOut = new xu({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, s, h) {
          this._zoomIn.touchstart(t, s, h), this._zoomOut.touchstart(t, s, h);
        }
        touchmove(t, s, h) {
          this._zoomIn.touchmove(t, s, h), this._zoomOut.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          const m = this._zoomIn.touchend(t, s, h), g = this._zoomOut.touchend(t, s, h);
          return m ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: T.getZoom() + 1, around: T.unproject(m) }, { originalEvent: t }) }) : g ? (this._active = !0, t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (T) => T.easeTo({ duration: 300, zoom: T.getZoom() - 1, around: T.unproject(g) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const t_ = { 0: 1, 2: 2 };
      class El {
        constructor(t) {
          this.reset(), this._clickTolerance = t.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
        }
        _correctButton(t, s) {
          return !1;
        }
        _move(t, s) {
          return {};
        }
        mousedown(t, s) {
          if (this._lastPoint)
            return;
          const h = kt(t);
          this._correctButton(t, h) && (this._lastPoint = s, this._eventButton = h);
        }
        mousemoveWindow(t, s) {
          const h = this._lastPoint;
          if (h) {
            if (t.preventDefault(), this._eventButton != null && function(m, g) {
              const T = t_[g];
              return m.buttons === void 0 || (m.buttons & T) !== T;
            }(t, this._eventButton))
              this.reset();
            else if (this._moved || !(s.dist(h) < this._clickTolerance))
              return this._moved = !0, this._lastPoint = s, this._move(h, s);
          }
        }
        mouseupWindow(t) {
          this._lastPoint && kt(t) === this._eventButton && (this._moved && pt(), this.reset());
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class hp extends El {
        mousedown(t, s) {
          super.mousedown(t, s), this._lastPoint && (this._active = !0);
        }
        _correctButton(t, s) {
          return s === 0 && !t.ctrlKey;
        }
        _move(t, s) {
          return { around: s, panDelta: s.sub(t) };
        }
      }
      class vu extends El {
        _correctButton(t, s) {
          return s === 0 && t.ctrlKey || s === 2;
        }
        _move(t, s) {
          const h = 0.8 * (s.x - t.x);
          if (h)
            return this._active = !0, { bearingDelta: h };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class hh extends El {
        _correctButton(t, s) {
          return s === 0 && t.ctrlKey || s === 2;
        }
        _move(t, s) {
          const h = -0.5 * (s.y - t.y);
          if (h)
            return this._active = !0, { pitchDelta: h };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class va {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = s.clickTolerance || 1, this.reset(), i.aP(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new i.P(0, 0);
        }
        touchstart(t, s, h) {
          return this._calculateTransform(t, s, h);
        }
        touchmove(t, s, h) {
          if (this._active && !(h.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (h.length === 1 && !i.dz())
                return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
            }
            return t.cancelable && t.preventDefault(), this._calculateTransform(t, s, h);
          }
        }
        touchend(t, s, h) {
          this._calculateTransform(t, s, h), this._active && h.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, s, h) {
          h.length > 0 && (this._active = !0);
          const m = Id(h, s), g = new i.P(0, 0), T = new i.P(0, 0);
          let z = 0;
          for (const F in m) {
            const N = m[F], j = this._touches[F];
            j && (g._add(N), T._add(N.sub(j)), z++, m[F] = N);
          }
          if (this._touches = m, z < this._minTouches || !T.mag())
            return;
          const R = T.div(z);
          return this._sum._add(R), this._sum.mag() < this._clickTolerance ? void 0 : { around: g.div(z), panDelta: R };
        }
        enable() {
          this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
        }
        disable() {
          this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = we("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showTouchPanBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 500);
        }
      }
      class hc {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, this._firstTwoTouches = void 0;
        }
        _start(t) {
        }
        _move(t, s, h) {
          return {};
        }
        touchstart(t, s, h) {
          this._firstTwoTouches || h.length < 2 || (this._firstTwoTouches = [h[0].identifier, h[1].identifier], this._start([s[0], s[1]]));
        }
        touchmove(t, s, h) {
          const m = this._firstTwoTouches;
          if (!m)
            return;
          t.preventDefault();
          const [g, T] = m, z = Nn(h, s, g), R = Nn(h, s, T);
          if (!z || !R)
            return;
          const F = this._aroundCenter ? null : z.add(R).div(2);
          return this._move([z, R], F, t);
        }
        touchend(t, s, h) {
          if (!this._firstTwoTouches)
            return;
          const [m, g] = this._firstTwoTouches, T = Nn(h, s, m), z = Nn(h, s, g);
          T && z || (this._active && pt(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          this._enabled = !0, this._aroundCenter = !!t && t.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Nn(c, t, s) {
        for (let h = 0; h < c.length; h++)
          if (c[h].identifier === s)
            return t[h];
      }
      function Lo(c, t) {
        return Math.log(c / t) / Math.LN2;
      }
      class Ld extends hc {
        reset() {
          super.reset(), this._distance = 0, this._startDistance = 0;
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, s) {
          const h = this._distance;
          if (this._distance = t[0].dist(t[1]), this._active || !(Math.abs(Lo(this._distance, this._startDistance)) < 0.1))
            return this._active = !0, { zoomDelta: Lo(this._distance, h), pinchAround: s };
        }
      }
      function uh(c, t) {
        return 180 * c.angleWith(t) / Math.PI;
      }
      class up extends hc {
        reset() {
          super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
        }
        _start(t) {
          this._startVector = this._vector = t[0].sub(t[1]), this._minDiameter = t[0].dist(t[1]);
        }
        _move(t, s) {
          const h = this._vector;
          if (this._vector = t[0].sub(t[1]), h && (this._active || !this._isBelowThreshold(this._vector)))
            return this._active = !0, { bearingDelta: uh(this._vector, h), pinchAround: s };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const s = 25 / (Math.PI * this._minDiameter) * 360, h = this._startVector;
          if (!h)
            return !1;
          const m = uh(t, h);
          return Math.abs(m) < s;
        }
      }
      function zd(c) {
        return Math.abs(c.y) > Math.abs(c.x);
      }
      class dh extends hc {
        constructor(t) {
          super(), this._map = t;
        }
        reset() {
          super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
        }
        _start(t) {
          this._lastPoints = t, zd(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, s, h) {
          const m = this._lastPoints;
          if (!m)
            return;
          const g = t[0].sub(m[0]), T = t[1].sub(m[1]);
          return this._map._cooperativeGestures && !i.dz() && h.touches.length < 3 || (this._valid = this.gestureBeginsVertically(g, T, h.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, { pitchDelta: (g.y + T.y) / 2 * -0.5 });
        }
        gestureBeginsVertically(t, s, h) {
          if (this._valid !== void 0)
            return this._valid;
          const m = t.mag() >= 2, g = s.mag() >= 2;
          if (!m && !g)
            return;
          if (!m || !g)
            return this._firstMove == null && (this._firstMove = h), h - this._firstMove < 100 && void 0;
          const T = t.y > 0 == s.y > 0;
          return zd(t) && zd(s) && T;
        }
      }
      const i_ = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class n_ {
        constructor() {
          const t = i_;
          this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey)
            return;
          let s = 0, h = 0, m = 0, g = 0, T = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              s = 1;
              break;
            case 189:
            case 109:
            case 173:
              s = -1;
              break;
            case 37:
              t.shiftKey ? h = -1 : (t.preventDefault(), g = -1);
              break;
            case 39:
              t.shiftKey ? h = 1 : (t.preventDefault(), g = 1);
              break;
            case 38:
              t.shiftKey ? m = 1 : (t.preventDefault(), T = -1);
              break;
            case 40:
              t.shiftKey ? m = -1 : (t.preventDefault(), T = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (h = 0, m = 0), { cameraAnimation: (z) => {
            const R = z.getZoom();
            z.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Dd, zoom: s ? Math.round(R) + s * (t.shiftKey ? 2 : 1) : R, bearing: z.getBearing() + h * this._bearingStep, pitch: z.getPitch() + m * this._pitchStep, offset: [-g * this._panStep, -T * this._panStep], center: z.getCenter() }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function Dd(c) {
        return c * (2 - c);
      }
      const bu = 4.000244140625, uc = 1 / 450;
      class dc {
        constructor(t, s) {
          this._map = t, this._el = t.getCanvasContainer(), this._handler = s, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = uc, i.aP(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!t && t.around === "center", this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t) {
          if (!this.isEnabled())
            return;
          if (this._map._cooperativeGestures) {
            if (!(t.ctrlKey || t.metaKey || this.isZooming() || i.dz()))
              return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== "hidden" && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
          }
          let s = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const h = i.q.now(), m = h - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = h, s !== 0 && s % bu == 0 ? this._type = "wheel" : s !== 0 && Math.abs(s) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = s, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(m * s) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, s += this._lastValue)), t.shiftKey && s && (s /= 4), this._type && (this._lastWheelEvent = t, this._delta -= s, this._active || this._start(t)), t.preventDefault();
        }
        _onTimeout(t) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t);
        }
        _start(t) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const s = Gt(this._el, t);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : s, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive()))
            return;
          const t = this._map.transform;
          this._type === "wheel" && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
          const s = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;
          if (this._delta !== 0) {
            const F = this._type === "wheel" && Math.abs(this._delta) > bu ? this._wheelZoomRate : this._defaultZoomRate;
            let N = 2 / (1 + Math.exp(-Math.abs(this._delta * F)));
            this._delta < 0 && N !== 0 && (N = 1 / N);
            const j = s(), G = Math.pow(2, j), W = typeof this._targetZoom == "number" ? t.zoomScale(this._targetZoom) : G;
            this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(W * N))), this._type === "wheel" && (this._startZoom = j, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
          }
          const h = typeof this._targetZoom == "number" ? this._targetZoom : s(), m = this._startZoom, g = this._easing;
          let T, z = !1;
          if (this._type === "wheel" && m && g) {
            const F = Math.min((i.q.now() - this._lastWheelEventTime) / 200, 1), N = g(F);
            T = i.af(m, h, N), F < 1 ? this._frameId || (this._frameId = !0) : z = !0;
          } else
            T = h, z = !0;
          this._active = !0, z && (this._active = !1, this._finishTimeout = window.setTimeout(() => {
            this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200));
          let R = T - s();
          return R * this._lastDelta < 0 && (R = 0), { noInertia: !0, needsRenderFrame: !z, zoomDelta: R, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let s = i.dA;
          if (this._prevEase) {
            const h = this._prevEase, m = (i.q.now() - h.start) / h.duration, g = h.easing(m + 0.01) - h.easing(m), T = 0.27 / Math.sqrt(g * g + 1e-4) * 0.01, z = Math.sqrt(0.0729 - T * T);
            s = i.dy(T, z, 0.25, 1);
          }
          return this._prevEase = { start: i.q.now(), duration: t, easing: s }, s;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && (this._alertContainer = we("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
        }
        _showBlockerAlert() {
          this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
          }, 200);
        }
      }
      class ba {
        constructor(t, s) {
          this._clickZoom = t, this._tapZoom = s;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class zo {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        blur() {
          this.reset();
        }
        dblclick(t, s) {
          return t.preventDefault(), { cameraAnimation: (h) => {
            h.easeTo({ duration: 300, zoom: h.getZoom() + (t.shiftKey ? -1 : 1), around: h.unproject(s) }, { originalEvent: t });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Ya {
        constructor() {
          this._tap = new xu({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
        }
        touchstart(t, s, h) {
          this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? h.length > 0 && (this._swipePoint = s[0], this._swipeTouch = h[0].identifier) : this._tap.touchstart(t, s, h));
        }
        touchmove(t, s, h) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (h[0].identifier !== this._swipeTouch)
                return;
              const m = s[0], g = m.y - this._swipePoint.y;
              return this._swipePoint = m, t.preventDefault(), this._active = !0, { zoomDelta: g / 128 };
            }
          } else
            this._tap.touchmove(t, s, h);
        }
        touchend(t, s, h) {
          this._tapTime ? this._swipePoint && h.length === 0 && this.reset() : this._tap.touchend(t, s, h) && (this._tapTime = t.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Al {
        constructor(t, s, h) {
          this._el = t, this._mousePan = s, this._touchPan = h;
        }
        enable(t) {
          this._inertiaOptions = t || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class Ka {
        constructor(t, s, h) {
          this._pitchWithRotate = t.pitchWithRotate, this._mouseRotate = s, this._mousePitch = h;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class s_ {
        constructor(t, s, h, m) {
          this._el = t, this._touchZoom = s, this._touchRotate = h, this._tapDragZoom = m, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const wu = (c) => c.zoom || c.drag || c.pitch || c.rotate;
      class r_ extends i.z {
      }
      class o_ {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t, s) {
          const h = i.ab.vec3.sub([], s, t);
          this.radius = i.ab.vec3.length(h[2] < 0 ? i.ab.vec3.div([], h, this.constants) : [h[0], h[1], 0]);
        }
        projectRay(t) {
          i.ab.vec3.div(t, t, this.constants), i.ab.vec3.normalize(t, t), i.ab.vec3.mul(t, t, this.constants);
          const s = i.ab.vec3.scale([], t, this.radius);
          if (s[2] > 0) {
            const h = i.ab.vec3.scale([], [0, 0, 1], i.ab.vec3.dot(s, [0, 0, 1])), m = i.ab.vec3.scale([], i.ab.vec3.normalize([], [s[0], s[1], 0]), this.radius), g = i.ab.vec3.add([], s, i.ab.vec3.scale([], i.ab.vec3.sub([], i.ab.vec3.add([], m, h), s), 2));
            s[0] = g[0], s[1] = g[1];
          }
          return s;
        }
      }
      function fh(c) {
        return c.panDelta && c.panDelta.mag() || c.zoomDelta || c.bearingDelta || c.pitchDelta;
      }
      class dr {
        constructor(t, s) {
          this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new op(t), this._bearingSnap = s.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new o_(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(s), i.aP(["handleEvent", "handleWindowEvent"], this);
          const h = this._el;
          this._listeners = [[h, "touchstart", { passive: !0 }], [h, "touchmove", { passive: !1 }], [h, "touchend", void 0], [h, "touchcancel", void 0], [h, "mousedown", void 0], [h, "mousemove", void 0], [h, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [h, "mouseover", void 0], [h, "mouseout", void 0], [h, "dblclick", void 0], [h, "click", void 0], [h, "keydown", { capture: !1 }], [h, "keyup", void 0], [h, "wheel", { passive: !1 }], [h, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [m, g, T] of this._listeners) {
            const z = m === document ? this.handleWindowEvent : this.handleEvent;
            m.addEventListener(g, z, T);
          }
        }
        destroy() {
          for (const [t, s, h] of this._listeners) {
            const m = t === document ? this.handleWindowEvent : this.handleEvent;
            t.removeEventListener(s, m, h);
          }
        }
        _addDefaultHandlers(t) {
          const s = this._map, h = s.getCanvasContainer();
          this._add("mapEvent", new lp(s, t));
          const m = s.boxZoom = new Qm(s, t);
          this._add("boxZoom", m);
          const g = new e_(), T = new zo();
          s.doubleClickZoom = new ba(T, g), this._add("tapZoom", g), this._add("clickZoom", T);
          const z = new Ya();
          this._add("tapDragZoom", z);
          const R = s.touchPitch = new dh(s);
          this._add("touchPitch", R);
          const F = new vu(t), N = new hh(t);
          s.dragRotate = new Ka(t, F, N), this._add("mouseRotate", F, ["mousePitch"]), this._add("mousePitch", N, ["mouseRotate"]);
          const j = new hp(t), G = new va(s, t);
          s.dragPan = new Al(h, j, G), this._add("mousePan", j), this._add("touchPan", G, ["touchZoom", "touchRotate"]);
          const W = new up(), te = new Ld();
          s.touchZoomRotate = new s_(h, te, W, z), this._add("touchRotate", W, ["touchPan", "touchZoom"]), this._add("touchZoom", te, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new cp(s));
          const ee = s.scrollZoom = new dc(s, this);
          this._add("scrollZoom", ee, ["mousePan"]);
          const se = s.keyboard = new n_();
          this._add("keyboard", se);
          for (const oe of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            t.interactive && t[oe] && s[oe].enable(t[oe]);
        }
        _add(t, s, h) {
          this._handlers.push({ handlerName: t, handler: s, allowed: h }), this._handlersById[t] = s;
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: s } of this._handlers)
              s.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), this._changes = [], this._originalZoom = void 0;
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers)
            if (t.isActive())
              return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!wu(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(t, s, h) {
          for (const m in t)
            if (m !== h && (!s || s.indexOf(m) < 0))
              return !0;
          return !1;
        }
        handleWindowEvent(t) {
          this.handleEvent(t, `${t.type}Window`);
        }
        _getMapTouches(t) {
          const s = [];
          for (const h of t)
            this._el.contains(h.target) && s.push(h);
          return s;
        }
        handleEvent(t, s) {
          this._updatingCamera = !0;
          const h = t.type === "renderFrame", m = h ? void 0 : t, g = { needsRenderFrame: !1 }, T = {}, z = {}, R = t.touches ? this._getMapTouches(t.touches) : void 0, F = R ? ui(this._el, R) : h ? void 0 : Gt(this._el, t);
          for (const { handlerName: G, handler: W, allowed: te } of this._handlers) {
            if (!W.isEnabled())
              continue;
            let ee;
            this._blockedByActive(z, te, G) ? W.reset() : W[s || t.type] && (ee = W[s || t.type](t, F, R), this.mergeHandlerResult(g, T, ee, G, m), ee && ee.needsRenderFrame && this._triggerRenderFrame()), (ee || W.isActive()) && (z[G] = W);
          }
          const N = {};
          for (const G in this._previousActiveHandlers)
            z[G] || (N[G] = m);
          this._previousActiveHandlers = z, (Object.keys(N).length || fh(g)) && (this._changes.push([g, T, N]), this._triggerRenderFrame()), (Object.keys(z).length || fh(g)) && this._map._stop(!0), this._updatingCamera = !1;
          const { cameraAnimation: j } = g;
          j && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], j(this._map));
        }
        mergeHandlerResult(t, s, h, m, g) {
          if (!h)
            return;
          i.l(t, h);
          const T = { handlerName: m, originalEvent: h.originalEvent || g };
          h.zoomDelta !== void 0 && (s.zoom = T), h.panDelta !== void 0 && (s.drag = T), h.pitchDelta !== void 0 && (s.pitch = T), h.bearingDelta !== void 0 && (s.rotate = T);
        }
        _applyChanges() {
          const t = {}, s = {}, h = {};
          for (const [m, g, T] of this._changes)
            m.panDelta && (t.panDelta = (t.panDelta || new i.P(0, 0))._add(m.panDelta)), m.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + m.pitchDelta), m.around !== void 0 && (t.around = m.around), m.aroundCoord !== void 0 && (t.aroundCoord = m.aroundCoord), m.pinchAround !== void 0 && (t.pinchAround = m.pinchAround), m.noInertia && (t.noInertia = m.noInertia), i.l(s, g), i.l(h, T);
          this._updateMapTransform(t, s, h), this._changes = [];
        }
        _updateMapTransform(t, s, h) {
          const m = this._map, g = m.transform, T = (ce) => [ce.x, ce.y, ce.z];
          if (((ce) => {
            const _e = this._eventsInProgress.drag;
            return _e && !this._handlersById[_e.handlerName].isActive();
          })() && !fh(t)) {
            const ce = g.zoom;
            g.cameraElevationReference = "sea", this._originalZoom != null && g._orthographicProjectionAtLowPitch && g.projection.name !== "globe" && g.pitch === 0 ? (g.cameraElevationReference = "ground", g.zoom = this._originalZoom) : (g.recenterOnTerrain(), g.cameraElevationReference = "ground"), ce !== g.zoom && this._map._update(!0);
          }
          if (g._isCameraConstrained && m._stop(!0), !fh(t))
            return void this._fireEvents(s, h, !0);
          let { panDelta: z, zoomDelta: R, bearingDelta: F, pitchDelta: N, around: j, aroundCoord: G, pinchAround: W } = t;
          g._isCameraConstrained && (R > 0 && (R = 0), g._isCameraConstrained = !1), W !== void 0 && (j = W), (R || ((ce) => s[ce] && !this._eventsInProgress[ce])("drag")) && j && (this._dragOrigin = T(g.pointCoordinate3D(j)), this._originalZoom = g.zoom, this._trackingEllipsoid.setup(g._camera.position, this._dragOrigin)), g.cameraElevationReference = "sea", m._stop(!0), j = j || m.transform.centerPoint, F && (g.bearing += F), N && (g.pitch += N), g._updateCameraState();
          const te = [0, 0, 0];
          if (z)
            if (g.projection.name === "mercator") {
              const ce = this._trackingEllipsoid.projectRay(g.screenPointToMercatorRay(j).dir), _e = this._trackingEllipsoid.projectRay(g.screenPointToMercatorRay(j.sub(z)).dir);
              te[0] = _e[0] - ce[0], te[1] = _e[1] - ce[1];
            } else {
              const ce = g.pointCoordinate(j);
              if (g.projection.name === "globe") {
                z = z.rotate(-g.angle);
                const _e = g._pixelsPerMercatorPixel / g.worldSize;
                te[0] = -z.x * i.dB(i.aS(ce.y)) * _e, te[1] = -z.y * i.dB(g.center.lat) * _e;
              } else {
                const _e = g.pointCoordinate(j.sub(z));
                ce && _e && (te[0] = _e.x - ce.x, te[1] = _e.y - ce.y);
              }
            }
          const ee = g.zoom, se = [0, 0, 0];
          if (R) {
            const ce = T(G || g.pointCoordinate3D(j)), _e = { dir: i.ab.vec3.normalize([], i.ab.vec3.sub([], ce, g._camera.position)) };
            if (_e.dir[2] < 0) {
              const pe = g.zoomDeltaToMovement(ce, R);
              i.ab.vec3.scale(se, _e.dir, pe);
            }
          }
          const oe = i.ab.vec3.add(te, te, se);
          g._translateCameraConstrained(oe), R && Math.abs(g.zoom - ee) > 1e-4 && g.recenterOnTerrain(), g.cameraElevationReference = "ground", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(s, h, !0);
        }
        _fireEvents(t, s, h) {
          const m = wu(this._eventsInProgress), g = wu(t), T = {};
          for (const N in t) {
            const { originalEvent: j } = t[N];
            this._eventsInProgress[N] || (T[`${N}start`] = j), this._eventsInProgress[N] = t[N];
          }
          !m && g && this._fireEvent("movestart", g.originalEvent);
          for (const N in T)
            this._fireEvent(N, T[N]);
          g && this._fireEvent("move", g.originalEvent);
          for (const N in t) {
            const { originalEvent: j } = t[N];
            this._fireEvent(N, j);
          }
          const z = {};
          let R;
          for (const N in this._eventsInProgress) {
            const { handlerName: j, originalEvent: G } = this._eventsInProgress[N];
            this._handlersById[j].isActive() || (delete this._eventsInProgress[N], R = s[j] || G, z[`${N}end`] = R);
          }
          for (const N in z)
            this._fireEvent(N, z[N]);
          const F = wu(this._eventsInProgress);
          if (h && (m || g) && !F) {
            this._updatingCamera = !0;
            const N = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), j = (G) => G !== 0 && -this._bearingSnap < G && G < this._bearingSnap;
            N ? (j(N.bearing || this._map.getBearing()) && (N.bearing = 0), this._map.easeTo(N, { originalEvent: R })) : (this._map.fire(new i.z("moveend", { originalEvent: R })), j(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
          }
        }
        _fireEvent(t, s) {
          this._map.fire(new i.z(t, s ? { originalEvent: s } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t) => {
            this._frameId = void 0, this.handleEvent(new r_("renderFrame", { timeStamp: t })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const Tu = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
      class dp extends i.E {
        constructor(t, s) {
          super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = s.bearingSnap, this._respectPrefersReducedMotion = s.respectPrefersReducedMotion !== !1, i.aP(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new i.bO(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, s) {
          return this.jumpTo({ center: t }, s);
        }
        panBy(t, s, h) {
          return t = i.P.convert(t).mult(-1), this.panTo(this.transform.center, i.l({ offset: t }, s), h);
        }
        panTo(t, s, h) {
          return this.easeTo(i.l({ center: t }, s), h);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, s) {
          return this.jumpTo({ zoom: t }, s), this;
        }
        zoomTo(t, s, h) {
          return this.easeTo(i.l({ zoom: t }, s), h);
        }
        zoomIn(t, s) {
          return this.zoomTo(this.getZoom() + 1, t, s), this;
        }
        zoomOut(t, s) {
          return this.zoomTo(this.getZoom() - 1, t, s), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, s) {
          return this.jumpTo({ bearing: t }, s), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, s) {
          return this.jumpTo({ padding: t }, s), this;
        }
        rotateTo(t, s, h) {
          return this.easeTo(i.l({ bearing: t }, s), h);
        }
        resetNorth(t, s) {
          return this.rotateTo(0, i.l({ duration: 1e3 }, t), s), this;
        }
        resetNorthPitch(t, s) {
          return this.easeTo(i.l({ bearing: 0, pitch: 0, duration: 1e3 }, t), s), this;
        }
        snapToNorth(t, s) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, s) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, s) {
          return this.jumpTo({ pitch: t }, s), this;
        }
        cameraForBounds(t, s) {
          t = i.az.convert(t);
          const h = s && s.bearing || 0, m = s && s.pitch || 0, g = t.getNorthWest(), T = t.getSouthEast();
          return this._cameraForBounds(this.transform, g, T, h, m, s);
        }
        _extendPadding(t) {
          const s = { top: 0, right: 0, bottom: 0, left: 0 };
          return t == null ? i.l({}, s, this.transform.padding) : typeof t == "number" ? { top: t, bottom: t, right: t, left: t } : i.l({}, s, t);
        }
        _extendCameraOptions(t) {
          return (t = i.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding = this._extendPadding(t.padding), t;
        }
        _minimumAABBFrustumDistance(t, s) {
          const h = s.max[0] - s.min[0], m = s.max[1] - s.min[1];
          return h / m > t.aspect ? h / (2 * Math.tan(0.5 * t.fovX) * t.aspect) : m / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
        }
        _cameraForBoundsOnGlobe(t, s, h, m, g, T) {
          const z = t.clone(), R = this._extendCameraOptions(T);
          z.bearing = m, z.pitch = g;
          const F = i.bO.convert(s), N = i.bO.convert(h), j = 0.5 * (F.lat + N.lat), G = 0.5 * (F.lng + N.lng), W = i.dC(j, G), te = i.ab.vec3.normalize([], W), ee = i.ab.vec3.normalize([], i.ab.vec3.cross([], te, [0, 1, 0])), se = i.ab.vec3.cross([], ee, te), oe = [ee[0], ee[1], ee[2], 0, se[0], se[1], se[2], 0, te[0], te[1], te[2], 0, 0, 0, 0, 1], ce = [W, i.dC(F.lat, F.lng), i.dC(N.lat, F.lng), i.dC(N.lat, N.lng), i.dC(F.lat, N.lng), i.dC(j, F.lng), i.dC(j, N.lng), i.dC(F.lat, G), i.dC(N.lat, G)];
          let _e = i.cd.fromPoints(ce.map((Je) => [i.ab.vec3.dot(ee, Je), i.ab.vec3.dot(se, Je), i.ab.vec3.dot(te, Je)]));
          const pe = i.ab.vec3.transformMat4([], _e.center, oe);
          i.ab.vec3.squaredLength(pe) === 0 && i.ab.vec3.set(pe, 0, 0, 1), i.ab.vec3.normalize(pe, pe), i.ab.vec3.scale(pe, pe, i.ax), z.center = i.dD(pe);
          const Te = z.getWorldToCameraMatrix(), xe = i.ab.mat4.invert(new Float64Array(16), Te);
          _e = i.cd.applyTransform(_e, i.ab.mat4.multiply([], Te, oe));
          const be = this._extendAABB(_e, z, R, m);
          if (!be)
            return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          _e = be, i.ab.vec3.transformMat4(pe, pe, Te);
          const ve = 0.5 * (_e.max[2] - _e.min[2]), Pe = this._minimumAABBFrustumDistance(z, _e), Oe = i.ab.vec3.scale([], [0, 0, 1], ve), Xe = i.ab.vec3.add(Oe, pe, Oe), Ze = Pe + (z.pitch === 0 ? 0 : i.ab.vec3.distance(pe, Xe)), ke = z.globeCenterInViewSpace, Ne = i.ab.vec3.sub([], pe, [ke[0], ke[1], ke[2]]);
          i.ab.vec3.normalize(Ne, Ne), i.ab.vec3.scale(Ne, Ne, Ze);
          const st = i.ab.vec3.add([], pe, Ne);
          i.ab.vec3.transformMat4(st, st, xe);
          const ht = i.ds / i.ax, yt = i.ab.vec3.length(st), je = i.bH(Math.max(yt * ht - i.ds, Number.EPSILON), 0), at = Math.min(z.zoomFromMercatorZAdjusted(je), R.maxZoom);
          return at > 0.5 * (i.c6 + i.bY) ? (z.setProjection({ name: "mercator" }), z.zoom = at, this._cameraForBounds(z, s, h, m, g, T)) : { center: z.center, zoom: at, bearing: m, pitch: g };
        }
        _extendAABB(t, s, h, m) {
          const g = 0.5 * ((h.padding.left || 0) + (h.padding.right || 0)), T = 0.5 * ((h.padding.top || 0) + (h.padding.bottom || 0)), z = T, R = g, F = g, N = T, j = s.width - (R + F), G = s.height - (z + N), W = i.ab.vec3.sub([], t.max, t.min), te = Math.min(j / W[0], G / W[1]), ee = Math.min(s.scaleZoom(s.scale * te), h.maxZoom);
          if (isNaN(ee))
            return null;
          const se = s.scale / s.zoomScale(ee), oe = new i.cd([t.min[0] - R * se, t.min[1] - N * se, t.min[2]], [t.max[0] + F * se, t.max[1] + z * se, t.max[2]]), ce = (typeof h.offset.x == "number" && typeof h.offset.y == "number" ? new i.P(h.offset.x, h.offset.y) : i.P.convert(h.offset)).rotate(-i.ai(m));
          return oe.center[0] -= ce.x * se, oe.center[1] += ce.y * se, oe;
        }
        queryTerrainElevation(t, s) {
          const h = this.transform.elevation;
          return h ? (s = i.l({}, { exaggerated: !0 }, s), h.getAtPoint(i.aa.fromLngLat(t), null, s.exaggerated)) : null;
        }
        _cameraForBounds(t, s, h, m, g, T) {
          if (t.projection.name === "globe")
            return this._cameraForBoundsOnGlobe(t, s, h, m, g, T);
          const z = t.clone(), R = this._extendCameraOptions(T);
          z.bearing = m, z.pitch = g;
          const F = i.bO.convert(s), N = i.bO.convert(h), j = new i.bO(F.lng, N.lat), G = new i.bO(N.lng, F.lat), W = z.project(F), te = z.project(N), ee = this.queryTerrainElevation(F), se = this.queryTerrainElevation(N), oe = this.queryTerrainElevation(j), ce = this.queryTerrainElevation(G), _e = [[W.x, W.y, Math.min(ee || 0, se || 0, oe || 0, ce || 0)], [te.x, te.y, Math.max(ee || 0, se || 0, oe || 0, ce || 0)]];
          let pe = i.cd.fromPoints(_e);
          const Te = z.getWorldToCameraMatrix(), xe = i.ab.mat4.invert(new Float64Array(16), Te);
          pe = i.cd.applyTransform(pe, Te);
          const be = this._extendAABB(pe, z, R, m);
          if (!be)
            return void i.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          pe = be;
          const ve = 0.5 * i.ab.vec3.sub([], pe.max, pe.min)[2], Pe = this._minimumAABBFrustumDistance(z, pe), Oe = [0, 0, 1, 0];
          i.ab.vec4.transformMat4(Oe, Oe, Te), i.ab.vec4.normalize(Oe, Oe);
          const Xe = i.ab.vec3.scale([], Oe, Pe + ve), Ze = i.ab.vec3.add([], pe.center, Xe);
          i.ab.vec3.transformMat4(pe.center, pe.center, xe), i.ab.vec3.transformMat4(Ze, Ze, xe);
          const ke = z.unproject(new i.P(pe.center[0], pe.center[1])), Ne = i.dE(z.projection, ke), st = Math.pow(2, Ne), ht = Math.min(z._zoomFromMercatorZ(Ze[2] * z.pixelsPerMeter * st / z.worldSize), R.maxZoom);
          return z.mercatorFromTransition && ht < 0.5 * (i.c6 + i.bY) ? (z.setProjection({ name: "globe" }), z.zoom = ht, this._cameraForBounds(z, s, h, m, g, T)) : { center: ke, zoom: ht, bearing: m, pitch: g };
        }
        fitBounds(t, s, h) {
          const m = this.cameraForBounds(t, s);
          return this._fitInternal(m, s, h);
        }
        fitScreenCoordinates(t, s, h, m, g) {
          const T = i.P.convert(t), z = i.P.convert(s), R = new i.P(Math.min(T.x, z.x), Math.min(T.y, z.y)), F = new i.P(Math.max(T.x, z.x), Math.max(T.y, z.y));
          if (this.transform.projection.name === "mercator" && this.transform.anyCornerOffEdge(T, z))
            return this;
          const N = this.transform.pointLocation3D(R), j = this.transform.pointLocation3D(F), G = this.transform.pointLocation3D(new i.P(R.x, F.y)), W = this.transform.pointLocation3D(new i.P(F.x, R.y)), te = [Math.min(N.lng, j.lng, G.lng, W.lng), Math.min(N.lat, j.lat, G.lat, W.lat)], ee = [Math.max(N.lng, j.lng, G.lng, W.lng), Math.max(N.lat, j.lat, G.lat, W.lat)], se = m && m.pitch ? m.pitch : this.getPitch(), oe = this._cameraForBounds(this.transform, te, ee, h, se, m);
          return this._fitInternal(oe, m, g);
        }
        _fitInternal(t, s, h) {
          return t ? (s = i.l(t, s)).linear ? this.easeTo(s, h) : this.flyTo(s, h) : this;
        }
        jumpTo(t, s) {
          this.stop();
          const h = t.preloadOnly ? this.transform.clone() : this.transform;
          let m = !1, g = !1, T = !1;
          "zoom" in t && h.zoom !== +t.zoom && (m = !0, h.zoom = +t.zoom), t.center !== void 0 && (h.center = i.bO.convert(t.center)), "bearing" in t && h.bearing !== +t.bearing && (g = !0, h.bearing = +t.bearing), "pitch" in t && h.pitch !== +t.pitch && (T = !0, h.pitch = +t.pitch);
          const z = typeof t.padding == "number" ? this._extendPadding(t.padding) : t.padding;
          if (t.padding != null && !h.isPaddingEqual(z))
            if (t.retainPadding === !1) {
              const R = h.clone();
              R.padding = z, h.setLocationAtPoint(h.center, R.centerPoint);
            } else
              h.padding = z;
          return t.preloadOnly ? (this._preloadTiles(h), this) : (this.fire(new i.z("movestart", s)).fire(new i.z("move", s)), m && this.fire(new i.z("zoomstart", s)).fire(new i.z("zoom", s)).fire(new i.z("zoomend", s)), g && this.fire(new i.z("rotatestart", s)).fire(new i.z("rotate", s)).fire(new i.z("rotateend", s)), T && this.fire(new i.z("pitchstart", s)).fire(new i.z("pitch", s)).fire(new i.z("pitchend", s)), this.fire(new i.z("moveend", s)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || i.w(Tu), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t, s) {
          const h = this.transform;
          if (!h.projection.supportsFreeCamera)
            return i.w(Tu), this;
          this.stop();
          const m = h.zoom, g = h.pitch, T = h.bearing;
          h.setFreeCameraOptions(t);
          const z = m !== h.zoom, R = g !== h.pitch, F = T !== h.bearing;
          return this.fire(new i.z("movestart", s)).fire(new i.z("move", s)), z && this.fire(new i.z("zoomstart", s)).fire(new i.z("zoom", s)).fire(new i.z("zoomend", s)), F && this.fire(new i.z("rotatestart", s)).fire(new i.z("rotate", s)).fire(new i.z("rotateend", s)), R && this.fire(new i.z("pitchstart", s)).fire(new i.z("pitch", s)).fire(new i.z("pitchend", s)), this.fire(new i.z("moveend", s)), this;
        }
        easeTo(t, s) {
          this._stop(!1, t.easeId), ((t = i.l({ offset: [0, 0], duration: 500, easing: i.dA }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
          const h = this.transform, m = this.getZoom(), g = this.getBearing(), T = this.getPitch(), z = this.getPadding(), R = "zoom" in t ? +t.zoom : m, F = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, N = "pitch" in t ? +t.pitch : T, j = this._extendPadding(t.padding), G = i.P.convert(t.offset);
          let W, te, ee;
          if (h.projection.name === "globe") {
            const Oe = i.aa.fromLngLat(h.center), Xe = G.rotate(-h.angle);
            Oe.x += Xe.x / h.worldSize, Oe.y += Xe.y / h.worldSize;
            const Ze = Oe.toLngLat(), ke = i.bO.convert(t.center || Ze);
            this._normalizeCenter(ke), W = h.centerPoint.add(Xe), te = new i.P(Oe.x, Oe.y).mult(h.worldSize), ee = new i.P(i.at(ke.lng), i.aA(ke.lat)).mult(h.worldSize).sub(te);
          } else {
            W = h.centerPoint.add(G);
            const Oe = h.pointLocation(W), Xe = i.bO.convert(t.center || Oe);
            this._normalizeCenter(Xe), te = h.project(Oe), ee = h.project(Xe).sub(te);
          }
          const se = h.zoomScale(R - m);
          let oe, ce;
          t.around && (oe = i.bO.convert(t.around), ce = h.locationPoint(oe));
          const _e = this._zooming || R !== m, pe = this._rotating || g !== F, Te = this._pitching || N !== T, xe = !h.isPaddingEqual(j), be = t.retainPadding === !1 ? h.clone() : h, ve = (Oe) => (Xe) => {
            if (_e && (Oe.zoom = i.af(m, R, Xe)), pe && (Oe.bearing = i.af(g, F, Xe)), Te && (Oe.pitch = i.af(T, N, Xe)), xe && (be.interpolatePadding(z, j, Xe), W = be.centerPoint.add(G)), oe)
              Oe.setLocationAtPoint(oe, ce);
            else {
              const Ze = Oe.zoomScale(Oe.zoom - m), ke = R > m ? Math.min(2, se) : Math.max(0.5, se), Ne = Math.pow(ke, 1 - Xe), st = Oe.unproject(te.add(ee.mult(Xe * Ne)).mult(Ze));
              Oe.setLocationAtPoint(Oe.renderWorldCopies ? st.wrap() : st, W);
            }
            return t.preloadOnly || this._fireMoveEvents(s), Oe;
          };
          if (t.preloadOnly) {
            const Oe = this._emulate(ve, t.duration, h);
            return this._preloadTiles(Oe), this;
          }
          const Pe = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = _e, this._rotating = pe, this._pitching = Te, this._padding = xe, this._easeId = t.easeId, this._prepareEase(s, t.noMoveStart, Pe), this._ease(ve(h), (Oe) => {
            h.cameraElevationReference === "sea" && h.recenterOnTerrain(), this._afterEase(s, Oe);
          }, t), this;
        }
        _prepareEase(t, s, h = {}) {
          this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== "globe" && (this.transform.cameraElevationReference = "ground"), s || h.moving || this.fire(new i.z("movestart", t)), this._zooming && !h.zooming && this.fire(new i.z("zoomstart", t)), this._rotating && !h.rotating && this.fire(new i.z("rotatestart", t)), this._pitching && !h.pitching && this.fire(new i.z("pitchstart", t));
        }
        _fireMoveEvents(t) {
          this.fire(new i.z("move", t)), this._zooming && this.fire(new i.z("zoom", t)), this._rotating && this.fire(new i.z("rotate", t)), this._pitching && this.fire(new i.z("pitch", t));
        }
        _afterEase(t, s) {
          if (this._easeId && s && this._easeId === s)
            return;
          this._easeId = void 0, this.transform.cameraElevationReference = "ground";
          const h = this._zooming, m = this._rotating, g = this._pitching;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, h && this.fire(new i.z("zoomend", t)), m && this.fire(new i.z("rotateend", t)), g && this.fire(new i.z("pitchend", t)), this.fire(new i.z("moveend", t));
        }
        flyTo(t, s) {
          if (this._prefersReducedMotion(t)) {
            const Je = i.ay(t, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
            return this.jumpTo(Je, s);
          }
          this.stop(), t = i.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: i.dA }, t);
          const h = this.transform, m = this.getZoom(), g = this.getBearing(), T = this.getPitch(), z = this.getPadding(), R = "zoom" in t ? i.aw(+t.zoom, h.minZoom, h.maxZoom) : m, F = "bearing" in t ? this._normalizeBearing(t.bearing, g) : g, N = "pitch" in t ? +t.pitch : T, j = this._extendPadding(t.padding), G = h.zoomScale(R - m), W = i.P.convert(t.offset);
          let te = h.centerPoint.add(W);
          const ee = h.pointLocation(te), se = i.bO.convert(t.center || ee);
          this._normalizeCenter(se);
          const oe = h.project(ee), ce = h.project(se).sub(oe);
          let _e = t.curve;
          const pe = Math.max(h.width, h.height), Te = pe / G, xe = ce.mag();
          if ("minZoom" in t) {
            const Je = i.aw(Math.min(t.minZoom, m, R), h.minZoom, h.maxZoom), _t = pe / h.zoomScale(Je - m);
            _e = Math.sqrt(_t / xe * 2);
          }
          const be = _e * _e;
          function ve(Je) {
            const _t = (Te * Te - pe * pe + (Je ? -1 : 1) * be * be * xe * xe) / (2 * (Je ? Te : pe) * be * xe);
            return Math.log(Math.sqrt(_t * _t + 1) - _t);
          }
          function Pe(Je) {
            return (Math.exp(Je) - Math.exp(-Je)) / 2;
          }
          function Oe(Je) {
            return (Math.exp(Je) + Math.exp(-Je)) / 2;
          }
          const Xe = ve(0);
          let Ze = function(Je) {
            return Oe(Xe) / Oe(Xe + _e * Je);
          }, ke = function(Je) {
            return pe * ((Oe(Xe) * (Pe(_t = Xe + _e * Je) / Oe(_t)) - Pe(Xe)) / be) / xe;
            var _t;
          }, Ne = (ve(1) - Xe) / _e;
          if (Math.abs(xe) < 1e-6 || !isFinite(Ne)) {
            if (Math.abs(pe - Te) < 1e-6)
              return this.easeTo(t, s);
            const Je = Te < pe ? -1 : 1;
            Ne = Math.abs(Math.log(Te / pe)) / _e, ke = function() {
              return 0;
            }, Ze = function(_t) {
              return Math.exp(Je * _e * _t);
            };
          }
          t.duration = "duration" in t ? +t.duration : 1e3 * Ne / ("screenSpeed" in t ? +t.screenSpeed / _e : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
          const st = g !== F, ht = N !== T, yt = !h.isPaddingEqual(j), je = t.retainPadding === !1 ? h.clone() : h, at = (Je) => (_t) => {
            const ct = _t * Ne, nt = 1 / Ze(ct);
            Je.zoom = _t === 1 ? R : m + Je.scaleZoom(nt), st && (Je.bearing = i.af(g, F, _t)), ht && (Je.pitch = i.af(T, N, _t)), yt && (je.interpolatePadding(z, j, _t), te = je.centerPoint.add(W));
            const Lt = _t === 1 ? se : Je.unproject(oe.add(ce.mult(ke(ct))).mult(nt));
            return Je.setLocationAtPoint(Je.renderWorldCopies ? Lt.wrap() : Lt, te), Je._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(s), Je;
          };
          if (t.preloadOnly) {
            const Je = this._emulate(at, t.duration, h);
            return this._preloadTiles(Je), this;
          }
          return this._zooming = !0, this._rotating = st, this._pitching = ht, this._padding = yt, this._prepareEase(s, !1), this._ease(at(h), () => this._afterEase(s), t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _requestRenderFrame(t) {
        }
        _cancelRenderFrame(t) {
        }
        _stop(t, s) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
            const h = this._onEaseEnd;
            this._onEaseEnd = void 0, h.call(this, s);
          }
          if (!t) {
            const h = this.handlers;
            h && h.stop(!1);
          }
          return this;
        }
        _ease(t, s, h) {
          h.animate === !1 || h.duration === 0 ? (t(1), s()) : (this._easeStart = i.q.now(), this._easeOptions = h, this._onEaseFrame = t, this._onEaseEnd = s, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t = Math.min((i.q.now() - this._easeStart) / this._easeOptions.duration, 1), s = this._onEaseFrame;
          s && s(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t, s) {
          t = i.bF(t, -180, 180);
          const h = Math.abs(t - s);
          return Math.abs(t - 360 - s) < h && (t -= 360), Math.abs(t + 360 - s) < h && (t += 360), t;
        }
        _normalizeCenter(t) {
          const s = this.transform;
          if (s.maxBounds || s.projection.name !== "globe" && !s.renderWorldCopies)
            return;
          const h = t.lng - s.center.lng;
          t.lng += h > 180 ? -360 : h < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t) {
          return this._respectPrefersReducedMotion && i.q.prefersReducedMotion && !(t && t.essential);
        }
        _emulate(t, s, h) {
          const m = Math.ceil(15 * s / 1e3), g = [], T = t(h.clone());
          for (let z = 0; z <= m; z++) {
            const R = T(z / m);
            g.push(R.clone());
          }
          return g;
        }
        _preloadTiles(t, s) {
        }
      }
      class fp {
        constructor(t = {}) {
          this.options = t, i.aP(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t) {
          const s = this.options && this.options.compact, h = t._getUIString("AttributionControl.ToggleAttribution");
          this._map = t, this._container = we("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = we("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", h);
          const m = we("span", "mapboxgl-ctrl-icon", this._compactButton);
          return m.setAttribute("aria-hidden", "true"), m.setAttribute("title", h), this._innerContainer = we("div", "mapboxgl-ctrl-attrib-inner", this._container), s && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), s === void 0 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
        }
        _updateEditLink() {
          let t = this._editLink;
          t || (t = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const s = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || i.e.ACCESS_TOKEN }];
          if (t) {
            const h = s.reduce((m, g, T) => (g.value && (m += `${g.key}=${g.value}${T < s.length - 1 ? "&" : ""}`), m), "?");
            t.href = `${i.e.FEEDBACK_URL}/${h}#${yu(this._map, !0)}`, t.rel = "noopener nofollow";
          }
        }
        _updateData(t) {
          !t || t.sourceDataType !== "metadata" && t.sourceDataType !== "visibility" && t.dataType !== "style" || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let t = [];
          if (this._map.style.stylesheet) {
            const m = this._map.style.stylesheet;
            this.styleOwner = m.owner, this.styleId = m.id;
          }
          const s = this._map.style._mergedSourceCaches;
          for (const m in s) {
            const g = s[m];
            if (g.used) {
              const T = g.getSource();
              T.attribution && t.indexOf(T.attribution) < 0 && t.push(T.attribution);
            }
          }
          t.sort((m, g) => m.length - g.length), t = t.filter((m, g) => {
            for (let T = g + 1; T < t.length; T++)
              if (t[T].indexOf(m) >= 0)
                return !1;
            return !0;
          }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
          const h = t.join(" | ");
          h !== this._attribHTML && (this._attribHTML = h, t.length ? (this._innerContainer.innerHTML = h, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Pl {
        constructor() {
          i.aP(["_updateLogo", "_updateCompact"], this);
        }
        onAdd(t) {
          this._map = t, this._container = we("div", "mapboxgl-ctrl");
          const s = we("a", "mapboxgl-ctrl-logo");
          return s.target = "_blank", s.rel = "noopener nofollow", s.href = "https://www.mapbox.com/", s.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), s.setAttribute("rel", "noopener nofollow"), this._container.appendChild(s), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(t) {
          t && t.sourceDataType !== "metadata" || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return !0;
          const t = this._map.style._sourceCaches;
          if (Object.entries(t).length === 0)
            return !0;
          for (const s in t) {
            const h = t[s].getSource();
            if (h.hasOwnProperty("mapbox_logo") && !h.mapbox_logo)
              return !1;
          }
          return !0;
        }
        _updateCompact() {
          const t = this._container.children;
          if (t.length) {
            const s = t[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? s.classList.add("mapboxgl-compact") : s.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Su {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(t) {
          const s = ++this._id;
          return this._queue.push({ callback: t, id: s, cancelled: !1 }), s;
        }
        remove(t) {
          const s = this._currentlyRunning, h = s ? this._queue.concat(s) : this._queue;
          for (const m of h)
            if (m.id === t)
              return void (m.cancelled = !0);
        }
        run(t = 0) {
          const s = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const h of s)
            if (!h.cancelled && (h.callback(t), this._cleared))
              break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      class uo {
        constructor(t) {
          this.jumpTo(t);
        }
        getValue(t) {
          if (t <= this._startTime)
            return this._start;
          if (t >= this._endTime)
            return this._end;
          const s = i.cB((t - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - s) + this._end * s;
        }
        isEasing(t) {
          return t >= this._startTime && t <= this._endTime;
        }
        jumpTo(t) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = t, this._end = t;
        }
        easeTo(t, s, h) {
          this._start = this.getValue(s), this._end = t, this._startTime = s, this._endTime = s + h;
        }
      }
      const fo = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use ⌘ + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" }, fc = ["mouseenter", "mouseover", "mouseleave", "mouseout"];
      class Ja extends i.z {
        constructor(t, s, h, m) {
          const { point: g, lngLat: T, originalEvent: z, target: R } = t;
          super(t.type, { point: g, lngLat: T, originalEvent: z, target: R }), this.preventDefault = () => {
            t.preventDefault();
          }, this.id = s, this.interaction = h, this.feature = m;
        }
      }
      class pc {
        constructor(t) {
          this.map = t, this.interactionsByType = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.delegatedHandlers = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this);
        }
        add(t, s) {
          if (this.typeById.has(t))
            throw new Error(`Interaction id "${t}" already exists.`);
          const { type: h, filter: m } = s;
          m && this.filters.set(t, i.aZ(m));
          const g = this.interactionsByType.get(h) || /* @__PURE__ */ new Map();
          if (g.size === 0) {
            if (fc.includes(h)) {
              const { mousemove: T, mouseout: z } = this._createDelegatedHandlers(t, s);
              this.map.on("mousemove", T), this.map.on("mouseout", z), this.delegatedHandlers.set(t, { mousemove: T, mouseout: z });
            } else
              this.map.on(h, this.handleType);
            this.interactionsByType.set(h, g);
          }
          g.set(t, s), this.typeById.set(t, h);
        }
        get(t) {
          const s = this.typeById.get(t);
          if (!s)
            return;
          const h = this.interactionsByType.get(s);
          return h ? h.get(t) : void 0;
        }
        remove(t) {
          const s = this.typeById.get(t);
          if (!s)
            return;
          this.typeById.delete(t), this.filters.delete(t);
          const h = this.interactionsByType.get(s);
          if (h) {
            if (h.delete(t), this.delegatedHandlers.has(t)) {
              const { mousemove: m, mouseout: g } = this.delegatedHandlers.get(t);
              this.map.off("mousemove", m), this.map.off("mouseout", g), this.delegatedHandlers.delete(t);
            }
            h.size === 0 && this.map.off(s, this.handleType);
          }
        }
        queryTargets(t, s) {
          const h = [];
          for (const [m, g] of s)
            g.target && h.push({ targetId: m, target: g.target, filter: this.filters.get(m) });
          return this.map.style.queryRenderedTargets(t, h, this.map.transform);
        }
        handleType(t, s) {
          const h = this.interactionsByType.get(t.type), m = Array.from(h).reverse();
          s = s || this.queryTargets(t.point, m);
          let g = !1;
          for (const T of s) {
            for (const [z, R] of m) {
              if (!R.target)
                continue;
              const F = T.variants ? T.variants[z] : null;
              if (F) {
                for (const N of F) {
                  const j = new i.cw(T, N);
                  if (R.handler(new Ja(t, z, R, j)) !== !1) {
                    g = !0;
                    break;
                  }
                }
                if (g)
                  break;
              }
            }
            if (g)
              break;
          }
          if (!g)
            for (const [T, z] of m) {
              const { handler: R, target: F } = z;
              if (!F && R(new Ja(t, T, z, null)) !== !1)
                break;
            }
        }
        _createDelegatedHandlers(t, s) {
          switch (s.type) {
            case "mouseenter":
            case "mouseover": {
              let h = !1, m = /* @__PURE__ */ new Set();
              return { mousemove: (g) => {
                const T = this.queryTargets(g.point, [[t, s]]), z = /* @__PURE__ */ new Set();
                if (!T.length)
                  return h = !1, void m.clear();
                const R = [];
                for (const F of T)
                  m.has(F.id) || (z.add(F.id), R.push(F));
                h && !R.length || (h = !0, m = z, g.type = s.type, this.handleType(g, R));
              }, mouseout: () => {
                h = !1, m.clear();
              } };
            }
            case "mouseleave":
            case "mouseout": {
              let h = [];
              return { mousemove: (m) => {
                const g = this.queryTargets(m.point, [[t, s]]);
                if (!g.length)
                  return m.type = s.type, this.handleType(m, h), void (h = g);
                const T = [], z = new Set(g.map((R) => R.id));
                for (const R of h)
                  z.has(R.id) || T.push(R);
                T.length && (m.type = s.type, this.handleType(m, T)), h = g;
              }, mouseout: (m) => {
                h.length && (m.type = s.type, this.handleType(m, h), h = []);
              } };
            }
          }
        }
      }
      function kd(c, t) {
        if (Array.isArray(c) && Array.isArray(t)) {
          const s = new Set(c), h = new Set(t);
          return s.size === h.size && c.every((m) => h.has(m));
        }
        return i.bn(c, t);
      }
      const Ui = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1, precompilePrograms: !0, scaleFactor: 1, spriteFormat: "auto" }, Qa = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class a_ {
        constructor(t, s, h = !1) {
          this._clickTolerance = 10, this.element = s, this.mouseRotate = new vu({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance }), this.map = t, h && (this.mousePitch = new hh({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), i.aP(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), s.addEventListener("mousedown", this.mousedown), s.addEventListener("touchstart", this.touchstart, { passive: !1 }), s.addEventListener("touchmove", this.touchmove), s.addEventListener("touchend", this.touchend), s.addEventListener("touchcancel", this.reset);
        }
        down(t, s) {
          this.mouseRotate.mousedown(t, s), this.mousePitch && this.mousePitch.mousedown(t, s), ut();
        }
        move(t, s) {
          const h = this.map, m = this.mouseRotate.mousemoveWindow(t, s), g = m && m.bearingDelta;
          if (g && h.setBearing(h.getBearing() + g), this.mousePitch) {
            const T = this.mousePitch.mousemoveWindow(t, s), z = T && T.pitchDelta;
            z && h.setPitch(h.getPitch() + z);
          }
        }
        off() {
          const t = this.element;
          t.removeEventListener("mousedown", this.mousedown), t.removeEventListener("touchstart", this.touchstart, { passive: !1 }), t.removeEventListener("touchmove", this.touchmove), t.removeEventListener("touchend", this.touchend), t.removeEventListener("touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          bt(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
        }
        mousedown(t) {
          this.down(i.l({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), Gt(this.element, t)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
        }
        mousemove(t) {
          this.move(t, Gt(this.element, t));
        }
        mouseup(t) {
          this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();
        }
        touchstart(t) {
          t.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = ui(this.element, t.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: !0, preventDefault: () => t.preventDefault() }, this._startPos));
        }
        touchmove(t) {
          t.targetTouches.length !== 1 ? this.reset() : (this._lastPos = ui(this.element, t.targetTouches)[0], this.move({ preventDefault: () => t.preventDefault() }, this._lastPos));
        }
        touchend(t) {
          t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      function pp(c, t, s) {
        if (c = new i.bO(c.lng, c.lat), t) {
          const h = new i.bO(c.lng - 360, c.lat), m = new i.bO(c.lng + 360, c.lat), g = 360 * Math.ceil(Math.abs(c.lng - s.center.lng) / 360), T = s.locationPoint(c).distSqr(t), z = t.x < 0 || t.y < 0 || t.x > s.width || t.y > s.height;
          s.locationPoint(h).distSqr(t) < T && (z || Math.abs(h.lng - s.center.lng) < g) ? c = h : s.locationPoint(m).distSqr(t) < T && (z || Math.abs(m.lng - s.center.lng) < g) && (c = m);
        }
        for (; Math.abs(c.lng - s.center.lng) > 180; ) {
          const h = s.locationPoint(c);
          if (h.x >= 0 && h.y >= 0 && h.x <= s.width && h.y <= s.height)
            break;
          c.lng > s.center.lng ? c.lng -= 360 : c.lng += 360;
        }
        return c;
      }
      const ph = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class ea extends i.E {
        constructor(t, s) {
          if (super(), (t instanceof HTMLElement || s) && (t = i.l({ element: t }, s)), i.aP(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t && t.anchor || "center", this._color = t && t.color || "#3FB1CE", this._scale = t && t.scale || 1, this._draggable = t && t.draggable || !1, this._clickTolerance = t && t.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t && t.rotation || 0, this._rotationAlignment = t && t.rotationAlignment || "auto", this._pitchAlignment = t && t.pitchAlignment && t.pitchAlignment || "auto", this._updateMoving = () => this._update(!0), this._occludedOpacity = t && t.occludedOpacity || 0.2, t && t.element)
            this._element = t.element, this._offset = i.P.convert(t && t.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = we("div");
            const g = 41, T = 27, z = qe("svg", { display: "block", height: g * this._scale + "px", width: T * this._scale + "px", viewBox: `0 0 ${T} ${g}` }, this._element), R = qe("radialGradient", { id: "shadowGradient" }, qe("defs", {}, z));
            qe("stop", { offset: "10%", "stop-opacity": 0.4 }, R), qe("stop", { offset: "100%", "stop-opacity": 0.05 }, R), qe("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, z), qe("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, z), qe("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, z), qe("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, z), this._offset = i.P.convert(t && t.offset || [0, -14]);
          }
          this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (g) => {
            g.preventDefault();
          }), this._element.addEventListener("mousedown", (g) => {
            g.preventDefault();
          });
          const h = this._element.classList;
          for (const g in ph)
            h.remove(`mapboxgl-marker-anchor-${g}`);
          h.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const m = t && t.className ? t.className.trim().split(/\s+/) : [];
          h.add(...m), this._popup = null;
        }
        addTo(t) {
          return t === this._map || (this.remove(), this._map = t, t.getCanvasContainer().appendChild(this._element), t.on("move", this._updateMoving), t.on("moveend", this._update), t.on("remove", this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on("click", this._onMapClick)), this;
        }
        remove() {
          const t = this._map;
          return t && (t.off("click", this._onMapClick), t.off("move", this._updateMoving), t.off("moveend", this._update), t.off("mousedown", this._addDragHandler), t.off("touchstart", this._addDragHandler), t.off("mouseup", this._onUp), t.off("touchend", this._onUp), t.off("mousemove", this._onMove), t.off("touchmove", this._onMove), t.off("remove", this._clearFadeTimer), t._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return this._lngLat = i.bO.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t) {
            if (!("offset" in t.options)) {
              const m = Math.sqrt(Math.pow(13.5, 2) / 2);
              t.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [m, -1 * (38.1 - 13.5 + m)], "bottom-right": [-m, -1 * (38.1 - 13.5 + m)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = t, t._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
          }
          return this;
        }
        _onKeyPress(t) {
          const s = t.code, h = t.charCode || t.keyCode;
          s !== "Space" && s !== "Enter" && h !== 32 && h !== 13 || this.togglePopup();
        }
        _onMapClick(t) {
          const s = t.originalEvent.target, h = this._element;
          this._popup && (s === h || h.contains(s)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
        }
        _behindTerrain() {
          const t = this._map, s = this._pos;
          if (!t || !s)
            return !1;
          const h = t.unproject(s), m = t.getFreeCameraOptions();
          if (!m.position)
            return !1;
          const g = m.position.toLngLat();
          return g.distanceTo(h) < 0.9 * g.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t = this._map;
          if (!t)
            return;
          const s = this._pos;
          if (!s || s.x < 0 || s.x > t.transform.width || s.y < 0 || s.y > t.transform.height)
            return void this._clearFadeTimer();
          const h = t.unproject(s);
          let m;
          t._showingGlobe() && i.dH(t.transform, this._lngLat) ? m = 0 : (m = 1 - t._queryFogOpacity(h), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (m *= this._occludedOpacity)), this._element.style.opacity = `${m}`, this._element.style.pointerEvents = m > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(m), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _updateDOM() {
          const t = this._pos;
          if (!t || !this._map)
            return;
          const s = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${ph[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${s.x}px,${s.y}px)
        `;
        }
        _calculateXYTransform() {
          const t = this._pos, s = this._map, h = this.getPitchAlignment();
          if (!s || !t || h !== "map")
            return "";
          if (!s._showingGlobe()) {
            const R = s.getPitch();
            return R ? `rotateX(${R}deg)` : "";
          }
          const m = i.c4(i.dI(s.transform, this._lngLat)), g = t.sub(i.dJ(s.transform)), T = Math.abs(g.x) + Math.abs(g.y);
          if (T === 0)
            return "";
          const z = m / T;
          return `rotateX(${-g.y * z}deg) rotateY(${g.x * z}deg)`;
        }
        _calculateZTransform() {
          const t = this._pos, s = this._map;
          if (!s || !t)
            return "";
          let h = 0;
          const m = this.getRotationAlignment();
          if (m === "map")
            if (s._showingGlobe()) {
              const g = s.project(new i.bO(this._lngLat.lng, this._lngLat.lat + 1e-3)), T = s.project(new i.bO(this._lngLat.lng, this._lngLat.lat - 1e-3)).sub(g);
              h = i.c4(Math.atan2(T.y, T.x)) - 90;
            } else
              h = -s.getBearing();
          else if (m === "horizon") {
            const g = i.ac(4, 6, s.getZoom()), T = i.dJ(s.transform);
            T.y += g * s.transform.height;
            const z = t.sub(T), R = i.c4(Math.atan2(z.y, z.x));
            h = (R > 90 ? R - 270 : R + 90) * (1 - g);
          }
          return h += this._rotation, h ? `rotateZ(${h}deg)` : "";
        }
        _update(t) {
          cancelAnimationFrame(this._updateFrameId);
          const s = this._map;
          s && (s.transform.renderWorldCopies && (this._lngLat = pp(this._lngLat, this._pos, s.transform)), this._pos = s.project(this._lngLat), t === !0 ? this._updateFrameId = requestAnimationFrame(() => {
            this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
          }) : this._pos = this._pos.round(), s._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (s._showingGlobe() || s.getTerrain() || s.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
          }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return this._offset = i.P.convert(t), this._update(), this;
        }
        addClassName(t) {
          return this._element.classList.add(t), this;
        }
        removeClassName(t) {
          return this._element.classList.remove(t), this;
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        _onMove(t) {
          const s = this._map;
          if (!s)
            return;
          const h = this._pointerdownPos, m = this._positionDelta;
          if (h && m) {
            if (!this._isDragging) {
              const g = this._clickTolerance || s._clickTolerance;
              if (t.point.dist(h) < g)
                return;
              this._isDragging = !0;
            }
            this._pos = t.point.sub(m), this._lngLat = s.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new i.z("dragstart"))), this.fire(new i.z("drag"));
          }
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
          const t = this._map;
          t && (t.off("mousemove", this._onMove), t.off("touchmove", this._onMove)), this._state === "active" && this.fire(new i.z("dragend")), this._state = "inactive";
        }
        _addDragHandler(t) {
          const s = this._map, h = this._pos;
          s && h && this._element.contains(t.originalEvent.target) && (t.preventDefault(), this._positionDelta = t.point.sub(h), this._pointerdownPos = t.point, this._state = "pending", s.on("mousemove", this._onMove), s.on("touchmove", this._onMove), s.once("mouseup", this._onUp), s.once("touchend", this._onUp));
        }
        setDraggable(t) {
          this._draggable = !!t;
          const s = this._map;
          return s && (t ? (s.on("mousedown", this._addDragHandler), s.on("touchstart", this._addDragHandler)) : (s.off("mousedown", this._addDragHandler), s.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return this._rotation = t || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return this._rotationAlignment = t || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === "auto" || this._rotationAlignment === "horizon" && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return this._pitchAlignment = t || "auto", this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === "auto" ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(t) {
          return this._occludedOpacity = t || 0.2, this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const wa = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 }, fr = { maxWidth: 100, unit: "metric" }, Fr = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, Os = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px" }, mp = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Un(c = new i.P(0, 0), t = "bottom") {
        if (typeof c == "number") {
          const s = Math.round(Math.sqrt(0.5 * Math.pow(c, 2)));
          switch (t) {
            case "top":
              return new i.P(0, c);
            case "top-left":
              return new i.P(s, s);
            case "top-right":
              return new i.P(-s, s);
            case "bottom":
              return new i.P(0, -c);
            case "bottom-left":
              return new i.P(s, -s);
            case "bottom-right":
              return new i.P(-s, -s);
            case "left":
              return new i.P(c, 0);
            case "right":
              return new i.P(-c, 0);
          }
          return new i.P(0, 0);
        }
        return c instanceof i.P || Array.isArray(c) ? i.P.convert(c) : i.P.convert(c[t] || [0, 0]);
      }
      return { version: O, supported: Se.supported, setRTLTextPlugin: i.dK, getRTLTextPluginStatus: i.dL, Map: class extends dp {
        constructor(c) {
          Y.mark(Z.create);
          const t = c;
          if ((c = i.l({}, Ui, c)).minZoom != null && c.maxZoom != null && c.minZoom > c.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (c.minPitch != null && c.maxPitch != null && c.minPitch > c.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (c.minPitch != null && c.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (c.maxPitch != null && c.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (c.antialias && i.dF(window) && (c.antialias = !1, i.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new pa(c.minZoom, c.maxZoom, c.minPitch, c.maxPitch, c.renderWorldCopies), c), this._repaint = !!c.repaint, this._interactive = c.interactive, this._minTileCacheSize = c.minTileCacheSize, this._maxTileCacheSize = c.maxTileCacheSize, this._failIfMajorPerformanceCaveat = c.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = c.preserveDrawingBuffer, this._antialias = c.antialias, this._trackResize = c.trackResize, this._bearingSnap = c.bearingSnap, this._refreshExpiredTiles = c.refreshExpiredTiles, this._fadeDuration = c.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = c.crossSourceCollisions, this._collectResourceTiming = c.collectResourceTiming, this._language = this._parseLanguage(c.language), this._worldview = c.worldview, this._renderTaskQueue = new Su(), this._domRenderTaskQueue = new Su(), this._controls = [], this._markers = [], this._popups = [], this._mapId = i.aV(), this._locale = i.l({}, fo, c.locale), this._clickTolerance = c.clickTolerance, this._cooperativeGestures = c.cooperativeGestures, this._performanceMetricsCollection = c.performanceMetricsCollection, this._tessellationStep = c.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = c.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new uo(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = c.scaleFactor, this._requestManager = new hn(c.transformRequest, c.accessToken, c.testMode), this._silenceAuthErrors = !!c.testMode, this._contextCreateOptions = c.contextCreateOptions ? { ...c.contextCreateOptions } : {}, typeof c.container == "string") {
            const s = document.getElementById(c.container);
            if (!s)
              throw new Error(`Container '${c.container.toString()}' not found.`);
            this._container = s;
          } else {
            if (!(c.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = c.container;
          }
          if (this._container.childNodes.length > 0 && i.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), c.maxBounds && this.setMaxBounds(c.maxBounds), this._spriteFormat = c.spriteFormat, i.aP(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new fu()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: !0 }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: !0 }, () => {
            this._update();
          }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
            this.setScaleFactor(this._scaleFactor);
          }), this._setupPainter(), this.painter === void 0)
            throw new Error("Failed to initialize WebGL.");
          if (this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new dr(this, c), this._localFontFamily = c.localFontFamily, this._localIdeographFontFamily = c.localIdeographFontFamily, (c.style || !c.testMode) && this.setStyle(c.style || i.e.DEFAULT_STYLE, { config: c.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), c.projection && this.setProjection(c.projection), this.indoor = new _l(this), c.hash && (this._hash = new Cd(typeof c.hash == "string" && c.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
            t.center == null && t.zoom == null || (this.transform._unmodified = !1), this.jumpTo({ center: c.center, zoom: c.zoom, bearing: c.bearing, pitch: c.pitch });
            const s = c.bounds;
            s && (this.resize(), this.fitBounds(s, i.l({}, c.fitBoundsOptions, { duration: 0 })));
          }
          this.resize(), c.attributionControl && this.addControl(new fp({ customAttribution: c.customAttribution })), this._logoControl = new Pl(), this.addControl(this._logoControl, c.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
          }), this.on("data", (s) => {
            this._update(s.dataType === "style"), this.fire(new i.z(`${s.dataType}data`, s));
          }), this.on("dataloading", (s) => {
            this.fire(new i.z(`${s.dataType}dataloading`, s));
          }), this._interactions = new pc(this);
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(c, t) {
          if (t === void 0 && (t = c.getDefaultPosition ? c.getDefaultPosition() : "top-right"), !c || !c.onAdd)
            return this.fire(new i.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s = c.onAdd(this);
          this._controls.push(c);
          const h = this._controlPositions[t];
          return t.indexOf("bottom") !== -1 ? h.insertBefore(s, h.firstChild) : h.appendChild(s), this;
        }
        removeControl(c) {
          if (!c || !c.onRemove)
            return this.fire(new i.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const t = this._controls.indexOf(c);
          return t > -1 && this._controls.splice(t, 1), c.onRemove(this), this;
        }
        hasControl(c) {
          return this._controls.indexOf(c) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(c) {
          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
            return this;
          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
          const t = !this._moving;
          return t && this.fire(new i.z("movestart", c)).fire(new i.z("move", c)), this.fire(new i.z("resize", c)), t && this.fire(new i.z("moveend", c)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds() || null;
        }
        setMaxBounds(c) {
          return this.transform.setMaxBounds(i.az.convert(c)), this._update();
        }
        setMinZoom(c) {
          if ((c = c ?? -2) >= -2 && c <= this.transform.maxZoom)
            return this.transform.minZoom = c, this._update(), this.getZoom() < c ? this.setZoom(c) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(c) {
          if ((c = c ?? 22) >= this.transform.minZoom)
            return this.transform.maxZoom = c, this._update(), this.getZoom() > c ? this.setZoom(c) : this.fire(new i.z("zoomstart")).fire(new i.z("zoom")).fire(new i.z("zoomend")), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(c) {
          if ((c = c ?? 0) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (c >= 0 && c <= this.transform.maxPitch)
            return this.transform.minPitch = c, this._update(), this.getPitch() < c ? this.setPitch(c) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(c) {
          if ((c = c ?? 85) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (c >= this.transform.minPitch)
            return this.transform.maxPitch = c, this._update(), this.getPitch() > c ? this.setPitch(c) : this.fire(new i.z("pitchstart")).fire(new i.z("pitch")).fire(new i.z("pitchend")), this;
          throw new Error("maxPitch must be greater than or equal to minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getScaleFactor() {
          return this._scaleFactor;
        }
        setScaleFactor(c) {
          return this._scaleFactor = c, this.painter.scaleFactor = c, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((t) => t.type === "symbol"), this._update(!0), this;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(c) {
          return this.transform.renderWorldCopies = c, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
        }
        getLanguage() {
          return this._language;
        }
        _parseLanguage(c) {
          return c === "auto" ? navigator.language : Array.isArray(c) ? c.length === 0 ? void 0 : c.map((t) => t === "auto" ? navigator.language : t) : c;
        }
        setLanguage(c) {
          const t = this._parseLanguage(c);
          if (!this.style || t === this._language)
            return this;
          this._language = t, this.style.reloadSources();
          for (const s of this._controls)
            s._setLanguage && s._setLanguage(this._language);
          return this;
        }
        getWorldview() {
          return this._worldview;
        }
        setWorldview(c) {
          return this.style && c !== this._worldview ? (this._worldview = c, this.style.reloadSources(), this) : this;
        }
        getProjection() {
          return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
        }
        _showingGlobe() {
          return this.transform.projection.name === "globe";
        }
        setProjection(c) {
          return this._lazyInitEmptyStyle(), c ? typeof c == "string" && (c = { name: c }) : c = null, this._useExplicitProjection = !!c, this._prioritizeAndUpdateProjection(c, this.style.projection);
        }
        _updateProjectionTransition() {
          if (this.getProjection().name !== "globe")
            return;
          const c = this.transform, t = c.projection.name;
          let s;
          t === "globe" && c.zoom >= i.bY ? (c.setMercatorFromTransition(), s = !0) : t === "mercator" && c.zoom < i.bY && (c.setProjection({ name: "globe" }), s = !0), s && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
        }
        _prioritizeAndUpdateProjection(c, t) {
          return this._updateProjection(c || t || { name: "mercator" });
        }
        _updateProjection(c) {
          let t;
          return t = c.name === "globe" && this.transform.zoom >= i.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(c), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
        }
        project(c) {
          return this.transform.locationPoint3D(i.bO.convert(c));
        }
        unproject(c) {
          return this.transform.pointLocation3D(i.P.convert(c));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving() || !1;
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming() || !1;
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating() || !1;
        }
        _isDragging() {
          return this.handlers && this.handlers._isDragging() || !1;
        }
        _createDelegatedListener(c, t, s) {
          const h = (m) => {
            let g = [];
            if (Array.isArray(t)) {
              const T = t.filter((z) => this.getLayer(z));
              g = T.length ? this.queryRenderedFeatures(m, { layers: T }) : [];
            } else
              g = this.queryRenderedFeatures(m, { target: t });
            return g;
          };
          if (c === "mouseenter" || c === "mouseover") {
            let m = !1;
            return { listener: s, targets: t, delegates: { mousemove: (T) => {
              const z = h(T.point);
              z.length ? m || (m = !0, s.call(this, new Or(c, this, T.originalEvent, { features: z }))) : m = !1;
            }, mouseout: () => {
              m = !1;
            } } };
          }
          if (c === "mouseleave" || c === "mouseout") {
            let m = !1;
            return { listener: s, targets: t, delegates: { mousemove: (z) => {
              h(z.point).length ? m = !0 : m && (m = !1, s.call(this, new Or(c, this, z.originalEvent)));
            }, mouseout: (z) => {
              m && (m = !1, s.call(this, new Or(c, this, z.originalEvent)));
            } } };
          }
          {
            const m = (g) => {
              const T = h(g.point);
              T.length && (g.features = T, s.call(this, g), delete g.features);
            };
            return { listener: s, targets: t, delegates: { [c]: m } };
          }
        }
        on(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.on(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._createDelegatedListener(c, t, s);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[c] = this._delegatedListeners[c] || [], this._delegatedListeners[c].push(h);
          for (const m in h.delegates)
            this.on(m, h.delegates[m]);
          return this;
        }
        once(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.once(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._createDelegatedListener(c, t, s);
          for (const m in h.delegates)
            this.once(m, h.delegates[m]);
          return this;
        }
        off(c, t, s) {
          if (typeof t == "function" || s === void 0)
            return super.off(c, t);
          if (typeof t == "string" && (t = [t]), !this._areTargetsValid(t))
            return this;
          const h = this._delegatedListeners ? this._delegatedListeners[c] : void 0;
          return h && ((m) => {
            for (let g = 0; g < m.length; g++) {
              const T = m[g];
              if (T.listener === s && kd(T.targets, t)) {
                for (const z in T.delegates)
                  this.off(z, T.delegates[z]);
                return m.splice(g, 1), this;
              }
            }
          })(h), this;
        }
        queryRenderedFeatures(c, t) {
          if (!this.style)
            return [];
          if (c === void 0 || c instanceof i.P || Array.isArray(c) || t !== void 0 || (t = c, c = void 0), c = c || [[0, 0], [this.transform.width, this.transform.height]], !t) {
            const g = this.style.queryRenderedFeatures(c, void 0, this.transform), T = this.style.queryRenderedFeatureset(c, void 0, this.transform);
            return g.concat(T);
          }
          let s = !0;
          if (t.target && (s = this._isTargetValid(t.target), s && !t.layers))
            return this.style.queryRenderedFeatureset(c, t, this.transform);
          let h = !0;
          if (t.layers && Array.isArray(t.layers)) {
            for (const g of t.layers)
              if (!this._isValidId(g)) {
                h = !1;
                break;
              }
            if (h && !t.target)
              return this.style.queryRenderedFeatures(c, t, this.transform);
          }
          let m = [];
          return h && (m = m.concat(this.style.queryRenderedFeatures(c, t, this.transform))), s && (m = m.concat(this.style.queryRenderedFeatureset(c, t, this.transform))), m;
        }
        querySourceFeatures(c, t) {
          return !c || typeof c == "string" && !this._isValidId(c) ? [] : this.style.querySourceFeatures(c, t);
        }
        isPointOnSurface(c) {
          const { name: t } = this.transform.projection;
          return t !== "globe" && t !== "mercator" && i.w(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(i.P.convert(c));
        }
        addInteraction(c, t) {
          return this._interactions.add(c, t), this;
        }
        removeInteraction(c) {
          return this._interactions.remove(c), this;
        }
        setStyle(c, t) {
          return t = i.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t), this.style && c && t.diff !== !1 && t.localFontFamily === this._localFontFamily && t.localIdeographFontFamily === this._localIdeographFontFamily && !t.config ? (this.style._diffStyle(c, (s, h) => {
            s ? (i.w(`Unable to perform style diff: ${String(s.message || s.error || s)}. Rebuilding the style from scratch.`), this._updateStyle(c, t)) : h && this._update(!0);
          }, () => {
            this._postStyleLoadEvent();
          }), this) : (this._localIdeographFontFamily = t.localIdeographFontFamily, this._localFontFamily = t.localFontFamily, this._updateStyle(c, t));
        }
        _getUIString(c) {
          const t = this._locale[c];
          if (t == null)
            throw new Error(`Missing UI string '${c}'`);
          return t;
        }
        _updateStyle(c, t) {
          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), c) {
            const s = i.l({}, t);
            t && t.config && (s.initialConfig = t.config, delete s.config), this.style = new hr(this, s).load(c), this.style.setEventedParent(this, { style: this.style });
          }
          return this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new hr(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : (i.w("There is no style added to the map."), !1);
        }
        _isValidId(c) {
          return c == null ? (this.fire(new i.y(new Error("IDs can't be empty."))), !1) : !i.cr(c) || (this.fire(new i.y(new Error(`IDs can't contain special symbols: "${c}".`))), !1);
        }
        _isTargetValid(c) {
          return "featuresetId" in c ? this._isValidId("importId" in c ? c.importId : c.featuresetId) : "layerId" in c && this._isValidId(c.layerId);
        }
        _areTargetsValid(c) {
          if (Array.isArray(c)) {
            for (const t of c)
              if (!this._isValidId(t))
                return !1;
            return !0;
          }
          return this._isTargetValid(c);
        }
        addSource(c, t) {
          return this._isValidId(c) ? (this._lazyInitEmptyStyle(), this.style.addSource(c, t), this._update(!0)) : this;
        }
        isSourceLoaded(c) {
          return !!this._isValidId(c) && !!this.style && this.style._isSourceCacheLoaded(c);
        }
        areTilesLoaded() {
          return this.style.areTilesLoaded();
        }
        addSourceType(c, t, s) {
          this._lazyInitEmptyStyle(), this.style.addSourceType(c, t, s);
        }
        removeSource(c) {
          return this._isValidId(c) ? (this.style.removeSource(c), this._updateTerrain(), this._update(!0)) : this;
        }
        getSource(c) {
          return this._isValidId(c) ? this.style.getOwnSource(c) : null;
        }
        addImage(c, t, { pixelRatio: s = 1, sdf: h = !1, stretchX: m, stretchY: g, content: T } = {}) {
          if (this._lazyInitEmptyStyle(), t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap) {
            const { width: z, height: R, data: F } = i.q.getImageData(t);
            this.style.addImage(c, { data: new i.r({ width: z, height: R }, F), pixelRatio: s, stretchX: m, stretchY: g, content: T, sdf: h, version: 0, usvg: !1 });
          } else if (t.width === void 0 || t.height === void 0)
            this.fire(new i.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          else {
            const { width: z, height: R } = t, F = t;
            this.style.addImage(c, { data: new i.r({ width: z, height: R }, new Uint8Array(F.data)), pixelRatio: s, stretchX: m, stretchY: g, content: T, sdf: h, usvg: !1, version: 0, userImage: F }), F.onAdd && F.onAdd(this, c);
          }
        }
        updateImage(c, t) {
          this._lazyInitEmptyStyle();
          const s = this.style.getImage(c);
          if (!s)
            return void this.fire(new i.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const h = t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap ? i.q.getImageData(t) : t, { width: m, height: g, data: T } = h;
          if (m === void 0 || g === void 0)
            return void this.fire(new i.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (m !== (s.usvg ? s.icon.usvg_tree.width : s.data.width) || g !== (s.usvg ? s.icon.usvg_tree.height : s.data.height))
            return void this.fire(new i.y(new Error(`The width and height of the updated image (${m}, ${g})
                must be that same as the previous version of the image
                (${s.data.width}, ${s.data.height})`)));
          const z = !(t instanceof HTMLImageElement || ImageBitmap && t instanceof ImageBitmap);
          let R = !1;
          s.usvg ? (s.data = new i.r({ width: m, height: g }, new Uint8Array(T)), s.usvg = !1, s.icon = void 0, R = !0) : s.data.replace(T, z), this.style.updateImage(c, s, R);
        }
        hasImage(c) {
          return c ? !!this.style && !!this.style.getImage(c) : (this.fire(new i.y(new Error("Missing required image id"))), !1);
        }
        removeImage(c) {
          this.style.removeImage(c);
        }
        loadImage(c, t) {
          i.o(this._requestManager.transformRequest(c, i.R.Image), (s, h) => {
            t(s, h instanceof HTMLImageElement ? i.q.getImageData(h) : h);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addModel(c, t) {
          this._lazyInitEmptyStyle(), this.style.addModel(c, t);
        }
        hasModel(c) {
          return c ? this.style.hasModel(c) : (this.fire(new i.y(new Error("Missing required model id"))), !1);
        }
        removeModel(c) {
          this.style.removeModel(c);
        }
        listModels() {
          return this.style.listModels();
        }
        addLayer(c, t) {
          return this._isValidId(c.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(c, t), this._update(!0)) : this;
        }
        getSlot(c) {
          const t = this.getLayer(c);
          return t && t.slot || null;
        }
        setSlot(c, t) {
          return this.style.setSlot(c, t), this.style.mergeLayers(), this._update(!0);
        }
        addImport(c, t) {
          return this.style.addImport(c, t), this;
        }
        updateImport(c, t) {
          return typeof t != "string" && t.id !== c ? (this.removeImport(c), this.addImport(t)) : (this.style.updateImport(c, t), this._update(!0));
        }
        removeImport(c) {
          return this.style.removeImport(c), this;
        }
        moveImport(c, t) {
          return this.style.moveImport(c, t), this._update(!0);
        }
        moveLayer(c, t) {
          return this._isValidId(c) ? (this.style.moveLayer(c, t), this._update(!0)) : this;
        }
        removeLayer(c) {
          return this._isValidId(c) ? (this.style.removeLayer(c), this._update(!0)) : this;
        }
        getLayer(c) {
          if (!this._isValidId(c))
            return null;
          const t = this.style.getOwnLayer(c);
          return t ? t.type === "custom" ? t.implementation : t.serialize() : void 0;
        }
        getSlots() {
          return this.style.getSlots();
        }
        setLayerZoomRange(c, t, s) {
          return this._isValidId(c) ? (this.style.setLayerZoomRange(c, t, s), this._update(!0)) : this;
        }
        setFilter(c, t, s = {}) {
          return this._isValidId(c) ? (this.style.setFilter(c, t, s), this._update(!0)) : this;
        }
        getFilter(c) {
          return this._isValidId(c) ? this.style.getFilter(c) : null;
        }
        setPaintProperty(c, t, s, h = {}) {
          return this._isValidId(c) ? (this.style.setPaintProperty(c, t, s, h), this._update(!0)) : this;
        }
        getPaintProperty(c, t) {
          return this._isValidId(c) ? this.style.getPaintProperty(c, t) : null;
        }
        setLayoutProperty(c, t, s, h = {}) {
          return this._isValidId(c) ? (this.style.setLayoutProperty(c, t, s, h), this._update(!0)) : this;
        }
        getLayoutProperty(c, t) {
          return this._isValidId(c) ? this.style.getLayoutProperty(c, t) : null;
        }
        getSchema(c) {
          return this.style.getSchema(c);
        }
        setSchema(c, t) {
          return this.style.setSchema(c, t), this._update(!0);
        }
        getConfig(c) {
          return this.style.getConfig(c);
        }
        setConfig(c, t) {
          return this.style.setConfig(c, t), this._update(!0);
        }
        getConfigProperty(c, t) {
          return this.style.getConfigProperty(c, t);
        }
        setConfigProperty(c, t, s) {
          return this.style.setConfigProperty(c, t, s), this._update(!0);
        }
        getFeaturesetDescriptors(c) {
          return this.style.getFeaturesetDescriptors(c);
        }
        setLights(c) {
          if (this._lazyInitEmptyStyle(), c && c.length === 1 && c[0].type === "flat") {
            const t = c[0];
            t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, "flat");
          } else
            this.style.setLights(c), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
          return this._update(!0);
        }
        getLights() {
          const c = this.style.getLights() || [];
          return c.length === 0 && c.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), c;
        }
        setLight(c, t = {}) {
          return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: c }]);
        }
        getLight() {
          return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
        }
        setTerrain(c) {
          return this._lazyInitEmptyStyle(), !c && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(c), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(c) {
          return this._lazyInitEmptyStyle(), this.style.setFog(c), this._update(!0);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        setSnow(c) {
          return this._lazyInitEmptyStyle(), this.style.setSnow(c), this._update(!0);
        }
        getSnow() {
          return this.style ? this.style.getSnow() : null;
        }
        setRain(c) {
          return this._lazyInitEmptyStyle(), this.style.setRain(c), this._update(!0);
        }
        getRain() {
          return this.style ? this.style.getRain() : null;
        }
        setColorTheme(c) {
          return this._lazyInitEmptyStyle(), this.style.setColorTheme(c), this._update(!0);
        }
        setImportColorTheme(c, t) {
          return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(c, t), this._update(!0);
        }
        setCamera(c) {
          return this.style.setCamera(c), this._triggerCameraUpdate(c);
        }
        _triggerCameraUpdate(c) {
          return this._update(this.transform.setOrthographicProjectionAtLowPitch(c["camera-projection"] === "orthographic"));
        }
        getCamera() {
          return this.style.camera;
        }
        _queryFogOpacity(c) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(i.bO.convert(c), this.transform) : 0;
        }
        setFeatureState(c, t) {
          return c.source && !this._isValidId(c.source) ? this : (this.style.setFeatureState(c, t), this._update());
        }
        removeFeatureState(c, t) {
          return c.source && !this._isValidId(c.source) ? this : (this.style.removeFeatureState(c, t), this._update());
        }
        getFeatureState(c) {
          return c.source && !this._isValidId(c.source) ? null : this.style.getFeatureState(c);
        }
        _updateContainerDimensions() {
          if (!this._container)
            return;
          const c = this._container.getBoundingClientRect().width || 400, t = this._container.getBoundingClientRect().height || 300;
          let s, h, m, g = this._container;
          for (; g && (!h || !m); ) {
            const T = window.getComputedStyle(g).transform;
            T && T !== "none" && (s = T.match(/matrix.*\((.+)\)/)[1].split(", "), s[0] && s[0] !== "0" && s[0] !== "1" && (h = s[0]), s[3] && s[3] !== "0" && s[3] !== "1" && (m = s[3])), g = g.parentElement;
          }
          this._containerWidth = h ? Math.abs(c / h) : c, this._containerHeight = m ? Math.abs(t / m) : t;
        }
        _detectMissingCSS() {
          window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") !== "rgb(250, 128, 114)" && i.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const c = this._container;
          c.classList.add("mapboxgl-map"), (this._missingCSSCanary = we("div", "mapboxgl-canary", c)).style.visibility = "hidden", this._detectMissingCSS();
          const t = this._canvasContainer = we("div", "mapboxgl-canvas-container", c);
          this._canvas = we("canvas", "mapboxgl-canvas", t), this._interactive && (t.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
          const s = this._controlContainer = we("div", "mapboxgl-control-container", c), h = this._controlPositions = {};
          ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((m) => {
            h[m] = we("div", `mapboxgl-ctrl-${m}`, s);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(c, t) {
          const s = i.q.devicePixelRatio || 1;
          this._canvas.width = s * Math.ceil(c), this._canvas.height = s * Math.ceil(t), this._canvas.style.width = `${c}px`, this._canvas.style.height = `${t}px`;
        }
        _addMarker(c) {
          this._markers.push(c);
        }
        _removeMarker(c) {
          const t = this._markers.indexOf(c);
          t !== -1 && this._markers.splice(t, 1);
        }
        _addPopup(c) {
          this._popups.push(c);
        }
        _removePopup(c) {
          const t = this._popups.indexOf(c);
          t !== -1 && this._popups.splice(t, 1);
        }
        _setupPainter() {
          const c = i.l({}, Se.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }), t = this._canvas.getContext("webgl2", c);
          t ? (Us(t, !0), this.painter = new Pd(t, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (s) => {
            s.dataType === "source" && this.painter.setTileLoadedFlag(!0);
          }), i.m.testSupport(t)) : this.fire(new i.y(new Error("Failed to initialize WebGL")));
        }
        _contextLost(c) {
          c.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new i.z("webglcontextlost", { originalEvent: c }));
        }
        _contextRestored(c) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new i.z("webglcontextrestored", { originalEvent: c }));
        }
        _onMapScroll(c) {
          if (c.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
        }
        idle() {
          return !this.isMoving() && this.loaded();
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        frameReady() {
          return this.loaded() && !this._placementDirty;
        }
        _update(c) {
          return this.style ? (this._styleDirty = this._styleDirty || c, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(c) {
          return this._update(), this._renderTaskQueue.add(c);
        }
        _cancelRenderFrame(c) {
          this._renderTaskQueue.remove(c);
        }
        _requestDomTask(c) {
          !this.loaded() || this.loaded() && !this.isMoving() ? c() : this._domRenderTaskQueue.add(c);
        }
        _render(c) {
          let t;
          this.fire(new i.z("renderstart")), ++this._frameId;
          const s = this.painter.context.extTimerQuery, h = i.q.now(), m = this.painter.context.gl;
          if (this.listens("gpu-timing-frame") && (t = m.createQuery(), m.beginQuery(s.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(c), this._domRenderTaskQueue.run(c), this._removed)
            return;
          this._updateProjectionTransition();
          const g = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const F = this.transform.zoom, N = this.transform.pitch, j = i.q.now(), G = new i.a8(F, { now: j, fadeDuration: g, pitch: N, transition: this.style.transition });
            this.style.update(G);
          }
          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
          let T = !1;
          this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), T = this._updateAverageElevation(h), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : T = this._updateAverageElevation(h);
          const z = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, g, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
          if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), z && (this._placementDirty = z.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: g, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new i.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, Y.mark(Z.load), this.fire(new i.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t) {
            const F = i.q.now() - h;
            m.endQuery(s.TIME_ELAPSED_EXT), setTimeout(() => {
              const N = m.getQueryParameter(t, m.QUERY_RESULT) / 1e6;
              m.deleteQuery(t), this.fire(new i.z("gpu-timing-frame", { cpuTime: F, gpuTime: N }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const F = this.painter.collectGpuTimers();
            setTimeout(() => {
              const N = this.painter.queryGpuTimers(F);
              this.fire(new i.z("gpu-timing-layer", { layerTimes: N }));
            }, 50);
          }
          if (this.listens("gpu-timing-deferred-render")) {
            const F = this.painter.collectDeferredRenderGpuQueries();
            setTimeout(() => {
              const N = this.painter.queryGpuTimeDeferredRender(F);
              this.fire(new i.z("gpu-timing-deferred-render", { gpuTime: N }));
            }, 50);
          }
          const R = this._sourcesDirty || this._styleDirty || this._placementDirty || T;
          if (R || this._repaint)
            this.triggerRepaint();
          else {
            const F = this.idle();
            if (F && (T = this._updateAverageElevation(h, !0)), T)
              this.triggerRepaint();
            else if (this._triggerFrame(!1), F && (this.fire(new i.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
              const N = this._calculateSpeedIndex();
              this.fire(new i.z("speedindexcompleted", { speedIndex: N })), this.speedIndexTiming = !1;
            }
          }
          !this._loaded || this._fullyLoaded || R || (this._fullyLoaded = !0, Y.mark(Z.fullLoad), this._performanceMetricsCollection && xs(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
        }
        _forceMarkerAndPopupUpdate(c) {
          for (const t of this._markers)
            c && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
          for (const t of this._popups)
            !c || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
        }
        _updateAverageElevation(c, t = !1) {
          const s = (m) => (this.transform.averageElevation = m, this._update(!1), !0);
          if (!this.painter.averageElevationNeedsEasing())
            return this.transform.averageElevation !== 0 && s(0);
          const h = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
          if (h || (t || c - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(c)) {
            const m = this.transform.averageElevation;
            let g = this.transform.sampleAverageElevation();
            this.transform.elevation != null && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(g) ? g = 0 : this._averageElevationLastSampledAt = c;
            const T = Math.abs(m - g);
            if (T > 1) {
              if (this._isInitialLoad || h)
                return this._averageElevation.jumpTo(g), s(g);
              this._averageElevation.easeTo(g, c, 300);
            } else if (T > 1e-4)
              return this._averageElevation.jumpTo(g), s(g);
          }
          return !!this._averageElevation.isEasing(c) && s(this._averageElevation.getValue(c));
        }
        _authenticate() {
          De(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (c) => {
            if (c && (c.message === An || c.status === 401)) {
              const t = this.painter.context.gl;
              Us(t, !1), this._logoControl instanceof Pl && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new i.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), ln(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _postStyleLoadEvent() {
          this.style.globalId && xi(this._requestManager._customAccessToken, { map: this, skuToken: this._requestManager._skuToken, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
        }
        _updateTerrain() {
          const c = this._isDragging();
          this.painter.updateTerrain(this.style, c);
        }
        _calculateSpeedIndex() {
          const c = this.painter.canvasCopy(), t = this.painter.getCanvasCopiesAndTimestamps();
          t.timeStamps.push(performance.now());
          const s = this.painter.context.gl, h = s.createFramebuffer();
          function m(g) {
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, g, 0);
            const T = new Uint8Array(s.drawingBufferWidth * s.drawingBufferHeight * 4);
            return s.readPixels(0, 0, s.drawingBufferWidth, s.drawingBufferHeight, s.RGBA, s.UNSIGNED_BYTE, T), T;
          }
          return s.bindFramebuffer(s.FRAMEBUFFER, h), this._canvasPixelComparison(m(c), t.canvasCopies.map(m), t.timeStamps);
        }
        _canvasPixelComparison(c, t, s) {
          let h = s[1] - s[0];
          const m = c.length / 4;
          for (let g = 0; g < t.length; g++) {
            const T = t[g];
            let z = 0;
            for (let R = 0; R < T.length; R += 4)
              T[R] === c[R] && T[R + 1] === c[R + 1] && T[R + 2] === c[R + 2] && T[R + 3] === c[R + 3] && (z += 1);
            h += (s[g + 2] - s[g + 1]) * (1 - z / m);
          }
          return h;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const t of this._controls)
            t.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
          const c = this.painter.context.gl.getExtension("WEBGL_lose_context");
          c && c.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), Vs.delete(this.painter.context.gl), Is.remove(), qt.remove(), this._removed = !0, this.fire(new i.z("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(!0);
        }
        _triggerFrame(c) {
          this._renderNextFrame = this._renderNextFrame || c, this.style && !this._frame && (this._frame = i.q.frame((t) => {
            const s = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, s && this._render(t);
          }));
        }
        _preloadTiles(c) {
          const t = this.style ? this.style.getSourceCaches() : [];
          return i.bl(t, (s, h) => s._preloadTiles(c, h), () => {
            this.triggerRepaint();
          }), this;
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(c) {
          this._trackResize && this.resize({ originalEvent: c })._update();
        }
        _onVisibilityChange() {
          document.visibilityState === "hidden" && this._visibilityHidden++;
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(c) {
          this._showTileBoundaries !== c && (this._showTileBoundaries = c, this._tp.refreshUI(), this._update());
        }
        get showParseStatus() {
          return !!this._showParseStatus;
        }
        set showParseStatus(c) {
          this._showParseStatus !== c && (this._showParseStatus = c, this._tp.refreshUI(), this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(c) {
          this._showTerrainWireframe !== c && (this._showTerrainWireframe = c, this._tp.refreshUI(), this._update());
        }
        get showLayers2DWireframe() {
          return !!this._showLayers2DWireframe;
        }
        set showLayers2DWireframe(c) {
          this._showLayers2DWireframe !== c && (this._showLayers2DWireframe = c, this._tp.refreshUI(), this._update());
        }
        get showLayers3DWireframe() {
          return !!this._showLayers3DWireframe;
        }
        set showLayers3DWireframe(c) {
          this._showLayers3DWireframe !== c && (this._showLayers3DWireframe = c, this._tp.refreshUI(), this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(c) {
          this._speedIndexTiming !== c && (this._speedIndexTiming = c, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(c) {
          this._showPadding !== c && (this._showPadding = c, this._tp.refreshUI(), this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(c) {
          this._showCollisionBoxes !== c && (this._showCollisionBoxes = c, this._tp.refreshUI(), c ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(c) {
          this._showOverdrawInspector !== c && (this._showOverdrawInspector = c, this._tp.refreshUI(), this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(c) {
          this._repaint !== c && (this._repaint = c, this._tp.refreshUI(), this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(c) {
          this._vertices = c, this._update();
        }
        get showTileAABBs() {
          return !!this._showTileAABBs;
        }
        set showTileAABBs(c) {
          this._showTileAABBs !== c && (this._showTileAABBs = c, this._tp.refreshUI(), c && this._update());
        }
        _setCacheLimits(c, t) {
          i.dG(c, t);
        }
        get version() {
          return O;
        }
      }, NavigationControl: class {
        constructor(c = {}) {
          this.options = i.l({}, Qa, c), this._container = we("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this.options.showZoom && (i.aP(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t) => {
            this._map && this._map.zoomIn({}, { originalEvent: t });
          }), we("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t) => {
            this._map && this._map.zoomOut({}, { originalEvent: t });
          }), we("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (i.aP(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (t) => {
            const s = this._map;
            s && (this.options.visualizePitch ? s.resetNorthPitch({}, { originalEvent: t }) : s.resetNorth({}, { originalEvent: t }));
          }), this._compassIcon = we("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        _updateZoomButtons() {
          const c = this._map;
          if (!c)
            return;
          const t = c.getZoom(), s = t === c.getMaxZoom(), h = t === c.getMinZoom();
          this._zoomInButton.disabled = s, this._zoomOutButton.disabled = h, this._zoomInButton.setAttribute("aria-disabled", s.toString()), this._zoomOutButton.setAttribute("aria-disabled", h.toString());
        }
        _rotateCompassArrow() {
          const c = this._map;
          if (!c)
            return;
          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(c.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${c.transform.pitch}deg) rotateZ(${c.transform.angle * (180 / Math.PI)}deg)` : `rotate(${c.transform.angle * (180 / Math.PI)}deg)`;
          c._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = t);
          });
        }
        onAdd(c) {
          return this._map = c, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), c.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && c.on("pitch", this._rotateCompassArrow), c.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new a_(c, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          const c = this._map;
          c && (this._container.remove(), this.options.showZoom && c.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && c.off("pitch", this._rotateCompassArrow), c.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
        }
        _createButton(c, t) {
          const s = we("button", c, this._container);
          return s.type = "button", s.addEventListener("click", t), s;
        }
        _setButtonTitle(c, t) {
          if (!this._map)
            return;
          const s = this._map._getUIString(`NavigationControl.${t}`);
          c.setAttribute("aria-label", s), c.firstElementChild && c.firstElementChild.setAttribute("title", s);
        }
      }, GeolocateControl: class extends i.E {
        constructor(c = {}) {
          super();
          const t = navigator.geolocation;
          this.options = i.l({ geolocation: t }, wa, c), i.aP(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = rh(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
        }
        onAdd(c) {
          return this._map = c, this._container = we("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
        }
        _checkGeolocationSupport(c) {
          const t = (s = !!this.options.geolocation) => {
            this._supportsGeolocation = s, c(s);
          };
          this._supportsGeolocation !== void 0 ? c(this._supportsGeolocation) : navigator.permissions !== void 0 ? navigator.permissions.query({ name: "geolocation" }).then((s) => t(s.state !== "denied")).catch(() => t()) : t();
        }
        _isOutOfMapMaxBounds(c) {
          const t = this._map.getMaxBounds(), s = c.coords;
          return !!t && (s.longitude < t.getWest() || s.longitude > t.getEast() || s.latitude < t.getSouth() || s.latitude > t.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(c) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(c))
              return this._setErrorState(), this.fire(new i.z("outofmaxbounds", c)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = c, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(c), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(c), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("geolocate", c)), this._finish();
          }
        }
        _updateCamera(c) {
          const t = new i.bO(c.coords.longitude, c.coords.latitude), s = c.coords.accuracy, h = this._map.getBearing(), m = i.l({ bearing: h }, this.options.fitBoundsOptions);
          this._map.fitBounds(t.toBounds(s), m, { geolocateSource: !0 });
        }
        _updateMarker(c) {
          if (c) {
            const t = new i.bO(c.coords.longitude, c.coords.latitude);
            this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), this._accuracy = c.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const c = this._map.transform, t = i.bH(1, c._center.lat) * c.worldSize, s = Math.ceil(2 * this._accuracy * t);
          this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && typeof this._heading == "number" ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(c) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (c.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (c.code === 3 && this._noTimeout)
                  return;
                this._setErrorState();
              }
            this._watchState !== "OFF" && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new i.z("error", c)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(c) {
          if (this._map !== void 0) {
            if (this._container.addEventListener("contextmenu", (t) => t.preventDefault()), this._geolocateButton = we("button", "mapboxgl-ctrl-geolocate", this._container), we("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", c === !1) {
              i.w("Geolocation support is not available so the GeolocateControl will be disabled.");
              const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
            } else {
              const t = this._map._getUIString("GeolocateControl.FindMyLocation");
              this._geolocateButton.setAttribute("aria-label", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t);
            }
            this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = we("div", "mapboxgl-user-location"), this._dotElement.appendChild(we("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(we("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new ea({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = we("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ea({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t) => {
              t.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t.originalEvent && t.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new i.z("trackuserlocationend")));
            });
          }
        }
        _onDeviceOrientation(c) {
          this._userLocationDotMarker && (c.webkitCompassHeading ? this._heading = c.webkitCompassHeading : c.absolute === !0 && (this._heading = -1 * c.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return i.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new i.z("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new i.z("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new i.z("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
              this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let c;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (c = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = !0) : (c = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, c), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
          return !0;
        }
        _addDeviceOrientationListener() {
          const c = () => {
            "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
          };
          typeof DeviceMotionEvent < "u" && typeof DeviceMotionEvent.requestPermission == "function" ? DeviceOrientationEvent.requestPermission().then((t) => {
            t === "granted" && c();
          }).catch(console.error) : c();
        }
        _clearWatch() {
          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: fp, ScaleControl: class {
        constructor(c = {}) {
          this.options = i.l({}, fr, c), this._isNumberFormatSupported = function() {
            try {
              return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), !0;
            } catch {
              return !1;
            }
          }(), i.aP(["_update", "_setScale", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _update() {
          const c = this.options.maxWidth || 100, t = this._map, s = t._containerHeight / 2, h = t._containerWidth / 2 - c / 2, m = t.unproject([h, s]), g = t.unproject([h + c, s]), T = m.distanceTo(g);
          if (this.options.unit === "imperial") {
            const z = 3.2808 * T;
            z > 5280 ? this._setScale(c, z / 5280, "mile") : this._setScale(c, z, "foot");
          } else
            this.options.unit === "nautical" ? this._setScale(c, T / 1852, "nautical-mile") : T >= 1e3 ? this._setScale(c, T / 1e3, "kilometer") : this._setScale(c, T, "meter");
        }
        _setScale(c, t, s) {
          this._map._requestDomTask(() => {
            const h = function(g) {
              const T = Math.pow(10, `${Math.floor(g)}`.length - 1);
              let z = g / T;
              return z = z >= 10 ? 10 : z >= 5 ? 5 : z >= 3 ? 3 : z >= 2 ? 2 : z >= 1 ? 1 : function(R) {
                const F = Math.pow(10, Math.ceil(-Math.log(R) / Math.LN10));
                return Math.round(R * F) / F;
              }(z), T * z;
            }(t), m = h / t;
            this._container.innerHTML = this._isNumberFormatSupported && s !== "nautical-mile" ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: s }).format(h) : `${h}&nbsp;${Fr[s]}`, this._container.style.width = c * m + "px";
          });
        }
        onAdd(c) {
          return this._map = c, this._language = c.getLanguage(), this._container = we("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", c.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off("move", this._update), this._map = void 0;
        }
        _setLanguage(c) {
          this._language = c, this._update();
        }
        setUnit(c) {
          this.options.unit = c, this._update();
        }
      }, FullscreenControl: class {
        constructor(c = {}) {
          this._fullscreen = !1, c && c.container && (c.container instanceof HTMLElement ? this._container = c.container : i.w("Full screen control 'container' must be a DOM element.")), i.aP(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(c) {
          return this._map = c, this._container || (this._container = this._map.getContainer()), this._controlContainer = we("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", i.w("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const c = this._fullscreenButton = we("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          we("span", "mapboxgl-ctrl-icon", c).setAttribute("aria-hidden", "true"), c.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const c = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", c), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", c);
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends i.E {
        constructor(c) {
          super(), this.options = i.l(Object.create(Os), c), i.aP(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(c && c.className ? c.className.trim().split(/\s+/) : []);
        }
        addTo(c) {
          return this._map && this.remove(), this._map = c, this.options.closeOnClick && c.on("preclick", this._onClose), this.options.closeOnMove && c.on("move", this._onClose), c.on("remove", this.remove), this._update(), c._addPopup(this), this._focusFirstElement(), this._trackPointer ? (c.on("mousemove", this._onMouseEvent), c.on("mouseup", this._onMouseEvent), c._canvasContainer.classList.add("mapboxgl-track-pointer")) : c.on("move", this._update), this.fire(new i.z("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
          const c = this._map;
          return c && (c.off("move", this._update), c.off("move", this._onClose), c.off("preclick", this._onClose), c.off("click", this._onClose), c.off("remove", this.remove), c.off("mousemove", this._onMouseEvent), c.off("mouseup", this._onMouseEvent), c.off("drag", this._onMouseEvent), c._canvasContainer && c._canvasContainer.classList.remove("mapboxgl-track-pointer"), c._removePopup(this), this._map = void 0), this.fire(new i.z("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(c) {
          this._lngLat = i.bO.convert(c), this._pos = null, this._trackPointer = !1, this._update();
          const t = this._map;
          return t && (t.on("move", this._update), t.off("mousemove", this._onMouseEvent), t._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          this._trackPointer = !0, this._pos = null, this._update();
          const c = this._map;
          return c && (c.off("move", this._update), c.on("mousemove", this._onMouseEvent), c.on("drag", this._onMouseEvent), c._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(c) {
          return this.setDOMContent(document.createTextNode(c));
        }
        setHTML(c) {
          const t = document.createDocumentFragment(), s = document.createElement("body");
          let h;
          for (s.innerHTML = c; h = s.firstChild, h; )
            t.appendChild(h);
          return this.setDOMContent(t);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(c) {
          return this.options.maxWidth = c, this._update(), this;
        }
        setDOMContent(c) {
          let t = this._content;
          if (t)
            for (; t.hasChildNodes(); )
              t.firstChild && t.removeChild(t.firstChild);
          else
            t = this._content = we("div", "mapboxgl-popup-content", this._container || void 0);
          if (t.appendChild(c), this.options.closeButton) {
            const s = this._closeButton = we("button", "mapboxgl-popup-close-button", t);
            s.type = "button", s.setAttribute("aria-label", "Close popup"), s.setAttribute("aria-hidden", "true"), s.innerHTML = "&#215;", s.addEventListener("click", this._onClose);
          }
          return this._update(), this._focusFirstElement(), this;
        }
        addClassName(c) {
          return this._classList.add(c), this._updateClassList(), this;
        }
        removeClassName(c) {
          return this._classList.delete(c), this._updateClassList(), this;
        }
        setOffset(c) {
          return this.options.offset = c, this._update(), this;
        }
        toggleClassName(c) {
          let t;
          return this._classList.delete(c) ? t = !1 : (this._classList.add(c), t = !0), this._updateClassList(), t;
        }
        _onMouseEvent(c) {
          this._update(c.point);
        }
        _getAnchor(c) {
          if (this.options.anchor)
            return this.options.anchor;
          const t = this._map, s = this._container, h = this._pos;
          if (!t || !s || !h)
            return "bottom";
          const m = s.offsetWidth, g = s.offsetHeight, T = h.x < m / 2, z = h.x > t.transform.width - m / 2;
          if (h.y + c < g)
            return T ? "top-left" : z ? "top-right" : "top";
          if (h.y > t.transform.height - g) {
            if (T)
              return "bottom-left";
            if (z)
              return "bottom-right";
          }
          return T ? "left" : z ? "right" : "bottom";
        }
        _updateClassList() {
          const c = this._container;
          if (!c)
            return;
          const t = [...this._classList];
          t.push("mapboxgl-popup"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push("mapboxgl-popup-track-pointer"), c.className = t.join(" ");
        }
        _update(c) {
          const t = this._map, s = this._content;
          if (!t || !this._lngLat && !this._trackPointer || !s)
            return;
          let h = this._container;
          if (h || (h = this._container = we("div", "mapboxgl-popup", t.getContainer()), this._tip = we("div", "mapboxgl-popup-tip", h), h.appendChild(s)), this.options.maxWidth && h.style.maxWidth !== this.options.maxWidth && (h.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = pp(this._lngLat, this._pos, t.transform)), !this._trackPointer || c) {
            const m = this._pos = this._trackPointer && c instanceof i.P ? c : t.project(this._lngLat), g = Un(this.options.offset), T = this._anchor = this._getAnchor(g.y), z = Un(this.options.offset, T), R = m.add(z).round();
            t._requestDomTask(() => {
              this._container && T && (this._container.style.transform = `${ph[T]} translate(${R.x}px,${R.y}px)`);
            });
          }
          if (!this._marker && t._showingGlobe()) {
            const m = i.dH(t.transform, this._lngLat) ? 0 : 1;
            this._setOpacity(m);
          }
          this._updateClassList();
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const c = this._container.querySelector(mp);
          c && c.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(c) {
          this._container && (this._container.style.opacity = `${c}`), this._content && (this._content.style.pointerEvents = c ? "auto" : "none");
        }
      }, Marker: ea, Style: hr, LngLat: i.bO, LngLatBounds: i.az, Point: i.P, MercatorCoordinate: i.aa, FreeCameraOptions: Ba, Evented: i.E, config: i.e, prewarm: i.dM, clearPrewarmedResources: i.dN, get accessToken() {
        return i.e.ACCESS_TOKEN;
      }, set accessToken(c) {
        i.e.ACCESS_TOKEN = c;
      }, get baseApiUrl() {
        return i.e.API_URL;
      }, set baseApiUrl(c) {
        i.e.API_URL = c;
      }, get workerCount() {
        return i.dO.workerCount;
      }, set workerCount(c) {
        i.dO.workerCount = c;
      }, get maxParallelImageRequests() {
        return i.e.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(c) {
        i.e.MAX_PARALLEL_IMAGE_REQUESTS = c;
      }, clearStorage(c) {
        i.dP(c);
      }, get workerUrl() {
        return i.dQ.workerUrl;
      }, set workerUrl(c) {
        i.dQ.workerUrl = c;
      }, get workerClass() {
        return i.dQ.workerClass;
      }, set workerClass(c) {
        i.dQ.workerClass = c;
      }, get workerParams() {
        return i.dQ.workerParams;
      }, set workerParams(c) {
        i.dQ.workerParams = c;
      }, get dracoUrl() {
        return i.dR();
      }, set dracoUrl(c) {
        i.dS(c);
      }, get meshoptUrl() {
        return i.dT();
      }, set meshoptUrl(c) {
        i.dU(c);
      }, setNow: i.q.setNow, restoreNow: i.q.restoreNow };
    });
    var P = w;
    return P;
  });
})(lw);
var pC = lw.exports;
const Ph = /* @__PURE__ */ ow(pC);
class mC {
  constructor() {
    this.Bounds = [], this.EventSelectChart = null, this.CurrentLocationMarker = null;
  }
  init(a, f, y, w) {
    this.map = new Ph.Map({
      container: a,
      style: "mapbox://styles/mapbox/streets-v11",
      accessToken: "pk.eyJ1Ijoic2VjdXJjdWJlbWF4IiwiYSI6ImNsbW94MzRodjE4YjEya3BuM3liZXl6MXYifQ.db3c6nnAcFwFm5jD2NCg6w",
      // MapBoxApiKey ?? 
      center: [0, 0],
      zoom: 1,
      scrollZoom: y
    }), this.map.addControl(new Ph.NavigationControl()), this.map.addControl(new Ph.FullscreenControl()), this.map.on("style.load", () => {
      this.map.addSource("mapbox-dem", {
        type: "raster-dem",
        url: "mapbox://mapbox.mapbox-terrain-dem-v1",
        tileSize: 512,
        maxzoom: 14
      }), this.map.setTerrain({ source: "mapbox-dem", exaggeration: 1.5 });
    });
  }
  _addMarker(a, f, y) {
    const w = document.createElement("div"), b = 32, P = 32;
    return w.className = "marker", w.style.backgroundImage = `url(${f})`, w.style.width = `${b}px`, w.style.height = `${P}px`, w.style.backgroundSize = "100%", w.addEventListener("click", (i) => {
      y == null || y.call(this, i);
    }), new Ph.Marker().setLngLat([a[1], a[0]]).addTo(this.map);
  }
  AppPolylines(a, f, y, w, b) {
    this.Bounds = a.filter((P) => P != null), this.map.on("load", () => {
      const P = Nm.Utils.DividePolylinesPoints(a);
      if (this.map.addSource("route", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: P.map((i, O) => ({
            type: "Feature",
            properties: {
              color: O < f.length ? f[O] : f[f.length - 1]
            },
            geometry: {
              type: "LineString",
              coordinates: i.map((Z) => [Z[1], Z[0]])
            }
          }))
        }
      }), this.map.addLayer({
        id: "route",
        type: "line",
        source: "route",
        layout: {
          "line-join": "round",
          "line-cap": "round"
        },
        paint: {
          "line-color": ["get", "color"],
          "line-width": 3
        }
      }), (y == "" || y == null) && (y = "https://maps.google.com/mapfiles/kml/pal4/icon25.png"), this.CurrentLocationMarker = this._addMarker(a[0], y, (i) => {
      }), w != "") {
        let i = a[0];
        i != null && this._addMarker(i, w, null);
      }
      if (b != "" && a[a.length - 1] != null) {
        let i = a[a.length - 1];
        i != null && this._addMarker(i, b, null);
      }
      this.CenterMap();
    });
  }
  AddWaypoints(a, f) {
  }
  MoveMarkerToPosition(a, f) {
    var y;
    (y = this.CurrentLocationMarker) == null || y.setLngLat([a[1], a[0]]);
  }
  SetCurrentGPSPosition(a, f, y) {
  }
  CenterMap() {
    var a;
    try {
      if (this.Bounds && this.Bounds.length > 0) {
        let f = {
          minLat: Number.POSITIVE_INFINITY,
          maxLat: Number.NEGATIVE_INFINITY,
          minLng: Number.POSITIVE_INFINITY,
          maxLng: Number.NEGATIVE_INFINITY
        };
        this.Bounds.forEach((b) => {
          if (!Array.isArray(b) || b.length !== 2)
            throw new Error("Each coordinate must be an array with [latitude, longitude].");
          const [P, i] = b;
          f.minLat = Math.min(f.minLat, P), f.maxLat = Math.max(f.maxLat, P), f.minLng = Math.min(f.minLng, i), f.maxLng = Math.max(f.maxLng, i);
        });
        const y = new Ph.LngLat(f.minLng, f.minLat), w = new Ph.LngLat(f.maxLng, f.maxLat);
        (a = this.map) == null || a.fitBounds(new Ph.LngLatBounds(y, w), { padding: 20, animate: !1 });
      }
    } catch (f) {
      console.log(f);
    }
  }
  AddPhotos(a) {
  }
}
const _C = "1", gC = "2", yC = "3", xC = "4", vC = "5", bC = "6", wC = "5", TC = "4", SC = "3", MC = "2", EC = "1";
class CC {
  constructor(a) {
    this.map = null, this.myChart = null, this.params = a, this.init();
  }
  init() {
    var go, yo, xo, yr, Sr, io, Xs, Mr, mi;
    let {
      targetId: a,
      mapType: f,
      mapData: y,
      graphDist: w,
      graphEle: b,
      graphSpeed: P,
      graphHr: i,
      graphAtemp: O,
      graphCad: Z,
      graphGrade: Y,
      waypoints: J,
      unit: ae,
      unitspeed: ue,
      color1: Se,
      color2: we,
      color3: qe,
      color4: Ge,
      color5: lt,
      color6: Et,
      color7: ut,
      chartFrom1: bt,
      chartTo1: Vt,
      chartFrom2: pt,
      chartTo2: Gt,
      startIcon: ui,
      waypointIcon: kt,
      endIcon: At,
      currentIcon: Si,
      zoomOnScrollWheel: An,
      langs: hn,
      pluginUrl: Ht,
      usegpsposition: Mi,
      currentpositioncon: Ji,
      TFApiKey: fi
    } = this.params;
    var jt = [], ni = { suf: "", dec: 0 }, Gi = { suf: "", dec: 0 }, an = { suf: "", dec: 0 }, qt = { suf: "%", dec: 1 }, ln = { suf: "", dec: 0 }, Di = { suf: "", dec: 0 }, xi = document.getElementById("wpgpxmaps_" + a), Cs = document.getElementById("map_" + a), xs = document.getElementById("chart_" + a);
    if (document.getElementById("report_" + a), document.getElementById("wpgpxmaps_" + a + "_osm_footer"), Cs == null)
      return;
    let Is = this;
    this.params.MapBoxApiKey && this.params.MapBoxApiKey.length > 20 ? this.map = new mC() : this.map = new fC(), this.map.init(
      Cs,
      f,
      An == "true",
      fi
    ), this.map.EventSelectChart = function(On) {
      var No, Ke;
      if (Is.myChart) {
        for (var Vn = On[0], Zi = On[1], Jn = Is.getClosestIndex(y, Vn, Zi), Fn = [], Ls = Is.myChart._metasets.length, zs = 0; zs < Ls; zs++)
          Fn.push(Is.myChart._metasets[zs].data[Jn]);
        if (Fn.length > 0) {
          let re = (No = Is.myChart.tooltip) == null ? void 0 : No.getActiveElements();
          (re == null || re.length == 0) && ((Ke = Is.myChart.tooltip) == null || Ke.setActiveElements([{
            datasetIndex: 0,
            index: Jn
          }], {
            x: Fn[0].x,
            y: Fn[0].y
          })), Is.myChart.tooltip.setActiveElements(Fn), Is.myChart.draw();
        }
      }
    }, Mi == "true" && navigator.geolocation && navigator.geolocation.watchPosition(
      function(On) {
        On.coords.accuracy / 2;
        var Vn = [On.coords.latitude, On.coords.longitude];
        this.map.SetCurrentGPSPosition([Vn[0], Vn[1]], Ji, hn);
      },
      function(On) {
      },
      {
        enableHighAccuracy: !1,
        timeout: 5e3,
        maximumAge: 0
      }
    ), J != null && J.length > 0 && this.map.AddWaypoints(J, kt);
    let De = document.getElementById("ngimages_" + a);
    De == null || De.setAttribute("style", "display:block;position:absolute;left:-50000px");
    var Vs = De == null ? void 0 : De.querySelectorAll("span");
    if (Vs && Vs.length > 0) {
      for (var Us = [], Zr = 0; Zr < Vs.length; Zr++) {
        var Mt = Vs[Zr], ir = Mt.children[0], $n = [
          Number(Mt.getAttribute("lat")),
          Number(Mt.getAttribute("lon"))
        ];
        this.map.Bounds.push($n), Us.push({
          lat: $n[0],
          lng: $n[1],
          name: ir.children[0].getAttribute("alt"),
          url: ir.children[0].getAttribute("src"),
          thumbnail: ir.children[0].getAttribute("src")
        });
      }
      Us.length > 0 && this.map.AddPhotos(Us);
    }
    y && this.map.AppPolylines(y, Se, Si, ui, At);
    var Ws = this.map;
    let vi = null, kn = xi == null ? void 0 : xi.parentElement;
    for (; kn != null; ) {
      if (kn.classList.contains("wordpress-post-tabs") && kn.classList.contains("tab-pane")) {
        vi = kn;
        break;
      }
      kn = kn.parentElement;
    }
    if (vi) {
      var $s = function(On) {
        setTimeout(function(Vn) {
          var Zi;
          (Zi = Ws.map) == null || Zi.invalidateSize(), Ws.CenterMap();
        }, 300);
      };
      (go = document.querySelector(".wpsm_nav-tabs a")) == null || go.addEventListener("click", $s, !1), (yo = vi.querySelector("div > ul > li > a")) == null || yo.addEventListener("click", $s, !1);
    }
    var Hr = xs == null ? void 0 : xs.style.height;
    if (w && (b || P || i || O || Z) && Hr != "0px") {
      w.length, _C == ae ? (Gi = { suf: "mi", dec: 1 }, an = { suf: "ft", dec: 0 }) : gC == ae ? (Gi = { suf: "km", dec: 1 }, an = { suf: "m", dec: 2 }) : yC == ae ? (Gi = { suf: "NM", dec: 1 }, an = { suf: "m", dec: 0 }) : xC == ae ? (Gi = { suf: "mi", dec: 1 }, an = { suf: "m", dec: 0 }) : vC == ae ? (Gi = { suf: "NM", dec: 1 }, an = { suf: "ft", dec: 0 }) : (Gi = { suf: "m", dec: 0 }, an = { suf: "m", dec: 0 });
      var qr = 1111.1, Wr = qr.toLocaleString(), si = Wr.length;
      Wr.substring(si - 2, si - 1), Wr.substring(1, 2), Ol.register(...hC);
      var fs = {
        type: "line",
        data: {
          datasets: []
        },
        //borderWidth: 1,
        options: {
          animation: {
            // duration: 0,
            // general animation time
          },
          hover: {
            // animationDuration: 0,
            // duration of animations when hovering an item
          },
          // responsiveAnimationDuration: 0,
          // animation duration after a resize
          //customLine: {
          //	color: 'gray'
          //},
          scales: {
            xAxe: {
              type: "linear",
              min: 0,
              max: w[w.length - 1],
              ticks: {
                /* Include a dollar sign in the ticks. */
                callback: function(Vn, Zi, Jn) {
                  return parseFloat(Vn + "").toFixed(Gi.dec) + Gi.suf;
                }
              }
            }
          },
          plugins: {
            tooltip: {
              position: "average",
              mode: "index",
              intersect: !1,
              callbacks: {
                title: function(Vn) {
                  var Zi = jt[0].label_x, Jn = Vn[0].element.x, Fn = Zi.dec, Ls = Zi.suf;
                  return Jn.toFixed(Fn) + Ls;
                },
                label: function(Vn) {
                  var Zi = Vn.label || "", Jn = jt[Vn.datasetIndex].label_y, Fn = Jn.dec, Ls = Jn.suf, zs = Vn.element.y;
                  return Zi && (Zi += ": "), Zi += zs.toFixed(Fn) + Ls, Zi;
                },
                footer: function(Vn) {
                  var Zi = Vn[0].dataIndex, Jn = Nm.Utils.GetItemFromArray(y, Zi);
                  Jn && Ws.MoveMarkerToPosition(Jn, !1);
                }
              }
            }
            /*
            							decimation: {
            								beforeEvent: function (chart, args, options) {
            									if ((args.event.type === 'mousemove' && args.event.x)
            										&& (args.event.x >= chart.chartArea.left)
            										&& (args.event.x <= chart.chartArea.right)
            									) {
            										chart.options.customLine.x = args.event.x;
            									}
            								},
            								afterDraw: function (chart, args, opt) {
            									var ctx = chart.ctx;
            									var chartArea = chart.chartArea;
            									var x = chart.options.customLine.x;
            									if (!isNaN(x)) {
            										ctx.save();
            										ctx.strokeStyle = chart.options.customLine.color;
            										ctx.moveTo(chart.options.customLine.x, chartArea.bottom);
            										ctx.lineTo(chart.options.customLine.x, chartArea.top);
            										ctx.stroke();
            										ctx.restore();
            									}
            								}
            
            							}						
            						*/
          }
        }
        //labels: graphDist
      };
      let On = 1;
      if (b && b.length > 0) {
        var zn = this.mergeArrayForChart(w, b);
        let Vn, Zi;
        bt != "" ? Vn = parseFloat(bt) : Vn = zn.Min, Vt != "" ? Zi = parseFloat(Vt) : Zi = zn.Max;
        var Rn = "yaxis" + On++, Pn = {
          type: "linear",
          max: Zi,
          min: Vn,
          ticks: {
            callback(Jn, Fn, Ls) {
              return parseFloat(Jn + "").toFixed(an.dec) + an.suf;
            }
          }
        };
        ((xo = fs.options) == null ? void 0 : xo.scales)[Rn] = Pn, jt.push({ label_x: Gi, label_y: an }), fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.altitude, zn.Items, we, Rn));
      }
      if (P && P.length > 0) {
        bC == ue ? ni = { suf: "min/100m", dec: 2 } : wC == ue ? ni = { suf: "knots", dec: 2 } : TC == ue ? ni = { suf: "min/mi", dec: 2 } : SC == ue ? ni = { suf: "min/km", dec: 2 } : MC == ue ? ni = { suf: "mi/h", dec: 0 } : EC == ue ? ni = { suf: "km/h", dec: 0 } : ni = { suf: "m/s", dec: 0 };
        var zn = this.mergeArrayForChart(w, P);
        let Zi = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(ni.dec) + ni.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        };
        pt != "" ? Zi.min = parseFloat(pt) : Zi.min = zn.Min, Gt != "" ? Zi.max = parseFloat(Gt) : Zi.max = zn.Max, jt.push({ label_x: jt[0].label_x, label_y: ni });
        var Rn = "yaxis" + On++;
        ((yr = fs.options) == null ? void 0 : yr.scales)[Rn] = Zi, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.speed, zn.Items, qe, Rn));
      }
      if (i && i.length > 0) {
        var zn = this.mergeArrayForChart(w, i), Pn = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(ln.dec) + ln.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((Sr = fs.options) == null ? void 0 : Sr.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.heartRate, zn.Items, Ge, Rn)), jt.push({ label_x: jt[0].label_x, label_y: ln });
      }
      if (O && O.length > 0) {
        var zn = this.mergeArrayForChart(w, O), Pn = {
          type: "linear",
          ticks: {
            /* Include a dollar sign in the ticks. */
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(1) + "°C";
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((io = fs.options) == null ? void 0 : io.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.atemp, zn.Items, ut, Rn)), jt.push({ label_x: jt[0].label_x, label_y: { suf: "°C", dec: 1 } });
      }
      if (Z && Z.length > 0) {
        var zn = this.mergeArrayForChart(w, Z, !0), Pn = {
          type: "linear",
          ticks: {
            // Include a dollar sign in the ticks.
            callback(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(Di.dec) + Di.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        }, Rn = "yaxis" + On++;
        ((Xs = fs.options) == null ? void 0 : Xs.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.cadence, zn.Items, lt, Rn)), jt.push({ label_x: jt[0].label_x, label_y: Di });
      }
      if (Y && Y.length > 0) {
        var zn = this.mergeArrayForChart(w, Y), Pn = {
          type: "linear",
          ticks: {
            // Include a dollar sign in the ticks.
            callback: function(Fn, Ls, zs) {
              return parseFloat(Fn + "").toFixed(qt.dec) + qt.suf;
            }
          },
          position: "right"
          //scalePositionLeft: false,
        };
        jt.push({ label_x: jt[0].label_x, label_y: qt });
        var Rn = "yaxis" + On++;
        ((Mr = fs.options) == null ? void 0 : Mr.scales)[Rn] = Pn, fs.data.datasets.push(this.wpgpxmapsGetDataset(hn.grade, zn.Items, Et, Rn));
      }
      var js = (mi = document.getElementById("myChart_" + a)) == null ? void 0 : mi.getContext("2d");
      js && (this.myChart = new Ol(js, fs));
    } else
      xs == null || xs.style.setProperty("display", "none");
    return this;
  }
  mergeArrayForChart(a, f, y) {
    const w = a.length, b = new Array(w);
    let P = 1e4, i = -1e4;
    for (let O = 0; O < w; O++)
      if (a[O] != null) {
        let Z = f[O];
        y === !0 && Z === 0 && (Z = null), b[O] = {
          x: a[O],
          y: Z
        }, Z > i && (i = Z), Z < P && (P = Z);
      }
    return {
      Items: b,
      Min: P,
      Max: i
    };
  }
  wpgpxmapsGetDataset(a, f, y, w) {
    return {
      label: a,
      data: f,
      borderColor: y,
      backgroundColor: this.hexToRgbA(y, 0.3),
      pointRadius: 0,
      borderWidth: 1,
      pointHoverRadius: 1,
      yAxisID: w
    };
  }
  hexToRgbA(a, f) {
    let y;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(a))
      return y = a.substring(1).split(""), y.length == 3 && (y = [y[0], y[0], y[1], y[1], y[2], y[2]]), y = "0x" + y.join(""), "rgba(" + [y >> 16 & 255, y >> 8 & 255, y & 255].join(",") + "," + f + ")";
    throw new Error("Bad Hex");
  }
  getItemFromArray(a, f) {
    try {
      return a[f];
    } catch {
      return [0, 0];
    }
  }
  getClosestIndex(a, f, y) {
    let w = 1e4, b = 0;
    for (let P = 0; P < a.length; P++) {
      if (a[P] === null)
        continue;
      const i = this.wpgpxmapsDist(a[P][0], a[P][1], f, y);
      i < w && (b = P, w = i);
    }
    return b;
  }
  getClosestImage(a, f, y) {
    let w = 1e4, b;
    const P = document.getElementById("ngimages_" + y);
    if (P == null)
      return;
    const i = P.getElementsByTagName("span");
    for (let O = 0; O < i.length; O++) {
      let Z = i[O].getAttribute("lat"), Y = i[O].getAttribute("lon");
      if (Z == null || Y == null)
        return;
      Z = Z.replace(",", "."), Y = Y.replace(",", ".");
      const J = this.wpgpxmapsDist(parseFloat(Z), parseFloat(Y), a, f);
      J < w && (b = i[O], w = J);
    }
    return b;
  }
  isNumeric(a) {
    return /^-{0,1}\d*\.{0,1}\d+$/.test(a);
  }
  wpgpxmapsDist(a, f, y, w) {
    const b = y - a, P = w - f;
    return Math.sqrt(b * b + P * P);
  }
}
export {
  CC as WPGPXMaps
};
//# sourceMappingURL=WP-GPX-Maps.es.js.map
